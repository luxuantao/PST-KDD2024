<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Compiling Deep Learning Models for Custom Hardware Accelerators</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andre</forename><surname>Xian</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Purdue University Department</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ming</forename><surname>Chang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Purdue University Department</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Aliasger</forename><surname>Zaidy</surname></persName>
							<email>azaidy@purdue.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Purdue University Department</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vinayak</forename><surname>Gokhale</surname></persName>
							<email>vgokhale@purdue.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Electrical Engineering</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eugenio</forename><surname>Culurciello</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Purdue University Department</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Compiling Deep Learning Models for Custom Hardware Accelerators</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Compiler</term>
					<term>FPGA</term>
					<term>Deep Neural Networks</term>
					<term>Hardware accelerator</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Convolutional neural networks (CNNs) are the core of most state-of-the-art deep learning algorithms specialized for object detection and classification. CNNs are both computationally complex and embarrassingly parallel. Two properties that leave room for potential software and hardware optimizations for embedded systems. Given a programmable hardware accelerator with a CNN oriented custom instructions set, the compiler's task is to exploit the hardware's full potential, while abiding with the hardware constraints and maintaining generality to run different CNN models with varying workload properties. Snowflake is an efficient and scalable hardware accelerator implemented on programmable logic devices. It implements a control pipeline for a custom instruction set. The goal of this paper is to present Snowflake's compiler that generates machine level instructions from Torch7 model description files. The main software design points explored in this work are: model structure parsing, CNN workload breakdown, loop rearrangement for memory bandwidth optimizations and memory access balancing. The performance achieved by compiler generated instructions matches against hand optimized code for convolution layers. Generated instructions also efficiently execute AlexNet and ResNet18 inference on Snowflake. Snowflake with 256 processing units was synthesized on Xilinx's Zynq XC7Z045 FPGA. At 250 MHz, AlexNet achieved in 93.6 frames/s and 1.2 GB/s of off-chip memory bandwidth, and 21.4 frames/s and 2.2 GB/s for ResNet18. Total on-chip power is 5 W.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The deep learning field has grown in popularity in recent years with the success of back-propagation based models. For the past few years, CNNs have consecutively achieved the state-of-the-art accuracy for classification tasks <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b8">9]</ref> on large image datasets <ref type="bibr" target="#b19">[20]</ref>. Those models are embarrassingly parallel, but exploiting parallelism for all existent models is a design problem with room for software and hardware exploration to achieve better performance per power. Snowflake <ref type="bibr" target="#b6">[7]</ref> is a scalable and programmable, low-power accelerator for deep learning with a RISC based custom instruction set. Snowflake architecture was designed to provide high performance, given optimal sequence of instructions. But, manually crafting assembly like instructions can be cumbersome and error prone specially when a model is composed of several layers like in ResNet <ref type="bibr" target="#b8">[9]</ref>. Even if one was patient enough to manually write code for some of state-ofthe-art deep learning models, further customization on both sides: on the hardware and software would require modifying thousands of lines of assembly code, preventing experimentation on custom system for deep learning.</p><p>In this work, we present a compiler, which is responsible for generating instructions and managing data in the main memory. We designed a generic software structure to go from high level model representation from Torch7 <ref type="bibr" target="#b3">[4]</ref> down to an instruction stream that runs Snowflake. The main contributions of this work are:</p><p>• A software framework to generate custom instructions for CNN targeted hardware accelerator.</p><p>• Deciding whether to send maps data multiple times per set of kernels or send kernels multiple times per set of maps data for optimal bandwidth usage.</p><p>• Communication load balancing to better utilize available memory bandwidth.</p><p>Snowflake was implemented on Xilinx's Zynq XC7Z045 FPGA <ref type="bibr" target="#b23">[24]</ref>. The system was benchmarked with AlexNet and ResNet18 <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b8">9]</ref> pre-trained models. At 250 MHz, AlexNet arXiv:1708.00117v1 [cs.DC] 1 Aug 2017 achieved in 93.6 frames/s and 1.2 GB/s of off-chip memory bandwidth, and 21.4 frames/s and 2.2 GB/s for ResNet18. The following sections present background and related work, overview of Snowflake hardware architecture, overview of instruction set, details of compiler implementation and the obtained results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND RELATED WORK</head><p>Before designing a compiler for custom deep learning accelerators, lets briefly go through commonly used layers in CNN models that Snowball will be targeting in this paper:</p><p>Spatial Convolution (CONV) is a 3D convolution of an input volume with a group of 3D kernels that result in extracted features from the input. Each 3D kernel is associated with a bias value. Number channels is the z-axis of input volume. Input volume is called maps and a slice of it is a map. A window is the size of one kernel convolved with part of input volume. Operations in a compute window are independent, hence it is well suited to multi-core processors: GPUs <ref type="bibr" target="#b20">[21]</ref> and other designs using ASIC <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref> and FPGAs <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>Activation unit is a non-linear function that some layer's outputs go through. Some examples are: rectified linear unit (ReLU), tanh and sigmoid. In this work, we only use ReLU.</p><p>Max pooling (Maxpool) is a down-sampling technique to achieve data invariance and to compress feature representation. Max pooling is element-wise comparison and its result is the highest value in a processing window.</p><p>Average pooling (Avgpool) is similar to Max pooling, but instead of getting the highest value in a window, it averages out its values. Average pooling can be implemented as a CONV with a single weight value of inverse of window size. Multiplying and accumulating all values in a window with this weight gives the average value of a window.</p><p>Residual addition or bypass is used in ResNet models <ref type="bibr" target="#b8">[9]</ref>. The output values of a CONV are element-wise added with a previous layer's input. In hardware, we want to add those bypass values as output results are being produced by a CONV layer to save communication cost. Thus we need to keep track of previous input layers and to conditionally issue an extra instruction.</p><p>Fully connected (FC) layers are used to map the features into a classification vector that has the "final answer" of the network and it is usually the last layer of a CNN model. FC layer is a data movement intensive operation because it provides limited data reuse. Thus, memory bandwidth is a bottleneck for running FC layers. Weight compression and weight pruning based on network sparsity are techniques that lower memory bandwidth requirement for this type of workload <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>[5] presents a compiler for a custom CNN accelerator using Torch5 models. Their approach is to map Torch5 models into a set of pre-defined sequence of control signals for DMA transfers and processing units. Custom hardware and instruction generation software was developed for Caffe <ref type="bibr" target="#b10">[11]</ref> in <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b0">1]</ref>. Snowball is the first to generate to custom instructions for hardware accelerator from Torch7 <ref type="bibr" target="#b3">[4]</ref> or Pytorch models.</p><p>The system in <ref type="bibr" target="#b24">[25]</ref> maps FC layers and CONV layers into a uniformed control representation: input or weight major processing. This work also uses uniform representation, but with a finer granularity defined as trace, which is any contiguous sequence of multiply and accumulate. This allows finer hardware and algorithmic optimizations.</p><p>Memory transfer friendly computation tiling for CNN accelerators was explored in <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. In <ref type="bibr" target="#b0">[1]</ref>, block tiling with xy axis ordering was used. They store tiles with extra overlap regions, called augmented-tiles, in DRAM to avoid multiple DMA transactions. Snowball also stores overlapped regions but it tiles at the granularity of row strips with channel major ordering to lower overlapped data replication. This lowers the required memory bandwidth.</p><p>Other domain-specific instructions set for CNN were presented in <ref type="bibr" target="#b14">[15]</ref>, can be added into Snowball, because they also use vector compute instructions and scratchpad on-chip memory loads instructions. The intermediate representation and the techniques presented can be also be integrated into conventional frameworks <ref type="bibr" target="#b13">[14]</ref>, which is left for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SNOWFLAKE HARDWARE OVERVIEW</head><p>Snowflake was presented in <ref type="bibr" target="#b6">[7]</ref>. This section summarizes the main hardware concepts that will be needed to develop a compiler. For readers' convenience Snowflake's diagram is shown in figure <ref type="figure" target="#fig_0">1</ref>.</p><p>The main building block of Snowflake's convolution engine are 16 bit multiply and accumulate units (MACs). A vector MAC (vMAC) is comprised of 16 MACs, that process 256 bits in one cycle. A compute unit (CU) is composed of 4 vMACs. Each vMAC has a private kernel scratchpad buffer (WBuf) and every vMAC in a CU shares the input data through the maps scratchpad buffer (MBuf). Data transfer time is overlapped by MAC compute time by using double buffer strategy.</p><p>Numerous CUs can be grouped into compute clusters. A compute cluster has a control unit, which is a RISC based pipeline. There are 4 load/store units that access the host main memory through DMA using AXI protocol. Vector comparator units (Pool Unit) are used for max-pool operations. RISC based instructions are loaded into the instruction cache (I$). The synthesized Snowflake was aimed for embedded system workloads, thus only one cluster with 4 CUs was instantiated. Each maps bank has 64 KB and each vMACs weight buffer is 8 KB. Instruction cache is 4 KB. Two ARM Cortex-A9 CPUs function as the host processor for the Snowflake implementation. Snowflake is clocked at 250 MHz and the ARM CPUs are at 666 MHz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Control pipeline</head><p>The control pipeline provides the CUs control signals given a stream of instructions from the instruction cache. It is a pipeline with 5 stages: fetch, decode, dispatch, execute and register writeback.</p><p>In the fetch stage, instructions are read from the instruction cache. The instructions are 32 bit. The decode stage turns fetched instructions into signals for operation modes, sign extends immediate values and gives addresses to access the register file. Decode stage also performs true dependency or read-after-write (RAW) hazards detection. RAW causes decode stalls, which is a pipeline stall but not necessarily a CU stall. The dispatch stage is responsible for identifying the resources needed for the current instruction and issuing register file read. Snowflake has 32 32 bit registers. If the decoded instruction is a vector operation, then CUs receive signals to fetch data and start processing a vector. Scalar computations are implemented in execute stage. The execute stage gets the dispatch signals and starts the compute On the left, a vMAC is a group of MAC units. In the center, a CU is composed of a group of vMACs with data buffers. In the right, a group of CUs forms a compute cluster that shares the control unit and load/store units. resources for a scalar operation. Scalar unit is composed of multiplier, adder and comparator. Previous stages are single cycle latency, whereas the execute stage is 2 cycle. Finally, the register write-back stage writes scalar results to the register file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CUSTOM INSTRUCTION SET</head><p>Snowflake's instruction set contains 13 instructions: MOV, MOVI, ADD, ADDI, MUL, MULI, MAC, MAX, VMOV, BLE, BGT, BEQ and LD. The 32 bit instructions are grouped into four categories: data movement, compute, flow control and memory access. Most instructions have in common four properties: 4 bit operand code, 1 bit mode select, 5 bit register selects (destination and two source registers) and a immediate field.</p><p>Data movement: Instruction MOVI moves a 23 bit immediate value into a register. MOV moves data between registers with a optional 5 bit left shift. VMOV is a vector move from buffer into compute units. It fetches a buffer block and load it into an operand register of a compute unit defined by select. VMOV is used to load the CONV/FC layer's bias into the MACs or to load the bypass values in residual add for ResNet.</p><p>Compute: ADD is a simple register to register add and ADDI is register with immediate add. MUL and MULI are register to register and register to immediate multiply, respectively. The vector compute units are controlled by MAC/MAX instructions. MAC multiplies and accumulates from contiguous sequence of data (trace) in maps and weights buffers. MAX is another vector instruction that has similar behavior to MAC. It performs comparisons with a retained previous vector. After a vector instruction finishes, a store to buffer or store to main memory is issued, thus there is not an explicit store instruction.</p><p>Snowflake's MAC instruction has two modes of operations: cooperative (COOP) and independent (INDP). In COOP mode, all MACs in one vMAC work together to produce one value of the output map. Each MAC processes a different channel of one kernel, and the results of all 16 MACs are added together by an extra adder called gather adder to produce one value. In independent mode, all MACs in one vMAC work independently on different kernels and map values are broadcast to produce 16 different output map values. More details on custom instructions are presented in <ref type="bibr" target="#b6">[7]</ref>.</p><p>Flow control: BLE, BEQ, BGT are branch instructions that compare the value at Rs1 to the value at Rs2. The immediate is the PC offset when the condition is true. Branches take 4 cycles to go through the pipeline, thus it leaves 4 branch delay slots to be filled with instructions. Only one pair of true RAW dependent instructions is allowed in the branch delay slots.</p><p>Memory access: LD instruction loads data from main memory to one of Snowflake's buffers. Snowflake can have multiple load units that can start independent load streams, within the off-chip memory bandwidth constraints. LD have select modes that allow a processing choice of weights broadcast and different maps, or maps broadcast with different weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SNOWBALL</head><p>Given the custom hardware constraints, the compiler is responsible to orchestrate the hardware for all sorts of layers. How to load balance the communication ports for better bandwidth utilization, how to partition maps and kernels to fit in on-chip buffers, how to issue compute and load instructions without stalling and how to balance between loops and unrolled instructions are some software design decisions.</p><p>The compiler performs three major tasks: parse high level representation of a model, instruction generation and instruction deployment into hardware. Each task has steps that are described in following subsections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Model parsing</head><p>In this task, the start point is a model representation from Torch7, and the end point is a data structure that contains all the information to easily generate Snowflake instructions. There are 5 steps to reach our goal.</p><p>Thnets <ref type="foot" target="#foot_0">1</ref> is an open-source library that provides means to read a Torch7 model representation file and to convert it into a C data structure. Using Thnets' functions, step 1 loads the parameters of each layer in the model into a layer object. This step scans through all layers and ignores nonsequential inter-layer relations that happens in parallel layer paths. The layer objects are serialized into a doubly linked list. Snowflake will process each element in the list in sequence.</p><p>In some models, such as GoogLeNet <ref type="bibr" target="#b21">[22]</ref> and ResNet <ref type="bibr" target="#b8">[9]</ref>, not all the layers are sequential. Some layers share their input and output, thus some layers in the list are labeled according to their parallel path.</p><p>Step 2 scans the model to get the inter-layer relations, and creates a dependency label for each layer object. This label indicates whether the layer is only connected to its previous and next layers or not. This label translates into how each layer share their maps data in pre-allocated main memory regions.</p><p>Step 3 processes each layer's information and its neighboring layers to decide how to decompose and generate instructions for different layers. Snowflake hardware parameter object is globally shared among functions to create hardware dependent structures: maps tile, kernel tile and load objects. The main hardware constraints are:</p><p>• Instruction cache size: Snowflake instruction cache is double banked with 512 instructions per bank. But branching across instruction banks is not permitted. This affects how loops are broken down.</p><p>• Data buffer size: this defines how to decompose the maps and weights into tiles. It also affects the required memory bandwidth, since smaller tiles means more overlapped data is loaded more frequently.</p><p>• Memory bandwidth: computation stalls happen when required data has not arrived into the buffer, which is caused by the memory bandwidth constraint. It affects whether to loop kernels or maps. This will be explained in section 6.2.</p><p>• Instruction latency: vector instructions require variable latency to produce a result. Within these cycles we want to hide all other necessary operations: loop control, conditional branches, buffer address increment and load instructions. Another reason why a CU can stall is because there was not enough MAC/MAX instructions issued in sequence, not leaving enough cycles to overlap with bookkeeping instructions.</p><p>Based on these constraints and the layer parameters, the compiler sets decision variables that chooses mode (COOP or INDP) to use, chooses loop breakdown based on instruction cache size, sets tile size limit based on data buffer size, chooses whether is better to fix map data and loop through kernels or vice-versa based on memory bandwidth constraint.</p><p>Step 4 breaks down the layers' maps and weights data into tiles that fits into the data buffer. The maps are decomposed in tiles with output row granularity, meaning that each tile produces output row(s). Weights are decomposed in tiles with single kernel granularity. Single kernel size is input channels times window size. Based on the decision made in step 2 and the neighboring layers, the tiles can have different data sizes. For instance, if we broadcast weights, then each CU works on different map tiles and the maps need to be decomposed such that all CUs will have the same amount of work. Inevitably, some remaining tiles won't be big enough to share among all CUs. Then some CUs must be disabled. Another example is in the context of ResNet where a CONV followed by a bypass needs two input maps: one for the CONV and one for the bypass. This special CONV needs to use both maps buffer banks simultaneously. Double buffering is done by using different buffer regions.</p><p>After creating a list of tiles to process, each element of the list will create operation lists in step 5. For each tile, there are two major operations: load and compute. A load list carries information necessary for a load instruction: stream length, memory address and buffer address. Each load object is associated with a different tile. The load list is created taking into account subsequent tiles loads, so that Snowflake can process a tile while loading data for the next one.</p><p>Compute objects contain information about a set of vector compute operations in a window, the number repetition in x and y directions and x and y offsets. This allows grouping of striding windows with same window size into one object. For example, multiple compute objects are needed for CONVs with padding, whereas a single object suffices in a CONV without padding. Compute objects will be translated into nested loops of MAC/MAXP instructions. The loop boundaries are the repeat variable and the vector instruction read buffer address is incremented by the offset variable. The compute object also has an extension with variables for VMOV if the layer is a CONV with bypass.</p><p>An example of Snowflake's data structure is shown in figure 2. A layer object can be one of the layer types: CONV, Maxpool, Avgpool, FC and Residual add. A layer has two lists of tiles: one for kernel and one for maps. Each tile object can instantiate a list of windows and a list of loads. A kernel tile does not have window list because compute operations are defined by maps tiles. Load list is in the tile list that is not being repeated in a loop. In the example shown in figure <ref type="figure" target="#fig_1">2</ref>, all kernels are looped through each maps tile. Kernel tile object contains repeat variable that defines the kernel loop boundaries. Hence, there is one kernel tile object. Kernel loads are implicit in a repeating tile object parameters, thus there is not a load list in the kernel tile. If maps are being repeated in loop for each different kernel tile, then kernel tile objects have load list and maps wont.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Instruction generation</head><p>After the model parsing task completes, the compiler goes through the lists and create instructions accordingly. Each tile object creates a block of instructions that will be concatenated with other tile objects instructions. The compiler inserts load for the following instruction cache bank at the beginning of each instruction block and inserts a jump to next instruction bank at the end to allow instruction double buffering. Hence, before generating instructions, we need to predict how many instructions are needed for a tile and check if it fits into the instruction cache constraint, so that we can correctly insert instruction loads and jumps. The prediction step passes through all objects and creates a temporary instruction block for each tile. If the predicted number of instruction in a block is larger than instruction cache bank size, then different instruction generation strategy must be used for that tile. After an instruction count profile for each tile is generated, the program knows where it can safely insert an instruction load for next bank. Then the permanent instruction stream is created.</p><p>Most of the instruction stream structure was sketched in the data structure as a result from model parsing in section 5.1. There are three main goals that instructions blocks need to accomplish:</p><p>• Initialization or register reset: the first tile of the model needs to populate all buffers in Snowflake creating a initialization latency. The following tiles needs to reset some loop control registers and set the reserved registers to the correct output locations.</p><p>• Compute data: each tile has their compute list, which defines a maximum of 3 nested loops. The inner loop is to accumulate traces, the second loop is stride along x-axis and the outer loop is stride along y-axis. Respectively, the loop limits are defined by kernel height, repeat x variable and repeat y variable.</p><p>• Load data: buffers needs to be updated for each compute tile, so that the following compute section can proceed without stalling for data. Both weights buffer and maps buffer loads need to be inserted in between compute operations, so that data coherence is maintained.</p><p>Figure <ref type="figure">3</ref> shows an example of instructions for a CONV tile, where T denotes trace loop, X x-axis loop, Y y-axis loop and K kernel loop (Kloop). The compiler first generates instructions for the initial map and weight buffer loads with the parameters in the first load object. Then it creates a kernel loop based on the kernel tile object. If the map tile window objects have non-unity repeat Y then a Y loop is created. Inside Y loop, T and X loops are created depending on the window objects variables. The load for the next tile, which is the second load MBuf object, is inserted in the X loop. The load insertion is needed because the compiler needs to guarantee that previously issued vector instructions have finished using a buffer bank before issuing new data load to that buffer bank. One way is to issue 16 vector instructions that will fill the trace buffer with new vector instructions, which guarantees that there no old vector instructions pending.</p><p>Depending on the CONV case, some of the loops are removed. For example, 1 × 1 CONVs don't have trace loop. Depending on bandwidth constraint, map and kernel tile objects can be generated, such that the kernel loop can become map loop, which means maps are sent multiple times for one tile of kernel.</p><p>Window objects can be broken down into multiple loops, which is based on the instruction latency versus instruction size trade-off. Snowball can only put limited amount of bookkeeping work in between two consecutive vector instructions. If those operations takes on average more cycles than MAC/MAX latency then CUs would stall because there is not enough MAC/MAX instruction being issued in sequence. A CONV with higher MAC latency allows more freedom to add flow control instructions, making the instruction stream more generic and with fewer instructions. On the other hand, 1×1 CONVs have lower MAC latency, which restricts the number of bookkeeping instructions that can be overlapped with the MAC instruction's latency. For example, if a MAC takes 16 cycles to finish, then having 20 instructions (loads, branches and other bookkeeping) in between MAC instructions will stall the CUs. In this case, breaking the loops or full loop unrolling will reduce the amount of bookkeeping instructions between consecutive instructions. But this increases the instruction count. One extreme is that all loops are completely unrolled.</p><p>Window objects also have the buffer address of bias value associated with each output map produced by a kernel, so a VMOV is needed before each Kloop iteration. For a residual add, a VMOV for each write-back MAC instruction is necessary because output value is added with a bypass value. Note that only the last MAC instruction of a trace loop is a write-back MAC instruction. VMOV also adds additional bookkeeping instructions for incrementing and resetting addresses and word select. This causes issue in extreme cases when there are not enough MAC instructions to hide the bookkeeping operations, like in the last 1 × 1 CONVs of ResNet18 and ResNet50.</p><p>Another part is that load instruction can become comparably large. For example, if weights are not broadcast, then there will be a load for each weights buffer. In a 4 CU system, there will be 16 weight LDs plus load ID bookkeeping operations. For a low MAC/MAX latency CONV case, the 16 loads should be spread out and interleaved with the MAC/MAX instructions. Load unit balance is also necessary to better utilize the available memory bandwidth. It is better to break a single large load transaction into multiple smaller loads to prevent the CUs from stalling for incoming data.</p><p>Instruction granularity optimization: register assignment, branch delay slot filling and instruction reordering are topics for future work. For this paper, register assignment is statically defined to avoid unnecessary register saving instructions. Branch delay slots are filled and instruction order is manually optimized for a small subset of the main tasks: compute and load. Finding the sweet spot between fully handwritten code and generic pieces of optimized instructions that achieves high-performance for most use cases is up to further study. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Instruction deployment</head><p>Last task is to run Snowflake. This task loads and arranges weights and biases data from a trained model. The weights and bias need to be arranged differently based on the workload break down and the compute decision made earlier. For instance, each vMAC works on a different kernel in COOP mode, whereas in INDP mode each vMAC works on 16 different kernels, hence in INDP we need to group 16 kernels in one vMAC weight buffer. Instruction deployment task also need to load the input image for the first layer of the model. Snowflake uses CMA (Contiguous Memory Allocator) for memory to FPGA communication. All data need to be placed into CMA allocated region of memory. Different regions in CMA are allocated according to layer dependencies (step 2 in section 5.1). Different regions are allocated for each layer's weights. After that, some configuration registers enables an initial load instruction to populate Snowflake's instruction cache with the first set of instructions. The software polls an output counter register to check whether processing has finished or not. Finally, for validation purposes, we wrote a software implementation of the model's layers using Q8.8 to simulate Snowflake's compute operations. Result checking allows layer by layer validation.</p><p>The data representation of choice for hardware and software was Q8.8, which has been shown to have insignificant accuracy degradation compared to neural networks implemented in 32 bit floating point <ref type="bibr" target="#b9">[10]</ref>. Nevertheless, other number representations can be used in the system. Pretrained ResNet18 2 was profiled on ImageNet dataset <ref type="bibr" target="#b19">[20]</ref> using Q8.8 and Q5.11 fixed point precisions. Top-5 accuracy using 32 bit float was 89% , Q8.8 was 84% and Q5.11 was 88%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RESULTS</head><p>This section presents Snowball's results. We compared hand optimized instruction stream versus code generated from Snowball. Performance results for AlexNet, ResNet18 and ResNet50 model were measured. Finally, this section presents a discussion of techniques used in Snowball: kernel or maps data loop and communication load balance.</p><p>2 https://github.com/facebook/fb.resnet.torch</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Snowball generated instructions</head><p>Using all the techniques described in previous section, Snowball generates an instruction stream that achieves performance comparable to handcrafted instructions as shown in Table <ref type="table" target="#tab_1">1</ref>. In the table, CONVs parameters are, respectively, input size, kernel size, input plane, output plane, stride and padding. Auto stands for compiler generated code and hand is handwritten code. Auto-generated code has higher instruction count (437 more), but it achieves similar execution time compared to hand optimized code, which exploits manual optimizations such as filling branch delay slots and instruction reordering. We have only compared some AlexNet layers because models in handwritten instruction are human error prone and tedious. The results for auto-generated instruction for models are shown in table 2. 224 × 224 images was used as model's input. The compiler results show its main contributions: to provide means to test models, ensure output correctness and to allow further exploration. Some inefficiency is caused by cold buffer misses, memory bandwidth limitation and nonoverlapped Maxpool layers. Execution time for all models does not account for FC layer times, since FC layers are inherently bandwidth limited operations. Those issues will be addressed in future hardware and software developments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Loop rearrangement for bandwidth constraints</head><p>Unlike GPUs and ASIC designs, FPGA accelerators are limited mostly by their off-chip memory bandwidth. While a  GPU's optimized memory interconnects can achieve a high bandwidth of 112 GB/s <ref type="bibr" target="#b15">[16]</ref>, Xilinx ZC706 board <ref type="bibr" target="#b23">[24]</ref> can achieve 4.2 GB/s bi-directional bandwidth with the AXI ports <ref type="bibr" target="#b22">[23]</ref>.</p><p>Loop rearrangement is a method that reduces total amount of data movement between main memory and hardware accelerator leading to memory bandwidth savings. Some CONV layers have large kernels, whereas others have large maps, but usually neither completely fits into the buffer. Maps and kernels need to be partitioned and processed in buffer sized tiles. A map tile needs to go through each kernel tile, leading to repeated kernel loads when the next map tile is loaded. Alternatively, a kernel tile needs to be processed with every map tile, resulting in repeated map loads for the following kernel tile. The total amount of data moved is different depending on kernel/map load repetition for a particular CONV layer. Figure <ref type="figure" target="#fig_2">4</ref> shows some examples of CONVs that have lower bandwidth requirement with maps load repetition and vice-versa. Mloop is abbreviation for repeated maps data and Kloop is abbreviation for repeated kernel data. A red dashed line indicates the memory bandwidth limit of the development board. CONVs A and B are from AlexNet model. Their required memory bandwidth is below the limit, so choosing between Mloop or Kloop wont significantly affect performance. CONVs G and H are examples from Resnet50 model and their required memory bandwidth is above the limit for the Mloop mode. Kloop mode is necessary for those layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Communication load balance</head><p>Snowflake has 4 load/store units, and properly distributing LD instructions to all units prevents CU stalls due to data transfer. Issuing a single map load to a unit while distributing kernels for all units will lead to unbalanced load units workload. A better approach is to break the maps data into multiple load instructions and distribute evenly with the kernel loads. Communication load balancing optimizes the load unit usage, and thus results in better usage of available memory bandwidth. Load imbalance is a measure of how evenly data is distributed. The percent imbalance metric equation 1 is commonly used <ref type="bibr" target="#b16">[17]</ref>. Where Lmax is maximum load for any load unit and µL is the mean load over all load units.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CL = (</head><p>Lmax µL − 1) × 100% (1) Table <ref type="table" target="#tab_3">3</ref> shows the speedup achieved by reducing the load imbalance on a CONV 1 × 1 with 1024 input channels, 2048 output channels and stride 2. The load imbalance percent is measured and averaged out for all tiles. The worst imbalance in the table 3 is the case when kernel and maps uses two load units. The measured speedup in the execution time is compared with the worst load imbalance. This shows that finer load balancing has gains in performance up to a certain limit when data loads are mostly overlapped with vector computation. From this point, reducing memory latency by better load distribution results in diminishing improvements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>This work presented a complete software design flow from high level model definitions created with popular deep learning tools (Torch7) down to custom architecture for accelerating deep learning. Snowball was implemented to provide hardware usability, while efficiently utilizing all hardware resources for various CNN workloads. This work addresses software design points, such as model structure parsing, workload breakdown, loop rearrangement and memory access balancing. Those techniques were tested on the Snowflake custom accelerator, but they can be applied to other custom accelerators.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure1: Snowflake architecture block diagram. On the left, a vMAC is a group of MAC units. In the center, a CU is composed of a group of vMACs with data buffers. In the right, a group of CUs forms a compute cluster that shares the control unit and load/store units.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Example Snowball's data structure. The arrows represent pointers. Objects are grouped into lists. Head and tail pointers of the lists are omitted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Required memory bandwidth in Mloop or Kloop mode for various CONV examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 3: Example of instruction generation for a CONV layer. Different layers create different number of objects, but they all become MAC/MAX for window objects and LD for load objects.</figDesc><table><row><cell>Layer</cell><cell>CONV Load Map$ Load Map$</cell><cell>Map Tile Window Window Window</cell><cell>T X T</cell><cell>Y</cell><cell>K Kernel Tile</cell><cell>LD MBuff // initial cache loads LD KBuff Kloop: Yloop: Tloop: MAC instruction BLE 0 KLoop Kloop BLE 0 YLoop Yloop BLE 0 TLoop Tloop MAC instruction Tloop: BLE 0 XLoop Xloop LD KBuff // for next Kloop iteration If(first Kloop iter.) LD MBuff // load once for next section BLE 0 TLoop Tloop MAC instruction Tloop: Xloop: BLE 0 TLoop Tloop</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Hand optimized code (hand) versus autogenerated instructions (auto).</figDesc><table><row><cell>Layer</cell><cell cols="2">Code Time [ms]</cell></row><row><cell>27x27,5x5,64,192,1,2</cell><cell>Hand Auto</cell><cell>3.256 3.261</cell></row><row><cell>13x13,3x3,192,384,1,1</cell><cell>Hand Auto</cell><cell>1.627 1.624</cell></row><row><cell>13x13,3x3,384,256,1,1</cell><cell>Hand Auto</cell><cell>2.188 2.187</cell></row><row><cell>13x13,3x3,256,256,1,1</cell><cell>Hand Auto</cell><cell>1.462 1.458</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Results for models using Snowball</figDesc><table><row><cell>Model</cell><cell cols="2">Exec. Time [ms] BW [GB/s]</cell></row><row><cell>AlexNetOWT</cell><cell>10.68</cell><cell>1.22</cell></row><row><cell>ResNet18</cell><cell>46.77</cell><cell>2.25</cell></row><row><cell>ResNet50</cell><cell>218.61</cell><cell>1.87</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Speed up versus load imbalance.</figDesc><table><row><cell cols="2">Load Balance [%] Speed up</cell></row><row><cell>5</cell><cell>1.658</cell></row><row><cell>17</cell><cell>1.656</cell></row><row><cell>42</cell><cell>1.652</cell></row><row><cell>102</cell><cell>1.644</cell></row><row><cell>114</cell><cell>1.297</cell></row><row><cell>132</cell><cell>1.000</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">https://github.com/mvitez/thnets</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Neurostream: Scalable and energy efficient deep learning with smart memory cubes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Azarkhish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Loi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.06420</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Origami: A convolutional network accelerator</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cavigelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gschwend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Willi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Muheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Edition on Great Lakes Symposium on VLSI, GLSVLSI &apos;15</title>
				<meeting>the 25th Edition on Great Lakes Symposium on VLSI, GLSVLSI &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="199" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Eyeriss: A spatial architecture for energy-efficient dataflow for convolutional neural networks</title>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="367" to="379" />
			<date type="published" when="2016-06">June 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Torch7: A matlab-like environment for machine learning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Farabet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BigLearn, NIPS Workshop, number EPFL-CONF-192376</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Neuflow: A runtime reconfigurable dataflow processor for vision</title>
		<author>
			<persName><forename type="first">C</forename><surname>Farabet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Martini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Corda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Akselrod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Culurciello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR 2011 WORKSHOPS</title>
				<imprint>
			<date type="published" when="2011-06">June 2011</date>
			<biblScope unit="page" from="109" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A 240 g-ops/s mobile coprocessor for deep neural networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gokhale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dundar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Martini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Culurciello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The IEEE Conference on Computer Vision and Pattern Recognition (CVPR) Workshops</title>
				<imprint>
			<date type="published" when="2014-06">June 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Snowflake: An efficient hardware accelerator for convolutional neural networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gokhale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zaidy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">X</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Culurciello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Circuits and Systems (ISCAS)</title>
				<imprint>
			<date type="published" when="2017-05">May 2017</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">EIE: efficient inference engine on compressed deep neural network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pedram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<idno>CoRR, abs/1602.01528</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<idno>CoRR, abs/1512.03385</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Finite precision error analysis of neural network hardware implementations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Holi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-N</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="281" to="290" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Caffe: Convolutional architecture for fast feature embedding</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM international conference on Multimedia</title>
				<meeting>the 22nd ACM international conference on Multimedia</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="675" to="678" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient memory compression in deep neural networks using coarse-grain sparsification for speech applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kadetotad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Arunachalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Seo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE/ACM International Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>Computer-Aided Design</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">One weird trick for parallelizing convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<idno>CoRR, abs/1404.5997</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Llvm: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization</title>
				<meeting>the international symposium on Code generation and optimization: feedback-directed and runtime optimization</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page">75</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Cambricon: An instruction set architecture for neural networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd International Symposium on Computer Architecture</title>
				<meeting>the 43rd International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="393" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Nvidia. Gtx</title>
		<imprint>
			<biblScope unit="volume">960</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Quantifying the effectiveness of load balance algorithms</title>
		<author>
			<persName><forename type="first">O</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gamblin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>De Supinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Amato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th ACM international conference on Supercomputing</title>
				<meeting>the 26th ACM international conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="185" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Memory-centric accelerator design for convolutional neural networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Peemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Setio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mesman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Corporaal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Design (ICCD), 2013 IEEE 31st International Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="13" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The neuro vector engine: Flexibility to improve convolutional net efficiency for wearable vision</title>
		<author>
			<persName><forename type="first">M</forename><surname>Peemen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Juurlink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mesman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Corporaal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="1604" to="1609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ImageNet Large Scale Visual Recognition Challenge</title>
		<author>
			<persName><forename type="first">O</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Satheesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Vision (IJCV)</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="252" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Performance and scalability of gpu-based convolutional neural networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Strigl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kofler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Podlipnig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel, Distributed and Network-Based Processing (PDP), 2010 18th Euromicro International Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="317" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Going deeper with convolutions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Anguelov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rabinovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</title>
				<imprint>
			<date type="published" when="2015-06">June 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Vivado Design Suite</title>
				<imprint>
			<date type="published" when="2015-11">Nov. 2015</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">ZC706 Evaluation Board for the Zynq-7000 XC7Z045 All Programmable SoC</title>
		<author>
			<persName><surname>Xilinx</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">Sept. 2015. v1.5</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Caffeine: Towards uniformed representation and acceleration for deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th International Conference on Computer-Aided Design, ICCAD &apos;16</title>
				<meeting>the 35th International Conference on Computer-Aided Design, ICCAD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Optimizing fpga-based accelerator design for deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays, FPGA &apos;15</title>
				<meeting>the 2015 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays, FPGA &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="161" to="170" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
