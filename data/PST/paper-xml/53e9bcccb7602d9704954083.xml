<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Collaborative TCP Sequence Number Inference Attack -How to Crack Sequence Number Under A Second</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zhiyun</forename><surname>Qian</surname></persName>
							<email>zhiyunq@umich.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<addrLine>2260 Hayward Street Ann Arbor</addrLine>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Z</forename><forename type="middle">Morley</forename><surname>Mao</surname></persName>
							<email>zmao@umich.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<addrLine>2260 Hayward Street Ann Arbor</addrLine>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yinglian</forename><surname>Xie</surname></persName>
							<email>yxie@microsoft.com</email>
							<affiliation key="aff2">
								<orgName type="department">Microsoft Research Silicon Valley</orgName>
								<address>
									<addrLine>1288 Pear Avenue Mountain View</addrLine>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Collaborative TCP Sequence Number Inference Attack -How to Crack Sequence Number Under A Second</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7B8C037FFAD1F2AC4B4A790A7457873B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.6 [Operating Systems]: Security and Protection-Information flow controls; C.2.5 [Computer-Communication Networks]: Local and Wide-Area Networks-Internet (e.g.</term>
					<term>TCP/IP) Security</term>
					<term>Experimentation TCP hijacking</term>
					<term>TCP sequence number</term>
					<term>Network packet counters</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this study, we discover a new class of unknown side channels -"sequence-number-dependent" host packet counters -that exist in Linux/Android and BSD/Mac OS to enable TCP sequence number inference attacks. It allows a piece of unprivileged on-device malware to collaborate with an off-path attacker to infer the TCP sequence numbers used between a client and a server, leading to TCP injection and hijacking attacks. We show that the inference takes, in common cases, under a second to complete and is quick enough for attackers to inject malicious Javascripts into live Facebook sessions and to perform malicious actions on behalf of a victim user. Since supporting unprivileged access to global packet counters is an intentional design choice, we believe our findings provide important lessons and offer insights on future system and network design.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Since TCP was not originally designed for security, for years it has been patched to address various security holes, among which the randomization of TCP's initial sequence number (ISN), introduced in RFC1948 <ref type="bibr">[7]</ref> in 1996 was an important one. It was proposed to guard against off-path spoofing attacks attempting to inject packets with forged source addresses (for data injection or reset attacks) <ref type="bibr">[7,</ref><ref type="bibr" target="#b8">8]</ref>. ISN randomization prevents easy prediction of sequence numbers; thus arbitrarily injected packets are likely to be discarded at the receiver due to invalid sequence numbers.</p><p>The patch has largely rendered most sequence-numberguessing-based attacks very hard to succeed. However, in recent years, new attacks are reported. In 2007, a study reported in Phrack magazine <ref type="bibr" target="#b1">[1]</ref> has revisited the problem and claimed that TCP sequence number can still be inferred based on how a host treats in-window and out-of-window incoming packets. However, the scope of this attack is rather limited, primarily targeting long-lived connections with a rather low success rate (as shown in §3.3). In 2012, researchers have discovered that the sequence number inference attack can be more generally applicable, impacting even short-lived HTTP connections <ref type="bibr" target="#b26">[26]</ref>. However, this attack heavily relies on the presence of sequence-number-checking firewall middleboxes deployed in the network. Specifically, the idea is that if a packet has passed the sequence-numberchecking firewall, then it implies that the sequence number of the packet is considered within a legitimate window.</p><p>Our work generalizes these attacks by eliminating the strong requirements imposed on them to enable a broader class of attacks. Specifically, we make the following key contributions:</p><p>• Building on the threat model presented in the recent work <ref type="bibr" target="#b26">[26]</ref>, we generalize the sequence number inference attack by demonstrating that it can be reliably carried out without the help of the firewall middleboxes. Our work provides further evidence that relying on TCP sequence number for security is not an option.</p><p>• Distinct from the "error counters" (e.g., packets rejected due to old timestamps) used in the previous study <ref type="bibr" target="#b26">[26]</ref>, which serves only as an indication of whether a packet is allowed to pass through the sequence-number-checking firewall, we discover a new class of packet counters -"sequencenumber-dependent" counters in Linux/Android (1 counter) and BSD/Mac OS (8 counters) -that can directly leak sequence numbers without requiring the presence of firewall middleboxes, thereby elevating the danger of TCP injection and hijacking attacks.</p><p>• We are able to complete the sequence number inference within 4-5 round trips, which is much faster than the one previously proposed <ref type="bibr" target="#b26">[26]</ref>, due to both the property of newly discovered "sequence-number-dependent" counters as well as a more efficient probing scheme. For instance, we show that it takes as little as 50ms to complete the inference, two orders of magnitude faster than previous method. It can even eliminate the need of conducting additional TCP hijacking attacks required before, resulting in a much higher attack success rate (See §5.1).</p><p>As a proof-of-concept demonstration, we show that our attack allows a piece of unprivileged malware on Android smartphones to hijack a Facebook connection, replacing the login page, or injecting malicious Javascripts to post new status on behalf of the victim user, or performing other actions. All these attacks (except the TCP hijacking attack) work on the latest Linux kernel. TCP hijacking requires kernel versions earlier than 3.0.2, which are still the case for the majority of the Android phones. Besides Android/Linux, we also demonstrate that the attack is applicable to the latest BSD/Mac OS. We believe our work presents an important message that today's systems still expose too much shared state with poor isolation.</p><p>The rest of the paper is organized as follows: §2 thoroughly describes the related work. §3 explains how to infer TCP sequence number (including both previous study and our discovery). §4 covers how we can leverage the sequence number inference as a building block to conduct a number of TCP attacks. §5 shows several cases studies demonstrating the impact on specific applications. §6 discusses why the problem occurred and concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>TCP sequence number inference attack. By far, there are only a few reported TCP sequence number inference attacks. The first one goes back to 1999 where a TCP stack bug causes the kernel to silently drop the third packet during "three-way handshake" if the ACK number is smaller than the expected ACK number, and sends a reset otherwise <ref type="bibr" target="#b4">[4]</ref>. This allows an attacker to send spoofed ACK packets and infer the correct ACK number. This minor bug was quickly fixed. Besides it, there are three other closely related studies. One of them is described in the Phrack magazine <ref type="bibr" target="#b1">[1]</ref> that uses the IPID side channel on Windows to infer both the server-side and the client-side TCP sequence numbers. According to our empirical results, such attack is theoretically possible but very hard to carry out. It can succeed under rather limited conditions due to a large number of packets required as well as the noisy side-channel that is leveraged. Following the same direction, a more recent work <ref type="bibr" target="#b20">[20]</ref> improves the reliability of the attack by requiring certain control on the client (e.g., javascript through browser), yet it still relies on the noisy IPID side channel available on Windows only.</p><p>A closely related recent work <ref type="bibr" target="#b26">[26]</ref> discusses how sequencenumber-checking firewall middleboxes can leak the TCP sequence number state stored on the firewall. The idea is that if a packet has passed the sequence-number-checking firewall, it implies that the sequence number of the packet is considered within a legitimate window. Otherwise, it implies that the packet has an out-of-window sequence number. As a result, if an attacker can observe whether a spoofed packet has passed the firewall, he will be able to know if a guessed sequence number is correct. To do so, an attacker can intentionally craft a spoofed packet with certain errors (e.g., old timestamp) and then leverage the error packet counters on the host (e.g., packets rejected due to old times-tamps) to tell if a spoofed packet has passed the firewall and reached the end-host. In our work, we make a major improvement by eliminating the requirement of firewall middleboxes altogether with the help of a class of "sequencenumber-dependent" packet counters that we discover. In addition to a more general attack model, we also show significant improvements on success rate and attack speed with much lower network resource requirements.</p><p>Other TCP-sequence-number-related attacks. (1) TCP sequence number prediction attack. Different from TCP sequence number inference attack, the prediction attack relies on the non-randomness of TCP Initial Sequence Numbers (ISN) <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b2">2]</ref>. To defend the attack, RFC1948 <ref type="bibr">[7]</ref> standardizes the ISN randomization behavior such that different connections should generate random sequence numbers independently. (2) Blind TCP RST attack. Due to the fact that a connection will be reset as long as the sequence number of the reset (RST) packet falls in the current receive window, in a long-lived connection (e.g., a BGP session), an attacker can brute force all possible target connections and sequence number ranges <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b32">32]</ref> to cause denial of service.</p><p>Smartphone-based attacks. There have been a number of attacks against smartphones, many of which focus on leaking sensitive information <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b28">28]</ref>. In addition, there is a class of privilege escalation attacks on Android <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b14">14]</ref>, but they are limited to gaining permissions that typically cannot affect the behavior of other applications. For instance, one application may gain the permission of reading the contact list or GPS location through other colluding or vulnerable apps, but it cannot tamper with the TCP connection of other applications given the OS's sandboxing mechanisms. Our study demonstrates that injection and hijacking of TCP connections can be achieved without requiring any special permission other than the permission to access the Internet.</p><p>Side-channel information leakage. A wide range of side channels have been investigated before: CPU, power, shared memory/files, and even electromagnetic waves, etc.</p><p>Researchers have found that it is possible to construct various attacks, e.g., to infer keystrokes through many side channels <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b18">18]</ref>. It is especially interesting to see how smartphones can allow malware to infer sensitive information through on-board sensors (which can also be considered as side-channels). For instance, Soundcomber <ref type="bibr" target="#b28">[28]</ref> uses the audio sensor to record credit card numbers entered through keypad. In our work, we also rely on side-channels on the host, but the attacks infer information at the network-layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">TCP SEQUENCE NUMBER INFER-ENCE ATTACK</head><p>The ultimate goal of the attack is to inject malicious TCP payload into apps running on a victim smartphone or client device. It is achieved by a piece of unprivileged on-device malware collaborating with an off-path attacker on the Internet. The main implication of this attack is that websites that do not use HTTPS will be vulnerable to various attacks such as phishing and Javascript injection because the HTTP response can be potentially replaced. Even if HTTPS is used, they are still vulnerable to connection reset attacks as we show that the sequence number can be quickly inferred in under a second.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Threat Model</head><p>The threat model is illustrated in Figure <ref type="figure" target="#fig_1">1</ref>. There are four main entities: <ref type="bibr" target="#b1">(1)</ref> The victim smartphone and a target application, constituting the attack target. (2) The legitimate server, which talks to the victim smartphone using an unencrypted application-layer protocol (e.g., HTTP). The server can also become the attack target (see §5). (3) The on-device malware, which is unprivileged and cannot tamper with other apps directly. (4) The off-path attacker, who is capable of spoofing the IP address of the legitimate server and the victim smartphone. The off-path attacker and the malware collaborate to infer the correct TCP sequence number of the connection established between the target app and the legitimate server. Note that different from the threat model described in the recent study <ref type="bibr" target="#b26">[26]</ref>, this attack does not require the network firewall middlebox, making our attack model much more general.</p><p>At a high level, as shown in Figure <ref type="figure" target="#fig_1">1</ref>, the off-path attacker needs two pieces of information: (1) the four tuples of a target connection, i.e., source/destination IP addresses and source/destination port numbers and (2) the correct sequence number. The on-device malware can easily identify the current active connections (e.g., through netstat), but it does not know the sequence number in use. In this attack model, the off-path attacker can send probe packets using the target four tuples with different guessed sequence numbers. The unprivileged malware then uses certain sidechannels to provide feedback on whether the guessed sequence numbers are correct. Guided by the feedback, the off-path attacker can then adjust the sequence numbers to narrow down the correct sequence number.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Packet Counter Side Channels</head><p>In this study, we look at a particular type of side channel, packet counters, that can potentially provide indirect feedback on whether a guessed sequence number is correct. In Linux, the procfs <ref type="bibr" target="#b24">[24]</ref> exposes aggregated statistics on the number of incoming/outgoing TCP packets, with certain properties (e.g., wrong checksums). Alternatively, "netstat -s" exposes a similar set of information on all major OSes including Microsoft Windows, Linux, BSD, Mac OS and smartphone OSes like Android and iOS. Since such counters are aggregated over the entire system, they are generally considered safe and thus accessible to any user or program without requiring special permissions. The IPID sidechannel <ref type="bibr" target="#b27">[27]</ref> can be considered as a special form of packet counter that records the total number of outgoing packets since it is incremented for every outgoing packet. However, such side-channel is nowadays only available on Microsoft Windows and is typically very noisy.</p><p>Even though it is generally perceived safe, we show that an attacker can correlate the packet counter update with how the TCP stack treats a spoofed probing packet with a guessed sequence number. Different from the recent work <ref type="bibr" target="#b26">[26]</ref> that uses certain "error counters" as an indication of whether a spoofed packet has passed the sequencenumber-checking firewall middlebox, our hypothesis is that the TCP stack may increment certain counters when the guessed sequence number is wrong and remain the same when it is correct, or vice versa. Such counters can directly leak sequence numbers without the help of the firewall middlebox and are thus named "sequence-number-dependent counters" (details in §3.4 and §3.5). To investigate such a possibility, we first need to understand how TCP stack handles an incoming TCP packet and how various counters are incremented during the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">TCP Incoming Packet Validation</head><p>In this section, we provide background on how a standard TCP stack validates an incoming packet that belongs to an established TCP connection. Specifically, we use the source code of the latest Linux kernel 3.2.6 (at the time of writing) as reference to extract the steps taken and checks performed on an incoming packet (the packet validation logic is stable since 2.6.28). Based on the source code, we summarize "sequence-number-dependent" side-channels on Linux and extend it to BSD/Mac OS. As we can see in Figure <ref type="figure" target="#fig_2">2</ref>, there exist five main checks performed by Linux TCP stack based on the corresponding source code as well as our controlled experiments. These checks are performed for any incoming TCP packet that is deemed to belong to an established connection based on the four tuples:</p><p>(1). Error check is for the purpose of dropping invalid packets early on. There are a number of specific error checks: 1) MD5 option check, 2) timestamp option check, 3) packet length and checksum check. Each has a corresponding error packet counter. If a specific error is caught, the corresponding host packet counter is incremented and the packet is not inspected further. Otherwise, it goes to the next step.</p><p>(2). Sequence number check is the most relevant check. It basically checks if a packet is in window by making sure that the ending sequence number of the incoming packet is larger than or equal to X, and the starting sequence number is smaller than or equal to X+rcv win, where X is the next expected sequence number and rcv win is the current receive window size. If the sequence number is out of window, it triggers an immediate duplicate acknowledgment packet to be sent back, indicating the correct sequence number that it is expecting. Otherwise, the next check is conducted.</p><p>(3). Acknowledge number check is an additional validity check on the packet. A valid ACK number should theoretically be within [Y, Y+outstanding bytes] to be considered valid. Here Y is the first unacknowledged sequence number and outstanding bytes is total number of outstanding bytes not yet acknowledged. Linux has a relaxed implementation which allows half of the ACK number space to be considered valid (we discuss its impact later). If the ACK number is considered invalid, then it is dropped without further processing. Else, the packet goes through the later non-validity-related checks.</p><p>(4). At this point the packet has the correct sequence number and the ACK number. The stack needs to check if it has any payload. If it does not have any payload, the packet is silently ignored unless there happens to be pending data that can be piggybacked. In particular, the host cannot send another 0-payload acknowledgment packet for the 0-payload incoming ACK packet, which will create endless TCP ACK storm <ref type="bibr" target="#b23">[23]</ref>.</p><p>(5). If the packet has non-zero payload, the final check is to detect retransmission by checking if the ending sequence number of the packet is smaller than or equal to the next expected sequence number. If so, it does not process the packet further and immediately sends an ACK packet to inform the other end of the expected sequence number. Since step 2 has already ensured that the ending sequence number cannot be smaller than the next expected sequence number, the only possible ending sequence number that can satisfy the retransmission check is the one equal to the next expected sequence number.</p><p>From the above description on how a TCP packet is handled, it is not hard to tell that depending on whether the sequence number is in or out of window, the TCP stack may behave differently, which can be observed by the on-device malware. Specifically, if it is an out-of-window packet with 0-payload, it most likely will not trigger any outgoing packet. However, if it is an in-window packet, it immediately triggers an outgoing duplicate ACK packet. As a result, it is possible to use the counter that records the total number of outgoing packets to tell if a guessed sequence number is in window.</p><p>A similar observation has been made by the previous study in the Phrack magazine <ref type="bibr" target="#b1">[1]</ref>. The problem with their approach to infer sequence number is that such general packet counters can be very noisy -there may be background traffic which can increment the system-wide outgoing packet counters. It is especially problematic when the receive window size is small -a large number of packets need to be sent and the probing is very likely to have limited success. In fact, we have implemented such sequence number inference attack on a smartphone at home connected to the broadband ISP through WiFi with 10Mbps downlink bandwidth. Through 20 repeated experiments, we find that the inference always failed because of the noise of the background traffic It is also worth noting that the error checks are performed at the very beginning, preceding the sequence number check, which means that the corresponding error counters used by the recent study <ref type="bibr" target="#b26">[26]</ref> alone cannot provide any feedback on a guessed TCP sequence number.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Sequence-Number-Dependent Counter in Linux</head><p>The reason why the Phrack attack <ref type="bibr" target="#b1">[1]</ref> is difficult to carry out is two-fold: <ref type="bibr" target="#b1">(1)</ref> The required number of packets is too large; an attacker needs to send at least one packet per receive window in order to figure out the right sequence number range. <ref type="bibr" target="#b2">(2)</ref> The counter that records the total number of outgoing packets is too noisy. Subsequently, we show that both problems can be addressed by using a newly discovered set of sequence-number-dependent packet counters that increment when the sequence number of an incoming packet matches certain conditions.</p><p>if (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp; before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) { NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST); … } Server-side sequence number inference. We closely study the function tcp send dupack() which is called after the sequence number check (depicted in Figure <ref type="figure" target="#fig_2">2</ref>). Within the function, we discover an interesting piece of code shown in Figure <ref type="figure" target="#fig_3">3</ref>. The "if" condition says if the packet's starting sequence number is not equal to its ending sequence number (i.e., the packet has nonzero payload), and its starting sequence number is "before" the expected sequence number, then a packet counter named De-layedACKLost is incremented (which is publicly accessible from /proc/net/netstat). This particular logic is to detect lost delayed ACK packets sent previously and switch from the delayed ACK mode into the quick ACK mode <ref type="bibr" target="#b12">[12]</ref>. The presence of an old/retransmitted TCP packet is an indication that the delayed ACKs were lost.</p><p>The question is how "before()" is implemented. In Linux (and Mac OS), it basically subtracts an unsigned 32-bit integer from another unsigned 32-bit integer and converts the result into a signed 32-bit integer. This means that half of the sequence number space (i.e., 2G) is considered before the expected sequence number. For instance, two unsigned integers 1G minus 2G would lead to an unsigned integer 3G. When converting to an signed value, we obtain -1G.</p><p>The net effect of the tcp send dupack() is that it allows an attacker to easily determine if a guessed sequence number is before or after the expected sequence number. Since the DelayedACKLost counter very rarely increments naturally (See §3.8), an attacker can use this counter as a clean and reliable side-channel.</p><p>Binary search. Using this special counter, it is straightforward to conduct a binary search on the expected sequence number. Note that the process is significantly different than the one proposed in the earlier work <ref type="bibr" target="#b26">[26]</ref> in that the earlier work still requires sending one packet per "window", which results in a total of thousands or tens of thousands of packets. Here, as illustrated in Figure <ref type="figure" target="#fig_5">4</ref>, the attacker only needs to send one packet each round and only a total of 32 packets, resulting in hardly any bandwidth requirement. Specifically, as shown in the figure, in the first iteration, the attacker can try the middle of the sequence number space (i.e., 2G). If the expected sequence number falls in the first half (i.e., bin 1), the DelayedACKLost counter increments by 1. Otherwise, (i.e., if it falls in bin 2), the counter remains the same. Suppose the attacker finds that the expected sequence number is in the first half after the first iteration, in the second iteration, he can try 1G to further narrow down the sequence number. After log 2 4G = 32 rounds (also 32 packets), the exact sequence number can be pinpointed. The total inference time can be roughly calculated as 32 × RT T . In reality, the number of RTTs can be further reduced by stopping the inference at an earlier iteration. For instance, if it is stopped at the 31st iterations, the attacker would know that the sequence number is either X or X+1. Similarly, if the number of iterations is 22, the attacker knows that the sequence number is within [X, X+1024). In many cases, this is sufficient because the attacker can still inject a single packet with payload of 1460 bytes and pad the first 1024 bytes with whitespace (which effectively leaves 436 bytes of effective payload). For instance, if the application-layer protocol is HTTP, the whitespace is safely ignored even if they happen to be accepted as part of the HTTP response.  N-way search. To further improve the inference speed, we devise a variation of the "N-way search" proposed in the recent work <ref type="bibr" target="#b26">[26]</ref>. The idea is similar -instead of eliminating half of the sequence number space each iteration, we can eliminate N -1 N of the search space by simultaneously probing N-1 of N equally-partitioned bins. The difference is that the inference requires one or two orders of magnitude fewer packets compared to the previously proposed search.</p><p>Figure <ref type="figure" target="#fig_7">5</ref> illustrates the process of a 4-way search. In the first iteration, the search space is equally partitioned into 4 bins. The attacker sends one packet with sequence number 1G, three packets with sequence number 2G, and two packets with sequence number 3G. If the expected sequence number falls in the first bin, the DelayedACKLost counter increments by 2, as the two packets sent with sequence number 3G are considered before the expected sequence number. Similarly, the counter increments by a different number for different bins. In general, as long as the number of packets sent for each bin follow the distance between two consecutive marks on a circular/modular Golomb ruler <ref type="bibr" target="#b3">[3]</ref>, the De-layedACKLost counter increment will be unique when the expected sequence number falls in different bins.</p><p>In the later iterations, however, a much simpler strategy can be used. In Figure <ref type="figure" target="#fig_7">5</ref>(b), an attacker can just send one packet per bin instead of following the circular Golomb ruler. The reason is that now that the search space is reduced to smaller than 2G, it is no longer circular (unlike the first iteration where the counter increment in the first bin can be impacted by the fourth bin). Now, if the sequence number falls in the first bin, then the counter remains the same; if it falls in the second bin, the counter will increment 1; and so on. We discuss the realistic settings and performance of different "N" in §3.7.  Client-side sequence number inference. Sometimes, it is necessary to infer the client-side sequence number, for the purpose of either injecting data to the victim server, or injecting data to the victim client with an appropriate ACK number. The latter is currently unnecessary as Linux/Android and BSD/Mac OS allows half of the ACK number space to be valid <ref type="bibr" target="#b26">[26]</ref>. For the former, we can still use the same DelayedACKLost counter to infer the ACK number.</p><p>Specifically, as discussed in §3.3, the only ending sequence number that can satisfy the retransmission check is the one equal to the next expected sequence number. When that happens, the TCP stack increments the DelayedACKLost packet counter again. The source code of the retransmission check is shown in Figure <ref type="figure" target="#fig_8">6</ref>.</p><p>Since the retransmission check is after the ACK number check, it allows an attacker to send a non-zero payload packet that has the ending sequence number equal to the next expected sequence number with a guessed ACK number. If it does not pass the ACK number check, the packet is dropped and the DelayedACKLost counter does not increment. Otherwise, the packet is considered a retransmitted packet and triggers the counter to increment. Based on such behavior, we can perform a binary search or N-way search on the ACK number similar to the sequence number search. In fact, the procedure is mostly identical.</p><p>if (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) { NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST); … } Inspired by the newly discovered counter in Linux, we further conduct a survey on the latest FreeBSD source code (version 10). Surprisingly, we find that at least four pairs of packet counters can leak TCP sequence number. The counters are confirmed to exist in Mac OS as well. This finding shows that the sequence-number-dependent counters are widely available and apparently considered safe to include in the OS. They are: 1) rcvduppack and rcvdupbyte; 2) rcvpackafterwin and rcvbyteafterwin; 3) rcvoopack and rcvoobyte; 4) rcvdupack and rcvacktoomuch. They can be either accessed through the standard "netstat -s" interface or sysctl API <ref type="bibr" target="#b11">[11]</ref>.</p><p>The first three pairs can be used to infer server-side sequence numbers. Specifically, based on the source code, the semantic of rcvduppack is identical to that of DelayedACK-Lost. rcvdupbyte, however, additionally provides information on the number of bytes (payload) carried in the incoming packets that are considered duplicate (with an old sequence number). This counter greatly benefits the sequence number inference. Following the same "N-way" procedure, the first iteration can be improved by changing the "k packets sent per bin" to "a single packet with k bytes payload". This improvement substantially reduces the number of packets/bytes sent in each iteration, especially when "N" is large (shown in §3.7).</p><p>The semantic of rcvpackafterwin and rcvbyteafterwin is similar to rcvduppack and rcvdupbyte, except that the former increments only when the sequence number is bigger than (instead of smaller than) certain sequence number X. In this case, X is the expected sequence number plus the receive window size. rcvbyteafterwin can be used similarly as rcvdupbyte to conduct the sequence number inference.</p><p>rcvoopack and rcvoobyte differ from the previous two pairs. They increment only when packets arrive out of order, or more precisely, when the sequence number is bigger than the expected sequence number yet smaller than the expected sequence number plus the receive window size. Even though an attacker needs to send a lot more packets to infer the TCP sequence number using this counter pair, at least they can be used to replace the original noisy side-channel in the Phrack attack <ref type="bibr" target="#b1">[1]</ref> to improve success rate.</p><p>rcvdupack and rcvacktoomuch are used to determine the client-side sequence numbers. Specifically, the former increments when the ACK number of an incoming packet is smaller than or equal to the unacknowledged number (SND.UNA). The latter increments when the ACK number is greater than the sequence number of the next original transmit (SND.MAX). The comparison again follows the "unsigned integer to signed integer conversion" such that half of the ACK number space is considered to match the condition.</p><p>We currently did not combine the counters together to improve the inference speed. However, we do realize there are potential ways to speed things up. For instance, the rcvdupbyte and rcvdupack allows the client-side sequence number inference to be piggybacked with the server-side sequence number inference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Sequence-Number-Dependent Counters in Microsoft Windows</head><p>Interestingly, Microsoft Windows OSes do not appear to expose such sequence-number-dependent counters and are thus not vulnerable to the attack. On Windows 7, for example, the TCP-related packet counters include the total number of incoming packets, outgoing packets, and the number of packets retransmitted from the output of "netstat -s". These packet counters do not leak sequence numbers directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Inference Performance and Overhead</head><p>We have implemented the sequence number inference on both Android (which incorporates the Linux kernel) and Mac OS. We are interested in the tradeoffs between different strategies in picking "N" in the "N-way search".</p><p>Generally, as "N" goes up, the total number of bytes sent should also increase. Since the first iteration in the "N-way" search requires sending more bytes, we pick a smaller "N" for the first iteration and a bigger "N" in the later iterations to ensure that the number of bytes sent in each round is similar. In the Linux implementation, we pick the following pairs of N, (2/2, 4/6, 8/30, 12/84); For Mac OS, we pick (2/2, 4/6, 34/50, 82/228). Here 4/6 means that we pick N=4 for the first iteration and N=6 for the later iterations.</p><p>As shown in Figure <ref type="figure" target="#fig_10">7</ref>, we can see that the general tradeoff is that the fewer iterations an attacker wants, the more bytes he needs to send in total. For instance, when the number of iterations is 4, an attacker on Linux needs to send 13.7KB. With the presence of the rcvdupbyte counter in Mac OS, it requires to send only 8.4KB. This is a rather low network resource requirement because it takes only 70ms to push 8.4KB onto the wire with even just 1Mbps bandwidth. Going further down to 3 iterations requires sending 27.75KB for Mac OS. Depending on the available bandwidth and the RTT, we may or may not want to increase the number of bytes to save one round trip.</p><p>Next, we pick N=34/50 (4 round trips) for Mac OS attacks, and N=8/30 (5 round trips) for Linux attacks (with roughly the same resource requirement), and plot the inference time measured under various conditions. We control the RTT between the attacker and the victim in three different settings: 1) The victim is in an office environment (enterprise-like) connected to the network using WiFi, and the attacker is in the same building (the RTT is around 5-10ms). 2) The victim is in a home environment and the attacker is 50ms RTT away. 3) The victim is in a home environment and the attacker is 100ms RTT away. In Figure <ref type="figure">8</ref>, we see that in the first setting the inference time for Android and Mac OS are 80ms and 50ms, which are low enough to directly launch injection attacks on HTTP connections with the guarantee that the inference finishes before the first legitimate response packet comes back (also discussed later in §4.2). In fact, inference time between 350ms and 700ms can be short enough in certain scenarios (see §5.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Noisiness of Sequence-Number-Dependent Counters</head><p>So far, we have claimed that these sequence-numberdependent counters are "clean" side-channels that rarely increment naturally even with background traffic. To quantitatively support this claim, we conduct a worse-case-scenario experiment as follows: We open a YouTube video at the background and browse web pages at the same time to see how often the counters get incremented. Since it is easier to do the multi-tasking on Mac OS, we choose it over the Android platform. The Android counters should increment even less frequently since smartphones are rarely used for video streaming and web browsing simultaneously.</p><p>We pick the rcvdupbyte counter (which is equivalent to De-layedACKLost on Linux) and run the experiments for about 8.5 minutes. The video is long enough that it has not been fully buffered by the end of the experiment. To quantify the counter noisiness, we break down the time into 30ms intervals to mimic the window of exposure during one round of probing, and then count how many intervals in which we observe any counter increment. As expected, there are only 10 intervals out of 16896 that have the increment. This indicates that the probability that the counter increments due to noise and interference with one round of probing is roughly 0.059%. Even if there are 22 rounds (worse case), the probability that the entire probing will be affected by the counter noisiness is only 1.2%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DESIGN AND IMPLEMENTATION OF TCP ATTACKS</head><p>In the previous section, we described how to infer TCP sequence number efficiently and reliably using the newly discovered set of sequence-number-dependent packet counters. Since the sequence number inference only takes less than a second, it can be fast enough to launch many applicationlayer attacks. In this section, we discuss four possible TCP attacks that can be launched against a variety of applications. All of the attacks leverage the TCP sequence number inference as the essential building block, but the main difference is in the timing and reliability with slightly different requirements. We have implemented the attacks on both Android and Mac OS. We use Android as the example for description Injection vs. Hijacking. Using the same terminology as a recent work <ref type="bibr" target="#b26">[26]</ref>, we define TCP hijacking to be the more powerful attack than TCP injection. Specifically, TCP hijacking allows an attacker to inject packets right after the TCP 3-way handshake. For instance, it enables an attacker to inject a complete HTTP response without any interference. In contrast, TCP Injection is more general and does not require this capability.</p><p>The four attacks are named as: <ref type="bibr" target="#b1">(1)</ref>. client-side TCP Injection, <ref type="bibr" target="#b2">(2)</ref>. passive TCP hijacking, (3). active TCP hijacking, (4). server-side TCP injection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Attack Requirements</head><p>There are a number of base requirements that need to be satisfied for all of these TCP attacks. Note that our attacks have much fewer requirements than the one proposed in the recent study <ref type="bibr" target="#b26">[26]</ref>. Specifically, we do not require a firewall middlebox in the network, which makes our attacks applicable in a much more general environment.</p><p>The set of requirements include: (1) malware on the client with Internet access, (2) malware that can run in the background and read packet counters, (3) malware that can read the list of active TCP connections and their four tuples, and (4) a predictable external port number if NAT is deployed. The first three requirements are straightforward. All of the Android applications can easily request Internet access, read packet counters (i.e.,/proc/net/netstat and /proc/net/snmp, or "netstat -s"), and read active TCP connections' four tuples (e.g., through /proc/net/tcp and /proc/net/tcp6, or "netstat"). The requirements can be easily satisfied on most modern OSes as well. In addition, an off-path attacker needs the client's external port mapping to choose the correct four tuples when sending probing packets, so we need the fourth requirement. This requirement is also commonly satisfied, since many NAT mapping types allow the external port to be predictable to facilitate NAT traversal. For instance, our home routers directly map the internal ports to the external ports. According to recent measurement studies on the NAT mapping types <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b31">31]</ref>, the majority of the NATs studied do have predictable external ports. Further, even if the prediction is not 100% accurate, attacks may still succeed by guessing the mappings.</p><p>Additional requirements for passive TCP hijacking are C1 and S1:</p><p>(C1). Client-side ISN has only the lower 24-bit randomized. This requirement is necessary so that the malware can roughly predict the range of the ISN of a newly created TCP connection. In Linux kernels earlier than 3.0.2, the ISN generation algorithm is designed such that ISNs for different connections are not completely independent. Instead, the high 8 bits for all ISNs is a global number that increments slowly (every five minutes). This feature is designed to balance security, reliability, and performance. It is long perceived as a good optimization, with the historical details and explanations in this article <ref type="bibr" target="#b5">[5]</ref>. The result of this design is that the ISN of two back-to-back connections will be at most 2 24 = 16, 777, 216 apart. Even though it is a design decision and not considered a "vulnerability", since Linux 3.0.2, the kernel has changed the ISN generation algorithm such that two consecutive connections will have independent ISNs. The majority of Android systems that are on the market are still on Linux 2.6.XX, which means that they are all vulnerable to the passive TCP hijacking attack.</p><p>(S1). The legitimate server has a host-based stateful TCP firewall. Such a firewall is capable of dropping out-of-state TCP packets. Many websites such as Facebook and Twitter deploy such host firewalls to reduce malicious traffic. For instance, iptables can be easily configured to achieve this purpose <ref type="bibr" target="#b10">[10]</ref>. Interestingly, as we will discuss later, this security feature on the server actually enables TCP hijacking attacks.</p><p>In order to perform active TCP hijacking attacks, the additional requirements include S1 and C2:</p><p>(C2). Client-side ISN monotonically incrementing for the same four tuples. This client-side requirement is in fact explicitly defined in RFC 793 <ref type="bibr" target="#b9">[9]</ref> to prevent packets of old connections, with in-range sequence numbers, from being accepted by the current connection mistakenly. Even though the latest Linux kernel has eliminated the requirement C1, C2 is still preserved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Client-Side TCP Injection</head><p>In this attack, an attacker attempts to inject malicious data into a connection established by other apps on the phone. The essential part of the attack is the TCP sequence number inference which has already been described in detail. The challenge is that the injected data may compete with the data sent from the legitimate server. For instance, considering the connection under attack is an HTTP session where a valid HTTP response typically follows immediately after the request is sent, by the time the sequence number inference is done, at least part of the HTTP response is already sent by the server. The injected HTTP packets likely can only corrupt the response and cause denial of service instead of serious damage.</p><p>Even though the timing requirement sounds difficult to satisfy, we did implement this attack against websites such   ... as Facebook where we are able to inject malicious Javascripts to post new status on behalf of a victim user. The detail is described in §5.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Port jamming</head><p>The idea is to leverage two common scenarios: (1) The server may take a long time to process a request and assemble the response. This is especially common as many services (websites) take longer than 100ms or more to process a request. The fact that the sequence number inference time in certain scenarios (when RTT from the server to the client is small) can be made below 100ms makes the injection attack as powerful as hijacking. (2) A single TCP connection is reused for more than one pair of HTTP request and response. The idea is to use the inferred sequence number for injecting malicious data not on the first HTTP request but the later ones. In both cases, an attacker has enough time to conduct sequence number inference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Passive TCP Hijacking</head><p>Passive TCP hijacking allows an attacker to hijack TCP connections that are passively detected. This means that the attacker can hijack TCP connections issued by the browser or any other app, regardless of how and when they are made. It is the most powerful TCP attack in this study. As demonstrated in §5, with this attack, it is possible to replace the Facebook login page with a phishing one.</p><p>The high-level idea is the same as proposed in the recent work <ref type="bibr" target="#b26">[26]</ref>, which is to reset the connection on the legitimate server as soon as possible to allow the attacker to claim to be the legitimate server talking to the victim. The key is that such reset has to be triggered right after the legitimate server sends SYN-ACK. Requirement C1 allows the malware and the attacker to predict the rough range of victim's ISN and send reset packets with sequence numbers in that range. This is helpful because the attacker is required to send fewer spoofed RST packets (thus with lower bandwidth requirement) compared to enumerating the entire 4G space. Further, after the legitimate server is reset, requirement S1 is necessary since it helps prevent the legitimate server from generating RST upon receiving out-of-state data or ACK packets from the victim.</p><p>The attack sequence diagram is shown in Figure <ref type="figure">9</ref>. Time steps 1 to 3 are the same as the previous attack where the unprivileged malware detects and reports the newly established TCP connection. In addition, the malware also needs to establish a connection to the off-path attacker to report the current ISN value (high 8 bits). With this information, at time 4, the off-path attacker can flood the legitimate server with a number of spoofed RSTs enumerating the lower 24 bits (sequence numbers can increment by a step size as large as the server's receive window size). Note that the RST packets have to arrive before the ACK/request packets at time 5; otherwise, the server may send back the response packets before the attacker. Of course, the server may need some time to process the request as well, which can vary from case to case, allowing the attacker additional time to complete the reset procedure. After the legitimate server's connection is reset, all future packets from the victim app will be considered out-of-state and silently dropped due to requirement S1. For instance, the ACK packet received at time 5 is silently discarded. From time 6 to 7, the attacker conducts the sequence number inference described earlier and injects malicious content afterwards at time 8 with the inferred sequence number. A more detailed analysis on the bandwidth and time requirement is discussed in a similar setting in a prior work <ref type="bibr" target="#b26">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Server-side TCP Injection</head><p>In this attack, an attacker tries to inject malicious payload into a victim connection, destined for the server (as opposed to the client). For instance, as shown in the case study in §5, we are able to target at Windows live messenger protocols to inject malicious commands to cause persistent changes to the victim user account, e.g., adding new friends or removing existing friends.</p><p>This attack is straightforward by combining the sequence number inference and ACK number inference as described in §3. We omit the detailed attack sequence as it does not include other important steps. This attack has no additional requirements besides the base requirements. In general, applications with unencrypted and stateful protocols are good attack targets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Active TCP Hijacking</head><p>In this attack, an attacker attempts to hijack connections. However, because the latest Linux kernel since 3.0.2 has the entire 32-bit randomized for ISNs of different four tuples, requirement C1 is no longer satisfied. In this case, we show that it is still possible to launch a weaker version of TCP hijacking by "actively" performing offline analysis as long as requirement C2 is satisfied. As shown in §5, we have successfully used the port-jamming-assisted active TCP hijacking to replace a Facebook login page with a phishing one.</p><p>Requirement C2 specifies that the ISN for the same fourtuple always increments with time. This implies that as long as an attacker can infer the client's ISN for a particular fourtuple once, he can store the value for a future connection that reuses the same four-tuple, and reset the server using the stored ISN (plus the increment by time) so that the attacker can hijack the connection.</p><p>The detailed attack sequence is demonstrated in Figure <ref type="figure" target="#fig_12">10</ref>, at time 1, the unprivileged malware establishes a connection on its own to a target server of interest (e.g., Facebook server), and notifies the off-path attacker immediately (at time 2) so that it can infer the client ISN of the used four tuples (through time 3 to 4). Now, assuming that the attacker knows that a victim app is about to initiate a connection to the same server, an attacker can immediately perform port jamming to exhaust all the local port numbers (at time 5) so that the victim app's connection can only use the local port number that was in the inferred four tuples (we will describe how port jamming can be done later). Now that the victim connection reuses the same four tuples, the malware can immediately notify the off-path attacker (at time 6) which uses the previously inferred client-side ISN to reset the server (at time 7). Subsequently, the attack sequence is identical to the end of passive TCP hijacking.</p><p>In the above attack sequence, one critical part is the knowledge of when the victim app initiates the connection to the target website. One simple strategy is to actively trigger the victim app to make the connection through the unprivileged malware. On Android, for instance, any app could directly invoke the browser going to a given URL, before which the attacker can perform the port jamming.</p><p>One alternative strategy is to perform offline analysis on as many four tuples as possible so that it can essentially obtain the knowledge of ISN for all possible four tuples going to a particular website (without requiring port jamming). This way, after the offline analysis is performed, the attacker basically can launch passive TCP hijacking on any of the four tuples that have been previously analyzed. Since each client-side ISN inference should take a little over a second, an attacker can infer, for instance, 1000 four tuples in 15 minutes. Even though a connection to Facebook may have 1% probability falling in the range, the user may repeatedly visit the website and the probability that all of the connections failing to match any existing four tuples is likely very low. We have verified that the ISN for the same four-tuple does increment consistently over time for over an hour. We suspect that the cryptographic key for computing ISN does not change until reboot in Linux 3.0.2 and above.</p><p>To jam local ports, the unprivileged malware can simply start a local server, then open many connections to the local server intentionally occupying most of the local port except the ones that are previously seen for inference. One challenge is that the OS may limit the total number of ports that an application can occupy, thus preventing the attacker from opening too many concurrent connections. Interestingly, we find such limit can be bypassed if the established connections are immediately closed (which no longer counts towards the limit). The local port numbers are not immediately released since the closed connections enter the TCP TIME WAIT state for a duration of 1 to 2 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ATTACK IMPACT ANALYSIS FROM CASE STUDIES</head><p>Experiment setup. As discussed earlier, even though our attacks are implemented on both Android and Mac OS, we choose to focus on Android in our implementation and experiments. We use two different phones: Motorola Atrix and Samsung Captivate. We verified that all attacks work on both Android phones, although the experimental results are repeated based on Atrix. The WiFi networks include a home network and a university network. The off-path attacker is hosted on one or more Planetlab nodes in California.</p><p>We describe four case studies corresponding to the four TCP attacks proposed in the previous section. We also present experimental results such as how likely we can succeed in hijacking the Facebook login page based on repeated experiments.</p><p>For all attacks, we implemented the malware as a benign app that has the functionality of downloading wallpapers from the Internet (thus justifying the Internet permission). Since the malware needs to scan netstat (or /proc/net/tcp and /proc/net/tcp6 equivalently) for new connection detection, which can drain the phone's battery very quickly, we make the malware stealthy such that it only scans for new connections when it detects that the victim app of interest is at the foreground. This can be achieved by querying each app's IMPORTANCE FOREGROUND flag which is typically set by the Android OS whenever it is brought to the foreground. Further, the malware queries the packet counter only when the off-path attacker instructs it to do so. The malware is only used in our controlled experiment environments without affecting real users.</p><p>Note that most apps except the browser on the smartphones do not have an indication about whether the connection is using SSL, which means that the users may be completely unaware of the potential security breach for unencrypted connections (e.g., HTTP connections used in the Facebook app).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Facebook Javascript Injection</head><p>We launch the attack based on client-side TCP injection as described in §4.2. Recall that the injection can happen only after the sequence number inference finishes. If the inference cannot be done earlier than the response comes back, the attacker will miss the window of opportunity.</p><p>By examining the packet trace generated by visiting the Facebook website where a user is already logged in, we identify two possible ways to launch the Javascript injection attack. The first attack is surprisingly straightforward. Basically, when the user visits m.facebook.com, the browser issues an HTTP request that fetches all recent news. We observe that it consistently takes the server more than 1.5 seconds to process the request before sending back the first response packet. According to our results in §3.7, the inference time usually finishes within 0.7s even when RTT=100ms. It allows enough time for an attacker to inject the malicious response in time (or inject a phishing login page as well). RTT=100ms. It goes up to 97.5% when the experiment is conducted in the university network where RTT=70ms. The failed cases are mostly due to packet loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>As shown in</head><p>The second attack is based on the observation that multiple requests are issued over the same TCP connection to the Facebook site. Even if the attacker is not able to infer the sequence number in time to inject response for the first request (e.g., Facebook may improve the server processing time in the future), he can still perform inference for the second request. Specifically, if the user visits the root page on Facebook, the browser on one of the Android phones (Samsung Captivate) will send two HTTP requests: the first request is asking for the recent news; the second request seems to be related to prefetching (e.g., retrieving the friend list information in case a user clicks on any friend for detailed information).</p><p>Since there is a delay of about 1s between the end of the first request and the start of the second request, an attacker can monitor if the sequence number remains the same for a certain period of time to detect the end of the first response. Furthermore, the second request takes about 100ms to process on the server. A simple strategy that an attacker can employ is to just wait for around 1.1s before injecting the malicious response for the second request. A more sophisticated attacker could also monitor the start of the second request by tracking the current ACK number. Specifically, when the second request is sent, the valid ACK number range moves forward by the number of bytes in the request payload.</p><p>In our proof-of-concept implementation, we always inject the Javascript after waiting for a fixed amount of time after the connection is detected, which can already succeed for a few times. However, a more sophisticated attacker can definitely do better.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Phishing Facebook Login Page</head><p>We launch this attack based on passive TCP hijack which passively monitors if a new connection to Facebook is made. In this case study, we look at how to replace the Facebook login page by resetting the Facebook immediately after it has responded with SYN-ACK.</p><p>We assume that the user is not already logged in to Facebook. Otherwise, as described in the previous attack, the server processing delay for the first HTTP request is so long that is is too easy to succeed. When the user is not logged in, the server processing delay will become negligible and the effective time window for reset to succeed is basically a single round trip time. This scenario is also generic enough that the attack can be applied for many other websites such as twitter.com.</p><p>In Table <ref type="table">2</ref>, we show how likely the attack can succeed under different conditions. For instance, when there's a single Planetlab node, the success rate is a little below 50%. However, when we use two nodes for latency values of 70ms and 100ms respectively, the success rate increases significantly to 62.5% and 82.5% , indicating that we have more bandwidth to reset the server. In addition, the result also verifies that the larger the RTT, the more likely the attack can succeed.</p><p>Note that the 100ms RTT to Facebook may sound very large given the popularity of CDN services. However, the CDNs are mostly used for hosting static contents such as images and Javascripts. For webpages that are highly customized and dynamic (e.g., personalized Facebook news feed), they are very likely to be stored on the main server in a single location (e.g., Facebook main servers are hosted in California). We find that this is a common design for many sites with dynamic contents (e.g., twitter).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Command Injection on Windows Live Messenger</head><p>Leveraging server-side TCP injection described in §4.4, the case study of command injection attack on Windows Live Messenger is an interesting example of server-side attack carried out on a connection where the user is already logged in. The main connection of Windows Live Messenger runs on port 1863 and uses Microsoft Notification Protocol (MSNP) which is a complex instant messenger protocol developed by Microsoft <ref type="bibr" target="#b6">[6]</ref>. Many Windows Live Messenger clients on Android as well as the ones on the desktops (including official ones) use plaintext in their connections, thus allowing the attack. Once upon the detection of a vulnerable Windows Live Messenger app running or a connection established to known port numbers and IP addresses that are associated with the app, an attacker can launch this attack.</p><p>We have verified that the commands that are possible to inject into the server include, but not limited to, (1) adding a new friend or removing an existing friend (specified by the account email address), (2) changing the status messages, and (3) sending messages to friends. Given that the messenger client is idle most of the time and the fact that the clientside sequence number inference only takes 2-3 seconds, the attack can be launched fairly easily. The commands can cause serious damage. For instance, the add-friend command allows an attacker to add its malicious account as a friend which can subsequently send spam or phishing messages. In addition, after being added as a friend, the attacker can read the friend list (email accounts) of the victim user, delete them, or spam them. Finally, new status posting can be part of the phishing attack against the friends as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Restricted Facebook Login Page Hijack</head><p>This attack is launched based on active TCP hijack as described in §4.5. The goal of this attack is still to hijack TCP connections. However, due to the lack of ability to reset the server-side connection in the new version of the Linux kernel, it requires offline analysis on the client-side ISN of the target four tuples.</p><p>In our implementation, we develop a simple Android test malware that performs the offline analysis right after it is started. The four tuples we target include a pre-selected local port and the Facebook server IP that's resolved for m.facebook.com. After the analysis, the attack takes a lit-  <ref type="table">2</ref>: Success rate of Facebook login page injection (case study 2) tle over one second, and it performs port jamming immediately (which takes about 5 seconds). After this, our malware app immediately sends an Intent that asks to open m.facebook.com through the browser. An attacker may come up with reasons such as asking a user to use his Facebook account to register for the app. When the browser starts the connection to Facebook, the malware works with the off-path attacker to hijack the connection (as described in §4.5). We have verified that the Facebook login page can indeed be hijacked following these steps.</p><p>The main difficulty in this attack is not about successfully inferring the sequence number. Instead, it requires the user to be convinced that the app indeed has a relationship with the target website (i.e., Facebook) so that the user will enter his password into the browser.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION AND CONCLUSION</head><p>From these real attacks, there are a few lessons that we learn: (1) Even though OS statistics are aggregated and seemingly harmless, they can leak critical internal network/system state through unexpected interactions from the on-device malware and the off-path attacker. Similar observations have been made recently in a few other studies as well, e.g., using procfs as side channels <ref type="bibr" target="#b22">[22]</ref>. Our study reveals specifically that the packet counters can leak TCP sequence numbers. (2). Our systems today still have too much shared state: the active TCP connection list shared among all apps (through netstat or procfs); the IP address of the malware's connection and other apps'; the global packet counters. Future system and network design should carefully evaluate what information an adversary can obtain through these shared state.</p><p>On the defense side, there are a few measures that may improve security: (1) always using SSL/TLS, (2) removing unnecessary global state (such as the active TCP connection list and packet counters) or only allow privileged programs to access such state, (3) providing better isolation among resources, e.g., providing a separate set of packet counters for each app. With IPv6 widely deployed, we may even provide different source IP addresses for connections in different processes on a device so that malware will not be able to learn the IP address of the connection established by another process. In the extreme case, each app may run in its own virtual machine.</p><p>To conclude, we have demonstrated an important type of TCP sequence number inference attack enabled by host packet counter side-channels under a variety of client OS and network settings. We also offer insights on why they occur and how they can be mitigated.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Threat model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Incoming packet validation logic</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: tcp send dupack() source code snippet in Linux</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Sequence number inference illustration using the DelayedACKLost packet counter (binary search)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Sequence number inference illustration using the DelayedACKLost packet counter (four-way search)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Retransmission check source code snippet from tcp data queue() in Linux</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Tradeoff between inference speed and overhead</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: Relationship between RTT and inference time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Active TCP hijacking sequence</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>RT T b =70ms1 RT T b =100ms RT T b =70ms RT T b =100ms Succ Rate 42.5% (17/40) 47.5% (19/40) 62.5% (25/40) 82.5% (33/40) 1 RT T b is the RTT between the attacker and the Facebook server Table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 ,</head><label>1</label><figDesc>the success rate is 87.5% based on 40 repeated experiments in our home environment where RT Ta is the RTT between the attacker and the client</figDesc><table><row><cell></cell><cell>RT Ta=70ms1</cell><cell>RT Ta=100ms</cell></row><row><cell>Succ Rate</cell><cell>97.5% (39/40)</cell><cell>87.5% (35/40)</cell></row><row><cell>1</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Success rate of Facebook Javascript injection (case study 1)</figDesc><table /></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.phrack.org/issues.php?issue=64&amp;id=15" />
		<title level="m">Blind TCP/IP Hijacking is Still Alive</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://www.cert.org/advisories/CA-1995-01.html" />
		<title level="m">CERT Advisory CA-1995-01 IP Spoofing Attacks and Hijacked Terminal Connections</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Golomb</forename><surname>Ruler</surname></persName>
		</author>
		<ptr target="http://en.wikipedia.org/wiki/Golomb_ruler" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://www.securityfocus.com/bid/580/info" />
		<title level="m">Linux Blind TCP Spoofing Vulnerability</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="http://kerneltrap.org/node/4654" />
		<title level="m">Linux: TCP Random Initial Sequence Numbers</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Protocol</forename><surname>Messenger</surname></persName>
		</author>
		<ptr target="http://www.hypothetic.org/docs/msn/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://tools.ietf.org/html/rfc1948" />
		<title level="m">RFC 1948 -Defending Against Sequence Number Attacks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://tools.ietf.org/html/rfc5961" />
		<title level="m">RFC 5961 -Improving TCP&apos;s Robustness to Blind In-Window Attacks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://tools.ietf.org/html/rfc793" />
		<title level="m">RFC 793 -Transmission Control Protocol</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<ptr target="http://www.puschitz.com/FirewallAndRouters.shtml" />
	</analytic>
	<monogr>
		<title level="j">Stateful Firewall and Masquerading on Linux</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Os X</forename><surname>Mac</surname></persName>
		</author>
		<author>
			<persName><surname>Manual</surname></persName>
		</author>
		<ptr target="https://developer.apple.com/library/mac/#documentation/Darwin/Reference/Manpages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<ptr target="http://wiki.hsc.com/wiki/Main/InsideLinuxTCPDelayedAck" />
	</analytic>
	<monogr>
		<title level="j">TCP Delayed Ack in Linux</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Side-channel Leaks in Web Applications: A Reality Today, a Challenge Tomorrow</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Security and Privacy</title>
		<meeting>of IEEE Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Quire: Lightweight Provenance for Smart Phone Operating Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shekhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pisetsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">PiOS: Detecting Privacy Leaks in iOS Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">TaintDroid: An Information-flow Tracking System for Realtime Privacy Monitoring on Smartphones</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Study of Android Application Security</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Octeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Idle Port Scanning and Non-interference Analysis of Network Protocol Stacks using Model Checking</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ensafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kapur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Crandall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Permission Re-delegation: Attacks and Defenses</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Off-Path Attacking the Web</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gilad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Herzberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Workshop on Offensive Technologies (WOOT)</title>
		<meeting>of USENIX Workshop on Offensive Technologies (WOOT)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Characterization and Measurement of TCP Traversal through NATs and Firewalls</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM IMC</title>
		<meeting>ACM SIGCOMM IMC</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Learning secrets from process footprints</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
		<author>
			<persName><surname>Memento</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Security and Privacy</title>
		<meeting>of IEEE Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Simple Active Attack against TCP</title>
		<author>
			<persName><forename type="first">L</forename><surname>Joncheray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Leech</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rayson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wilson</surname></persName>
		</author>
		<ptr target="http://www.nsa.gov/research/_files/selinux/papers/slinux/node57.shtml" />
		<title level="m">Procfs Analysis</title>
		<meeting>fs Analysis</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">A Weakness in the 4.2BSD Unix TCP/IP Software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Off-Path TCP Sequence Number Inference Attack -How Firewall Middleboxes Reduce Security</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Security and Privacy</title>
		<meeting>of IEEE Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Investigation of Triangular Spamming: A Stealthy and Efficient Spamming Technique</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Security and Privacy</title>
		<meeting>of IEEE Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Soundcomber: A Stealthy and Context-Aware Sound Trojan for Smartphones</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Intwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kapadia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Timing Analysis of Keystrokes and Timing Attacks on SSH</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Compromising electromagnetic emanations of wired and wireless keyboards</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vuagnoux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pasini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An Untold Stody of Middleboxes in Cellular Networks</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Slipping in the Window: TCP Reset Attacks</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CanSecWest</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Peeping Tom in the Neighborhood: Keystroke Eavesdropping on Multi-User Systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX Security Symposium</title>
		<meeting>of USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
