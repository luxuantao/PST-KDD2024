<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Simplified and Generalized Treatment of Luby-Rackoff Pseudorandom Permutation Generators</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Ueli</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
							<email>maurer@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Institute for Theoretical Computer Science ETH</orgName>
								<address>
									<postCode>CH-8092</postCode>
									<settlement>Zurich, Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Simplified and Generalized Treatment of Luby-Rackoff Pseudorandom Permutation Generators</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">385E5BE49EA7283B78A4D90BDAB803F7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Locally random function</term>
					<term>Pseudorandom function</term>
					<term>Pseudorandom permutation</term>
					<term>Luby-Rackoff permutation generator</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A paper by Luby and Rackoff on the construction of pseudorandom permutations from pseudorandom functions based on a design principle of the DES has recently initiated a burst of research activities on applications and generalizations of these results. This paper presents a strongly simplified treatment of these results and generalizes them by pointing out the relation to locally random functions, thereby providing new insight into the relation between probability-theoretic and complexity-theoretic results in cryptography. The first asymptotically-optimal construction of a locally random function is presented and new design strategies for block ciphers based on these results are proposed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In a celebrated complexity-theoretic paper <ref type="bibr" target="#b8">[9]</ref>, Euby and Rackoff described a construction of a pseudorandom permutation generator from any pseudorandom function generator that was motivated by a study of the Data Encryption Standard (DES, cf. <ref type="bibr" target="#b3">[4]</ref>). Much research has recently been based on this paper (e.g., <ref type="bibr">[ll]</ref>, [la], [13], <ref type="bibr" target="#b13">[14]</ref>). The main goal of the present paper is to give a simplified and generalized treatment of the results of [$I] by suggesting an informationtheoretic rather than complexity-theoretic interpretation bawd on the concept of locally random functions whose treatment is an independent goal of this paper. It is shown that the proof of the Main Lemma of <ref type="bibr">[Y]</ref>, which originally required three pages of highly technical definitions, claims and arguments, can be strongly simplified and interpreted essentially as an application of the birthday paradox, thus providing much more insight. Moreover, the central proposition of <ref type="bibr">[Y]</ref>, which was used to establish the relation between probability-theoretic arguments and complexity-theoretic results and which was unfortunately stated without proof, is shown to be unnecessary and somewhat misleading.</p><p>Local randomness is an important concept in theoretical computer science with several applications. Intuitively, a family of functions is locally random of degree k if for every set of at most k arguments, the function values for these arguments for a randomly (from the family) chosen function are independent and uniformly distributed. In other words, a randomly (from the family) chosen function behaves precisely like a truly random function as long as it is evaluated for at most k arguments. Similarly, a sequence generator is locally random of degree L <ref type="bibr">[lo]</ref> if for a randomly selected seed, every subset of k (or less) digits is completely random. Clearly, a locally random sequence generator can be obtained from a locally random function by "reading out" the function values for a given enumeration of the arguments, but the converse is not true in general because a sequence generator need not have the property that arbitrary digits can be accessed efficiently (only consecutive digits must be efficiently computable).</p><p>The usefulness of local randomness has previously been observed (e.g., <ref type="bibr">[l]</ref>,</p><p>[3], <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>) and was referred to as k-wise independence. However, our treatment is more general in that (1) families of functions that are only "almost" locally random of degree L and (2) polynomial-time computable functions with superpolynomial degree of local randomization are considered, allowing applications in complexity theory as well as for the design of practical block ciphers.</p><p>The results of Luby and Rackoff are discussed in Section 3. Locally random functions are introduced in Section 4 , and an alternative interpretation and generalization of the results of Luby and Rackoff based on this new concept are described Section 5. Some further applications of locally random functions and a new design strategy for block ciphers are discussed in Section 6 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Terminology</head><p>Our terminology is similar to that of <ref type="bibr" target="#b8">[9]</ref>. Let (0,l)" denote the set of binary strings of length n , let F" denote the set of all 2"'" functions ( 0 , l ) " -+ {0, l}", and let P" denote the subset of functions of F" that are permutations of (0, l}", i-e., invertible or one-to-one. For f1 E F" and f2 E F", fi o f2 denotes the composition of f i and fi, i.e., f1 o fz(x) = fz(f~(x)).</p><p>For two binary strings a and b, a b denotes their concatenation and when a and b have the same length, a @ b denotes their bit-by-bit ezcluszve or. The string consisting of the t rightmost bits of a string a is denoted by [.It. In particular, [ill for a non-negative integer i &lt; 2' denotes the representation of i by t bits (with possible leading zeroes).</p><p>When an argument of a function is replaced by a set of arguments this will denote the multiset of resulting function values. In all cases, a random choice of an object x from a set or multiset S of objects (denoted by x E R S ) will be such that each object is equally likely to be chosen, taking into account multiple occurrencies in multisets. We refer to Section 4 of <ref type="bibr" target="#b8">[9]</ref> for definitions of a pseudorandom number (or bit) generator (PRNG), of a pseudorandom function generator (PRFG) and of a pseudorandom permutation generator (PRPG). A</p><formula xml:id="formula_0">function f : IN -+ IN is called superpolynomial if for every polynomial Q, f(n) &gt; Q(n) for</formula><p>all sufficiently large n. Finally, # S denotes the cardinality of the set or multiset S, and all logarithms in this paper are to the base 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Luby-Rackoff Pseudorandom Permutation Generators</head><p>Levin [S] gave a construction of a PRNG from any one-way function, and Goldreich, Goldwasser and Micah [5] devised a method for constructing a PRFG from any PRNG and hence, by Levin's result, also from any one-way function.</p><p>(As a by-product of this research a simpler construction of a PRFG from any PRNG will be described in Section 4.) A PRNG can be used for encryption in a so-called additive stream cipher but a PRFG cannot directly be used for (block) encryption because pseudorandom functions are not invertible in general. Luby and Rackoff considered the problem of constructing a secure block encryption algorithm, i.e., a (secure) pseudorandom permutation generator, from any (secure) PRFG, and hence from any PRNG or from any one-way function. We refer to <ref type="bibr" target="#b8">[9]</ref> for definitions.</p><p>Motivated by the round structure of the Data Encryption Standard DES (cf. [4]), Luby and Rackoff defined a mapping H : F" x F" x F" -+ Pzn assigning every triple of functions in F" a permutation in P'". Let L and R denote the left and right half of a Pn-bit string L R and let for f E F" the permutation f E P2" be defined as</p><formula xml:id="formula_1">- - f ( L R ) = R [L CE ! ( @I ,</formula><p>i.e., the right half of the argument appears unchanged as the left half of the result and the right half of the result is equal to L @ f ( R ) . This corresponds to one round of DES. For a list of functions, f1,. . . , fs E F", let the function (actually a permutation) $(PI,. . . , fs) : (0, l}2n -+ (0, 1}2n be defined by -</p><formula xml:id="formula_2">$ ( f l , -. , f d = f l O --' O f J , -- i.e., + ( f i , . . , , f , ) ( L 0 R) = fJ(fsVl(. . .T,(L 0 R) . . -)).</formula><p>Note that H can now be defined by H(fi, fz, f3) = $(fi I f2, f3) (cf. Figure <ref type="figure">l</ref>), where</p><p>Luby and Rackoff considered the problem of distinguishing, by use of an oracle circuit, a function randomly chosen from FZn from a function randomly chosen from the much smaller set * ( F " , F", F"). An oracle circuit Czn is a circuit with oracle gates, i.e., gates with a 2n-bit input and a 2n-bit output, where all oracle gates in a circuit evaluate the same fixed function in F2" (for details see <ref type="bibr" target="#b8">[9]</ref>). Let</p><formula xml:id="formula_3">P[C,n(f)=1: ~E R +(F", F", F")] and ~[ C a n ( f ) = 1 : f ER F2n]</formula><p>denote the probabilities that Can outputs 1 if the oracle gates are evaluated for a function chosen randomly from $ ( F " , F", F " ) and from F2n, respectively. We hope that this notation, which differs slightly from that of <ref type="bibr" target="#b8">[9]</ref>, is more intuitive. The Main Lemma of <ref type="bibr" target="#b8">[9]</ref> is as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Main Lemma of [9j. Lei Czn be a n oracle circuit with k oracle gales such that no input value is repeated t o an oracle gate. T h e n</head><p>From the following discussion it will become clear that the restriction to circuits whose oracle gates must have different inputs, and hence also the proposition stated (unfortunately without proof) in <ref type="bibr" target="#b8">[9]</ref> above the Main Lemma, are unnecessary and somewhat misleading. The result can be stated a s a purely probability-theoretic result having no direct relation to complexity theory, and will in Section 5 be interpreted as a result on locally random functions.</p><p>Let g : ((0, 1)2n)k --+ {0,1} be a function taking as input k 2n-bit strings.</p><p>For a given set of k arguments z1 , .. . , zk, let in analoe to the above definitions</p><formula xml:id="formula_4">P[g(f(zi), . . . , f ( z k ) ) = 1 : ~E R $!(F". F", F")]</formula><p>and</p><formula xml:id="formula_5">p g P [ g ( f ( z l ) , . . . ~f ( $ k ) ) = l : f E R F2"] (1)</formula><p>be defined as the probabilities that g(f(zl), . . . , f(zk)) = 1 when f is chosen randomly from $ ( F " , F", F") and from F2n, respectively. Note that Pg can alternatively be defined as where r l , . . . , r k are independent and randomly selected from (0, 1}2n. Again equivalently, Pg can also be defined as</p><formula xml:id="formula_6"># ( ( r 1 , . . ., r k ) E ((0, I)'")~ : g(rl.. . .:n) = 1) Pg = 22nk</formula><p>Clearly, Lemma 1 is also true for every function g : ({o,~)"")' -{0,1) with k' &lt; k. It demonstrates that there exists no set of k arguments, whether adaptively chosen or not, and whether distinct or not, that would allow an oracle circuit with these arguments as the inputs to the oracle gates to achieve</p><formula xml:id="formula_7">I P [ c z n ( f ) = l : f E R $(F"I F", F n ) ] -p [ c zn(f)=1: f E R F q &gt; k2/2".</formula><p>The Main Lemma of <ref type="bibr" target="#b8">[9]</ref> is hence an immediate consequence of Lemma 1. (It is easy to see that the converse is also true.) Moreover. it is obvious that probabilistic strategies cannot be better than deterministic ones for distinguishing a function from a random function since the deterministic function g could be defined as that resulting for the optimal choice of the randomizer.</p><p>Proof of Lemma 1. Let fi , fi and f3 be functions randomly chosen from F", and let f = +(.fl, fz, f3). Let 2 , = Li R, for 1 5 i 5 k be the k arguments of f, and define Si, and V, for 1 5 i 5 k as follows (cf. Figure <ref type="figure" target="#fig_0">1</ref> ) : and v = f3(T1) @Si.</p><p>Note that when the evaluation o f f for the argument z i is viewed as a threeround process (similar to three rounds of DES), the outputs of the first, second and third round are R, 0 Si, Si 0 T, and Z K = f (Li 0 R,), respectively. We may for the rest of the proof assume without loss of generality that the z j , 1 5 i 5 k, are distinct. Choosing identical arguments provides no new information and can thus certainly not help. is the union of the (i) events {S; = S;) for 1 -&lt; i &lt; j 5 E and the (i) events {T, = T j ) for 1 5 i &lt; j 5 k. The probability of the union of several events is upper bounded by the sum of the probabilities; and hence for i # j. By a similar argument we obtain for i # j . The total number of terms on the right side of (2) is 2(:) = k(E -1) &lt; k2. Lemma 1 follows.</p><formula xml:id="formula_8">For i # j we have 2-" if.&amp; f Rj 0 if R, = R</formula><p>An interpretation and generalization of this result based on locally random functions, which are introduced in the following section, will be presented in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Random Functions and Locally Random Funct ions</head><p>A random function r : (0,1}" -+ ( 0 , l ) " is a function that assigns to all arguments 2 E (0,l)" independent and completely random values r(z) E (0, l}".</p><p>The trivial implementation of a random function as a table requires the generation of n2" random bits during a precomputation phase and n2" bits of memory to store the table.</p><p>A random function can alternatively be implemented as a device (or procedure) that, when given as input an argument z that was never given before, generates a random output r(z) and stores the pair (2, r ( x ) ) in a table ordered according to z, and when. given as input an argument z for which r was previously evaluated, outputs ~( z )  stored in the table. An advantage of the latter implementation is that when r needs to be evaluated for at most t arguments, 2tn bits of memory are required and at most 2tn random bits need to be generated. However, the computation time for each argument is O(1ogt) compared to 0(1) for an implementation based on a pregenerated table (of exponential size), and hence depends on the number t of arguments.</p><p>When the computation time of an algorithm accessing a random function, implemented as described above, is polynomially (in n) bounded, so are the total computation time and memory requirements of the resulting algorithm, including the random function. In other words, although a random function seems at first to require an exponential amount of memory, any polynomial-time algorithm using random functions can be implemented in polynomial time and polynomial space. This observation is the key argument of the proof of Theorem 1 of <ref type="bibr" target="#b8">[9]</ref>. We would like to point out (without making further use of this result) that the same observation can be used to present a construction of a PRFG from a PRNG that is much simpler (albeit less practical) than that proposed by Goldreich, Goldwasser and Micali <ref type="bibr">[5]</ref> for proving the following proposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1 [5]. Pseudorandom function generators exist i f and only i f pseudorandom number generators exist.</head><p>Randomness is often an expensive and limited resource. Moreover, a dependence of the function evaluation time and memory requirement on the number t of arguments for which a function is evaluated is most often intolerable. Therefore, an important concept is that of a locally random function, i.e., a function that behaves like a random function as long as it is evaluated for at most k arguments for some parameter k. Definition 1. A family Fz = (fz : z E 2) of functions fz : (0, 1)" -+ (0, l}m is an ( n , m, k) locally random function <ref type="bibr">(LRF)</ref> with key space 2 if for every subset {XI, I . . , zk} of (0, l}", f Z ( q ) , . .</p><p>. , f z ( z k ) are uniformly distributed over (O,l}"' and jointly statistically independent, when z is randomly selected from 2 .</p><p>F'2 could alternatively be viewed as a single function 2 x (0,1}" --+ (0, I}*.</p><p>A random function (0,l)" -+ (0, I}" is an ( n , n , 2n) LRF. The restriction to binary digits is made without essential loss of generality. The above definition is purely combinatorial, i.e., no restriction on the computation time is made.</p><p>LRFs will be generalized below to take into account both minor deviations from c.omplete randomness of any k function values and efficient (i.e., polynomial-time) computability. An important question is for which choices of parameters n, rn, L and 1 2 1 there exist LRFs. Because it is impossible to expand deterministically a sequence of random bits into a longer sequence of (independent) random bits, it is obvious that for an (n, m , k) LRF with key space 2, must hold. It may appear to be somewhat surprising that, for any n , m and k with rn = n or m a multiple of n , equality in (4) can be achieved. This follows from the folIowing well-known proposition, which can be proved by observing that the d+ 1 coefficients of a polynomial of degree d over a field can be interpolated from any set of d + 1 arguments and the corresponding polynomial values.</p><p>When m &lt; n, equality in (4) cannot be achieved. For the sake of completeness we state the following proposition, which is an immediate consequence of Theorem 1 in <ref type="bibr">[lo]</ref>. Let Z = {0,1}", i.e., the key consists of v binary digits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3. There exists a ( n , r n , L ) LRF if</head><formula xml:id="formula_9">V mk 5 n + h g v n and there exists no ( n , 1, k) L R F if 2(v + n + 1) ' n -l o g z v + l '</formula><p>In order to state our results on PRFGs and PRPGs in terms of LFFb, we need to generalize the concept of LRFs in two different ways. As a first generalization, the condition of true randomness of any k function values must be somewhat relaxed. Instead of introducing the new concept of "almost" locally random functions we generalize LRFs by introducing a fourth parameter, 6 , believing that this generalization will be intuitive rather than ambiguous. (Note that a  <ref type="figure">,</ref><ref type="figure">a (n,</ref><ref type="figure">m ,</ref><ref type="figure">k,</ref><ref type="figure">E</ref> ) LRF can easily be modified by deleting some output bits to yield a (n, m', L, E ) LRF for any rn' &lt; rn. Conversely, a (n, cm, k, E ) LRF with key space 2" can for c &gt; 1 be obtained from a ( n , m , k, 6) LRF Fz with key space 2 by a simple concatenation of c copies of Fz with independent keys.</p><p>A second generalization of LRFs is necessary in order to be consistent with other asymptotic definitions in complexity theory, in particular those used in <ref type="bibr" target="#b8">[9]</ref>.  <ref type="figure">is a (n,</ref><ref type="figure">n ,</ref><ref type="figure">k(n),</ref><ref type="figure">~( n )</ref> )</p><p>LRF with key space (0, l]'(n) that is (for every given argument and key) computable in time polynomial in n, independent of the number of previous evaluations, where <ref type="bibr">~( n )</ref> vanishes faster than l/Q(n) for every polynomial Q(n) (i.e., l / ~( n ) is superpolynomial in n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Complexity-theoretic Applications of Locally Random Functions</head><p>The construction of [9] for a PRPG is based on the following observation which can be formalized. Let T be a LRFG (or LRPG) with key length function l ( n ) whose degree of local randomization k ( n ) is superpolynomial in n (which implies that I(n) is superpolynomial in n). Let T' be the PRFG (or PRPG) resulting from T when the n l ( n ) random bits are substituted by a function generator G generating the corresponding amount of (pseudorandom) bits. Then T' is a PRFG (or PRPG) under the assumption that G is a PRFG.</p><p>For PRFGs, this construction seems to be of little value because a PRFG is required for constructing another PRFG. For the case of a PRPG, however, this observation allows to relax the problem of constructing a PRPG t o the two problems of constructing a PRFG and a LRFG with superpolynomial degree of local randomization that is also a permutation generator.</p><p>For the construction of a LRF described in Proposition 2, the evaluation time is proportional to the degree k of local randomization because for every z, #(z) depends on every internal random bit, i.e., on all the coefficients of the polynomial p ( z ) . A different construction for which every function value depends only on an negligible fraction of the key bits must hence be used for obtaining a superpolynomial degree k of local randomization while retaining the polynomial evaluation time, as is required for a generalized interpretation of the Luby-Rackoff results. Before presenting such constructions we point out that the mapping H : F" x F" x F" + P2" gives a construction of LRFGs from other LRFGs.</p><p>Theorem 1.</p><formula xml:id="formula_10">@(&amp;, Fz, Fs) is u (272,272, k, c) L R F f o r all k, where E = k22-" + €1 + €2 + €3,</formula><p>Let 3 , for i = 1,2,3 be three independent ( n , n , k , c i ) LRF's.</p><p>Proof. The fact that 3i is a (n, n, k , ci) LRF can be expressed as <ref type="bibr">(5)</ref> where Pg is defined in (1) with F2" replaced by F". Since using a randomized strategy for distinguishing 3 i from a random function cannot be better than using the best deterministic function g, as mentioned before, inequality (5</p><formula xml:id="formula_11">) implies that lP[g(f( 21 ) 7 . . ., f ( zk )) = 1 : f E R d'(F" F" F" )] -P[g(f(Zl), . . -, f ( Z k ) ) = l : f E R $'(319Fn,Fn)]1 5 €1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and and</head><p>The proof is completed by combining these three inequalities with Lemma 1 and observing t h a t these four probability differences define four adjacent (but possibly overlapping) subintervals of [0,1] whose total span can be at most the sum of the four interval lengths. 0 Note that the functions of $(31, Fz, T-3) are actually permutations. Lemma 1 follows immediately as a corollary of this theorem since F" with key space {0, l}n2n is an ( n , n, 2", 0) LRF.</p><p>Instead of implementing the functions f1, fz, fa in the Luby-Rackoff construction H ( f 1 , fi! f3) directly as some pseudorandom functions, the construction I? can be applied iteratively. For instance, a pseudorandom permuta- tion f : (0, l}4n --r (0, 1}4" can be implemented as f = H ( f l , f Z , f 3 ) where fij are pseudorandom functions (0, 1)" ---+ (0, l}". Let fl = H(f11, f12, f13), f 2 = H(fZ1, f 2 2 , f23) and f 3 = H(f31, f32, f33) and where H(") : (F")3a --+ p2.n be the s-fold iterative application of the Luby-Rackoff construction H which requires 3" functions {0,1)" -+ (0,l)" as inputs. The following Corollary to Theorem 1 gives a characterization of this iterative construction as a result on locally random functions.</p><p>Corollary 1. When H ( " ) is applied t o 3s dependent ( n , n, k, 6 ) LRFs then the resulting function is a (2'71, 25n, k, 8) LRF where 8 = k2 Cf=l 3i-12-2'-'n+35~.</p><p>Although the mapping H serves the originally intended purpose of proving an important complexity-theoretic result , randomness is used wastefully: The degree of local randomization is only on the order of the square root of the number of key bits. The best (in terms of efficient use of key bits) previously known asymptotic construction is the LRFG {4(Fn, F", Fn, F", F") : n E IN} with superpolynomial degree of local randomization and with key length function I(n) = 5n2", which was proved in <ref type="bibr">[ll]</ref> to have degree k</p><formula xml:id="formula_12">(n) = Q(22"/3) = !2(I(n)2/3) of local randomization.</formula><p>In the following we present an alternative construction of LRFGs that achieves a local randomization of degree k ( n ) = R(l(n)") for any a &lt; 1. Such LRFGs lead to alternative constructions of PRFGs and PRPGs based on PRFGs.</p><p>: (0, l}t -(0,l)" for 1 5 i 5 d be random functions, let c = [log2 4 and let P be a (n + c, t , 2d) LRF. For example, P could be implemented as P(() = k(&lt;)lt (the t least significant bits ofp(t)), where p is a polynomial p ( u ) = P2d-1U2d-1+* . .+PI u+po of degree 2 d -1 over GF(2"+') and the key of P consists of the 2d coefficients Proof. Let aij, 1 5 i 5 d , 1 5 j 5 k be the input to function r, when F(") is evaluated for the j t h argument z, . Let E be the event that for every x i l 1 5 j 5 L, there exists an i,, 1 5 ij 5 d, such that uijj # aijm for all rn # j . If E occurs, then for 1 5 j 5 k at least one of the terms in the sum forming fz(zj) is a random variable that is completely random and independent of all the other terms occurring in the evaluations of fz(q), . . . , fZ((zk), and hence fi (XI), . . . , fz ( z k ) are independent and completely random. The complementary eventzistheunionover l _ &lt; j _ &lt; k a n d o v e r m ; ~{ l , ..., j -l , j + l , ..., k}for 1 5 i 5 d of the k(kl)d events {u;, = aim, for 1s i 5 d } .</p><p>Because the U i j are 2d-wise independent, each of these events has probability 2-d' and hence</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P[q 5 kd+'2--dt . o</head><p>The following argument demonstrates that the construction of Theorem 2 yields an asymptotically optimal IocalIy random function. Let</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B = { F ( ~)</head><p>: n E IN), <ref type="bibr" target="#b5">(6)</ref> where F(") is the LRF from Theorem 2 with d = t and t is any function of n such that 2 t / t is superpolynomial in n. For instance, t ( n ) = [(logn)lf61 for some fixed 6 &gt; 0. The key length function of is One can prove that even when P I , . . . , pd are taken to be the same random function r : (0,l)' -+ ( 0 , l ) " rather than independent random functions, the resulting family of functions is a LRF also satisfying k(n) = n(l(n)") for any a &lt; 1. </p><formula xml:id="formula_13">l ( n ) = 2t(n + pog,t]) + 2$tn = e(2'tn).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Concluding Discussion</head><p>An important application of locally random functions is in the area of probabilistic algorithms, where randomness is often an expensive resource and therefore simulated by a pseudorandom generator with a random seed. In the analysis of a probabilistic algorithm that uses blocks of random bits at various stages it is sometimes sufficient to require that the random blocks be only k-wise independent rather than jointly independent. For instance, the "birthday paradox" holds not only for independent random birthdays but also when the birthdays are only pairwise independent. Furthermore, pairwise independence of a set of random variables is sufficient for proving that the variance of the sum of the random variables equals the sum of the variances (e.g., see <ref type="bibr" target="#b2">[3]</ref>).</p><p>Local randomness has also several applications in cryptography. A first (in the author's opinion misinterpreted) cryptographic application is the design of cipher systems "provably secure" against enemies with unlimited computational resources. Schnorr <ref type="bibr" target="#b12">[13]</ref> suggested to simulate the random keystream of the onetime pad by a keystream that is only locally random. If an eavesdropper can examine at most k (arbitrarily chosen) bits of the keystream, where k is the degree of local randomization, such a system offers the same perfect security as the one-time pad, even if the eavesdropper has infinite computing power. Of course, as is pointed out in <ref type="bibr">[lo]</ref> where Schnorr's idea is generalized, the drawback of such a system is that clearly k cannot be greater than the length of the secret key (the seed) and thus the assumption that an eavesdropper cannot obtain more than k keystream bits is generally completely unrealistic. Another example is the "provably secure" block cipher described in <ref type="bibr" target="#b13">[14]</ref> which suffers from an even stronger weakness because the number of plaintext-cryptogram pairs an eavesdropper is allowed to obtain is upper bounded by only the square root of the key size. Loosely speaking, an enemy is guaranteed to spend at least 100 years breaking the cipher if the user of the system is willing to spend 10'000 years for only loading the secret key into the system. Clearly, if such a long secret key were available, the users would be better off using a one-time pad to begin with.</p><p>A related but much more important cryptographic application of local randomness is the design of conventional cryptographic algorithms using a secret key of only moderate size. The basic idea, which could be further formalized, is to design a system that uses an (impractically) large amount of secret random bits and to prove it secure against enemies with unlimited computational resources for a suitable definition of security. If the random bits are replaced by pseudorandom bits generated by a pseudorandom number generator or a pseudorandom function generator with only a short secret key, the system can clearly not retain its unconditional security. However, failure of this modified system to be computationally secure for the same definition of security implies failure of the pseudorandom (number or function) generator to be computationally indistinguishable from a random generator since any breaking algorithm for the cryptosystem would yield a distiguishing algorithm for the pseudorandom generator. Therefore, the modified system can be proved secure under the as- sumption that the component pseudorandom generators are secure. Although no pseudorandom generator has been proved secure, to rely on such an unproven assumption may be worth-while as it allows to clarify the principles on which a cipher's security is based.</p><p>The most trivial and widely used application of the described idea are conventional additive stream ciphers which can trivially be "proved" secure under the assumption that the keystream generator is a pseudorandom number generator according to <ref type="bibr">[a]</ref>. Another less trivial application is for the design of block ciphers. A block cipher can be obtained from an efficiently computable locally random function by replacing the random bits by one or several pseudorandom function.</p><p>A further cryptographic application of local randomness may be for the key scheduling in secret-key ciphers where a relatively short key must be stretched to a sequence of subkeys (e.g. round keys of a block cipher).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Computation of $(fllf2,f3)(111</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3 )</head><label>3</label><figDesc>,. P[S; = S;] = Note that when R, = Rj, then P[Si = Sj] = 0 since by Lj Rj and hence Li # L j . Equation (3) shows that (assumption Li R, # P[Si = Sj] 5 2-"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Proposition 2 .</head><label>2</label><figDesc>Let PO,. . . , p k . -1 be randomly selected n-bit strings. The function p : (0, l}n -(0,l)" : 5 H p ( z ) = pk-&amp;l + . . . + p1z +PO, where all quantities are considered as representations of elements of the finite field GF(2"), is a (n, n, A) LRF with minimal key space 2 = {0, l}kn.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(n, rn, k, 0) LRF w i l l be the same as a (n, m , k) LRF.) Definition 1'. A family 3i = {fz : z E 2 ) of functions f z : {O,l}" -+ (0, l}m is an (n, m, k, c) locally random function with key space 2 if for all functions g : ((0, l}m)k --t {0,1} and for every subset (21,. , . , zk} of (0, l}n, for z randomly selected from 2, Ip[g(.fz(zl), * . . 3 f z ( r k ) ) = 1 3p [ g ( r l , . . . Tk) = 111 5 6 , where 71,. . . , Tk are independent and randomly selected from (0, lIffl Note that Clearly, an (n, m, k, E ) LRF is also an (n, m, k', 6') LRF for every k' 5 k and 6' &gt;_ E . Moreover</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 2 .</head><label>2</label><figDesc>A locally random function generator (LRFG) with key length function l(n) and degree of local randomization k(n) is a family T = { F ~o , l l , ~ : n E IN}, where T ~o , l l l c , , ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>p 2 dTheorem 2 .</head><label>22</label><figDesc>-1 , . . . , po. The total number of random bits required for implementing r and P is hence I(n) = 2tdn + 2d(n + c ) . The family offunctions F(") = {fz : z E ( 0 , l)'(")) defined by Let d be a parameter of the following construction, let d-1 f&amp;) = c T i ( P ( + [ ~I e ) ) , i = O where the sum is bit-wise modulo 2 andthe l ( n ) = 2'dn + 2 d ( n + c ) bits of z are used in some m a n n e r t o implement the functions ri and as the key of P , i s a ( n , n, k , 7 ( k ) ) LRF f o r all k, where y(k) = t d + 1 2 -d r .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fork</head><label></label><figDesc>(n) = 2'('-1)/(*+')we have y(k) = 2-$. It is straight-forward to prove that for all (Y &lt; 1 and thus we have the following result. Corollary 2. I? as defined i n (6) i s a LRFG with degree of local randomization k(n) = R(l(n)*) f o r any Q &lt; 1. We suggest as an open problem to devise a LRFG with superpolynomial key length function l(n) and local randomization of degree k ( n ) = R(l(n)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Theorem 3 .</head><label>3</label><figDesc>The family offunctions F(*) = {fz : z E ( 0 , l}r(*l} defined by d-1 f z ( 4 = c P(P(3: [ilc)), i = O where the I(n) = 2tn + 2d(n + c) bits of z are used in some manner t o implement the function I-and as Ihe key of P , is a ( n , n , k , y ( k ) ) LRF, where 7 ( k ) = kd+1(2d2-t)d, f o r all t 2 m.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>Jacques Patarin has independently found a different construction of a LRFG with superpolynomial key length function I(n) and local randomization of degree k(n) = Q ( / ( n ) " ) for any Q &lt; 1.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Simple constructions of almost k-wise independent random variables</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hastad</surname></persName>
		</author>
		<author>
			<persName><surname>Peralta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 91st IEEE Symposium on Foundataons of Computer Science</title>
		<meeting>the 91st IEEE Symposium on Foundataons of Computer Science</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="544" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How to generate cryptographically strong sequences of pseudo-random bits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="96" to="113" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the power of two-point based sampling</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Complexity</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="106" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
		<title level="m">Cryptography and Data Security</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ihe Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="792" to="807" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On a set of almost deterministic k-independent random variables</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Probability</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="161" to="162" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Pairwise statistical independence</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">O</forename><surname>Lancaster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math. Statist</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1313" to="1317" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">One-way functions and pseudorandom generators</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th A C M Symposium on Theory of Computing</title>
		<meeting>17th A C M Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="363" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIA M Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Local randomness in pseudo-random sequences</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="135" to="149" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An extract appeared in: J . Patarin, New results on pseudorandom permutation generators based on the DES scheme, Advances in Cryptobgy -CRYPTO&apos;91</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Etude des gknhrateurs de permutations bas&amp; sur le Sch4ma du D.E.S</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Le Chesnay, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991. 1992</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="301" to="312" />
		</imprint>
		<respStmt>
			<orgName>INRIA, Domaine de Voluceau</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">How t o construct pseudorandom permutations from single pseudorandom functions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT&apos;SO</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">B</forename><surname>Damgdrd</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">473</biblScope>
			<biblScope unit="page" from="140" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the construction of random number generators and random function generators</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT&apos;BB</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Gunther</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">330</biblScope>
			<biblScope unit="page" from="225" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Impossibility and optimality results on constructing pseudorandom permutations</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Matsumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Imai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Cryptology -Eu-Rocrypt'89</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">434</biblScope>
			<biblScope unit="page" from="412" to="421" />
			<date type="published" when="1990">1990</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
