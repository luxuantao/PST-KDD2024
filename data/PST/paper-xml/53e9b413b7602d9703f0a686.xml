<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">COnto-Diff: generation of complex evolution mappings for life science ontologies q</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012-05-08">8 May 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Michael</forename><surname>Hartung</surname></persName>
							<email>hartung@izbi.uni-leipzig.de</email>
						</author>
						<author>
							<persName><forename type="first">Anika</forename><surname>Groß</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Erhard</forename><surname>Rahm</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Interdisciplinary Center for Bioinformatics</orgName>
								<orgName type="institution">University of Leipzig</orgName>
								<address>
									<addrLine>Härtelstraße 16-18</addrLine>
									<postCode>04107</postCode>
									<settlement>Leipzig</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Leipzig</orgName>
								<address>
									<postBox>P.O. Box 100920</postBox>
									<postCode>04009</postCode>
									<settlement>Leipzig</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Leipzig</orgName>
								<address>
									<postBox>P.O. Box 100920</postBox>
									<postCode>04009</postCode>
									<settlement>Leipzig</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">COnto-Diff: generation of complex evolution mappings for life science ontologies q</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-05-08">8 May 2012</date>
						</imprint>
					</monogr>
					<idno type="MD5">640034603571E6FCA4B37BBC3645C787</idno>
					<idno type="DOI">10.1016/j.jbi.2012.04.009</idno>
					<note type="submission">Received 25 July 2011 Accepted 7 April 2012</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Ontology evolution Ontology versions Diff Life science ontologies</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Life science ontologies evolve frequently to meet new requirements or to better reflect the current domain knowledge. The development and adaptation of large and complex ontologies is typically performed collaboratively by several curators. To effectively manage the evolution of ontologies it is essential to identify the difference (Diff) between ontology versions. Such a Diff supports the synchronization of changes in collaborative curation, the adaptation of dependent data such as annotations, and ontology version management. We propose a novel approach COnto-Diff to determine an expressive and invertible diff evolution mapping between given versions of an ontology. Our approach first matches the ontology versions and determines an initial evolution mapping consisting of basic change operations (insert/ update/delete). To semantically enrich the evolution mapping we adopt a rule-based approach to transform the basic change operations into a smaller set of more complex change operations, such as merge, split, or changes of entire subgraphs. The proposed algorithm is customizable in different ways to meet the requirements of diverse ontologies and application scenarios. We evaluate the proposed approach for large life science ontologies including the Gene Ontology and the NCI Thesaurus and compare it with PromptDiff. We further show how the Diff results can be used for version management and annotation migration in collaborative curation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Ontologies have become increasingly important, e.g., to semantically and consistently annotate and categorize information. In life sciences, large biomedical ontologies such as the Gene Ontology (GO) <ref type="bibr" target="#b11">[12]</ref> are used to describe the functions of genes or proteins, e.g., in SwissProt <ref type="bibr" target="#b4">[5]</ref> or Ensembl <ref type="bibr" target="#b9">[10]</ref>. The ontological information is utilized in many analytical studies such as for term enrichment analysis <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b35">36]</ref>. The number of life science ontologies is continuously growing. For instance, the Open Biological and Biomedical Ontologies Foundry (OBO) <ref type="bibr" target="#b39">[40]</ref> or the BioPortal <ref type="bibr" target="#b28">[29]</ref> currently provide access to about 250 ontologies covering knowledge from different domains such as anatomy, phenotype, biological function or biochemistry.</p><p>Most life science ontologies evolve heavily to meet new requirements, correct previous design errors or better incorporate new domain knowledge <ref type="bibr" target="#b16">[17]</ref>. Hence there is a continuous release of new versions of an ontology that reflect the latest changes. The analysis of the version history reveals that important ontologies such as the Gene Ontology or the NCI Thesaurus <ref type="bibr" target="#b38">[39]</ref> doubled their size since 2004 <ref type="bibr" target="#b15">[16]</ref>. Large ontologies are typically developed and adapted collaboratively by several curators and experts <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b43">44]</ref>. For example, the Gene Ontology is maintained by a consortium with members from several international organizations and projects 1 . While ontology developers typically focus on areas of their expertise it is still valuable to them to know the overall changes of the ontology that have already been applied.</p><p>In this paper we propose a new approach to automatically determine the changes between two given versions of an ontology. The changes are collected within a so-called diff evolution mapping which is helpful for ontology developers, ontology users and applications:</p><p>Ontology developers can see from the diff result how the ontology has evolved and what changes are dominating. In collaborative ontology development, it is important for both the coordinators as well as individual developers to exactly know what changes have already been performed and what changes may still be missing. Previous changes may in fact serve as a starting point for further modifications. Early approaches such as the Protégé plugin PromptDiff <ref type="bibr" target="#b31">[32]</ref> already show the need to determine ontology changes to support collaborative ontology development.</p><p>The computed evolution mapping can be used to find out whether existing applications or analysis studies are affected by ontology changes so that they may have to be adapted or redone. For instance, ontology changes may invalidate previous findings of a term enrichment analysis <ref type="bibr" target="#b20">[21]</ref> so that the analysis may have to be repeated. The evolution mapping can support the propagation of ontology changes to ontology-dependent artifacts such as annotations or ontology mappings. For instance, curators of annotations can quickly find and remove outdated annotations referring to deleted or obsolete ontology concepts <ref type="bibr" target="#b15">[16]</ref>. Annotation curators may also collaboratively decide about how to deal best with ontology changes. Evolution mappings can be used to optimize the management of ontology versions by only storing the version differences instead of the entire ontology versions <ref type="bibr" target="#b22">[23]</ref>.</p><p>Our approach to determine the Diff between ontology versions is based on a previous matching of ontology versions which determines semantic correspondences between equivalent concepts. There has been a huge amount of research on semi-automatic ontology matching in the last decade <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b37">38]</ref> (see Section 2), and we can therefore leverage existing approaches to (semi-) automatically find correspondences. While Match focuses on the unchanged ontology elements, Diff also has to consider added and deleted ontology elements. Simple changes on individual ontology elements (concepts, relationships) and their additions/ deletions are relatively easy to find and supported by current developer tools such as OBO-Edit <ref type="bibr" target="#b7">[8]</ref> or OBO Explorer <ref type="bibr" target="#b0">[1]</ref>. However, we observe that such low-level mappings represented by long lists of primitive changes are of limited usefulness for human users. Especially for large ontologies it becomes difficult for individual curators to understand the semantics behind changes performed by others. We therefore aim at a much more compact and semantically more expressive diff representation capturing complex ontology changes such as merging, splitting and moving of ontology concepts or adding and deleting entire subgraphs. Such mappings are likely to serve much better the discussed purposes of evolution mappings, in particular for ontology developers and ontology users.</p><p>For illustration we use the running example in Fig. <ref type="figure" target="#fig_0">1</ref> on the evolution of a part of an anatomy ontology. The goal is to derive the evolution mapping between the two ontology versions. A basic Diff approach only supporting add/delete/change operations for individual ontology elements would derive a deletion of the 'accessory cochlear nucleus' and 'anterior cochlear nucleus' concepts although these concepts are actually merged into concept 'cochlear ventral nucleus'. We propose a more expressive Match-based Diff generation supporting complex changes. In Fig. <ref type="figure" target="#fig_0">1</ref>, the names of the white concepts remain unchanged during the evolution and we assume that correspondences between these concepts are part of the match result. Dashed lines indicate further relevant matching concepts. The correspondences help our Diff approach to correctly determine that the redundant concepts 'accessory cochlear nucleus' and 'anterior cochlear nucleus' have been merged into 'cochlear ventral nucleus'. The original redundancy could have been introduced by different developers and this is now corrected by a merge change. In such cases the labels of the old concepts may be introduced as synonyms in the new concept. This information can be exploited to detect concept merges. Another complex change is the addition of the sub-ontology rooted at 'brain stem white matter'. Especially for large life science ontologies it is valuable to identify such larger changed ontology portions. Further complex changes include the move of concepts 'trigeminal sensory nucleus' and 'trigeminal motor nucleus' from 'brainstem nucleus' to the new inner concept 'trigeminal nucleus'.</p><p>The contributions of this paper are as follows:</p><p>We introduce a model for diff evolution mappings between ontology versions that is based on a set of basic and complex change operations. Based on this model we present a generic Diff algorithm, COnto-Diff (Complex Ontology Diff), to automatically determine expressive (compact) diffs between given ontology versions. The approach is based on the result of a (semi-) automatic match operation. The evolution mapping is computed by a rule-based approach utilizing so-called COG (change operation generating) rules.</p><p>We propose an algorithm using the evolution mapping to migrate an old ontology version to the newer one. We can also derive an inverse evolution mapping to migrate from a changed ontology version back to the original one. This underlines that evolution mappings are executable and useful for the management of ontology versions. We also discuss how our evolution mappings can be used to update annotations and thus support annotation curators. We comprehensively evaluate our approach for large life science ontologies including the Gene Ontology and the NCI Thesaurus, and provide a comparison with the PromptDiff approach. We also show that the determined diff mappings allow a correct migration between ontology versions. The results confirm the applicability and scalability of the approach to large ontologies with many changes.</p><p>We made the functionality of COnto-Diff available within a new web tool <ref type="bibr" target="#b14">[15]</ref> so that users can interactively determine and analyze diffs between ontology versions. While COnto-Diff is based on a match step, matching is not the focus of this paper since it has already been widely investigated. We further focus on determining evolution mappings solely at the ontology level and leave related problems (e.g., instance migration) for future work.</p><p>We discuss related work in Section 2. In Section 3 we introduce our ontology model, the considered set of basic and complex changes as well as our model of match mappings and evolution mappings. COnto-Diff is presented in Sections 4 and 5. Section 4 introduces the set of COG rules to determine the change operations that occurred during the evolution. Section 5 outlines the overall approach for determining the diff evolution mapping based on the introduced COG rules. The application of the diff evolution mappings for ontology and annotation migration is explained in Section 6. We present evaluation results in Section 7. We conclude with a summarizing discussion on the strengths and current limitations of our approach and on plans for future work. The appendix provides details such as correctness proofs for the proposed algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>We first discuss related work on ontology evolution, in general. Before we describe previous approaches to determine ontology changes, we provide an overview of recent work on the related problem of ontology matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Ontology evolution</head><p>There is already a substantial amount of related work on ontology evolution (see <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref> for surveys). The Protégé tool <ref type="bibr" target="#b29">[30]</ref> supports both the development and evolution of ontologies. The evolution framework is based on a change and annotation ontology (CHAO) <ref type="bibr" target="#b30">[31]</ref> including both simple and complex changes. Changes can be specified via logging of incremental changes or by a direct ontology version comparison (see PromptDiff later). The ontology evolution process itself has been extensively studied by Stojanovic et al. <ref type="bibr" target="#b42">[43]</ref>. Oliver and colleagues <ref type="bibr" target="#b32">[33]</ref> investigate the representation of typical changes in controlled medical terminologies including additions, renaming, hierarchical changes and merges. In contrast to these works, we do not consider the active modification of ontologies but focus on determining the changes between given versions.</p><p>Tools such as OBO-Edit <ref type="bibr" target="#b7">[8]</ref> or OBO2OWL <ref type="bibr" target="#b27">[28]</ref> enable the management and development of OBO ontologies. OBO-Edit contains a commandline tool obodiff<ref type="foot" target="#foot_0">2</ref> which can compare a pair of OBO files and reports all edits that are necessary to transform the first into the second file. Furthermore, information on changes of current ontologies (history tracking) is primarily limited to mailing lists and reports by the ontology distributors. For instance, the GO consortium summarizes changes on the Gene Ontology in a monthly report. <ref type="foot" target="#foot_1">3</ref>Most of the tools and systems only report on primitive changes, e.g., additions of concepts or relationships between succeeding versions of an ontology. In contrast COnto-Diff is able to detect more meaningful, complex changes and is not restricted to succeeding versions, i.e., the input versions may be from much different points in time.</p><p>Several studies have analyzed the evolution of life science ontologies and terminologies. Study <ref type="bibr" target="#b45">[46]</ref> analyzes the evolution of GO with the help of simple change statistics on the number of concepts, relationships and paths. A more comprehensive study <ref type="bibr" target="#b16">[17]</ref> analyzes the evolution of 16 life science ontologies and associated annotations. Ceusters et al. <ref type="bibr" target="#b5">[6]</ref> have studied the evolution of SNOMED CT and found that the main changes are class modifications followed by class additions and deletions. They acknowledge the importance of a diff or history mechanism to analyze and enhance the quality of ontologies, e.g., by identifying mistakes of the past and avoiding them in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Ontology matching</head><p>Ontology matching is the process of determining a set of semantic correspondences (ontology mapping) between concepts of two ontologies O 1 and O 2 . A manual matching by domain experts is very time-consuming and for large ontologies almost infeasible. Thus, many (semi-) automatic matching algorithms have been developed for ontology matching (see <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref> for surveys). Common match approaches utilize the linguistic and structural similarity of ontology concepts; some approaches also consider the similarity of ontology instances. State-of-the art match systems such as COMA++ <ref type="bibr" target="#b1">[2]</ref>, Falcon <ref type="bibr" target="#b19">[20]</ref> or SAMBO <ref type="bibr" target="#b24">[25]</ref> combine multiple matchers within a match strategy to achieve better match quality. In general, automatically determined mappings are not perfect but should be verified and revised by human experts (semi-automatic matching). The revision process benefits from a collaborative involvement of multiple experts to speed-up mapping creation and to increase the included knowledge <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b46">47]</ref>.</p><p>Previous work on matching life science ontologies showed that linguistic matching methods based on the similarity of concept names and synonyms produce very good results <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>. This work applies such approaches to enable a largely automatic ontology matching. We also exploit the fact that matching two versions of the same ontology is facilitated by the large portion of shared identifiers between two versions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Ontology change detection</head><p>Most related to this paper are previous approaches for detecting ontology changes. They can be classified into incremental and direct ones. Incremental approaches are based on a version log of changes. For instance, <ref type="bibr" target="#b34">[35]</ref> differentiates between simple and composite changes which are defined declaratively using a Change Definition Language (CDL). Based on an available change log, the approach aims at detecting additional implicit changes by evaluating the definition of specified change operations. However, such approaches require access to a version log of an ontology which is often not possible. Furthermore, the occurrence of redundant changes in a log makes change detection between two versions difficult. Hence, we consider a direct comparison of ontology versions to determine the diff as more versatile.</p><p>The best known approach of this kind is PromptDiff <ref type="bibr" target="#b31">[32]</ref> that is part of the Protégé ontology management suite <ref type="bibr" target="#b29">[30]</ref>. It uses several heuristic matchers (e.g., single unmatched sibling, unmatched inverse slots, or same type/name) to detect changes between two ontology versions. The algorithm works iteratively and applies the heuristic matchers as long as no more changes are found. The approach supports the detection of several basic as well as complex changes including concept additions, deletions, splits and merges. The result is a difference table which lists the detected changes. Each row represents a change operation including its parameters. Changes on entire subtrees can be recognized with the PromptDiff plugin in the Protégé UI which allows users to visualize tree-level changes <ref type="bibr" target="#b30">[31]</ref>, i.e., one can notice if all classes of a subtree have changed in the same way, e.g., all were added or deleted. We will provide a more detailed comparison between PromptDiff and COnto-Diff in the evaluation (see Section 7.4).</p><p>The OntoView system <ref type="bibr" target="#b23">[24]</ref> focuses on versioning of RDF-based ontologies. It can detect simple changes such as label modifications as well as logical definition changes, e.g., changes on subClassOf relationships or domain/range properties. The algorithm is based on RDF triples and uses a graph representation as well as a set of IF-THEN statements to detect changes between versions. More complex changes such as merges or splits are not supported.</p><p>The authors of <ref type="bibr" target="#b33">[34]</ref> describe an approach to detect high-level changes such as moveClass in RDF/S knowledge bases. The pro-posed framework distinguishes between basic, composite and heuristic changes which are expressed in a formal language. The main algorithm focuses on the detection of basic and composite changes while the detection of heuristic changes such as rename, merge, or split is considered as optional. The starting point is a so-called lowlevel delta containing RDF triples that have been added/deleted between input versions V1 and V2. Changes are described by (1) required added RDF triples, (2) required deleted RDF triples and (3) a set of conditions that need to be fulfilled. The detection algorithm first uses the low-level delta and the defined change descriptions to generate a set of possible changes between V1 and V2. Afterwards the algorithm iteratively selects change operations that meet the conditions and reduces the low-level delta set accordingly. The algorithm first tries to detect composite and then basic changes. Changes on entire subgraphs cannot be recognized by the approach.</p><p>In contrast to these previous change detection approaches we adopt a two-phase Diff approach that starts with a match processing to determine corresponding concepts in the input ontology versions. We then apply a rule-based approach to determine complex ontology changes. Ontology matching is not performed in Onto-View while PromptDiff employs matching in its heuristic matchers. <ref type="bibr" target="#b33">[34]</ref> utilizes ontology matching only as an optional step but not in the main algorithm. Compared to all other approaches we distinguish between matching and diff computation and can thus flexibly adapt our algorithm to work with different ontologies or to utilize enhanced matching techniques. The proposed rule-based Diff computation supports a large set of change operations and can easily be adapted to deal with further types of changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Models and problem statement</head><p>We first introduce the assumed ontology model and describe the change operations that may be applied during ontology evolution. We then define the notions of match and evolution mappings. Finally, we state the specific problem we address with the COnto-Diff approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Ontology model and versions</head><p>An ontology O = (C, A, R) consists of concepts C having associated attributes of A. The concepts are interrelated by directed relationships of R. Each ontology concept has a special attribute called accession which is used to unambiguously identify a concept within the ontology. Concepts can have optional concept attributes a = (a concept , a name , a value ) 2 A which semantically describe the concept in more detail. For instance, life science ontologies often provide synonyms for a concept and use an 'obsolete' attribute to mark outdated concepts. R consists of a set of directed relationships r = (r source , r type , r target ) of type r type interconnecting concepts r source and r target . The most important relationship type in life science ontologies is 'is_a' describing a subsumption relation between two concepts. Another common relationship type is 'part_of' denoting an inclusion (parthood) relation. The ontology concepts connected by 'is_a' and 'par-t_of' relationships form a directed acyclic graph (DAG). Between two concepts c 1 and c 2 we allow at most one 'is_a' or one 'part_of' relationship, i.e., two coexistent relationships (c 1 , is_a, c 2 ) and (c 1 , part_of, c 2 ) are not allowed. However, concepts may have additional domain-specific directed relationships <ref type="bibr" target="#b40">[41]</ref> such as the types 'positively_regulates' or 'negatively_regulates' used in the Gene Ontology.</p><p>Our ontology model is motivated by life science ontologies that typically have no directly associated instance data. Instead sources such as Ensembl <ref type="bibr" target="#b9">[10]</ref> or SwissProt <ref type="bibr" target="#b4">[5]</ref> use ontology concepts to uniformly describe the properties of their objects (annotation). The model is comparable to the OBO format <ref type="bibr" target="#b6">[7]</ref> used to develop and distribute many life science ontologies <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b39">40]</ref>. Recent studies <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b44">45]</ref> showed how the OBO format is related to Semantic Web languages such as RDF/S and OWL and the findings also hold for our ontology model. RDF/S and OWL ontologies can be transformed into our model as follows: OWL classes correspond to our concepts, RDF/S 'subClassOf' to 'is_a' relationships, and RDF/S labels to the concept names. RDF/S properties can be converted into attributes, e.g., synonyms, or further relationships such as 'part_of'. Thus, we can also determine diffs for OWL ontologies. However, not all OWL constructs can be mapped into appropriate OBO constructs (e.g., property restrictions) so that we currently do not support the full OWL language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An ontology version</head><formula xml:id="formula_0">O v = (C v , A v , R v ) of version v represents a</formula><p>snapshot of an ontology at a specific point in time. The elements of O v are assumed to be valid until a new ontology version is released. Ontology providers distribute new releases at regular time intervals or whenever a significant number of changes has been incorporated. For instance, the GO Consortium daily releases a new version of the popular Gene Ontology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Change operations</head><p>We consider two sets of change operations for ontology evolution: basic changes (set B op ) and complex changes (set C op ). The presented operations are supported by our current design and implementation. While the sets of possible changes are already comprehensive our approach is flexible and customizable by supporting the addition of further change operations to deal with specific requirements.</p><p>Table <ref type="table">1</ref> gives an overview of the changes that are currently supported by COnto-Diff. Basic changes are applied on a single concept, attribute or relationship and deal with either a map (change), addition or deletion resulting in nine operations displayed in the upper part of the table. All other changes are called complex changes and are shown in the middle/ lower part of the table. As we will see they are based on basic changes or other complex changes and thus specify changes at a higher level of abstraction. Some of the complex changes operate on single elements (denoted with lower case letters), e.g., substitute. Most of our complex changes refer to multiple ontology elements (sets denoted with upper case letters), e.g., merge or addSubGraph. For example, the merge of source concepts 'accessory cochlear nucleus' and 'anterior cochlear nucleus' into target concept 'cochlear ventral nucleus' in our running example can be described as mergeðfaccessory cochlear nucleus; anterior cochlear nucleusg; cochlear ventral nucleusÞ: Some of the changes such as merge, split and move are generally useful and not limited to life science ontologies. Complex changes w.r.t. entire subontologies such as addSubGraph are especially valuable for large life science ontologies to compactly describe the evolution. Finally, the changes toObsolete and revokeObsolete are useful to identify the concepts that should not be used anymore or for which the obsolete status has been withdrawn.</p><p>Complex change operations can be implemented by a series of basic change operations. For each complex change we maintain the simpler underlying changes (see end of Section 4.3 for more details). Furthermore, each change operation has an inverse that undoes the effect of the change. For instance, the inverse of merge(Source_C, target_c) is split(target_c, Source_C), i.e., a single source concept is split into multiple target concepts (for the inverses of all change operations see Table <ref type="table">1</ref>). This symmetry of change operations allows us to derive for every change operation the associated inverse change operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Match and evolution mappings</head><p>We represent changes between two ontology versions O old and O new as a mapping. In model management <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> a mapping map(O old , O new ) connects elements of an old ontology version O old with elements of a new version O new . We distinguish between a match mapping match(O old , O new ) and an evolution mapping diff(O old , O new ). Match mappings represent semantic correspondences between two ontology versions and thus interrelate unchanged elements as well as changed but corresponding (semantically equivalent or related) ontology elements. For our purpose, we only require simple match mappings consisting of correspondences interlinking two concepts each, i.e., match</p><formula xml:id="formula_1">(O old , O new ) = {matchC(c1, c2)jc1 2 O old , c2 2 O new }.</formula><p>By contrast an evolution mapping highlights the differences and covers all changes that occurred between two ontology versions. Unchanged ontology elements included in a match mapping are not part of an evolution mapping. Diff mappings can contain all change operations as introduced in the previous section:</p><formula xml:id="formula_2">diff(O old , O new ) = {chgOp(e1, . . .)jchgOp 2 B Op [ C Op }.</formula><p>The simplest kind of diff mapping, diff basic , only contains basic change operations, i.e., map, add and delete operations: diff basic (O old , O new ) = {chgOp (e1, . . .)jchgOp 2 B Op }. However, the main goal is to derive a semantically expressive diff specifying the occurred evolution by complex changes as much as possible. This final diff compact therefore should contain only the semantically most expressive change operations which are not part of any other change operation. As the name suggests, diff compact (O old , O new ) will generally have fewer operations than the corresponding diff basic since a complex change typically replaces several basic changes. We also want to determine the inverse evolution mapping that can be used to migrate O new to O old . We will use the inverse of the change operations in diff(O old , O new ) to create the inverse mapping and show that it is equivalent to diff(O new , O old ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Problem statement</head><p>The problem that we investigate in this paper is the following. For two given ontology versions O old and O new of the same ontology and a match mapping match(O old , O new ) the task is to compute the basic evolution mapping diff basic (O old , O new ) and a semantically expressive evolution mapping diff compact (O old , O new ) as well as their inverse mappings. The Diff algorithm should be able to recognize any defined change operation. The evolution mappings should be complete and minimal. In particular, they should contain all changes between the two input versions so that the new (old) ontology version can be constructed from the old (new) ontology version and the (inverse) diff evolution mapping. Furthermore, diff basic (O old , O new ) should only contain those basic changes that are required for a correct version migration. Analogously, diff compact (O old , O new ) should only contain change operations that are not included in any other complex change operation, i.e., the most compact set of changes between O old and O new w.r.t. the defined set of operations. The algorithms should also be scalable to large life science ontologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Change operation generating rules</head><p>The identification of basic and complex change operations is based on Change Operation Generating Rules (COG rules). Each rule is defined by a set of pre-conditions. If all pre-conditions are fulfilled, a sequence of resulting actions is applied to create new change operations or eliminate existing ones. Depending on the type of generated change operations we distinguish between (1) Basic and (2) Complex COG rules. We further use (3) Aggregation rules to iteratively determine more complex change operations for sets of ontology elements. The various rules will be used by the main Diff algorithm presented in Section 5.</p><p>In the following we describe the different types of rules in more detail and provide examples for illustration. Please consult Appendix A for the complete set of our current COG rules. In the rule def-Table <ref type="table">1</ref> COnto-Diff operations with descriptions and their inverses. The upper part shows all basic change operations (B op ) while all complex change operations (C op ) operating whether on single elements (denoted with lower case letters) or multiple elements (sets denoted with upper case letters) are displayed in the middle and lower part, respectively.  In some rules, we test the equality (=sign) or inequality (-sign) of two elements. We regard two concepts as equal if they share the same identifier, i.e., they have exactly the same accession number or URI (disregarding namespace and versioning information though).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Basic COG rules</head><p>The basic COG rules (b-COG) primarily use information from the match mapping and the ontology versions to determine basic change operations. The following five b-COG rules are used to determine addC, delC and mapC change operations: In our running example (b 1 ) determines concept additions (addC) such as for 'trochlear nucleus' and 'trigeminal nucleus'. (b 3 ) creates mapC changes that map between changed concepts, e.g., mapC (accessory cochlear nucleus, cochlear ventral nucleus). Furthermore, (b 4 ) and (b 5 ) look for concepts that have multiple matches to others and create corresponding mapC changes. The existence of multiple correspondences implies a changed semantics for the concept that is expressed in the evolution mapping. Table <ref type="table">A</ref>.1 lists six further b-COG rules to determine relationshipand attribute-level changes.</p><formula xml:id="formula_3">ðb 1 Þ c 2 O new ^9 = aða 2 O old ^matchCða; cÞÞ ! create½addCðcÞ ðb 2 Þ c 2 O old ^9 = aða 2 O new ^matchCðc; aÞÞ ! create½delCðcÞ ðb 3 Þ a 2 O</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Complex COG rules</head><p>Complex COG rules (c-COG) are non-recursive and determine the complex changes based on either basic change operations or other complex changes. Complex changes on sets of elements are generally derived in two steps. We first apply c-COG rules to create complex changes on single ontology elements and then use an additional aggregation step (using aggregation rules) to combine several element changes into complex changes on set-valued parameters.</p><p>For example, for the complex merge operation we first derive partial merge operations on a single input element using the following c-COG rule: The left side of the rule ensures that there exist at least two different source concepts a and b(ab) mapping to the same target concept c, and that a and b have no further maps to other target concepts d and e, respectively. If these pre-conditions are fulfilled we create two element-level merge change operations one from concept a into concept c and one from b into c, the corresponding basic changes mapC(a, c) and mapC(b, c) are eliminated.</p><formula xml:id="formula_4">ðc 8 Þ a; b</formula><p>For our example mapC(accessory cochlear nucleus, cochlear ventral nucleus) and mapC(anterior cochlear nucleus, cochlear ventral nucleus) would produce change operations merge({accessory cochlear nucleus}, cochlear ventral nucleus) and merge({anterior cochlear nucleus}, cochlear ventral nucleus).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Aggregation COG rules</head><p>Aggregation COG rules (a-COG) are used to determine all affected elements in set-valued complex change operations. Particularly, several related element-level (or multi-valued) change operations can be aggregated into a combined change operation for a more compact representation. Furthermore, redundant element-level change operations can be eliminated since they are now covered in an aggregated change operation. a-COG rules are recursive to incrementally aggregate elements for a particular change operation.</p><p>For instance, the a-COG rule for merge looks as follows: The rule specifies that two existing merge operations on concept sets A and B for the same target concept c can be combined into a merge on the union A [ B into c. Since the merge from A into c and from B into c are now covered by merge(A [ B, c) we eliminate the two previous ones. By iteratively applying the rule we can increasingly aggregate the input sets of the operations until no further aggregation is possible. In our example we would create merge({accessory cochlear nucleus, anterior cochlear nucleus}, cochlear ventral nucleus) and eliminate merge({accessory cochlear nucleus}, cochlear ventral nucleus) and merge({anterior cochlear nucleus}, cochlear ventral nucleus).</p><formula xml:id="formula_5">ða 5 Þ c 2 O</formula><p>As described in Section 3.2, each complex change operation can be implemented by a series of basic change operations. When applying a rule we keep track of the simpler change operations and affected ontology components underlying a complex change operation. For instance, our merge operation can be implemented by the two basic mapC operations mapC(accessory cochlear nucleus, cochlear ventral nucleus) and mapC(anterior cochlear nucleus, cochlear ventral nucleus). Users can thus be provided with complex changes for an overview but also with detailed change information if needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Diff computation</head><p>In this section we present COnto-Diff to generate a diff evolution mapping. We first give an overview of the approach and discuss how to obtain the match mapping needed as input. In Section 5.3 we describe the algorithm to determine the basic evo-lution mapping diff basic as well as the final evolution mapping diff compact .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Overview</head><p>The main phases of COnto-Diff are illustrated in Fig. <ref type="figure" target="#fig_3">2</ref>. The input are two versions of the same ontology (O old , O new ). Optionally, background knowledge (e.g., dictionaries) can be provided for matching the ontologies. The result is an expressive diff evolution mapping diff compact (O old , O new ) and a corresponding diff basic (O old , O new ). Optionally we determine the inverse evolution mapping (Section 6.2). The complete algorithm operates on a working repository which stores the ontology versions as well as intermediate and final mappings.</p><p>The first phase is a Matching of the two ontology versions to identify common as well as modified but corresponding ontology elements. The result is a match mapping match(O old , O new ) consisting of a set of matchC correspondences. The following steps use this result and are completely automatic. They utilize COG rules to determine the diff evolution mapping according to Algorithm 1. It sequentially applies the different kinds of COG rules for finding basic changes (Basic Change Detection), complex changes (Complex Change Detection), and aggregated complex changes (Aggregation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Matching phase</head><p>The matching phase uses both input versions as well as optional background knowledge to compute a match mapping. Matching ontology versions is typically much easier than matching independent ontologies. This is due to the fact that a new version evolves from the older version and hence a larger part of the old version usually remains unchanged. To achieve a largely automatic ontology matching we use our GOMMA system that provides state-ofthe-art match capabilities and has been successfully applied to life science ontologies <ref type="bibr" target="#b21">[22]</ref>. The match strategy applied in this work is further explained in Section 7.1. As already mentioned, matching is generally semi-automatic, i.e., a domain expert should verify proposed match correspondences and correct them if necessary. Our Diff algorithm assumes that the match step provides the correct and complete set of correspondences.</p><p>The result of the matching phase for our motivating example in Fig. <ref type="figure" target="#fig_0">1</ref> is the following. All white categories exhibiting the same label in the old and new version do match as well as concept pairs connected by a dashed line. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Rule-based change detection</head><formula xml:id="formula_6">M = match(O 1 , O 2 ), list of rules R = [R bÀCOG , R cÀCOG , R aÀCOG ], Output: diff evolution mappings diff basic (O 1 , O 2 ), diff compact (O 1 , O 2 ) 1 diff basic (O 1 , O 2 ) diffBasicGen(O 1 , O 2 , M, R bÀCOG ); 2 D diff basic (O 1 , O 2 ); 3 foreach r 2 R cÀCOG do 4 D applyRule (D, r); 5 end 6 diff compact (O 1 , O 2 )</formula><p>applyAggRules(D, R aÀCOG );</p><formula xml:id="formula_7">7 return [diff basic (O 1 , O 2 ), diff compact (O 1 , O 2 )];</formula><p>Step 1 calls a procedure diffBasicGen (see Algorithm 2) to generate the basic diff evolution mapping diff basic (O 1 , O 2 ) based on match mapping M and the list of b-COG rules (R bÀCOG ). The b-COG rules need only to be applied once (applyBasicRule) in the pre-defined order (see numbering in Table <ref type="table">A</ref>.1). We will use diff basic for ontology migration purposes (see Section 6.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2. diffBasicGen</head><p>Input: two ontology versions O 1 and O 2 , match mapping</p><formula xml:id="formula_8">M = match(O 1 , O 2 ), list of b-COG rules R bÀCOG Output: basic diff evolution mapping D = diff basic (O 1 , O 2 ) 1 D empty; 2 foreach r 2 R bÀCOG do 3 D applyBasicRule (D, r, O 1 , O 2 , M); 4 end 5 return D;</formula><p>The processing of c-COG rules (steps 2-5 of Algorithm 1) is similar to the processing of b-COG rules in that each rule needs to be applied only once in the predetermined order. Rule processing starts with the basic diff evolution mapping and iteratively enriches the mapping with complex changes and the elimination of basic ones.</p><p>The Aggregation step requires to apply the a-COG rules multiple times to recursively aggregate set-valued change operations. This functionality is realized by the applyAggRules procedure (Algorithm 3) called in step 6 of Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Match</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ontology version</head><p>O old</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ontology version O new</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Working repository</head><p>Match System   <ref type="table">A</ref>.3). Thus, we can apply a-COG rules multiple times (once per iteration) to recursively detect and aggregate multiple change operations. The application of one rule (applyRule) modifies the temporary evolution mapping D 0 according to the rule's resulting actions (create, eliminate). We apply rules as long as new changes are inferred and the temporary mapping changes (D -D 0 ). Tables 2-4 contain the complete results of running the algorithm diffEvolMapGen for the running example. The first column shows the rule by which the change operation in column two was derived. Column three represents the rule by which a change operation was eliminated. Grey-shaded change operations had been created but later eliminated due to their coverage by a more complex change operation. The basic diff evolution mapping consists of the changes displayed in Table <ref type="table" target="#tab_6">2</ref>. All white-shaded changes in Tables 2-4 form the final (compact) diff evolution mapping which cannot further be compacted w.r.t. the used set of rules. As a result, we note that the basic evolution mapping comprises 26 basic change operations while the semantically equivalent compact mapping contains merely 10 changes. Appendix B illustrates the generation of a complex change in more detail, namely the addition of the 'brainstem white matter' subgraph in the running example (right-hand side in Fig. <ref type="figure" target="#fig_0">1</ref>).</p><p>For the correctness proofs of the proposed algorithm we refer to Appendix C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Applications: migration of ontology versions and annotations</head><p>An important application of diff evolution mappings is the migration of ontology versions. In this Section we will first show how we can use the diff evolution mapping to migrate from an old to a new (changed) ontology version (Section 6.1). We then outline how we can use the inverse diff evolution mappings to migrate also in the backward direction (Section 6.2). Furthermore, we discuss how an evolution mapping can be used to adapt dependent data in particular annotations and ontology mappings (Section 6.3).  It executes the basic change operations of diff basic in a predefined order (performOrder). For the deletions, we first remove concept attributes. We then remove the concepts from the ontology structure and finally eliminate themselves. For the map changes we first need to substitute concepts (mapC), afterwards mapR and mapA can be executed, e.g., we update a changed attribute value or relationship type. Finally, for additions we first add the concept and then its attributes and relationships. We show the correctness of ontVersionMig in Appendix D.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Basic version migration</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We can migrate an old version</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Inverse diff mappings</head><p>Inverse diff evolution mappings can be applied to undo the changes in an evolution, i.e., we want to switch back from a changed ontology version to the old one. Our change model allows an easy way to determine an inverse diff evolution mapping because every change operation has an unique inverse change operation as introduced in Section 3 and listed in Table <ref type="table">1</ref>. Hence, we can simply replace every change operation by its inverse change operation to obtain the inverse mapping. The inverse of diff basic (O 1 , O 2 ) gives us a basic evolution mapping that, using the algorithm ontVersionMig, can be used to correctly migrate from O 2 to O 1 . We show the correctness of the inverse diff mapping in Appendix D.2.</p><p>To evaluate and verify the proposed algorithms we can apply a roundtrip migration between two ontology versions as illustrated in Fig. <ref type="figure" target="#fig_9">3</ref> 1 should equal O 1 due to the correctness of inverse mappings and their migration. We evaluate the roundtrip migration for real-world ontologies in Section 7.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Migration of annotations and dependent mappings</head><p>The generated evolution mappings are also useful to migrate annotations or ontology mappings affected by ontology changes. For instance, collaborating annotation curators can make use of COnto-Diff evolution mappings between their current ontology version and the newest release. Each curator would then be able to recognize whether or not changes occurred in his area of expertise and can (semi-) automatically migrate affected annotations. In general, additive changes such as addSubGraph or addLeaf may not affect existing annotations so that there is no immediate need to update annotations. However, other changes such as merge, split,substitute or delSubGraph require an update of affected annotations. The adaptation should be performed in a semi-automatic manner to limit the amount of manual effort but should still give curators the chance to make manual decisions. The necessary steps for adaptation depend on the type of change and include the following: merge, leafMerge: annotations of the source concepts of the old ontology version need to be migrated to the merged (target) concept of the new ontology version, substitute: affected annotations from the source concept need to be migrated (associated) to the new target concept, delSubGraph, delLeaf: an expert should be consulted to determine whether the annotations of the deleted concepts should also be deleted or whether they can be migrated to alternate concepts such as the parents of deleted concepts, toObsolete: an expert should be consulted to determine whether the annotations of the obsolete concepts should also be marked as obsolete or migrated to an alternate concept, e.g., parent concept, split, leafSplit: an expert should be consulted to determine to which new target concepts (selected from the ones listed in the change operation) one should migrate the annotations of a split source concept.</p><p>When annotations can be adapted in different ways the final decision can be reached in a collaborative way. For example, if there are multiple alternatives for an obsolete concept, a team of curators could vote which of the alternatives would be the best solution to migrate an annotation. We have already realized a first annotation migration functionality in our OnEX tool <ref type="bibr" target="#b15">[16]</ref> covering merge, toObsolete and delC changes. In Section 7.3 we evaluate how annotations were influenced by changes in the Gene Ontology. In the future we plan to extend this work by incorporating more complex change operations for annotation migration. In a similar way, we plan to use evolution mappings to adapt ontology mappings (see Section 8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Evaluation experiments</head><p>We first describe the setup, in particular the tested ontologies and evolution scenarios. We then evaluate the basic and compact evolution mappings determined by COnto-Diff. We also analyze the use of the evolution mappings for a roundtrip migration of the ontologies and the adaptation of annotations. Finally, we compare the evolution mappings of COnto-Diff with those determined by PromptDiff.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Evaluation setup</head><p>We determine and evaluate evolution mappings for four large life science ontologies namely the Gene Ontology (GO) <ref type="bibr" target="#b11">[12]</ref>, the National Cancer Institute Thesaurus (NCIT) <ref type="bibr" target="#b38">[39]</ref>, the Mammalian Phenotype Ontology (MP) <ref type="bibr" target="#b41">[42]</ref> and the Mouse Adult Gross Anatomy Ontology (MA) <ref type="bibr" target="#b18">[19]</ref>. GO is widely used in bioinformatics for a uniform annotation of molecular-biological objects such as proteins or genes. NCIT is maintained at the National Cancer Institute and consists of 20 main categories which cover cancer-related topics such as drugs, tissues or anatomical structures. MP provides a set of standard terms for annotating mammalian phenotypic data Fig. <ref type="figure" target="#fig_9">3</ref>. Roundtrip migration of ontology versions using diff evolution mappings.</p><p>while MA is a structured controlled vocabulary of the adult anatomy of the mouse. We consider two yearly evolution periods (three ontology versions) for each ontology: 2009 (2009-01 ? 2010-01) and 2010 (2010-01 ? 2011-01). The ontology versions are from the archives of GO,<ref type="foot" target="#foot_2">4</ref> NCIT<ref type="foot" target="#foot_3">5</ref> and OBO. <ref type="foot" target="#foot_4">6</ref> COnto-Diff is implemented in Java. We utilize a MySQL database as a working repository and for storing ontology versions as described in <ref type="bibr" target="#b22">[23]</ref>. The experiments are conducted on a Windows XP desktop computer with an Intel Core 2 Duo CPU (2.66 GHz) and 4 GB of RAM.</p><p>Matching two ontology versions in the context of ontology evolution is facilitated by the large portion of unchanged concepts occuring in both versions. In the initial matching phase we thus apply the following automatic strategy. We utilize the fact that concepts of life science ontologies have unambiguous accession numbers and can thus easily identify most corresponding concepts in two ontology versions. Furthermore, we generate additional correspondences by checking if accessions or labels of concepts in the old version appear as synonyms of a concept in the new version. For instance, if the accession of a concept a appears as a synonym of concept b we would create the correspondence matchC(a, b). We manually checked the match results especially correspondences between unequal concepts (correspondences like matchC(a, a) are clear) and found that the automatically determined correspondences are correct and useful for our diff computation. In the comparison with PromptDiff (Section 7.4) we provide a specific match example that helped to find a merge change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Basic vs. compact Diff evolution mappings</head><p>Table <ref type="table" target="#tab_10">5</ref> lists details on the size of the considered ontology versions and the determined match and evolution mappings for the eight different evolution scenarios. For the ontology sizes we specify the number of concepts jCj and relationships jRj. NCIT is the largest ontology followed by GO, MP and MA. The first three ontologies grew substantially in the two years (between 8% and 12% increase in each year) while MA only had a modest increase in size (2% per year).</p><p>The further columns show the sizes of match, diff basic and diff compact , i.e., the number of match correspondences and the number of changes in the diff evolution mappings. For all investigated ontologies we could find a correspondence for each concept in the old ontology version, i.e., no ontology concept has been deleted but has at most been declared as obsolete. The number of match correspondences is even slightly higher than the number of concepts in the old versions since some source concepts are matched to several target concepts. The number of basic changes in diff basic is relatively high but much smaller than the number of correspondences underlining that the majority of concepts remained unchanged. For all scenarios the number of changes in diff compact could be substantially reduced with only between 30% and 43% of the number of changes in diff basic (see ratio in the last column of Table <ref type="table" target="#tab_10">5</ref>). The evolution mapping is also compact in comparison to the ontology sizes. For instance, diff compact (GO 2010-01 , GO 2011-01 ) is about a factor 20 smaller than the single versions GO 2010-01 and GO 2011-01 . For MA the compactness of the diff is even higher (up to a factor of 100) due to a lower change intensity. These observations show that ontologies remain largely unchanged during evolution (many more match correspondences than basic changes). Furthermore, despite significant increases in ontology size our algorithm is able to find compact evolution mappings that we will now analyze in more detail.</p><p>To analyze the determined evolution mappings, we show in Table 6 the number of basic and complex change operations within the compact evolution mappings. We group all remaining basic changes into the three groups add, del and map. The large ontology growth is reflected in a high number of information extending operations such as addLeaf, leafSplit as well as subgraph additions. For instance, the largest subgraph (GO:0070887 -'cellular response to chemical stimulus') added in 2009 encompasses 126 new concepts; in 2010 the largest added subgraph on 'renal system development' (GO:0072001) consisted of 168 concepts. There have been additions of large subgraphs in NCIT as well, e.g., 'MicroR-NA_Gene' (C80699) with 285 concepts in 2009 or 'Gastrointesti-nal_System_Cancer_TNM_Finding_v7' (C89710) with 359 concepts in 2010. Furthermore, our algorithm was able to assign all mapC changes (no mapC changes in diff compact ) to a complex change such as merge or substitute. mapR changes were especially identified in GO where new relationship types such as 'nega-tively_regulates' or 'positively_regulates' have been introduced. Thus, existing relationships have been modified to include these new types and to enhance the semantics of GO.</p><p>Note that no concepts have been in the ontologies under investigation (the delete frequencies in Table <ref type="table" target="#tab_11">6</ref> are only delR changes and contain no delC changes). Outdated concepts are merely marked as obsolete but the outdated information is retained for compatibility reasons. Setting concepts to obsolete has frequently been performed in GO, NCIT and MP. For GO and MP we also observe a relative high number of merge changes. For example, in 2010 the four GO concepts GO:0001622 ('super conserved receptor expressed in brain receptor activity'), GO:0001623 ('Mas proto-oncogene receptor activity'), GO:0001624 ('RDC1 receptor activity') and GO:0001625 ('Epstein-Barr Virusinduced receptor activity') have been merged into GO:0004930 ('G-protein coupled receptor activity'). Interestingly, in NCIT some concepts have become obsolete and merged into another concept at the same time, e.g., 'Mammoplasty' (C51614) is obsolete since August 2009 but was also merged into 'Breast_Reconstruction' (C15354). Using our c-COG rule (c 14 ) we could identify such co-occurring modifications and prefer merge over toObsolete for the final diff result. Move changes, i.e., the rearrangement of concepts within the ontology have occurred for all investigated evolution scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Ontology version and annotation migration</head><p>To evaluate the correctness of the determined evolution mappings we performed the roundtrip migration experiment described in Section 6.2. For comparing O 1 with O 00 1 we utilize their representation as sets of concepts and relationships as introduced in Section 3.1. By testing</p><formula xml:id="formula_9">O 1 [ O 00 1 ¼ O 1 \ O 00</formula><p>1 we evaluate whether the migrated ontology version O 00 1 contains exactly the same elements (concepts, relationships) as O 1 , indicating the completeness of the evolution mapping and its inverse mapping. The results are presented in Table <ref type="table">7</ref>. The first column shows the number of elements in the source version (jO 1 j), the last two columns indicate the number of elements in the intersection and union of O 1 with O 00</p><p>1 . We can verify that O 1 and O 00 1 contain exactly the same elements for all scenarios confirming that the determined evolution mappings allow for the correct migration of ontologies and that COnto-Diff has been correctly implemented.</p><p>To analyze the migration of annotations we use the manuallycurated Uniprot-GOA Human annotations in version 63 from May 2008. 7 The annotations are based on the GO version from May 2008 and we compute the evolution mapping diff compact (GO 2008-05 , GO 2011-01 ) to study changes w.r.t. the GO version of January 2011. The results in Table <ref type="table" target="#tab_12">8</ref> show the change frequency for three complex changes and how many annotations were affected by these changes. Overall we observe that more than 1,000 annotations are affected and that about every third change operation influenced at least one annotation. For example, we determined 38 merge operations affecting 125 annotations. We could use this mapping to automatically update the annotations with the new ontology concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.">Comparison with PromptDiff</head><p>We now compare the results obtained with COnto-Diff with those determined by PromptDiff <ref type="bibr" target="#b31">[32]</ref>. For this analysis, we evaluate the MA diff evolution mapping for 2009. We loaded the two versions MA 2009-01 /MA 2010-01 into the current version of Protégé and executed PromptDiff to get the difference table. PromptDiff uses a somewhat different set of change operations, in particular they distinguish between add, delete, merge, split, map and change modifications. For a better comparison, we group our changes and those of PromptDiff into three categories namely 'Addition of concepts', 'Structural changes' and 'Revision of concepts' as shown in Table <ref type="table" target="#tab_13">9</ref>.</p><p>PromptDiff generates a total of 108 changes, while COnto-Diff determines only 76 complex change operations. Many changes are similar in the two diff results but there are also substantial differences caused by the different sets of changes and different detection approaches. While PromptDiff has found 59 concept additions, COnto-Diff classifies and aggregates those into more expressive changes like leafSplit or addSubGraph. For instance, the addition of a new subgraph MA:0002901 ('aorta wall') representing knowledge about the wall of the aorta and its different layers was identified. Another example is the split of MA:0001722 ('decidua') into the two more fine-grained leaf concepts MA:0002905 ('decidua basalis') and MA:0002906 ('decidua capsularis'). These examples show why there are fewer change operations in the COnto-Diff result and that these changes are more precise and understandable than just listing individual additions.</p><p>With respect to 'Structural changes', both tools identify the same concepts involved. However, PromptDiff sometimes does not aggregate basic changes into more complex ones, e.g., it often reports one add and one delete change instead of a move. Particularly, COnto-Diff also detects the 15 relationship changes found by PromptDiff either as a mapR or as a move change. COnto-Diff detects eight additional mapR/ move changes which are classified as relationship additions and deletions by PromptDiff. Thus, the diff of PromptDiff contains 16 more structural changes (8 additions, 8 deletions) resulting in a less compact diff representation.</p><p>The most significant differences occur for changes of the last category 'Revision of concepts'. COnto-Diff determines four correct merges, including a merge of the apparently redundant concept MA:0002440 ('smooth muscle tissue') into the retained concept MA:0000166 ('smooth muscle tissue') as well as the merge of MA:0002832 ('ventricle trabecula carnea') into MA:0002831 ('trabecula carnea'). PromptDiff does not recognize any merge of concepts but detects two concept maps and two deletions. In particular, PromptDiff maps MA:0002440 to MA:0002930 ('posteromedial cortical amygdaloid nucleus') and MA:0002832 to MA:0002922 ('basomedial amygdaloid nucleus') which are apparently both wrong. PromptDiff also recognizes two wrong deletions of MA:0000056 and MA:0001485. By contrast, COnto-Diff correctly finds that these concepts are involved in merge operations, namely MA:0000056 ('fat') is merged into MA:0000009 ('adipose tissue') and MA:0001485 ('incisive bone') into MA:0001493 ('pre-maxilla'). This is made possible by our match strategy using accession numbers and synonyms of ontology concepts. For example, the concept MA:0000009 in the new version contains a synonym MA:0000056 so that the match step generates a correspondence matchC(MA:0000056, MA:0000009) which together with the trivial matchC(MA:0000009, MA:000009) is later rewritten into a merge. We suspect that the PromptDiff problems are due to its match approach. It seems that PromptDiff first applies an exact matching of concept accessions/labels and then tries to perform a fuzzy lexical matching of unmatched concepts. It therefore does not create correspondences to already matched concepts leading to wrong correspondences.</p><p>In summary, we observe that COnto-Diff can determine a more expressive and more compact diff result than PromptDiff and that PromptDiff determines wrong changes, probably because of limitations in the applied matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Discussion and future work</head><p>We presented a new rule-based approach COnto-Diff to determine an expressive and invertible diff evolution mapping between two versions of the same ontology. The diff evolution mapping covers basic and complex changes. The approach is based on an initial matching between the ontology versions and utilizes Change Operation Generating Rules (COG rules) to find the basic as well as complex change operations. The rules also specify which simpler changes are replaced by more expressive changes. The evaluation on large life science ontologies showed that our Diff approach generates semantically expressive and compact evolution mappings. We also showed that the determined evolution mappings allow the correct migration of old into new ontology version or vice versa. They can also be used to semi-automatically adapt annotations and ontology mappings after ontology modifications. We expect the expressive evolution mappings to be useful for ontology developers and users such as curators, especially for large ontologies.</p><p>A key advantage of the proposed COnto-Diff approach over previous solutions such as PromptDiff is its high modularity and flexibility. First, COnto-Diff separates matching from diff computation and can thus leverage customized match strategies, e.g., to deal with domain-specific ontology characteristics such as the use of synonyms in life science ontologies. Using this strategy we are able to automatically compute diffs for all OBO-based ontologies available in the OBO Foundry or in BioPortal. Second, the rule-based approach supports an easy extension of COnto-Diff to identify additional kinds of changes. We could thus incorporate specific changes to deal with obsolete concepts. The comparative evaluation with PromptDiff (see Section 7.4) showed that COnto-Diff can determine more compact and more correct diff evolution mappings due to its use of tailored matching techniques and the ability to correctly identify complex changes such as merges. We made the proposed diff functionality already available within a web tool <ref type="bibr" target="#b14">[15]</ref>. Thus, users can compute and analyze evolution mappings for different life science ontologies online or via a web service interface. There are still some limitations of COnto-Diff and its usability for further kinds of ontologies. First, the matching step which we could apply automatically for life science ontologies in this paper may require human intervention, e.g., for correcting/ revising determined correspondences. Especially if we cannot make use of unambiguous concept accession numbers, we need to apply further matching techniques to find correspondences. Second, to support further changes corresponding COG rules must be defined correctly, i.e., domain knowledge about the evolution of ontologies needs to be formally defined in rules to detect the changes. A designer of such rules needs to keep possible effects in mind, i.e., one must be aware of the consequences by introducing defective rules or manipulating their order. Third, COnto-Diff does not yet cover OWL constructs such as disjunctive classes or property restrictions. Fourth, COnto-Diff is currently not integrated in an ontology editor such Protégé, however it would be possible to provide COnto-Diff as a plugin so that it can be used in editors as well.</p><p>In future work, we plan to address these issues as well as the following topics. We want to apply COnto-Diff to additional ontologies and domains. We also want to investigate in more detail the adaptation of ontology mappings and of ontology instances. The first rule (c 6 ) is used to detect leaf concept additions. Rule (c 10 ) is based on the results of (c 6 ) and infers subgraph additions connecting a newly added concept a and a leaf concept b rooted at a. In our example 'crura cerebri', 'superior cerebellar peduncle', 'middle cerebellar peduncle', 'inferior cerebellar peduncle' and 'posterior commissure' are classified as leaf concept additions. Afterwards rule (c 10 ) infers addSubGraph(brainstem white matter, {crura cerebri}), addSubGraph(brainstem white matter, {posterior commissure}), addSubGraph(cerebellar peduncle, {superior cerebellar peduncle}), addSubGraph(cerebellar peduncle, {middle cerebellar peduncle}) and addSubGraph(cerebellar peduncle, {inferior cerebellar peduncle}). We then can apply the following a-COG rules: ) recursively aggregates added concepts into larger subgraphs. If multiple subgraph additions with the same root exist, we can aggregate these into one by fusing their sub concepts (a 10 ). In our example (a 9 ) would detect three changes: addSubGraph(brainstem white matter,{cerebellar peduncle, superior cerebellar peduncle}), addSubGraph(brainstem white matter,{cerebellar peduncle, middle cerebellar peduncle}) and addSubGraph(brainstem white matter,{cerebellar peduncle, inferior cerebellar peduncle}) which are finally aggregated into addSubGraph(brainstem white matter, {crura cerebri, posterior commissure, cerebellar peduncle, superior cerebellar peduncle, middle cerebellar peduncle, inferior cerebellar peduncle}) by (a 10 ).</p><formula xml:id="formula_10">ða 9 Þ a;b;r 2 O new ^A#O new ^addSubGraphða;AÞ^addCðbÞ^addRðrÞ ^rsource ¼ a ^rtarget ¼ b ^rtype 2 f 0 is a 0 ; 0 part</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C. Correctness of Diff algorithm</head><p>We will show that the proposed algorithm for generating diff evolution mappings (see Section 5.3) is correct, in particular that it generates all changes and that it terminates. We first show that the generation of the basic diff evolution mapping is complete, i.e., determines all basic changes between two input ontology versions O old and O new . We focus on concept changes; the correctness proof for relationship and attribute changes is analogous. We first show that algorithm diffEvolMapGen terminates. This is mainly ensured by two facts. First, all rules operate on a finite number of ontology elements in O old /O new and do not create new ontology elements. Second, the evaluation of all rules terminates since we apply them only once or as long as the mapping changes. The application of c-COG rules terminates since they are nonrecursive and are applied only once based on a pre-defined order. a-COG rules are recursive but always reduce the number of change operations by aggregating ontology elements. Particularly, each rule uses at least two input change operations which are fused into one; the input change operations are eliminated. This steady reduction of change operations terminates when the most aggregated change operations have been found.</p><p>To prove the completeness of the generated diff compact we have to show that this mapping covers all changes. This is ensured by the completeness of the input (diff basic ) and since our rules cover all possible changes and the rule execution always terminates.</p><p>The derivation of the most compact evolution mapping is ensured by the design of our rules. In particular, we can show for every change operation that it will be rewritten by the algorithm to at most one complex change operation in a unique way. This is because the preconditions using a particular kind of change operation in different rules are mutually exclusive. Together with the termination and completeness properties this confluence behavior ensures that we determine the most compact evolution mapping. We will illustrate the confluence only for the non-trivial mapC change operation, the proof for the other basic change operations is analogous. For the map of a concept a into another concept b(mapC(a, b)) four variants may occur: Creation of an attribute map if value has changed: p 2 O old ^q 2 O new ^delA(p) ^addA(q) ^pconcept = q concept pname = q name ^pvalue -q value ?create[mapA(p, q)],eliminate[delA(p),addA(q)] mapC change, only rule (c 1 ) can be executed since (c 8 ) and (c 9 ) require a second mapC change operation involving either a or b. In this case mapC(a, b) is rewritten to a substitute (substitute(a, b)) which cannot be aggregated (no a-COG rule). If the target concept b of mapC(a, b) is involved in another mapC change mapC(c, b) it is possible that rule (c 8 ) can be executed. However, the precondition ensures that a as well as c must not be involved in another mapC change, e.g., mapC(a, d) or mapC(b, d). If this applies, both changes belong to a merge into the common target b. (c 8 ) would generate two partial merges, one from a into b and one from c into b. In the aggregation step (rule (a 5 ) for merge), these partial merges are unified in one common merge change operation, i.e., all mapC which belong to a merge are rewritten to one common merge operation. On the opposite, the source concept may be involved in multiple mapC changes, i.e., another mapC change mapC(a, c) exists. In this case, the split rule (c 9 ) could be executed if the targets b and c are not involved in any other mapC change operation. If the precondition is fulfilled we would derive two partial splits, one from a to b and one from a to c. In the aggregation phase, rule (a 6 ) then unifies all partial splits with the same source concept (in our case a). Hence, all mapC changes which belong to a common split change are rewritten to exactly one split change operation. The fourth variant occurs in situations where no exact decision can be reached. For instance, if mapC(a, b) exists, a is mapped to another target concept c(mapC(a, c)) and b is mapped to another source concept d(mapC(d, b)) we cannot clearly find out what happened. On the one hand, a and d could be merged into b. On the other hand, a could be split into b and c. Since we cannot automatically treat this case, we do not derive any complex change operation so that we keep the basic change operation.</p><p>The properties of our rule set guaranteeing termination and confluence need to be preserved when extending it for the support of additional change operations. In particular, new COG rules should not introduce cyclic dependencies between rules and only aggregation rules reducing the number of changes may be recursive. Furthermore, the use of a new change operation in multiple rules must use mutually exclusive preconditions for this change operation.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Motivating example -evolution in a part of an anatomical ontology (left: old version, right: new version).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Insertion of a new concept c in the changed ontology delC(c) delC(c) Deletion of an existing concept c from the old ontology version addC(c) mapC(c1, c2) Maps a concept c1 of the first ontology version to a concept c2 of the second version mapC(c2, c1) addR(r) Insertion of a new relationship r delR(r) delR(r) Deletion of an existing relationship r addR(r) mapR(r1, r2) Maps a relationship r1 of the first ontology version to a (differently typed) relationship r2 of the second version mapR(r2, r1) addA(a) Addition of an attribute a delA(a) delA(a) Deletion of an existing attribute a addA(a) mapA(a1, a,2)Maps an attribute a1 of the first to an attribute a2 of the second</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 1</head><label>1</label><figDesc>shows the overall procedure implementing the rule-based generation of diff evolution mappings. Its input are two ontology versions O 1 and O 2 , a match mapping M between O 1 and O 2 as well as the list of COG rules R. The result contains two diff evolution mappings namely a basic diff evolution mapping diff basic (O 1 , O 2 ) and a semantically enriched one, diff compact (O 1 , O 2 ). The algorithm has three main steps to apply the three kinds of COG rules in order to generate the respective changes. Algorithm 1. diffEvolMapGen Input: two ontology versions O 1 and O 2 , match mapping</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Schematic overview of COnto-Diff.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>O 1 to the changed version O 2 by applying the basic diff evolution mapping diff basic (O 1 , O 2 ) on O 1 . This approach results in an in-place ontology version migration that retains the unchanged ontology elements. Changes are thus limited to the ontology parts affected by the evolution supporting an efficient migration. Algorithm 4 (ontVersionMig) implements the migration of ontology version O 1 to O 0 1 based on the basic diff evolution mapping diff basic (O 1 , O 2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>ðc 10 Þ a; b 2 O new ^B # O new ^addCðaÞ ^addLeaf ðb; BÞâ 2 B ! create½addSubGraphða; fbgÞ; eliminate½addCðaÞ; addLeaf ðb; BÞ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 1 .Theorem 2 .</head><label>12</label><figDesc>The b-COG rules applied in diffBasicGen generate a complete basic diff evolution mapping diff basic (O old , O new ) containing (a) all concept additions (addC) between O old and O new , (b) all concept deletions (delC) between O old and O new , (c) all concept changes (mapC) including concepts that map to multiple concepts in the other ontology version. To prove the theorem, we refer to the five b-COG rules (b 1 -b 5 ) introduced in Section 4.1 and applied in diffBasicGen. The rules distinguish between concepts that match with at least one concept in the other ontology version and those that do not match. For all non-matching concepts of O new b-COG rule (b 1 ) generates addC change operations. b-COG rule (b 2 ) generates concept deletions (delC) for all non-matching concepts of O old . Matching concepts occur in correspondences matchC(a, b) 2 match(O old , O new ) and are processed by b-COG rules (b 3 ), (b 4 ) and (b 5 ). Rule (b 3 ) creates a mapC(a, b) change if a and b are unequal (ab). For (a = b), rules (b 4 ) and (b 5) ensure that we only create a mapC change if the concept is involved in further correspondences, i.e., has not remained the same. Hence, all matchC(a, a) connecting unchanged concepts are not included in diff basic . In summary, diff basic reflects all basic changes but does not relate unchanged ontology parts. The c-COG and a-COG rules applied in the second part of diffEvolMapGen terminate and generate a complete and the most compact diff evolution mapping diff compact (O old , O new ) w.r.t. our defined change operation set and rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>1 .</head><label>1</label><figDesc>mapC(a, b) belongs to a substitute, i.e., a is exactly replaced by b 2. mapC(a, b) belongs to a merge of multiple concepts A into b 3. mapC(a, b) belongs to a split of a into multiple concepts B 4. mapC(a, b) cannot be rewritten From the c-COG rules only rules (c 1 ), (c 8 ) and (c 9 ) can consume mapC changes. The preconditions in the three rules are mutually exclusive, i.e., exactly one of them or no rule is applicable. If mapC connects two concepts a and b which are not involved in any other Table A.1 List of all b-COG rules. ID Rule b 1 Creation of a concept addition: c 2 O new ^9 = a(a 2 O old ^matchC(a, c)) ?create[addC(c)] b 2 Creation of a concept addition: c 2 O old ^9 = a(a 2 O new ^matchC(c, a)) ?create[delC(c)] b 3 Creation of a concept map between different concepts based on a match correspondence: a 2 O old ^b 2 O new ^matchC(a, b) ^a -b ^:isObsolete(a) ^:isObsolete(b) ?create[mapC(a, b)] b 4 Creation of a concept map between equal concepts if source is involved in multiple match correspondences: a 2 O old , O new ^matchC(a, a) ^$ b(b 2 O new ^matchC(a, b) ^a -b) ^:isObsolete(a) ^:isObsolete(b) ?create[mapC(a, a)] b 5 Creation of a concept map between equal concepts if source is involved in multiple match correspondences: a 2 O old , O new ^matchC(a, a) ^$ b(b 2 O new ^matchC(b, a) ^a -b) ^:isObsolete(a) ^:isObsolete(b) ?create[mapC(a, a)] b 6 Creation of a relationship addition: r 2 O new ^r R O old ?create[addR(r)] b 7 Creation of a relationship deletion: r 2 O old ^r R O new ?create[delR(r)] b 8 Creation of a relationship map if only the relationship type between two concepts changed: r 2 O old ^s 2 O new ^delR(r) ^addR(s) ^rsource = s source rtarget = s target ^rtype -s type ?create[mapR(r, s)],eliminate[delR(r),addR(s)] b 9 Creation of an attribute addition: p 2 O new ^p R O old ?create[addA(p)] b 10 Creation of an attribute deletion: p 2 O old ^p R O new ?create[delA(p)] b 11</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>b-COG rule (b 2 ) will create a delC(c) change in diff basic (O 2 , O 1 ). Analogously, (b 1 ) would create addC(c) in diff basic (O 2 , O 1 ) if c is in O 1 but not in O 2 which corresponds to a delC(c) change (inverse of addC(c)) in diff basic (O 1 , O 2 ). A mapC(a, b) change in diff basic (O 1 , O 2 )has mapC (b, a) as its inverse and, according to rules (b 3 , b 4 , b 5 ), requires a correspondence matchC(a, b). Changing the domain and range leads to a matchC(b, a) correspondence and thus to a mapC(b, a) change in diff basic (O 2 , O 1 ). The concept changes in diff basic (O 2 , O 1 ) are only created by rules (b 1 ) to (b 5 ) like those of diff basic (O 1 , O 2 ). Hence, there can be no further changes in addition to the changes in the inverse of diff basic (O 1 , O 2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Table A. 3</head><label>3</label><figDesc>List of all a-COG rules. ID Rule a 1 Aggregation of move changes if they refer to the same concept: c 2 O new ^A, C # O old ^B, D # O new ^move(c, A, B) ^move(c, C, D) ^(A -C _ B -D) ?create[move(c, A [ C, B [ D)],eliminate[move(c, A, B), move(c, C, D)] a 2 Aggregation of chgAttValue changes if multiple values of an attribute changed: c 2 O new ^chgAttValue(c, n, A, B) ^chgAttValue(c, n, C, D) ^(A -C _ B -D) ?create[chgAttValue(c, n, A [ C, B [ D)],eliminate[chgAttValue(c, n, A, B), chgAttValue(c, n, C, D)]a 3 Aggregation of addLeaf changes if they refer to the same concept: a 2 O new ^A, B # O new ^addLeaf(a, A) ^addLeaf(a, B) ^A -B ?create[addLeaf(a, A [ B)],eliminate[addLeaf(a, A),addLeaf(a, B)] a 4 Aggregation of delLeaf changes if they refer to the same concept: a 2 O old ^A, B # O old ^delLeaf(a, A) ^delLeaf(a, B) ^A -B ?create[delLeaf(a, A [ B)],eliminate[delLeaf(a, A),delLeaf(a, B)] a 5 Aggregation of merges if they share the same target concept: c 2 O new ^A, B # O old ^merge(A, c) ^merge(B, c) ^A -B ?create[merge(A [ B, c)],eliminate[merge(A, c),merge(B, c)] a 6 Aggregation of leaf merges if they share the same target concept: c 2 O new ^A, B # O old ^leafMerge(A, c) ^leafMerge(B, c) ^A -B ?create[leafMerge(A [ B, c)],eliminate[leafMerge(A, c),leafMerge(B, c)] a 7 Aggregation of splits if they share the same source concept: c 2 O old ^A, B # O new ^split(c, A) ^split(c, B) ^A -B ?create[split(c, A [ B)],eliminate[split(c, A),split(c, B)] a 8 Aggregation of leaf splits if they share the same source concept: c 2 O old ^A, B # O new ^leafSplit(c, A) ^leafSplit(c, B) ^A -B ?create[leafSplit(c, A [ B)],eliminate[leafSplit(c, A),leafSplit(c, B)]a 9 Extension of an added subgraph if a relationship to another added concept exists: a, b, r 2 O new ^A # O new ^addSubGraph(a, A) ^addC(b) ^addR(r) rsource = a ^rtarget = b ^rtype 2 { 0 is_a 0 , 0 part_of 0 } ?create[addSubGraph(b,{a} [ A)],eliminate[addSubGraph(a,A), addC(b),addR(r)] a 10 Aggregation of two added subgraphs if they refer to the same root: a 2 O new ^A, B # O new ^addSubGraph(a, A) ^addSubGraph(a, B) ^A -B ?create[addSubGraph(a, A [ B)],eliminate[addSubGraph(a, A),addSubGraph(a, B)] a 11 Aggregation of two added subgraphs if one of them is contained in the other: a, b, r 2 O new ^A, B # O new ^addSubGraph(a, A) ^addSubGraph(a, B) âddR(r) ^rsource = a ^(r target = b ^rtarget 2 B) ^rtype 2 { 0 is_a 0 , 0 part_of 0 } ?create[addSubGraph(b,{a} [ A [ B)],eliminate [addSubGraph(a, A),addSubGraph(b, B),addR(r)] a 12 Extension of a deleted subgraph if a relationship to another deleted concept exists: a, b, r 2 O old ^A # O old ^delSubGraph(a, A) ^delC(b) ^delR(r) rsource = a ^rtarget = b ^rtype 2 { 0 is_a 0 , 0 part_of 0 } ?create[delSubGraph(b,{a} [ A)],eliminate [delSubGraph(a, A),delC(b),delR(r)] a 13 Aggregation of two deleted subgraphs if they refer to the same root: a 2 O old ^A, B # O old ^delSubGraph(a, A) ^delSubGraph(a, B) ^A -B ?create[delSubGraph(a, A [ B)],eliminate[delSubGraph(a, A),delSubGraph(a, B)] a 14 Aggregation of two deleted subgraphs if one of them is contained in the other: a, b, r 2 O old ^A, B # O old ^delSubGraph(a, A) ^delSubGraph(b, B) delR(r) ^rsource = a ^(r target = b _ r target 2 B) ^rtype 2 { 0 is_a 0 , 0 part_of 0 } ?create[delSubGraph(b,{a} [ A [ B)], eliminate[delSubGraph(a, A),delSubGraph(b, B),delR(r)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Moves a concept c and its subgraph from concept set C_From to the concept set C_To move(c, C_From, C_To) chgAttValue(c, att_name, V_Old, V_New) Changes the set of values of the att_name attribute of a concept c from V_Old to initions we denote single elements of an ontology with lower case letters (a, b, . . . 2 O), and element sets with upper case letters (A, B, . . . # O). Each rule has an unique number also indicating the rule type rule (b 1 , b 2 , . . . for basic, c 1 , c 2 , . . . for complex, and a 1 , a 2 , . . . for aggregation COG rules). The rule numbers reflect dependencies between different rules that require a partial order in which rules have to be applied. For instance, rules (b 6 ) and (b 7 ) must be applied before (b 8 ) since they create change operations (addR, delR) which are needed by (b 8 ) to create mapR changes.</figDesc><table><row><cell></cell><cell>ontology version</cell><cell>mapA(a2, a1)</cell></row><row><cell>substitute(c1, c2)</cell><cell>Concept c1 is replaced by c2</cell><cell>substitute(c2, c1)</cell></row><row><cell>toObsolete(c)</cell><cell>Concept c becomes obsolete, i.e., it should not be used anymore</cell><cell>revokeObsolete(c)</cell></row><row><cell>revokeObsolete(c)</cell><cell>The obsolete status of c is revoked, i.e., it becomes active again</cell><cell>toObsolete(c)</cell></row><row><cell>move(c, C_To, C_From)</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>chgAttValue(c, att_name, V_New, V_Old)</cell></row><row><cell></cell><cell>V_New</cell><cell></cell></row><row><cell>addLeaf(c, C_Parents)</cell><cell>Insertion of a leaf concept c below the concepts in C_Parents</cell><cell>delLeaf(c, C_Parents)</cell></row><row><cell>delLeaf(c, C_Parents)</cell><cell>Deletion of a leaf concept c situated below the concepts in C_Parents</cell><cell>addLeaf(c, C_Parents)</cell></row><row><cell>merge(Source_C, target_c)</cell><cell>Merges multiple source concepts Source_O into one target concept target_c</cell><cell>split(target_c, Source_C)</cell></row><row><cell>leafMerge(Child_C, parent_c)</cell><cell>Special merge that fuses all child concepts Child_C into their parent concept</cell><cell>leaf Split(parent_c, Child_C)</cell></row><row><cell></cell><cell>parent_C(parent_c becomes a leaf)</cell><cell></cell></row><row><cell>split(source_C, Target_C)</cell><cell>Splits one source concept source_c into multiple target concepts Target_C</cell><cell>merge(Target_C, source_c)</cell></row><row><cell>leafSplit(parent_c, Child_C)</cell><cell></cell><cell></cell></row></table><note><p>Special split that refines a leaf concept parent_c by multiple child concepts Child_C(parent_c becomes an inner concept) leaf Merge(Child_C, parent_c) addSubGraph(c_root, C_Sub) Inserts a new subgraph with root c_root and concepts C_Sub connected by 'is_a' and 'part_of' relationships delSubGraph(c_root, C_Sub) delSubGraph(c_root, C_Sub) Removes an existing subgraph with root C_root and concepts C_Sub connected by 'is_a' and 'part_of' relationships addSubGraphi(c_root, c_Sub)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>old ,O new ) Rule library Rules Background Knowledge BK match (O old ,O new )</head><label></label><figDesc></figDesc><table><row><cell>•Single Matchers</cell><cell></cell><cell></cell></row><row><cell>•Match Workflows</cell><cell></cell><cell></cell></row><row><cell>•Set Operators</cell><cell></cell><cell></cell></row><row><cell>Ruled-</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>diff compact</cell></row><row><cell cols="3">(O Basic Complex</cell></row><row><cell>Change</cell><cell>Change</cell><cell>Aggregation</cell></row><row><cell>Detection</cell><cell>Detection</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>based Change Detection diff basic (O old ,O new )</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2</head><label>2</label><figDesc>Applying b-COG rules on motivating example.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3</head><label>3</label><figDesc>Applying c-COG rules on motivating example.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4</head><label>4</label><figDesc>Applying a-COG rules on motivating example. Input: ontology version O 1 , basic diff evolution mapping D = diff basic (O 1 , O 2 ) Output: migrated ontology version O 0</figDesc><table><row><cell cols="3">Algorithm 4. ontVersionMig</cell></row><row><cell></cell><cell></cell><cell>1</cell></row><row><cell>1 O 0 1</cell><cell>O 1 ;</cell></row><row><cell cols="2">2 performOrder</cell><cell>[delA, delR, delC, mapC, mapA, mapR, addC, addA, addR];</cell></row><row><cell cols="3">3 foreach chgOp 2 performOrder do</cell></row><row><cell>4 O 0 1</cell><cell cols="2">performðD:getChgOpðchgOpÞ; O 0 1 );</cell></row><row><cell>5 end</cell><cell></cell></row><row><cell cols="2">6 return O 0 1 ;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>. We first migrate version O 1 to a changed version O 0 1 as follows: O 0 1 ¼ ontVersionMigðO 1 ; diff basic ðO 1 ; O 2 ÞÞ. Due to the correctness of the migration algorithm, O 0 1 should equal O 2 . Second, we determine the inverse of diff basic (O 1 , O 2 ), i.e., diff basic (O 2 , O 1 ), and use it to migrate O 0</figDesc><table /><note><p>1 : O 00 1 ¼ ontVersionMigðO 0 1 ; diff basic ðO 2 ; O 1 ÞÞ. The resulting ontology O 00</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 5</head><label>5</label><figDesc>Statistics for GO, NCIT, MP and MA scenarios. O old À O new jO old j(jCj, jRj) jO new j(jCj, jRj) jmatchj j diff basic j j diff compact j</figDesc><table><row><cell>Ratio in %</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 6</head><label>6</label><figDesc>Distribution of change operations. add, del and map represent all remaining basic changes for concepts (mapC, addC, delC) and relationships (mapR, addR, delR) in diff compact .</figDesc><table><row><cell></cell><cell>GO</cell><cell></cell><cell>NCIT</cell><cell></cell><cell>MP</cell><cell></cell><cell>MA</cell><cell></cell></row><row><cell></cell><cell cols="3">2009 2010 2009</cell><cell>2010</cell><cell cols="4">2009 2010 2009 2010</cell></row><row><cell>add</cell><cell cols="2">1375 1157</cell><cell>186</cell><cell>334</cell><cell>99</cell><cell cols="2">130 12</cell><cell>12</cell></row><row><cell>del</cell><cell>238</cell><cell>267</cell><cell>81</cell><cell>79</cell><cell>94</cell><cell>125</cell><cell>7</cell><cell>10</cell></row><row><cell>map</cell><cell>44</cell><cell>45</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>5</cell><cell>0</cell></row><row><cell>addLeaf</cell><cell>646</cell><cell cols="4">478 4,250 4,129 231</cell><cell cols="2">243 20</cell><cell>14</cell></row><row><cell>merge</cell><cell>89</cell><cell>113</cell><cell>28</cell><cell>28</cell><cell>6</cell><cell>17</cell><cell>4</cell><cell>0</cell></row><row><cell>leafSplit</cell><cell>239</cell><cell>182</cell><cell>161</cell><cell>318</cell><cell>65</cell><cell>58</cell><cell>7</cell><cell>6</cell></row><row><cell>substitute</cell><cell>1</cell><cell>3</cell><cell>1</cell><cell>0</cell><cell>6</cell><cell>41</cell><cell>0</cell><cell>0</cell></row><row><cell>move</cell><cell cols="2">1185 1526</cell><cell>4341</cell><cell cols="2">2387 177</cell><cell cols="2">305 18</cell><cell>18</cell></row><row><cell>toObsolete</cell><cell>63</cell><cell>44</cell><cell>67</cell><cell>189</cell><cell>56</cell><cell>31</cell><cell>0</cell><cell>0</cell></row><row><cell>addSubGraph</cell><cell>424</cell><cell>364</cell><cell>245</cell><cell>746</cell><cell>76</cell><cell>122</cell><cell>3</cell><cell>2</cell></row><row><cell>P</cell><cell cols="2">4304 4179</cell><cell>9360</cell><cell cols="2">8210 810</cell><cell cols="2">1072 76</cell><cell>62</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 8</head><label>8</label><figDesc>Influence of ontology evolution on the Uniprot-GOA Human annotation set of version 63. The table shows the number of all and influencing changes occurred in GO between May 2008 and January 2011 as well as the number of affected annotations (changes with no impact are not displayed).</figDesc><table><row><cell>Change</cell><cell>Occurence</cell><cell>With impact</cell><cell>Affected annotations</cell></row><row><cell>merge</cell><cell>209</cell><cell>38</cell><cell>125</cell></row><row><cell>leaf Split</cell><cell>445</cell><cell>144</cell><cell>707</cell></row><row><cell>toObsolete</cell><cell>292</cell><cell>115</cell><cell>197</cell></row><row><cell></cell><cell>946</cell><cell>297</cell><cell>1029</cell></row></table><note><p><p>7 </p>Uniprot-GOA archive: ftp://ftp.ebi.ac.uk/pub/databases/GO/goa/old/HUMAN/.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 9</head><label>9</label><figDesc>Quantitative statistics of the COnto-Diff-PromptDiff comparison for the MA 2009 scenario. The table shows the number of detected changes (occ.) as well as information about their manually verified correctness (corr.). Ticks denote correct results while crosses signal wrong change operations.</figDesc><table><row><cell>COnto-Diff</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>obodiff: http://oboedit.org/docs/html/obodiff.htm.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>GO Monthly Reports: http://www.geneontology.org/MonthlyReports/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>GO: http://archive.geneontology.org/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>NCIT: http://evs.nci.nih.gov/ftp1/NCI_Thesaurus/archive/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>OBO: http://obo.cvs.sourceforge.net/viewvc/obo/obo/ontology/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>M. Hartung et al. / Journal of Biomedical Informatics 46 (2013) 15-32</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank all anonymous reviewers for their useful comments to improve the paper. This work is supported by the German Research Foundation (DFG), Grant RA 497/18-1 (''Evolution of Ontologies and Mappings'').</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>q This work is supported by the German Research Foundation (DFG), Grant RA 497/18-1 (''Evolution of Ontologies and Mappings'').</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Summary of COG rules</head><p>The following Tables A.1-A.3 list all COG rules (b-COG, c-COG, a-COG) that allow the determination of all change operations introduced in Section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Example walkthrough for Diff algorithm</head><p>In the following we illustrate an example walkthrough to determine the subgraph addition in our running example (see Fig. <ref type="figure">1</ref>). For this subgraph example the b-COG addition rule (b 1 ) would detect seven concept additions: addC(brainstem white matter), ad-dC(crura cerebri), addC(cerebellar peduncle), addC(superior cerebellar peduncle), addC(middle cerebellar peduncle), addC(inferior cerebellar peduncle) and addC(posterior commissure). For detecting subgraph additions the following c-COG rules are applied:</p><p>! create½addLeaf ða;fr target gÞ;eliminate½addCðaÞ;addRðrÞ</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D. Correctness of version migration algorithms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.1. Correctness of basic version migration</head><p>We will show the correctness of the ontVersionMig algorithm presented in Section 6.1. We prove the theorem for concept changes. We need to show that the generated ontology version is complete, i.e., it (1) contains all concepts and (2) contains no further/other concepts. First, it is easy to see that the algorithm removes deleted concepts indicated by delC changes so that they do not become part of O 2 . Analogously, the concepts of the domain of mapC changes are eliminated and thus do not appear in O 2 . Second, an unchanged concept c already available in O 1 should be present in O 2 as well. Particularly, such a c is not covered by any change operation of diff basic and thus remains in O 2 . Finally, concepts specified by addC changes are added to the unchanged ontology part and thus become part of O 2 . In the same way the range concepts of mapC changes in diff basic are inserted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.2. Correctness of inverse diff mappings</head><p>In the following we will prove the correctness of our inverse diff mappings.</p><p>Theorem 4. The inverse of a basic diff evolution mapping diff basic (O 1 , O 2 ) is correct, i.e., is identical to diff basic (O 2 , O 1 ).</p><p>We prove this theorem for concept changes. We will show that the inverse of every change operation in </p><p>Creation of revokeObsolete if a concept's status changed from true to false:</p><p>Creation of a leaf addition if a concept with no children was added:</p><p>Creation of a leaf deletion if a concept with no children was deleted: </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">OBO explorer: an editor for open biomedical ontologies in OWL</title>
		<author>
			<persName><forename type="first">S</forename><surname>Aitken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">443</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Schema and ontology matching with COMA++</title>
		<author>
			<persName><forename type="first">D</forename><surname>Aumueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Massmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc of ACM SIGMOD</title>
		<imprint>
			<biblScope unit="page" from="906" to="908" />
			<date type="published" when="2005">2005</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Applying model management to classical meta data problems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of conference on innovative database research (CIDR)</title>
		<meeting>conference on innovative database research (CIDR)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="209" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Model management 2.0: manipulating richer mappings</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM SIGMOD international conference on management of data</title>
		<meeting>the 2007 ACM SIGMOD international conference on management of data</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The SWISS-PROT protein knowledgebase and its supplement TrEMBL in 2003</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boeckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bairoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Apweiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Blatter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Estreicher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gasteiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucl Acids Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="365" to="370" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Would SNOMED CT benefit from realismbased ontology evolution?</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ceusters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Spackman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMIA annual symposium proceedings</title>
		<imprint>
			<biblScope unit="page">105</biblScope>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The OBO flat file format specification, version 1</title>
		<author>
			<persName><forename type="first">J</forename><surname>Day-Richter</surname></persName>
		</author>
		<ptr target=".2.&lt;http://www.geneontology.org/go.format.obo-1_2.shtml&gt;" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">OBO-edit -an ontology editor for biologists</title>
		<author>
			<persName><forename type="first">J</forename><surname>Day-Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Haendel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lewis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page">2198</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Ontology matching</title>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shvaiko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Flicek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Aken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Beal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ballester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caccamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucl Acids Res</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="707" to="714" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Ontology change: classification and survey</title>
		<author>
			<persName><forename type="first">G</forename><surname>Flouris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Manakanatas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plexousakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowl Eng Rev</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="152" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The gene ontology project in 2008</title>
		<author>
			<persName><forename type="first">Gene</forename><surname>Ontology</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Consortium</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucl Acids Res</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="440" to="444" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Creating mappings for ontologies in biomedicine: simple methods work</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ghazvinian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of AMIA annual symposium</title>
		<meeting>of AMIA annual symposium</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Mapping composition for matching large life science ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kirsten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Intl conference on biomedical ontology</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">CODEX: exploration of semantic changes between ontology versions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="895" to="896" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">OnEX: exploring changes in life science ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kirsten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">250</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Analyzing the evolution of life science ontologies and mappings</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kirsten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data integration in the life sciences (DILS)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="11" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Recent advances in schema and ontology evolution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Terwilliger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Schema matching and mapping</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Bellahsene</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="149" to="190" />
		</imprint>
	</monogr>
	<note>chapter 6</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The adult mouse anatomical dictionary: a tool for annotating and integrating data</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Hayamizu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mangan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Corradi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Kadin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ringwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>R29</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Falcon-AO: a practical ontology matching system</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Web Semantics: Sci. Services Agents World Wide Web</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="237" to="239" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Bioinformatics enrichment tools: paths toward the comprehensive functional analysis of large gene lists</title>
		<author>
			<persName><forename type="first">D</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sherman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lempicki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucl Acids Res</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Gomma: a component-based infrastructure for managing and analyzing life science ontologies and their evolution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kirsten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Biomed Semantics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Efficient management of biomedical ontology versions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kirsten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>OTM workshops</publisher>
			<biblScope unit="page" from="574" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Ontology versioning and change detection on the web</title>
		<author>
			<persName><forename type="first">M</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fensel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kiryakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ognyanov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowl Eng Knowl Manage: Ontol Semantic Web</title>
		<imprint>
			<biblScope unit="page" from="247" to="259" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Sambo -a system for aligning and merging biomedical ontologies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lambrix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Web Semantics: Sci Services Agents World Wide Web</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="196" to="206" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Bingo: a cytoscape plugin to assess overrepresentation of gene ontology categories in biological networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Maere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Heymans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuiper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page">3448</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Matching schemas in online communities: a web 2.0 approach</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mccann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th International conference on data engineering</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="110" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">OBO to OWL: a protege OWL tab to read/save OBO ontologies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Moreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page">1868</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Bioportal: a web repository for biomedical ontologies and data resources</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dorf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Griffith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jonquet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ISWC</title>
		<meeting>of ISWC</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A framework for ontology evolution in collaborative environments</title>
		<author>
			<persName><forename type="first">Chugh</forename><forename type="middle">A</forename><surname>Noynf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The semantic web -ISWC 2006, 5th international semantic web conference</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="544" to="558" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Tracking changes during ontology evolution</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kunnatur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ISWC</title>
		<meeting>of ISWC</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="259" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">PromptDiff: a fixed-point algorithm for comparing ontology versions</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the national conference on artificial intelligence</title>
		<meeting>the national conference on artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="744" to="750" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Representation of change in controlled medical terminologies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shortliffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif Intel Med</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="76" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">On detecting high-level changes in RDF/S KBs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Papavassiliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Flouris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Fundulaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Christophides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Prof of ISWC</publisher>
			<biblScope unit="page" from="473" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Ontology change detection using a version log</title>
		<author>
			<persName><forename type="first">P</forename><surname>Plessers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Troyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ISWC</title>
		<meeting>of ISWC</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Func: a package for detecting significant associations between gene sets and ontological annotations</title>
		<author>
			<persName><forename type="first">K</forename><surname>Prüfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Muetzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Khaitovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">41</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Towards large scale schema and ontology matching</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Schema matching and mapping</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Bellahsene</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="3" to="27" />
		</imprint>
	</monogr>
	<note>chapter 1</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A survey of approaches to automatic schema matching</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="334" to="350" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">NCI thesaurus: a semantic model integrating cancer-related clinical and molecular information</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sioutos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Coronado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Haber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Hartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Shaiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Biomed Inform</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="43" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The OBO foundry: coordinated evolution of ontologies to support biomedical data integration</title>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ashburner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rosse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bug</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ceusters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat Biotechnol</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1251" to="1255" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Relations in biomedical ontologies</title>
		<author>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ceusters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Klagges</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Köhler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lomax</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">46</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The mammalian phenotype ontology as a tool for annotating, analyzing and comparing phenotypic information</title>
		<author>
			<persName><forename type="first">C</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Goldsmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eppig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">User-driven ontology evolution management</title>
		<author>
			<persName><forename type="first">L</forename><surname>Stojanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maedche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Stojanovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowl Eng Knowl Manage: Ontol Semantic Web</title>
		<imprint>
			<biblScope unit="page" from="133" to="140" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Ontoedit: collaborative ontology development for the semantic web</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sure</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Erdmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angele</forename><forename type="middle">J</forename><surname>Staab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Studer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wenke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of ISWC</title>
		<meeting>of ISWC</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="221" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Mapping between the obo and owl ontology languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tirmizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Aitken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Moreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mungall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shah</surname></persName>
		</author>
		<idno>S3</idno>
	</analytic>
	<monogr>
		<title level="j">J Biomed Semantics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">Suppl 1</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Ontology analysis on complexity and evolution based on conceptual model</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data integration in the life sciences</title>
		<imprint>
			<biblScope unit="page" from="216" to="223" />
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Community-driven ontology matching</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Zhdanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shvaiko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>ESWC</publisher>
			<biblScope unit="page" from="34" to="49" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
