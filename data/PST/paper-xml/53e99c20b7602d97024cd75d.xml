<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multicast with Network Coding in Application-Layer Overlay Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ying</forename><surname>Zhu</surname></persName>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Baochun</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jiang</forename><surname>Guo</surname></persName>
						</author>
						<title level="a" type="main">Multicast with Network Coding in Application-Layer Overlay Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">275B4E3B78B676271EAD37EA08889F3B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Application-layer overlay networks</term>
					<term>network coding</term>
					<term>application-layer multicast</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>All of the advantages of application-layer overlay networks arise from two fundamental properties: (1) The network nodes in an overlay network, as opposed to lower-layer network elements such as routers and switches, are end systems and have capabilities far beyond basic operations of storing and forwarding; and (2) The overlay topology, residing above a densely connected IP-layer wide-area network, can be constructed and manipulated to suit one's purposes.</p><p>In this paper, we seek to significantly improve end-to-end throughput in application-layer multicast by taking full advantage of these unique characteristics. This objective is achieved with two novel insights. First, we depart from the conventional view that data can only be replicated and forwarded by overlay nodes. Rather, as end systems, these overlay nodes also have the full capability of encoding and decoding data at the message level using efficient linear codes. Second, we depart from traditional wisdom that the multicast topology from source to receivers needs to be a tree, and propose a novel and distributed algorithm to construct a 2-redundant multicast graph (a directed acyclic graph) as the multicast topology, on which network coding is applied. We design our algorithm such that the costs of link stress and stretch are explicitly considered as constraints and minimized. We extensively evaluate our algorithm by provable analytical and experimental results, which show that the introduction of 2-redundant multicast graph and network coding may indeed bring significant benefits, essentially doubling the end-toend throughput in most cases.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Due to the lack of a widely available IP multicast service at the network layer in backbone networks, recent research (e.g., <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>) has examined the feasibility and trade-offs of implementing multicast services in the application layer. The general approach common to all existing proposals is to have applications self organize into a logical overlay network, and to transfer data along the edges of such an overlay network using unicast transport services. Each application-layer node communicates only with its neighbors in the overlay network. Multicasting is implemented by forwarding messages along overlay multicast trees that are constructed and embedded in the virtual overlay network.</p><p>Application-layer multicast, in general, enjoys two attractive advantages over traditional IP multicast: <ref type="bibr" target="#b0">(1)</ref> Multicast support in the network layer is not required; <ref type="bibr" target="#b1">(2)</ref> Data is transmitted between nodes via unicast, effectively exploiting all existing security, flow control and reliable delivery mechanisms that are Ying Zhu, Baochun Li and Jiang Guo are with the Department of Electrical and Computer Engineering, University of Toronto. Their email addresses are {yz, bli, jguo}@eecg.toronto.edu.</p><p>readily available and mature. However, an overlay multicast approach, however efficient, cannot perform as well as IP multicast. It is impossible to completely prevent multiple overlay edges from traversing the same physical link, causing unavoidable redundant traffic (identical copies of applicationlayer messages) on the same link, referred to as link stress <ref type="bibr" target="#b0">[1]</ref>. Further, unicast communication between end systems involves traversing other end systems, potentially increasing latency. It is therefore critical to evaluate and seek to minimize both the relative increase of end-to-end latencies (caused by link stretch <ref type="foot" target="#foot_0">1</ref> ) and the increase in per-link bandwidth requirements as compared with network-layer multicast.</p><p>Beyond what has been extensively studied in previous work, we emphasize that the advantages of deploying applicationlayer overlay networks arise from two fundamental properties.</p><p>(1) Network nodes in an overlay network, as opposed to lowerlayer network elements such as routers, are end systems and have capabilities far beyond basic operations of storing and forwarding. <ref type="bibr" target="#b1">(2)</ref> The topology of an overlay network can be manipulated willfully to suit one's purposes since it resides on top of a densely connected IP-layer network. The links between nodes can be dynamically created or torn down to construct topologies that are conducive to better network performance. Recent research in application layer multicast (e.g., <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>) has shown that it may well be worth the incurred cost of topology construction and maintenance to profit in increased robustness, flexibility and efficiency.</p><p>In this paper, we seek to improve end-to-end session throughput in an application-layer overlay multicast topology by taking full advantage of both of these unique characteristics. We deviate from the conventional view that data can only be replicated and forwarded by overlay routing nodes. Rather, as end systems, these overlay nodes also have the full capability of encoding and decoding data. We apply the mechanism of network coding <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref> on intermediate overlay nodes. In addition, we also depart from the traditional wisdom that the multicast topology needs to be a tree from source to receivers; rather, we seek to construct a 2-redundant multicast graph (a directed acyclic graph to be defined in Sec. III) as the multicast topology, on which network coding is applied. Based on these insights, our main contribution is to propose a set of distributed algorithms to construct such multicast graphs and to subsequently assign linear codes and apply network coding, such that as a provable property, the endto-end throughput may be significantly increased (doubled in many cases) for all members of the multicast group. Since overlay multicasts come with the cost of link stress and stretch, we design our algorithm such that these costs are explicitly considered as constraints and optimized. Achieving the objective of increasing end-to-end multicast throughput is particularly important when applications such as content distribution services demand the highest capacity possible in overlay networks. We extensively evaluate our algorithm by using both analytical and simulation-based experimental tools. We show that our algorithm is indeed able to bring significant benefits with respect to increasing end-to-end session throughput.</p><p>The remainder of this paper is organized as follows. Sec. II motivates the case for application-layer coded multicast, by presenting concepts, advantages and requirements of network coding. Sec. III presents formal definitions of terms, leading to the main theorem with respect to the maximally achievable throughput with network coding. Our algorithm is formally presented in Sec. IV, along with its provable properties and relevant discussions. Sec. V presents experimental results using simulations. Finally, Sec. VI evaluates our proposal in the context of related work, and Sec. VII concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. A CASE FOR APPLICATION-LAYER CODED MULTICAST</head><p>The main contributions of this paper are: (1) constructing multiple data paths from source to multicast group members, and (2) applying the concept of network coding in applicationlayer multicasts, motivating the case for application-layer coded multicast. The objective is to take advantage of alternate paths and excess capacity in the IP-layer network topology, and to significantly increase end-to-end multicast capacity.</p><p>The information-theoretic aspects of network coding was first proposed and studied by Ahlswede et al. <ref type="bibr" target="#b4">[5]</ref>. With network coding, nodes have the capability of encoding and decoding data at the per-message level using efficient linear codes; the aim is to use bandwidth more efficiently and thereby increase network capacity.</p><p>We briefly review the concepts of network coding with an example shown in Fig. <ref type="figure" target="#fig_1">1(c</ref>). The example shows how the session throughput of an 1-to-2 multicast session may be improved. In the figure, a and b represent two independent information flows originating from the source S. Node u 3 transmits the coded flow a ⊕ b along the "bottleneck" link u 3u 4 to node u 4 , which then forwards the coded flow to both destinations t 1 and t 2 . Receivers t 1 and t 2 can recover {a, b} from {a, a ⊕ b} and {b, a ⊕ b}, respectively. The session achieves a throughput of 2C, assuming each link has capacity C. Without network coding, it can be verified that the achievable throughput is only 3C/2.</p><p>However, network coding is not the panacea when it comes to increasing multicast session throughput. There exist many topologies -including all forms of multicast trees -where network coding fails to be more effective with respect to improving throughput. It helps to increase throughput only in network graphs that conform to special patterns. It is extremely difficult to manipulate nodes in the IP layer to construct multicast graphs that conform to specific patterns, and it is infeasible to modify all IP routers and switches to support coding. Overlay networks, on the other hand, have exactly the properties that could be leveraged to employ network coding for higher throughput in application-layer multicast: flexibility in topology construction, and capability of encoding and decoding.</p><p>Traditionally, the fundamental topological structure of multicast, whether it be IP-layer or application-layer, is a tree. Hence, every multicast group member in the tree has only one path from the source root; its throughput is limited by this path. To increase throughput by adding another path from the source to each receiver, one is faced with two problems: (a) The gain may be overshadowed by the cost<ref type="foot" target="#foot_1">2</ref> of the additional links and nodes in the alternative paths. (b) One must ensure that the alternative paths do not conflict with the original paths in order to avoid throughput-limiting bottlenecks. (c) Throughput is doubled with network coding and alternative paths (dark edges form second path for t 1 , second path for t 2 is the mirror image).</p><p>(d) Throughput is doubled using alternative paths, but not using network coding.  We propose a new application-layer multicast strategy that, by appropriate use of network coding, will resolve these problems and achieve the higher throughput without commensurate cost or complexity. We use the previous example to illustrate how we apply network coding advantageously. The overlay network is represented by the graph in Fig. <ref type="figure" target="#fig_1">1(a)</ref>, in which t 1 and t 2 are the two receivers in the multicast group, and s is the source. Each edge has the same bandwidth of 1 except that the bandwidth available on edge (s, u 3 ) is w 1. This is the case when, for example, s can not sustain an outgoing bandwidth of much more than 2. The usual all-widest-paths multicast tree is shown in Fig. <ref type="figure" target="#fig_1">1(b)</ref>; the widest alternative paths are added in Fig. <ref type="figure" target="#fig_1">1</ref>(c), while the other choice of (narrower) alternative paths are shown in Fig. <ref type="figure" target="#fig_1">1(d)</ref>.</p><p>Without network coding, it is impossible to double throughput in Fig. <ref type="figure" target="#fig_1">1(c</ref>), since the alternative paths to t 1 and t 2 interfere with each other's widest paths such that they cannot both double their throughput. The conflict can be eliminated by choosing the paths in Fig. <ref type="figure" target="#fig_1">1(d</ref>), but the bandwidth of the alternative paths is much less (narrower) than that of the original tree, again making it not feasible to double the throughput. This example exemplifies the two concerns specified previously. With network coding, however, the graph in Fig. <ref type="figure" target="#fig_1">1</ref>(a) can be safely used in the multicast to double the throughput to both receivers, as shown in Fig. <ref type="figure" target="#fig_1">1(c</ref>). The tremendous power of network coding lies in the fact that any conflicts resulting from interfering paths in the multicast graph can be resolved to obtain the same throughput for each receiver as if it was the only receiver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PRELIMINARIES</head><p>We consider a network graph with a source node s and a set of multicast group members as receiver nodes (or simply receivers). We define two notions of maximum flow and kredundant multicast graph.</p><p>Definition 1 (individual maxflow). Given any single receiver t, we say that the individual maximum flow (or simply "individual maxflow") of t is the maximum flow from s to t when data flows from s only to t, and the other receivers are not considered except as part of the subgraph serving the data flow from s to t.</p><p>Definition 2 (simultaneous maxflow). When all multicast group members receive data flowing from s simultaneously, i.e., a multicast, the maximum flow that a receiver t achieves is the simultaneous maximum flow of t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (k-redundant multicast graph).</head><p>A kredundant multicast graph for single-source multicast is a directed acyclic graph (DAG) which has the following two properties:</p><p>1) The set of all nodes, A, is the union of three disjoint subsets {s} ∪ A I ∪ A T : {s}, the source, indegree(s) = 0 and outdegree(s) &gt; 0; A I , the intermediate nodes (who are not members of the multicast group), denoted by u i , 1 ≤ i ≤ n I , 1 ≤ indegree(u i ) ≤ k and outdegree(u i ) &gt; 0; A T , the receiver nodes (i.e., multicast group members), denoted by t i , 1 ≤ i ≤ n T , indegree(t i ) = k and outdegree(t i ) ≥ 0; 2) If each edge in the graph has unit bandwidth, then for any node whose indegree is k, its individual maxflow is k.</p><p>In particular, since the indegree of all receivers is k, the individual maxflow of each receiver t is k, if the graph has unit-bandwidth edges. If edges have different bandwidths, then the individual maxflow of t is clearly k times the bandwidth of the bottleneck edge between s and t. Without loss of generality, we can assume that all the edges have the same bandwidth (that of the bottleneck). This assumption will be made throughout this section to simplify presentation of proofs.</p><p>Let n = 1 + n I + n T be the total number of nodes. In this paper, we only consider the case of 2-redundant multicast graphs. The justifications are two-fold: (1) As k increases, both the sustainable physical link stress leading to overlay nodes and the limited number of intermediate nodes and receivers significantly decrease the probability of finding multiple good paths from the source to each receiver. In the example of Fig. <ref type="figure" target="#fig_1">1(a)</ref>, when the sustainable stress on all nodes is no greater than 3 incoming and outgoing flows, it is infeasible to construct a k-redundant multicast graph if k &gt; 2. (2) As k increases, the code assignment algorithm (Sec. IV-F) becomes more complex and averse to the dynamics of node joins and departures.</p><p>We now establish the sufficiency of a maximum indegree of 2 in a 2-redundant multicast graph. It is not immediately clear why no node in the graph needs more than two incoming edges to ensure individual maxflow of 2 to each receiver. We prove that a maximum indegree of 2 is sufficient by first proving the following observations (Proposition 1 and 2) about disjoint paths.</p><p>Definition 4 (disjoint paths). We say two paths from s to t are disjoint if they do not share any common edges.</p><p>Proposition 1: Given a node t with indegree 2 in a 2redundant multicast graph with source s and unit-bandwidth edges, t has two disjoint paths from s if and only if t has individual maxflow of 2.</p><p>Proof: (⇒) This direction is straightforward. It is obvious that if there are two disjoint paths to t, then it has maxflow of 2. (⇐) A maxflow of 2 implies (in this case where edges have unit bandwidth) that there are two flows, f 1 , f 2 , each of bandwidth 1. Each flow clearly must define a path from s to t, let p 1 , p 2 denote the paths for f 1 , f 2 , respectively. If p 1 and p 2 share a common edge e, then f 1 and f 2 must share the bandwidth of e, which is only 1. So the value of each flow is 1/2, this is a contradiction. Therefore, p 1 and p 2 do not share any common edges and are two disjoint paths to t from s.</p><p>Proposition 2: It is not necessary for any node in a 2redundant multicast graph to have indegree of greater than 2 to obtain two disjoint paths for each receiver from s.</p><p>Proof: We only need to show that by constructing two disjoint data paths for a receiver t, it is not necessary for adding a third incoming edge to any node in the existing multicast graph. When constructing the first path p 1 , suppose, by contradiction, that a third incoming edge is to be added to a node u. This clearly is not necessary, since a path must exist from u to t, u → t, and a path must already exist from s to u (due to connectedness), s → u, and so p 1 can be simply a concatenation of s → u and that from u → t. This contradicts the necessity of adding the third incoming edge to u.</p><p>When constructing the second path p 2 , suppose, again by contradiction, that a third incoming edge is to be added to a node u. Since u has an indegree of 2, by property 2 in Definition 3 and Proposition 1, u must have two disjoint paths from s, denote them by su 1 , su 2 , respectively. There are two cases. Case 1: First path for t, p 1 , is disjoint from at least one of su 1 and su 2 . Without loss of generality, suppose p 1 is disjoint from su 1 , then p 2 can be constructed by concatenating su 2 and u → t. It is clear that p 2 thus formed is disjoint from p 1 . Case 2: Both su 1 and su 2 share common edges with p 1 . Without loss of generality, suppose the common edge closest to t is shared by su 1 and p 1 . Let v → w denote this common edge, and also let s → v denote the segment of su 1 until v and w → t denote the segment of p 1 from w to t. A new first path for t, p 1 , can then be constructed from concatenating s → v and w → t; and p 2 is formed by su 2 followed by u → t. It is easy to see that p 1 and p 2 are disjoint.</p><p>The property of 2-redundant multicast graphs that the maximum indegree of a node is 2 not only reduces complexity in the algorithm to construct the graph, but moreover contributes significantly towards minimizing stress.</p><p>Towards the objective of constructing a 2-redundant multicast graph, Proposition 1 shows the importance of constructing two disjoint paths from the source s to a receiver t. Further, directed acyclicity must be preserved in the construction of the multicast graph, i.e., there must be no directed cycles in the graph. Directed cycles in the network introduce great complexity and difficulty in determining the linear codes used for multicast <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>. In fact, Koetter et al. <ref type="bibr" target="#b5">[6]</ref> have not presented any solution for the case of general networks with cycles. We next show that, in order to construct a 2-redundant acyclic multicast graph, the set of intermediate nodes, A I , needs to be non-empty.</p><p>Proposition 3: A 2-redundant multicast graph with only receivers, i.e., every node beside s has two disjoint directed paths from s, contains a directed cycle.</p><p>Proof: Let t 1 be any node that has a directed edge from s. Since it has two disjoint paths from s, there is a second directed edge pointing to it from another node, say, t 2 , denoted by t 2 → t 1 . Similarly, t 2 has at least one incident directed edge from a node that is not s, say, t 3 . A chain of nodes may be built with t 2 → t 1 , t 3 → t 2 , and so forth. Since there exists a finite number of nodes, eventually t i becomes the same node as t j with j &lt; i, i.e., t j is in the chain before t i , thus forming a directed cycle.</p><p>Obviously, there may not exist two disjoint paths from s to each u i , which leads to the conclusion that multicast group members may not serve as intermediate nodes. We need to recruit dedicated high-degree relay nodes in the overlay network as intermediate nodes, who do not belong to the multicast group. For this purpose, we may deploy a pool of end hosts or proxy servers connected to high-bandwidth physical links. Naturally, the number of required intermediate nodes must be minimized, and scalable to large-scale multicast groups. Such a pool of dedicated nodes is the price we pay to exploit the power of network coding to significantly increase throughput. These intermediate nodes do not place much additional stress on the network, since they do not require multiple data delivery paths from the source. Facilitated by intermediate nodes, we seek to construct 2-redundant multicast graphs with no directed cycles (a DAG).</p><p>As an example, the multicast graph in Fig. <ref type="figure" target="#fig_1">1(c</ref>) is 2redundant, with receivers t 1 and t 2 both having two disjoint paths from s (as explained in Sec. II).</p><p>We now proceed to illustrate the essence of linear codes. Definition 5 (linear coding multicast). Linear coding multicast views a block of data flowing over an edge as a vector and assigns a linear transformation for each node u in the multicast graph such that:</p><p>-for each outgoing edge e of u, the vector sent out on e is a linear combination of the vectors of the incoming edges; -for source s, any vectors can be sent out on its outgoing edges; -all the vectors are in the same infinite-dimensional vector space over a base field. Linear codes are the coefficients that determine the linear transformations. For example, in Fig. <ref type="figure" target="#fig_1">1(c</ref>), the data sent by u 3 on the outgoing edge is a linear combination of {a, b}:</p><formula xml:id="formula_0">1 • a + 1 • b = a + b,</formula><p>where + is defined in a finite field, e.g., GF(256). Such a linear combination is represented as <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b0">1)</ref>.</p><p>The main result of network coding, first proposed in <ref type="bibr" target="#b6">[7]</ref> (a slightly weaker version was proposed earlier in <ref type="bibr" target="#b4">[5]</ref>), is stated in the following theorem. It essentially states that in an acyclic network with a source and multiple receivers, the maximum individual throughput of each receiver can always be achieved as if there was no interference at all from data flowing in the network to the other receivers, by using only linear coding.</p><p>Theorem 1 (Li and Koetter). For every multicast graph, there exists a set of linear codes that could be used for multicast (linear coding multicast) such that simultaneous maxflow of t i is equal to individual maxflow of t i .</p><p>Proof: The interested reader is referred to <ref type="bibr" target="#b5">[6]</ref> or <ref type="bibr" target="#b6">[7]</ref> for detailed proofs using different methodologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. ALGORITHM AND ANALYSIS</head><p>The ultimate goal of our algorithm is to build and maintain a 2-redundant multicast graph as defined in Sec. III. There are several non-trivial challenges. Our algorithm addresses each of these challenges, and much of the complexity lies in tackling all of them in conjunction. <ref type="bibr" target="#b0">(1)</ref> In order to subsequently apply network coding, we need to correctly construct a 2-redundant acyclic multicast graph from the source to all members of the multicast group <ref type="foot" target="#foot_2">3</ref> . During the construction process, data delivery paths should be optimized in the multicast graph to the receivers. Each receiver essentially has two paths from the source; both paths should be carefully chosen to maximize the aggregated throughput to the receiver. (2) We need to minimize the number of intermediate nodes with a given number of receivers while preserving good performance. (3) Minimizing stress is paramount since it directly determines how much actual bandwidth a virtual link has and high stress can severely diminish end-to-end throughput. These problems embody the fundamental objective of maximizing multicast performance (end-to-end throughput and latency) while minimizing the penalty incurred by elevating the functionality of multicast from the IP layer to the application layer and by using a multicast graph instead of a multicast tree. In particular, minimizing stretch is an integral part of optimizing the paths and minimizing stress is covered by imposing a maximum node degree in the multicast graph.</p><p>The algorithms we developed for our multicast scheme are fully distributed. Our scheme mainly consists of three steps. The first step is building a relatively densely connected graph of the set of all nodes in the group, A, referred to as the rudimentary graph. Fig. <ref type="figure" target="#fig_2">2</ref>(a) shows a simple example of a rudimentary graph of a small multicast group with 7 nodes; the intermediate nodes, A I , consist of {u 1 , u 2 , u 3 }. The second and third steps are carried out for data delivery. In the second step, a spanning tree of only the intermediate nodes with source s as the root is constructed, referred to as rudimentary tree. With node r 1 being the source s, the rudimentary tree is shown, as darkened edges with incident nodes, in Fig. <ref type="figure" target="#fig_2">2(a)</ref>. Using the rudimentary graph and tree, the third step constructs the 2-redundant multicast graph by carefully selecting two paths through intermediate nodes from the source for each leaf receiver. In our simple example, the leaf receivers A T = {r 2 , r 3 , r 4 } each has two disjoint paths from s, as shown in Fig. <ref type="figure" target="#fig_2">2(b)</ref>.</p><p>Both the rudimentary tree and the multicast graph have the degree constraint: every node has degree ≤ ∆; i.e., ∆ is the maximum node degree. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Rudimentary graph</head><p>When a node joins the group, it is given a set of nodes already in the group, these are its initial neighbors in the rudimentary graph. The new node contacts its neighbors so they are made aware of it. Every node maintains a set of neighbors with which it periodically exchanges group information. That is, each node stores a list of the addresses of all the nodes it knows about in the group and periodically exchanges it with its neighbors' lists, and updates accordingly. After a node joins, the information will eventually propagate through the rudimentary graph.</p><p>Each edge (or link), e, in the rudimentary graph has associated with it a 2-tuple weight, w(e) = (β, λ), where β is the link bandwidth and λ is the link latency. Each path, p = (e 1 , e 2 , . . . , e m ), also has an associated weight, w(p) = (β, λ), and β = min(β i , i = 1, . . . , m), λ = m i=1 λ i , where w(e i ) = (β i , λ i ). As usual, path bandwidth is the minimum of the link bandwidths and path latency is the sum of the link latencies. Let w(p 1 ) = (β 1 , λ 1 ), w(p 2 ) = (β 2 , λ 2 ) be the weights of p 1 , p 2 , respectively. p 1 is better than</p><formula xml:id="formula_1">p 2 if β 1 &gt; β 2 , or β 1 = β 2 and λ 1 &lt; λ 2 .</formula><p>Also, periodically, each node u chooses randomly another node v in the group that is not a neighbor and by sending a probing message, estimates the bandwidth and latency of the direct overlay link, (u, v). If the direct link is better than most of its (direct) links to its current neighbors, then v is added as a neighbor of u and the edge (u, v) is added to the rudimentary graph. The goal is to have overlay links (edges) that have good performance in the rudimentary graph. Let x be a current neighbor of u. From the same motivation, if (u, x) is much worse than the links u has to its other neighbors, and both u and x use this link rarely (i.e., use it to reach very few nodes), then u drops x as its neighbor and (u, x) is removed from the rudimentary graph.</p><p>The dynamics of adding high-quality edges and dropping poor-quality edges is vital to the performance of the entire multicast scheme. Because, ultimately, the edges in the rudimentary graph are used to construct the data delivery paths, whose performance depends directly on the property (i.e., weight) of these edges.</p><p>The graph resembles the Narada mesh <ref type="bibr" target="#b0">[1]</ref>, with the following important differences: (1) For every intermediate node, the number of its neighbors that are intermediate nodes must be no larger than ∆. This is necessary to ensure that the maximum degree of nodes in the rudimentary tree (of intermediate nodes) constructed from this graph is limited by ∆. (2) For every node (intermediate or not), the total number of its neighbors may be larger than ∆. The algorithm for building the multicast graph later explicitly enforces the ∆ degree constraint, so nodes in the rudimentary graph can have more than ∆ neighbors. Since these extra links are for control messages and not for data transmission, more of them can be allowed without raising concerns about performance degradation. (3) The subgraph of intermediate nodes with their incident edges must be connected.</p><p>Definition 6 (core graph). The core graph is the subgraph of the rudimentary graph with the set of vertices A I and all the incident edges.</p><p>The core graph is kept connected by the same heuristics used for keeping the entire graph connected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Rudimentary tree</head><p>The rudimentary tree is built from the subgraph consisting of the core graph and s (with its ≤ ∆ edges incident with the core). We adopt the distributed algorithm proposed by Wang et al. <ref type="bibr" target="#b7">[8]</ref> based on distance vectors that finds the shortest widest paths. The widest path, or the path with the highest end-to-end bandwidth, is selected; and if there is more than one widest path, the shortest, one with the lowest end-to-end latency, is selected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Multicast graph</head><p>The basic idea of building the multicast graph is to use the rudimentary tree as a basis and add edges, when necessary, from the rudimentary graph. Construction of the 2-redundant multicast graph G 2r adheres to the following rules for source node s and every intermediate node u:</p><formula xml:id="formula_2">1) s has k intermediate nodes as children and 2 ≤ k ≤ ∆ -1 (outdegree(s) = k); 2) total degree of u = indegree(u) + outdegree(u) ≤ ∆; 3) 1 ≤ indegree(u) ≤ 2; 4) number of children of u that are leaf receivers ≤ ∆ -1-indegree(u).</formula><p>The fourth rule forces an intermediate node to leave at least one outdegree available for adding an edge to another intermediate node. This ensures that the search for a path is always successful as long as there are enough intermediate nodes in the rudimentary graph, without resorting to expensive exhaustive search.</p><p>We shall use a running example throughout the description of the algorithm to help illustrate how the algorithm works. The core graph of the rudimentary graph and the rudimentary tree of the example are shown in Fig. <ref type="figure">3</ref>. Note that the maximum degree, ∆, is 4 in our example. We now need to define two additional terms. Definition 8 (saturation). We say v is saturated if either degree(v) = ∆, or v is a leaf intermediate and degree(v) = ∆ -1.</p><p>For instance, in the G 2r in Fig. <ref type="figure">4</ref>(b), u 7 is a leaf intermediate node while u 3 is not. If we assume ∆ = 4 for the graph in Fig. <ref type="figure">4</ref>(b), then u 1 will be saturated if one leaf receiver is connected to it. While u 7 will be saturated if two leaf receivers are connected to it. Even when a leaf intermediate node is saturated, there is an outdegree preserved from leaf receiver to allow possibility of adding at least one child intermediate node.</p><p>The 2-redundant multicast graph G 2r is initialized to the rudimentary tree, so initially it has no leaf receivers. Adding each leaf receiver t entails constructing two disjoint data delivery paths for t. Edges not in the tree (but in the rudimentary graph) may be added to G 2r in the process. We now describe procedures for obtaining two disjoint paths, p f and p s , for a leaf receiver t. The distributed algorithms are formulated in Table <ref type="table" target="#tab_2">I</ref> and Table <ref type="table" target="#tab_2">II</ref>.</p><p>We seek to create, for t, two data delivery paths from s, denoted by p f and p s , denoting the first path and the second path, respectively. Moreover, p f and p s do not share any edges in common.</p><p>To find p f , t first contacts all its neighbors in the rudimentary graph that are intermediate nodes and finds out which are unsaturated. If t has unsaturated neighbors, then t compares their tree paths appended with the edge from them to t, and selects node u with the best path. Let u f denote the node that is parent of t in p f , then u f is assigned u. If all of t's neighbors are saturated, t initiates a breadth-first search of the tree to find the first k unsaturated nodes. Comparison of the k tree paths appended by respective edges from these nodes to t yields node u with the best path. As above, u f is set to u. In either case, p f = P (s, u f ) ∪ (u f , t), where P (s, u f ) is the tree path from s to u f .</p><p>The primitive of the breadth-first search of the tree used in the procedure will recur in later procedures. The details of its implementation are presented in Sec. IV-D. The number k represents a trade-off between efficiency of the algorithm and optimality of the path constructed. It should not be too high to avoid near-exhaustive search of the tree for an unsaturated node, when there are many leaf receivers saturating many nodes.</p><p>Suppose we want to construct p f , p s for t with the rudimentary graph and tree in Fig. <ref type="figure">3</ref>, and the existing 2-redundant multicast graph is as shown in Fig. <ref type="figure">4</ref> In our example, the unsaturated nodes t considers are u 4 , u 8 . t chooses the best path from the directed paths (s, u 1 , u 4 , t) and (s, u 1 , u 4 , u 8 , t), as shown in Fig. <ref type="figure">4(b</ref>). If the better path is the first one, then p f for t is shown in Fig. <ref type="figure">4(c</ref>). To keep the figures clean, the directions on the edges in the multicast graphs in later figures are omitted. The directions of the edges are uniformly downward.</p><p>For reference, the procedure for determining p s is presented in Table <ref type="table" target="#tab_2">II</ref>. The leaf receiver t first finds k unsaturated nodes {u i }, which are not in p f , from its neighbors. If there are fewer than k such neighbors, t randomly probes intermediate nodes. Now each u i is requested by t to give the best path, p i , from s to u i . After t receives p i 's and w(p i )'s from all the u i 's, t simply selects the best path among {p i ∪ (u i , t)}. Let u s denote the parent intermediate node of the best path p that t selects. The second data delivery path to t is p s = p∪(u s , t).</p><p>Each u i , when requested by t, first checks if its tree path P (s, u i ) intersects with p f . If not, then P (s, u i ) is returned. If it does intersect, then u i finds an alternative path from s. An alternative path may already exist (if u i has indegree 2), in which case, u i replies with that. Otherwise, u i sends a message to a child node c of s that is different from the child s who is upstream from u i . It is a request for c to do a breadth-first search of its own subtree and reply to u i the first unsaturated or leaf intermediate node found. Let v denote this node. u i replies to t with P (s, v) ∪ (v, u).</p><p>Note that the search will always be successful, since a breadth-first search will always eventually find a leaf intermediate node. This is not true if the search was only for unsaturated nodes. Moreover, the algorithm requires for each leaf intermediate node to leave one outdegree free for an edge to another intermediate node (recall the definition of node saturation). This is the reason that we allow adding a second incoming edge to u i . The rationale behind the allowance is quite intuitive: we are trying to find two best paths from s to t which must be disjoint, it is entirely possible that they do not both belong to the rudimentary tree.</p><p>Returning to our example, we let k = 2. For constructing p s , t first finds two unsaturated nodes that are not in p f : u 7 and u 8 . t then sends requests to u 7 , u 8 for their best paths from s. The tree path of u 7 from s does not intersect with p f , so u 7 will return its tree path p = (s, u 3 , u 7 ). If t chooses p ∪ (u 7 , t) as the best path, then p s is shown in Fig. <ref type="figure" target="#fig_4">5(a)</ref>. Since u 8 is in the same subtree as u 4 , it will need to find an alternative path from s, p = (s, u 2 , u 6 , u 8 ). If p ∪ (u 8 , t) is a better path than {(s, u 3 , u 7 )} ∪(u 7 , t), then p s is shown in Fig. <ref type="figure" target="#fig_4">5(b</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Breadth-first search primitive</head><p>Breadth-first search of a tree to find unsaturated nodes can be made much more efficient than blind and exhaustive search. Keeping record of the states of saturation of the subtrees of children is not hard. When a node first becomes saturated, it simply sends that information upstream in the multicast graph. Recursively, a node, which is the root of subtree R, knows R is saturated when all its children have sent saturation notification to it. In this case, the breadth-first search takes guidance from the indicators of subtree saturation at the roots of subtrees. If the subtree is saturated, then no node in the subtree is searched henceforth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Analysis</head><p>We prove the correctness of the algorithm, show some bounds on the number of intermediate nodes required, and discuss scalability.</p><p>Theorem 2. The graph constructed by the algorithm is indeed a 2-redundant multicast graph.</p><p>Proof: The graph is 2-redundant by construction, i.e., it is constructed to be such that each leaf receiver has two disjoint paths from the source. We only need to show that the graph constructed is acyclic. We show by induction that this holds. The initialization of the graph is the rudimentary tree with directed edges from parent to child, which is certainly acyclic. Suppose an existing multicast graph is acyclic. We now prove that after adding a new leaf receiver t, the multicast graph remains acyclic. Let p f , p s be the two paths chosen for t. If p f , p s were already in the multicast graph, then only two directed edges to t are added, and the resulting graph is clearly still acyclic.</p><p>Suppose new edges are added to the graph for p f and p s . For p f , only an edge directed to t is added, so no cycle is introduced.</p><p>For p s , there are two cases. The first case is when the parent node of t in p s , u s , is not in the same subtree as the nodes in p f . p s is the path P (s, u s ) in the rudimentary tree plus the added edge from u s to t, which is the same scenario as for p f above, hence no cycle exists.</p><p>The second case is when u s is in the same child-subtree of s as nodes in p f . So a directed edge (w, u s ) not in the rudimentary tree is added (in addition to (u s , t)), where w is in a different subtree. We prove by contradiction that the directed edge (w, u s ) cannot be part of a cycle. Suppose that a cycle containing (w, u s ) indeed exists. Since w and u s are in different child-subtrees of s, there must be a directed edge (u, v) in the cycle such that u is in the same child-subtree of s as u s , while v is in a different child-subtree. Moreover, u is a descendant of u s . The edge (u, v) was added before and when it was added, u s was unsaturated. But (u, v) exists only if a breadth-first search from the top yielded that u s was saturated, otherwise, (u s , v) would have been chosen instead. This is a contradiction.</p><p>With the restriction of maximum degree, ∆, on the nodes in the multicast graph, the number of intermediate nodes needed increases with the number of leaf receivers. For n T leaf receivers, we would like to determine the maximum and minimum number of intermediate nodes possible. It may be easier to consider the contrapositives of these: (1) the maximum number of leaf receivers possible, in a 2-redundant multicast graph, n T max , for a given number of intermediate nodes, and (2) the minimum number of leaf receivers that can saturate a 2-redundant multicast graph using the above algorithm, n T min .</p><p>Theorem 3. Given n I intermediate nodes,</p><formula xml:id="formula_3">nT max = ((∆ -2)nI + 1)/2 , (<label>1</label></formula><formula xml:id="formula_4">)</formula><formula xml:id="formula_5">nT min = ((∆ -4)nI + 1)/2 . (<label>2</label></formula><formula xml:id="formula_6">)</formula><p>Proof: It is easy to see that to prove Equation ( <ref type="formula" target="#formula_3">1</ref>) is equivalent to finding the number of leaves in a (∆-1)-regular tree. (An m-regular tree is a tree in which every non-leaf (i.e., intermediate) node has exactly m children.) The total number of children in tree = (∆ -1)n I = number of non-leaf nodes + number of leaf nodes + root = n I + n T + 1, and the claim follows directly. Now we prove Equation (2). As above, consider the (∆-1)regular tree. Starting with this tree, the number of leaf nodes decreases every time the algorithm adds a second incoming edge to a non-leaf (intermediate) node. There are two incident nodes of this additional edge and the degree of each decreases by 1, which means that the number of children of each decreases by 1. So each such second incoming edge added decreases the total number of children by 2. The worst case is when every non-leaf node has a second incoming edge. Therefore, the least number of total children is (∆ -1)n I -2n I = n I + n T + 1, and the claim follows.</p><p>Now we discuss the issue of scalability, by first noting that each node only exchanges control messages with a constant number of neighbors. The steps of building the rudimentary graph and the rudimentary tree is a variant of the distancevector algorithm (also known as the distributed Bellman-Ford algorithm), which has been proven to converge and has time complexity of O(V E), where V is the number of nodes and E is the number of links. Since the number of neighbors is constant for each node, the complexity for n nodes O(n 2 ). Similarly, the overhead of control messages for constructing the rudimentary graph and tree is the same as that for the distance-vector algorithm, variants of which are commonly used in realistic networks (e.g., Border Gateway Protocol). Hence, our protocol is clearly scalable, in terms of both time complexity and control overhead, to high numbers of group nodes. It is easy to see that all the procedures in the last step are dominated, in time complexity and control overhead, by the procedure of finding k unsaturated nodes. All other operations are constant time with respect to n (the number of nodes). To find k unsaturated nodes, it takes constant time if a constant number of random probes are successful; otherwise, a special version of a breadth-first search, described in Sec. IV-D, is executed. A node needs to exchange control messages with at worst O(log n) other nodes, since our breadth-first search primitive includes record-keeping at the nodes. Thus the control overhead in the worst case is O(log n). Overall, it is clear that our graph-construction algorithm is scalable to large multicast group sizes.</p><p>To handle discrepancy in bandwidths or rates of two incoming flows, we resort to existing flow control mechanisms (e.g., TCP) to synchronize the incoming flow rates, as it is traditionally done for matching incoming and outgoing rates in a flow-controlled reliable connection. We know that the end-to-end throughput in a multicast tree is determined by the minimum bandwidth link in the tree. Since two incoming flows synchronize rates in a 2-redundant multicast graph, the end-to-end throughput is twice the minimum bandwidth in the two (disjoint) paths. To resolve a difference in latency of two incoming signals, buffer is needed; the buffer size is proportional to the latency difference and is finite. Since the nodes in the overlay network are end systems (with abundant memory space), the issue of available memory for buffering is not likely to be significant. It is also possible and not hard to add optimization techniques to the existing algorithm to minimize the latency difference when finding a pair of disjoint paths during graph construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Linear coding multicast</head><p>Once a multicast graph is constructed, a set of linear codes must be found to realize linear coding multicast. Both Koetter et al. <ref type="bibr" target="#b5">[6]</ref> and Li et al. <ref type="bibr" target="#b6">[7]</ref> give algorithms for constructing the linear codes. However, because both papers are theoretical in nature, Li et al. <ref type="bibr" target="#b6">[7]</ref> with an information-theoretic perspective while Koetter et al. <ref type="bibr" target="#b5">[6]</ref> has an algebraic-geometric formulation, their briefly described algorithms have been included mainly for completeness. The algorithms are moreover centralized, difficult to implement in a distributed manner, and intended for general multicast scenarios. Since the graphs constructed by our algorithm are of a specific structure, a more light-weight algorithm tailored for this specific type of multicast graphs can be devised.</p><p>We propose a distributed algorithm that is easy to implement for obtaining the linear codes for the 2-redundant multicast graph. We observe that coding is only needed at the source s and the intermediate nodes, and that an intermediate node has either one or two incoming edges (by construction). Furthermore, since each leaf receiver has exactly two paths from the source s, s sends the data vector (a, b) and both a and b should be obtained by each receiver. We assume that there is a function gen(m) that generates a sequence of m transformation vectors {(p 1 , q 1 ) T , (p 2 , q 2 ) T , . . . , (p m , q m ) T } such that p i , q i are elements in a field; -(p i , q i ) and (p j , q j ) are linearly independent, ∀i = j; -(p i , q i ) T defines a linear transformation of data vector (a, b):</p><formula xml:id="formula_7">c i = (a, b)(p i , q i ) T = p i • a + q i • b (p i , q i are</formula><p>coefficients of a linear combination of a, b), i.e., (p i , q i ) T determines a vector c i , ∀i. Hence c i and c j are linearly independent, ∀i = j. Let C = {c 1 , . . . , c m }. Essentially, gen(m) generates codes for m linear transformations. For example, gen( <ref type="formula">5</ref>) could be {(1, 0) T , (0, 1) T , (1, 1) T , (2, 1) T , (1, 2) T }, then the corresponding C would be {a, b, a + b, 2a + b, a + 2b}. Any two elements from C are linearly independent and therefore, a and b can be obtained from them. It follows that a leaf receiver is able to get both a and b as long as it receives any two distinct elements from the set C. We assign only one linear transformation to every intermediate node u, so u sends out the same data over all its outgoing edges.</p><p>• u has 1 incoming edge: the identity transformation is assigned, i.e., data on the incoming edge is forwarded, with no encoding, on all the outgoing edges; • u has 2 incoming edges: a transformation vector v u = (v 1 , v 2 ) T is assigned by the algorithm, so if x is received on one incoming edge and y on the other, then</p><formula xml:id="formula_8">(x, y)(v 1 , v 2 ) T = v 1 x+v 2 y</formula><p>is sent on all of u's outgoing edges. We will now describe how the v u 's are obtained for those u with indegree 2. The distributed algorithm has two phases, AssignCodes and DisseminateCodes. Due to the special topology of the 2-redundant multicast graph, we can assume that the source s is multicasting a 2-dimensional data vector (a, b) to every leaf receiver. Every node u ∈ A I will determine a vector w u = (p u , q u ) T such that the data sent on its outgoing edges is (a, b)(p u , q u ) T . This way, a node u with indegree 2 can obtain these from its two parent nodes and together with its own w u , it can easily obtain v u , as will be shown later.</p><p>In the AssignCodes phase, s first multicasts a message through the rudimentary tree to initiate the AssignCodes phase. If an intermediate node u has 2 incoming edges, then it sends a message containing its address to s requesting a code. When enough time has passed for all the nodes to have a chance to send requests, suppose m requests were received and s has j children, then s generates m+j linear codes using gen(m+j) and sends to each requesting node one of the first m codes. This vector will be the w u vector of u. The pseudocode is given in Table <ref type="table" target="#tab_7">IV</ref>.</p><p>The w i for nodes i with indegree 1 are determined in the DisseminateCodes phase (summarized in Table <ref type="table" target="#tab_7">V</ref>), followed by obtaining v u for every u, The last j vectors generated by gen(m + j) are sent by s to its children, one to each child. A child i of s assigns the received vector to its w i . Each node u with one incoming edge simply sets its w u to the vector received and forwards it on all its outgoing edges. (Also, u has the identity transformation.)</p><p>Each node u with two incoming edges already has w u = (p u , q u ) T from the AssignCodes phase and passes it onto its outgoing edges. Node u also receives (p 1 , q 1 ), (p 2 , q 2 ) on its incoming edges, respectively. Now u needs to determine v u = (v 1 , v 2 ) T . Let α, β denote the data received on the two incoming edges, respectively, then (α, β)(v 1 , v 2 ) T is the data u sends out on its outgoing edges.</p><p>We know u should send out (a, b)(p u , q u ) T , but we also know ( a b )</p><formula xml:id="formula_9">p 1 p 2 q 1 q 2 = ( α β )</formula><p>We have</p><formula xml:id="formula_10">( a b ) pu qu = ( α β ) p 1 p 2 q 1 q 2 -1 pu qu</formula><p>So the product of the matrix and vector on the right of (α, β) is the vector v u . This is correct only if the matrix in the equation is invertible, i.e., (p 1 , q 1 ) and (p 2 , q 2 ) are linearly independent. Two edges carry the same (p, q) only when they come out of the same intermediate node. But since the construction algorithm ensures that the paths containing one upstream node of u do not intersect with any path containing the other upstream node of u, except at s. Therefore (p 1 , q 1 ) and (p 2 , q 2 ) are linearly independent. The same logic applies to the leaf receivers, so the data on one incoming edge and the data on the other incoming edge are linearly independent. This, in fact, proves the correctness of the algorithm. Encoding at any intermediate node u is completely defined by the transformation vector v u if u has indegree 2 and no encoding is done at intermediate nodes with indegree 1. Decoding at the leaf receivers is simple, because in the DisseminateCodes phase, each leaf receiver gets the codes from its two upstream nodes and can use these to decode the data they receive. It only remains to find gen(m). We define gen(m) to be a set such that every (p, q) in the set is distinct and p, q are two prime numbers with p = q. It is clear that any two vectors are linearly independent, because they are only linearly dependent if one is a multiple of the other, which is impossible when they are not equal and are vectors of prime numbers. A function for generating primes in increasing order starting from 2 is used. It is straightforward to code such a function or find an existing efficient function. We give the algorithm in Table <ref type="table" target="#tab_5">III</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Complexity analysis of linear codes algorithm</head><p>In the AssignCodes phase, one initiate-session message is multicast through a tree, i.e., O(n) transmissions of the message occur, where n is the number of nodes; then O(m) messages are unicast between the source and intermediate nodes, where m is the number of intermediate nodes. The DisseminateCodes phase involves only each node sending one  = {(p 1 , q 1 ) T , (p 2 , q 2 ) T , . . . , (p m+j , q m+j ) T } for i = 1 to m send code, (p i , q i ) T to node at address node addr[i] Upon receiving start AssignCodes , each node u ∈ A I : if u has 1 incoming edge then do nothing else if u has 2 incoming edges then send message request code, address of u to s Upon receiving new code, (p, q) , each node u ∈ A I : u sets its wu: pu = p and qu = q message, including the codes assigned to it, to each of its downstream nodes. So the number of messages transmitted is exactly the number of edges in the multicast graph, the upper bound of which is 2n. Hence, the total number of control messages transmitted for the two phases is O(n). Let T the largest round-trip time or delay from the source to any node via the paths in the multicast graph. The largest roundtrip time between any two nodes via unicast, let it be denoted by t, is obviously dominated by T . The AssignCodes phase requires at most time 3T for exchanging messages. While the DisseminateCodes phase requires only time t, since all the transmissions are done in parallel and no forwarding of messages is necessary. As such, the overall time complexity is O(T ).</p><formula xml:id="formula_11">) i ← 1, j ← 1 primes[i] ← 2, vectors[m] ← (2, 2) Iteration: Find the next prime p, smallest p &gt; primes[i] for k = 1 to i j ← j + 1 vectors[j] ← (primes[k], p) if j = m then halt j ← j + 1 vectors[j] ← (p, primes[k]) i ← i + 1 primes[i] ← p</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PERFORMANCE EVALUATION</head><p>The primary objective of our evaluation process is to reveal the strengths and performance of our proposed algorithm with respect to network level metrics, and to compare with previously proposed representative multicast algorithms at both the application and the IP layer. At the application layer, we choose the Narada protocol <ref type="bibr" target="#b0">[1]</ref> to evaluate the merits of our algorithm, since as one of the first algorithms proposed in the application layer, it uses a two-step mesh-based process that is similar to our work (a detailed discussion is postponed to Sec. VI). At the IP layer, we assume that IP multicast involves constructing classical shortest-paths trees (e.g., using DVMRP for i = 1 to j send code, gen(m + i) to its ith child Each node u ∈ A I with indegree 1:</p><p>Upon receiving code, (p, q) T from its parent: set its wu: pu = p, qu = q send code, (pu, qu) T out on all its outgoing edges, i.e., to all its downstream nodes set linear transformation for all outgoing edges to the identity Each node u ∈ A I with indegree 2:</p><p>send code, (pu, qu) T out on all its outgoing edges Upon receiving code, (p 1 , q 1 ) T , code, (p 2 , q 2 ) T , respectively, from its two upstream nodes:</p><formula xml:id="formula_12">vu = v 1 v 2 = p 1 p 2 q 1 q 2 -1</formula><p>pu qu <ref type="bibr" target="#b8">[9]</ref>), composed of the reverse paths from the source to each receiver.</p><p>For the purpose of performance evaluation, we have resorted to simulation experiments, conducted using a locally written, message-level, event-based simulator. In accordance with the goal of simulating a realistic IP-based wide-area network, we have chosen the INET topology generator from the University of Michigan <ref type="bibr" target="#b9">[10]</ref>, which is fully capable of generating largescale topologies that conform to the power-law characteristics <ref type="bibr" target="#b10">[11]</ref>. Other topology generators may also be used, but we do not expect material deviations if the resulting topology maintains power-law properties.</p><p>With such a generated IP-based network topology as an underlying foundation, we selectively connect applicationlayer end hosts (i.e., overlay nodes) to a subset of IP-layer nodes in the IP topology. We require that the IP-layer nodes in such a subset have very few links (usually just a single link) to other IP-layer nodes, such that they represent edge nodes in the wide-area network with a high probability, rather than core routers. For the purpose of application-layer multicast, each virtual link in the overlay topology represent an unicast path between two end hosts in the IP topology. With respect to network-level metrics, we use a similar simulation environment as Narada to facilitate more accurate comparisons: we assume identical availability of residual bandwidth on all physical links in the backbone IP topology, as well as randomly assigned link delays in the range of 8 -12 ms.</p><p>Given IP-layer physical link delays and available bandwidth, it is straightforward to derive the delays and bandwidth of virtual links in the overlay. The delay of a virtual link is, obviously, the sum of physical link delays that the virtual link traverses. Calculating the bandwidth of a virtual link is more involved, however, since there may exist multiple virtual links sharing the same physical link (stress). In this case, the physical link bandwidth is equally divided among all the virtual links passing through. Finally, the available bandwidth on a certain virtual link is the minimum available bandwidth of all the physical links (i.e., the physical link with the most stress) that it traverses. With the knowledge of delay and bandwidth of a virtual link, the 2-tuple weight of the link, detailed in Sec. IV, may be obtained.</p><p>We consider the following performance metrics in our simulation:</p><p>-Multicast session throughput. We measure applicationlayer throughput at each of the receivers. -End-to-end delay. We measure end-to-end latency from the source to the receivers, as perceived at the application layer, which naturally incorporates stretch. -Stress. We measure stress on the physical links leading to overlay nodes, and also compute the normalized stress (the ratio of stress over the achievable session throughput). -Resource usage. We measure the number of physical links, L, that are actively in service for a multicast session. The resource usage may be defined as</p><formula xml:id="formula_13">L i=1 d i • s i</formula><p>, where d i is the delay of link i, and s i is its stress. The resource usage is a metric that corresponds to the consumed network resources for data delivery to all receivers in a multicast session. The resource usage should also be normalized over session throughput. We plot session throughput at the receivers as a function of the number of receivers. Our Coded Multicast scheme does not perform as well as DVMRP, as expected. The endsystem nodes in overlay networks are often at the boundaries of the IP network, where there are fewer underlying physical links. Inevitably, a number of virtual links will map to the same physical link near an end-system, introducing stress on those few physical links around the end-systems. Stress creates bottleneck links that decrease session throughput. This is an inherent problem of application-layer multicast. Thus the figure shows that Narada has much lower throughput than DVMRP. Coded Multicast performs significantly better than Narada, consistently achieving at least doubled throughput for groups of almost all sizes; at times, even achieving more than twice Narada's throughput. This confirms our previous theoretical results that throughput in the multicast graph constructed by our algorithms can be twice as high as in a multicast tree.</p><p>In Fig. <ref type="figure" target="#fig_6">7</ref>, the average end-to-end delay is plotted as a function of the number of receivers. It is expected that the end-to-end delay in our multicast scheme would be higher than the end-to-end delay for Narada and DVMRP. Because in our scheme, we use alternate paths which are likely not as good as the shortest widest paths in the multicast tree, so they will certainly have higher delays. The delay for Coded Multicast is only slightly higher than the delay for Narada when both are compared to DVMRP. We observe that on average, the difference between Coded Multicast and Narada is only less than 1/4 of the difference between Narada and DVMRP. Especially for groups of size less than 50 and greater than 150, the increase in delay is very small. Narada and Coded Multicast have end-to-end delay on the same order with both being higher than DVMRP. The increase in delay is slight and not proportional to the increase in throughput.</p><p>In the top graph in Fig. <ref type="figure" target="#fig_7">8</ref>, the horizontal axis is the link stress and the vertical axis is the number of physical links for a given stress. The number of virtual overlay links for Coded Multicast is higher, so stress on physical links in proximity of the end-systems (overlay nodes) is bound to be higher. That is why there are more physical links with higher stress for Coded Multicast than for Narada. The difference in normalized link stress is not as pronounced, as can be seen from the bottom graph in Fig. <ref type="figure" target="#fig_7">8</ref> which plots normalized link stress as a function of the number of receivers. For groups of size less than 100, normalized link stress of Coded Multicast is actually roughly equal to that of Narada. Furthermore, as group size increases, Coded Multicast has the tendency of approaching Narada, which is grounds for optimism for Coded Multicast.</p><p>The normalized resource usage as a function of the number of receivers is plotted in Fig. <ref type="figure" target="#fig_8">9</ref>. We observe that for groups of size less than 150, the normalized resource usage of Coded Multicast and that of Narada are comparable. For groups of sizes 150 to 250, the normalized resource usage of Coded Multicast is roughly 1/3 higher than that of Narada. Both are high, in the order of a few thousands, as compared to DVMRP, which is in the order of a few hundreds.</p><p>Since the resource usage is defined to be a sum of products of delay and stress, it is a direct result of the data in Fig. <ref type="figure" target="#fig_6">7</ref> and Fig. <ref type="figure" target="#fig_7">8</ref> that resource usage will be higher for Coded Multicast. However, it can be seen from Fig. <ref type="figure" target="#fig_8">9</ref> that normalized resource usage for Coded Multicast has the same slope as that for Narada, only shifted up by a constant that is small in proportion to the absolute values of the resource usage. The trend is that as group size increases, the resource usage of Narada and Coded Multicast are in the same order, and the constant difference will approach negligible.</p><p>In summary, the multicast scheme we propose, Coded Multicast, achieves twice the end-to-end throughput of Narada. The penalty incurred by Coded Multicast in end-to-end delay is not proportional to the significant increase in throughput. In all three metrics of delay, stress and resource usage, Coded Multicast performs worse than Narada by a small percentage. We believe that the slight additional penalty of using Coded Multicast is not commensurate with the considerable gain in throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>This work was mainly inspired by previous work on network coding, first proposed by Ahlswede et al. <ref type="bibr" target="#b4">[5]</ref>, and then developed in <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b5">[6]</ref>, from information-theoretic and algebraic approach, respectively. It is shown that per-receiver max-flow throughput can be achieved (details summarized previously in Theorem 1) by applying network coding in a multicast (IP-layer) network. Although exciting insights are provided, the existing studies on network coding have remained largely theoretical, and we are not aware of any published work that studies the feasibility of applying the theoretical insights in network coding to increase throughput in actual multicast sessions over wide-area networks. In this paper, we give algorithms to achieve such a goal in application-layer overlay networks, supported by analytical and simulation results.</p><p>There exists an extensive body of research work in the area of multicast routing in wide-area IP networks <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>. Because it has been shown that IP-based multicast lacks flexibility and is difficult to deploy in general, algorithms promoting application-layer overlay multicast have recently been proposed as remedial solutions, <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>. They focus on the issue of constructing and maintaining a multicast tree, with only unicasts between end hosts, and of minimizing the inefficiency brought forth by link stress and stretch. Researchers have recently focused on designing overlay multicast tree construction algorithms that are scalable, using tools including Delaunay Triangulations <ref type="bibr" target="#b3">[4]</ref> and hierarchical clusters <ref type="bibr" target="#b2">[3]</ref>. It is also possible to design overlay multicast algorithms based on structured overlay networks (ones that impose data on specific nodes based on hash functions), examples include overlay multicast <ref type="bibr" target="#b18">[19]</ref> based on CAN <ref type="bibr" target="#b19">[20]</ref>, as well as Scribe <ref type="bibr" target="#b1">[2]</ref> based on Pastry <ref type="bibr" target="#b20">[21]</ref>. These approaches may incur performance penalty, and may not be adaptive to dynamic network metrics, which is shown to be critical in overlay multicast routing, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref>.</p><p>Inspired by two-step algorithms such as Narada <ref type="bibr" target="#b0">[1]</ref>, our algorithm begins with the construction of the rudimentary graph followed by the rudimentary tree. Our approach is also similar to most of the existing proposals in the sense that it is a distributed algorithm. However, our proposal distinguishes from all previous work in the following fundamental aspect: we construct a multicast graph, rather than a tree. Although the idea of multiple paths has been studied in the area of distributed Quality-of-Service routing ( <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b24">[25]</ref>), none of the previous work had sought to utilize the path diversity concurrently to increase end-to-end throughput. Among all previous work, perhaps the work on CoopNet <ref type="bibr" target="#b25">[26]</ref> and the position proposal on SplitStream <ref type="bibr" target="#b26">[27]</ref> are most similar to our work. Both papers have proposed to utilize multiple multicast trees to deliver striped data, using either multiple description coding or source erasure codes to split content to be multicast. CoopNet proposes a centralized algorithm which does not feature support of optimizing link stress and stretch.</p><p>SplitStream proposes a decentralized algorithm to construct a forest of multicast trees, with a focus on per-node load balancing. In both work, the inherent concerns of throughput limitations caused by conflicting paths have not been addressed. In comparison, our algorithm constructs an acyclic multicast graph from one multicast source, which, combined with coding, introduces a smaller degree of stress on overlay nodes compared with a forest. Further, our algorithm seeks a well-balanced trade-off between the constraints on link stress and the selection of good paths to achieve high throughput. Network coding, while essential to the performance of our algorithm, has not been incorporated in either CoopNet or SplitStream.</p><p>There has been research conducted on parallel downloads in peer-to-peer or overlay networks from mirror sites, i.e., multiple sources, in <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>. These papers investigate a different problem than that of overlay multicast that we study in this paper. Parallel downloads consider multiple servers containing replicated content (sometimes in encoded form), and clients obtain desired content by connecting to these servers. In our work, we only have one source holding the data. Instead of parallel unicasts from sources to clients, we construct a topology so that clients do not only receive by unicast from the source. Our approach does not assume that multiple sources are available, and provides more flexibility in efficiently distributing data to receivers by providing a multicast topology that includes multiple hops and store-andforward routing actions in the nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUDING REMARKS</head><p>In this paper, we have proposed a set of distributed algorithms to significantly improve end-to-end multicast session throughput. Such results are achieved by the application of network coding when exploiting path diversity with two disjoint paths to each multicast group receiver. To the best of our knowledge, there do not exist similar proposals in previous literature. With respect to the effectiveness and performance of our algorithm, we have undertaken both analytical and simulation-based studies, which agree with our original claims. We are currently in the process of implementing our algorithms as an application-layer protocol on the wide-area overlay network testbed PlanetLab <ref type="bibr" target="#b30">[31]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(a) Example with two receivers, t 1, t 2 . (b) Shortest path multicast tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The effects of network coding: an example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. A simple example of a multicast group, with rudimentary graph, rudimentary tree, and the resulting 2-redundant multicast graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Fig. 3. The core graph of rudimentary graph and the rudimentary tree for an example set of intermediate nodes, with ∆ = 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Two examples of adding a second data path, ps; darkened lines represent ps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Multicast session throughput at the receivers in (1) DVMRP; (2) Narada; (3) Coded Multicast.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. End-to-end delay averaged over all receivers in (1) DVMRP; (2) Narada; (3) Coded Multicast.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Top figure: Link stress in (1) DVMRP; (2) Narada; (3) Coded Multicast. Bottom figure: Normalized link stress in (1) DVMRP; (2) Narada; (3) Coded Multicast.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Normalized resource usage in (1) DVMRP; (2) Narada; (3) Coded Multicast.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>An intermediate node v is called a leaf intermediate if v does not have any downstream intermediate nodes in G 2r , i.e., none of v's children in G 2r is an intermediate node.</figDesc><table /><note><p>Definition 7 (leaf intermediate).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE I PROCEDURE</head><label>I</label><figDesc>FOR CONSTRUCTING p f FOR t Leaf receiver t: if not all t's intermediate node neighbors are saturated (u i 's) u = Find best path(t, {u i }) u f = u and p f = p ∪ (u, t) else if all neighbors of t are saturated Breadth-first search of tree, halt when k unsaturated nodes {u i } found u = Find best path(t, {u i }) u f = u and p f = p ∪ (u, t) Find best path(t, {u 1 , . . . , um}): request u i 's for weights {w(p i ) = (β i , λ i )} of their paths in tree for each (unsaturated) u i β = bandwidth of edge (u i , t) compute w(p i ∪ (u i , t)) = (min(β i , β), α + α i ) choose the best (shortest widest) path, p return u that corresponds to p TABLE II PROCEDURE FOR CONSTRUCTING ps FOR t Leaf receiver t: find k unsaturated intermediate nodes {u i }, which are not in p f , from its neighbors and/or random probing. send p f to each u i and request best path p i from s to u i that does not intersect with p f and its weight w(p i ) u = Find best path(t, {u i }, {p i }, {w(p i )}) Find best path(t, {u i }, {p i }, {w(p</figDesc><table /><note><p><p>i )}): for each u i β = bandwidth of edge (u i , t) compute w(p i ∪ (u i , t)) = (min(β i , β), α + α i ) choose the</p>best (shortest widest) path, p return u that corresponds to p Intermediate node u i : Upon receiving p f and request for paths from s to u i disjoint from p f if u i 's tree path P (s, u i ) does not intersect with p f then return p = P (s, u i ) and w(p) else if u i 's tree path intersects p f then if u i has an alternative path p from s then return p and w(p) else if u i has indegree 1 then contact a different child c of s than the one whose subtree u i is in. c conducts breadth-first search of its subtree and returns to u i first unsaturated or leaf intermediate node v. return p = P (s, v) ∪ (v, u) and w(p)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>(a). Nodes u 1 , u 2 , u 3 are saturated. Fig. 4. Examples of 2-redundant multicast graphs. Ellipsis indicates part of graph there is not shown.</figDesc><table><row><cell></cell><cell>s</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>s</cell><cell>s</cell></row><row><cell>u 1</cell><cell></cell><cell>u 2</cell><cell></cell><cell>u 3</cell><cell>u 1</cell><cell>u 4</cell><cell>u 1</cell></row><row><cell>...</cell><cell>...</cell><cell>...</cell><cell>u 7</cell><cell></cell><cell>u 4</cell><cell>u 8</cell><cell>t</cell></row><row><cell></cell><cell>t 1</cell><cell>t 2</cell><cell></cell><cell>t 3</cell><cell>t</cell><cell></cell></row><row><cell cols="5">(a) Existing 2-redundant multicast graph</cell><cell cols="3">(b) u 4 ,u 8 are unsaturated neighbours of t; t will choose the best path from</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">these two paths</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>s</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>u 1</cell><cell></cell><cell></cell><cell>u 2</cell><cell>u 3</cell></row><row><cell></cell><cell>u f = u 4</cell><cell>...</cell><cell></cell><cell>...</cell><cell>u 7</cell><cell></cell></row><row><cell></cell><cell>u 8</cell><cell></cell><cell>t</cell><cell>t 1</cell><cell>t 2</cell><cell>t 3</cell></row><row><cell></cell><cell cols="6">(c) Adding the first data path p f = (s,u 1 ,u 4 ,t)</cell></row><row><cell></cell><cell cols="6">for new leaf receiver t; u f = u 4 , dark edges are p f .</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>).</figDesc><table><row><cell></cell><cell>s</cell><cell></cell><cell></cell><cell></cell><cell>s</cell><cell></cell><cell></cell></row><row><cell>u 1</cell><cell></cell><cell>u 2</cell><cell>u 3</cell><cell>u 1</cell><cell></cell><cell>u 2</cell><cell>u 3</cell></row><row><cell>u 4</cell><cell>...</cell><cell>...</cell><cell>u 7</cell><cell>u 4</cell><cell>u 5</cell><cell>u 6</cell><cell>u 7</cell></row><row><cell>...</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>...</cell><cell>...</cell><cell></cell></row><row><cell></cell><cell>t</cell><cell></cell><cell></cell><cell>u 8</cell><cell>t</cell><cell></cell><cell></cell></row><row><cell cols="4">(a) Second data path p s = (s,u 3 ,u 7 ,t) if t chooses u s = u 7 ; dark edges form p s.</cell><cell cols="4">(b) Second data path p s = (s,u 2 ,u 6 ,u 8 ,t) if t chooses u s = u 8 ; dark edges form p s.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE III</head><label>III</label><figDesc>Vector sequence generation ALGORITHM Algorithm gen(m</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE V DisseminateCodes</head><label>V</label><figDesc>PHASE  The source s (has j children and has gen(m + j) from last phase):</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Formally, stretch is defined as the ratio of path length from the source to the multicast group member along the overlay to the length of the direct unicast path<ref type="bibr" target="#b2">[3]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The cost of a link embodies critical metrics of concern, such as bandwidth, latency and loss rate.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Henceforth, the terms multicast group members and receivers will be used interchangeably.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Case for End System Multicast</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="page" from="1456" to="1471" />
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Scribe: A Large-Scale and Decentralized Application-Level Multicast Infrastructure</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-M</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="page" from="1489" to="1499" />
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalable Application Layer Multicast</title>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bhattacharjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kommareddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCOMM</title>
		<meeting>of ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2002-08">August 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Application-Layer Multicasting With Delaunay Triangulation Overlays</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liebeherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nahas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Si</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="page" from="1472" to="1488" />
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Network Information Flow</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ahlswede</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-Y</forename><forename type="middle">R</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Yeung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="1204" to="1216" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Beyond Routing: An Algebraic Approach to Network Coding</title>
		<author>
			<persName><forename type="first">R</forename><surname>Koetter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Medard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
		<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linear Network Coding</title>
		<author>
			<persName><forename type="first">S.-Y</forename><forename type="middle">R</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Yeung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Theory</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Quality of Service Routing for Supporting Multimedia Applications</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1228" to="1234" />
			<date type="published" when="1996-09">September 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multicast Routing in Internetworks and Extended LANs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1988-08">August 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">INET: an Autonomous System (AS) level Internet Topology Generator</title>
		<author>
			<persName><forename type="first">J</forename><surname>Winick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jamin</surname></persName>
		</author>
		<ptr target="http://topology.eecs.umich.edu/inet/" />
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
	<note>version 3.0,&quot; available online</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On Power-Law Relationships of the Internet Topology</title>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Core Based Trees</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ballardie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1993-08">August 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Architecture for Wide-Area Multicast Routing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Farinacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1994-08">August 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The MASC/BGMP Architecture for Interdomain Multicast Routing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Radoslavov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Alaettinoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Scattercast: An Architecture for Internet Broadcast Distribution as an Infrastructure Service</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chawathe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Berkeley, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. California</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Overcast: Reliable Multicasting with an Overlay Network</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>O'toole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Symposium Operating System Design and Implementation (OSDI)</title>
		<meeting>4th Symposium Operating System Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Yoid: Your Own Internet Distribution</title>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<ptr target="http://www.aciri.org/yoid/" />
		<imprint>
			<date type="published" when="2000-04">April 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">ALMI: An Application Level Multicast Infrastructure</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pendarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waldvogel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 3rd USNIX Symposium on Internet Technologies and Systems (USITS &apos;01)</title>
		<meeting>of the 3rd USNIX Symposium on Internet Technologies and Systems (USITS &apos;01)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-03">March 2001</date>
			<biblScope unit="page" from="49" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Applicationlevel Multicast Using Content-addressable Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Workshop on Networked Group Communication (NGC &apos;01)</title>
		<meeting>3rd Int. Workshop on Networked Group Communication (NGC &apos;01)<address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Scalable Content-Addressable Network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP/ACM Middleware</title>
		<meeting>IFIP/ACM Middleware</meeting>
		<imprint>
			<date type="published" when="2001-11">2001. November 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multicast Routing and Bandwidth Dimensioning in Overlay Networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="page" from="1444" to="1455" />
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">QoSMIC: Quality of Service sensitive Multicast Internet protoCol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pankaj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Quality of Service Multipath Multicast Protocol</title>
		<author>
			<persName><forename type="first">P</forename><surname>Baccichet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Rossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Workshop on Networked Group Communication</title>
		<meeting>the Fourth International Workshop on Networked Group Communication<address><addrLine>Boston, Massachussetts</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An Overview of Quality-of-Service Routing for the Next Generation High-Speed Networks: Problems and Solutions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nahrstedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network, Special Issue on Transmission and Distribution of Digital Video</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="64" to="79" />
			<date type="published" when="1998-12">November/December 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Distributing Streaming Media Content Using Cooperative Networking</title>
		<author>
			<persName><forename type="first">V</forename><surname>Padmanabhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sripanidkulchai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th International Workshop on Network and Operating Systems Support for Digital Audio and Video</title>
		<meeting>of the 12th International Workshop on Network and Operating Systems Support for Digital Audio and Video<address><addrLine>Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">SplitStream: High-Bandwidth Content Distribution in a Cooperative Environment</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-M</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Second International Workshop on Peer-to-Peer Systems (IPTPS 2003)</title>
		<meeting>of the Second International Workshop on Peer-to-Peer Systems (IPTPS 2003)<address><addrLine>Berkeley, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-02">February 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Accessing Multiple Mirror Sites in Parallel: Using Tornado Codes to Speed Up Downloads</title>
		<author>
			<persName><forename type="first">J</forename><surname>Byers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
		<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Dynamic Parallel-Access to Replicated Content in the Internet</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Biersack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="455" to="465" />
			<date type="published" when="2002-08">August 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Rateless Codes and Big Downloads</title>
		<author>
			<persName><forename type="first">P</forename><surname>Maymounkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazieres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd International Workshop on Peer-to-Peer Systems</title>
		<meeting>of the 2nd International Workshop on Peer-to-Peer Systems</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A Blueprint for Introducing Disruptive Technology into the Internet</title>
		<author>
			<persName><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Workshop on Hot Topics in Networks (HotNets-I)</title>
		<meeting>of the First Workshop on Hot Topics in Networks (HotNets-I)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
