<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Recent directions in netlist partitioning: a survey*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Charles</forename><forename type="middle">J</forename><surname>Alpert</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">UCLA</orgName>
								<address>
									<postCode>90024-1596</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">UCLA</orgName>
								<address>
									<postCode>90024-1596</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Recent directions in netlist partitioning: a survey*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">319248F6AA07AAD9C233B091863A097F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This survey describes research directions in netlist partitioning during the past two decades in terms of both problem formulations and solution approaches. We discuss the traditional min-cut and ratio cut bipartitioning formulations along with multi-way extensions and newer problem formulations, e.g., constraint-driven partitioning (for FPGAs) and partitioning with module replication. Our discussion of solution approaches is divided into four major categories: move-based approaches, geometric representations, combinatorial formulations, and clustering approaches. Move-based algorithms iteratively explore the space of feasible solutions according to a neighborhood operator; such methods include greed, iterative exchange, simulated annealing, and evolutionary algorithms. Algorithms based on geometric representations embed the circuit netlist in some type of "geometry", e.g., a 1-dimensional linear ordering or a multidimensional vector space; the embeddings are commonly constructed using spectral methods. Combinatorial methods transform the partitioning problem into another type of optimization, e.g., based on network flows or mathematical programming. Finally, clustering algorithms merge the netlist modules into many small clusters; we discuss methods which combine clustering with existing algorithms (e.g., two-phase partitioning). The paper concludes with a discussion of benchmarking in the VLSI CAD partitioning literature and some perspectives on more promising directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contents</head><p>1 Introduction 2 2 Partitioning formulations 5 2.1 Preliminaries 5 2.2 Circuit representations 7 2.3 Bipartitioning formulations 9 2.4 Multi-way partitioning formulations 10 2.5 Constraint-driven (satisficing) formulations ! 3 2.6 Replication formulations 14 3 Move-based approaches 3.1 Iterative improvement 3.1.1 The Kernighan-Lin (KL) algorithm 3.1.2 The Feduccia-Mattheyses (FM) algorithm 3.1.3 Tie-breaking strategies 3.1.4 Sanchis' multi-way partitioning algorithm *Partial support for this work was provided by NSF Young Investigator * Corresponding author.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The essence of netlist partitioning is to divide a system specification into clusters such that the number of intercluster connections is minimized. The partitioning task is ubiquitous to many subfields of VLSI CAD: any top-down hierarchical (i.e., "divide and conquer") approach to system design must rely on some underlying partitioning technique. There are several reasons why partitioning has recently emerged as a critical optimization in many phases of VLSI system synthesis, and why the past several years have seen so much research activity on the subject. Above all, partitioning heuristics are used to address the increasing complexity of VLSI design. Systems with several million transistors are now common, presenting instance complexities that are unmanageable for existing logic-level and physical-level design tools. Partitioning divides a system into smaller, more manageable components; the number of signals which pass between the components corresponds to the interactions between the design subproblems. In a top-down hierarchical design methodology, decisions made early in the system synthesis process (e.g., at the system and chip levels) will constrain succeeding decisions. Thus, the feasibility -not to mention the quality -of automatic placement, global routing and detailed routing depends on the quality of the partitioning solution. A bottom-up clustering may also be applied to decrease the size of the design, typically in cell-or gate-level layout. The current emphasis on a quick-turnaround ASIC design cycle reinforces the need for reliable and effective algorithms.</p><p>Partitioning heuristics also have a greater impact on system performance as designs become interconnect-dominated. In current submicron designs, wire delays tend to dominate gate delays <ref type="bibr">[15]</ref>; the differences between on-chip and off-chip signal delays and the increasingly pin-limited nature of large chips make it desirable to minimize the number of signals traveling off a given chip. Larger die sizes imply that long on-chip global routes between function blocks will more noticeably affect system performance. Other considerations (e.g., design for testability, low-power design, etc.) also require partitioning algorithms to identify interconnect structure, albeit at more of a functional or communication-based level.</p><p>Finally, partitioning heuristics affect the layout area: wires between clusters at high levels of the hierarchy will tend to be longer than wires between clusters at lower levels, and total wirelength is directly proportional to layout area due to minimum wire spacing design rules. The traditional minimum-cut objective is natural for this application: if the layout area is divided into a dense uniform grid, total wirelength can be expressed in "grid" units or equivalently as the sum over all gridlines of the number of wires crossing each gridline. This view can also improve auto-routability since it suggests reducing the wire congestion in any given layout region.</p><p>All of these considerations motivate the development of netlist partitioning tools that identify interconnection and communication structure in a given system design. Indeed, one of the five-year predictions issued by participants at the 1991 CANDE workshop <ref type="bibr">[142]</ref> was that stand-alone partitioning for every phase of system synthesis would comprise the next major class of CAD tools to emerge in the marketplace. That this prediction has come to pass is evident from the various new tools and startup companies which focus almost exclusively on partitioning. <ref type="bibr" target="#b0">1</ref> Today, leading applications of partitioning include the following:</p><p>• General design packaging. Logic must often be partitioned into clusters, subject to constraints on cluster area as well as possible 1/O bounds. This problem is known as design packaging and is still the canonical partitioning application; it arises not only in chip floorplanning and placement, but also at all other levels of the system design. <ref type="bibr" target="#b1">2</ref> The design packaging problem also arises whenever technology improves and existing designs must be repackaged onto higher-capacity modules ("technology migration"). Note that the problem is usually associated with large cluster sizes, with few constraints on the internal structure of the clusters. When a finite library of available module types is specified, the optimization is more along the lines of "covering" or "technology mapping". • Netlist-level partitioning in HDL-based synthesis. Synthesis tools have emerged which reduce the design cycle by automatically mapping a high-level functional description to a gate-or cell-level netlist. However, even with increased maturity of such high-level synthesis tools, netlist partitioning remains central to the success of the design procedure. This is essentially because writing HDL code -as opposed to performing layout -can abstract away the physical layout effects of design choices (for example, a few lines of HDL code that specify a register file or</p><p>1Two notable examples are: High Level Design Systems, whose "advanced design planner" performs design planning at the floorplan level, and ACEO, whose "SoftWire" tool performs communication-based partitioning of multiple-FPGA systems. Partitioning is also at the heart of new tools for system-level design optimization and mapping of designs onto emulation or prototyping architectures composed of multiple field-programmable gate arrays (FPGAs). 2Despite the existence of partitioning applications throughout the system design cycle, calls for papers of major CAD conferences still implicitly classify partitioning within placement and/or floorplanning. Interestingly, research activity in "pure partitioning" arguably exceeds that in either of these mainstay categories.</p><p>crossbar connection can correspond to a large portion of the final layout area). As a result, the block decomposition of the functional (software) description does not necessarily map well into a decomposition of the physical layout. Hence, in contrast to previous building-block methodologies which yielded a small number of function blocks that could be optimally handpartitioned, HDL-based synthesis virtually requires the physical design methodology to shift from working with a small number of building blocks to working with large, flattened design representations . Partitioning of flattened inputs is also necessary for such applications as the design of "precursor systems" (i.e., finding the packaging tradeoffs that correspond to optimum cost-performance points at early stages in the product life cycle). • Estimation for design optimization. Accurate estimation of layout area and wireability has always been a critical element of high-level synthesis and floorplanning. Now, such estimates are becoming critical to higher-level searches over the system design space. Predictive models often combine analysis of the netlist partitioning structure with analysis of the output characteristics of placement and routing algorithms, in order to yield estimates of wiring requirements and system performance. This use of system partitioning hierarchies is increasingly prominent as "design optimization" and "electronic system design automation" capture the attention of CAD users and vendors.</p><p>• System emulation and rapid prototyping <ref type="bibr">(FPGA partitioning)</ref>. Many logic emulation systems and rapid system prototyping methodologies (e.g., those from Quickturn or Zycad/Inca) use partitioning tools to map complex circuit designs onto hundreds or even thousands of interconnected FPGAs. Typically, such partitioning instances are challenging because the timing, area, and I/O resource utilizations must satisfy hard device-specific constraints. Furthermore, the partitioning optimization is affected by the discrete nature of system resources -e.g., interconnect delay in routing segments, layout area in configurable logic blocks (CLBs), or individual FPGA chips in a multiple-FPGA system -all of which have large "quanta". • Hardware simulation and test. A good partitioning will minimize the number of inter-block signals that must be multiplexed onto the bus architecture of a hardware simulator or mapped to the global interconnect architecture of a hardware emulator. Reducing the number of inputs to a block often reduces the number of test vectors needed to exercise the logic.</p><p>In this work, we survey the major research directions in netlist partitioning and establish a taxonomy of existing works based on the underlying solution methodology. While we have tried to make this survey both complete and self-contained, we emphasize more recent problem formulations and solution approaches, possibly at the expense of methods that have been treated in previous surveys. 3 Section 2 develops notation, discusses various graph and hypergraph representations of the circuit netlist, and formulates basic variants of the partitioning problem. These problem formulations include bipartitioning, multi-way partitioning, constraint-driven partitioning, and partitioning with replication. Sections 3-6 survey four major categories of partitioning approaches: 3Limited surveys are given in the textbooks <ref type="bibr">[149]</ref> and <ref type="bibr">[-171-]</ref>; the former contains a more personal perspective by W. Donath on early works. The book by <ref type="bibr">Lengauer [133]</ref> is noteworthy, especially for its complete development of certain combinatorial algorithms (network flow, multicommodity flow, etc.).</p><p>• Section 3 discusses move-based approaches: we classify an algorithm in this category if it explores the solution space by moving from one solution to another. Greedy and iterative exchange approaches are most common -these always try to make the best move, but can easily be trapped in local minima. To avoid this behavior, many other strategies have been proposed including stochastic hill-climbing (simulated annealing), evolutionary algorithms, and the multistart strategy. We discuss these approaches along with many adaptations that have used these methods to address more complex formulations. • Section 4 discusses methods that construct a 9eometric representation of the partitioning problem via such constructions as a l-dimensional linear ordering or a multi-dimensional vector space. Such a representation offers possibilities for geometric approaches to solve problems that are intractable for general graphs. Spectral methods are commonly used to construct geometric representations, due to their ability to capture global netlist information. • Section 5 discusses combinatorial approaches: we loosely classify an approach under this category if the partitioning problem can be transformed into some other "classic" type of optimization, e.g., maximum flow, mathematical programming, graph labeling, or set covering. These approaches are promising since complex formulations that include timing, module preassignment, replication, and other hard constraints can often be expressed in terms of a mathematical program or flow network.</p><p>In addition, changing user requirements for solution quality and runtime, as well as improved computing platforms, have made such approaches more practical. • Section 6 treats clustering-based approaches, which traditionally consist of bottom-up approaches that merge netlist modules into small clusters. We augment this class to include methods which use clustering within another algorithm, such as for two-phase partitioning or placement. Clusteringbased approaches have received much recent attention since they are viewed as the most promising method for handling the increasing problem sizes in VLSI CAD.</p><p>Section 7 concludes with a discussion of benchmarking practice, as well as a brief list of perspectives on future research in the field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Partitioning formulations</head><p>In this section, we describe the major variant formulations of the partitioning problem. We defer the description of several less well-studied variants -e.g., retiming formulations -to the discussions of their respective underlying solution strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Preliminaries</head><p>Given a set of n netlist modules V = {U1, /')2, "'" , l)n}, the purpose of partitioning is to assign the modules to a specified number of clusters k satisfying prescribed properties. 4 *Many works distinguish between the partitioning problem where k is small (e.g., k ~&lt; 15) and the clustering problem where k is large (e.g., k = O(n)). Such works may refer to what we call as cluster as a "partition"; we choose not to make this distinction, since our multi-way partitioning formulations are independent of the relative size of k. For reasons of clarity, we will generally refer to pk as a "partitioning" for small k and as a "clustering" for large k.</p><p>Definition. A k-way partitioning pk= {C1, C2, ... ,Ck} consists of k clusters (subsets of V), C1, C2, ..., Ck, such that CI u C2 u ... UCk = V. If k = 2, we refer to p2 as a bipartitioning.</p><p>The objective to be optimized is denoted by F(pk), i.e., the objective is a function of the partitioning solution. We generally make the traditional assumption that the clusters are mutually disjoint; note however that replication formulations permit a module to be a member of more than one cluster.</p><p>The most common method for representing the circuit netlist connections is as a hypergraph H(V, E) with E = {el, e2, ... ,era} being the set of signal nets (see, e.g., <ref type="bibr" target="#b22">[23]</ref> for basic concepts of graphs and hypergraphs). Each net is a subset of V containing the modules which the net connects, and we assume that for each e e E, lel &gt;~ 2. The equivalence between netlists and hypergraphs is exact if each net has at most one pin on any module. The modules in e may also be called the pins of e. We also assume a weighting function w: V ~ ~, generally used for the area of each module. The weighting function can be extended to clusters, i.e., w(C) = Y~c w(v). Another weighting function w': E ~ ~ can be defined for nets (e.g., to give higher weights for critical nets or input-output paths), but for ease of presentation we omit net-weighting from our discussion, s Definition. For each module v, the set of nets incident to v is denoted by N(v) = {e e E I v ~ e} and the set of modules that are neighbors of v is denoted by M(v) --{w ~ V 13 e ~ N(v), w ~ e, v -¢ w}. We say that deg(v)= IN(v) I is the degree of v, and degmin--minv~vdeg <ref type="bibr">(v)</ref> and degmax = max v~v deg <ref type="bibr">(v)</ref> are the respective minimum and maximum degrees of the hypergraph.</p><p>Definition. Each signal net e consists of a single source module S(e) and a set of destination modules D(e) (so {S(e)} w D(e) = e), which indicates the direction of signal flow.</p><p>Many algorithms either ignore source and destination information or assume it is not available.</p><p>Definition. The set of hyperedges cut by a cluster C is given by E(C) = {e ~ E s.t. 0 &lt; lenCI &lt; lel}, i.e., e ~ E(C) if at least one, but not all, of the pins of e are in C. The set of nets cut by a partitioning solution pk can be expressed as E(P k) = ok= 1E <ref type="bibr">(CI)</ref> or equivalently E(P k) = {e ~ E 13u, v e e, with u ~ Ch, v ~ C~ and h 4: l}. We say that IE(P~)I is the cutsize of pk.</p><p>Sometimes, it may be easier to represent a partitioning solution in terms of vectors and matrices, hence our final definition: Definition. Given pk, the indicator vector for cluster Ch is the n-dimensional vector Xh = (Xih) with Xih = 1 if V~e Ch and Xih = 0 if vi¢Ch. The n× k matrix X with column h equal to Xh is the assignment matrix for pk.</p><p>SUseful information regarding the subcircuit function and the design hierarchy may be inferred from the module uniquenesses (module IDs), depending on how other development tools represent and output intermediate design representations. Current works in partitioning do not assume the availability of such information, but this may change in light of new applications such as functional clustering.</p><p>When k = 2, we have X~ = 1 -?(2, so only one indicator vector is needed. For this case, we let x = X2 represent the bipartitioning solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Circuit representations</head><p>The choice of netlist representation is typically a consequence of the objective or the algorithmic approach, e.g., minimizing cut nets implicitly requires a hypergraph representation, and a maximum-flow solution for replication cut will require a directed network (graph) representation. Aside from the hypergraph model discussed above, standard netlist representations include the following:</p><p>• Weighted undirected graph. A graph G = (V, E) is a special case of a hypergraph with all ]eil --2.</p><p>When certain standard matrix computations or algorithm implementations are used (e.g., spectral computations or mathematical programming), an undirected graph representation is often convenient. The netlist is represented by a symmetric n x n adjacency matrix A = (air) in which the matrix entry aij ~&gt; 0 captures the connectivity between modules vi and vj (so au -0 is typically assumed). Generally, for the adjacency matrix is useful only when it is sparse, i.e., aij &gt; 0 for a very small percentage of the matrix entries. • To construct a graph from a netlist, the clique net model is often used: a signal net e contains ]e] pins and will induce an edge between every pair of its pins; each edge has a weight that is a function of [el (multiple edges with total weight W connecting a pair of modules are contracted into a single edge with weight W). The "standard" clique net model <ref type="bibr">[-133</ref>] assigns uniform weight 1/([e{ -1) to each clique edge, although many other weighting functions have been proposed. 6 It has been noted</p><p>6Ideally, no matter how modules of the clique are partitioned, the cost should be one, corresponding to a single cut of a net. <ref type="bibr">Ihler et al. 1,</ref><ref type="bibr">106]</ref> prove that such a "perfect" clique net model is impossible to achieve. In addition, <ref type="bibr">Lengauer 1,</ref><ref type="bibr">133]</ref> shows that no matter what weighting function is used, there exists a bipartitioning with deviation t2(x~) from the desired cost of cutting a single net e. The standard clique model ensures that for every signal net cut in a partitioning solution, the total weight of cut edges for that net will be at least one. However, since a cut net can contribute up to lelZ/(4(]e[-1)) to the partitioning objective, large nets are less likely to be cut than smaller nets. A weight of 4/(I el(l el -1)) was proposed by D.J.-H. H uang and adopted by 13] so that the expected weight of a cut signal net would be one.  propose a weighting scheme that is a function of both [el and k which guarantees that the cost of splitting e into k clusters will be bounded above by one. For the maximum cost of a net cut in the transformed graph to be one, Donath shows that the appropriate edge weighting is 4/(lel 2 -(lel rood 2)) since there are (lel 2 -(lel mod 2))/4 edges crossing between two clusters when half the modules ofe are in each cluster (also see <ref type="bibr" target="#b0">1,</ref><ref type="bibr">184]</ref>). Donath further shows that when there are more than two clusters, 4/(lel 2 -(lelmod 2)) remains the correct uniform weighting to achieve this upper bound. Many other net models are motivated by 1-and 2-dimensional cell placement. For example, the standard 1/(lel -1) weight is inspired by linear placement into fixed slots separated by distance one <ref type="bibr" target="#b39">[40]</ref>: since the minimum wirelength of an [el-pin net must be at least le] -1, the weighting should be inversely proportional to le[ -1 so that the objective does not "try too hard" to place the modules into an impossibly small span of slots (also see ). If the span of a net is exactly Fer -1, then D.J.-H. Huang showed that a weighting function of6/(leJ(lel + 1)) gives the total wirelength Jef -1 for the clique representation. In a 2-dimensional layout, <ref type="bibr">[91]</ref> assumes that the net will be a spanning tree with lel -1 edges; hence, if the weight for these edges is evenly distributed among the clique edges, the weight function should be (Jef-1)/(4~ 4) ---2/lel.  that the clique net model may enable a "finer-grain optimization" than the hypergraph model, e.g., <ref type="bibr">Shih [172]</ref> reports that solution quality of Fiduccia-Mattheyses bipartitioning <ref type="bibr" target="#b65">[65]</ref> can improve when run on the graph representation of the netlist instead of the original hypergraph.</p><p>However, the clique model can destroy the natural sparsity of the netlist since (L~I) nonzeros will be inserted in A for every net e. For example, a 1000-pin clock net will induce 499 500 nonzero entries in A. Thus, some existing methods discard large nets to maintain sparsity <ref type="bibr" target="#b36">[37,</ref><ref type="bibr">79]</ref>. An undirected graph can also be induced from a netlist by constructing random spanning trees, paths, or cycles over the pins in every signal net. Alternatively, dummy modules may be inserted [106], e.g., the "star" model adds a dummy node for each net and connects every pin of the net to this dummy node (cf. the discussion of [99] in Section 5.2). H(V', E'), which has the same vertex set V' = {el, e2, ... ,era} as the intersection graph. However, the connections are slightly different in that modules are mapped to hyperedges: For each v e V, the hyperedge N(v) is added to E' (note fE'J = n). Observe that the intersection graph can be derived by applying the clique net model to the dual hypergraph. <ref type="bibr">Yeh et al. [194]</ref> used this representation for their Primal-Dual FM-based algorithm (see Section 3.5), and <ref type="bibr" target="#b49">[49]</ref> used a combination of the intersection and dual representations. • Directed graph: Signal flow direction can be easily integrated into a graph representation, e.g., by creating directed edges (S(e), w) for every e ~ E and every w ~ D(e). This specific construction is called the directed tree representation. A directed graph is particularly useful for flow, unidirectional cut, timing, and replication formulations. Sometimes this construction yields a directed acyclic graph (DAG), e.g., for combinational logic networks <ref type="bibr" target="#b50">[50,</ref><ref type="bibr">107]</ref>. In such a case, the set of primary inputs is denoted by PI = {v ~ V r v e ~ N(v), S(e) = v} and the set of primary outputs is denoted by</p><formula xml:id="formula_0">PO = {v ~ V J ~/e ~ N(v), v ~ D(e)}.</formula><p>These five models are illustrated in Fig. <ref type="figure" target="#fig_1">1</ref>. In the remainder of the discussion, we will assume that the circuit is represented as a hypergraph. Of course, any method for hypergraph partitioning can also be applied to the graph representation, as well as to the intersection and dual representations, if a scheme is provided to transform the resulting net partitioning into a module partitioning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Bipartitioning formulations</head><p>The min-cut bipartitioning problem seeks to divide V into two clusters such that the number of hyperedges cut by the clusters is minimized:</p><formula xml:id="formula_1">Min-Cut Bipartitioning: Minimize F(P 2) = IE(C1)I = IE(C2)f such that C 1 ~z 0, C2 ~ 0.</formula><p>Min-Cut Bipartitioning can be solved by converting the hypergraph to a flow network, computing a certain set of n-1 flows and applying the max-flow min-cut theorem <ref type="bibr" target="#b66">[66]</ref> to obtain a minimum cut. Many algorithms are known which can solve the max-flow problem in polynomial time; see [76, 2-1 for surveys. Note, however, that finding a minimum cut does not necessarily require a maximum flow; fast techniques to find minimum cuts <ref type="bibr">[92,</ref><ref type="bibr">114,</ref><ref type="bibr">141]</ref> are noted in Section 5 below.</p><p>Optimal solutions to ,Min-Cut Bipartitioning will often be quite unbalanced and thus not be useful within a hierarchical design methodology; however, such solutions may form the basis of a useful heuristic <ref type="bibr">[190,</ref><ref type="bibr">191]</ref>. A more practical formulation seeks min-cut bipartitionings with bounds on module cardinality or total module area within each cluster. The Min-Cut Bisection problem seeks two equal-weight clusters:</p><p>Min-Cut Bisection: Minimize F(P 2) = IE(C~)I such that Iw(C~) -w(C2)l ~&lt; ~.</p><p>If all modules have unit weight, then e = 1. When move-based heuristics are applied, it is usually convenient to allow the cluster weight imbalance e to vary up to the largest module weight (otherwise the number of possible moves may become too limited). Min-Cut Bisection is NPcomplete <ref type="bibr" target="#b70">[70]</ref>, as are all of the other size-constrained formulations that we discuss since Min-Cut Bisection can be reduced to them.</p><p>This formulation may be unnecessarily restrictive: and relaxing the size constraints may permit a much better solution while still maintaining relatively balanced clusters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Size-Constrained Min-Cnt Bipartitioning:</head><p>Given prescribed lower and upper cluster size lower and upper bounds L and U, minimize F(P 2) ---IE(C01 such that L &lt;&lt;. W(Ch) &lt;&lt;, U for h = 1, 2.</p><p>This formulation has become popular in the recent literature, both for its greater practical relevance and as an added basis for algorithm comparisons, e.g., <ref type="bibr">[156,</ref><ref type="bibr">190]</ref> present results using unit module areas and L = 9n/20, U = lln <ref type="bibr">/20, and [188, 86]</ref> present results using actual module areas and L = ¼ ET= 1 w(vi), U = 3 ZT= 1 w(ui) (see Section 7).</p><p>Rather than minimizing cutsize subject to cluster size constraints, the cutsize and balance criteria can be smoothly integrated into the partitioning objective. The concept of ratio cut partitioning was introduced in <ref type="bibr" target="#b31">[132]</ref> and first applied to circuit partitioning by <ref type="bibr">Wei and Cheng [187]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Minimum Ratio Cut Bipartitioning: Minimize F(P 2) = IE(C1)I/(w(C1)'w(C2)).</head><p>The numerator favors a low cutsize while the denominator favors more balanced cluster sizes. Fig. <ref type="figure" target="#fig_2">2</ref> contrasts the optimal solutions for the Min-Cut Bipartitioning, Min-Cut Bisection and Minimum Ratio Cut Bipartitioning objectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Multi-way partitioning formulations</head><p>A multi-way partitioning is a k-way partitioning with k &gt; 2. A standard formulation is:</p><p>Min-Cut k-Way Partitioning: Given lower and upper cluster size bounds L and U, minimize</p><formula xml:id="formula_2">F(Pk) = Y~= 1 E(Ch) such that L &lt;~ w(Ci) &lt;~ U for all h = 1, ... , k.</formula><p>Exact cluster size balance is achieved by setting L = (l/k)Y~i w(vl) -e and U = (l/k)•i w(vi) + ~, where e &gt; 0 may again be required for move-based algorithms to maintain feasible solutions. A similar constrained formulation used by, e.g., <ref type="bibr">[18]</ref>, requires that W(Ch) = mh for user-prescribed cluster sizes ml &gt;&gt;-m2 &gt;&gt;, ... &gt;&gt;-mk. Notice that the Min-Cut k-Way Partitioning objective sums the nets cut by each cluster: a net that is cut by h clusters is counted h times in the sum. As noted by <ref type="bibr">[159,</ref><ref type="bibr">179]</ref>, this objective is preferable to simply counting the number of nets cut (i.e., F(P k) = IE(pk)l) since signal nets that span more clusters can consume more I/O and timing ?,,. resources. Note that the two objectives are identical for undirected graphs (which have J el = 2 for all e ~ E).</p><p>As with bipartitioning, it is possible to integrate cutsize and cluster size balance within a single objective. To this end,  and <ref type="bibr">Yeh et al. [193]</ref>, respectively, proposed the Minimum Scaled Cost and Minimum Cluster Ratio objectives.</p><formula xml:id="formula_3">1 k IE(Ch)l Minimum Sealed Cost: Minimize F(pk) = n(k -1~) h~' lT" W(fh) le(ek)l Minimum Cluster Ratio: Minimize F(Pk) = y k-1 •k=i+ 1 W(Ch) w(Ct)"</formula><p>Both of these objectives are k-way generalizations of the ratio cut objective, and are exactly equivalent to Minimum Ratio Cut Bipartitioning when k = 2. Scaled Cost seems more useful because it penalizes nets that are divided among more than two clusters; Cluster Ratio is also more difficult to evaluate, and the O(k 2) terms in the denominator do not give immediate intuition regarding the cutsize-balance tradeoff.</p><p>Other k-way partitioning objectives have been proposed in the context of circuit clustering, i.e., when k is large with respect to I VI (see Section 6). The DS objective [48-1 is:</p><formula xml:id="formula_4">DS: Maximize 1 k degree(Ch) F(pk) = n h~= l separation(Ch)'</formula><p>where <ref type="bibr">de#ree(Ch)</ref> is the average number of nets incident to each module of the cluster that have at least two pins in the cluster, and separation(Ch) is the average length of a shortest path between two modules in Ch (= ~ if the cluster is disconnected). Since DS requires O(n 3) time to evaluate, it is more useful for the comparison of rather than optimization of clustering solutions. </p><formula xml:id="formula_5">Density: Maximize k F(pk )= ~l{e~E ] e~_Ch}l,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>r,, h: 1 W~hj</head><p>Density differs from Absorption in that only nets completely absorbed in the cluster are counted. Without this denominator, the objective is equivalent to minimizing the total number of cut nets (cf. the "Clustering" problem in <ref type="bibr">[133]</ref>), since it can be rewritten as IEI-IE(pk)I.</p><p>A very important clustering-related formulation captures the problem of timing-driven k-way partitioning (see Section 5.1 below). A DAG representation is assumed, and the goal is to minimize the longest delay over all paths from primary inputs to primary outputs of the circuit, subject to satisfying the size constraint w(C) ~&lt; U. Each module v E V has delay 6(v), and an edge <ref type="bibr">(v~, vj)</ref> between two modules has delay one if v~ and vj are in different clusters, and delay zero if vi and vj are in the same cluster. In other words, the cost (delay) of a path p from v~ to vj can be written as cost(p) = ~vep~(V) d-K(p), where K(p) is the number of intercluster edges in p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Min-Delay Clustering:</head><p>Given a DAG G(V, E), module delays 6(vi) and cluster size bound U, minimize F(P k) = maXallpaths p cost(p) such that W(Ch) &lt;&lt;. U for all h = 1, ..., k.</p><p>As noted in <ref type="bibr">[151]</ref>, this formulation can capture delay between adjacent modules vi and v~ by inserting a dummy module v,, on edge (v~, vj) with w(v,,) = 0 and edge delay 6(Vm); such a transformation only increases the size of the netlist by a constant factor. Applications of Min-Delay Clustering abound in the performance-driven design of multi-chip module (MCM) or multiple-FPGA systems. For example, in the latter application a technology-mapped circuit will have been decomposed into configurable logic block (CLB) equivalents, and these must be partitioned onto k FPGA devices subject to hard I/O limits for each device.</p><p>Finally, there is the class of layout-driven multi-way partitioning formulations, which are generally motivated by the link between partitioning and placement in typical physical design methodologies. <ref type="bibr">Vijayan [186]</ref> proposed an abstract formulation that requires the netlist modules to be mapped onto an underlying k-node tree structure. Each node of the tree has a prescribed capacity of netlist modules, and the cost of the k-way partitioning is the sum of the costs of routing each net on the underlying tree structure. Thus, a tree consisting of two nodes, each with capacity n/2, captures Min-Cut Bisection. Similarly, a star topology with k leaf nodes each having capacity n/k, along with a dummy central vertex having zero capacity, captures balanced Min-Cut k-Way For layout-driven applications, a general graph topology rather than a tree structure can better incorporate information about the layout geometry <ref type="bibr">[182]</ref>. For example, if modules are assigned to 12 identical devices that are arranged in a 3 × 4 grid, the cost of a cut net might correspond to the routing tree cost over the devices that contain pins of the net. This formulation applies to partitioning of multiple-FPGA systems, MCM designs, and general floorplanning. As with Vijayan's formulation, edge-weighting of the underlying topology can be used to model distance, signal delay, routing congestion or other layout parameters. <ref type="bibr">Roy and Sechen [159]</ref> have integrated both the perimeter of a net's bounding box and penalties for wirelength of critical-paths into an objective function for MCM partitioning. Similar formulations are given in <ref type="bibr">[158,</ref><ref type="bibr">171]</ref>. The quadrisection problem [178] is a classic special case of the same formulation for standard-cell placement: the underlying graph is a 2 × 2 grid, and the objective is to minimize the number of nets crossing the middle horizontal and vertical gridlines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Constraint-driven (satisficiny).formulations</head><p>With the increasing complexity of system design, CAD optimizations are becoming constraintdriven, i.e., satisficing, meaning that the design problem is expressible as a decision question. If the answer to the decision question is yes, then there exists a feasible solution that satisfies all the constraints, and all feasible solutions are equally good. For example, a design that can achieve a given system clock speed, fit into a given gate array, meet given I/O constraints on logic blocks, etc. will indeed be a good solution. Constraint-driven partitioning formulations are most prominent in the design of multiple-FPGA systems for rapid prototyping or system emulation. Because FPGA gate density is low, and because logic (CLB) and I/O resources both have hard upper bounds, FPGA partitioning is virtually a canonical constraint-driven application. Thus, we use the term "FPGA partitioning" to exemplify the more general case of partitioning with area, I/O and perhaps timing constraints. In FPGA partitioning, a cluster corresponds to an FPGA device (i.e., a chip), so that the circuitry of the modules and the connections in the cluster must be mappable onto the chip. If all the devices are of the same type, <ref type="bibr">Ku~nar et al. [125]</ref> propose finding a feasible solution that minimizes the number of devices. This formulation has also been studied in, e.g., <ref type="bibr" target="#b43">[44,</ref><ref type="bibr">100]</ref>. Notice that this formulation is easily stated as a decision question -"Given a value k and a device type D, does there exist a feasible pk with respect to D?" More generally, a library of different device types with varying size capacities and I/O limits may be available. Each device type D has an associated cost, denoted by cost(D) . Let A = {D1, D2 .... , Dr} denote a library of devices and let dev: 2v~ A be a partial mapping of possible clusters to the lowest-cost device types for which they are feasible. The multiple-device FPGA partitioning problem [125] is: Multiple-Device FPGA Partitioning: Given a library of devices A, find pk = {C1, C2 .... , Ck} and a partial mapping dev such that every Ch~ pk is feasible with respect to dev(Ch) and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition:</head><formula xml:id="formula_6">N V 2 N 2 ~ N 2 N 2 N (a) (b)</formula><formula xml:id="formula_7">F(Pk) = Ek= 1 cost(dev(Ch)) is minimized.</formula><p>For satisficing problems, there are often many solutions that can achieve the same cost. In practice, other criteria can be used to distinguish superior solutions. For example, if w(C) is very close to w(dev(C)), then the FPGA device may not be routable; one may seek to balance "slacks" w(dev(C)) -w(C) among the clusters in order to yield the highest possibility of routing. As another example, it might be desirable to minimize the number of pins used, Ek= 1 IE(Ci)I, since this quantity represents total interconnect between FPGAs. This pin-minimization objective was proposed by <ref type="bibr"></ref> who also studied a more rigid capacity constraint: each module has an associated "cell type" and each FPGA device can only contain a fixed number of modules of each cell type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">6. Replication formulations</head><p>The final class of formulations that we preview removes the assumption that clusters are disjoint, i.e., a module can belong to multiple clusters <ref type="bibr">[122]</ref>. Replicating modules can reduce the cutsize, and is particularly useful for FPGA partitioning since many device architectures seem more I/O-limited or interconnect-limited than logic-limited. Replication can also reduce the number of interchip wires along a given path, increasing system performance. There are three forms of replication in the literature, involving directed graphs [103], hypergraphs with source and destination information <ref type="bibr">[122]</ref>, and functional information <ref type="bibr">[126,1 (i.e</ref>., the actual logic functions must be known in addition to the circuit topology).</p><p>Consider the directed graph shown in Fig. <ref type="figure" target="#fig_4">3</ref>(a), in which module v represents an N-input decoder circuit. The cut shown has size 2 N, but if the decoder v is replicated as in (b), each one of these 2 N edges will become uncut (however, N new edges will be cut). The following rules are used to modify the edge set E when v ~ Ch is replicated into v' ~ C~.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Directed Graph Replication Rules [103]:</head><p>• For each (v, w) with w ~ Cl, replace (v, w) with (v', w).</p><p>• For each (w, v) 6 E, add (w, v') to E.</p><p>Notice that the 2 N edges were removed in Fig. <ref type="figure" target="#fig_4">3</ref>(b) according to the first rule, and the addition of N edges followed from the second rule.</p><p>These rules can be extended to hypergraphs, where source and destination information are known <ref type="bibr">[122]</ref>. The following rules are used to modify the edge set E when v 6 Ch is replicated into V' E Ct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hypergraph Replication Rules:</head><p>• For every net e with v = S(e) and for every Note the difference between this second rule and the corresponding rule for directed graph replication. Fig. <ref type="figure" target="#fig_7">4</ref> shows an example with inputs (outputs) on the left (right) side of each module. By the first rule, replicating v adds the new net e~ containing v' and w to the set of hyperedges; by the second rule, v' is added as another destination module for net e~. Thus, el is still cut only once, but if a directed tree representation and directed graph rules were applied (as in <ref type="bibr">[103]</ref>), both the edges (S(el), v') and (S(el), w) would cross the cut.</p><p>The third replication formulation is due to <ref type="bibr">Ku~nar et al. [126]</ref> and assumes functional knowledge of the circuit. The key idea is that if one knows the actual function of a module, then not all incoming signals may be required by both copies of the replicated module, The first hypergraph replication rule above is applied to construct new nets and remove any resulting 1-pin nets. Then, the second hypergraph replication rule is modified (again, when replicating v to v') to: Consider the module v shown in Fig. <ref type="figure">5</ref>(a), with three inputs e~, e2, e3 and two outputs e4, es. From the dotted lines within the modules, we see that output e4 depends only on inputs e 1 and e3, while output e5 depends only on inputs ez and e3. Three nets cross the cutline in (a), but only two nets are cut after v has been replicated to v' in (b). Applying the first replication rule deletes e~, (since D(e'4) = 0) while e~ remains. Applying the second rule using E*= {e~} shows that v' needs connections to e2 and e3 only, since e's does not depend on el. This formulation is germane to FPGA system synthesis, e.g., CLBs of such popular device families as the Xilinx 4000-series indeed have multiple outputs with differing dependencies on the input variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Move-based approaches</head><p>A partitioning approach is move-based if it iteratively constructs a new candidate solution based on two considerations: (i) a neighborhood structure that is defined over the set of feasible solutions, and (ii) the previous history of the optimization. The first consideration requires the notion of a local perturbation of the current solution; this is the heart of the move-based paradigm. The type of perturbation used determines a topology over the solution space, known as the neighborhood structure. For the objective function to be "smooth" over the neighborhood structure, the perturbation (also known as a neighborhood operator) should be small and "local". Typical neighborhood operators for partitioning include swapping a pair of modules, or shifting a single module, across a cluster boundary. For example, two partitioning solutions are neighbors under the pair-swap neighborhood structure if one solution can be derived from the other by swapping two modules between clusters. In general, the solution space is explored by repeatedly moving from the current solution to a neighboring solution. With respect to previous history, some approaches are "memoryless", e.g., a simple greedy method might rely only on the current solution to generate the next solution. On the other hand, such methods as Kernighan-Lin or Fiduccia-Mattheyses implicitly remember the entire history of a "pass"; hybrid genetic-local search or tabu search approaches, must also remember lists of previously seen solutions.</p><p>Move-based approaches dominate both the literature and industry practice for several reasons. First, they are generally very intuitive -the logical technique for improving a given solution is to repeatedly make it better via small changes, such as moving individual modules. Second, iterative algorithms are simple to describe and implement; for this reason, the bipartitioning method of  and the multi-way partitioning method of <ref type="bibr">Sanchis [164]</ref> are standards against which nearly all other heuristics are measured. Third, the move-based approach encompasses more sophisticated strategies for exploring the solution space -e.g., simulated annealing, tabu search, and genetic algorithms -which yield performance improvements over greedy iterative methods while retaining the intuitiveness associated with local search. Finally, the move-based approach is independent of the nature of the objective function that is used to measure solution quality. While other approaches might require the objective to be of a particular form, or to be a relatively simple function of solution parameters, the move-based approach can flexibly incorporate arbitrary constraints (e.g., on critical path delays or I/O utilization). Thus, the move-based approach has been applied to virtually every known partitioning formulation.</p><p>The remainder of this section is organized as follows. We first discuss the "classic" greedy iterative improvement algorithms, which move from the current solution to the best neighboring solution. We also discuss implementation issues that can greatly affect the performance of these methods. We then discuss three stochastic hill-climbin9 methods -simulated annealing, tabu search, and genetic algorithms -which can move to higher-cost neighboring solutions in order to escape local minima. Finally, the section concludes by reviewing the numerous works that have each adapted some basic move-based paradigm in addressing some variant partitioning formulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Iterative improvement</head><p>Iterative improvement algorithms are based on the greedy strategy: start with some feasible solution and iteratively move to the best (improving) neighboring solution. The process terminates when the algorithm reaches a local minimum, i.e., a solution for which all neighbors have greater cost. Early greedy improvement methods apply simple pair-swap or single-move neighborhood operators, and quickly reach local minima corresponding to poor solutions. By contrast, the strategies discussed in this subsection all rely on extended neighborhood structures which effectively allow hill-climbing out of local minima (even though each strategy is greedy with respect to its neighborhood operator). Due to these methods, iterative improvement remains a viable strategy, particularly when clustering techniques are integrated (see Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1.">The Kernighan-Lin (KL) algorithm</head><p>In 1970,  introduced what is often described as the first "good" graph bisection heuristic. Their algorithm uses a pair-swap neighborhood structure and proceeds in a series of passes. During each pass of the algorithm, every module moves exactly once, either from C1 to C2 or from C2 to C1. At the beginning of a pass, each module is unlocked, meaning that it is flee to be swapped; after a module is swapped it becomes locked. KL iteratively swaps the pair of unlocked modules with the highest 9ain, where the gain of swapping vi ~ C1 with vj ~ Cz is given by F({C1, C2}) -F <ref type="bibr">({CI + vj -vi}, {Cz + v, -vj})</ref>. In other words, the gain is the decrease in solution cost that results from the pair-swap. For a weighted undirected graph and the min-cut objective, the gain for these modules is given by gain(vi, vi) = ~ (aik --ajk) + ~ (aik --aik).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VkEC2 Uk~Cl</head><p>The swapping process is iterated until all modules become locked, and the lowest-cost bisection observed during the pass is returned. Another pass is then executed using this bisection as its starting solution; the algorithm terminates when a pass fails to find a solution with lower cost than its starting solution. An advantage of KL is that it can climb out of local minima, since it always swaps the pair of modules with highest gain even if this gain is negative. However, if we consider all solutions reachable within a single pass of the algorithm to be "neighbors" of the current solution, the KL algorithm is still seen to be greedy.</p><p>A  <ref type="bibr">[169]</ref> extended KL to hypergraphs and a similar extension appears possible for Quick Cut.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2.">The Fiduccia-Mattheyses (FM) algorithm</head><p>Fiduccia and Mattheyses <ref type="bibr" target="#b65">[65]</ref> presented a KL-inspired algorithm which reduced the time per pass to linear in the size of the netlist. The main difference between KL and FM is the neighborhood structure: a new bipartitioning is derived by moving a single module either from Ca to C2 or from Cz to Ca. Since intermediate solutions considered by FM must violate the strict bisection constraint, the solution is permitted to deviate from an exact bisection by the size of the largest module. The gain associated with module v e Ci is [E(Ci)I-IE(Civ)l. Like KL, the FM algorithm performs passes wherein each module moves exactly once, returns the best solution observed during a pass, and terminates when a pass fails to improve the cost function. However, FM permits a much faster O(IE I) implementation on undirected graphs and an O(p) implementation on hypergraphs, where p is the number of pins in the netlist. The key to the speedup is the gain bucket data structure shown in Fig. <ref type="figure">6</ref>, which allows constant-time selection of the module with highest gain and fast gain updates after each move.</p><p>The efficient management of gain buckets is possible because (i) all module gains are integers, and (ii) every gain is bounded above by degmax and below by -degmax. +de.m,, A -degrmnt I 1 2 "'" n Fig. <ref type="figure">6</ref>. The gain bucket list structure as shown in <ref type="bibr" target="#b65">[65]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3.">Tie-breaking strategies</head><p>A frequently cited enhancement to FM is that of <ref type="bibr">Krishnamurthy [123]</ref>. He suggested that the lack of an "intelligent" tie-breaking mechanism from among the many possible modules in the highest-gain bucket could cause FM to make "bad" choices. <ref type="bibr">Hagen et al. [80]</ref> observe that 15-30 modules will typically share the highest-gain value at any time during an FM pass on the Primaryl MCNC benchmark (833 modules). As a tie-breaking mechanism, Krishnamurthy introduced a gain vector, which is a sequence of potential gain values corresponding to numbers of possible moves into the future. Thus, the rth entry in the gain vector looks r moves ahead, and ties are broken lexicographically by lst-level gains, then 2nd-level gains, etc. Gain vectors can be integrated into the FM gain bucket structure, increasing the complexity to O(pr), where r is the maximum number of lookahead moves stored in the gain vector.</p><p>Krishnamurthy defines the binding number flc,(e) of a signal net e with respect to cluster Ci as the number of unlocked modules in Cin e, unless Cine contains a locked module, in which case /?q(e) = ~. Intuitively, the binding number measures how many modules must be moved from C~ in order to move all the pins in e out of C~. This is impossible when a module in C~ n e is locked, so the binding number is infinite. The rth-level gain 7,(v) for v e Ca is given by 7,(v) = I{e e E({v}) s. The first term counts how many nets with binding number r -1 are "created" by the move, and the second term counts how many nets with binding number r -1 are "destroyed" by the move (i.e., have new binding number = ~). Hence, the rth-level gain counts the additional number of nets that may possibly become uncut following r moves. Note that the lst-level gain is identical to the gain in the FM algorithm. Although the benefit of higher-level gains is well-documented (e.g., <ref type="bibr">[94]</ref>), small modifications might improve performance. For example, instead of combining the positive and negative gains into a single term, one could store both terms separately to afford a two-tiered rth-level comparison.</p><p>Even with Krishnamurthy's gain vector, ties may still occur in the lst-through rth-level gains. In this case, the implementation of the gain bucket data structure will determine which module is selected. The original FM algorithm uses a linked list for each bucket; from Fig. <ref type="figure">6</ref>, reproduced from <ref type="bibr" target="#b65">[65]</ref>, we may infer that modules are removed and inserted at the head of the list, i.e., the bucket organization corresponds to a last-in-first-out (LIFO) stack. The authors of <ref type="bibr" target="#b65">[65]</ref> do not mention why a LIFO organization was chosen, but one can speculate that it was an "obvious" choice. However, a first-in-first-out (FIFO) organization which supports the same update efficiency could also be implemented, simply by removing modules from the head of the linked list and inserting modules at the tail of the linked list. Alternatively, a random organization could be implemented, although the time complexity would increase slightly since bucket selection could not be accomplished in constant time.</p><p>Recently, the authors of [80] observed that <ref type="bibr">Sanchis [164]</ref>, and most likely <ref type="bibr">Krishnamurthy [123]</ref>, used random selection from gain buckets in their implementations. Furthermore, <ref type="bibr">[80]</ref> observed that a LIFO gain bucket organization yields considerably superior solutions than either the FIFO or random bucket organization, for both the FM and Krishnamurthy algorithms. (This result seems quite surprising: if anything, "folklore" would have it that introducing randomness can improve solution quality by increasing the range of the neighborhood search.) One possible explanation for the success of LIFO is that it enforces "locality" in the choice of modules to move, i.e., modules that are naturally clustered together will tend to move sequentially. <ref type="bibr">Hagen et al. [80]</ref> use this idea of locality to propose an alternative formula for higher-level gains which also improves performance. Since slight modifications to the bucket organization or gain formula can so dramatically affect the solution quality obtained by these iterative approaches, exploring other implementation choices seems to be a very promising direction for future work. The importance of such research is heightened by the present widespread use of the FM and Krishnamurthy algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.4.">Sanchis ' multi-way partitioning algorithm</head><p>Sanchis <ref type="bibr">[164]</ref> extended the FM algorithm, together with Krishnamurthy's lookahead scheme, to multi-way partitioning. The algorithm is generally straightforward, although there are several knotty implementation issues. Sanchis' detailed explanation of these issues accounts for her algorithm's wide use in practice, as well as its present status as a benchmark against which multi-way partitioning heuristics are compared.</p><p>Sanchis extends the definition for the binding number of a net e with respect to cluster Ci as fl~,(e) = ~j~:i[lcj(e). In other words, fl'c~(e) is the sum of the Krishnamurthy binding numbers for e with respect to every cluster except Ci, and measures the difficulty of removing the pins in e from Ci. The analog of Eq. ( <ref type="formula" target="#formula_18">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Simulated annealing</head><p>Simulated annealing (SA) was popularized by <ref type="bibr">Kirkpatrick et al. [119]</ref> as an alternative to greedy approaches, which become quickly trapped in local minima since they can only make downhill moves. Given a neighborhood structure and a current solution, SA picks a random neighbor of the current solution and moves to this new solution if it represents a downhill move. Even if the new solution represents an uphill move, SA will move to it with probability e-~/r (termed a "Boltzmann acceptance rule") and otherwise retain the current solution; here, A is the cost of the new solution minus the cost of the current solution, and T is the current value of a temperature parameter which guides the optimization. To control the rate of convergence and the strategy for exploring the solution space, the user typically establishes a temperature schedule by which T varies, e.g., as a function of the number of moves made. The SA algorithm enjoys certain theoretical attractions <ref type="bibr" target="#b72">[72,</ref><ref type="bibr">88]</ref> (see also <ref type="bibr">[127]</ref>): using Markov chain arguments and properties of Gibbs-Boltzmann statistics, one can show that SA will converge to a globally optimum solution given an infinite number of moves and a temperature schedule that cools to zero sufficiently slowly. The use of terms such as "cooling" and "temperature schedule" are due to SA's analogy to physical annealing of a material into a ground-state energy configuration.</p><p>For the Min-Cut Bisection problem, <ref type="bibr">Johnson et al. [110]</ref> conducted an extensive empirical study of simulated annealing versus iterative improvement approaches, using various random graphs as a testbed (see Section 7.1). The authors of <ref type="bibr">[110]</ref> conclude that SA is a competitive approach, outperforming KL for uniform and geometric random graphs. However, they suggest that multiple runs of KL with random starting solutions may be preferable to SA for sparse graphs that have local structure (a description that applies to circuit netlists). They also make a number of interesting observations, including:</p><p>• Starting SA with a good solution as opposed to a random solution may be advantageous, particularly if the good solution can identify and exploit special structure of the instance. • Spending long periods of time at high temperatures is not necessary. • Geometric cooling schedules (i.e., setting T = ~MT o where M is the number of moves made and To is the initial temperature) seem at least as effective as nonadaptive alternatives such as logarithmic or linear cooling. Adaptive cooling schedules which are modified during the execution of SA (e.g., based on solution quality, distribution of solution costs in the neighborhood, etc.) hold promise. • Expanding the feasible solution space may be worthwhile (e.g., by loosening the size constraints for bisection); expanding the neighborhood structure allows good solutions to be found more quickly.</p><p>These conclusions are based on studies of random graphs which do not possess natural hierarchical structure. Although there is no a priori reason to doubt such conclusions will also hold for circuit netlists, similar studies using VLSI circuits would seem worthwhile. We note that annealing is</p><p>generally not yet viewed as "practical" for VLSI partitioning applications: runtimes are simply too long. For this reason, there is only limited work that addresses the use of SA for VLS1 partitioning. Parallel implementations, improved temperature schedules, and two-stage approaches which anneal at low temperature starting from a good heuristic solution have all been investigated for VLSI placement, where annealing has often outperformed other heuristics. Quite possibly, such enhancements will make SA more viable for partitioning applications in the future.</p><p>One reason for long SA runtimes is that at low temperatures, many candidate moves (i.e., neighbors of the current solution) might be generated and rejected before one is finally accepted. <ref type="bibr">Greene and Supowit [78]</ref> proposed a "rejectionless" variant of SA in which no moves are rejected, since candidate moves are generated with probability proportional to their likelihood of being generated and accepted given the current solution. For bipartitioning, a "gain" must be stored for each module, and only the gains for modules in M(v) need to be updated when v is moved. The Boltzmann acceptance rule maps the gain of v to a weight w(v), and the probability that v is generated (and moved to) is w(v)/~,u~ v w(u).</p><p>Recently, <ref type="bibr">Roy and Sechen [159]</ref> used simulated annealing to implement a timing-driven MCM partitioning algorithm. Their cost function is the sum of the half-perimeters of each net spanning multiple chips on the MCM, plus a timing penalty for critical nets whose wirelength exceeds predefined constraints. Chatterjee and Hartley <ref type="bibr" target="#b40">[41]</ref> presented an SA-based heuristic which performs partitioning and placement simultaneously. Their cost function is the sum of five components: conflict and capacity costs which combine to measure the feasibility of mapping a cluster onto the chip, a wasted space cost that penalizes unused resources on the chip, a half-perimeter net cost, and a pin cost. These works illustrate the ease with which SA can address relatively arbitrary objective functions (of course, simple objective functions are preferred since evaluation of solution cost dominates the runtime). <ref type="bibr">Sun and Sechen [179]</ref> have also used SA to optimize Absorption in a clustering preprocessor within the TimberWolf placement tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mean field annealing</head><p>Mean Field Annealing (MFA) is a technique similar to SA which also has a physical analogy to systems of particles in thermal equilibrium. <ref type="bibr">Van den Bout and Miller [54]</ref> showed how MFA could be applied to graph partitioning. They use an indicator n-vector x to denote a bipartitioning solution, where xi = 0 corresponds to membership of vi in C1 and x~ = 1 corresponds to membership of v~ in C2. However, x~ can also take on any real value between 0 and 1. Initially, each xi is set to be slightly larger than 0.5. Iteratively, a random v~ is chosen and the two solutions x(0) with xi = 0 and x(1) with xi = 1 are generated from the current solution x and evaluated (the cost function is extended to nondiscrete solutions). MFA then finds a "compromise" value for x~,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>x~ --(1 + e(e(x~l))-Ftx(O)))/T) -1</head><p>and x is modified accordingly for the next iteration. The intuition behind this assignment is that x~ should migrate towards its natural value, e.g., if F(x( <ref type="formula">1</ref>)</p><formula xml:id="formula_8">) = F(x(O)) then x~ = 0,5 and if F(x(1)) ,~ F(x(O)) then x,,~ 1.</formula><p>This process of choosing a random vi and computing a new x~ value is repeated until a stable solution is reached. The temperature T is then lowered and the algorithm repeated; this polarizes the x~ values further (to 0 or 1). Finally, a graph bipartitioning solution is obtained by rounding each x~ to its nearest discrete value. <ref type="bibr">Bultan and Aykanat [33]</ref> have extended this basic approach to multi-way partitioning of hypergraphs. An earlier work of <ref type="bibr">Peterson and Anderson [145]</ref> studied the performance of MFA for graph bisection; their formulation used x with x~ = -1 if v~ ~ C 1 and</p><formula xml:id="formula_9">xi = 1 if vi ~ C2, with maximization objective = ~=1 aljxixj-~ xi F(x) 2i= j=l i</formula><p>where ~ is a user-chosen constant. The first term of the objective affords a positive weight aij if (vi, v j) is not cut, and weight -a~ i if (v~, v~) is cut; the second term penalizes cluster size imbalance.</p><p>While MFA is a well-studied optimization paradigm, its application to VLSI CAD remains largely unexplored. Like many promising approaches (for instance, those based on eigenvectors, one-dimensional orderings, mathematical programming, fuzzy clustering, etc.), the MFA approach permits nondiscrete partitioning solutions (i.e., a relaxation), and thus allows search over a larger solution space. As highlighted in Section 4, a reasonable strategy is to leave the feasible ("legal") region of the solution space, find a superior infeasible ("nonlegal") solution, then find the feasible solution that is closest to the infeasible solution. However, like SA, MFA takes a long time to converge, although parallel implementations may reduce this time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Tabu search</head><p>Tabu search was proposed by Glover <ref type="bibr" target="#b74">[74]</ref> as a general combinatorial optimization technique. Tabu search is similar to iterative improvement in that moves are sought which transform the current solution to its best neighboring solution. Tabu search also maintains a tabu list of its r most recent moves (e.g., pairs of modules that have been swapped recently), with r a prescribed constant; moves on the tabu list cannot be made. The tabu list exists to prevent cycling near a local minimum and also to enable uphill moves; the tabu list can be viewed as an alternative to the locking mechanism in KL and FM. Occasionally, a tabu move may be made if the aspiration function permits it (essentially, the aspiration function will override the tabu list if the move "looks good enough"). A claimed advantage of tabu search over SA is that SA may waste time making poor random moves or cycling through previously visited regions of the solution space. Although tabu search can certainly behave similarly, it is designed to quickly find a local minimum, climb out of the "valley" surrounding this local minimum, and then move on to the next local minimum. In this sense, tabu search might explore the solution space more efficiently than SA. 7</p><p>Tabu search has been applied to graph bisection by <ref type="bibr">Tao et al. [180]</ref> and <ref type="bibr">Lim and Chee [134]</ref>. In [180], a move consists of swapping a pair of modules, and the aspiration function is one less than the cost of the best solution, i.e., a pair swap on the tabu list is accepted if the resulting solution has lower cost than every solution seen so far. The authors of [134] also adopt a pair-swapping neighborhood structure, although the aspiration function depends on the cost of the current solution. For each solution with cost F, the aspiration value A(F) is the maximum decrease in cost that has been previously observed when moving from a solution of cost F. Thus, if a move from a solution with cost F results in a solution with cost F', then the aspiration function overrides the tabu list if F -F' &gt; A(F). <ref type="bibr">Areibi and Vannelli [9]</ref> first applied tabu search to hypergraph bipartitioning using the same aspiration function as <ref type="bibr">[134]</ref>, but with single module moves as the neighborhood operator. <ref type="bibr">Andreatta and Ribeiro [7]</ref> applied tabu search to a DAG partitioning formulation designed for 7It is instructive to compare the motivations for tabu search with those of other methods in the optimization literature, e.g., Baum's iterated descent  or the "iterated Lin-Kernighan" strategy used by <ref type="bibr">Johnson [109]</ref> to address the traveling salesman problem. Furthermore, one may ask whether certain problem classes possess relationships among local minima in the neighborhood structure which make tabu search more effective (e.g., see <ref type="bibr" target="#b24">[25]</ref>). <ref type="table">VLS1Journal 19 (1995) 1-81</ref> testing of combinational circuits. Areibi and Vannelli have also applied tabu search as a postprocessing mechanism to initial partitioning solutions constructed using an eigenvector <ref type="bibr" target="#b9">[10]</ref> and a genetic algorithm <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11]</ref>. In <ref type="bibr">[-8]</ref>, the genetic algorithm is used to generate many good starting solutions, so that the tabu search can concentrate its efforts on the most promising regions of the solution space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.J. Alpert, A.B. Kahng / INTEGRATION, the</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Genetic algorithms</head><p>Genetic algorithms are motivated by Darwin's theory of natural selection in evolution, where "superior" members of a species produce more offspring in succeeding generations than "inferior" members <ref type="bibr">[.98</ref>]. A oenetic aloorithm (GA) starts with an initial population of solutions. This population evolves over generations, with the solutions in the current generation being replaced with a set of offsprin9 solutions in the next generation. A GA implementation typically has crossover and mutation operators that determine candidate offspring for the next generation. The crossover operator is analogous to mating: two solutions are selected from the current population (based on some probabilistic selection scheme), and their descriptors are partially mixed to generate an offspring. The mutation operator enables small random perturbations to a given single solution. There exists some heuristic justification (cf. the "schema theorem" of [98]) as to why such operators enable "good" solution characteristics to become more prevalent (and "bad" characteristics less prevalent) in the population with succeeding generations. The replacement scheme is the final component of a GA; it determines which offspring will replace which members of the current population. Designing each of these elements (crossover and mutation operators, selection scheme and replacement scheme) seems to be critical to the success of a genetic approach. <ref type="bibr">Inayoshi and Manderick [108]</ref> studied weighted graph bisection, representing a solution as an indicator vector having equal numbers of O's and l's. The Hamming distance between two solutions x and y is given by dH(x, y) = I~x -yll 2, i.e., the number of entries in which x and y differ.</p><p>The crossover operator applied to x and y constructs an offspring z in which zi = xi if xi = yi; otherwise, if dn(x, y) = 2M, the 2M coordinates of z in which x and y differ are randomly filled with M ones and M zeros. Thus, z inherits the entries common to its two parents, and has mean Hamming distance M to each of its parents. A mutation of x flips a random x~ = 1 to 0 and a random xj = 0 to 1, yielding one of the n2/4 neighbors of x according to the pair-swap neighborhood structure. The selection scheme is linear-rank based: solutions are ranked by their cost, and the probability of a solution being chosen for a mutation or crossover operation is decreases linearly with its rank.</p><p>Ackley <ref type="bibr" target="#b0">[1]</ref> proposed a GA for Min-Cut Bisection that combines crossover and mutation into a single operation. The crossover of x and y yields an offspring z for which each entry z~ has probability p of being set to a random value, and probability (1 -p)/2 of being set to x~ or y~, respectively. The selection scheme is purely random and the replacement scheme eliminates a random solution in the current population which has below-average quality. This GA may create unbalanced solutions that are not legal bisections, and therefore also incorporates a penalty term equal to 2(llxll 2-n/2) 2 in the cost function. The structure of the cost function reflects the preference of [,1] for a continuous cost function over the solution space.</p><p>Bui and Moon have utilized GAs for graph bisection <ref type="bibr">[32]</ref> and for ratio cut bipartitioning of hypergraphs <ref type="bibr" target="#b30">[31]</ref>. Their linear selection scheme is a function of solution cost instead of rank (specifically, the best solution is four times as likely to be selected as the worst solution, and a solution of intermediate quality will be chosen with probability proportional to its cost difference from the worst solution). The replacement scheme is adaptive; in general, an offspring replaces its more closely related parent (in terms of Hamming distance) if it has lower cost than the parent. The mutation operator flips each xi value in x with independent probability 0.015, and crossover is accomplished via random crossover points. For example, if there are three crossover points 1 ~&lt; cl &lt; c2 &lt; c3 ~&lt; n, then the offspring z derived from crossover of x and y has zi = xl for 1 ~&lt; i &lt; Cl, c2 ~&lt; i &lt; C 3 and zi = Yi for cl ~&lt; i &lt; c2, c3 ~ i ~&lt; n. Since this crossover operator makes it likelier for v~ and vj to be in the same cluster if li -Jl is small, ordering the indicator vector to capture the netlist structure can improve performance. The implementation of <ref type="bibr" target="#b30">[31]</ref> adopts a weighted depth-first ordering; orderings based on the 1-dimensional representations discussed in Section 4 may be promising in this context. <ref type="bibr">Saab and Rao [162]</ref> proposed a simulated evolution bisection heuristic which has no crossover operator, but rather a more complex mutation operator. The authors of [162] define the "goodness" of a module vi (e.g., in C~) as EJI~, where E~ = EvjEc2 a~j is the cost of the external edges incident to vi and I~ = y ~jEcl aij is the cost of the internal edges incident to v~. If the goodness of v~ is less than a given random number between 0 and 1, then vi is judged to be good; otherwise, it is judged to be bad. Intuitively, a good vertex should remain in its current cluster since it is likely to have many internal connections; on the other hand, a bad vertex should be moved to the other cluster ([162] also provides a secondary criterion for judging a vertex good or bad). The mutation operator essentially swaps large subsets of bad vertices. Finally, GAs for multi-way partitioning have been proposed by <ref type="bibr">Chandrasekharam et al. [39]</ref> and <ref type="bibr">Hulin [102]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Local search hybrids and multi-start</head><p>Because GAs are ill-equipped to search a prescribed region of the solution space for local optima, a given GA may take fairly long to find a good solution, if it finds one at all <ref type="bibr" target="#b30">[31]</ref>. Thus, many researchers have successfully combined GAs with local optimization heuristics to form GA-local search hybrids, or hybrid GAs. For example, lnayoshi and Manderick [108] applies KL to every member of the population; <ref type="bibr" target="#b30">[31,</ref><ref type="bibr">32]</ref> do the same with FM; and <ref type="bibr" target="#b7">[8]</ref> does the same with tabu search.</p><p>Recent works have shed some light on the mechanism by which GAs, and GA hybrids in particular, can find good solutions. Boese et al. <ref type="bibr" target="#b24">[25]</ref> and lnayoshi and Manderick <ref type="bibr">[108]</ref> observe that many of the best local optima are "close" to other local optima according to natural measures of distance in the neighborhood structure. Fig. <ref type="figure" target="#fig_13">7</ref> depicts 2500 runs of a greedy pair-swapping heuristic on a random graph in the class Gaui(100, 4, 10) (see Section 7.1). In (a), for each local minimum the average distance to the other local minima (in terms of number of pair-swaps) is plotted as a function of solution cost. The distribution indicates that the local minima with lowest cost are on average closer to all the other (2499) local minima, i.e., they are in the center of a "big valley" structure that governs the set of all local minima. Fig. <ref type="figure" target="#fig_13">7</ref>(b) plots for each local minimum the distance to the best (lowest-cost) local minimum; again we see that the local minima that are structurally most similar to the best minimum are also the next best solutions. Such correlations suggest that a crossover between two good solutions might lead to an even better solution, since it in some sense "averages" the good solutions and the cost surface is "convex". Indeed, hybrid GAs -in retaining common features of parents and searching only the "regions of disagreement" -implicitly assume that global optima will be located near good local minima.  Based on the "big valley" (Fig. <ref type="figure" target="#fig_13">7</ref>), Boese et al. <ref type="bibr" target="#b24">[25]</ref> suggested the following adaptive multi-start (AMS) approach (originally in the context of the traveling salesman problem)• First, AMS generates a set of random starting solutions and runs a greedy iterative algorithm from each solution to find corresponding local minima. Then, AMS generates new starting solutions by combining features of the t best local minima seen so far, with t being a parameter of the approach• New local minima are obtained by running the greedy algorithm from these new starting solutions, and the process iterates until some stopping criterion is met. AMS bears some resemblance to hybrid GAs, but differs in that many solutions (instead of just two) are used to generate the new starting solution. AMS also uses only the t very best solutions to construct the new starting solution, while the standard GA selection scheme will incorporate inferior solutions with nonzero probability•</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Adaptations of move-based algorithms</head><p>In practice, iterative improvement methods (i.e., KL, FM, Krishnamurthy and Sanchis) are the most commonly applied, due to their excellent runtimes, relatively high solution qualities, and simple implementations. Their basic paradigms are also flexible enough to adapt to objectives other than rain-cut, as well as to variant netlist representations, solution constraints, etc. We now review the "litany" of iterative adaptations that have appeared in the literature. We loosely categorize each approach by either its characteristics or its associated problem formulation•</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1.">Alternative move strategies</head><p>A possible weakness of the KL and FM strategies lies in the locking mechanism, e.g., a module v may be moved from Ca to C2 early in a pass, only to have many of its neighboring modules moved back to Cz, which causes v to be in the wrong cluster. To rectify this behavior, <ref type="bibr">Hoffman [97]</ref> proposed a dynamic locking mechanism which behaves like FM, except that when v is moved out of Ci, every module in M(v) n Ci becomes unlocked. This allows the neighbors of v in C~ to also migrate out of C~. The algorithm permits a maximum of ten moves per module per pass. Dasdan and Aykanat <ref type="bibr" target="#b52">[52]</ref> propose a multi-way FM variant that allows a small constant number (e.g., three or four) module moves per pass. <ref type="bibr">Yeh et al. [194]</ref> gave an extension of Sanchis' multi-way partitioning algorithm that alternates "primal" passes of module moves with "dual" passes of net moves. A dual pass allows more than one module to be moved simultaneously, thereby expanding the neighborhood structure. For each net e, Yeh et al. define the critical set with respect to C; as e c~ Ci and the complementary critical set as e -(e n C~). A move in a dual pass consists of either moving the critical set out of Ci or moving the complementary critical set into C~. The gain is the decrease in cost of the partitioning solution resulting from the move. Due to the complexity of the gain computation, a dual pass typically requires around 9-10 times the CPU of a primal pass. <ref type="bibr">Kring and Newton [122]</ref> extended FM to include module replication moves. The gain for replicating a module v is the change in cutsize resulting from applying the replication rules in Section 2.6. For hypergraphs with signal information, the gain is the number of cut nets for which v is a source, minus the number of uncut nets for which v is a destination. The authors of <ref type="bibr">[122]</ref> observe that once a module v is replicated, v tends to remain replicated, so that modules in M(v) tend to remain in their clusters. This behavior inhibits further moves, hence Kring and Newton restrict the number of replications by keeping three separate bucket structures for normal, replicating and unreplicating moves. Separate structures permit the unreplication of a module if its unreplication gain is higher than a prescribed threshold, even if better moves are available. Kring and Newton also prescribe a minimum replication gain threshold below which a module replication is prohibited, even if it is the best move available. <ref type="bibr">Sechen and Chen [170]</ref> propose another modification of the original KL and FM descriptions, based on the observation that the Min-Cut Bisection objective (and the associated gain computation) are not ideal when the partitioning solution is to be used as the basis of hierarchical placement. If a net e has more than one pin in both C1 and C2, then e may cross the cut more than once after routing. For example, let vl, v3, v5 ~ C1 and v2, v4, v 6 ~: C 2 be the modules of a 6-pin net e, and assume that the cut between Ca and C2 corresponds to a vertical slice of the placement. If module v~ ~ e is placed in row i, then if e is routed to minimize vertical wirelength, e will cross the cut six times. Thus, for each net e, the authors of [170] consider every possible assignment of modules in e to rows 1, 2, ..., Jel, compute the number of times e will cross the cut when routing each configuration, then average the results to derive an expected cutsize for e. This expected cutsize is used to compute module gains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2.">Relaxed size constraints</head><p>In practice, an exact bisection is not required, yet if cluster size constraints are removed, an unbalanced bipartitioning will result. This has motivated several alternative strategies. <ref type="bibr">Wei and Cheng [187]</ref> proposed the following iterative approach to optimize the ratio cut objective. First, pick random modules v and w, form the bipartitioning {C1, C2} where C~ = {v} and C2 = V -{v}, and iteratively move modules from C~ to C2 to optimize ratio cut, until C1 = V-{w} and C2 = {w}. This step is repeated with the roles of w and v reversed, and the best of up to 2n -2 ratio cut bipartitionings created is taken as the initial solution. Then, an iterative shifting procedure is repeatedly applied: a right (left) shift iteratively moves modules from C1(C2) to C2(C1) to optimize ratio cut until C1(C2) = 0. The solution with smallest ratio cut generated during a shift starts the next iteration, and left and right shifts are alternated. Finally, Wei and Cheng apply an FM variant in which (i) there are no size constraints, and (ii) if two modules have the same gain in terms of nets cut, then the module which causes the larger reduction in ratio cut is selected to be moved. In <ref type="bibr">[188]</ref>, the same authors have also applied a hierarchical version of their algorithm to obtain clusterings for use within two-phase FM (see Section 6). <ref type="bibr">Park and Park [144]</ref> modify Sanchis' algorithm to handle relaxed balance constraints, using the cost function: IE(pk)I + R" CBal <ref type="bibr">(P k)</ref> where</p><formula xml:id="formula_10">CB~(P k) = ~ Iw(C,) -w(Cj)[ 1 &lt;~i&lt;j&lt;~k</formula><p>and R is a user-defined parameter. The term CBal(P k) is minimized when cluster sizes are perfectly balanced and increases as clusters become unbalanced. Sanchis's algorithm is applied without lookahead gain vectors; the algorithm maintains two gain bucket structures, one for cutsize as in traditional FM and one for Caa~.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.3.">FPGA partitioning</head><p>FPGA partitioning poses qualitatively different challenges than Min-Cut partitioning due to hard size and pin constraints implicit in mapping onto prescribed devices. <ref type="bibr">Woo and Kim [189]</ref> consider additional "cell-type" constraints for the devices: each FPGA device has an upper bound (capacity) on the number of modules of a given cell-type that can be assigned to the device. Woo and Kim proposed a k-way extension of FM in which the objective is to minimize the maximum number of I/Os used by the devices while satisfying type constraints and upper bounds on cluster size and I/O. Like FM, this algorithm seeks to move the highest-gain module, although many modules may have to be examined before finding a feasible move. Thus, the approach may be viewed as multi-way FM with a more complex gain function and certain moves being forbidden. A related satisficing formulation for MCM partitioning was addressed by Chen et al. <ref type="bibr" target="#b41">[42]</ref>; their method solves the linear programming relaxation of an integer program, converts to a feasible solution, and then applies a KL-based post-processing step. <ref type="bibr">Ku~nar et al. [125]</ref> recursively apply FM bipartitioning to address the Multiple Device FPGA problem. For a given library of devices and number of modules in the circuit, an integer linear program (ILP) can be solved to find a set of devices that yields a lower bound on cost. This device set would form the optimal solution if the circuit had no interconnections; however, it may not be possible to map the circuit onto these devices while satisfying I/O constraints. The algorithm picks the largest device D from this device set, and applies FM bipartitioning to yield {C1, V -C~} where C1 is feasible for D. The ILP is resolved for the remaining subcircuit V -C1 and the largest device D' is chosen from the set and FM is run on V -C~ to yield {C1, C2, V -C1 -C2} with C2 feasible for D'. This continues until the ILP yields a single device that is the smallest device onto which the remaining subcircuit can be feasibly mapped. Note that the objective function is not exactly min-cut, due to the existence of system I/O pins in the initial circuit description. For example, a net e that contains a system I/O pin on C1 will require an additional terminal on the CI device ife has a pin in V -C1. Ku~nar et al. minimize an objective consisting of the number of nets cut times the number of terminals in the remainder of the subcircuit (the solution cost is infinite if device constraints are violated). They also give a slight, but perhaps promising, modification to the FM paradigm. During an FM pass, their implementation records both the best and the second-best solutions encountered. When a pass starting from the best solution does not yield any improvement, a second pass starting from the second-best solution is performed. Only if this pass also fails to yield improvement does the algorithm terminate. In [126], <ref type="bibr">Ku~nar et al. extend</ref> this algorithm to include functional replication (see Section 2.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.4.">Layout-driven .formulations</head><p>To map modules onto an underlying tree structure, <ref type="bibr">Vijayan [186]</ref> applies a variant of Sanchis' algorithm but with no lookahead gains. The overall procedure is the same, but the gain computation and update are complicated since the objective is the cost of routing nets on the tree structure. A speedup of Vijayan's heuristic was given in <ref type="bibr">[182]</ref>.</p><p>If the underlying structure is a 2 x 2 grid, a quadrisection formulation results. The motivation is that applying alternating horizontal and vertical cuts in hierarchical rain-cut placement will cut fewer nets in the first direction chosen. The quadrisection formulation can trade off between vertical and horizontal routing resources according to a user-specified parameter. <ref type="bibr">Suaris and Kedem [178]</ref> adapted FM to this problem: there are 12 possible ways to move modules from cluster C~ (four choices) to Cj (three choices), so 12 different gain bucket structures are used to store the move types. The authors of [178] construct a placement by using the terminal propagation technique of <ref type="bibr" target="#b60">[60]</ref> and recursively quadrisecting the clusters. <ref type="bibr">Shih et al. [174]</ref> have applied a multi-way KL variant to MCM partitioning with cluster timing, area, thermal and pin constraints, where the objective is to minimize wirelength over the MCM configuration. An initial solution that satisfies timing constraints is constructed by merging modules with timing dependencies into "super-nodes". The super-nodes are then greedily packed into k clusters such that all the constraints are satisfied. Finally, multi-way KL is run on the clusters such that all the modules in a super-node must be moved together, and only moves which satisfy the constraints are permitted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.5.">DAG partitioning</head><p>Finally, we note variants which partition combinational Boolean networks. Since the input G(V, E) is a DAG, a partitioning of V induces a dependency graph with k nodes, each corresponding to a cluster. The directed edge (Ci, Cj) is an edge in the dependency graph if3u ~ Ci, v ~ Cj such that (u, v) ~ E. <ref type="bibr">Cong et al. [50]</ref> define a partitioning to be acyclic if it induces an acyclic dependency graph (which is desirable for pipelining or parallel circuit simulation applications). Since a random initial solution is not guaranteed to be acyclic, initial solutions are constructed using random topological sorts. Sanchis' algorithm is then applied, with moves restricted so as not to create a cycle in the dependency graph. The approach also uses MFFC clustering (see Section 6), within a two-phase methodology. An interesting approach of <ref type="bibr" target="#b21">[22]</ref> applies FM and a resynthesis technique </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.6.">Perspectives on "iterative variants"</head><p>This subsection has surveyed a "litany of variants" arising from the core FM, KL, and Sanchis algorithms. Many of the modifications represent rather simple ideas, such as allowing locked modules to become unlocked, keeping the best and second best solutions, allowing net moves in addition to module moves, etc. More importantly, it remains unclear which of these modifications really improves the algorithm and which are "simply different". (For example, the partitioning study <ref type="bibr">[94]</ref> concludes that dual passes are not worth the extra runtime.) As we have previously discussed, small changes in implementation can greatly affect performance, so further study of modifications to iterative methods is likely to be worthwhile; on the other hand, very detailed and systematic investigations are required if meaningful conclusions are to be drawn.</p><p>The "litany of variants" also reveals that applying an FM-based algorithm to yet another problem formulation can require varying degrees of innovation. For example, the balance term in the cost function of <ref type="bibr">[144]</ref> is obvious: increase the penalty proportionally to the deviation from bisection. On the other hand, certain changes in formulation may appear simple (e.g., partitioning onto an underlying tree structure, by <ref type="bibr">Vijayan [186]</ref>, but issues such as efficient gain updating can make the implementation differences non-trivial. Many new problem formulations seem very similar to previous ones (modulo some extra constraints or modified cost functions), hence care must be taken to discern the works which more substantially advance the field through their combination of relevance, non-obvious solution, and experimental methodology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Geometric representations</head><p>A geometric representation of the circuit netlist can provide a useful basis for a partitioning heuristic, since speedups and special "geometric" heuristics become possible. For example, computing a minimum spanning tree of a weighted undirected graph requires O (n 2) time, in general, but only O (n log n) time for points in 2-dimensional geometric space <ref type="bibr">[150]</ref>. Single-source shortest path, all-pairs shortest paths, and matching are other examples of problems that can be solved more efficiently for geometric instances. This section discusses partitioning approaches based on finding a geometric representation of a graph or hypergraph and applying "geometric" algorithms to find a partitioning solution. We focus on three primary types of representations:</p><p>• A 1-dimensional representation or a linear ordering is a sequential list of the modules. Generally, modules that are closely connected should lie close to each other in the ordering, so that the ordering can reveal the netlist's structure. Indeed, problems in the sparse matrix computation literature such as finding minimum bandwidth, minimum profile, and minimum fill-in orderings exactly correspond to this type of ordering problem <ref type="bibr">[147]</ref>. A linear ordering may also be viewed as a 1-dimensional placement, and vice-versa; consequently, some of the partitioning approaches we discuss below were originally designed for 1-dimensional placement. • A multi-dimensional representation is a set of n points in d-dimensional space with d &gt; 1, where each point maps to (represents) a unique module. This representation implicitly defines a distance relation between every pair of' modules, e.g., the Euclidean distance between their corresponding points. Geometric clustering algorithms may be applied to the set of points, possibly in conjunction with other graph-based algorithms. Such a representation is also common 2-dimensional cell placement. • A multi-dimensional vector space representation can arise in two distinct ways. Using one approach, the vector space consists of indicator n-vectors (corresponding to bipartitioning solutions), and the problem becomes one of finding the direction of the best indicator vector <ref type="bibr" target="#b68">[68]</ref>. Using the other approach, the n modules are mapped to n vectors in d-space and the vectors are clustered together to form both a vector partitioning and a module partitioning <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">6,</ref><ref type="bibr" target="#b36">37]</ref>. A major advantage of the vector space approach is that spectral methods can be used to construct a vector space that optimally captures the netlist information vis-~-vis partitioning, i.e., the optimal indicator vector direction or the optimal vector partitioning solution will map to the optimal graph partitioning solution.</p><p>Spectral methods are of primary importance in constructing geometric representations; their discussion requires the following notation. Assume the netlist is represented as a weighted undirected graph G(V, E) with adjacency matrix A = (air). The n × n degree matrix D is given by dgi = deg <ref type="bibr">(vi)</ref>  8This property combined with the orthogonality property implies that the entries of each/~ withj &gt; 1 sum to zero. This does not necessarily hold for the spectra of A, and further the eigenvalues of A will generally be both positive and negative. However, in practice, a diagonal matrix B is often added to A to ensure positive semi-definiteness and the computability of eigenvectors, and also to obtain properties similar to Q (e.g., Donath and Hoffman <ref type="bibr" target="#b59">[59]</ref> use B = -D, thereby obtaining the spectra of -Q). Currently, the relationship between the spectra of A and Q are not wellunderstood, although we believe that most theoretical results in the spectral literature can be equivalently derived with either Q or A. To this end, we discuss as many of the works in this section as possible in terms of Q, even if the original paper used A. For example, the discussion of <ref type="bibr">Barnes's work [18]</ref> below is given in terms of Q, which allows us to establish the equivalence of lower bounds due to Barnes and to Donath and Hoffman. By "equivalence", we mean that following the theorem derivation of each work using the spectra of Q leads to the identical result.</p><formula xml:id="formula_11">with dij = 0 if i ~-j. The n x n Laplacian matrix of G is defined as Q = D -A. An n-dimensional</formula><p>The remainder of this section is organized as follows. First, we discuss the one-dimensional placement algorithm of <ref type="bibr">Hall [89]</ref>, and see how the second eigenvector/~2 gives the optimal solution for minimum-squared wirelength placement. A linear ordering of modules is obtained by sorting the entries of~u2, and a heuristic bipartitioning can be derived from splitting the ordering. Next, we describe an extension of Hall's multi-way partitioning approach due to <ref type="bibr">Barnes [18]</ref>, as well as some other extensions (e.g., <ref type="bibr">[79,</ref><ref type="bibr" target="#b36">37]</ref>). These approaches use k eigenvectors to derive a k-way partitioning; Barnes' approach explicitly tries to map each cluster to a single eigenvector. Third, we discuss an alternative approach that uses multiple eigenvectors to generate a bipartitioning. This linear probe technique 1-68] first constructs a vector space using the eigenvectors as a basis, then generates probes which search the vector space to find good bipartitionings. Fourth, we discuss utilizing this vector space to construct a vector partitioning problem that is equivalent to many multi-way graph partitioning formulations. Finally, we discuss techniques for deriving partitioning solutions from a linear ordering, and show how many of the approaches presented in this section can be used to construct such linear orderings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Hall's quadratic placement</head><p>As defined in Section 2.1, we let x denote the 0-1 indicator vector for a given bipartitioning p2. The min-cut bipartitioning objective (F(P 2) = I E(C1)I) can now be written as</p><formula xml:id="formula_12">2F(p2)=xTQx = ~ ~ aij(xi-xi) 2. (4.1)</formula><p>i=lj=l All the (xi -x j) 2 terms in the double summation of Eq. (4.1) are zero, unless vi and v~ are in different clusters. In this case, (x~ -x~) 2 = 1, and the cost aii of each cut edge appears twice in the sum, so the double summation evaluates to 2F(p2). Also observe that Eq. (4.1) gives the squared wirelength of the 1-dimensional placement given by x, even when the coordinates are allowed to be non-discrete, i.e., the x{s are not restricted to integer values. Under the constraint IIx II 2 = xTx = 1, <ref type="bibr">Hall [89]</ref> showed that x = P2 gives the optimal nontrivial 1-dimensional placement, with squared wirelength equal to 22 (note that/~ gives the trivial zero-wirelength solution with all modules placed at coordinate 1/x/-n).</p><p>The significance of Hall's result is that it provides the optimal non-discrete solution for min-cut bipartitioning. Although a non-discrete solution for x is meaningless, this result suggests heuristically finding the discrete solution "closest" to /u2. Given cluster size constraints [Cll = m~ and Ic21 = m2, the closest discrete solution is obtained by sorting the coordinates of /~2 the m~ modules with the highest coordinates are placed in C1 and the m2 lowest modules with the lowest coordinates are placed in C2. The reverse assignment is also attempted, and one of these solutions is guaranteed to be closest to/u2 as measured by the Frobenius norm. One can view this sorting algorithm as moving the smallest coordinates to Ca (corresponding to xi = 0) and the largest coordinates to C~ (corresponding to x~ = 1). 9 This approach of finding the bipartitioning 9 This interpretation is not exactly correct since x =/J2 has y~ 7-1 xi = 0 while the sum for an indicator vector of a bisection is n/2. Furthermore, the indicator vector for a bisection also has LIx LI 2 = n/2 as opposed to 11/~2 It 2 = 1. These inconsistencies are addressed by using coordinates ( -1/~/-n, 1/x/-n) instead of (0, 1) for the indicator vector. Note that these coordinates correspond to the ratioed assignment matrix R defined in the next subsection. which best approximates the second smallest eigenvector was first used by <ref type="bibr">Barnes [18]</ref> and is commonly known as spectral bisection (when ml = m2 = n/2). This algorithm has also been widely used by the sparse matrix computation community; <ref type="bibr">Pothen et al. [148]</ref> have used it as the basis of a vertex separator algorithm, and <ref type="bibr">Hendrickson and Leland [96]</ref> have extended it to partitioning onto hypercube or mesh architectures. Also, <ref type="bibr">Hagen and Kahng [82]</ref> extended spectral bisection to ratio cut bipartitioning by choosing the best ratio cut that results from each possible split of the sorted coordinates of ~2.</p><p>We observe that spectral bisection may perform arbitrarily worse than optimal, as illustrated by the following example. Consider the graph in Fig. <ref type="figure" target="#fig_16">8</ref> in which each circle represents a clique, so that two (n/4)-cliques A and C are each connected by a single edge to the (n/2)-clique B. Since/~2 gives the optimum 1-dimensional squared wirelength placement, sorting the entries in/~2 yields the coordinates for modules in A, followed by the coordinates for those in B, and in turn followed by the coordinates for those in C. Consequently, spectral bisection will split B into equal halves, cutting (n/4) 2 = n2/16 edges. This solution is an f2(n 2) factor worse than the optimum bisection cutsize of two edges, obtained by assigning A and C to one cluster and B to the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Mapping k clusters to k eigenvectors</head><p>Hall's approach can be extended to multi-way partitioning by associating each duster with an eigenvector with small eigenvalue. The 1-dimensional placement solution P2 yields the minimum squared wirelength of 22, but ~3 gives the next best solution (orthogonal to/t2) with cost 23, etc.</p><p>again subject to the IIx 112 = 1 constraint. For each of these high-quality I-dimensional eigenveetor placements, the closest indicator vector can be easily found, and the k indicator vectors can be used to construct a k-way partitioning.</p><p>Assume that the standard multi-way partitioning objective F(P k) = y k=llE(Ch) I applies, and that prescribed cluster sizes ml I&gt; m2/&gt; ... i&gt; mk &gt;/0 are given. Let M denote the k x k diagonal matrix with entries m~, m2, ..., mk. Although X denotes the assignment matrix for pk, sometimes it will be advantageous to represent pk as the n x k ratioed assianment matrix R = (r~h) where r~h = 1/Ix//~hl if v~ ~ Ch and rib = 0 otherwise. Notice that Rh, the hth column of R, has magnitude one, thereby satisfying the constraint in Hall's 1-dimensional placement formulation. Let P = (Pu) be the n x n partition matrix with pq = 1 if vi and vj are in the same cluster and p~j = 0 otherwise; observe that P = XX T = RMR r. Finally, define the n x n ratioed partition matrix pR to be a scaled version of P with ij entry equal to 1/I CI if v~ and v~ are in the same cluster C, and 0 otherwise (so pR = RRT). <ref type="bibr">Barnes</ref>   It is not hard to show that the eigenvalues of -P are -ml, --mE .... , --ink, 0, 0, ..., 0, which yields</p><formula xml:id="formula_13">k k IIQ -(-P)[I 2 &gt;~ E ( 2i --(--mi)) 2 q-~'~ (2i --0) 2 = E (2i -b mi) 2 -k-~ 22. (4.3) i=1 i=k+l i=l i=k+l</formula><p>Combining Eq. ( <ref type="formula">4</ref>.3) with Eq. (4.2) yields the equivalent of the famous Donath and Hoffman 1-59] lower bound: F(P k) &gt;1 s k= 12imi. 1° Actually, the lower bound of <ref type="bibr" target="#b59">[59]</ref> is stronger, since it holds for not only the eigenvalues of Q, but also the eigenvalues of D -A as long as the diagonal matrix D has trace(D) = ~= ~deg(v~). It is thus possible to vary D to increase yk= ~2~mi and improve the lower bound.</p><p>Observe that the Donath-Hoffman lower bound also implies that an optimal partitioning solution would be obtained if each R~ could be set to/~. However, setting R = Uk generally does not yield a valid ratioed partition matrix. <ref type="bibr">Barnes [18]</ref> justifies his approach to finding a valid R that best approximates Uk as follows. Since Q = U,A,Ur, and P ---RMR v, Eq. (4.2) implies that the partitioning objective can be written as (4.4)</p><p>If R could be chosen such that UX, R = J, where J is the n x k matrix having the k x k identity matrix, Ik as its first k rows and all other entries zero, we would have equality in Eq. (4.3), and R would represent the optimal partitioning solution. Since such a choice of R is generally impossible, Barnes chooses to minimize the error II UV.R -J II 2 ___ II Uk -R II 2 by setting up a transportation problem which can be solved efficiently (see Section 5.3.3). To minimize this error for a given vector R~ (representing C~), I~TR~I should be maximized; this occurs when the nonzero entries of R~ are the m~ largest (or smallest) coordinates of ~. Of course, it may not be possible to choose each R~ in this fashion, because a module might be assigned to more than one cluster; Barnes' transportation formulation optimally resolves this conflict. Notice that for k---2, this formulation reduces to minimizing [I U2 -R ll 2 and the optimal solution is derived by sorting the coordinates of ~u2 as discussed above.</p><p>Barnes' algorithm was applied to VLSI circuits by <ref type="bibr">Hadley et al. [79]</ref>, who also incorporated a new clique net model to obtain a graph representation and FM post-processing. <ref type="bibr">Vannelli and Rowan [185]</ref> also applied the algorithm to two variant constructions of the adjacency matrix, 1°Combining the two equations yields Uk is very close to an optimal solution. Consequently, the authors of [154] first relax the integer constraints of the assignment matrix X to find an X close to Uk, then uses the transportation formulation to find the closest legal solution to X. They also perturb the diagonal entries of A before computing the eigenvectors, leading to tighter lower bounds than those given by Donath and Hoffman <ref type="bibr" target="#b59">[59]</ref>. Further, they extend the average case bisection bound of Boppana [27-1 to k &gt; 2 (see <ref type="bibr">[133]</ref> for a more complete discussion of spectrally derived lower bounds).</p><formula xml:id="formula_14">k k ~ k 2F(P k) &gt;1 -IIQtl 2-~m2+ ~ (2, + m,)2 + ;~2= -IIQII= +2 ~2,m,+<label>2 2.</label></formula><p>Chan et al. <ref type="bibr" target="#b36">[37]</ref> extend the Donath and Hoffman bound F(P k) &gt;~ y k:12imi to Scaled Cost, proving for this objective that F(P k) &gt;t y~k= 12i. They argue that since R is an approximation of Uk, an approximation for pR = RRT should be given by UkU~, i.e., the matrix having as its/jth entry the dot product of the ith row of Uk with thejth row of Uk. Viewing each module v~ as a vector in k-dimensional space with coordinates given by the ith row of Uk, the ijth entry of UkU[ is the angle or directional cosine between modules v~ and v~. <ref type="bibr">Chan et al. consider</ref> the directional cosine between two modules as a distance measure: the larger the directional cosine, the more likely the two modules should be placed in the same cluster. A directional cosine of zero between vg and vj implies that the/jth entry in PR is zero (since PR should approximate UkUD, meaning that v~ and vj should be assigned to different clusters. The KP algorithm of Chan et al. <ref type="bibr" target="#b36">[37]</ref> finds an orthogonal basis with k "prototype vectors" and constructs k clusters by assigning each module to its closest prototype according to the directional cosines measure. <ref type="bibr">Chan et al. [38]</ref> have also adapted their KP approach to FPGA partitioning by assigning each module to its closest prototype while observing size and I/O constraints on the clusters (FPGA devices).</p><p>We believe that the Barnes and KP approaches may have limited performance potential. Both approaches assume that Uk can be perturbed to give a legal ratioed assignment matrix R: Barnes chooses R to minimize the error p[ Uk-R[[ 2, and Chan et al. explicitly assume that R is an approximation of Uk. Thus, each R~ representing cluster C~ should be close to pg in the ideal case, but for real VLSI circuits R~ and p~ will generally be quite different. A given eigenvector will typically have a few outliers -modules with large coordinates -but a large majority of modules will have coordinates very close to zero; these coordinates would have to be perturbed considerably to achieve a valid ratioed assignment matrix. To see this, consider the coordinates for P2 (on the x-axis) and ~u3 (on the y-axis) for the Primaryl and Test05 benchmarks shown in Fig. <ref type="figure">9</ref>. Exactly 603 of the 833 modules for Primaryl have zero (to three decimal places) as their y-coordinate, and these modules are strongly clustered together. The embedding actually admits a very natural 3-way partitioning with sizes 681, 76, 76 but does not reveal a natural bisection. This phenomenon is even more apparent for Test05, as 12 outliers with x-coordinate larger than 0.1 force a strong agglomeration of points around zero, again leading to a difficult clustering task. We believe that even when minimized, the error 1[ Uk --R ]l 2 will usually be large, i.e., each R~ will not be close to its corresponding ~u~. This potentially large error may be magnified by squaring Uk: Chan et al. assume that pR = RR T is an approximation of UkU[ (but their KP algorithm does not actually square Uk, since computing all n 2 entries of UkU[ would be too expensive).</p><p>Hall [89] also proposed a method for multi-way partitioning using the same eigenvector embedding as the authors of <ref type="bibr" target="#b36">[37]</ref>. Since P2 gives the optimal 1-dimensional placement with squared wirelength, Hall reasoned that the other low-cost eigenvector placements could also be We believe that neither directional cosines nor Euclidean distance is the proper similarity (or dissimiliarity) measure between spectrally embedded modules• The theoretical results described in the next two subsections indicate that the "proper" spectral embedding should be scaled by the eigenvalues, and that the module similarity measure should be a "vector sum".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Probes in multi-dimensional vector space</head><p>We have noted that a potential difficulty with the approaches of [18, 37], namely, that each cluster is associated with a single eigenvector, but the cluster's indicator vector may be far from its eigenvector. Blanks <ref type="bibr" target="#b23">[24]</ref> also shared this intuition and illustrated (for placement, although it also holds for bipartitioning) that the closest legal solution to the eigenvector solution ~2, i.e., the sol ut i onx, , ~ o~ Opt i mum Cl osest l egal part i t i oni ng part i t i oni ng Fig. <ref type="figure" target="#fig_30">10</ref>. Abstraction of Hall's eigenvector approach as shown in <ref type="bibr" target="#b23">[24]</ref>.</p><p>indicator vector that maximally projects onto/u2, will generally not be optimum. Fig. <ref type="figure" target="#fig_30">10</ref> gives an abstract visualization of this concept. The solution space consists of all n-dimensional vectors x, the plane represents the subspace of all legal indicator vectors, and the optimum non-discrete solution for min-cut partitioning is given by the point x =/~2. The ellipsoids correspond to constant cost degradation, i.e., the smallest ellipsoid is the set of solutions with cost 22 + e, the second smallest ellipsoid contains solutions with cost 22 + 2e, etc. Blanks proved that these cost surfaces are indeed ellipsoidal. The optimum legal bipartitioning solution B is the intersection of the subspace of legal solutions with the smallest possible ellipsoid (such that this intersection is nonempty). The indicator vector x that maximally projects onto/J2, labeled with A in the figure, certainly does not have to be identical to B.</p><p>An alternative approach to finding the closest legal solution might be to combine several high-quality eigenvector solutions into a new solution that is closer to the subspace of legal solutions. The same figure shows a combined solution whose closest legal solution, C, is closer to optimal than A. Note that all linear combinations of the first d eigenvector solutions lie in the d-dimensional subspace spanned by these eigenvectors. This observation is the genesis behind the probing approach of Frankle and Karp <ref type="bibr" target="#b67">[67,</ref><ref type="bibr" target="#b68">68]</ref>: they searched this entire subspace for a good solution rather than associating a solution with a single eigenvector.</p><p>Frankle and Karp <ref type="bibr" target="#b68">[68]</ref> developed the following probing technique for finding such non-discrete combined solutions in the multi-dimensional eigenspace. Since the n eigenvectors of Q form an orthogonal n-dimensional basis, any indicator vector can be expressed as a sum of projections onto each of the eigenvectors, i.e., x = Ej = 1 (XJ(X)IllJ where ~j(x) = x "</p><p>x pj. Substituting this value for x in Eq. (4.1) yields F(P 2) = ~ o~j(x)22j.</p><p>(4.5) j=l If the cluster sizes I Cll = m l and IC21 = m2 are fixed, then ~= l gj(x) 2 = m2 is a constant (since x is the indicator vector for C2). This observation, along with Eq. (4.5), implies that the goal is to find an P Fig. <ref type="figure" target="#fig_30">11</ref>. Illustration of the probing approach of <ref type="bibr" target="#b68">[68]</ref>.</p><p>indicator vector x that projects maximally onto the eigenvectors with small eigenvalues: the eigenvalue 2i is the coefficient for the ~(x) term; hence, when 2i is large cti(x) should be small, and vice versa. If the large eigenvalues are ignored and only the first d terms in the sum are considered, the problem becomes one of finding the indicator vector with maximal projection onto the subspace spanned by the first d eigenvectors. Frankle and Karp express equation ( <ref type="formula">9</ref>) as the following maximization problem:</p><p>Maximize:</p><formula xml:id="formula_15">Hm2-F(P 2) = H ~ (Xj(X) 2 --~ O~j(X)2~,j : ~ (~j(X)2(H-,~.j) (4.6) j=l j=l j=l</formula><p>for some H &gt;~ 2,. Let Vn denote the n x d scaled eigenvector matrix with column j equal to pjw/-H -~,j. The right-hand side of Eq. (4.6) can now be expressed as [IxVV, I[. Given any n-vectory, i.e., a probe direction, Frankle and Karp show that the legal indicator vector x that maximizes xXV, y can be found efficiently by sorting and splitting the entries of V,y, as in spectral bisection.</p><p>Here, the vectory serves as the combined solution point in Fig. <ref type="figure" target="#fig_30">10</ref>. Fig. <ref type="figure" target="#fig_30">11</ref> illustrates this approach for two dimensions. The vector xTVz that projects maximally onto y gives the optimal solution vector for probe direction y.</p><p>Frankle and Karp heuristically search over various d-dimensional vector probes y, and find for each y the indicator vector x that maximizes xTVdy. Both randomized and iterated probing techniques are used to construct candidate probe vectors. By restricting y to d dimensions, only vectors-that lie in the subspace spanned by the first d eigenvectors are considered. We believe that this is a sound strategy, given the intuition of Eq. (4.5) that a good solution x should strongly project onto the first few eigenvectors. The problem reduces to finding a probe directiony that is as close as possible to a legal solution. Note that for d = 2, any probe vector will return the solution obtained by sorting and splitting the entries of/~2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Vector partitioning</head><p>The probe approach can also be viewed in another way [6]: for each module vi, observe that the d-dimensional vector corresponding to the ith row of Va is actually the indicator vector for the single-module cluster {vi} after projecting onto the subspace spanned by the first d eigenvectors, and scaling thejth coordinate by x/H -),~, 1 ~&lt;j ~&lt; d. Ifx is the 0-1 indicator vector for {vi}, then Arun and Rao <ref type="bibr" target="#b11">[12]</ref> also noted this vector partitioning formulation, but called it a "geometric clustering" problem. Their derivation is somewhat different, relying on the factorability of the adjacency matrix, i.e., ifA can be expressed as A = CC T where C is an n × d matrix, then A only has rank d. This implies that the columns of C span the same space as the columns (or rows) of A, hence the columns of C form a basis for this space. The indicator vector for {vl} becomes the ith row of C when expressed in this basis. Viewing the rows of C as points in d-space centered at the origin, the bipartitioning problem reduces to finding a subset of points whose center is furthest from the origin.</p><p>To find an appropriate matrix C, the authors of <ref type="bibr" target="#b11">[12]</ref> invoke a theorem from principal components analysis <ref type="bibr">[152]</ref>, that the best rank-d approximation to A with respect to both the spectral and Frobenius norms is UdAaU~. (Following <ref type="bibr" target="#b11">[12]</ref>, we use the eigenvectors of A so the columns of Ud are ~Ul, ...,/In with eigenvalues 21 /&gt; "'" /&gt; 2d.) This result implies that C = UdA 1/2 best approximates A = CC r, and thus C is "equivalent" to Vd, meaning the reductions of <ref type="bibr" target="#b68">[68]</ref> and <ref type="bibr" target="#b11">[12]</ref> are also equivalent. Hence, Arun and Rao choose C = UdA 1/2. Like <ref type="bibr">Barnes [18]</ref>, they solve the 1-dimensional geometric clustering problem by sorting the entries of ~1; they solve the 2-dimensional problem by testing all possible hyperplanes which divide the set of points into two clusters. In <ref type="bibr" target="#b12">[13]</ref>, they extend their 2-dimensional hyperplane algorithm to d dimensions, finding the optimal vector partitioning in O(n d~d+3)/2) time. Frankle <ref type="bibr" target="#b67">[67]</ref> has shown how to exhaustively search a d-dimensional vector space with probes, finding the optimal solution in O(n d-1) time.</p><p>The min-cut bipartitioning reductions of <ref type="bibr" target="#b68">[68]</ref> and <ref type="bibr" target="#b11">[12]</ref> can be extended to many multi-way formulations, including minimum Scaled Cost, minimum total net cut, or maximum cluster I/O (IE(Ch)] in FPGA partitioning), via a vector partitionin9 formulation <ref type="bibr">[6]</ref>. Let S be the set of n vectors {Yl,Y2, ... ,Yn} which form the n rows of Vd. <ref type="bibr">Alpert and Yao [6]</ref> showed that min-cut k-way partitioning reduces to the following vector partitionin9 problem: find k mutually disjoint subsets of vectors {$1, $2, ... ,Sk), with $1 wS2w "" WSk = S, so as to maximize If d = n and {S~, $2 .... , Sk} is the optimum vector partitioning solution, then {C1, C2, ..., Ck} is the optimum vector partitioning solution where Ch = {vi]y~ E Sh}.</p><p>Alpert and Yao propose the greedy MELO algorithm, which does not explicitly construct a vector partitioning, but instead generates a 1-dimensional ordering that is split into a clustering using dynamic programming (see Section 4.5). Given a d-dimensional vector partitioning instance, MELO starts with a set of vectors $1 --0 and iteratively adds to $1 the vector y~ e S -$1 that maximizes Yi -t-y~Sl yj "</p><p>Ifyi is thejth vector added to S~ then vi is thejth module in the linear ordering. MELO can also be interpreted strictly in terms of Eq. (4.6). Recall that the indicator vector x should maximally project onto the d eigenvectors with smallest eigenvalues. Starting with x = 0, MELO iteratively sets xi = 1, for that i which maximizes y~= lO~j(x)2(H --,~j), until x = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.">From orderings to partitionings</head><p>We have seen that spectral methods can be used to construct various geometric representations of the netlist, including multi-dimensional embeddings and 1-dimensional orderings. The latter type of representation has led to several intuitive and efficient heuristics (e.g., we have discussed constructing a bipartitioning from a 1-dimensional placement by sorting coordinates to obtain a linear ordering of modules, and then splitting this ordering into two clusters), and has received increased attention in recent years. We conclude this section by surveying various methods which construct partitionings from 1-dimensional orderings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1.">The net-based approach</head><p>If a vertex ordering is constructed for the intersection graph or dual graph, then we will actually obtain an ordering of signal nets, rather than of modules. An approach which then splits the net ordering will require an additional step to construct a module partitioning from the resulting net partitioning. In other words, if we are given a bipartition of signal nets, some modules will belong only to nets on one side of the partition and can be unambiguously assigned to that side, but other modules will be shared by nets on both sides of the partition (cf. terms such as "boundary graph" <ref type="bibr">[112,</ref><ref type="bibr">85]</ref> or "module contention" <ref type="bibr" target="#b49">[49]</ref>). We must therefore seek a completion of the net partition which assigns each shared module to a single cluster, such that the partition cost is minimized. This general net-based partitioning approach (i.e., first obtain a net partition, then complete the net partition into a module partition) was established in <ref type="bibr">[85]</ref> and extended in, e.g., <ref type="bibr" target="#b48">[48]</ref> and <ref type="bibr" target="#b49">[49]</ref> (see Section 5.2).</p><p>If the nets are partitioned into two sets N1 and N2, a module bipartitioning p2 = {C1, C2} can be derived by having the nets "vote" to determine each module assignment. The IG-Vote algorithm of <ref type="bibr">Hagen and Kahng [85]</ref> begins with all nets in Na and all modules in Ca. Iteratively, a net is moved from N~ to N2 according to the net ordering. After each net is moved, if any incident module in Ca has stronger connections to nets in N2 than to nets in N1, then this module is moved to C2. This process generates at most n -1 module bipartitionings; the one with smallest ratio cut is chosen. The variant approach of <ref type="bibr" target="#b48">[48]</ref> also considers each split of the net ordering, and for each completes the module bipartitioning by using a matching-based approach (see Section 5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2.">Dynamic programming for restricted partitioning</head><p>To split a linear ordering into more than two clusters, Alpert and <ref type="bibr">Kahng [5]</ref> proposed the DP-RP ("dynamic programming for restricted partitioning") algorithm, which optimally solves the restricted formulation which requires each cluster of pk to be contiguous in the linear ordering.</p><p>Notice that there are at most n z contiguous subsets of the ordering, and these represent every possible cluster that can belong to pk. DP-RP begins by computing the costs for each of these possible clusters. These correspond to the optimal 1-way partitioning solutions for all contiguous subsets of the ordering. Dynamic programming is then applied to find all the optimal 2-way solutions, then all the optimal 3-way solutions, etc. DP-RP is optimal for any partitioning objective that is a monotone function of some intercluster cost metric. Such objectives include standard k-Way Min-Cut, Scaled Cost, Absorption, and the DS metric. Although the complexity of DP-RP depends on the objective function, O(nU + kn(U -L)) implementations exist for all of these objectives except DS, with L and U denoting lower and upper bounds on cluster size.</p><p>The DP-RP result highlights the problem of finding 1-dimensional netlist representations which will lead to good multi-way partitioning solutions. <ref type="bibr">Alpert and Yao [6]</ref> have applied DP-RP to their (MELO) orderings (see also the discussions of <ref type="bibr">[4, 100, 10l]</ref> in Section 6). Note that Frankle and Karp's <ref type="bibr" target="#b68">[68]</ref> probe technique can be used to yield linear orderings as well, simply by sorting the entries of Vdy for a given probe direction y; we believe that applying DP-RP to these orderings is a promising direction for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.3.">Placement-based approaches</head><p>Another method which constructs a bipartition from a linear ordering is due to <ref type="bibr">Riess et al. [156]</ref>. The premise of their PARABOLI approach is that the squared wirelength objective is not as useful as a linear wirelength objective for 1-dimensional placement; this insight derives from experiments with the GORDIAN placement package <ref type="bibr">[120]</ref>. The authors of <ref type="bibr">[156]</ref> begin with the 1-dimensional placement induced by P2; the ten modules with largest coordinates are fixed at location 1.0, and the ten modules with smallest coordinates are fixed at location 0.0. The remaining "free" modules are constrained to have center of gravity (i.e., mean coordinate) at 0.5; quadratic programming techniques are used to reposition these modules to minimize linear wirelength (see Section 5.3.4). The 5% of modules with largest coordinates are assigned center of gravity 0.95, and the 5% with smallest coordinates are assigned center of gravity 0.05. The free modules are again replaced, and the next 5% at the extreme right (left) are assigned center of gravity 0.90 (0.10). Note that throughout this process, only the original 20 extreme modules are fixed, with all others free to move but restricted by their centers of gravity. This process is repeated ten times (e.g., the next iteration uses centers of gravity 0.85 and 0.15), inducing ten distinct linear orderings. Riess et al. choose the best ratio cut bipartitioning among all possible splits of all ten orderings. The intuition behind PARABOLI is that after the first iteration, the leftmost and rightmost modules clearly belong at opposite ends of the linear ordering, but the proper locations for the middle modules remain unclear. Iteratively constraining only small fractions of the modules to the extremes of the linear ordering makes placing of the inner modules easier, while retaining flexibility. <ref type="bibr">Riess and Schoene [158]</ref> have extended this approach to a layout-driven formulation in MCM partitioning, optimizing a given multi-chip layout alternately in vertical and horizontal directions.</p><p>We believe the success of the PARABOLI approach may have just as much to do with its module assignment technique as its linear wirelength objective. Thus, an interesting experiment would be to evaluate the quality of linear orderings derived using the same methodology, but with a quadratic objective. The successive over-relaxation placement approach of <ref type="bibr">Tsay and Kuh [183]</ref> can also be used for this type of quadratic optimization with fixed module locations (however, centers of gravity cannot be used); see Section 5.3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.J. ,41pert, A.B. Kahng / INTEGRATION, the VLS1Journal 19 (1995) 1-81</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Combinatorial formulations</head><p>The engineering workstations in a typical modern design environment have processing capabilities exceeding those of mainframes from only a few years ago, thereby permitting previously infeasible approaches to be applied to CAD optimizations. For example, spectral computations proposed in the early 1970s have become viable for netlist partitioning, and the quadratic programming iteration behind GORDIAN-type cell placement programs [120] now drives many of the latest industry placement packages. Many of these "rediscovered" combinatorial optimizations are well-studied and have either polynomial-time optimal solutions (e.g., network flow) or highly developed heuristic tools (e.g., Espresso II for set covering). In addition, combinatorial approaches can capture complex formulations that incorporate timing constraints, preassignment of modules to clusters, or multiple cost functions (e.g., the authors of <ref type="bibr">[174]</ref> force all paths to satisfy delay constraints within a quadratic boolean program). Quite possibly, the next frontier of optimization strategies for CAD applications will involve large-scale mathematical programming instances, including mixed integer-linear programs that require branch-and-bound search.ll This trend toward combinatorial algorithmic approaches is typified by the works that we now discuss.</p><p>The approaches in this section share the common theme of the transformation of a partitioning problem into a different combinatorial formulation. Each formulation is of independent interest and typically has a long history and a large literature outside the scope of VLSI partitioning. Our discussion begins with graph labeling techniques for solving the Min-Delay Clustering problem. We then show how many formulations can be addressed in the context of network flows. Next, we discuss mathematical programming formulations such as quadratic and linear programming. These approaches have also been applied to one-dimensional placement; we discuss such works along with their potential applications to partitioning. Finally, we review fuzzy partitioning techniques and a set-covering approach to FPGA partitioning. <ref type="bibr">Lawler et al. [130]</ref> first considered the Min-Delay Clustering problem (see Section 2.4) for combinational boolean networks (DAGs) with no module delay, i.e., 6(vi) = 0 Vvi ~ V. We call this the unit-delay clustering problem. This formulation assumes that module and intracluster delays (i.e., delays between modules in the same cluster) will be negligible compared to intercluster delay that results from placing clusters onto different chips. <ref type="bibr">Lawler et al.</ref> propose the following labeling scheme to derive a clustering in which all clusters C must satisfy w(C) &lt;&lt;, U.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Min-Delay Clustering by graph labeling</head><p>Each module vi is associated with a label n(i), i.e., n: <ref type="bibr">[1.</ref>. n] ~ [0.</p><p>. n]. Module vi is a predecessor of vj if there is a directed path from v~ to vj, and vi is an r-predecessor of vj if in addition n(i) = r. The set of all r-predecessors of vj is denoted by pj(r); the total weight of modules in this set is • For all primary inputs vi (no incoming edges), set ~z(i) = 0.</p><p>11A primal-dual approach with column generation has already been used to solve the linear programming relaxation of large integer programs in the context of global routing <ref type="bibr" target="#b35">[36]</ref>; however, only small integer programs have been essayed in CAD, typically for high-level synthesis (see, e.g., <ref type="bibr" target="#b71">[71]</ref>).</p><p>• Find any unlabeled v~, all of whose predecessors are labeled, and let r be the largest label of all predecessors of vi. If w(vi) + w(p~(r)) &lt;~ U, then set 7t(i) --r, otherwise set 7t(i) --r + 1.</p><p>The second step is repeated until all modules are labeled; two modules vi and vj with the same label re(i) are placed into the same cluster if every module on the path from vi to vj also has label n(i). If the netlist is a tree with a single primary output (a minor modification handles a single primary input), then this labeling scheme optimally solves the unit-delay clustering problem. If the netlist is a tree with multiple primary inputs and outputs, then the tree can be separated into a set of rooted subtrees, i.e., each subtree has a single primary input or primary output. The labeling scheme and clustering algorithm can be applied to each subtree, and merging the resulting clusterings gives an optimal unit-delay clustering solution.</p><p>If the netlist is not a tree, this labeling scheme can still derive the optimal solution if module replication is permitted. For this case, Lawler et al. construct a cluster C = {v~} wpi(rc(i)) for each vi such that all of v~'s successors (modules vj such that there is vg-vj path) have higher labels than v~. This solution may assign some modules to more than one cluster, i.e., replicating these modules. In Fig. <ref type="figure" target="#fig_24">12</ref>, we reproduce (a) an example from <ref type="bibr">[130]</ref>, and (b) their min-delay clustering solution (with replication) assuming unit module weights and U = 5. The labeling scheme assigns label 0 to the modules in the 6 leftmost clusters, label 1 to the modules in the 4 middle clusters, and label 2 to module 26 in the rightmost cluster. The modules with successors that all have higher labels are <ref type="bibr">5, 6, 10, 11, 12, 14, 17, 21, 24, 25 and 26.</ref> As an example of replication, note that the labeling scheme assigns module 8 to two clusters, since it is a 1-predecessor of modules 14 and 24; hence, the edges from 5 to 8 and from 6 to 8 are also replicated. <ref type="bibr">Murgai et al. [140]</ref> were the first to address the variable-delay clustering problem (with module delays 6(vi) -¢ 0). Their generalization of the above labeling scheme retained optimality only under certain conditions. <ref type="bibr">Rajaraman and Wong [151]</ref> later solved this problem optimally using a different labeling scheme. Consider, for a given vi, the subgraph N(i) induced by vi and all of its predecessors. The delay from any vj ~ PI to v~ in a given clustering solution is at least the delay from vj to Vg in the optimal clustering of N(i). This observation allows <ref type="bibr">[151]</ref> to iteratively build optimal clusterings over N(i) for each vi ~ V. Each vi~ PI is initially assigned the label n(i) = 6(i), and each v~¢PI will have a label no greater than the maximum delay of any path from a primary input to vg. As in <ref type="bibr">[130]</ref>, any module whose predecessors are all labeled may be labeled next. When labeling vi, a set cluster(i) ~_ N(i) is constructed which essentially consists of the predecessors of v~ that have the highest "label plus delay factor" values. Rajaraman and Wong show that there exists an optimal partitioning of N(i) with cluster(i) as a cluster. The label for v~ is the maximum delay over all paths from vj ~ PI to vi assuming that cluster(i) exists, i.e., a delay of 1 is added to any path containing an edge from a module in N(i) -cluster(i) to a module in cluster(i). The partitioning solution pk will be a subset of {cluster(i) p vi ~ V}. Initially, pk =_ • and cluster(i) is added to pk for every vi~ PO. Next, the following rule is iteratively applied: for every vi not contained in any cluster of pk, such that there exists some v~ with (v~, v j) ~ E and vj ~ Ch for some Ch ~ pk, add cluster(i) to pk. Like <ref type="bibr">[130]</ref>, this construction will also replicate modules.</p><p>A variant of the min-delay clustering problem was studied by <ref type="bibr">Cong and Ding [45]</ref> for technology mapping in lookup table-based FPGA designs. They remove the area constraints W( <ref type="formula">Ch</ref> "~ -"~- constraints allow each cluster to be mapped to a configurable logic block, i.e., a K-input lookup table that can implement any boolean function of K variables. To address this formulation, Cong and Ding proposed a labeling and flow-based heuristic. Subsequently, <ref type="bibr">Yang and Wong [191]</ref> proved that the same approach is not only optimal for these pin constraints, but also optimal for the more general pin constraints IIn(Ch)uOut(Ch)l ~&lt; K + 1 under the unit-delay model. The authors of <ref type="bibr">[191]</ref> combine the approaches of <ref type="bibr" target="#b44">[45]</ref> and <ref type="bibr">[-151</ref>] into a heuristic for min-delay clustering under size and pin constraints W(Ch) &lt;&lt;. U, IE(Ch)I ~&lt; K + 1. The algorithm achieves optimal delay under either the pin constraint alone (as does <ref type="bibr" target="#b44">[45]</ref>) or the size constraint alone (as does [,151]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Network flows</head><p>New formulations such as replication and the increased usage of a directed netlist representation have recently made flow-based approaches more popular. We now explore a variety of partitioning formulations, and describe how network flows can be used to solve them (see <ref type="bibr" target="#b42">[43]</ref> for many other examples).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1.">Preliminaries</head><p>We first review several concepts from the theory of network flows <ref type="bibr" target="#b66">[66]</ref>. A flow network G = (V, E) is a directed graph in which each edge (v, w) ~ E has a positive capacity c(v, w) &gt; 0; edges that are not present in the network implicitly have capacity zero. There are two distinguished nodes in G, a source s ~ V and a sink t e V. Aflow in G is a real-valued function f: E ~ 9~ + that satisfies the following properties:</p><formula xml:id="formula_16">1. Capacity constraints: For all (v, w)s E, f(v, w)&lt;~ c(v, w); e is said to be saturated if f(v, w) : c(v, w). 2. Skew symmetry: For all v, w ~ V, f (v, w) = -f (w, v). 3. Flow conservation: For all v e V -{s, t}, Z,~v f(U, v) = Zw~v f (V, w).</formula><p>The value ofa flowfis given by Ifl = Y,~,~vf <ref type="bibr">(s, v)</ref>. For a given network, the network flow problem is to find a flow of maximum value. An s-t cut is a bipartitioning {C1, C2} of G with s s C~, t e C2, and cutsize is given by F({CI, C2}) = <ref type="bibr">Z,~cl,v~c~ c(u, v)</ref>. A well-known result from linear programming duality is the max-fow min-cut theorem <ref type="bibr" target="#b66">[66]</ref>:</p><p>Max-Flow Min-Cut Theorem. Given a flow network G, the value of the maximum s-t flow is equal to minimum cost of any s-t cut. Moreover, all edges (v, w) with v ~ C1, w ~ Cz are saturated jbr some minimum s-t {C~, C2}.</p><p>The min-cost flow problem associates a cost (denoted cost(v, w)) with each (v, w)e E, and the problem becomes that of finding a flowfwith a prescribed value [fl = z such that the total flow cost y~.w)~e f (v, w) • cost(v, w) is minimized.</p><p>Another formulation is the uniform multicommodityflow (UMCF) problem, which has been used to bipartition undirected edge-weighted graphs <ref type="bibr">[138,</ref><ref type="bibr">133]</ref>. For every v, w ~ V, a special commodity f,,w is assigned, and we require exactly z units of this commodity to flow from v to w. The objective is to find a feasible flow with maximum z (s and t are unspecified). The total flow of all commodities along any given edge cannot exceed the capacity of the edge. Given a solution to the UMCF problem and a bipartitioning {C1, C2}, the flow from Cj to C2 is given by 2~c,,w~c2 z = z. ICaI" JC2[. The free capacity of {C~, Cz} (i.e., the total unused capacities on edges from C1 to C2) is the cutsize minus the flow from C1 to Cz. Using the fact that the free capacity is nonnegative, <ref type="bibr">Matula and Shahrokhi [138]</ref> establish the lower bound z ~&lt; min F({CI, C2})</p><p>ICll <ref type="bibr">'[c21 '</ref> i.e., the minimum ratio cut of G is an upper bound for z. <ref type="bibr">Leighton and Rao [132]</ref> showed this bound is relatively tight by constructing a bipartitioning with ratio cut cost of O(z log n), where z is the optimal flow for this UMCF formulation. An approximation algorithm for multi-way partitioning [131] applies Leighton and Rao's algorithm recursively. A review of recent advances in multicommodity flows is given in <ref type="bibr">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.">The Min-Cut Replication Problem</head><p>Assume that we are given a directed graph G(V,E) and a k-way partitioning pk= {CI, C2 ..... Ck} without replication, and let F be the multi-way rain-cut objective. The Min-Cut Replication Problem of <ref type="bibr">Hwang and El Gamal [103]</ref> seeks a collection of subsets of modules {C* I C*c_Ci, 1 &lt;~ i,j &lt;&lt;, k} that minimizes F(P k*) , where pk. is the partitioning that results when each subset C* is replicated from Ci to C s. (Hwang and El Gamal implicitly assume each Ci contains a subset Ii of primary inputs that cannot be replicated.) We now show how to solve this formulation optimally for k <ref type="bibr">= 2 [103]</ref>; the problem can be solved optimally for k &gt; 2 by solving k independent 2-way replication instances <ref type="bibr">[104]</ref>.</p><p>Given a bipartitioning p2 {C1, C2} , we seek a subset C* * c = = C12 --C1 -I1 such that the number of edges from modules in C1 -11 -C* to modules in C*wC2 is minimized. The new bipartitioning p2, contains clusters C~ and C2 w C*, so that edges from C* to C2 will not be cut (see Section 2.6 for replication rules). Edges from C2 to C~ and from 11 to C2 will still be cut in the new solution, and can be ignored; hence, only edges from C1-11-C* to C*~C2 need to be considered. Hwang and E1 Gamal construct the following flow network G'(V',E') with V' = {s, t}w V and E' = (E -Ezx)wE's~E't where <ref type="bibr">(s,</ref><ref type="bibr">v)[v~I1}. • E;</ref><ref type="bibr">= {(v,</ref><ref type="bibr">t) [ v~C2 and 3 w~Cl,</ref><ref type="bibr">(v,</ref><ref type="bibr">w)</ref> ~E}.</p><formula xml:id="formula_17">• E's = {</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• E21 = {(v, w) I v C2}.</head><p>The edge capacities are c(e) = oo Ve ~ E'sw E~, and c(e) = 1 Ve ~ E -E21; this ensures that only edges in E -E21 will be part of the min-cut. Applying the Max-Flow Min-Cut Theorem to G' yields the optimum min-cut bipartitioning p,2 ___ {C'1, C~} with {s} w 11 ~ C] and t e C~. Since no edges in E~ are cut, C2 ---C~, and C* = C~ -C2 is the optimum set of modules to replicate from C1. Optimality follows directly from the Max-Flow Min-Cut Theorem.</p><p>In [104], Hwang and El Gamal showed how to modify their flow network to solve min-cut replication for hypergraphs with signal information. While their formulation requires an input partitioning solution, it could be applied during the construction of a multi-way partitioning, and seems useful for pin-constrained (FPGA) formulations. For example, one might apply the algorithm to the bipartitioning { V -C, C} when a cluster C is close to satisfying the pin constraint IE(C)I ~&lt; 10. As a heuristic, <ref type="bibr">Hwang and E1 Gamal [104]</ref> integrated their min-cut replication solution with a modified form of FM. <ref type="bibr">Yang and Wong [192]</ref> slightly enhanced Hwang and E1 Gamal's approach to solve the min-cut replication problem while minimizing IC*I as a secondary objective, breaking ties so that a min-cut with "minimum size" is found. Recently, <ref type="bibr">Liu et al. [135]</ref> appear to have eliminated the need for a pre-existing bipartitioning by solving the general replication problem: find clusters Ca, C2, and a replication set C* _ C1 such that the number of cuts of p2 = {CaL)C, ' C2wC*} is minimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3.">Max-Flow Min-Cut approaches</head><p>The approaches in this section are linked by their use of the Max-Flow Min-Cut Theorem in finding one or more minimum s-t cuts to construct a partitioning solution.</p><p>To find the global min-cut bipartitioning, n-1 max-flow computations suffice via the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E(C').</head><p>This process continues until every node in the tree corresponds to a singleton cluster, and the global min-cut is determined by the edge in the tree with lowest cost. Hao and Orlin [92] also showed how to find a min-cut bipartitioning using O(n) flow computations, but with total time equivalent to that of just one flow computation. They compute a sequence of S-t' cuts where S is a set condensed into a single node and S = {s} initially. After an S-t' cut is computed, t' is added to S, a new t' is chosen and the process repeated until S = V. The lowest-cost cut observed in this sequence gives the optimal min-cut bipartitioning. <ref type="bibr">Hu and Moerder [99]</ref> showed how the Max-Flow Min-Cut duality can also be used to find a Min-Cut Bipartitioning in a hypergraph. For each net e, an extra dummy module is added to the graph, and a star is formed connecting the dummy module to each of the modules in e (see Fig. <ref type="figure" target="#fig_30">13(a)</ref>). The dummy module has unit capacity, and the other modules have infinite capacity. Hence, any minimum vertex separator (cutset of modules) of this network will be a subset of the dummy modules which will correspond to a subset of E. The minimum vertex separator can be found by maximum-flow after transforming this node-capacitated flow network into an edgecapacitated network G'(V', E') using a technique due to <ref type="bibr">Lawler [129]</ref>:</p><p>• For every v ~ V, add va and/2 2 to V <ref type="bibr">' and add (v~, v2</ref>) to E'. Assign c(va,/)2) to be the node capacity of/).</p><p>• For every (v, w) ~ E, add the edge (/)2, W1) to E'.</p><p>If Hu and Moerder's star representation in Fig. <ref type="figure" target="#fig_30">13(a</ref>) is transformed into a directed graph by replacing each undirected edge (v, w) with directed edges (v, w) and (w, v) and applying the above construction, the graph in Fig. <ref type="figure" target="#fig_30">13(b</ref>) is the result. However, applying the first rule of Lawler's transformation to modules with infinite capacity is unnecessary. Hence, vl and v2, ul and u2, and wl and w2 can be collapsed into u, v, and w, respectively, yielding the flow network in Fig. <ref type="figure" target="#fig_30">13(c</ref>). Hu and Moerder also show how to construct a modified Gomory-Hu cut tree to solve min-cut hypergraph bipartitioning with n -1 flow computations. <ref type="bibr">Vannelli and Hadley [184]</ref> also discuss hypergraph bipartitioning based on Gomory-Hu cut trees. <ref type="bibr">Saran and Vazarani [166]</ref> use Gomory-Hu cut trees as the basis for a k-way partitioning heuristic for weighted undirected graphs with no cluster size constraints. They sort the cuts gl, 92, ... ,gn-1 on the Gomory-Hu cut tree by increasing weight, and find the minimum i such that g~ Ugzu "" ugi divides the graph into k components. This solution is guaranteed to yield a cutset within a factor of 2 -2/k of optimal and uses n -1 flow computations. The authors of [166] also proposed an alternative method which hierarchically splits the cluster which has the smallest rain-cut; hence, a Gomory-Hu cut must be computed for each cluster. This approach also achieves a performance ratio of 2 -2/k but requires O(kn) flow computations. Neither heuristic uniformly dominates the other.</p><p>While a max-flow computation is guaranteed to return a min-cut, the resulting cluster sizes may be very unbalanced. Consequently, many works propose contracting large subsets of modules to enforce balance constraints, e.g., <ref type="bibr">Bui et al. [29]</ref> propose bisecting d-regular graphs by contracting modules in the neighborhoods of s and t before computing an s-t cut. The neighborhood of a module v in a d-regular graph with n modules is defined to be the set of all modules within graph distance 1og~d-1)(~/n --2) of v. Bui et al. compute a minimum s-t cut in the contracted graph for every possible choice of s and t, then combine the cuts to form a bisection. In bipartitioning a DAG subject to cluster size constraints, <ref type="bibr">Iman et al. [107]</ref> similarly use flow computations to find a minimum s-t cut and then, if size constraints are violated, contract the smaller cluster C into a single module with weight w(C). To force a different rain-cut in the next iteration, the capacity of each edge in the min-cut is increased by a factor of 1 + e in the flow network. <ref type="bibr">Yang and Wong [190]</ref> apply a similar scheme, along with the flow construction in Fig. <ref type="figure" target="#fig_30">13(c</ref>), for hypergraph bipartitioning with size constraints. However, instead of increasing capacities of edges in the cut, they pick an additional module v from the larger cluster and contract it with the smaller cluster C. This approach may be more likely to find the true min-cut (since it does not modify edge weights), and it also bounds the number of flow computations. Furthermore, the approach takes only O(nm) time, i.e., the time of a single max-flow computation since the max-flow can be computed in the new contracted network using the residue network (the network of remaining flow capacities) from the previous flow computation.</p><p>Alternative optimal Min-Cut methods <ref type="bibr">Nagamochi and Ibaraki [141]</ref> recently gave a very efficient algorithm which finds the optimal min-cut bipartitioning without using any flow computation. They assume an undirected, unweighted graph G(V, E) as input, although multiple edges may exist between modules. The modules and edges are labeled using a maximum-adjacency scheme, i.e., the module with the most (a) G°(V, 0 E°), contract (v~,v s ) edges incident to the set of labeled vertices is ordered next. Initially, labels re(v) = 0 are assigned to each v e V. The algorithm iteratively chooses the module v with the largest label (ties are broken arbitrarily), and then visits each unvisited edge (v, w), incrementing rr(w) by one and then setting the label of (v, w) to re(w). The scheme requires O(IEI) time to label all modules and edges.</p><formula xml:id="formula_18">/.'5/ z 1Z lilt\\ 7!L!!\ (c) Gi(V, 2 El), contract (vs,v 6) (b) GX(V, I EX), contract (~ ,v 7 ) (d) G3(V,<label>3</label></formula><p>Let E(i) be the set of all edges with label i. Interestingly, the edges in E(i) form a forest that spans G(V,E-E(1)-E(2) .....</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E(i-1)). The algorithm begins with GO= G and computes</head><p>G' ÷ 1 from G' as follows: first label the modules and edges of G" using the above scheme, then pick a module v with deg(v) = degmin such that v is incident to an edge (v, w) with label degmin, and finally contract v with this w. The resulting graph with self-loops removed is G" ÷ 1, and the edges incident to v in G" form the cutset. The smallest cutset observed during the contractions from G O down to G"-1 is a global min-cut for G. The authors of [141] also extended this approach to graphs with real-valued edge weights.</p><p>As an example, consider the multi-graph in Fig. <ref type="figure" target="#fig_30">14(a</ref>). The modules are numbered according to a possible labeling order, and each edge e is marked with (i,j) where i is the label ofe andj indicates the order in which the edges were visited. Many modules v have deg(v) = degmin = 7, although only v7 and Vs are incident to an edge with label 7. Hence, v7 and v8 are contracted to yield the multi-graph in (b). The labeling is computed for this new graph (the order in which edges are labeled is not shown), and the contraction is repeated, yielding the graphs in (c) and (d). The graphs G4-G 6 are not shown. The smallest cutset observed during this process is of size 6 in (d); this corresponds to the optimal min-cut bipartitioning {{vl, v2, /)3, /)4}, {V5, /')6, /)7, US}}" A randomized min-cut approach was proposed by <ref type="bibr">Karger [114]</ref> : iteratively contract a random pair of incident modules into a cluster until only two clusters remain. Karger showed that O(n 2) executions of this algorithm will not only find an optimal bipartitioning with high probability, but will also find all optimal min-cut bipartitionings with high probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4.">Bipartite flow</head><p>A bipartite graph G'(V', E') has the property that V' can be partitioned into V1 and V2 such that every edge (u, v) ~ E' has u E V1 and v ~ V2. A bipartite flow network is a bipartite graph with additional source s and sink t added to V', and all edges in E' directed from nodes in Va to nodes in V2. In addition, directed edges (s, v) 'qv 6 V1 and (w, t) Vw e V2 are added to the flow network. We now discuss various partitioning formulations that can be solved with bipartite graphs and/or flow networks.</p><p>Huang and <ref type="bibr">Kahng [101]</ref> use bipartite flow (specifically, the "provisioning" formulation from <ref type="bibr">Lawler [129]</ref>) to find the maximum-density cluster (i.e., subhypergraph) C of a hypergraph H(V, E), where den(C) = ]{e ~ E le ~_ C}I/w(C) (see Section 2.4). The decision question "Does there exist a cluster with density larger than d?" can be answered using the bipartite graph G'(V', E') with Va = E and V2 = V and E <ref type="figure">',</ref><ref type="figure">E'</ref>) yields a min-cut bipartitioning p2 = {Ca, C2} with s ~ Ca, t ~ C2. The cluster C = Ca n V is guaranteed to have density at least d if such a cluster exists. If no cluster has density &gt;~ d, then the computation will return C = 0 (actually Ca = {s}).</p><formula xml:id="formula_19">' = {(e, v) [ v ~ e, v ~ V, e ~ E}. a2 A bipartite flow network is constructed by setting capacities c(e, v) = ~ V(e, v) ~ E', c(s, e) = 1 Ve ~ E, and c(v, t) = d " w(v) Vv ~ V. The maximum s-t flow in G'(V</formula><p>Consider the hypergraph in Fig. <ref type="figure" target="#fig_30">15</ref>(a) with 6 modules and 4 nets; its density flow network assuming unit module weights is shown in (b). When d = ¼, the min-cut bipartitioning for this network is <ref type="bibr">el,</ref><ref type="bibr">e2,</ref><ref type="bibr">e3,</ref><ref type="bibr">vbv2,</ref><ref type="bibr">v4,</ref><ref type="bibr">Vs},</ref><ref type="bibr">{e4,</ref><ref type="bibr">v3,</ref><ref type="bibr">v6,</ref><ref type="bibr">t}}</ref>  If[ = 4d + 1 = 4. Hence, C = {vl, v2, v4, vs}, and the density of C is guaranteed to be at least ¼. Since the density decision question can be answered efficiently, binary search on values of d can yield the max-density cluster using O(log n) flow computations. As a heuristic for finding a k-way partitioning which maximizes the sum of cluster densities, Huang and Kahng propose iteratively finding the max-density cluster and removing it from the hypergraph. A post-processing step constructs a linear ordering from the sequence of max-density clusters; DP-RP (see Section 4.5) is then applied.</p><p>Another problem that can be solved using bipartite flow is the completion (see Section 4.5) of a net bipartitioning {N1, N2} into a module bipartitioning {C1, C2} such that if all the nets incident to a given module belong to the same cluster N~, then the module must be assigned to C~. The problem may be viewed as assigning modules corresponding to edges in the bipartite "conflict subgraph", i.e., modules with incident nets in both NI and N2, to C~ and C2 to minimize the number of cut nets. This bipartite graph G'(V', E') has V1 = N1, V2 = N2 and (e, e')E E' if e ~ N1, e'6 N2 and ene' :/= 0. Each edge in E' corresponds to the set of modules erie'. Every net e ~ Ni will either have all of its modules in C~ (i.e., it will be uncut) or have some modules in both clusters (i.e., it will be cut). A maximum independent set (MIS) S_ V' for G'(V', E') has the property that if e E S and e' ~ S then (e, e')¢E' and [SI is maximal with respect to this property. Cong et al.</p><p>[48] construct an MISS using the algorithm of [93] and assign each contested module v to C~ if there exists an e ~ Sn N(v) with e ~ N~. As an example, consider the bipartitioning of the intersection graph in Fig. <ref type="figure" target="#fig_29">16</ref>(a) with N1 = {el, e2, e3, e4} and N2 = {es, e6, eT, es} and (b) its corresponding bipartite graph. The unique MIS for this graph is {ex, e2, e3, e4, e7, e8} so the modules incident to these nets can all be assigned to the same cluster, and at most nets e5 and e6 will be cut. (Note that this approach is not optimal: vertices of the intersection graph not in the MIS may yet end up being uncut, i.e., maximizing the size of the independent set of uncut hyperedges does not correspond to minimizing the number of cut hyperedges.) <ref type="bibr">Kamidoi et al. [113]</ref> earlier proposed a similar technique for hypergraph bisection. They first transform the netlist into a graph G(V, E) using the star net model of <ref type="bibr">[99]</ref>. They then divide the nodes of this graph into module nodes VM and net nodes VN. Breadth-first search is used to find an articulation set (i.e., a vertex separator) S~ VM that separates V into two clusters C1 and C2.</p><p>S forms the set of contested modules and induces the bipartite graph with vertices VI ---C1 n VN, V2 = C2c~ VN and edges (e, e') e E if ec~e'~S ~ O. <ref type="bibr">Kamidoi et al.</ref> then resolve module contentions by finding an independent set of net nodes in this graph, using a greedy approach that integrates cluster sizes.</p><p>Finally, the multi-way contention problem seeks to convert a k-way net partitioning  <ref type="bibr">MAX -pref(v, N~)</ref>, where MAX is a constant larger than any preference value, and the preference of v for N~ is given by</p><formula xml:id="formula_20">pref(v, Ni) = ~ (lel -Con(e)) 2</formula><p>leeN,Ivee} lel'Con(e)</p><p>(5.1)</p><p>Here Con(e) is the number of modules of e that are in contention, i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Con(e)</head><p>= I{v e e s.t. 3e', v e e', with e e Ni, e' e Nj, for some indices i vs j}l.</p><p>A min-cost flow of value I gal will saturate n edge-disjoint paths from s to vertices Ni, which implies that there is exactly one saturated edge of the form (v, Ni) for each v e V1. For each such edge, v is assigned to cluster Ci. This algorithm guarantees the optimal module assignment in terms of maximum sum of preferences. <ref type="bibr">et al. [193]</ref> proposed an algorithm based on the relationship between uniform multicommodity flow and min-cut partitioning. Yeh et al. construct a "flow network" by assigning c(e) = cost(e) --1 and f(e) = 0 for every net e. Two random modules in the network are chosen and the shortest path (i.e., path with lowest cost) p between them is computed where cost(p) = Y~e~p cost(e). A constant A &lt; 1 is added tof(e) for e~ich net e e p, and the cost for every e e p is reset to cost(e) = e ~yte~ for some constant ~. <ref type="bibr">(Yeh et al. choose d = 0.1 and ~ = 10.)</ref> Adjusting the cost penalizes paths through congested areas and forces alternative shortest paths. This random shortest path computation is repeated until all paths between the chosen pair of modules pass through at least one "saturated" net (i.e., with f(e) = 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5.">Shortest path clustering (SPC) and probabilistic methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Yeh</head><p>The set of saturated nets induces a multi-way partitioning in which v and w belong to the same cluster if there is a path of unsaturated nets between v and w. For each of these clusters C, theflux IE(C)I/w(C) is computed and the clusters are sorted based on their flux value. <ref type="bibr">Yeh et al. begin</ref> initially with P1 = { V} and consider in turn each cluster from the sorted list to "peel" from V. For example, if C 1 is the first cluster in the list, the bipartitioning p2 _-.= {C1, V -C1} results. Assume that the current solution is pk = {C1, C2 .... , Ck-b V -Ca -Cz ..... Ck-1}, and the unseen duster with highest flux is C*.</p><formula xml:id="formula_21">If pk + l = {C1, C2, ... , Ck-1, C#:, V --C 1 -C 2 Ck-1 --C* }</formula><p>has a smaller Cluster Ratio (see Section 2.4) than pk, then pk + 1 replaces pk as the current solution, otherwise the next unseen cluster on the list is considered. This process repeats until all of the clusters in the sorted list have been seen. This SPC approach is attractive because the saturated nets are good candidates to be cut in a partitioning solution. However, SPC may tend to construct poorly balanced solutions since the clusters in the sorted list might all be very small. The basic principles behind this approach were adopted by <ref type="bibr">Hauck and Borriello [95]</ref> for FPGA partitioning onto an underlying topology (cf. the discussion of layout-driven formulations in Section 2.4).</p><p>An alternative taxonomy might classify the SPC approach with the random-walk clustering algorithm of <ref type="bibr">Hagen and Kahng [84]</ref> and the compaction algorithm of <ref type="bibr">Karger [114]</ref>. All of these approaches rely on randomization to uncover the circuit structure. For example, the nets between dense clusters are likely to be in many shortest paths, hence with high probability these nets will become saturated during the execution of the SPC algorithm. Similarly, a random walk that visits a dense cluster will likely not leave the cluster until many of the cluster's modules have been visited. Finally, contracting random nets is more likely to contract a dense cluster than a sparse cluster; this allows denser clusters to remain uncut.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">3. Mathematical programming</head><p>Mathematical programming optimizes an objective function subject to inequality constraints on the variables. (An equality constraint can be captured by two inequality constraints). A linear program (LP) requires every equation to be linear in terms of each variable. An LP can be solved in average-case polynomial time using the simplex method; interior methods such as that of Karmarkar have polynomial worst-case complexity; see e.g., <ref type="bibr" target="#b14">[115]</ref> for a review. An integer linear program (ILP) is an LP with the additional constraint that the variables must take on integer values; solving general ILP instances is NP-Hard. A quadratic prooram (QP) is an LP with an objective that is quadratic in the variables, and a quadratic boolean program (QBP) additionally restricts the variables to 0-1 values. Some QP and QBP formulations have polynomial solutions while others are NP-hard (see <ref type="bibr" target="#b73">[73]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F(P k) = subject to</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1.">Quadratic formulations</head><p>The multi-way graph partitioning formulation with objective F(P k) = zk=llE(Ci)l and fixed cluster sizes ml &gt;&gt;. m2 &gt;&gt;-... &gt;&gt;-mk (where IGI = m3 can be expressed as a QBP. Let B = (bij) be the k × k matrix with b, = 0 and bi~ = 1 if i 4: j, and let X = (xii) be the n x k assignment matrix. The QBP minimizes k ~, ai~ <ref type="bibr">(xihbh, xj,)</ref> (5.2)</p><p>i,j= l h,l= l</p><formula xml:id="formula_22">• Xih -~-mh, 1 &lt;~ h &lt;~ k, i=1 k ~ Xih = l, l &lt;~ i &lt;&lt;. n, h=l (prescribed cluster sizes),</formula><p>(each module belongs to exactly one cluster),</p><p>xii ~ {0, 1}, 1 ~&lt; i,j ~ n (legal assignment matrix).</p><p>To see why Eq. (5.2) holds, consider whether the edge (vi, v j) is cut. If it is, there will be a unique h and I such that vi ~ Cn and vj~ Ct, and only for these values will both Xih = 1 and xji = 1, hence ao ~,~= 1 (XihbhlXjl) = ao; the cost of (vi, v~) appears once in the sum. If the edge (v~, v j) is not cut, then vl and vj are in the same cluster, so h = I and when both xih = 1 and xji = 1, we have bh~ = 0 which implies that aij Y~,I= 1 (x~hbhtXjl) = O. <ref type="bibr">Shih and Kuh [173]</ref> extended this formulation to handle timing and area constraints. In this case, the matrix B captures the cost of wiring between clusters; previously, we had assumed that this cost is uniformly one, but it may be generalized (e.g., for MCM partitioning). The area constraints W(Ch) &lt;&lt;, Uh, 1 &lt;&lt;. h &lt;&lt;. k can be incorporated by replacing the constraints Y~'=I X~h = mh by (5.3)</p><formula xml:id="formula_23">i=1 h=l i,j=l h,l=l</formula><p>where the first term gives the cost of assigning modules to clusters, and the second term gives the wiring costs. The coefficients 0c and fl can be used to trade off between the terms, but in practice both are set to one. When the entries in B are permitted to take on any values, the formulation in Eq. (5.2) becomes the quadratic assignment problem (QAP). Shih and Kuh show how to adapt a QAP heuristic due to  to their formulation. The same heuristic was also applied by <ref type="bibr" target="#b62">[62]</ref> to an opto-electronic formulation with size, connection, power, and interconnect constraints. <ref type="bibr">Shih et al. [175]</ref> also applied the formulation of Eq. (5.3) to an MCM partitioning formulation, setting 0~ ---1 and /~ = 0 to obtain an ILP. The method assumes a good initial partitioning, although timing and area constraints may be violated. The matrix P is used to capture the cost of perturbing the current solution into a new solution. If Xih = 1 in the current solution, then Pil = n" w(vi)'dist(Ch, Cz)/w(V) for 1 ~&lt; 1 ~&lt; k, where dist <ref type="bibr">(Ch, Ct)</ref> is the Manhattan distance between Ch and C~ in the MCM; this is the cost of moving vi from Ch to Ct. The objective is then to satisfy timing and area constraints while minimizing the perturbation of the current solution. <ref type="bibr">Shih et al.</ref> apply a constraints decoupling technique, separating the problem into one with only area constraints and one with only timing constraints. The algorithm iteratively solves the two problems separately and uses the two solutions to reformulate for the next iteration, until the solutions converge.</p><p>We note one final quadratic (boolean) formulation due to <ref type="bibr">Khan and Madisetti [118]</ref> which integrates area, pin, and yield constraints for MCM partitioning. They apply a linearization technique which approximates the QBP by an ILP, adding a new constraint for each variable in the objective. This ILP is heuristically solved using branch and bound and linear programming relaxation. <ref type="bibr">Liu et al. [137]</ref> propose a timing formulation similar to the Min-Delay Clustering problem of Section 2.4, except that the cost of a path p is extended to loops in the circuit. Assume that V consists of a set of registers R(V) and a set of combinational logic blocks C(V ), and assume that 6(r) = O Vr~ R(V ). <ref type="bibr">Liu et al. define</ref> the iteration bound as L = maxtoopsl rcost(1)/r(l) ] where r(l) is the number of registers in loop 1. The clock cycle T is the maximum delay between consecutive registers on any path. L gives a lower bound on T: in the loop 1 with maximum L, cost(l) is the delay of a loop and r(l) is the number of registers, hence the longest delay between consecutive registers must be at least cost(l)/r(l). The latency on a path p from vi ~ PI to vj ~ PO is defined as the minimum number of clock cycles that pass between a signal arrival at vl and its first effect on the signal output at vj. The latency is determined by the critical path p between v~ and vj with the fewest registers; hence the latency bound for the circuit is defined as maxpaths p cost(p) over all Pl-to-PO paths. The retimin9 problem seeks a rearrangement of registers along their paths, such that the clock cycle and circuit latency are, respectively, as close as possible to the iteration and latency bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2.">Retiming</head><p>As an example, consider the circuit in Fig. <ref type="figure" target="#fig_31">17</ref>(a) in which registers are represented by rectangles and combinational blocks by circles. Assume that the intercluster delay is 2 instead of 1 (following <ref type="bibr">[137]</ref>) and that 6(v) = 1, Vv~ C(V). The shortest loop in the circuit that crosses the cut contains 9 combinational blocks~and crosses the cut twice for a delay of 13 units. Since this loop contains 7 registers, the iteration bound is [-13/7-] = 2, which is also the iteration bound for the entire circuit. Before retiming, we have T = 3 since the path from E to F crosses the cut once (2 units) and then passes through the combinational block h (1 unit). The paths from A to B and from G to H also force a 3-unit clock cycle; however, after retiming (moving B, F, and H as designated), T is reduced to 2 units, which is optimal. The latency after retiming is 18 since there are 9 registers on the longest path from I to O; however, in (b) a different cut plus retiming allows the removal of register P, reducing the latency to 16 units. <ref type="bibr">Liu et al. [136]</ref> add clock and latency constraints into the above QBP formulation. They only consider bipartitioning; thus, the objective in Eq. ( <ref type="formula">5</ref> 2 (~(1)i) "q-~ (XilX2j "q-Xi2Xj 1) ~ H, VIO-critical paths p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>viep (i,j)~p</head><p>Liu et al. then decompose the problem into primal and dual subproblems; the primal problem is solved using the heuristic of <ref type="bibr" target="#b33">[34]</ref>, and the dual problem is solved using a subgradient method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3.">A transportation problem</head><p>Barnes et al. <ref type="bibr" target="#b18">[19]</ref> use the QBP discussed at the beginning of this subsection, except that they maximize the number of uncut edges, rather than equivalently minimizing the number of cut edges. This objective can be expressed using Eq. (5.2) with B as the identity matrix. The objective becomes:</p><formula xml:id="formula_24">k k k k i,j=l h,l=l i,j=l h=l h=l i,j=l h=l</formula><p>where Xh is the indicator vector for cluster Ch. Notice the similarity between this equation and Hall's quadratic formulation in Eq. (4.1). Since optimizing Eq. (5.4) is NP-complete, <ref type="bibr">Barnes et al. try</ref> to approximate it as a transportation problem, a specific type of ILP that can be solved efficiently. Let A = QQT denote a Cholesky factorization of A into the product of lower-and upper-triangular matrices, and let ql be the ith row of Q. If we let r h = ~= 1 qiXih/mh then the following equality can be established:</p><formula xml:id="formula_25">(llqi --rhll 2 --IIq,ll2)mhXih = --~'~XT AXh • (5.5) h=l i=1 h=l</formula><p>This equation appears to be a linearization of Eq. (5.4) except that rh depends on X,. <ref type="bibr">Barnes et al.</ref> propose to fix the rh vectors and optimize the transportation problem that is linear in the Xih variables. Thus, the algorithm begins with an initial assignment matrix X corresponding to pk and computes the rh vectors from X. These vectors are then fixed for solving the transportation problem in Eq. (5.5), and the rh vectors are then recomputed for the new X. <ref type="bibr">Barnes et al.</ref> prove that each partitioning solution corresponding to X will have cost no higher than the previous one, and that their algorithm will eventually converge.</p><p>Recall from Section 4.2 that <ref type="bibr">Barnes [,</ref><ref type="bibr">18</ref>] also proposed another transportation problem that approximates the multi-way partitioning objective. He tried to minimize the error IIUk-Rll 2 which is equivalent to minimizing k ( ~tih ) i z i=l h=l subject to the same constraints as in Eq. (5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.4.">Programming and placement</head><p>We now discuss applying mathematical programming techniques for the 1-dimensional placement problem. Recall that a bipartitioning can be represented by a 0-1 indicator vector x, but that x can also represent a 1-dimensional placement if its entries take on real values. A linear placement also induces a linear ordering, and as seen in Section 4.5, linear orderings and placements can serve as the basis for a partitioning algorithm.</p><p>The placement formulation of <ref type="bibr">Tsay and Kuh [183]</ref> assumes that the coordinates of n legal slots S 1 ~ S 2 ~ "'" ~ S n are given, and a solution consists of an assignment of module locations {xg} to slots {s j}. The objective is to minimize the squared wirelength (xXQx in Eq. (4.1)) of the placement (i.e., the slot assignment). For example, if the placement corresponds to a bipartitioning into clusters of sizes ml and m2, then sl = s2 ..... s,,, = 0 and s,,,+l, s,,,+2 .... ,s, = 1. Tsay and Kuh enforce the slot constraints via a set of nonlinear equations:</p><formula xml:id="formula_26">• X i = ~ S i = C 1 first-order constraint, i=1 i=l ~ x 2 = ~ s 2 = c2 second-order constraint, i=1 i=I xi = si = c, nth-order constraint. i=1 i=1</formula><p>We have already seen that the second eigenvector j[l 2 of Q gives the optimal solution if only the firstand second-order constraints are considered. The difficulty lies in the 3rd-through nth-order constraints. Like , Tsay and Kuh observe that the closest legal solution to ~2 can be obtained by sorting the entries of/~2, although this solution will generally be suboptimal. They propose the SCAN postprocessing algorithm which improves on the ~J2 solution by gradually including higher-order constraints and resolving. In their implementation, subsequent solutions are functions of/.2,/*3 and /.4, but in general, the higher-order constraints cannot be directly mapped to an eigenvector-based solution.</p><p>Another formulation of <ref type="bibr">Tsay and Kuh [183]</ref> ignores slot constraints and assumes that ~ modules have already been assigned to fixed locations, while the other fl = n -~ modules are free to move. <ref type="bibr">Let xe=[x~,xz ..... xo]</ref> a be the coordinates of the movable modules and let x, = <ref type="bibr">[xa+ ~, xa + 2, -.., x,]</ref> x be the coordinates of the fixed modules. The optimal locations of the movable modules can be determined by solving Qooxa + Qp~x= = 0 where</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q=/"</head><p>Tsay and Kuh recommend solving this sparse system of linear equations using a successive over-relaxation (SOR) technique. Since Qpa is real, symmetric, positive definite and diagonally dominant, convergence is guaranteed; in practice, SOR converges in time nearly linear in the number of modules.  applied quadratic programming to a hypergraph representation in their GORDIAN cell placement program. Each net e has an associated location Xe = Ev,~e xdlel which is the "center of gravity" of all of its pins. Assuming a star topology, the squared wirelength objective becomes ~q(x)= Ee~Ey.v,~e(X,-Xe) 2, and setting Xe to be the center of gravity is optimum for this objective. <ref type="bibr">Sigl et al. [177]</ref> improved GORDIAN by incorporating a linear wirelength objective, which can be written as This approximation reduces the influence of nets with many pins. In addition, it reduces the influence of a module v, that is close to an incident net's location Xe (i.e., induces a large 1/gie term); the substituted 1/9e term is generally proportional to the span of e in a linear placement. This approach has led to both <ref type="bibr">MCM [158]</ref> and FPGA <ref type="bibr">[157]</ref> partitioning methods.</p><formula xml:id="formula_27">(X i --Xe) 2 (X, --Xe) 2 (~)l(X) = E E IX'-Xel = E E</formula><p>The quadratic programming formulation can be efficiently solved using a conjugate gradient method when each ge is constant. Let 9~ denote the value for 9e during the rth iteration of the solution. In the first iteration, ge ~ = 1 and the quadratic program of Eq. (5.6) is solved. Given the placement x from the (r -1)st iteration, g~ = max{w0, Y~ ~,~e IX, --XeL} in the rth iteration, where Wo &gt; 0 is a small constant that is used to avoid numerical error. This process of solving the quadratic program and adjusting the g~ terms is repeated until ~eeE Ig r-1 --orl &lt; g, for some choice of e. Notice the similarity between this approach and that of <ref type="bibr" target="#b18">[19]</ref> in which the rh vectors are adjusted after each iteration until convergence. <ref type="bibr">Hagen and Kahng [83]</ref> approximated the linear objective function by squaring it and ignoring the numerous mixed terms, yielding E1 ~ i. j _&lt;, aZ(x, -x j) 2, i.e., the traditional quadratic placement objective with squared coefficients. The more general question of finding a value c such that a~s(x, -x j) 2 best approximates linear wirelength was also raised. All of these placement techniques <ref type="bibr">([183, 177, 83]</ref>) can be used to iteratively generate a bipartitioning by solving the formulation, peeling off and fixing the extreme coordinates, and integrating these fixed coordinates into the next iteration. The PARABOLI scheme of <ref type="bibr">Riess et al. [156]</ref> (see Section 4.5) uses the GORDIAN linear wirelength placement in exactly this manner, but no analogous work has used orderings based on SOR or squared coefficients. In addition, none of these orderings have been used with the dynamic programming algorithm of <ref type="bibr">[5]</ref> to yield multi-way partitionings. We believe that constructing partitionings from placements derived via mathematical programming is a promising research direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Fuzzy partitioning</head><p>The Fuzzy k-Means (FKM) algorithm is a well-known optimization technique for clustering problems that arise in such fields as geological shape analysis, medical diagnosis, image analysis, irrigation design, and automatic target recognition <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">196]</ref>. The problem formulation generally involves clustering data points in multi-dimensional space, although the paradigm can be applied more generally.</p><p>A fuzzy partitioning can partially assign a module to several clusters, e.g., ½ to C1 and ¼ to C2 and to C3. The assignment matrix X is still used to represent a partitioning, with entries in X now real-valued; however, for any row i of X, we still have y~h k = 1 Xih = 1, i.e., vi is assigned to a total of one cluster. There are k variable cluster centers, denoted by wl, w2, ..., Wk. Assume that a distance function dist <ref type="bibr">(vi, Wh)</ref> is defined between modules and cluster centers (e.g., the distance function is obvious if the modules and cluster centers have physical locations). FKM begins with an initial fuzzy partitioning X, then iteratively modifies X to optimize the objective: where c &gt; 1 is a user-chosen scalar. If we let <ref type="bibr">(vii, vi2 .... , rid)</ref> and (Whb Wh2 .... , Whd) be the respective coordinates (assuming locations in d-space) for vi and wh, then the coordinates for wh are computed to be the weighted averages of the coordinates for modules with partial membership in Ch. This expression is given by <ref type="bibr">2, ... ,k, j = 1, 2, ... ,d.</ref>  The computation of cluster center coordinates and a new fuzzy partitioning is alternated until X no longer changes by a significant amount. Then, rounding to its closest discrete assignment is used to derive a non-fuzzy partitioning solution. <ref type="bibr">Ball et al. [16]</ref> have shown how to use FKM in conjunction with GORDIAN to derive 2-dimensional placements, and <ref type="bibr">Razaz [153]</ref> earlier did the same by first modifying FKM to handle graph partitioning without specified coordinates. Razaz uses the ith row ai of the adjacency matrix A to represent the coordinates for vi, so the cluster centers are given by the n-vectors Wl, w2, ..., WR. The distance between module v~ and cluster center Wh is simply dist(vi, Wh) = IL a~ --Wh II. Given a fuzzy partitioning X, the new cluster centers are given by Wh --~n= 1 (Xih) 2ai, h = 1, 2, ... , k.</p><formula xml:id="formula_28">~7=1 (Xih)CI)ij h = 1,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ET= 1 Xih</head><p>The use of 2 for the exponent in the numerator and 1 for the exponent in the denominator seem to be an arbitrary choice of <ref type="bibr">[153]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Boolean set covering</head><p>A new approach to multi-way partitioning was recently proposed by <ref type="bibr">Chou et al. [44]</ref> to address the the Single-Device FPGA Partitioning problem. Chou et al. initially construct a multi-way partitioning with each cluster satisfying the device's size and pin constraints, except that module overlapping is permitted, i.e., a module can be a member of more than one cluster.13 This feasible solution (i.e., one that satisfies all constraints) with overlapping is then transformed into a feasible solution without overlapping. That such a transformation can always be achieved is due to the FPGA Complementary Theorem, which states that: if C1, C2, ..., Ck are k feasible FPGA clusters, then there exits a permutation rt: <ref type="bibr">[1.</ref>. k] ~ <ref type="bibr">[1.</ref>. k] such that Crt(1), CTr( <ref type="formula" target="#formula_14">2</ref>)\Cn( <ref type="formula">1</ref>), Crr(3)\(Cr~(1)k--)Crt( <ref type="formula" target="#formula_14">2</ref>)), ... , Crr(k)\(C~z(1)k-)Cn( <ref type="formula" target="#formula_14">2</ref>)k-) "" k..)Cn(k_l)) are mutually disjoint, feasible clusters. (This result was extended to Multiple-Device FPGA Partitioning in <ref type="bibr">[100]</ref>.) Thus, one may find a minimum set covering of the modules, i.e., a minimum set of feasible clusters that covers (contains) all the modules, and this partitioning can always be transformed into a non-overlapping partitioning with the same number of clusters. Although the set covering problem is NP-Complete, the Espresso II tool <ref type="bibr" target="#b27">[28]</ref> provides a well-developed setcovering heuristic used for minimizing Boolean expressions. <ref type="bibr">Chou et al. adapt</ref> the main ideas behind Espresso II into their set covering algorithm. This approach is attractive because a highly developed tool for a very different problem was utilized for module partitioning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Clustering approaches</head><p>Clustering (i.e., k-way partitioning for large k = O(n)) is rarely a goal in and of itself. Rather, a clustering solution is typically used to induce a smaller and more tractable problem instance.</p><p>Many clustering algorithms utilize a bottom-up approach: each module initially belongs to its own cluster, and clusters are gradually merged or grown into larger clusters until the desired decomposition is found. We classify bottom-up approaches as agglomerative if new clusters are formed one 13In the Single-Device FPGA formulation, the constraints for each cluster can be evaluated independently of the other clusters, hence, overlapping allows modules to be assigned to multiple clusters, although this may have no physical meaning. Note the difference between overlapping and replication, in which the netlist is modified according to specified rules. at a time and hierarchical if several new clusters may be formed simultaneously. Other intuitive approaches involve random walks, iterative peeling of clusters, vertex orderings, and simulated annealing. Another set of approaches is specific to (acyclic) combinational boolean networks. This section begins with motivations for clustering, and then discusses the various clustering approaches. We conclude by surveying methods which integrate clustering into a move-based partitioning strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Motivations for clustering,</head><p>As noted above, move-based approaches, and iterative improvement in particular, are the most common partitioning algorithms in current CAD tools. A common weakness of these approaches is that the solution quality is not "stable", i.e., predictable. Fig. <ref type="figure" target="#fig_36">18</ref> shows the FM solution cost distribution for the Primary2 benchmark; we see that the distribution is roughly normal and that the average FM solution is significantly worse than the best FM solution. This result reflects the "central limit catastrophe" <ref type="bibr">[116]</ref> of move-based methods, i.e., that most local optima tend to be of only average quality. In hopes of hitting the "good tail of the distribution", many practical implementations of FM use a random multi-start approach, i.e., the algorithm is run many times from random starting solutions, and returns the best solution found. However, as discussed in Section 3.4 and as shown in Fig. <ref type="figure" target="#fig_36">18</ref>, hundreds of runs may be necessary to achieve stable performance.</p><p>Given a clustering solution pk = {C1, C2, ..., Ck}, we can reduce the instance size from n to k by constructing the contracted hypergraph H'(V', E') with V' = {C~, C2, ..., Ck}. For every e e E, there is a hyperedge e' e E' with e' = {Cl~v ~ e~C} (unless le'l = 1), i.e., each cluster in e' contains some module that has a pin of e. The contraction process will also decrease the sparsity of the netlist, i.e., the average degree degavg = Y.e~Ele[/lVI will be higher for the contracted hypergraph. <ref type="bibr">Goldberg and Burstein [75]</ref> claim that degavg is between 1.8 and 2.5 for real circuits, and that an FM-based algorithm performs "relatively poorly" in this range, but "nearly optimally" when degavg &gt; 5. <ref type="bibr">Lengauer [133]</ref> also conjectures that for graphs with high density and large minimum degree, there will be few local optima that are not global optima. Finally, the analysis of <ref type="bibr">Saab and Rao [163]</ref> also suggests that KL performance improves with increasing graph density. A bipartitioning is said to be m-optimal if swapping any m modules from C 1 with m modules from C2 cannot decrease the cost, e.g., KL is a 1-optimal algorithm. Saab and Rao give a performance bound which holds for any 1-optimal heuristic, and becomes tighter as the number of edges in the graph increases. Specifically, if (~)((1 + e)/(1 + 20) edges are present, then the heuristic bisection width is suboptimal by a factor of at most e (e.g., if z3(~) edges are present, a 1-optimal bisection can have cost at most twice optimal). All of these works imply that a move-based heuristic should be more effective on a contracted netlist not only because of the smaller solution space, but also because of the increased density.</p><p>These considerations have motivated the "two-phase" application of move-based algorithms [75]: first execute the given algorithm on a contracted netlist, then re-expand the resulting solution into the starting point of a second algorithm run on the flat (original) netlist. The two-phase approach has been applied with many clustering algorithms, e.g., <ref type="bibr" target="#b2">[3,</ref><ref type="bibr">4,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr">84,</ref><ref type="bibr">94,</ref><ref type="bibr">143,</ref><ref type="bibr">176]</ref>; see Section 6.6 for a discussion of methods which integrate clustering into move-based approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Agglomerative clustering</head><p>An agglomerative clustering algorithm begins with the n-way clustering P"= {{vl}, {v2} .... , {v,}} and iteratively constructs pk from pk+l as follows:</p><p>• Choose two clusters Ch and C~ from pk+l • Construct pk from pk + 1 by removing Ch and C~, and adding the merged cluster C = Ch U C~.</p><p>Agglomerative clustering was first proposed by <ref type="bibr">Johnson [111]</ref> for weighted complete graphs. The criterion for choosing clusters Ch and C~ is what distinguishes among agglomerative variants, e.g., <ref type="bibr">Johnson [111]</ref> merges the two clusters that minimize the diameter of the new cluster C. This minimum-diameter criterion was used for circuit bipartitioning in <ref type="bibr" target="#b2">[3]</ref> : modules were first mapped to points (i.e., singleton clusters) in multi-dimensional space (see Section 4), the diameter criterion was used to merge clusters, and the resulting clustering was used within two-phase FM.</p><p>For undirected graphs, <ref type="bibr">Karger [114]</ref> proposed a heuristic which begins with all vertices as isolated clusters. Iteratively, a random edge is chosen and its incident clusters are contracted into a single cluster (see Section 5.2). The approach can be extended to hypergraphs by picking a random net (perhaps with size-dependent probability) and contracting two random incident i clusters (or all incident clusters). An alternative greedy approach would be to simply merge the two clusters with highest connectivity, i.e., choose Ch and CI such that Nht = [E(Ch)nE(CI)[ is maximum. <ref type="bibr">Schuler and Ulrich [168]</ref> observe that such a criterion ignores the number of nets cut resulting from the merged cluster. Such a criterion generally will also fail to construct balanced clusterings. Thus, the authors of [168] maximize a merging objective of form:</p><formula xml:id="formula_29">Nht Nhl f(W(Ch)) + f(w(Ct)) (6.1) IE(Ch)[-Nhl IE(Cl)[ -Nht</formula><p>where f is a function of the cluster weights. The resulting cluster hierarchy is used to form a 1-dimensional placement. More recently, <ref type="bibr">Shin and Kim [176]</ref> proposed a slightly different approach: given pk + 1, they merge Ch and Ct to maximize</p><formula xml:id="formula_30">Nhl ~k(w(Ch) + w(Ct)) min {E(Ch), E(C,) } w( V)</formula><p>The first term captures the connectivity between clusters, with the denominator favoring the selection of "outlier" clusters (e.g., a cluster with connections to only one other cluster) for merging.</p><p>The second term implies a penalty for making a cluster too large; if the merged cluster has average weight in the resulting pk, the term reduces to ~. The authors of <ref type="bibr">[176]</ref> proposed this clustering approach for use with two-phase FM; their particular scheme makes many runs on the contracted netlist before the netlist is flattened for the second FM phase. <ref type="bibr">Ng et al. [143]</ref> propose an agglomerative algorithm based on Rent's rule; Rent's rule describes an average-case phenomenon in "good" circuit placements, i.e., that there is a power-law relationship IE(C) <ref type="bibr">[ = d(C)</ref>. [ CI" between the number of edges incident to a cluster and the size of the cluster (see <ref type="bibr">[128] and [85]</ref> for reviews). Here, d(C) = Zv~c deg(v)/I CI is the average degree of modules in the cluster. Because the layout has finite size, the power-law relationship eventually breaks down when the number of clusters is small. Feuer <ref type="bibr" target="#b64">[64]</ref>, Donath <ref type="bibr" target="#b57">[57]</ref> and others have established that a lower Rent parameter r corresponds to lower total wirelength in the layout. However, the connection between such results for placement (where the netlist topology is embedded in the plane) and the clustering domain (where the netlist topology is "free") remains unclear <ref type="bibr">(cf. [85]</ref>). The merging step chooses the pair of clusters Ch and C~ that minimize the Rent parameter 0 ~&lt; r ~&lt; 1 of the merged cluster C, where</p><formula xml:id="formula_31">r=l+ ln[E(C)l -ln(d(C)) lnlCl</formula><p>The merging process continues until the prescribed number k of clusters is reached, or until r exceeds a prescribed constant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">3. Hierarchical strategies</head><p>Generally, agglomerative methods will not be very efficient: finding the best pair of clusters to merge may require O(k 2) time, unless a list of cluster merging costs is stored and updated (which will likely require O(n 2) space). An alternative strategy is to find many good clusters to merge, then perform all merges simultaneously; we call this a hierarchical strategy. The difference between agglomerative and hierarchical strategies is illustrated in an 8-module example in Fig. <ref type="figure" target="#fig_37">19</ref>. In (a), the dendogram reveals the order in which clusters are merged; each dotted horizontal line is a level in the hierarchy, and an agglomerative algorithm will have n -1 levels. Fig. <ref type="figure" target="#fig_37">19</ref>(b) depicts a hierarchical algorithm that simultaneously merges as many cluster pairs as possible, yielding a hierarchy with Flog n-] levels.</p><p>In <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref>, <ref type="bibr">Bui et al.</ref> propose matching-based compaction as a clustering strategy. A matching in the netlist is a set of disjoint pairs of modules, such that each pair shares a common net. Bui et al. find a random maximal matching and merge each pair of modules into a cluster: this will ideally result in a set of n/2 clusters; matchings can be iteratively computed on the contracted netlist, yielding a hierarchy of clusterings with size n/4, n/8, etc. A similar approach was proposed earlier by <ref type="bibr">Goldberg and Burstein [75]</ref>. With the random matching approach, all clusters will have roughly the same size, although it is not known whether this is preferable, e.g., for two-phase bipartitioning.</p><p>Feo and Khellaf 1-63] proposed contracting edges according to a maximum-weight matching. Tight performance bounds were shown for this approach on graphs with edge weights that satisfy the triangle inequality, but the matching construction generally requires O(n 3) time. <ref type="bibr">Roy and Sechen [ 159]</ref> also proposed a deterministic contraction approach; they first construct a weighted undirected graph using the standard clique model, then contract all edges with weight higher than a given threshold. This approach differs from the matching-based approaches in that module pairs are contracted more selectively.</p><p>Instead of merging pairs of modules, entire nets may be contracted. In the placement heuristic of [181], nets are first sorted in nondecreasing order by size, and a net is picked from the list and contracted into a cluster as long as none of its modules belong to a contracted cluster. In other words, this approach greedily selects a maximal subset of mutually disjoint nets, then contracts all the nets in this subset. This procedure is iteratively repeated on the contracted netlist until certain "fractal" criteria are met.</p><p>Another scheme, proposed by <ref type="bibr">Hauck and Borriello [94]</ref>, uses randomization and the merging criterion of <ref type="bibr">[168]</ref>. Initially, each module belongs to its own singleton cluster; the clusters are then visited in a random order and each cluster is associated with the neighboring cluster with which it has highest connectivity, i.e., that maximizes Eq. (6.1) withf(Ch) = 1/W(Ch). If the current cluster in the order has already been associated with another cluster, it is ignored. After all clusters have been visited, clusters are transitively merged with their associated neighbors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Intuitive cluster properties</head><p>We now turn to a group of clustering approaches whose main common bond is that each tries to identify certain intuitive cluster properties, such as having dense cliques or cycles. Some of these intuitions are explicitly captured in a clustering objective that can be optimized, e.g., Absorption or ratio cut. We identify each approach by its underlying clustering intuition.</p><p>(K, L)..connectivity: Modules u and v are (K, L)-connected if there exist K edge-disjoint paths of length ~&lt; L between u and v. Garbers et al. <ref type="bibr" target="#b69">[69]</ref> proposed using the transitive closure of the (K, L)-connectedness relation for clustering into dense subgraphs (i.e., having large ]EI/I VI 2 ratio). However, the method may not be that intuitive, e.g., in a 4-cycle <ref type="bibr">(v~, v2, v3, v4)</ref>, vx and v3, along with v2 and v4, are (2, 2)-connected, yet the clustering {{v~, v3}, {v2, v4}} will cut all four edges. Furthermore, determining (K, L)-connectivity is NP-complete for L ~&gt; 5, with NP-completeness for L = 4 still an open question. In practice, <ref type="bibr">[-69]</ref> ensures clusters are connected by placing two modules in the same cluster if K edge-disjoint paths between them can be found with at least one path having length one.</p><p>Cycles in random walks: A random walk in a netlist is a random sequence of modules {wl, w2, ... ,wK} such that N(wi)c~N(wi+l)~ 0, Vi = 1 .... ,K-1. In other words, every consecutive pair of modules shares a common net. <ref type="bibr">Cong et al.</ref> [473 defined a cycle {wp, Wp+l, ..., w~} as a contiguous subsequence of the random walk with wp = wq and all wi distinct, i = p, p + 1, ..., q -1. The maximum cycle for vi is the longest cycle that begins and ends at vi; all maximal cycles are found in O(N) time and then used to identify clusters. (Intuitively, a maximal cycle should identify a good cluster: if it contains any natural subcluster, a module in this subcluster would have likely appeared more than once within the maximal cycle.) <ref type="bibr">Hagen and Kahng [84]</ref> assign v~ and vj to the same cluster if their sameness is larger than zero, where sameness is computed as follows. Let CC(i,j) be the number of times that vj occurs in a cycle beginning at vi. If CC(i,j)--0 or CC(j,i)= 0, then the sameness of vi and vj is 0; otherwise, it is set to 2(CC(i,j ) + CC(j, i)) and an adjustment of 4CC(i, l) -CC(j, l) (4CC(j, l) -CC(i, I) ) is added for each vl such that CC(j, 1) &gt; CC(i, l) (CC(i, l) &gt;~ CC(j, l)). The intuition behind the adjustment term is that if vz appears roughly the same number of times in cycles beginning with v~ and v j, then v~ and vj are similar; however, if v~ appears many more times in one module's cycle (i.e., by more than a factor of 4) then vi and vj are dissimilar. These random-walk approaches have been utilized within two-phase FM bipartitioning.</p><p>Cliques: A clique is a densest-possible subgraph, hence it forms a very intuitive cluster. <ref type="bibr">Cong and Smith [51]</ref> propose to find and collapse cliques in the undirected graph constructed from the netlist by applying the clique net model with edge weight 2~]el to all nets with lel ~&lt; 5. The algorithm searches for cliques of size ro and ro + 1 where ro is likely to be the size of the largest clique in the graph. A clique is contracted into a cluster as long as it satisfies the size and cardinality constraints 4w(C) ~&lt; w(V), 31CI ~&lt; n as well as the density constraint that total edge weight is at least 2~lEI/(n(n -1)) for some parameter ~. The density constraint prevents single nets from forming clusters. While the approach is amenable to parallel processing, finding dense cliques by enumeration is computationally expensive. Also, by discarding medium-size and large nets to maintain sparsity, the algorithm may lose important clustering information. module is a reconvergent module. A petal is defined as the set of all modules located on all paths from a reconvergent fanout stem to all of its reconvergent modules; the petal is the basic primitive of the clustering algorithm. Dey et al. construct a clustering by first finding all petals, then merging overlapping petals into corollas, with corollas being maximal with respect to the overlapping property. Each individual corolla may be resynthesized using algebraic/boolean factoring (e.g., Espresso <ref type="bibr" target="#b27">[28]</ref>) and if the new factorization will likely reduce the layout area, the resynthesized corolla is "glued" back in place of the original one. Other works by the same authors show the implications of corolla-based clustering for logic synthesis, delay reduction, testability, etc.</p><p>MFFCs: <ref type="bibr">Cong and Ding [46]</ref> use the standard DAG representation of a combinational network to find clusters for FPGA technology mapping. For every v e V, the authors of <ref type="bibr" target="#b45">[46]</ref> inductively define a fanout free cone of v, FFC~ V, as follows: (i) v ~ FFC~, and (ii) if u ~ FFC~, u ~ v, and (u, w) ~ E for some w, then w ~ FFC~. In other words, an FFC is a single-output subnetwork. A maximum fanout-free cone for v (MFFC,) is an FFC~ such that if w¢PI and w E MFFC~ then for every (u, w) ~ E, u ~ MFFCv. The intuition is that MFFCs are naturally suited for technology mapping onto lookup table-based logic blocks which have a single primary output and a fixed number of primary inputs. In <ref type="bibr" target="#b50">[50]</ref>, MFFC clusters are used for acyclic multi-way partitioning (see Section 3.5); here, the cluster sizes are heuristically thresholded since an MFFC can be quite large.</p><p>Cones: Given v ~ PO for a given DAG, <ref type="bibr">Saucier et al. [167]</ref> define the cone of v to be the set of all w E V such that there is a path from w to v. The authors of [167] use cones as a building block for a multi-way FPGA partitioning algorithm. For each v ~ PO, the cone A~ is constructed, and clusters C are formed by overlapping cones and extracting the "coarsest common cluster", i.e., C is a cluster if for every cone A,, C n A~ = C or C n A~ = 0. A new clustering is then agglomeratively constructed by iteratively finding Ch with maximum IE(fh)l/W(Ch) and merging it with Ct that maximizes [E(fhufl)l/w(fhufl) . The merging continues as long as all the clusters satisfy prescribed size and pin constraints. <ref type="bibr">Saucier et al. applied</ref> this method to the Single-Device FPGA Partitioning problem, and gave a modification which handles critical path delays. Each critical path lies entirely within a single cone, so that by not splitting the cone the path will be contained in a single cluster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.">Integration of clustering into a bipartitioning heuristic</head><p>Many of the above methods were originally proposed for use within an FM-based bipartitioning approach. The simplest way to incorporate a clustering solution is via the two-phase approach, i.e., run FM on the contracted netlist, and use the result as the starting solution of a second run on the flattened netlist. However, more sophisticated techniques may be preferable.</p><p>For example, <ref type="bibr">Shin and Kim [176]</ref> run a variant of FM on the clustered netlist ten times on each of five different clustering solutions (with k = n/ <ref type="bibr">12, n/11, n/lO, n/9, n/8)</ref>, The FM variant is then run only once on the flattened netlist, using the best of the 50 clustered bipartitionings as a starting solution. Note that the FM variant actually consists of multiple passes where the cluster size constraints become tighter within each pass; Shin and Kim state that this procedure allows closely coupled cells to settle first, with freer cells moving closer to an optimum bipartitioning in later passes. Hence, this scheme makes hundreds of FM passes on clustered netlists before making a single pass on a flattened netlist. It is difficult to evaluate whether this method is the most effective use of FM passes: certainly, since FM passes come "cheaply" (in linear time), they can be integrated within a clustering scheme in many creative ways. <ref type="bibr">Hauck and Borriello [94]</ref> discuss two unclustering methods which integrate a cluster hierarchy into the application of FM. The iterative unclustering method <ref type="bibr" target="#b51">[51]</ref> runs FM on the netlist contracted from the top clustering in the hierarchy (with smallest k), then runs FM on the next highest level in the hierarchy, etc. and finishes with a final run on the original flattened netlist. This scheme allows FM to first make big moves, then gradually reduce the size of moves at each level of the hierarchy. The edge unclustering method only unclusters the modules incident to cut edges, allowing fine-grained optimization of these modules and coarse-grained optimization of the other modules to occur simultaneously. However, in practice, the authors of [94] prefer the iterative unclustering method. <ref type="bibr">Saab [160]</ref> draws an analogy with simulated annealing and observes that clustering (and unclustering) should not proceed too quickly since the optimization process might become frozen in a suboptimal solution. He proposes the opposite of iterative unclustering, namely running FM first on the lowest level of the hierarchy, followed by clustering and then running FM on the next level. An interesting aspect of his approach is that the clusterings themselves are formed based on the order of moves in an FM run. The idea is that when one module is moved from Ca to C2, it tries to pull its incident modules into C2 as well. Hence, a sequence of consecutive moves from Cx to C2 may determine a natural cluster. This observation was also made by <ref type="bibr">Hagen et al. [80]</ref>, who showed that a LIFO FM gain bucket organization encouraged the movement of entire clusters of modules (see <ref type="bibr">Section 3.3.1)</ref>.</p><p>Finally, we note an intriguing approach of <ref type="bibr">Barnard and Simon [17]</ref> that applies clustering to spectral bisection. The second eigenvector of the contracted graph is computed, then the eigenvector is interpolated to approximate the eigenvector for the original graph, and finally this vector is refined and split into a bipartitioning.</p><p>In summary, we have noted many distinct clustering constructions, and many ways in which clusterings can be used within a general partitioning approach. However, we do not seem close to understanding which approaches are better, or why. One reason is that it is generally difficult to compare clustering strategies -many works present a single scheme for use in their own specialized heuristic (e.g., FPGA partitioning <ref type="bibr" target="#b43">[44]</ref>, or TimberWolf placement [179] ) without presenting any results for alternative clustering schemes. Another reason is that while it may be easy to devise clustering heuristics that optimize ratio cut, Absorption, etc., we do not know if these are the appropriate objectives for the specific application. For example, experiments conducted in <ref type="bibr">[4]</ref> found that WINDOW clusterings could improve such traditional objectives, but led to only average-quality two-phase FM results. Indeed, it seems that almost any clustering heuristic will improve FM performance via the two-phase strategy, but no heuristic particularly distinguishes itself from the pack.</p><p>Since clustering is still a very poorly understood realm of bipartitioning, we believe that seeking answers to the following questions will be important in future work:</p><p>• What is the correlation between clustering objectives and the effect of clusterings within twophase FM? Is there a natural clustering objective for the two-phase FM application?</p><p>• What is the best number of clusters? In a hierarchical approach, how many clusters should be at each level and how many levels are needed? • What is the best way to integrate a clustering or a series of clusterings into an FM-based algorithm (e.g., given a CPU resource in terms of the number of FM passes made, how should this resource be allocated)? • What cluster size constraints should be imposed? Is it better to have balanced clusters (as advocated by <ref type="bibr" target="#b29">[30]</ref>), or to have large clusters mixed with small ones (as in edge unclustering)?</p><p>We believe that once the answers to these questions are understood, the best clustering strategies will become evident.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>The past several years have seen the field of netlist partitioning make numerous advances -in terms of new formulations and objectives for various specific applications, and in terms of new algorithmic approaches. This paper has surveyed these developments, with an emphasis on more recent ideas. Throughout our discussion, we have attempted to note the research directions that merit further investigation, but have also tried to avoid value judgements based on experimental results. In this concluding section, we offer a summary of the benchmarking techniques for graphs and circuits that have appeared in the literature; we end with a brief assessment of the more promising approaches seen in recent works, and possible future directions for the field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Benchmarking</head><p>Many studies of partitioning are not specific to VLSI applications, or otherwise did not have any set of "real circuits" available for benchmarking. Thus, experiments have been conducted on various classes of random graphs, including:</p><p>• Uniform: A graph G(n, p) has n vertices, with the edge between each pair of vertices independently present with probability p. Random graphs (and hypergraphs) have been used by e.g., <ref type="bibr">[110,</ref><ref type="bibr">187,</ref><ref type="bibr">164]</ref>. See <ref type="bibr" target="#b25">[26]</ref> for a review of graph-theoretic results established for this model. • Geometric: The graph U(n, d) <ref type="bibr">[110]</ref> is generated by picking n random (x, y) coordinate pairs (corresponding to the n vertices) in the unit square, and introducing an edge between two vertices if the Euclidean distance between their corresponding (x, y) locations is no greater than d. • "Difficult" d-regular: A graph is in the class GBui <ref type="bibr">(n, b, d)</ref> if it has n vertices, is d-regular, and has expected optimum bisection width no greater than b. A construction was first given by Bui et al. <ref type="bibr" target="#b28">[29]</ref>, and a simpler variant construction was given in [85]. • Bisection specific: A graph in the class of random graphs G2set(2n, Pl, P2, his)  has a given edge internal to n-vertex clusters C1 and C2 with probabilities Pl and P2, respectively. Exactly bis edges connect C1 with Cz, with bis very likely to be the cost of the optimum bisection. • k-way specific: The class GGar(k, n/k, pi, Pe) <ref type="bibr" target="#b69">[69]</ref> represents the multi-way extension of the Bisection Specific construction. A graph in this class has k clusters, each of size n/k; the C(k, 2). (n/k) 2 intracluster edges are each independently present with probability Pi, and the k'C(n/k, 2) intercluster edges are each independently present with probability Pe. See also such works as <ref type="bibr" target="#b0">[1]</ref>.</p><p>Other, more complex random constructions have also been proposed, e.g., <ref type="bibr">[124,</ref><ref type="bibr">161]</ref>.</p><p>In recent years, works on netlist partitioning have begun using benchmark suites collected by ACM SIGDA for experimental comparisons. 14 Recently, the CAD Benchmarking Laboratory (CBL) at North Carolina State University has succeeded the Microelectronics Center of North Carolina as the host for maintaining and renewing suites of benchmarks (WWW:http:// www.cbl.ncsu.edu/www/CBL_Home.html/or ftp to ftp.cbl.ncsu.edu or email to benchmarks@ cbl.ncsu.edu). The benchmarks that most commonly appear in experiments in the literature belong to the LayoutSynthesis90 and 92, ISCAS85 and 89 [121], and PDWorkshop93 suites; for FPGA partitioning, the Partitioning93 suite is typically used. All of these benchmarks were originally designed for either placement or synthesis, hence each experimenter must translate the benchmark to some usable partitioning format. The differences in interpretations of the benchmarks can lead to discrepancies in the resulting inputs, and researchers may end up comparing the cuts of graphs and hypergraphs that are not identical. For example, the number of modules reported for the Test02-06 benchmarks is higher in <ref type="bibr">[195]</ref> than in <ref type="bibr">[84]</ref>, which is likely due to the interpretation of I/O pads. In other cases, problems may arise from netlist connectivity. For example, when converting the industry3.vpnr benchmark into PROUD format, the authors of GORDIAN observed that the netlist was disconnected, and the smaller 27-module component was discarded since it had no external connections and since GORDIAN requires connections to I/O pads in order to place the circuit <ref type="bibr">[155]</ref>. Other authors might not remove this smaller component, leading to different bisection and ratio cut results for the same algorithm and the "same" test case.</p><p>We believe that the VLSI partitioning field would greatly benefit from a standard set of benchmarks exclusively designed for partitioning. As a first step, TU Munich has made many benchmarks available in PROUD format <ref type="bibr">[183]</ref> (WWW: http: //www.regent.e-technik.tu-muenchen.de/) and we are currently making benchmarks available in a standard hypergraph format (WWW: http://nexus2.cs.ucla.edu). Our group is currently working with TU Munich to ensure consistency between our formats, making either format suitable for comparisons. Clearly, such entities as the CBL are best equipped to take such efforts a step further, e.g., by constructing and propagating self-consistent translators among the many existing partitioning input formats. Such institutionalized uniformity will help to make future benchmarking results in the literature much more meaningful. At the same time, care must also be taken not to constrain research paths by removing useful information. As examples, (i) logic function information must be retained in order to explore logic-based replication or combined resynthesis and partitioning (cf. <ref type="bibr" target="#b21">[22]</ref>), and (ii) directional information must be present in inputs to address acyclic, delay-minimization, etc., formulations.</p><p>By way of facilitating future comparisons, Table <ref type="table">1</ref> lists various partitioning formulations, along with works that have provided experimental results for some of the standard benchmarks. These are of historical note since formulations can become popular simply due to the existence of laGraphs from the Harwell-Boeing sparse matrix collection (anonymous ftp to orion.cerfacs.fr) have also appeared occasionally in the literature (e.g., ) and provide an excellent set of test cases for graph partitioning algorithms. Many of the formulations listed in the table are quite similar, e.g., the first five formulations are all bipartitioning variants. While it is unclear which formulation is "correct", all of the associated bipartitioning algorithms are certainly comparable in some sense. It remains for the field to establish a reasoned basis by which heuristic variants, and associated experimental results, can be evaluated. For instance, <ref type="bibr">Hauck and Borriello [94]</ref> recently completed an excellent study of FM-based bipartitioning algorithms, yet their results do not use unit area (rather, they set w(v) = deg(v) -2 for each v ~ V). Although this unorthodox weighting scheme by no means invalidates their conclusions, it does complicate future extensions of their study vis-~-vis other works. We believe that whether to use area information, which balance constraints apply, etc., are issues that can be addressed by identifying benchmarks (or benchmark variants) that are particularly suited for specific formulations.</p><p>Another weakness in the present "comparison-based literature" stems from having non-standard implementations of traditional algorithms, e.g., many researchers (including ourselves) have implemented their own FM-based 2-way or multi-way partitioners. On the other hand, Section 3 observed that subtle differences in implementation can have very large effects on solution quality. Widespread availability of canonical, well-tested implementations of standard algorithms (e.g., through CBL) could alleviate this problem. Also, researchers could perhaps use a shared site to make their source codes and/or executables available, to facilitate future comparisons as more benchmarks become available.15 Authors of future work might also provide detailed descriptions of their experimental protocols and benchmark instances, since so many discrepancies are possible.</p><p>Finally, there are many deeper questions associated with the use of benchmarks in the VLSI partitioning literature (cf. panel discussions at many leading conferences in recent years). The beginnings of a list might include:</p><p>• Is it correct, as has been the case in recent years, to equate "progress" with "beating" previous results in terms of both solution quality and run-time? Arguably, this heavily biases against such novel approaches as evolutionary computing, parallel search, parallel annealing, constraint satisfaction, etc. Experimental setup, data collection and reporting methodology, etc. will also affect the perception of superiority. Furthermore, the present trend may well be responsible for the recent proliferation of "new formulations" for which there are no previous results that must be "beaten". • Is it wise for the field to focus, as it has in recent years, on results for "real-world", as opposed to "artificial", instances? Note that (i) the provenance and functionality of benchmarks are often "sanitized" away so that it is unclear whether the benchmarks are representative; (ii) optimal solutions are never known for real-world instances (see <ref type="bibr">[81]</ref> for a partial workaround); and (iii) any benchmark suite (as opposed to a generator for a class of (random) instances) is limited in size, which can in turn limit the significance of comparisons. • Should industry users of CAD algorithms be more forthcoming with real-world test cases? Note that the literature for, e.g., the Multi-Way FPGA Device formulation <ref type="bibr" target="#b43">[44,</ref><ref type="bibr">100]</ref> includes test cases that presently can be obtained only under a signed nondisclosure agreement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Perspectives</head><p>We conclude our work by listing what we consider to be promising directions for future research. First, we believe that move-based approaches such as iterative improvement, stochastic hillclimbing, or evolutionary optimization are increasingly attractive. Certainly, FM and its derivatives have comprised the partitioning state-of-the-art throughout all areas of VLSI CAD during the past decade. However, small differences in implementations can lead to large differences in solution quality. <ref type="bibr" target="#b15">16</ref> It seems worthwhile to continue to explore various implementations and tie-breaking strategies, especially given the large payoffs that can result from only minor code changes.</p><p>Second, we have noted that in practice, move-based approaches are often run many times with different random starting solutions. However, adapting the starting point based on knowledge from 15There are instructive precedents in the fields of combinatorial optimization and operations research. For example, WWW http://netlib.att.com provides a repository for mathematical software and related items, including eigenvector computations, mathematical programming and network flow packages, etc. Similarly, the OR-Library at the Imperial College Management School (WWW http://mscmga.ms.ic.ac.uk/info.html)gives a collection of test data sets for a variety of combinatorial formulations including LP, IP, QAP and matching (but not yet partitioning). Another type of impetus comes from regular "challenges" within the field (cf. the ACM Physical Design Workshop placement challenges from 1987 1991, the recent DIMACS Challenges in combinatorial optimization, etc.). 16Such studies can call into question the conclusions drawn in oft-cited works, in this case those of <ref type="bibr">[123,</ref><ref type="bibr">164,</ref><ref type="bibr">189]</ref> regarding "lookahead" in iterative improvement strategies.</p><p>prior iterations can more quickly lead to stable solution quality; such an "adaptive multi-start" approach shares characteristics with hybrid genetic-local search techniques in evolutionary optimization. The paradigm of evolutionary optimization, with its unique style of search in the solution space, has claimed successes in the arenas of operations research and combinatorial optimization, which bodes well for future application to VLSI partitioning.</p><p>Third, spectral approaches that utilize multiple eigenvectors appear promising. Previous spectral approaches that associate a single eigenvector with a cluster <ref type="bibr">[18]</ref> or use only one eigenvector <ref type="bibr">[82]</ref> may have inherent limitations. Works such as <ref type="bibr">[6,</ref><ref type="bibr" target="#b68">68]</ref> achieve solutions by associating a partitioning instance with the vector space comprised by multiple eigenvectors, yet heuristics for this representation are largely undeveloped. In addition, older spectral ideas may be worth revisiting, e.g., Donath and Hoffman <ref type="bibr" target="#b59">[59]</ref> suggested varying the degree matrix to obtain better eigenvectors.</p><p>Fourth, finding good 1-dimensional circuit representations (i.e., linear orderings of the modules) also seems promising. Dynamic programming can optimally split such an ordering into multiple clusters with respect to many standard objectives. Also, analytic techniques such as conjugate gradient and successive over-relaxation are naturally 1-dimensional. Finally, different methods for producing a partitioning from a linear ordering (such as the PARABOLI approach of gradually pulling apart an ordering while reoptimizing it) merit further investigation.</p><p>Fifth, we note that three trends -(i) the need to address highly constrained and complex formulations (e.g., timing, I/O, clock period, etc. constraints), (ii) the increased transfer of algorithm techniques from other well-established disciplines, and (iii) the availability of more computing power for CAD optimizations combine to make combinatorial techniques increasingly viable. Analogous to the rediscovery of spectral and flow computations in recent years, we believe that approaches based on mathematical programming -including implicit enumeration methods such as branch-and-bound solution of ILP formulations -will be a "growth area" in VLSI partitioning.</p><p>Sixth, clustering now seems a required extension to many existing algorithms in light of increasing problem complexity. New criteria for clustering, as well as definitive studies correlating performance of the two-phase FM mechanism and the underlying clustering strategy, are still needed. Alternatives to the two-phase methodology are also well worth exploring. Works such as <ref type="bibr">[94]</ref> provide important first steps in this direction.</p><p>Finally, we have noted that the recent literature contains many heuristic forays and new problem variations, which is not unexpected when many new works are essentially evaluated by the numbers they achieve for a limited suite of (outdated) test cases. In the previous subsection, we sketched a wish list for the future which includes: (i) canonical algorithm implementations (e.g., of the KL and FM heuristics) for comparison, and more widespread conformity with standard benchmark interchange formats, (ii) larger, public benchmarks with more functional and library information, (iii) public availability of partitioning codes, test instances, and actual partitioning solutions used in reported results, (iv) elimination of biases against nascent "future algorithm technologies" which may not yet be competitive in terms of both solution quality and efficiency, (v) more creative criteria for algorithms (cf. the "self-scaling" concept in [81]), and (vi) more complete descriptions of experimental protocols, along with more statistically meaningful data. These may be the most important future directions for researchers in VLSI partitioning, as we strive to achieve increased relevance to current design practice, and a more reasoned, long-term, and scientific approach to this intractable problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Representations of a circuit with 7 modules and 10 signal nets: (a) circuit diagram with all inputs on the left side of the modules and all outputs on the right side; (b) the hypergraph representation; (c) the weighted graph representation using the standard clique net model with uniform edge weight 1/(le[ -1); (d) the intersection graph; (e) the dual graph; and (f) the directed graph (assuming a directed-tree hyperedge model). To enhance readability, not all edges have been labeled.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. Optimal bipartitionings of an edge-weighted graph with six modules. The min-cut bipartitioning {{Vl}, {/)2, /)3, /)4, /)5, U6}} will have cutsize 18, but is very unbalanced. The min-cut bisection {{vl, /)2, /),}, {/)3, vs, v6}} has cutsize 300, much worse than the arguably more natural solution {{Vl, v2}, {/)3, v4, v5, v6}}  which has cutsize 19 and corresponds to the optimal ratio cut of19/8.    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>A cluster C is feasible with respect to FPGA device type D if w(C)&lt;~ w(D) and JE(C)[ &lt;~ JE(D)J where w(D) is the capacity and E(D) is the I/O limit of the device type D. Single-Device FPGA Partitioning: Given an FPGA device type D, find pk = {C1, Cz, ..., Ck} such that every Ch ~ pk is feasible with respect to D and F(P k) = k is minimized.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Directed graph corresponding to an N-to-2 N decoder v. Replication of v reduces the cut size from 2 ~ in (a) to N in (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>.............</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. (a) A circuit with two nets crossing the cut, and (b) the same circuit with module v replicated, yielding only one cut net.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>w ~ D(e)~Ct, remove w from e; create a new net e' with S(e') = v' and D(e') = {w ~ D(e) n Ct}. Delete any resulting 1-pin nets from the hypergraph. • For every net e with v ~ O(e), add v' to D(e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Logic-Dependent Replication Rule: Let E* = {e IS(e) = v'}. For every net e such that v ~ D(e), if there exists an e* ~ E* that depends on e, add v' to D(e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>2 .Fig. 5 .</head><label>25</label><figDesc>Fig. 5. (a) A module v with three nets crossing the cut; (b) replication requires only two nets to cross the cut since the net corresponding to input el is not needed by v'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>t. flc,(e) = r, flc2(e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>.1) for the rth-level gain of moving module v e C~ to Cj is 7~(v) = I{e e E({v}) s.t. fl'cj(e) = r, fl'c,(e) &gt; 0}1 -[{e e E({v}) s.t. fl'c,(e) &gt; O, fl'cj(e) = rthat the objective is F(P k) = [E(U)I. In [165], Sanchis shows how to modify this gain formula to handle the objective function which assigns costj -1 to a net that spansj clusters (this is very similar to F(P k) = y~= 11E(Ch)[). For this objective, the rth-level gain is 7,(v) = [{e e E({v}) s.t. flc,(e) = r, flcj(e) &gt; 0}l -I{e e E({v}) s.t. flc~(e) &gt; O,/~c,(e) = r -1}l.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The distribution of 2500 random locally minimum bisections for a particular random graph in GBui(100, 4, 10). The data represent 2343 distinct local minima.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>of [105] to partitioning Boolean networks with functional information. The signals directed from C/to Cj are encoded in C~. Since some of the signals might carry redundant information, this can reduce the number of signals from Ci to Cj. Corresponding logic must be added to decode (or reinterpret) these signals in C~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>vector/~ is an eigenvector of Q with eigenvalue 2 if and only if Q/~ = 2p. We denote the set of eigenvectors of Q by pl, p2 .... , p, with corresponding eigenvalues 21 ~&lt; 22 ~&lt; ... ~&lt; 2,. T We assume that the eigenvectors are normalized, i.e., for 1 ~&lt; j ~&lt; n,/~jpj I[/uijf 2 = 1. Let Aa denote the d × d diagonal eigenvalue matrix with entries 21, 22, ... , 2d, and let Ud = (#~j) denote the n × d eigenvector matrix with columns/~1,/~2 .... , Pal. Notice that Q = U,A.UX,. Some works use the eigenvectors of A instead of Q; however, the Laplacian has becoming more popular because it has the following following desirable properties (the first two due to Q being positive semi-definite) [139]:• The eigenvectors are mutually orthogonal, and hence form a basis in n-dimensional space.• Each eigenvalue 2~ of Q is real.• The smallest eigenvalue 21 =0 and has a corresponding eigenvector ~ul = [1/x/~, 1/x//-n ..... 1/x/~]x. 8 • If G is connected then 22 &gt; 0. (In general, the multiplicity of 0 as an eigenvalue of Q is equal to the number of connected components of G.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Pathological instance for spectral bisection. Each circle represents a clique of modules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>i=1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>p[[2 = II Undn UT -+-RMRVI[ z = IIA, + U, RM(U,R) II 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>is not difficult to show that IlQll 2 = IIA,II 2 which yields the desired result.which, respectively, use a~j = IN(vi)\N(vj)l 4-IN(vi)\N(vi)[ and a~ = ([N(vi)\N(vj)l 4-IN(vj)\ N(v~)l)/(lN(v~)[ + [N(vj)l); observe that these graph representations of the hypergraph do not preserve sparsity.Rendl and Wolkowicz [154]  observe that Barnes' approach "only makes sense" if</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 9 . 9 .</head><label>99</label><figDesc>Fig. 9. The 2-dimensional embedding of the (a) Primaryl and (b) Test05 MCNC benchmarks, with #2 plotted on the x-axis and/a 3 plotted on the y-axis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>., the ith row of Vd. Observe that if Y = y~'= 1 xi "Yi, then Y = xTVd. Recall that Frankle and Karp showed bipartitioning equivalent to maximizing [IxVV, I[ 2; we now have that bipartitioning is also equivalent to maximizing ]l Y ][ 2 when d = n. We therefore seek a subset of vectorsyi (corresponding to xi = 1) whose sum has the largest possible magnitude. Graph bipartitioning exactly reduces to this vector subset problem for d = n and H = 2,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>) &lt;~ U, 1 &lt;&lt;. h &lt;~ k and replace them with the pin constraints Iln(C,)f &lt;~ K and IOut(Ch)l = 1, where In(Ch) = {Vj ~ Chl3VidgCh, (Vi, Vj) ~ E} and Out(Ch) = {vi~ Chl3Vj¢Ch, (Vi, Vj) ~ E}. These4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. (a) An example DAG from [130] and (b) the clustering solution from the Lawler et al. [130] labeling algorithm assuming unit module weight and cluster size bound U = 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. (a) The star representation for a 3-pin net, (b) the application of Lawler's transformation to (a), and (c) a more efficient representation of (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Gomory-</head><label></label><figDesc>Hu cut tree construction[-77]. Such a tree is formed by finding an s-t cut {C1, Ca}, and constructing the edge (Ca, C2) between vertices Ca and Cz in the cut tree, with cost IE(C1) [. The tree is expanded recursively by picking any two modules s and t in a cluster C and computing the minimum s-t cut {C', C"} in which all modules in V -C are condensed into a single node. If this node is in C' then the vertex C in the tree is replaced with C' and the edge (C', C") is added with cost</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Example of the execution of the min-cut algorithm of [141].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Fig</head><label></label><figDesc>Fig. 15. (a) An example of a hypergraph and (b) its density flow network assuming unit module weights.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. (a) An example of a net bipartitioning of the intersection graph and (b) the bipartite conflict graph it induces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>~n= 1 W</head><label>1</label><figDesc>(Vi)Xih ~ mh. TO capture timing constraints, the authors of [173] use the n × n matrix D c = (D c) to store the maximum allowable signal routing delay between every pair of modules, and the k x k matrix D = (Do) to store the cost of routing between every pair of clusters. Hence, the timing constraints are Dnl &lt;~ Di c, 1 &lt;&lt;, h, l &lt;~ k and 1 ~&lt; i, j ~&lt; n whenever Xih = Xjl = 1. Finally, the n x k matrix P = (Pih) stores the cost of assigning a module vi to Ch. The proposed objective of Shih and Kuh is k k ~ ~, pijxij + ~ ~ ~ a,j(Xihbh, xj,),</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. (a) A bipartitioning with clock cycle T = 3 before retiming, and T = 2 after retiming (with latency 18), and (b) a bipartitioning with T = 2 and 16 units latency after retiming.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head></head><label></label><figDesc>.2) reduces to aij(XilXj2 "-~ Xi2Xjl ) i,j=l since bij = 0 if i = j. Liu et al. also adapt the same area constraints Y~7= ~ w(vi) Xih &lt;&lt;-Uh, 1 &lt;&lt;, h &lt;&lt;, k and cluster membership constraints x~l + xi2 = 1, 1 ~&lt; i ~&lt; n. If an iteration bound of L is required, the constraints l (v~ie t~(1)i) l (i,j)el2 (Xil xzj + Xi2XJ')) &lt;~ L, V I°°pS I are added. The term in large parentheses gives the total delay for a signal to traverse loop l, so the entire left term gives the iteration bound. To enforce a latency bound H, the QBP adds constraints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head></head><label></label><figDesc>ix,: ~ -E E where Oie = I X' --Xel. eeE viEe eeE vice e~E viEe gie This objective can be approximated by minimizing ~[~l(X)'~ E --1 E (X, --Xe) 2 where ge = ~ 9,e = ~ IX,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head></head><label></label><figDesc>k ~. E (Xih)C" dist(vi, wh) 2, i=1 h=l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head></head><label></label><figDesc>... , n and h = 1, 2, ..., k, if the coordinates for vi and Wh are the same, then Xih is set to 1 and xij is set to 0 for all other j ~ h. Otherwise, the new fuzzy partitioning has entry(~(dist(vi, Wh)~2/(c-l') -1 xih = ,=, \~ w-~l).], i= 1,2 .... ,n, h = 1,e .... ,k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_36"><head>Fig. 18 .</head><label>18</label><figDesc>Fig. 18. Distribution of 21,203 FM bisection solutions (i.e., local minima) for SIGDA Layout Synthesis benchmark Primary2 (3014 modules). Each solution was generated from a new random starting point.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head>Fig. 19 .</head><label>19</label><figDesc>Fig. 19. An 8-module example of (a) an agglomerative and (b) a hierarchical construction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_38"><head></head><label></label><figDesc>comparison data. For example, Riess et al. [156] were the first to present 19 benchmark results for the 45/55-constrained bipartitioning objective (i.e., L = 0.45n and U = 0.55n). The objective is of interest since ratio cut solutions tend to be highly unbalanced and hence impractical, yet exact bisections are too restrictive. This work has very quickly become a standard object of comparisons (cf. [6, 94, 190]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Frankle and Karp 1,<ref type="bibr" target="#b68">68]</ref> proposed the uniform weight (2/lel) 3/2 for linear placement with minimum squared wirelength: if the span of a net is normalized to one and edges have weight w, the total edge cost may</figDesc><table /><note><p><p><p><p><p>vary from l e[w/2 to (I e[/2)2w depending on the distribution of pins; thus, Frankle and Karp set w = (2/[el) 3/2 to minimize the worst-case deviation of cost from the square of the span (this model has also been used by</p><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b36">37]</ref></p>).</p>Tsay and Kuh 1,183]   </p>propose edge weight 2/let for minimizing squared wirelength and (2/le[) 3 for minimizing Manhattan wirelength.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>• Intersection graph: One can view the netlist partitioning problem in terms of partitioning nets instead of modules. Given such a perspective, a useful netlist representation is the intersection graph G'(V', E'), whose vertices correspond to the signal nets of the original netlist hypergraph, i.e., V'= {el, e2, ... ,e,,}. Two vertices ei, ejE ~' are adjacent if and only if einej ~ 0, i.e., the nets share a module. Early uses of this representation were in both partitioning[112]  and placement[146]. Note that the intersection graph is typically quite sparse due to module fanout limits[82].• Dual hypergraph: A slightly different net-oriented representation is the dual hypergraph</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>The</head><label></label><figDesc>Absorption objective[179]  measures the sum of the fractions of nets "absorbed" by the Ch adds absorption zero if e has only one pin in Ch, and adds absorption one if all of e's pins are in Ch. Density objective [101] maximizes the sum of cluster densities, where the density of a cluster Ch is the number of hyperedges completely contained in Ch, divided by the weight of Ch:</figDesc><table><row><cell>clusters:</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Absorption: Maximize</cell><cell>k F(P k) = ~</cell><cell>~"</cell><cell>lec~Chl-1</cell></row><row><cell></cell><cell cols="3">h=l eeELenCh~O {el-1</cell></row><row><cell cols="2">e.g., net e incident to cluster</cell><cell></cell><cell></cell></row></table><note><p>The</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>MAXGAIN, then MAXGAIN is updated to this new value. If the bucket indexed by MAXGAIN becomes empty, then MAXGAIN is decreased until it indexes a non-empty bucket.</figDesc><table><row><cell>Even when variations of the</cell></row><row><cell>pure min-cut objective are permitted (e.g., non-integral net weights), there is usually a tight bound</cell></row><row><cell>on the range of possible gain values. At the beginning of a pass, the gains for each of the n possible</cell></row><row><cell>module moves are computed in O(p) time, and each move is inserted into the data structure</cell></row><row><cell>according to its gain. The modules with highest gain are stored in the bucket with gain value</cell></row><row><cell>MAXGAIN. During an FM pass, a module is selected from this bucket and deleted from the linked</cell></row><row><cell>list; the module is moved from its current cluster and the gains of unlocked modules incident to the</cell></row><row><cell>moved module are updated. The updating of a module can be accomplished by removing it from its</cell></row><row><cell>gain bucket list and inserting it at the head of the bucket list indexed by its new gain value. If one of</cell></row><row><cell>these modules has a new gain that is larger than</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>noted that Ei=~rni are fixed constants, minimizing IIQ + PN 2 and minimizing F(P k) are equivalent partitioning objectives. The Hoffman-Wielandt inequality states that if A and B are real n × n symmetric matrices with eigenvalues cq &gt;/~2 ~ "'" ~ 0~n and/~1 t&gt;/~2/&gt; "'" &gt;//~n, respectively, then IIA -BII 2 &gt;/ ~ (~,-j~,)2.</figDesc><table /><note><p><p>n k IIQ + pl[2 = IIQII2 + 2 ~ q,jp,j + liP211 = IIQI[ 2 + 2F(P k) + ~m 2. (4.2) i,j=l i=1</p>Since IIQ[I and k 2</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>{N1, N2, ..., Nk} into a k-way module partitioning {C ~, C2, ..., Ck}. A module is in contention if it is incident to nets that are not all in the same Ni; uncontested modules with all nets in Ni become assigned to Ci.Cong et al. [49]  construct a complete bipartite graph with V1 being the set of contested modules and V2 = {Nb N2 .... ,Nk} with an edge (v, Ni) from every v~ V~ to every cluster of nets. Edges (s, v) with cost zero and capacity one are introduced Vv e V ~, and edges (N~, t) with cost zero and capacity equal to the remaining size capacity of C~ are introduced VN~. Finally, each edge (v, N~) has capacity one and cost equal to</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements References</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Dennis Jen-Hsin Huang, Lars W. Hagen, Kenneth D. Boese and Bernhard M. Riess for their contributions to this review, and Albert Chung-Wen Tsao and Sudhakar Muddu for drawing figures. We also thank Martin D.F. Wong, Chung-Kuan Cheng, Pak K. Chan, Anthony Vannelli, Youssef Saab, and many others who made early versions of their works available to us. Finally, we thank James Hwang, Jon Frankle, Patrick Ciarlet and the anonymous reviewers for their helpful comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>C. <ref type="bibr">~L Alpert, A.B. Kahng / INTEGRATION, the VLSI Journal 19 (1995)</ref>  <ref type="bibr">1 81</ref> Ratio cut: Chou et al. <ref type="bibr" target="#b43">[44]</ref> and <ref type="bibr">Wei and Cheng [188]</ref> have constructed clusterings based on the ratio cut objective. The algorithm of <ref type="bibr" target="#b43">[44]</ref> applies the ratio cut algorithm of <ref type="bibr">[187]</ref> to construct a bipartitioning {C1, C2} such that I C, I ~&lt; u for some small U, e.g., U = 50. Cluster Ca is then removed from the circuit and the algorithm is repeated until the circuit has less than U modules. The strategy of finding a good cluster and "peeling" it from the circuit has been used in <ref type="bibr">[101]</ref> for the Density objective (see Section 5.2). <ref type="bibr">Chou et al.</ref> apply their clusterings to the FPGA Set Covering formulation discussed in Section 5.5. The ratio cut clustering approach of <ref type="bibr">Wei and Cheng [188]</ref> iteratively applies the bipartitioning algorithm of <ref type="bibr">[187]</ref> to the largest remaining cluster; this top-down divisive process ends when the largest cluster contains less than 2% of the modules, and seems to be the only "top-down clustering" approach in the literature. The clustering solutions were originally integrated within two-phase FM, and later used in a simulated-annealing based placement algorithm <ref type="bibr">[90]</ref>.</p><p>Absorption: <ref type="bibr">Sun and Sechen [179]</ref> believe that clusterings which maximize the Absorption objective are best suited for use in the TimberWolf simulated annealing-based placement program. They used L = 3Y and U = 30Y for the cluster size constraints L &lt;&lt;, w(Ch) &lt;&lt;. U, 1 &lt;~ h &lt;&lt;, k where 10Y is a designated mean cluster size, but they did not specify how Y is determined. TimberWolfs placement neighborhood structure is based on swapping clusters, hence the need for size constraints: too much variance in cluster sizes may make the placement solution infeasible. The clustering algorithm itself also uses simulated annealing, with a neighborhood structure based on moving a single module from one cluster to another. The authors claim that 100n moves are sufficient to optimize Absorption.</p><p>Ordering contiguity: <ref type="bibr">Alpert and Kahng [4]</ref> proposed constructing a linear ordering of the modules, then constructing a clustering by splitting the ordering. The intuition is that if the ordering can appropriately traverse the circuit, then the clustering will be of high quality. Their WINDOW ordering scheme begins with an empty cluster C and iteratively adds the module with highest attraction to the cluster, where the attraction function is defined to reflect a given objective. The authors of [4] have given attraction functions for a variety of objectives, including Scaled Cost and Absorption. In addition, they showed how attraction can capture breadth-first and depth-first orderings, along with "max-adjacency" and "min-perimeter" criteria (cf. the <ref type="bibr">Nagamochi and lbaraki discussion [141]</ref> in Section 5.2). Since C eventually becomes much larger than is desired for any single cluster, only a window of the most recently ordered modules is used to compute the attraction; the size of the window reflects cluster size constraints. The ordering is split into a clustering using the DP-RP algorithm discussed in Section 4.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">5. Clustering of boolean networks</head><p>The final three approaches all exploit the directed structure of combination boolean networks.</p><p>Corollas: <ref type="bibr">Dey et al. [55,</ref><ref type="bibr" target="#b56">56]</ref> construct a directed "star" representation for a combinational boolean network by introducing a dummy stem module v(e) for each net e. For every e E E, the DAG contains edges (S(e), v(e)) and (v~e), w) for every w ~ D(e). Observe that stems are the only modules with multiple fan-outs, i.e., a stem v(e) may have edges (v(e), u), (v(e), w), u ~ w. If there exist two disjoint paths from a stem to another module, the stem is called a reconvergentfanout stem, and the   </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Connectionist Machine for Genetic Hillclimbing</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Ackley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Ahuja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Magnanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Orlin</surname></persName>
		</author>
		<title level="m">Network Flows: Theory, Algorithms, and Applications</title>
		<meeting><address><addrLine>Englewood Cliffs, N J</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Geometric embeddings for faster and better multi-way netlist partitioning</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Alpert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="743" to="748" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A general framework for vertex orderings, with applications to netlist clustering</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Alpert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer-Aided Design</title>
		<meeting>IEEE Internat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="63" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multi-way partitioning via spacefilling curves and dynamic programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Alpert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="652" to="657" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Spectral partitioning: the more eigenvectors, the better</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Alpert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Z</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="195" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A graph partitioning heuristic for the parallel pseudo-exhaustive logical test of VLSI combinational circuits</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Andreatta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Ribeiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="36" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Advanced search techniques for circuit partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Areibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">DIMACS Series in Discrete Mathematics and Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="page" from="77" to="98" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Circuit partitioning using a tabu search approach</title>
		<author>
			<persName><forename type="first">S</forename><surname>Areibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Internat. Syrup. Circuits and Systems</title>
		<imprint>
			<biblScope unit="page" from="1643" to="1646" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A combined eigenvector tabu search approach for circuit partition</title>
		<author>
			<persName><forename type="first">S</forename><surname>Areibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Custom Integrated Circuits Conf</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An efficient solution to circuit partitioning using tabu search and genetic algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Areibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Internat. Conf. of Micro Electronics</title>
		<meeting>6th Internat. Conf. of Micro Electronics<address><addrLine>Istanbul</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="70" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Two-way graph partitioning by principal components</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Arun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">B</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Symp. Circuits and Systems</title>
		<meeting>IEEE lnternat. Symp. Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="2877" to="2880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">New heuristics and lower bounds for graph partitioning</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Arun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">B</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Symp. Circuits and Systems</title>
		<meeting>IEEE Internat. Symp. Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="1172" to="1175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multicommodity flows: a survey of recent research</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leighton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Internat. Symp. Algorithms and Computation</title>
		<meeting>4th Internat. Symp. Algorithms and Computation</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="297" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Bakoglu</surname></persName>
		</author>
		<title level="m">Circuits, Interconnections, and Packaging for VLSI</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fuzzy partitioning applied to VLSl-floorplanning and placement</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Mlynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Symp. Circuits and Systems</title>
		<meeting>IEEE lnternat. Symp. Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="177" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A fast multilevel implementation of recursive spectral bisection for partitioning unstructured problems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Barnard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Simon</surname></persName>
		</author>
		<idno>RNR-92-033</idno>
	</analytic>
	<monogr>
		<title level="j">NASA</title>
		<imprint>
			<date type="published" when="1992-11">November 1992</date>
			<pubPlace>Ames</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An algorithm for partitioning the nodes of a graph</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Barnes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Algebraic Discrete Methods</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">550</biblScope>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A new heuristic for partitioning the nodes of a graph</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Q</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Discrete Math</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="299" to="305" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Heuristics based on spacefilling curves for combinatorial problems in euclidean space</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Bartholdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Platzman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manaqement Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">305</biblScope>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Iterated descent: a better algorithm for local search in combinatorial optimization problems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Baum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Neural Information Processing Systems</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Touretzky</surname></persName>
		</editor>
		<meeting>Neural Information essing Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An algorithm for improving partitions of pin-limited multi-chip systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Beardslee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="378" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Berge</surname></persName>
		</author>
		<title level="m">Graphs and Hypergraphs</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>American Elsevier</publisher>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Near-optimal placement using a quadratic objective function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Blanks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="609" to="615" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A new adaptive multi-start technique for combinatorial global optimizations</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Boese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muddu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res. Lett</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="101" to="113" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Random Graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollobas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Eigenvalues and graph bisection: an average case analysis</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Boppana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Syrup. Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="page" from="280" to="285" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mcmullen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<title level="m">Logic Minimization Algorithms for VLSI Synthesis</title>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Graph bisection algorithms with good average case behavior</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorica</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="191" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Improving the performance of the Kernighan-Lin and simulated annealing graph bisection algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Heigham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leighton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="775" to="778" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A fast and stable hybrid genetic algorithm for the ratio-cut partitioning problem on hypergraphs</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="664" to="669" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A genetic algorithm for a special class of the quadratic assignment problem</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">DIMACS Series in Discrete Mathematics and Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="99" to="116" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">circuit partitioning using parallel mean field annealing algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bultan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aykanat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symp. Parallel and Distributed Processing</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="534" to="541" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Heuristic for quadratic boolean programs with applications to quadratic assignment</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Burkard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bonniger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="372" to="386" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient implementation of the fuzzy c-means clustering algorithms</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Cannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Bezdek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="248" to="255" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A global router using an efficient approximate multicommodity multiterminal flow algorithm</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Carden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="316" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Spectral k-way ratio-cut partitioning and clustering</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D F</forename><surname>Schlag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Zien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1088" to="1096" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D F</forename><surname>Schlag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Zien</surname></persName>
		</author>
		<title level="m">Spectral based multi-way FPGA partitioning, Proc. ACM/SIGDA Internat. Workshop on Field-Programmable Gate Arrays</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="133" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Genetic algorithm for node partitioning problem and applications in VLSI design</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chandrasekharam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Subhramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. E (Comput. Digital Techniques)</title>
		<imprint>
			<biblScope unit="volume">140</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="255" to="260" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Efficient partitioning of components</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Charney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Plato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Workshop</title>
		<meeting>Design Automation Workshop</meeting>
		<imprint>
			<date type="published" when="1968">1968</date>
			<biblScope unit="page" from="16" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A new simultaneous circuit partitioning and chip placement approach based on simulated annealing</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hartley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="36" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A graph partitioning problem for multiple-chip design</title>
		<author>
			<persName><forename type="first">Y.-P</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proc. IEEE lnternat. Syrup. Circuits and Systems</title>
		<imprint>
			<biblScope unit="page" from="1778" to="1781" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The optimal partitioning of networks</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="297" to="315" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Circuit partitioning for huge logic emulation systems</title>
		<author>
			<persName><forename type="first">N.-C</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-J</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lindelof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="244" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">An optimal technology mapping algorithm for delay optimization in lookup-table based FPGA designs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer-Aided Design</title>
		<meeting>IEEE Internat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="48" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">On area/depth trade-off in LUT-based FPGA technology mapping</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="213" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Alpert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName><surname>Lntegration</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">the VLSI Journal I</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">81</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Random walks for circuit clustering</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<idno>14.2.1-14.2.4</idno>
	</analytic>
	<monogr>
		<title level="m">Proc, IEEE lnternat. ASIC Conf</title>
		<meeting>IEEE lnternat. ASIC Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Net partitions yield better module partitions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="47" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Multi-way VLSI circuit partitioning based on dual net representation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Labio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shivakumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer-Aided Design</title>
		<meeting>IEEE Internat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="56" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Acyclic multi-way partitioning of boolean networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bagrodia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="670" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A parallel bottom-up clustering algorithm with applications to circuit partitioning in VLSI design</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proe. ACM/1EEE Design Automation Conf</title>
		<imprint>
			<biblScope unit="page" from="755" to="760" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Improved multiple-way circuit partitioning algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dasdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aykanat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIGDA Internat. Workshop on Field-Programmable Gate Arrays</title>
		<meeting>ACM/SIGDA Internat. Workshop on Field-Programmable Gate Arrays</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kelly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-07">July 1993</date>
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Graph partitioning usng annealed neural networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Van Den Bout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Neural Networks</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">203</biblScope>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Corolla based circuit partitioning and resynthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/1EEE Design Automation Conf</title>
		<meeting>ACM/1EEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="607" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Partitioning sequential circuits for logic optimization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer Design</title>
		<meeting>IEEE lnternat. Conf. Computer Design</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="70" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Placement and average interconnection lengths of computer logic</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Donath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Systems CAS</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="272" to="277" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Logic partitioning</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Donath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Physical Design Automation of VLSI Systems</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Lorenzetti</surname></persName>
		</editor>
		<meeting><address><addrLine>Benjamin/Cummings, Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="65" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Lower bounds for the partitioning of graphs, 1</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Donath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Hoffman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BM J. Res. Develop</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="420" to="425" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A procedure for layout of standard-cell VLSI circuits</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Dunlop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="92" to="98" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">New faster Kernighan-Lin type graph-partitioning algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="370" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Partitioning of opto-electronic multichip modules</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Catanzaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Multi-Chip Module Conf</title>
		<meeting>IEEE Multi-Chip Module Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="138" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A class of bounded approximation algorithms for graph partitioning</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Feo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Khellaf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="181" to="195" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Connectivity of random logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Feuer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput. C</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">33</biblScope>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">A linear time heuristic for improving network partitions</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Fiduccia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Mattheyses</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/1EEE Design Automation Conf</title>
		<meeting>ACM/1EEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="175" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Ford</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Fulkerson</surname></persName>
		</author>
		<title level="m">Flows in Networks</title>
		<meeting><address><addrLine>Princeton</addrLine></address></meeting>
		<imprint>
			<publisher>Princeton Univ. Press</publisher>
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m" type="main">Circuit placement methods using multiple eigenveetors and linear probe techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>UC Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Circuit placement and cost bounds by eigenvector decomposition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="414" to="417" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Finding clusters in VLSI circuits</title>
		<author>
			<persName><forename type="first">J</forename><surname>Garbers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Promel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Steger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Internat. Conj. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="520" to="523" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<title level="m">Computers and Intractability: A Guide to the Theory of NP Completeness</title>
		<meeting><address><addrLine>Freeman, San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title level="m" type="main">Optimal VLSI Architectural Synthesis: Area, Performance, and Testability</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Gebotys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Elmasry</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Stochastic relaxation, Gibbs distributions, and the Bayesian restoration of images</title>
		<author>
			<persName><forename type="first">S</forename><surname>Geman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="721" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Wright</surname></persName>
		</author>
		<title level="m">Practical Optimization</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Tabu Search-Part I</title>
		<author>
			<persName><forename type="first">F</forename><surname>Glover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA J. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="190" to="206" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Heuristic improvement technique for bisection of VLSI networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer Design</title>
		<meeting>IEEE Internat. Conf. Computer Design</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="122" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I~</forename><surname>Tardos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<idno>STAN-CS-89-1252</idno>
		<title level="m">Network flow algorithms</title>
		<imprint>
			<publisher>Stanford University CS Dept</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Multi-terminal network flows</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gomory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. SlAM</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="551" to="570" />
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Simulated annealing without rejected moves</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Supowit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer Design</title>
		<meeting>IEEE Internat. Conf. Computer Design</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="658" to="663" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">On implementation choices for iterative improvement partitioning algorithms</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Hadley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">W</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page">885</biblScope>
			<date type="published" when="1992">1992. 1995</date>
		</imprint>
	</monogr>
	<note>IEEE Trans. Comput.-Aided Des. submitted</note>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Quantified suboptimality of VLSI layout heuristics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">.-H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/1EEE Desi9 n Automation Conf</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="216" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Fast spectral methods for ratio cut partitioning and clustering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="10" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Improving the quadratic objective function in module placement</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. ASIC Conf</title>
		<meeting>IEEE Internat. ASIC Conf</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="42" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">A new approach to effective circuit clustering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="422" to="427" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">New spectral methods for ratio cut partitioning and clustering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page">1085</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Combining problem reduction and adaptive multi-start: a new technique for superior iterative partitioning</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">On the intrinsic rent parameter and spectra-based partitioning methodologies</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Kurdahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ramachandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="37" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Cooling schedules for optimal annealing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hajek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="311" to="329" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">An r-dimensional quadratic placement algorithm</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Hall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management Sci</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="219" to="229" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">A wire length estimation technique utilizing neighborhood density equations</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hamada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="57" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">A study of placement techniques</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Wolff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Agule</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Des. Automation Fault-Tolerant Comput</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">61</biblScope>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">A faster algorithm for finding the minimum cut in a graph</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Orlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIAM Syrup</title>
		<meeting>ACM/SIAM Syrup<address><addrLine>Orlando</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="165" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Minimum fault coverage in reconfigurable arrays</title>
		<author>
			<persName><forename type="first">N</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Symp. on Fault-Tolerant Computing Systems</title>
		<meeting>IEEE Internat. Symp. on Fault-Tolerant Computing Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="248" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">An evaluation of bipartitioning techniques</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hauck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Borriello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Chapel Hill Con</title>
		<meeting>Chapel Hill Con</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Logic partition orderings for multi-FPGA systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hauck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Borriello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIGDA Internat. Workshop on Field-Programmable Gate Arrays</title>
		<meeting>ACM/SIGDA Internat. Workshop on Field-Programmable Gate Arrays</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="32" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<monogr>
		<title level="m" type="main">An improved spectral graph partitioning algorithm for mapping parallel computations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hendrickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Leland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-09">September 1992</date>
		</imprint>
		<respStmt>
			<orgName>Sandia National Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">The dynamic locking heuristic a new graph partitioning algorithm</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Hoffman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Symp. Circuits and Systems</title>
		<meeting>IEEE Internat. Symp. Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="173" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<monogr>
		<title level="m" type="main">Adaptation in Natural and Artificial Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Holland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>University of Michigan Press</publisher>
			<pubPlace>Ann Arbor, MI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Multiterminal flows in a hypergraph</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Moerder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLSI Circuit Layout: Theory and Design</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Kuh</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="87" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Multi-way system partitioning into single or multiple type FPGAs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">.-H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIGDA lnternat. Workshop on Field-Programmable Gate Arrays</title>
		<meeting>ACM/SIGDA lnternat. Workshop on Field-Programmable Gate Arrays</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="140" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">When clusters meet partitions: new density-based methods for circuit decomposition</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">.-H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Design and Test Con</title>
		<meeting>European Design and Test Con</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="60" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Circuit partitioning with genetic algorithms using a coding scheme to preserve the structure of the circuit, Parallel Problem Solving from</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hulin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="page" from="75" to="79" />
			<date type="published" when="1990">1990</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Optimal replication for min-cut partitioning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">El</forename><surname>Gamal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="432" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Optimal replication for min-cut partitioning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gamal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="106" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Exploiting communication complexity for multilevel logic synthesis</title>
		<author>
			<persName><forename type="first">T.-T</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1017" to="1027" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Modeling hypergraphs by graphs with the same mincut properties</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ihler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett. 4fi</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="171" to="175" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Finding uni-directional cuts based on physical partitioning and logic restructuring</title>
		<author>
			<persName><forename type="first">S</forename><surname>Iman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fabian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIGDA Physical Design Workshop</title>
		<meeting>ACM/SIGDA Physical Design Workshop<address><addrLine>Los Angeles</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="187" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">The weighted graph-bi-partitioning problem: a look at GA performance, Parallel Problem Solving from</title>
		<author>
			<persName><forename type="first">H</forename><surname>Inayoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Manderick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="page" from="617" to="625" />
			<date type="published" when="1992">1992</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Local optimization and the traveling salesman problem</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Internat. Colloq. on Automata, Languages and Programming</title>
		<meeting>17th Internat. Colloq. on Automata, Languages and Programming</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="446" to="460" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing: an experimental evaluation, Part I, graph partitioning</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Aragon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mcgeoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schevon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="865" to="892" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Hierarchical clustering schemes</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychometrika</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="241" to="254" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Fast hypergraph partition</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="762" to="766" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">A fast heuristic for hypergraph bisection</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kamidoi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wakabayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Miyao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proc. IEEE lnternat. Syrup. Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1160" to="1163" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Global min cuts in RNC, and other ramifications of a simple min-cut algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/SIAM Syrup. Discrete Algorithms</title>
		<meeting>ACM/SIAM Syrup. Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Karloff</surname></persName>
		</author>
		<title level="m">Linear Programming</title>
		<meeting><address><addrLine>Basel</addrLine></address></meeting>
		<imprint>
			<publisher>Birkhauser</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Toward a general theory of adaptive walks on rugged landscapes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kauffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Theoret. Biol</title>
		<imprint>
			<biblScope unit="volume">128</biblScope>
			<biblScope unit="page">45</biblScope>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">An efficient heuristic procedure for partitioning graphs, Bell System Tech</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="291" to="307" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Yield-based system partitioning strategies for MCM and SEM design</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Madisetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proc. IEEE lnternat. Syrup. Circuits and Systems</title>
		<imprint>
			<biblScope unit="page" from="144" to="149" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Gelatt</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Vecchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">220</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">GORDIAN: VLSI placement by quadratic programming and slicing optimization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Kleinhans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sigl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Johannes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Antreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="356" to="365" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">Benchmarks of layout synthesis-evolution and current status</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kozmifiski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="265" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">A cell-replicating approach to mincut-based circuit partitioning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Newton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer-Aided Design</title>
		<meeting>IEEE Internat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="2" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<analytic>
		<title level="a" type="main">An improved min-cut algorithm for partitioning VLSI networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">446</biblScope>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">Constructing test cases for partitioning heuristics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Comput. C</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1112" to="1114" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">Cost minimization of partitions into multiple devices</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ku2nar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kozmifiski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="315" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Multi-way netlist partitioning into heterogeneous FPGAs and minimization of total device cost and interconnect</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ku~nar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zajc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/1EEE Design Automation Conf</title>
		<meeting>ACM/1EEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="238" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J M</forename><surname>Laarhoven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H L</forename><surname>Aarts</surname></persName>
		</author>
		<title level="m">Simulated Annealing: Theory and Applications</title>
		<meeting><address><addrLine>Reidel, Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">On a pin versus block relationship for partition of logic graphs, 1</title>
		<author>
			<persName><forename type="first">B</forename><surname>Landman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Russo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page">1469</biblScope>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</author>
		<title level="m">Combinatorial Optimization: Networks and Matroids</title>
		<meeting><address><addrLine>Holt, Rinehart, and Winston; New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">Module clustering to minimize delay in digital networks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Levitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="47" to="57" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">Approximation algorithms for VLSI partition problems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Makedon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tragoudas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Symp. Circuits and Systems</title>
		<meeting>IEEE lnternat. Symp. Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="2865" to="2868" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">An approximate max-flow min-cut theorem for uniform multicommodity flow problems with applications to approximation algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Foundations of Computer Science</title>
		<meeting>IEEE Symp. Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="422" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Lengauer</surname></persName>
		</author>
		<title level="m">Combinatorial Algorithms for Integrated Circuit Layout</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley-Teubner</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Graph partitioning using tabu search</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-M</forename><surname>Chee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Internat. Syrup. Circuits and Systems</title>
		<imprint>
			<biblScope unit="page" from="1164" to="1167" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">A replication cut for two-way partitioning</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="623" to="630" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">Data flow partitioning for clock period and latency minimization</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="658" to="663" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">Performance driven partitioning using retiming and replication</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N.-C</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ku</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="296" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<monogr>
		<title level="m" type="main">The maximum concurrent flow problem and sparsest cuts</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Matula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Shahrokhi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-03">March 1986</date>
		</imprint>
		<respStmt>
			<orgName>Southern Methodist Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">The Laplacian spectrum of graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mohar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Theory, Combinatorics, and Applications</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Alavi</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="871" to="898" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<analytic>
		<title level="a" type="main">On clustering for minimum delay/area</title>
		<author>
			<persName><forename type="first">R</forename><surname>Murgai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="6" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">Computing edge-connectivity in multigraphs and capacitated graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ibaraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Discrete Math</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="54" to="66" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Newton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-04">April 1991</date>
		</imprint>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b142">
	<analytic>
		<title level="a" type="main">Improvements of a mincut partition algorithm</title>
		<author>
			<persName><forename type="first">T.-K</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Oldfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pitchumani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer-Aided Design</title>
		<meeting>IEEE Internat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="470" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<analytic>
		<title level="a" type="main">An efficient algorithm for VLSI network partitioning problem using a cost function with balancing factor</title>
		<author>
			<persName><forename type="first">C.-I</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-B</forename><surname>Part</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1686" to="1694" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">Neural networks and NP-complete optimization problems; a performance study on the graph bisection problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Complex Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="89" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<analytic>
		<title level="a" type="main">A quadratic metric with a simple solution scheme for initial placement</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Pillage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Rohrer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="324" to="329" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Pissanetsky</surname></persName>
		</author>
		<title level="m">Sparse Matrix Technology</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<analytic>
		<title level="a" type="main">Partitioning sparse matrices with eigenvectors of graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pothen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Liou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SlAM J. Matrix Anal. Appl</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">452</biblScope>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<monogr>
		<title level="m">Physical Design Automation of VLSI Systems</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Preas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Lorenzetti</surname></persName>
		</editor>
		<meeting><address><addrLine>Benjamin/Cummings, Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Shamos</surname></persName>
		</author>
		<title level="m">Computational Geometry: An Introduction</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b150">
	<analytic>
		<title level="a" type="main">Optimal clustering for delay minimization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">309</biblScope>
			<biblScope unit="page">314</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b151">
	<analytic>
		<title level="a" type="main">The use and interpretation of principal component analysis in applied research</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sankhya Ser. A</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="329" to="358" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b152">
	<analytic>
		<title level="a" type="main">A fuzzy C-means clustering placement algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Razaz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Symp. Circuits and Systems</title>
		<meeting>IEEE lnternat. Symp. Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="2051" to="2054" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b153">
	<monogr>
		<title level="m" type="main">A projection technique for partitioning the nodes of a graph</title>
		<author>
			<persName><forename type="first">F</forename><surname>Rendl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wolkowicz</surname></persName>
		</author>
		<editor>B.M. Riess</editor>
		<imprint>
			<date type="published" when="1994-05">May 1994. February 1995</date>
		</imprint>
		<respStmt>
			<orgName>University of Waterloo</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b154">
	<analytic>
		<title level="a" type="main">Partitioning very large circuits using analytical placement techniques</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Riess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Doll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Johannes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="646" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b155">
	<monogr>
		<title level="m" type="main">A new k-way partitioning approach for multiple types of FPGAs</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Riess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Giselbrecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wurth</surname></persName>
		</author>
		<idno>TUM-LRE-95-2</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>Technical University of Munich</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b156">
	<analytic>
		<title level="a" type="main">Architecture driven k-way partitioning for multichip modules</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Riess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Schoene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Design and Test Conf</title>
		<meeting>European Design and Test Conf</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="71" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b157">
	<analytic>
		<title level="a" type="main">A timing-driven N-way chip and multi-chip partitioner</title>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sechen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="240" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b158">
	<analytic>
		<title level="a" type="main">A fast and robust network bisection algorithm</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Saab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b159">
	<analytic>
		<title level="a" type="main">New methods for construction of test cases for partitioning heuristics, Progress VLSI Des., to appear. Y. Saab and V. Rag, Fast effective heuristics for the graph bisectioning problem</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Saab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="91" to="98" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b160">
	<analytic>
		<title level="a" type="main">On the graph bisection problem</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Saab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Systems</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="760" to="762" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b161">
	<analytic>
		<title level="a" type="main">Multiple-way network partitioning</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Sanchis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="62" to="81" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b162">
	<analytic>
		<title level="a" type="main">Multiple-way network partitioning with different cost functions</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Sanchis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">22</biblScope>
			<biblScope unit="page" from="1500" to="1504" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b163">
	<analytic>
		<title level="a" type="main">Finding k-cuts within twice the optimal</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">V</forename><surname>Vazirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Syrup. Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="page" from="743" to="751" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b164">
	<analytic>
		<title level="a" type="main">Partitioning with cone structures</title>
		<author>
			<persName><forename type="first">G</forename><surname>Saucier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brasen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Hiol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Comput.-Aided Des</title>
		<meeting>IEEE lnternat. Conf. Comput.-Aided Des</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="236" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b165">
	<analytic>
		<title level="a" type="main">Clustering and linear placement</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Schuler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Ulrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="50" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b166">
	<analytic>
		<title level="a" type="main">A proper model for the partitioning of electrical circuits</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Schweikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="57" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b167">
	<analytic>
		<title level="a" type="main">An improved objective function for mincut circuit partitioning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sechen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="502" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b168">
	<monogr>
		<title level="m" type="main">Algorithms for VLS1 Physical Design Automation</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Sherwani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b169">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Shih</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b170">
	<analytic>
		<title level="a" type="main">Quadratic boolean programming for performance-driven system partitioning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kuh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="761" to="765" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b171">
	<analytic>
		<title level="a" type="main">Performance-driven system partitioning on multi-chip modules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kuh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R.-S</forename><surname>Tsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM IEEE Design Automation Conf</title>
		<meeting>ACM IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="53" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b172">
	<analytic>
		<title level="a" type="main">Timing-driven system partitioning by constraints decoupling method</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kuh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R.-S</forename><surname>Tsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Multi-Chip Module Conf</title>
		<meeting>IEEE Multi-Chip Module Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="164" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b173">
	<analytic>
		<title level="a" type="main">A simple yet effective technique for partitioning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. VLSI Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="380" to="386" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b174">
	<analytic>
		<title level="a" type="main">Analytical placement: a linear or a quadratic objective function?</title>
		<author>
			<persName><forename type="first">G</forename><surname>Sigl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Doll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Johannes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="427" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b175">
	<analytic>
		<title level="a" type="main">An algorithm for quadrisection and its application to standard cell placement</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Suaris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Systems</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="294" to="303" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b176">
	<analytic>
		<title level="a" type="main">Efficient and effective palcements for very large circuits</title>
		<author>
			<persName><forename type="first">W</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sechen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="170" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b177">
	<analytic>
		<title level="a" type="main">An efficient tabu search algorithm for graph bisectioning</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Thulasiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N S</forename><surname>Swamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Great Lakes Symp. VLSI</title>
		<meeting>Great Lakes Symp. VLSI</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="92" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b178">
	<analytic>
		<title level="a" type="main">A new approach of fractal-dimension based module clustering for VLSI layout</title>
		<author>
			<persName><forename type="first">M</forename><surname>Toyonaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-T</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Akino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Shirakawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proc. IEEE lnternat. Syrup. Circuits and Systems</title>
		<imprint>
			<biblScope unit="page" from="185" to="188" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b179">
	<analytic>
		<title level="a" type="main">An improved algorithm for the generalized rain-cut partitioning problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tragoudas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Great Lakes Syrup</title>
		<meeting>Great Lakes Syrup</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="242" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b180">
	<analytic>
		<title level="a" type="main">A unified approach to partitioning and placement</title>
		<author>
			<persName><forename type="first">R.-S</forename><surname>Tsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Kuh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Circuits Systems</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="521" to="533" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b181">
	<analytic>
		<title level="a" type="main">A Gomory-Hu cut tree representation of a netlist partitioning problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Hadley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Systems</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1133" to="1139" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b182">
	<analytic>
		<title level="a" type="main">A constrained clustering approach for partitioning netlists</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vannelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Rowan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th Midwest Symp. on Circuits and Systems</title>
		<meeting>28th Midwest Symp. on Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="211" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b183">
	<analytic>
		<title level="a" type="main">Generalization of min-cut partitioning to tree structures and its applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Vijayan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="307" to="314" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b184">
	<analytic>
		<title level="a" type="main">Towards efficient hierarchical designs by ratio cut partitioning</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. Computer-Aided Design</title>
		<meeting>IEEE Internat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="298" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b185">
	<analytic>
		<title level="a" type="main">An improved two-way partitioning algorithm with stable performance</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1502" to="1511" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b186">
	<analytic>
		<title level="a" type="main">An efficient method of partitioning circuits for multiple-FPGA implementation</title>
		<author>
			<persName><forename type="first">N.-S</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="202" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b187">
	<analytic>
		<title level="a" type="main">Efficient network flow based min-cut balanced partitioning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="50" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b188">
	<analytic>
		<title level="a" type="main">Circuit clustering for delay minimization under area and pin constraints</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Design and Test Conf</title>
		<meeting>European Design and Test Conf</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b189">
	<analytic>
		<title level="a" type="main">Optimal wiring minimization for partitioned circuits with least replication, manuscript, 1995</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">; C.-W</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-T</forename><forename type="middle">Y</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE lnternat. Conf. Computer-Aided Design</title>
		<meeting>IEEE lnternat. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="428" to="431" />
		</imprint>
	</monogr>
	<note>A probabilistic multi-commodity flow solution to circuit clustering problems</note>
</biblStruct>

<biblStruct xml:id="b190">
	<analytic>
		<title level="a" type="main">A general purpose, multiple-way partitioning algorithm</title>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-T</forename><forename type="middle">Y</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1480" to="1487" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b191">
	<analytic>
		<title level="a" type="main">Optimization by iterative improvement: an experimental evaluation on two-way partitioning</title>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-T</forename><forename type="middle">Y</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="145" to="153" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b192">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Zimmerman</surname></persName>
		</author>
		<title level="m">Fuzzy Set Theory and its Applications</title>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Nlijhoff</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
