<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Formal Program Construction by Transfomations-Computer-Aided, Intuition-Guided Programming I65</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Friedrich</forename><forename type="middle">Ludwig</forename><surname>Bauer</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bernhard</forename><surname>Moller</surname></persName>
						</author>
						<author>
							<persName><roleName>AND</roleName><forename type="first">Helmut</forename><surname>Partsch</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Pepper</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Germany</forename><forename type="middle">H</forename><surname>Partsch</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institut fur Informatik</orgName>
								<orgName type="institution">Tech-nische Universitat Munchen</orgName>
								<address>
									<addrLine>Postfach 20 24 20</addrLine>
									<postCode>D-8000</postCode>
									<settlement>Munchen 2, West</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Faculty for Mathematics and Science</orgName>
								<orgName type="institution">University of Nijmegen</orgName>
								<address>
									<postCode>NL-6525 ED</postCode>
									<settlement>Nijme-gen</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Fachbereich Informatik</orgName>
								<address>
									<addrLine>Technische Universitat Berlin</addrLine>
									<postCode>D-1000</postCode>
									<settlement>Berlin IO</settlement>
									<region>West Germany</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Formal Program Construction by Transfomations-Computer-Aided, Intuition-Guided Programming I65</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">393803D01765BBDC4AEDDD926D86F9FB</idno>
					<note type="submission">received January 31, 1984; revised August 31, 1988.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Algebraic specification</term>
					<term>formal semantics</term>
					<term>formal specification</term>
					<term>language design</term>
					<term>program correctness</term>
					<term>programming methodology</term>
					<term>program transformation</term>
					<term>software engineering</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Formal program construction by transformations is a method of software development in which a program is derived from a formal problem specification by manageable, controlled transformation steps which guarantee that the final product meets the initial specification. This methodology has been investigated in the Munich project CIP (computer-aided, intuition-guided programming). The research includes the design of a wide-spectrum language specifically tailored to the needs of transformational programming, the construction of a transformation system to support the methodology, and the study of transformation rules and other methodological issues. Particular emphasis has been laid on developing a sound theoretical basis for the overall approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>N the widest sense, programming means to find an ef-I ficient zilgorithm that solves a given problem. Theproblem frequently comes in the form of a bunch of half-baked wishes being vaguely defined and not very detailed, whereas the solving algorithm, also termed "product," has to be precisely deiined and fully operational. How to safely bridge the gap between these two extremes is the major concern of programming methodology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Formal Program Construction</head><p>The traditional way of "programming in one blast" has, among others, two severe drawbacks: such a big step is very hard to perform, to survey, and to verify, and frequently the product does not really solve the original problem; the one actually solved by the product is never explicitly specified.</p><p>These drawbacks were recognized a long time ago [33] and led to the idea of "software engineering." Software enginewing aims at using principles common to other engineering disciplines also for the development of software. In particular, it advocates an organizational decomposition of the software development process into smaller steps which are further characterized by underlying "life cycle models" (cf., e.g., <ref type="bibr">[37]</ref>). Each of these life cycle models at least contains a precise definition of the problem as an intermediate stage, thus breaking the whole process into two major parts, requirements engineering and program construction (the latter being usually called "coding and testing").</p><p>In principle, we follow this idea; however, we additionally assume that the problem is described in terms of a formal language as shown in Fig. <ref type="figure" target="#fig_0">1</ref>. This "separation of concerns" allows early validation (i.e., comparing the formal specification with the customer's wishes), and thus prevents useless programming work. (Note that, differently from traditional software engineering, no distinction is made between requirements specification and design specification.)</p><p>However, both steps are still fairly big. Whereas currently very little is known about how to reduce the complexity of the requirements engineering task, in the case of program construction it seems rather straightforward to introduce further intermediate stages as shown in Fig. <ref type="figure">2</ref>.</p><p>Thus, starting from a precisely defined, but not very detailed formal specification one finally obtains a fully detailed program by a stepwise addition of details that result from design decisions.</p><p>In the classical approach of " stepwise refinement" <ref type="bibr" target="#b72">[84]</ref>, the transitions between intermediate versions are done intuitively, without formal restrictions and without a rigid basis. This approach, however, again has disadvantages:</p><p>in order to ensure correctness of the resulting program, verification is necessary after each step;</p><p>verification is problem-dependent, i.e., it has to be done anew for each new problem.</p><p>The consequent next step now is to forbid formal transitions, and to allow only formal, provably semantics-preserving transitions. This is the basic idea of transformational programming. Obviously, this approach has a number of decisive advantages: the final program is correct by construction; the transitions can be described by schematic rules and thus be reused for whole classes of problems; due to formality the whole process of program development can be supported by the computer; the overall structure of the program is no longer fixed throughout the development process, so that the approach is quite flexible. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Approach of the Project CIP</head><p>The objective of the Munich project CIP (computeraided, intuition-guided programming, [6]) is to develop along the idea of transformational programming an integrated environment, including methodology, language, and system for the construction of "correct" software, that is, of software that is guaranteed by formal rules to meet its specification.</p><p>Due to different specific intentions and aims there are various technically different approaches to transformational programming (for overviews, cf. [71], [38]). In the particular view of the CIP project, program development is an evolutionary process [6] that usually starts with the formal problem specification (the "contract" [9]) and ends with an executable program for the intended target machine. The individual transitions between the various versions of a program are effected by applying exclusively semantics-preserving transformation .rules. In this way it is guaranteed that the final version of the program still satisfies the initial specification. Of course, the development has to be done in such a way that the end-product will meet additional criteria such as space and time constraints.</p><p>The development process is guided by the programmer who has to choose appropriate transformation rules for each of the above-mentioned transitions; his choice reflects the creative part in the development process. This aspect is expressed by the term "intuition-guided.'' To keep the programmer's mind free for this creative part, the development should be "computer-aided,'' i.e., sup-ported by a system which acts as a clerk carrying out the actual program modifications and checking the applicability of the chosen rules (as far as this is mechanically possible).</p><p>Clearly, guaranteed correctness cannot be obtained for free: one has to invest time and discipline. This makes our approach-at least for the near future-unfit for "throw-away'' programs. It should, however, be profitable in connection with "critical software" for which correctness is an indispensible requirement due to ethical, economical, or political reasons [7], [8].</p><p>Following the general idea of transformational programming, within the project CIP research on the fcillowing main topics has been carried out:</p><p>a sound methodology (based on a formal calculus) which is to guide the process of formal reasoning in program development;</p><p>design and formal definition of a wide-spectrum language which provides a uniform syntactic and semantic framework for formulating problem specifications and programs at all levels of expression, and in which to carry out transformations; development of an interactive system for supporting the program evolution process by mechanical performance of the transformations, administration of all kinds of objects involved, and documentation of the development process.</p><p>Additionally, research on each of these topics has initiated and was accompanied by thorough investigations on theoretical issues. And tentatively, several applications have been investigated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">THE WIDE-SPECTRUM LANGUAGE CIP-L</head><p>The CIP approach is based on a particular "life cycle of transformational program development 1) formal problem specification (usually descriptive) 2) modified specifications (usually still descriptive) 3) nondeterministic implicit recursive solutions 4) nondeterministic, explicit recursive solutions 5) deterministic, tail-recursive solutions 6) ameliorated applicative programs 7) efficient procedural or machine-oriented programs.</p><p>However, not all of these stages need occur; a development may well start below level 1) and end above level 7) and it may skip some of the intermediate stages.</p><p>In order to cover the whole program development process, a wide-spectrum language CIP-L has been designed [ 141 that comprises all these diferent levels of formulation [ 101. Constructing one wide-spectrum language rather than having layers of separate languages for all these levels was a straightforward consequence of the observation that transformations do not change a program as a whole but only small portions of it. Hence, the various styles cannot be separated but rather have to be integrated into one coherent syntactic and semantic framework [2S].</p><p>The semantics of CIP-L has been carefully designed; it is believed to comprise a large part of a universal conceptual basis of programming [5] that is independent of varying external representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Design Principles</head><p>According to our overall aim to support program specification and program transformation the actual language design was carried out hand in hand with the establishment of appropriate transformation rules. Another major design objective was to keep the number of basic concepts as small as possible despite the abundance in expressiveness.</p><p>This led quite naturally to a modular description of the language: there is a small kernel language (already having the full computational power); all remaining language constructs are extensions defined by transformational semantics [72], i.e., by "definitional transformation rules" mapping each program of the full language to some equivalent expression in the kernel (see Section 11-D).</p><p>This way of keeping such a large language manageable has additionally been supported by designing CIP-L as a scheme language: Instead of a fixed, specific set of data types there is a general mechanism for introducing data types by algebraic specGcations. However, this schematic view does not imply that every user program has to A further, though minor, objective was to encounter people's different patterns of perception. Thus, the language has an abstract syntax that allows different external representations. The language report [14] gives a complete definition of an Algol-like and a Pascal-like variant and exemplifies further variants such as Prolog-like, Adalike or Lisp-like ones. Note, however, that these similarities to other languages merely concern the syntactic surface; in many cases there are essential semantic differences. There is also an English-like external representation which seems particularly useful at the specification level in the communication with nonspecialists [36]. The examples in this paper will be denoted in the Pascal variant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Algebraic Spec@cations</head><p>The abstract description of a problem in particular requires an abstract description of the data structures used. Besides various "constructive" approaches (building new data types from given ones using a fixed set of construction operations) the main tool for this is given by the approach of algebraic specijications of data types (cf., e.g., <ref type="bibr" target="#b71">[83]</ref>). Its basic idea is to describe data structures together with their characteristic operations in an implementationindependent way, viz. by their properties.</p><p>For instance, the type of sequences of objects can be specified algebraically as follows: </p><formula xml:id="formula_0">abstracttype SEQU = (sort</formula><formula xml:id="formula_1">isempty empty = true , isempty ( x + s) = false , first ( x + s ) = x , rest (x + s ) = s enda bstracttype</formula><p>start from scratch: appropriate programming environments may be provided with predefined "standard" types.</p><p>Another, equally important language design objective was to support postponing of design decisions in a development ("delayed design decisions," "specification freedom" [50]) to a stage where enough information is available to allow well-founded decisions. This objective, on the one hand, promoted a liberal semantics for abstract data types ("loose specifications," [79], <ref type="bibr" target="#b71">[83]</ref>) rather than the restriction to initial or terminal models; on the other hand, it led to the incorporation of nondeterminism into the language. For achieving a homogeneous overall semantics, both areas required thorough theoretical investigations (cf., e.g., [27], [261).</p><p>SEQU is a type scheme (or a generic type), i.e., it is parameterized with the sort rn of the sequence elements. It is based on a type BOOL that characterizes the truth values. SEQU introduces the new sort sequ of sequence objects, a constant empty (of sort sequ), and the operations . + . , appending an element to the front of a sequence, first and rest, that give for a nonempty sequence the first element and all but the first element, and is- empty, which tests emptyness of a sequence. The dots around . +. indicate the argument positions. Note the use of parameter restrictions or assertions in case of the partial operations first and rest.</p><p>As further examples we give algebraic specifications for finite sets and for graphs with a fixed set of nodes:  FINSET is again a type scheme. The parameters here are an object sort rn and a binary predicate eq on rn that has to satisfy the properties of an equivalence relation; this restriction is expressed by another specification EQUlV as follows:</p><p>For specifying directed graphs, we assume a type NODE that specifies the sort node of graph vertices as well as an equality test eqn on node. Then finite directed graphs over the fixed vertex set node can be specified by abstracttype EQUlV = ( sort rn , function eq ( rn ; rn ) : bool) : basedon BOOL ; laws x , y , z : rn \I def ~( x , Y&gt; , eq(x, x ) = true , eq(x, Y&gt; = e q ( y , x&gt; &gt; eq(x, y ) = true A eq( y, z ) = true =&gt; eq(x, z ) = true endabstracttype .</p><p>The type FINSET provides the new sort fset of finite sets of rn-objects and the constant empty as well as the operations incorp (adding an element to a set), contains (test whether a set contains an element), delete (removing an element from a set), difference, sps (superset relation), and eqs (equality test on sets). The axiom def sps(s, t ) ensures that sps is a total operation; for the other operations this can be deduced from their respective axioms. This example also demonstrates that the axioms of algebraic specifications are not restricted to conditional equations; we do allow full first-order logic here. </p><formula xml:id="formula_2">isarc(eg, x , y ) = f a l s e , isarc(inc(g, x , y), x 1 , y l ) = (eqn(x, x 1 ) A eqn( Y , Y 1 &gt;) v isarc(g, x 1 , Y 1 ) endabstracttype .</formula><p>Here, eg ("empty graph") does not contain any arcs; inc(g, x , y ) is the graph that results from g by adding an edge leading from node x to node y . isarc(g, x , y) tests whether g contains an edge from x to y .</p><p>Of paramount importance for implementations of such specifications is the generation principle: To the outside, only those elements are available that can be generated using the available operations. This provides a powerful encapsulation mechanism preventing uncontrolled construction of data objects.</p><p>Types, corresponding to Pascal's variant records (however, with direct recursion instead of the use of pointers, [43]) are introduced into the language as shorthand notations for certain algebraic specifications. For example, the declaration type sexp = cons record car, cdr : sexp endrecord I atom record V a l : m endrecord , of the type of binary trees the leaves of which are labeled by objects of sort m, is equivalent to the following part of an algebraic specification:</p><formula xml:id="formula_3">sort sexp ,</formula><p>or by designating a unique element using the description operator (Hilbert's t ) , e.g., that x : n a t )I x + l = y ("the predecessor of y " ) .</p><p>So this level provides an extended "logic programming" style. In passing to the next level, choice and description operators as well as existence quantifiers are eliminated, and usually implicit recursion (without a guarantee for direct executability) results. However, resolution techniques may already allow a "rapid prototyping," mainly for clarification of the specification.</p><p>Explicit recursive function declarations can be viewed as a more readable shorthand notation for certain (lambdacalculus-like) expressions of the kernel language. At this level, non-determinism can be expressed by the jinite choice U or by guarded expressions-a counterpart to Dijkstra's "guarded commands," [35]. An example is given by</p><formula xml:id="formula_4">function anyatom ( s : sexp ) m ; if s is atom then va/(s)</formula><p>("the value of an arbitrary leaf of a given binary tree"). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Overview Over the Scheme Language</head><p>The language can be viewed as layered into conceptual levels similar to those introduced at the beginning of Section 11. At the highest level, in addition to the algebraic specifications the language comprises (generally nonexecutable) specijcation constructs taken from predicate logic and set theory, e.g., ( x : n a t 11 x 2 2 and ( v z : n a t 11 z I x imp1 ( z = 1 or z = x ) ) } ("the set of all primes").</p><p>Here n a t denotes the type of natural numbers. Elements of a certain domain may be selected either nondeterministically using the choice operator (Hilbert's v ) , e.g., cdr(cons(s/, sr)) = sr , Higher-order functions (called "functionals") together with function composition allow a style of programming that is equivalent to Backus's FP <ref type="bibr">[ 2 ]</ref> .</p><p>The constructs mentioned so far from the applicative level of the language. The "lower" levels of the language contain the classical concepts of programming languages: variables, assignments, procedures, repetition constructs, conditional statements, and guarded commands. At the machine-oriented level, well-known constructs such as loops, jumps, labels, aRd pointers can be found.</p><p>Parallelism is incorporated into the language in the form of conditional critical regions <ref type="bibr" target="#b38">[42]</ref>. Their semantics is explained by equivalent non-deterministic sequential statements <ref type="bibr">[19]</ref>. On this basis, one also obtains means for communication by send and receive primitives.</p><p>Finally, the language also assists "programming in the large" through a number of modularization tools: the gross structure of a program is expressed as a hierarchy some x : n a t 11 3 n : n a t 11 x = 2*n+l ("some odd natural number"), <ref type="bibr" target="#b71">[83]</ref> of units. At the highest level, these are algebraic specifications, which may then be implemented by purely applicative computation structures. At the procedural level these, in turn, are realized by modules [47], in which all procedure parameters are explicit, or by devices, which provide routines that operate on shielded internal variables. All these units may be parameterized to allow ge- neric units. The concept of devices in conjunction with the constructs for parallelism allows the definition of monitors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. De$nition Method</head><p>The language CIP-L has a complete formal definition. For the "highest" language level, i.e., the kernel of the language, a mathematical semantics is given. All other formulation levels are defined by giving transformation rules (cf. Section 111) that allow the reduction of all constructs from a certain language level to constructs of the respective next higher one. Altogether, for each program there is an equivalent program of the kernel language defining its semantics.</p><p>This particular way of language definition (transfor- mational semantics, [72]) not only guarantees a formally sound relationship between the different language levels, but also facilitates the addition of further constructs to the language. In this sense CIP-L is an extensible language. By the modularization of the language into layers, the definition has attained a remarkable clarity and simplicity despite the "size" of the language (compare the definition of CIP-L in [ 141, e.g., to the definition of Ada by attribute grammars in [ 821).</p><p>Technically, the language is specified using again concepts from the theory of algebraic specifications (for background information see <ref type="bibr" target="#b25">[30]</ref>): the syntax of CIP-L defines a term algebra ("abstract syntax"). Context conditions are particular predicates over this algebraic theory; the semantics is defined by conditional rewriting rules corresponding to transformation rules with enabling conditions (see Section 111). The aforementioned modulari- zation of the formal definition was realized by constructing the term algebra in a hierarchical way: each level of formulation is defined by enriching the signature describing the next-' 'higher" level of formulation; the rewriting rules are formulated in a suficiently complete way <ref type="bibr">[41]</ref> to guarantee that these extensions are conservative.</p><p>It should be noted that the present extensions of the kernel language are oriented towards the traditional von Neumann machine architecture. Consequently, we have a strict "call-by-value" semantics for routine calls, and the so-called "erratic" nondeterminism. Since novel architectures, such as data flow or reduction machines, would need extended semantic concepts, their integration into the language as defined in <ref type="bibr">[14]</ref> does not seem feasible. They could be based, however, on a kernel language with a specifically changed semantics. Theoretical investigations preparing such an extension can be found, e.g., in 1201, ~581.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Basic Semantic Notions</head><p>In this section we briefly describe some predicates over programs that are important for the correctness of transformation rules; for formal definitions see <ref type="bibr">[14]</ref>.</p><p>We call a program t a descendant of a program s <ref type="bibr">[55]</ref> if every possible outcome of t also is a possible outcome of s; we then write s 1 t. In this case we call a transformation of s into t correct, since then all possible outcomes of t still satisfy the "intermediate specification"</p><p>s. The language is designed in such a way that all constructs are monotonic wrt. the descendant relation. Hence, i f s 2 t then also A program is called de$ned if none of its executions can lead to nontermination or to nonadmissible applications of partial operations (such as division by zero). A program is called determinate if it has only one possible outcome (note that "undefined" is also considered as an outcome here).</p><formula xml:id="formula_5">C[s] 2 C[t]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">FOUNDATIONS OF TRANSFORMATIONAL</head><p>PROGRAMMING The central notions of the CIP approach are program schemes and transformation rules. Schemes are used to allow transformation rules that apply to whole classes of programs and thus can be reused. We shall now briefly present a formal calculus of transformation rules that is the basis for both the methodology and the transformation system. It is more fully described in [77], <ref type="bibr">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . Basic Notions</head><p>Generalizing the algebraic view in the definition of CIP-L, we define a program as a well-formed term over a signature PL that describes a programming language. A program scheme is a well-formed term from PL[X], i.e., a term from PL containing free identifiers from a set X of schema parameters. Thus, a program is but a program scheme that does not contain schema parameters.</p><p>The atomic formulas of the transformation calculus are formed by predicates applied to program schemes. There are "syntactic" predicates concerning variable bindings, type compatibility, and the like (KIND, OCCURS, etc.) and "semantic" predicates such as equivalence, descendant, or less-defined relations (cf. <ref type="bibr">[ 141)</ref>.</p><p>Over these atomic formulas, positive implicational formulas ("Horn clauses," or clauses for short) can be formulated; these clauses then are the components of infer- ences which provide a second level of implicational formulas. For example, we have the following inference for propagating determinacy information: </p><formula xml:id="formula_6">+DETERMINATEI[E,IJ +KINDI[E,j = m,</formula><formula xml:id="formula_7">A + REL[u, v ]</formula><p>where A is a set of clauses expressing the applicability conditions and REL is a binary semantic predicate. We call U the input template and v the output template of the rule. The rule states that under the premises A the program schemes U and v are in the semantic relation REL.</p><p>As an example, the conventional alternative (for a determinate condition C) is related to the guarded expression by the rule</p><formula xml:id="formula_8">+ DETERMINATEUC] +if C then E l else E2 endif = (G UARDl F) if C then E l Z 1 C then E2 endif</formula><p>Or, in the notation used in [ 141,</p><p>The above way of transforming programs allows deferring the verification of applicability conditions; the result of such a development then is a final program version together with a set of applicability conditions ("assumptions") still to be verified. This verification can be performed by using inferences in a "backward" fashion to reduce a condition to "easier" subgoals. In the above example, use of the inference DETPROP reduces the condition</p><formula xml:id="formula_9">-+DETERMINATEEX I y]</formula><p>to the subgoals</p><formula xml:id="formula_10">+DETERMINATE[Ix] +KIND[x] = rn +KIND[y] = m +KIND[. s .]I = function (rn;rn):bool +DETERMINATE[ . -+DETERMINATE[. I .I if C then E l else E2 endif t if C thek E l J 1 C then E2 endif (GUARD IF) D ET ERM I N AT EUC]</formula><p>Here, C is a schema parameter for boolean expressions, whereas E l and E2 are schema parameters for expressions of equal types. In the sequel we shall use both no-if s then endif tations according to convenience.</p><p>i.e., from schema parameters to program schemes.</p><p>Let us assume that our original scheme is transformed in a scope where x and y have type nat and where . I . denotes the usual order on natural numbers. Since .I.</p><p>then is a determinate function, these subgoals can be reduced to</p><formula xml:id="formula_11">Instances are finite partial mappings from X to PL[X],</formula><p>Applying a transformation rule</p><formula xml:id="formula_12">A + RELEU, v ] -+ DETERMINATEEX] +DETERMINATE[ y j .</formula><p>to a program scheme t results in a new, specialized inference B However, by the call-by-value semantics of CIP-L identifiers, such as x and y, always denote unique objects; therefore the conditions vanish altogether.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+REL[t, w]</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Classijication of Transformation Rules</head><p>Transformation rules may be categorized [ 131 in accordance with the formal definition of the language.</p><p>A basic set of rules is provided by thefundamental rules of the language kernel. "Unfold," i.e., the replacement of a function call by the respective body, or "fold," the inverse of unfold, are typical examples. Two other frequently used rules are where t, w, and B result from instantiating U , v , and A by an instance i which is determined by matching the input template U against t. If U does not match t the rule is not applicable.</p><p>For example, applying the rule (GUARDIF) to the scheme</p><formula xml:id="formula_13">if x 5 y then x else y endif E if C then E else E endif yields the instance (IFINTRO) L DEFINED I C ] c -x I y F(if C then E l else E2 endif) E l u x E2 -y (IFDIST) 0 if C then F(E1) else F(E2) endif</formula><p>and thus the specialized inference</p><formula xml:id="formula_14">+DETERMINATEEX 5 v i + if x I y then x else y endif if x 5 y then x C i x 5 y then y endif</formula><p>These rules are verified with respect to the mathematical semantics of the kernel. Note that, e.g., (IFDIST) is valid only since the call-by-value semantics of CIP-L makes all functional expressions strict.</p><p>This basic set of rules is extended by the de3nitionaZ transformations for the additional language constructs. For instance, the declaration of a constant can be defined by ~461 const X : M = E l ; E2</p><p>.L KINDUE21 = R (( X : M ) : R ; E2) <ref type="bibr">( E l )</ref> .</p><p>In addition to these rules that are independent of particular object sets and programs, further rules for individual programs are given by the axioms of the respective type environment. For instance, in an environment that contains an algebraic definition of stacks one would have the axiom v s : stack ; x : nat 11 pop(push(s,x)) = s ("for stacks, pop is the inverse of push").</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This axiom corresponds to the rule</head><p>In the transformational calculus the rules of these three categories serve as the axioms from which theorems, the abstracttype NODESEQU = problem class this has been investigated in <ref type="bibr">[65]</ref>. The other aspect deals with the formal propagation of information which is important for the local applicability of transformation rules <ref type="bibr" target="#b65">[75]</ref>, <ref type="bibr">[76]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. A SAMPLE DEVELOPMENT</head><p>As an extended example for the transformational methodology, we want to specify and develop an algorithm for testing the existence of cycles in a directed graph.</p><p>Cycles are particular paths in a graph; to formalize this notion, we need the following type of extended sequences that provides a length operation 1.1 and an indexing op- </p><formula xml:id="formula_15">n &gt; 0 A v (i : nat 1) 1 I i A i I n) I( isarc(g, s [ i ] , s [ ( i mod n) + 13)</formula><p>ples, such as computational induction (cf., e.g., <ref type="bibr">[51]</ref>) or data type induction (structural induction, [3 l]), which, in turn, is a special case of the general principle of noetherian induction. A large collection of transformation rules is contained in [ 151.</p><p>There are two more aspects of transformational programming that have been dealt with only recently. One of them concerns the problems of strategy or at least guidance for the user of the methodology. For a particular This specification states clearly and concisely the problem without hinting in any way at an efficient solution.</p><p>A first step into that direction is the frequently useful technique of embedding the problem into a more general one which after solving yields an algorithm for the original problem as a special case. In the specification of hascycle we parameterize according to the subset of nodes in which a cycle can exist. Finite sets of nodes can be specified by an instantiation of the type scheme FINSET: abstracttype NODESET = nodeset, 0 , . + ., .E., . -., .\., . I &gt; . , . = .: basedon NODE; include FINSET(node, eqn) as (nodeset, 0, . +., .E., . -., .\., .I&gt; ., . =.) endabstracttype Here we make use of the renaming facility for instantiations in CIP-L: now the dyadic operators +, E, -, difference, sps, and = stand for incorp, contains, delete, difference, sps, and eqs. Additionally we need a function nset which for a sequence forms the set of elements contained in it: function nset (s : nodesequ) : nodeset ; if isempty s then 0 else nset(rest s) + first s endif .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now we specify a generalized function hc for cycle recognition:</head><p>Now the body of hc can be transformed further. First, we introduce a case analysis using the function sources. We obtain hc(c, g) * if sources(c, g ) = 0 t h e n hc(c, g ) else hc(c, g ) endif .</p><p>By property ( 2 ) the then-branch simplifies to c # 0 ; in the else-branch we unfold the call of hc. This results in if sources(c, g ) = 0</p><p>t h e n c f 0</p><formula xml:id="formula_16">else 3 s : nodesequ )I iscyc(s, c , g ) endif .</formula><p>function </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Obviously we have</head><p>hascyc/e(g) e hc(a/lnodes, g ) , where c o n s t allnodes : nodeset = { x : node 11 true} .</p><p>To transform the specification further, we make use of some consequences of the problem statement. In a cycle, every node has a predecessor and a successor that again are nodes of the cycle. Hence we say that a subset M of the node set of a graph has the predecessor resp. succes- We are now interested in nodes without predecessors, since they cannot lie in a cycle. Therefore we define function sources (c : nodeset ; g : graph) : nodeset ;</p><formula xml:id="formula_17">Applying</formula><formula xml:id="formula_18">( x : node I ( x E c A preds(x, c , g ) = 0} .</formula><p>Now one can show that for all sequences s and node sets c the following holds:</p><p>This form of hc already shows the special type of tail recursion that can immediately be transformed into iterative form according to the schematic rule (in which ' ' x : m" stands for a tuple of parameters) <ref type="figure">(s,</ref><ref type="figure">c ,</ref><ref type="figure">g</ref> ) e iscyc(s, c\sources(c, g ) , 9)) .</p><formula xml:id="formula_19">function f ( x : m ) : n; if C t h e n f (K) else E endif T NEWUXD function f ( X : m 1 : n ; begin var x : = X ; while C loop x : = K endloop ; E end (1) iscycle(s, g ) (2) sources(c, g ) = 0 ( 3 ) sources(c, g ) # 0 * nset(s) f 0 A preprop(nset(s), g ) (hc(c,g) e c f 0) (iscyc</formula><p>However, we want to stay at the applicative level and perform some efficiency-increasing transformations there; because of the strong algebraic properties this is easier here than at the procedural level. The further development is partially based on <ref type="bibr">[17]</ref>. The desired improvement is to reduce the expensive calls of the function sources. To this end we introduce an additional parameter carrying the actual sources-sets; instead of recomputing sources in each incarnation of hc, we want to adapt this parameter incrementally. This technique, also called finite differencing [61] or formal differentiation [SO], is a generalization of the well-known ''strength reduction" in compiler construction; it frequently leads to great gains in efficiency. To apply it we define function hcs ( c : nodeset ; d : nodeset ; g : graph 11</p><p>and replace the initial call hc(allnodes, g ) by hcs(allnodes, sources(allnodes, g ) , 9). We unfold the call of hc and simplify the resulting body, using the assertion d = sources(c, g ) , into</p><formula xml:id="formula_20">d = sources(c, 9)) : boo1 ; hc(c, g ) if d = 0 then c # 0 else hc(c\d, g ) endif .</formula><p>It is now our aim to replace the else-branch by a call of hcs to obtain a directly recursive variant of hcs. For this, the additional parameter has to be actualized in a correct way. We get i f d = 0 then c # 0 else hcs(c\d, sources(c\d, g ) , g ) endif .</p><p>An increase in efficiency wrt. hc is achieved if sources(c \ d , g ) can be computed in a simple way from sources(c, 9). Using the assertion d = sourcesic, 9)</p><p>as well as the property preds(x, c , g ) = preds(x, e, g ) U preds(x, c\e, g )</p><p>for arbitrary e with c 2 e we calculate</p><p>x E sources(c\d, 9)</p><p>For further improvement we want to make the computation of preds more efficient. We unfold the call of hcs and simplify the resulting body, using the assertions into, preds(x, allnodes, g&gt; .</p><p>*</p><formula xml:id="formula_21">x E c \ d Apreds(x, c \ d , g ) = 0 @ x ~c ~x + d A p r e d s ( x , c \ d , g ) = 0 e x E c A x q ! sources(c, g ) A preds(x, c \ d , g ) = 0 e x E c A preds(x, c , g ) f 0 A preds(x, c , g ) = preds(x, d , g ) U preds(x, c \ d , 9 ) A preds(x, c \ d , g ) = 0 e x E c A preds(x, c, g ) # 0 A preds(x, c , g ) = preds(x, d, 9 ) @ x E c A preds(x, c, g ) # 0 A d 2 preds(x, c , g ) .</formula><p>Hence we obtain </p><formula xml:id="formula_22">{ x : node 1) x E c A get(x, m) # 0 A d 2 get(x, m ) } ; endif .</formula><p>To replace the call of hcs by one of hcm we again have to actualize the additional parameter correctly. We observe that work should be done automatically; also, a system is more reliable in such a mechanical activity than a human being.</p><p>The system can record the applicability conditions</p><formula xml:id="formula_23">preds(x, c \ d , g ) = preds(x, c , g ) \ d .</formula><p>and help in reducing them to simpler forms (hopefully to true in the case of nonschematic developments). This leads to</p><p>The system can keep track of the development his-</p><formula xml:id="formula_24">i f d = 0 then c # 0 else const e : nodeset = { x : node 11 x E c A get(x, m) # 0 A d 2 get(x, m ) } ;</formula><p>some n : nodernap ( 1 v x : node 11 </p><formula xml:id="formula_25">( x E c * get(x, n ) = get(x, m ) \ d ) A ( x $ c * get(x, n ) = get(x, m)) ;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. THE TRANSFORMATION SYSTEM CIP-S</head><p>Of course, transformational program development can be done merely with pencil and paper. However, there are a number of good reasons for using a system that supports the methodology:</p><p>By its very nature program transformation leads to frequent rewritings of program fragments. Such clerical tory. This history serves as a detailed software documentation, since it reflects every design decision that enters into the final program. Thus, if a development line turns out to be a blind alley, the history can be used for backtracking to try different design decisions. Moreover it is the key aid to software maintenance: When the specification has to be modified (because of new requirements), one can try to "replay" a development with adaptation to the altered specification.</p><p>In a practical, interactive form, such a system will have the traits of an expert system for programming, with a knowledge base that is obtained and extended by formal reasoning, viz. extensive collections of development histories in suitably compactified form.</p><p>Within the project CIP a prototype transformation system has been implemented. Based on the experiences with this prototype, a new, advanced transformation system CIP-S is now under construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . The Prototype System</head><p>The purpose of the prototype system [18], <ref type="bibr" target="#b66">[78]</ref> is the interactive manipulation of program schemes. Since concrete programs are but specific schemes (cf. Section 111), this also includes the transformation of programs.</p><p>Based on the algebraic view of language definition (cf. Section 111), the prototype system is language-independent; any algebraically defined language is suited for manipulation, provided respective facilities for translating between external and internal representations are available. Transforming program schemes not only allows the treatment of concrete programs, but also the formal derivation of new, complex rules within the system. The appropriate operations, viz. rule application, composition, choice, and iteration are furthermore the basic constitu-ents of transformational expressions (similar to the wellknown regular expressions), a kind of restrictive "metalanguage" for expressing program developments [8 l].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The System CIP-S</head><p>Currently a new transformation system CIP-S [15] is under construction. This work originates from different motivations. One major aim with the system project was the investigation of the viability of the CIP methodology under more realistic conditions. This means not only that we wanted to deal with a non-toy, medium-size problem, but also that we want to extract from this concrete project general transformational strategies that will be applicable to a large number of situations. Thus this project prepares the extension of the CIP approach to a practically usable software engineering discipline. On the other hand, CIP-S is intended to incorporate recent ideas as well as experience with our own prototype system and other people's systems. So it is to form the basis for a software tool supporting that discipline.</p><p>As with the prototype system, the purpose of the definitive system CIP-S is the transformational development of program schemes. This includes manipulation of concrete programs, derivation of new transformation rules within the system, transformation of algebraic types, and verification of applicability conditions, but also the documentation of developments and their manipulation.</p><p>Besides the self-evident components, such as the parser, program editor, tree module, etc., the system, like most interactive systems, may be sketched as shown in Fig. <ref type="figure">3</ref> . Within Fig. <ref type="figure">3</ref> the following main components can be identified:</p><p>The User Environment: As in the prototype, this component is to manage the user/system interaction. A typical task is the realization of the user/system communication by activating translations between external and internal representations.</p><p>The System Core: This central component summarizes different tasks, e.g., for dealing with program schemes and their manipulation by transformational expressions, for simplifying applicability conditions, or for handling the different databases. Its main functions will be initializing and activating system-specific operations, keeping track of different internal system states, and preparing reactions of the system to be conveyed as output to the user by the user environment. Here, the major difference to the prototype system is the more general view of transformation rules as particular inferences (cf. Section III), support in the verification or reduction of applicability conditions, and automatic documentation of the development.</p><p>The Knowledge Base: There are various databases (collectively referred to as the "knowledge base"), each consisting of a number of catalogs, e.g., for (global or local) transformation rules (predefined or user-defined) abstract types, realized as signatures and transformation rules that correspond to the axioms (temporary or permanent) program schemes program developments (development trees).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+ demands</head><p>Fig. <ref type="figure">3</ref> Among the aforementioned databases, the development history, i.e., a database for keeping track of the different program versions and their relations, plays a central role. The intention with this system component is not only to conserve information and to allow its retrieval (e.g., for backtracking in developments), but also to provide basic operations for manipulations of the development itself such as compressing a development for compact communication, extraction of new rules by abstraction from partial developments, or perhaps even replay of a development applied to an altered initial specification.</p><p>The system is also to provide assistance in reducing applicability conditions to "simpler" ones in the sense discussed in Section III-A. For this, the system offers a fixed set of meta-inferences the most important of which is the "cut' ' :</p><formula xml:id="formula_26">C D c U (D\(cl) From -and ~ infer C d d</formula><p>Since a program usually is based on primitive types, the system also needs fundamental means for representing and transforming types, computational structures, modules, and devices. The basis for the respective notion of correctness is given in <ref type="bibr" target="#b24">[29]</ref>.</p><p>The kernel of a system with the above properties has been formally specified in [ 151. Starting from that specification, all routines have been developed to Pascal level CIP-L using the prototype system. The more interesting parts of these developments together with the transformation rules used can again be found in [ 151. Currently the results of these developments are embedded into an appropriate user environment to yield a first operational version of CIP-S. For further phases we envisage partial automatization of standard segments of developments and of reductions of applicability conditions to free the user even more from routine work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIENCES</head><p>The experiences and resu!ts gained se far agzir. disc::bute to the different threads of research: on the theoretical side, well-founded theories of nondeterminism, (partial, hierarchical, parameterized) abstract data types, algebraic language definition, and correctness of transformation rules (including type transformations) have been developed: they have provided a sound and sufficient basis for all further investigations. The language (both its concepts and its way of definition) has turned out to be advantageous not only as an educational vehicle in teaching beginner students (a compiler for an executable subset of CIP-L is available), but also as a valuable tool in developing and formulating more pretentious pieces of software. The prototype system has already been successfully used in education and served as the essential software tool in developing CIP-S.</p><p>The benefits of the methodology have been demonstrated in numerous case studies on small and mediumsize algorithms (e.g., sorting <ref type="bibr" target="#b17">[22]</ref>, <ref type="bibr" target="#b53">[62]</ref>). Recently, more advanced algorithms (such as graph algorithms <ref type="bibr" target="#b19">[24]</ref>, [ 161, [ 171, or parsing algorithms [63]-[65]) have also successfully been developed by transformations. Finally, we think that the development of CIP-S [15] has shown the suitability of the methodology for larger software projects.</p><p>All of these positive experiences as well as the steadily increasing number of people working on similar ideas, have strengthened our belief that transformational programming will become an important factor in software engineering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. RELATION TO OTHER WORK</head><p>The CIP approach has much in common with the ideas of Burstall and Darlington <ref type="bibr" target="#b27">[32]</ref>. We also start from a small set of powerful fundamental transformation rules from which a user may construct more complex rules that are particularly tailored to his individual problem domain. However, whereas the Burstall/Darlington approach remains on a small, applicative formulation level (more precisely: recursion equations), the CIP approach goes further in both directions: it allows nonoperational formal specifications as well as procedural and even machineoriented formulations.</p><p>In the particular respect of being wide-spectrum, the CIP ideas coincide with developments within the IS1 project [3], <ref type="bibr" target="#b45">[50]</ref> and Kestrel Institute <ref type="bibr">[40]</ref>. However, their approaches again differ from ours in favoring a catalogoriented, knowledge-based administration of the transformation rules. Although there are a number of useful general derived rules (e.g., compact rules for all stages of program development within particular problem domains [65] or compact rules for recursion removal, e.g., <ref type="bibr">[12]</ref>) which should be provided ready-made in a transformation system, in CIP-S the main emphasis is laid on the ability for deriving rules within the system in order to allow the user to construct his own individual (problem-dependent) transformation catalog.</p><p>In contrast to the artificial intelligence ideas in the field of automated programming (see, e.g., the DEDALUS system <ref type="bibr" target="#b47">[52]</ref> and its successor [53], [54]), we doubt that for non-toy applications full automation of the development process will be achievable. Automation seems even less probable, if development takes place on different levels of formulation rather than merely on the "top level" as in the DEDALUS approach. Therefore, we rely on the human user as the ultimate authority. However, for certain limited subtasks (e.g., simplification of expressions), it is desirable to free the user from selecting each single transformation rule by hand. This can be achieved in the prototype by transformational expressions [8 11. More generally, as envisaged for CIP-S, suitable transformational programs can be written, generalizing what optimizing compilers already do in rudimentary form.</p><p>A more detailed analysis of differences between the CIP approach and others, in particular with respect to the system aspects, may be found in [7 11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. HISTORY AND PERSPECTIVES</head><p>The activities, initiated by ideas in [ 5 ] , started around 1975-partly inspired by <ref type="bibr" target="#b29">[34]</ref> and later accompanied by the work of others, in particular that of Burstall and Darlington <ref type="bibr" target="#b27">[32]</ref>. The early activities were centered around transforming control structures (for instance, recursion removal, e.g., <ref type="bibr">[69]</ref>) and led immediately to the study of algebraic laws for operations. Since such laws are naturally expressed within algebraic data types (e.g., <ref type="bibr" target="#b39">[44]</ref>, <ref type="bibr" target="#b44">[49]</ref>, [41], <ref type="bibr" target="#b34">[39]</ref>), this initiated our research on abstract data types (cf. <ref type="bibr" target="#b21">[26]</ref>, <ref type="bibr" target="#b71">[83]</ref>, <ref type="bibr" target="#b51">[59]</ref>, <ref type="bibr" target="#b52">[60]</ref> for summaries on the relevant results, but also as sources to further specific references). A first version of a language report emerged from these activities in 1981; the final document on CIP-L then is [ 141. In order to use the language in teaching, a compiler for a substantial subset of the language has been developed and already successfully used in introductory courses on programming.</p><p>In parallel with the language design the prototype system was implemented as reported in [18]. This system was used in the development of CIP-S. The formal specification of CIP-S and parts of its transformational development can be found in [ 151.</p><p>Since now the two major prerequisites CIP-L and CIP-S are either complete or close at hand, we can concentrate on methodological studies. Current focuses of research are advanced transformation techniques (such as data type transformations <ref type="bibr" target="#b24">[29]</ref>, or techniques for "programming in the large"), incorporation of requirements engineering into the development process <ref type="bibr" target="#b58">[68]</ref>, <ref type="bibr" target="#b60">[70]</ref>, <ref type="bibr" target="#b56">[66]</ref>, <ref type="bibr" target="#b57">[67]</ref>, or means for expressing strategies on the methodological side <ref type="bibr">[65]</ref>. Further studies will deal with specification and development of parallel algorithms.</p><p>The methods and tools elaborated so far in the CIP project have been more or less oriented towards the classical, i.e., von Neumann computer architecture. Some of the respective theoretical and methodological aspects-although not in full formality-can already be found in the textbook [ 121 for lower graduate level. Since 1981, however, the investigations were also directed toward extending the methodology to the development of programs for new architectures and languages such as parallel machines, array and vector computers, data flow architectures, or reduction machines [20], <ref type="bibr" target="#b50">[57]</ref>, <ref type="bibr" target="#b63">[73]</ref>. Experience gained so far is quite encouraging.</p><p>The main perspectives concern the wide field of application areas. In our view the time is ripe that the work done by the CIP group and the results obtained so far should encourage people from less academic, i.e., com-mercial, environments to test the available methods and tools in the development of larger real-life software. Moreover, transfer of the research results into the area of commercial software tools (to be created outside the academic limits) is envisaged. Partly this will even be carried out within "offspring" projects, such as PROSPEC-TRA Wossner, H. Zierer, and H. Zikeli. We are particularly grateful to H. Ehler for his valuable comments on a draft of this paper. From the industrial side, we gratefully acknowledge stimulating interest and financial support by IBM Santa Teresa Research Laboratory and by Siemens ZTI SOF. From 1974 to 1986 he worked at TUM within the CIP project. Since 1986 he has been a Protessor of Computer Science at the University of Nijmegen, The Netherlands, where he is respon sible for the field of software engineering Dr Partsch IS a member of the Gesellschaft fur lnformatik (GI) as well as a member and the current Chairman of IFIP WG 2 1 on Programming Languages ("Algol"). Dr. Moller is a member of the Association for Computing Machinery, the Gesellschaft fur Informatik, and IFIP WG 2.1 on Programming Languages ("Algol").</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Peter</head><p>Languages ("Algol").</p><p>of programming languages as well as optimizing compilers. Dr. Pepper is a member of the Gesellschaft fur Informatik. of the As- sociation for Computing Machinery, and IFlP WG 2. I on Programming</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>abstracttype FINSET = (sort rn ; function eq (rn ; rn) : boo1 I/ include EQUIV(rn, ea))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>= function (ml;. . . ;m,):m (1 I i I n) (DETPROP) +DETERMINATEI[F(EI,. . . ,E,JIJ Transformation rules are just special inferences of the form</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>function hcs (c : nodeset ; d : nodeset ; g : graph 11 d = sources(c, 9)) : boo1 ; i f d = @ thenc # 0 else const e : nodeset = hcs(c\d, e, g ) { x : node 11 x E c A preds(x, c , g ) # 0 A d 2 preds(x, c , 9 ) ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>const n : nodernap = hcm(c\d, e , n , g ) endif . Now this version is transformed into iterative form; the remaining prealgorithmic constructs are replaced by simple loops. The final version reads function hascycle ( g : graph) : boo1 ; begin var c : nodeset := allnodes; var d : nodeset : = 0 ; var m : nodemap : = init(@) ; for x in c loop const p : nodeset = preds(x, c , g ) ; i f p = 0 then d := d + x else skip endif ; m : = put(x, p , m) while d # 0 loop var e : nodeset : = 0 ; endloop ; for x in c loop const p : nodeset = ger(x, m) ; i f p f Q A d 2 p then e : = e + x else skip endif ; m : = put(x, p \ d , m) endloop ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>("PROgram Development by SPECification and TRAnsformation" [45]), or STOP (' 'Specification and Transformation Of Programs") which recently has been started in The Netherlands. ACKNOWLEDGMENT Since 1975, when the CIP project was initiated by F. L. Bauer and the late K. Samelson, many colleagues have contributed to its development, notably (in alphabetic order) U. Berger, R. Berghammer, B. Brass, M. Broy, W. Dosch, C. Delgado-Kloos, H. Ehler, F. Erhard, F. Geiselbrechtinger, R. Gnatz, E. Hangel, W. Hesse, U. Hill-Samelson, A. Horsch, H. HuBmann, B. Krieg-Briickner, A. Laut, M. Lichtmannegger, M. Luckmann, T . Matzner, F. Nickl, R. Obermeir, 0. Paukner, H . -0 . Riethmayer, G. Schmidt, R. Steinbriiggen, M. Wirsing, H.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>the report o n Algol 60. Since the early 1970's they headed the CIP research o n the methodology of transformational programming and the corresponding language design. Apart from that, he worked in numerical analysis and cryptology. Recently, he has set up the collection on computer science and automation of the Deutsches Museum in Munich. Dr. Bauer received an honorary doctor's degree from the University of Grenoble in 1974 and was awarded the honor of a Computer Pioneer by the IEEE Computer Society in 1988. He is a Fellow of the Bavarian Academy of Sciences and of the Leopoldina Academy in Halle, as well as of the Association for Computing Machinery, of IEEE Computer Society, of the Gesellschaft fur Informatik, and of IFIP WG 2.1 on Programming Languages ("Algol"). Bernhard Moller studied informatics and mathematics at the Technical University of Munich from 1972 to 1975 and from 1976 to 1977. From 1975 to 1976 he studied computer science at Cornell University, receiving the M.S. degree in 1977. He received the Ph.D. degree (Dr.rer.nat.) in 1982 and the formal admission as an academic lecturer (Habilitation) in 1987. Since 1977, he has been a member of the CIP research group. His research interests include formal semantics. algebraic soecifications. and the Helmut Partsch studied mathemdtics and physics at the University of Wurzburg, and mathemdtic\ and computer science (Informatik) at the Technical University of Munich (TUM) where he received the diploma in 1974. He received the Ph D degree in 1979 and the formal admission as an academic lecturer (Habilitation) i n 1985.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Pepper studied mathematics and informatics at the Technical University of Munich, where he received the M.S. degree (Diplom) in 1974. the Ph.D. degree (Dr.rer.nat.) in 1979, and his formal admission as an academic lecturer (Habilitation) in 1985. He was a member of the CIP research group from 1975 to 1985. Since 1985 he has been a Professor of Computer Science at the Technical University of Berlin. His research centers around the formal specification and development of software, with main emphasis on algebraic specifications and on the use of modal and temooral logics. His other interests include methods for the definition v methodology of formal program development.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>rn) sequ, empty, isempty. , first. , rest. , .+ basedon BOOL ; sort sequ , empty : sequ , function isempty. (sequ) : boo1 , function first. ( s : sequ 11 1 isempty s ) : rn , function rest. ( s : sequ II 1 isempty s ) : sequ ,</head><label></label><figDesc></figDesc><table><row><cell>function . +. (m ; seq") : sequ ; laws x : rn ; s : sequ 1)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>for arbitrary context C; this is essential for allowing the local application of transformation rules. If both s 1 t and t 1 s, we call s and t equivalent and write s = t.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>(s : sequ ; i : nat II 1 s i A i s Is[) : m ; laws x : m ; s : sequ II</figDesc><table><row><cell></cell><cell>eration .[.I:</cell></row><row><cell></cell><cell>abstracttype ESEQU = (sort m) sequ, empty, isempty, first, rest, . + ., 1.1, .[.I :</cell></row><row><cell></cell><cell>basedon SEQU(m) ;</cell></row><row><cell></cell><cell>basedon NAT ; function 1.1 (sequ) : nat ,</cell></row><row><cell></cell><cell>(empty1 = 0 , ( x + S I = 1 + (SI,</cell></row><row><cell></cell><cell>Is1 2 1 * s [ l ] = firsts,</cell></row><row><cell>basedon NODE ;</cell><cell></cell></row><row><cell cols="2">include ESEQU(node) as (nodesequ, empty, isempty, first, rest, . +. , 1.1, .[.I)</cell></row><row><cell>endabstracttype .</cell><cell></cell></row><row><cell cols="2">derived transformation rules, may be deduced. Fre-Based on these types, the problem of cycle recognition</cell></row><row><cell>quently this involves the use of various induction princi-</cell><cell>can be specified as follows:</cell></row></table><note><p>function .[.I i &gt; 1 A i I Is1 * s [ i ] = (rest s)[i-11 endabstracttype This scheme is then instantiated to yield a type for node sequences: ~~ nodesequ, empty, isempty, first, rest, . +. , 1.1, .[.I : function hascycle (g : graph) : bool; 3 s : nodesequ )I iscyc/e(s, g), function iscycle (s : nodesequ ; g : graph) : bool; begin const n : nat = \SI; e n d .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>Thus, the node set of a cycle has both the predecessor and successor properties. So, if a graph has a cycle there has to be a nonempty subset of its node set showing these properties. We concentrate on the predecessor property which is formalized by</figDesc><table><row><cell>recursive form</cell><cell></cell><cell></cell></row><row><cell>function hc (' :</cell><cell>; g : graph) :</cell><cell>;</cell></row><row><cell>if sources(c, g ) = 0</cell><cell></cell><cell></cell></row><row><cell>t h e n c # 0</cell><cell></cell><cell></cell></row></table><note><p>property ( 3 ) in the else-branch yields if sources(c, g ) = 0 t h e n c # 0 else 3 s : nodesequ 11 iscyc(s, c\sources(c, g ) , g ) endif . Now the expression in the else-branch can be folded into another call of hc with modified parameter; in this way one obtains if sources(c, g ) = 0 t h e n c f 0 else hc(c\sources(c, g ) , g ) endif . sorpropero if every node in has a predecessor resP. a This is already a first algorithmic version of hc, viz. the successor in M. else hc(c\sources(c, g ) , g ) endif . function preprop (c : nodeset ; g : graph) : boo1 ; v x : node 11 x E c * preds(x, c , g ) # 0 , function preds ( x : node ; c : nodeset ; g : graph) : nodeset ; ( y : node 11 y E c A isarc(g, y, x ) } .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>In the sequel we use the instantiation include MAP (node, nodeset) as (nodemap, init, Now we embed hcs into a new routine having as another additional parameter a finite map that realizes the function preds. It is defined as</figDesc><table><row><cell>map, init, put, get :</cell></row><row><cell>basedon BOOL ;</cell></row><row><cell>sort map ,</cell></row><row><cell>function init (elem) : map ,</cell></row><row><cell>function put (index ; elem ; map) : map ,</cell></row><row><cell>function get (index ; map) : elem ; laws x : elem ; rn : map ; i, j : index 1)</cell></row><row><cell>get(;, init(x)) = x ,</cell></row><row><cell>get(;, put(;, x , rn)) =</cell></row><row><cell>if eq(i, j ) then x else get(;, rn) endif</cell></row><row><cell>endabstracttype .</cell></row></table><note><p>To this end, we introduce the following data type of finite mappings: abstracttype MAP = (sort index ; function eq (index ; index) : boo1 ; sort elem )I include EQUIV(index, eq)) function hcrn (c : nodeset ; d : nodeset ; rn : put, get) . nodemap ; g : graph 11 d = sources(c, g ) A ( V x : node 11 x E c =$ get(x, rn) = preds(x, c , 9)) : boo1 ; Again we have to adapt the initial call, here to hcs(c, d , 9 ) . hcm(allnodes, sources(allnodes, g ) , nrn, g ) where n r n : nodemap = that rn : nodemap 11 v x : node 11 get(x, rn) =</p></note></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Friedrich Ludwig Bauer studied mathematics, physics, astronomy, and loglc at the University of Munich from 1946, taking the State Teacher Examination in 1949 In parallel, he worked on group representations for elementary particle theory for which he received the Ph.D degree in 1952</p><p>From 1952 to 1958 he was an Assistant Professor at the Munich University of Technology, from 1958 to 1962 he was an Associate Professor and then full Professor at the University of Mainz Since 1963 he has been full Professor at the Munich University of Technology, first only for Mathematics, and from 1972 on also for Computer Science, the field he had developed at this university. His main contributions to computer science are marked by the collaboration with his friend and colleague Klaus Samelson In connection wlth the construction of a successor to the tube computer PERM at the Munich University of Technology they developed the stack-principle. Both had strong</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">What are the new paradigms?</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Agresti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Paradigms for Software Development, W. M. Agresti</title>
		<meeting><address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Can programming be liberated from the von Neumann style? A functional style and its algebra of programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Backus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="613" to="641" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the transformational implementation approach to programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Balzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wile</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Int. Conf. Software Engineering</title>
		<meeting>2nd Int. Conf. Software Engineering<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="337" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Software technology in the 1990&apos;s: Using a new paradigm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Balzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Cheatham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">course of 3 lectures given at the Imperial College of Science and Technology</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973-10">Nov. 1983. Oct. 1973. 1973</date>
			<biblScope unit="volume">7318</biblScope>
			<biblScope unit="page" from="39" to="45" />
		</imprint>
	</monogr>
	<note>Proc. 2nd Int</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A trend for the next ten years of software engineering</title>
	</analytic>
	<monogr>
		<title level="m">Con$ Software Engineering</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Software Engineering</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Freeman</surname></persName>
		</editor>
		<editor>
			<persName><surname>Lewis</surname></persName>
		</editor>
		<meeting><address><addrLine>San Francisco, CA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic</publisher>
			<date type="published" when="1976">1976. 1980</date>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">New aspects of, and new prospects for a software engineer&apos;s programming methodology</title>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th COMPSAC</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Henderson</surname></persName>
		</editor>
		<meeting>5th COMPSAC<address><addrLine>Chicago, IL; Maidenhead</addrLine></address></meeting>
		<imprint>
			<publisher>Pergamon Infotech</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="165" to="174" />
		</imprint>
	</monogr>
	<note>System Design. lnfotech State of the Art Rep</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">From specifications to machine code: Program construction through formal reasoning</title>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int. Conf. Software Engineering</title>
		<meeting>6th Int. Conf. Software Engineering<address><addrLine>Tokyo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">Sept. 13-16, 1982</date>
			<biblScope unit="page" from="84" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Construction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Algorithmic Language and Program Development</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wossner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Systematics of transformation rules</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wossner</surname></persName>
		</author>
		<editor>Program Construction, F. L. Bauer and M. Broy</editor>
		<imprint>
			<date type="published" when="1979">1979. 1981</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="315" to="323" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Berghammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Geiselbrechtinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gnatz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hangel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hesse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Krieg-Briickner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Laut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Matzner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nickl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Samelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wirsing</surname></persName>
		</author>
		<author>
			<persName><surname>Wossner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Wide Spectrum Language CIP-L</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">I</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Horsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paukner</surname></persName>
		</author>
		<author>
			<persName><surname>Pepper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Program Transformation System CIP-S</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">II</biblScope>
		</imprint>
	</monogr>
	<note>The Munich Project CIP</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Zur formalen Entwicklung graphentheoretischer Algorithmen durch Transformation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Berghammer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">dissertation, Institut fur Informatik der TU Munchen</title>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A transformational development of several algorithms for testing the existence of cycles in a directed graph</title>
		<author>
			<persName><forename type="first">R</forename><surname>Berghammer</surname></persName>
		</author>
		<editor>B. Brass, F. Erhard, A. Horsch, H.-0. Riethmayer, and R. Steinbriiggen</editor>
		<imprint>
			<date type="published" when="1982">1986. 1982</date>
		</imprint>
	</monogr>
	<note>CIP-s: An instrument for program transformation and rule generation. Institut fur Informatik der TU Miinchen, Rep. TUM-18211</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Transformational semantics for concurrent programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Processing Lett</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="87" to="91" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A fixed point approach to applicative multiprogramming</title>
	</analytic>
	<monogr>
		<title level="m">Theoretical Foundations of Programming Methodology</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Schmidt</surname></persName>
		</editor>
		<meeting><address><addrLine>Dordrecht, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Reidel</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="562" to="622" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Algebraic methods for program construction: The project CIP</title>
	</analytic>
	<monogr>
		<title level="m">Program Transformation and Programming Environments</title>
		<meeting><address><addrLine>Bily Kriz, Czechoslovakia; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982. 1985</date>
			<biblScope unit="volume">82</biblScope>
		</imprint>
	</monogr>
	<note>Proc. SOFSEM</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Program construction by transformations: A family tree of sorting programs</title>
	</analytic>
	<monogr>
		<title level="m">Proc. NATO Advanced Study Institute, Bonas</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Biermann</surname></persName>
		</editor>
		<editor>
			<persName><surname>Eds</surname></persName>
		</editor>
		<meeting>NATO Advanced Study Institute, Bonas</meeting>
		<imprint>
			<date type="published" when="1981">Sept. 28-Oct. 10, 1981</date>
		</imprint>
	</monogr>
	<note>Computer Program Synthesis Methodologies. Advanced Study Institute Series 95</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Program development as a formal activity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="10" to="22" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Combining algebraic and algorithmic reasoning: An approach to the Schorr-Waite algorithm</title>
	</analytic>
	<monogr>
		<title level="j">ACM TOPLAS</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the coherence of programming language and programming methodology</title>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP Working Con$ Programming Languages and System Design</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Bormann</surname></persName>
		</editor>
		<meeting>IFIP Working Con$ Programming Languages and System Design<address><addrLine>Ed. Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="41" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Partial abstract types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inform</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Semantics of nondeterministic and noncontinuous constructs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gnatz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
		<editor>Program Construction, F. L. Bauer and M. Broy</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Semantic Relations in Programming Languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP Congress</title>
		<meeting>IFIP Congress<address><addrLine>Melbourne; Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="101" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Algebraic implementations preserve program correctness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sei. Comput. Program</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the algebraic definition of programming languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOPLAS</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="54" to="99" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Proving properties of programs by structural induction</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="41" to="48" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A transformation system for developing recursive programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J . ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">l</biblScope>
			<biblScope unit="page" from="44" to="67" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Software engineering techniques</title>
	</analytic>
	<monogr>
		<title level="j">NATO Science Committee</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Buxton</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1969">Oct. 27-31, 1969</date>
			<pubPlace>Rome, Italy</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The equivalence of certain computations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Cooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Compur. J</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="45" to="52" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Making formal specifications readable</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Institut fur Informatik der TU Munchen, Rep. TUM-18527</title>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Software Engineering Concepts</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fairley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A survey and classification of some program transformation approaches and techniques</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Feather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Netherlands</title>
		<editor>
			<persName><forename type="first">Program</forename><surname>Specijication</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">G L T</forename><surname>Transformation</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ed</forename><surname>Meertens</surname></persName>
		</editor>
		<editor>
			<persName><surname>Amsterdam</surname></persName>
		</editor>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="165" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">An initial algebra Dordrecht</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Wagner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1983. 1982. 1982. 1979</date>
			<publisher>Springer</publisher>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="553" to="592" />
			<pubPlace>The Netherlands; New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">approach to the specification, correctness, and implementation of abstract data types</title>
	</analytic>
	<monogr>
		<title level="m">Current trends in programming methodology</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Yeh</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1978">1986. 1978</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="80" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Research on knowledge-based programming and algorithm design-I981</title>
		<author>
			<persName><forename type="first">C</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Philipps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Westfold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pressburger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kedzierski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Angebranndt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mont-Reynaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tappel</surname></persName>
		</author>
		<idno>Kes.U.81.2</idno>
	</analytic>
	<monogr>
		<title level="j">Kestrel Inst</title>
		<imprint>
			<date type="published" when="1981">1981. 1982</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The specification and application to programming of abstract data types</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Guttag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Sci</title>
		<imprint>
			<date type="published" when="1975">1975</date>
			<pubPlace>Dep</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
	<note>Rep. CSRG-59</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Towards a theory of parallel programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems Techniques</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Perrott</surname></persName>
		</editor>
		<imprint/>
	</monogr>
	<note>Recursive data structures</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Algebraische Algorithmentheorie</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kaphengst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Reichel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VEB Robotron, Zentrum fur Forschung und Technik</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1971">1971</date>
			<pubPlace>Dresden</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Integration of program construction and verification: The PROSPECTRA methodology</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krieg-Briickner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Innovative Software Factories and Ada</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Habermann</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">275</biblScope>
			<biblScope unit="page" from="173" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The mechanical evaluation of expressions</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Landin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="308" to="320" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Safe procedural implementatinos of algebraic types</title>
		<author>
			<persName><forename type="first">A</forename><surname>Laut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Processing Lett</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="147" to="151" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Developing algebraic specifications of threaded data structure implementations</title>
	</analytic>
	<monogr>
		<title level="m">Werkzeuge der Programmiertechnik. Informatik-Fachberichte 43, G. Coos</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="28" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Programming with abstract data types</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zilles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Sigplan Cons Very High-Level Languages, Sigplan Notices</title>
		<meeting>ACM Sigplan Cons Very High-Level Languages, Sigplan Notices</meeting>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="55" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Implementing specification freedoms</title>
		<author>
			<persName><forename type="first">P</forename><surname>London</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Feather</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sei. Comput. Program</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Mathematical Theory of Conputation</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A deductive approach to program synthesis</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Waldinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Sofware Eng</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="90" to="121" />
			<date type="published" when="1531">1979. 1531. 1980. 1541. 1985</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>The Logic Basis for Computer Programming</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A basis for a mathematical theory of computation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Programming and Formal Systems</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Braffort</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Hirschberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1963">1963</date>
			<biblScope unit="page" from="33" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G L T</forename><surname>Meertens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Specification and Transformation (Proc. IFIP TC 2 Working Conference</title>
		<meeting><address><addrLine>Bad Tolz; The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1986">1986. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">An algebraic semantics for busy (data-driven) and lazy (demand-driven) evaluation and its application to a functional language</title>
		<author>
			<persName><forename type="first">B</forename><surname>Moller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">I</forename><surname>Diaz</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page" from="537" to="578" />
		</imprint>
	</monogr>
	<note>On the algebraic specification of infinite objects-Ordered and continuous models of algebraic types</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Algebraic specifications with higher-order operations</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G L T</forename><surname>Meertens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Specifcation and Transformation</title>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="367" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Fakultat fur Mathematik und Informatik der TU Miinchen, Habilitationsschrift, 1987. 1611</title>
		<author>
			<persName><forename type="first">R</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOPLAS</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="402" to="454" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
	<note>Finite differencing of computable expressions</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">An exercise in the transformational derivation of an efficient program by joint development of control and data structure</title>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Ammann</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="41" to="57" />
			<date type="published" when="1631">1983. 1631. 1984</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>Transformational derivation of parsing algorithms executable on parallel architectures</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Structuring transformational developments: A case study based on Earley&apos;s recognizer</title>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="61" to="71" />
			<date type="published" when="1972">1984. 1972</date>
			<publisher>Academic</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Transformational program development in a particular prob</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<author>
			<orgName type="collaboration">lem domain</orgName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fachbereich Mathematik und Informatik der TU Munchen</title>
		<imprint>
			<date type="published" when="1975">1975. 1985. 1986</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="99" to="123" />
		</imprint>
	</monogr>
	<note>Habilitationsschrift</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Algebraic requirements definition: A case study</title>
	</analytic>
	<monogr>
		<title level="j">Technique et Science of Informatiques</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="21" to="36" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">From informal requirements to a running program. A case study in algebraic specification and transformational programming</title>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint/>
	</monogr>
	<note>to be published</note>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">From requirements to their formalization-A case study on the stepwise development of algebraic specifications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Laut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programmiersprachen und Programmentwicklung (Informatik-Fachberichte 53</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Wossner</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A family of rules for recursion removal</title>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Processing Lett</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="174" to="177" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Abstract data types as a tool for requirements engineering</title>
	</analytic>
	<monogr>
		<title level="m">Requirements Engineering (Informatik-Fachberichte 74</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Homme1</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Kronig</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Program transformation systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Steinbriiggen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="199" to="236" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title level="m" type="main">A study on transformational semantics</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
		<editor>Program Construction, F. L. Bauer and M. Broy</editor>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="322" to="405" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">in Relationship Between Numerical computation and Programming Languages</title>
		<editor>J . K. Reid</editor>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>North-Holland</publisher>
			<biblScope unit="page" from="331" to="346" />
			<pubPlace>Amsterdam. The Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note>Specification languages and program transformation</note>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Program Transformations and Programming Environments (NATO</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AS1 Series. Series F: Computer and Systems Sciences)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Fachbereich Mathematik und Informatik der TU Miinchen, Habilitationsschrift</title>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<editor>
			<persName><forename type="first">Program</forename><surname>Specifcation</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">G L T</forename><surname>Transformation</surname></persName>
		</editor>
		<editor>
			<persName><surname>Meertens</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="221" to="262" />
			<date type="published" when="1985">1985. 1987</date>
			<publisher>North-Holland</publisher>
			<pubPlace>Ed. Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note>A simple calculus for program transformation (inclusive of induction)</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">User manual for the CIP-System-Prototype</title>
		<author>
			<persName><forename type="first">H.-0</forename><surname>Riethmayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Erhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Institut fur Informatik der TU Miinchen</title>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note>Rep. TUM-18511</note>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Implementation of parameterized specifications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sannella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science 140</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Nielsen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Schmidt</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982. 1982</date>
			<biblScope unit="page" from="473" to="488" />
		</imprint>
		<respStmt>
			<orgName>Univ. Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note>full version. Rep. CSR-103-82</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Some observations concerning formal differentiation of set theoretic expressions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sharir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOPDIS</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="196" to="226" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Program development using transformational expressions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Steinbriiggen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">lnstitut fur Informatik der TU Miinchen, Rep. TUM-18206</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">An Attribute Grammar for the Semantic Analysis of Ada</title>
		<author>
			<persName><forename type="first">J</forename><surname>Uhl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Persch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Coos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dausmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Winterstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kirchgassner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">139</biblScope>
			<date type="published" when="1982">1982</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">On hierarchies of abstract data types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pepper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Partsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inform</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Program development by step-wise refinement</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="429" to="449" />
			<date type="published" when="1971">1971. 1982. 1983. 1984. 1987</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin; Berlin; Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
