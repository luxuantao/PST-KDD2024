<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DynAlloy: Upgrading Alloy with Actions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marcelo</forename><forename type="middle">F</forename><surname>Frias</surname></persName>
							<email>mfrias@dc.uba.ar</email>
						</author>
						<author>
							<persName><forename type="first">Juan</forename><forename type="middle">P</forename><surname>Galeotti</surname></persName>
							<email>jgaleotti@dc.uba.ar</email>
						</author>
						<author>
							<persName><forename type="first">Carlos</forename><forename type="middle">G</forename><surname>L Ópez Pombo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nazareno</forename><forename type="middle">M</forename><surname>Aguirre</surname></persName>
							<email>naguirre@dc.exa.unrc.edu.ar</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science FCEyN Universidad de Buenos Aires</orgName>
								<address>
									<country key="AR">Argentina</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science FCEFQyN</orgName>
								<orgName type="institution">Universidad Nacional de Río</orgName>
								<address>
									<country>Cuarto Argentina</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">ICSE&apos;05</orgName>
								<address>
									<addrLine>May 15-21</addrLine>
									<postCode>2005</postCode>
									<settlement>St. Louis</settlement>
									<region>Missouri</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">DynAlloy: Upgrading Alloy with Actions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">49F5C8622097C95869A1F9DF0B87B35C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software Engineering]: Software/Program Verification-Validation</term>
					<term>D.2.10 [Software Engineering]: Design-Representation</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs Languages, Design, Verification Alloy, dynamic logic, software specification, software validation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present DynAlloy, an extension to the Alloy specification language to describe dynamic properties of systems using actions. Actions allow us to appropriately specify dynamic properties, particularly, properties regarding execution traces, in the style of dynamic logic specifications.</p><p>We extend Alloy's syntax with a notation for partial correctness assertions, whose semantics relies on an adaptation of Dijkstra's weakest liberal precondition. These assertions, defined in terms of actions, allow us to easily express properties regarding executions, favoring the separation of concerns between the static and dynamic aspects of a system specification.</p><p>We also extend the Alloy tool in such a way that DynAlloy specifications are also automatically analyzable, as standard Alloy specifications. We present the foundations, two casestudies, and empirical results evidencing that the analysis of DynAlloy specifications can be performed efficiently.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Alloy <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b6">6]</ref> is a formal specification language, which belongs to the class of the so-called model-oriented formal methods. Alloy is defined in terms of a simple relational semantics, its syntax includes constructs ubiquitous in objectoriented notations, and it features automated analysis capabilities <ref type="bibr" target="#b5">[5]</ref>; these characteristics have made Alloy an appealing formal method.</p><p>Alloy has its roots in the Z specification language <ref type="bibr" target="#b8">[8]</ref>, and, as Z, is appropriate for describing structural properties of systems. However, in contrast with Z, Alloy has been designed with the goal of making specifications automatically analyzable.</p><p>Alloy's representations of systems are based on abstract models. These models are defined essentially in terms of data domains, and operations between these domains. In particular, one can use data domains to specify the state space of a system or a component, and employ operations as a means for the specification of state change. Semantically, operations correspond to predicates, in which certain variables are assumed to be output variables, or, more precisely, are meant to describe the system state after the operation is executed. By looking into Alloy's semantics, it is easy to verify that "output" and "after" are intentional concepts, i.e., the notions of output or temporal precedence are not reflected in the semantics and, therefore, understanding variables this way is just a (reasonable) convention. Variable naming conventions are a useful mechanism, which might lead to a simpler semantics of specifications. However, as we advocate in this paper, the inclusion of actions (understood as a general concept associated with state change, covering transactions and events, for example), with a well defined input/output semantics, in order to specify properties of executions, might provide a significant improvement to Alloy's expressiveness and analyzability. Moreover, actions enable us to characterise properties regarding execution traces in a convenient way.</p><p>In order to see how actions might improve Alloy's expressiveness, suppose, for instance, that we need to define the combination of certain operations describing a system. Some combinations are representable in Alloy; for instance, if we have two operations Oper 1 and Oper 2 , and denote by Oper 1 ;Oper 2 and Oper 1 + Oper 2 the sequential composition and nondeterministic choice of these operations, respec-tively, then these can be easily defined in Alloy as follows:</p><p>Oper 1 ;Oper 2 (x, y) = some z | (Oper 1 (x, z) and Oper 2 (z, y)) ,</p><p>Oper 1 + Oper 2 (x, y) = Oper 1 (x, y) or Oper 2 (x, y) .</p><p>However, if we aim at specifying properties of executions, then it is reasonable to think that we will need to predicate at least about all terminating executions of the system. This demands some kind of iteration of operations. While it is possible to define sequential composition or nondeterministic choice, as we showed before, finite (unbounded) iteration of operations cannot be defined in Alloy. Nevertheless, some effort has been put toward representing the iteration of operations, in order to analyze properties of executions in Alloy. By enriching models with the inclusion of a new signature (type) for execution traces <ref type="bibr" target="#b6">[6]</ref>, and constraints that indicate how these traces are constructed from the operations of the system, it is possible to simulate operation iteration. Essentially, traces are defined as being composed of all intermediate states visited along specific runs. While adding traces to specifications provides indeed a mechanism for dealing with executions (and even specifications involving execution traces can be automatically analyzed), this approach requires the specifier to explicitly take care of the definition of traces (an ad hoc task which depends on the properties of traces one wants to validate). Furthermore, the resulting specifications are cumbersome, since they mix together two clearly separated aspects of systems, the static definition of domains and operations that constitute the system, and the dynamic specification of traces of executions of these operations. Modules might help in organizing a specification, by separating the static and dynamic aspects of a system; however, the specifier still needs to manually provide the specification of traces, since, as we said, this is an ad hoc activity, dependent on the particular property of executions that needs to be validated.</p><p>We consider that actions, if appropriately used, constitute a better candidate for specifying assertions regarding the dynamics of a system (i.e., assertions regarding execution traces), leading to cleaner specifications, with clearer separation of concerns.</p><p>In order to compare these two approaches, let us suppose that we need to specify that every terminating arbitrary execution of two operations Oper 1 and Oper 2 beginning in a state satisfying a formula α terminates in a state satisfying a formula β. Using the approach presented in <ref type="bibr" target="#b6">[6]</ref>, it is necessary to provide an explicit specification of execution traces complementing the specification of the system, as follows:</p><p>1. specify the initial state as a state satisfying α, 2. specify that every pair of consecutive states in a trace is either related by Oper 1 or by Oper 2 , 3. specify that the final state satisfies β.</p><p>Using the approach we propose, based on actions, execution traces are only implicitly used. The above specification can be written in a simple and elegant way, as follows:</p><formula xml:id="formula_0">{α} (Oper 1 + Oper 2 ) * {β}</formula><p>This states, as we required, that every terminating execution of (Oper 1 + Oper 2 ) * (which represents an unbounded iteration of the nondeterministic choice between Oper 1 and Oper 2 ) starting in a state satisfying α, ends up in a state satisfying β. This notation corresponds to the traditional and well-known notation for partial correctness assertions.</p><p>Notice that no explicit reference to traces is required. Nevertheless, traces exist and are well taken care of in the semantics of actions, far from the eyes of the software engineer writing a model. It seems clear then that pursuing our task of adding actions to Alloy might indeed contribute toward the usability of the language. Note that finite unbounded iteration is, in our approach, expressible via the iteration operation "*".</p><p>As we mentioned, one of the main features of Alloy is its analyzability. The Alloy tool allows us to automatically analyze specifications by searching for counterexamples of assertions with the help of the off-the-shelf SAT solvers MChaff, ZChaff <ref type="bibr">[7]</ref> and Berkmin <ref type="bibr" target="#b2">[2]</ref>. Therefore, extending the language with actions, while still an interesting intellectual puzzle, is not important if it cannot be complemented with efficient automatic analysis. So, we modify the Alloy tool in order to deal with the analysis of Alloy specifications involving actions and execution traces assertions. Notice that, even though finite unbounded iteration is expressible in DynAlloy, a bound on the depth of the iterations needs to be imposed for the analysis tasks. So, for SAT solving based analysis, our extension only covers bounded iteration.</p><p>The contributions of this paper are then summarized as follows.</p><p>• We add to Alloy the possibility of defining actions and asserting properties using partial correctness assertions, as a mechanism for the specification of operations. We refer to this extension of Alloy as DynAlloy.</p><p>• We present a modification of the Alloy tool in order to allow for an efficient verification of DynAlloy specifications.</p><p>• We present two case-studies for which we compare the analysis running time when using actions and traces. We conclude that efficiency increases when using actions and partial correctness assertions.</p><p>The remainder of this paper is organized as follows. In Section 2 we present the Alloy specification language. In Section 3 we present the DynAlloy language. In Section 4 we present the DynAlloy tool. In Section 5 we present the case-studies and their corresponding running times. Finally, in Section 6 we present our conclusions and proposals for further work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">THE ALLOY SPECIFICATION LANGUAGE</head><p>In this section, we introduce the reader to the Alloy specification language by means of an example extracted from <ref type="bibr" target="#b6">[6]</ref>. This example serves as a means for illustrating the standard features of the language and their associated semantics, and will also help us demonstrate the shortcomings we wish to overcome.</p><p>Suppose we want to specify systems involving memories with cache. We might recognize that, in order to specify memories, data types for data and addresses are especially necessary. We can then start by indicating the existence of disjoint sets (of atoms) for data and addresses, which in Alloy are specified using signatures:</p><formula xml:id="formula_1">sig Addr { } sig Data { }</formula><p>These are basic signatures. We do not assume any special properties regarding the structures of data and addresses. With data and addresses already defined, we can now specify what constitutes a memory. A possible way of defining memories is by saying that a memory consists of set of addresses, and a (total) mapping from these addresses to data values: sig Memory { addrs: set Addr map: addrs -&gt;! Data }</p><p>The symbol "!" in the above definition indicates that "map" is functional and total (for each element a of addrs, there exists exactly one element d in Data such that map(a) = d).</p><p>Alloy allows for the definition of signatures as subsets of the set denoted by another "parent" signature. This is done via what is called signature extension. For the example, one could define other (perhaps more complex) kinds of memories as extensions of the Memory signature: sig MainMemory extends Memory {} sig Cache extends Memory { dirty: set addrs } As specified in these definitions, MainMemory and Cache are special kinds of memories. In caches, a subset of addrs is recognized as dirty.</p><p>A system might now be defined to be composed of a main memory and a cache: sig System { cache: Cache main: MainMemory } As the previous definitions show, signatures are used to define data domains and their structure. The attributes of a signature denote relations. For instance, the "addrs" attribute in signature Memory represents a binary relation, from memory atoms to sets of atoms from Addr. Given a set m (not necessarily a singleton) of Memory atoms, m.addrs denotes the relational image of m under the relation denoted by addrs. This leads to a relational view of the dot notation, which is simple and elegant, and preserves the intuitive navigational reading of dot, as in object orientation. Signature extension, as we mentioned before, is interpreted as inclusion of the set of atoms of the extending signature into the set of atoms of the extended signature.</p><p>In Fig. <ref type="figure">1</ref>, we present the grammar and semantics of Alloy's relational logic, the core logic on top of which all of Alloy's syntax and semantics are defined. An important difference with respect to previous versions of Alloy, as the one presented in <ref type="bibr" target="#b4">[4]</ref>, is that expressions now range over relations of arbitrary rank, instead of being restricted to binary relations. Composition of binary relations is well understood; but for relations of higher rank, the following definition for the composition of relations has to be considered:</p><formula xml:id="formula_2">R;S = { a1, . . . , ai-1, b2, . . . , bj : ∃b ( a1, . . . , ai-1, b ∈ R ∧ b, b2, . . . , bj ∈ S)} .</formula><p>Operations for transitive closure and transposition are only defined for binary relations. Thus, function X in Fig. <ref type="figure">1</ref> is partial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Operations in a Model</head><p>So far, we have just shown how the structure of data domains can be specified in Alloy. Of course, one would like to be able to define operations over the defined domains. Following the style of Z specifications, operations in Alloy can be defined as expressions, relating states from the state spaces described by the signature definitions. Primed variables are used to denote the resulting values, although this is just a convention, not reflected in the semantics.</p><p>In order to illustrate the definition of operations in Alloy, consider, for instance, an operation that specifies the writing of a value to an address in a memory:</p><formula xml:id="formula_3">Write(m, m': Memory, d: Data, a: Addr) { m'.map = m.map ++ (a -&gt; d) } (1)</formula><p>The intended meaning of this definition can be easily understood, having in mind that m' is meant to denote the memory (or memory state) resulting of the application of function Write, a -&gt; d denotes the ordered pair a, d , and ++ denotes relational overriding, defined as follows <ref type="foot" target="#foot_0">1</ref> :</p><formula xml:id="formula_4">R++S = { a1, . . . , an : a1, . . . , an ∈ R ∧ a1 / ∈ dom (S) } ∪ S .</formula><p>We have already seen a number of constructs available in Alloy, such as the dot notation and signature extension, that resemble object oriented definitions. Operations, however, represented by functions in Alloy, are not "attached" to signature definitions, as in traditional object-oriented approaches. Instead, functions describe operations of the whole set of signatures, i.e., the model. So, there is no notion similar to that of class, as a mechanism for encapsulating data (attributes or fields) and behavior (operations or methods).</p><p>In order to illustrate a couple of further points, consider the following more complex function definition: fun SysWrite(s, s': System, d: Data, a: Addr) { Write(s.cache, s'.cache, d, a) s'.cache.dirty = s.cache.dirty + a s'.main = s.main } There are two important issues exhibited in this function definition. First, function SysWrite is defined in terms of the more primitive Write. Second, the use of Write takes advantage of the hierarchy defined by signature extension: note that function Write was defined for memories, and in SysWrite it is being "applied" to cache memories.</p><p>As explained in <ref type="bibr" target="#b6">[6]</ref>, an operation that flushes lines from a cache to the corresponding memory is necessary in order to have a realistic model of memories with cache, since usually  In the third line of the above definition of function Flush, x-&gt;Data denotes all the ordered pairs whose domains fall into the set x, and that range over the domain Data.</p><formula xml:id="formula_5">M : form → env → Boolean X : expr → env → value env = (var + type) → value value = (atom × • • • × atom)+ (atom → value) M [a in b]e = X[a]e ⊆ X[b]e M [!F ]e = ¬M [F ]e M [F &amp;&amp;G]e = M [F ]e ∧ M [G]e M [F || G]e = M [F ]e ∨ M [G]e M [all v : t/F ] = V {M [F ](e ⊕ v →{ x })/x ∈ e(t)} M [some v : t/F ] = W {M [F ](e ⊕ v →{ x })/x ∈ e(t)} X[a + b]e = X[a]e ∪ X[b]e X[a&amp;b]e = X[a]e ∩ X[b]e X[a -b]e = X[a]e \ X[b]e X[∼ a]e = { x, y : y, x ∈ X[a]e } X[a.b]e = X[a]e;X[b]e X[+a]e = the smallest r such that r ;r ⊆ r and X[a]e ⊆ r X[{v : t/F }]e = {x ∈ e(t)/M [F ](e ⊕ v →{ x })} X[v]e = e(v) X[a[v]]e = { y1</formula><p>Functions can also be used to represent special states. For instance, we can characterize the states in which the cache lines not marked as dirty are consistent with main memory:</p><formula xml:id="formula_6">fun DirtyInv(s: System) { all a : !s.cache.dirty | s.cache.map[a] = s.main.map[a] }<label>(2)</label></formula><p>In this context, the symbol "!" denotes negation, indicating in the above formula that "a" ranges over atoms that are non dirty addresses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Properties of a Model</head><p>As the reader might expect, a model can be enhanced by adding properties (axioms) to it. These properties are written as logical formulas, much in the style of the Object Constraint Language (OCL). Properties or constraints in Alloy are defined as facts. To give an idea of how constraints or properties are specified, we reproduce some here. It might be necessary to say that the sets of main memories and cache memories are disjoint: fact {no (MainMemory &amp; Cache)} In the above expression, "no x" indicates that x has no elements, and &amp; denotes intersection. Another important constraint inherent to the presented model is that, in every system, the addresses of its cache are a subset of the addresses of its main memory: fact {all s: System | s.cache.addrs in s.main.addrs} More complex facts can be expressed by using the quite considerable expressive power of the relational logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Assertions</head><p>Assertions are the intended properties of a given model. Consider, for instance, the following simple Alloy assertion, regarding the presented example: assert { all s: System | DirtyInv(s) &amp;&amp; no s.cache.dirty =&gt; s.cache.map in s.main.map } This assertion states that, if "DirtyInv" holds in system "s" and there are no dirty addresses in the cache, then the cache agrees in all its addresses with the main memory.</p><p>Assertions are used to check specifications. Using the Alloy analyzer, it is possible to validate assertions, by searching for possible (finite) counterexamples for them, under the constraints imposed in the specification of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DYNALLOY: ADDING PARTIAL CORRECTNESS ASSERTIONS TO ALLOY</head><p>In this section we extend Alloy's relational logic syntax and semantics with the aim of dealing with properties of executions of operations specified in Alloy. It will follow that DynAlloy extends Alloy and its relational logic.</p><p>The reason for this extension is that we want to provide a setting in which, besides functions describing sets of states, actions are made available, to represent state changes (i.e., to describe relations between input and output data). As opposed to the use of functions for this purpose, actions have an input/output meaning reflected in the semantics, and can be composed to form more complex actions, using wellknown constructs from imperative programming languages.</p><p>The syntax and semantics of DynAlloy is described in Section 3.1. It is worth mentioning at this point that both were strongly motivated by dynamic logic <ref type="bibr" target="#b3">[3]</ref>, and the suitability of dynamic logic for expressing partial correctness assertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Functions vs. Actions</head><p>Functions in Alloy are just parameterized formulas. Some of the parameters are considered input parameters, and the relationship between input and output parameters relies on the convention that the second argument is the result of the function application. Recalling the definition of function Write, notice that there is no actual change in the state of the system, since no variable actually changes its value.</p><p>Dynamic logic <ref type="bibr" target="#b3">[3]</ref> arose in the early '70s, with the intention of faithfully reflecting state change. Motivated by dynamic logic, we propose the use of actions to model state change in Alloy, as described below.</p><p>What we would like to say about an action is how it transforms the system state after its execution. A (now) traditional way of doing so is by using pre and post condition assertions. An assertion of the form {α} A {β} affirms that whenever action A is executed on a state satisfying α, if it terminates, it does so in a state satisfying β. This approach is particularly appropriate, since behaviors described by functions are better viewed as the result of performing an action on an input state. Thus, the definition of function Write could be expressed as an action definition, of the following form: (3) At first glance it is difficult to see the differences between (1) and (3), since both formulas seem to provide the same information. The crucial differences are reflected in the semantics, as well as in the fact that actions can be sequentially composed, iterated or composed by nondeterministic choice, while Alloy functions, in principle, cannot.</p><p>An immediately apparent difference between (1) and ( <ref type="formula">3</ref>) is that action Write does not involve the parameter m , while function Write uses it. This is so because we use the convention that m denotes the state of variable m after execution of action Write. This time, "after " means that m gets its value in an environment reachable through the execution of action Write (cf. Fig. <ref type="figure" target="#fig_3">3</ref>). Since Write denotes a binary relation on the set of environments, there is a precise notion of input/output inducing a before/after relationship.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Syntax and Semantics of DynAlloy</head><p>The syntax of DynAlloy's formulas extends the one presented in Fig. <ref type="figure">1</ref> with the addition of the following clause for building partial correctness statements: formula ::= . . . | {formula} program {formula} "partial correctness"</p><p>The syntax for programs (cf. Fig. <ref type="figure">2</ref>) is the class of regular programs defined in <ref type="bibr" target="#b3">[3]</ref>, plus a new rule to allow for the construction of atomic actions from their pre and post conditions. In the definition of atomic actions, x denotes a sequence of formal parameters. Thus, it is to be expected that the precondition is a formula whose free variables are within x, while postcondition variables might also include primed versions of the formal parameters.</p><p>In Fig. <ref type="figure" target="#fig_3">3</ref> we extend the definition of function M to partial correctness assertions and define the denotational semantics of programs as binary relations over env . The definition of function M on a partial correctness assertion makes clear that we are actually considering a partial correctness semantics. This follows from the fact that we are not requesting environment e to belong to the domain of the relation P [p]. In order to provide semantics for atomic actions, we will assume that there is a function A assigning, to each atomic action, a binary relation on the environments. We define function A as follows:</p><formula xml:id="formula_7">A( pre, post ) = ˘˙e, e ¸: M [pre]e ∧ M [post ]e ¯.</formula><p>There is a subtle point in the definition of the semantics of atomic programs. While actions may modify the value of all variables, we assume that those variables whose primed versions do not occur in the post condition retain their input value. Thus, the atomic action Write modifies the value of variable m, but a and d keep their initial values. This allows us to use simpler formulas in pre and post conditions.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Specifying Properties of Executions in Alloy and DynAlloy</head><p>Suppose we want to specify that a given property P is invariant under sequences of applications of the operations "Flush" and "SysWrite", from certain initial state. A technique useful for stating the invariance of a property P consists of specifying that P holds in the initial states, and </p><formula xml:id="formula_8">P (s) ∧ O(s, s ) ⇒ P (s ) .</formula><p>This specification is sound but incomplete, since the invariance may be violated in unreachable states. Of course it would be desirable to have a specification in which the states under consideration were exactly the reachable ones. This motivated the introduction of traces in Alloy <ref type="bibr" target="#b6">[6]</ref>.</p><p>The following example, extracted from <ref type="bibr" target="#b6">[6]</ref>, shows signatures for clock ticks and for traces of states. The first exclamation mark in the definition of "next"' means that this relation is total on its declared domain.  <ref type="figure">,</ref><ref type="figure">s',</ref><ref type="figure">d,</ref><ref type="figure">a</ref>) } If we now want to assert that P is invariant, it suffices to assert that P holds in the final state of every trace. Notice that unreachable states are no longer a burden because all states in a trace are reachable from the states that occurred before.</p><p>Even though, from a formal point of view, the use of traces is correct, from a modeling perspective it is less suitable. Traces are introduced in order to cope with the lack of real state change in Alloy. They allow us to port the primed variables used in single operations to sequences of applications of operations.</p><p>The specification of actions SysWrite and Flush in Dy-nAlloy is done as follows: Notice that the previous specifications are as understandable as the ones given in Alloy. Moreover, by using partial correctness statements on the set of regular programs generated by the set of atomic actions { SysWriteDA, FlushDA }, we can assert the invariance of a property P under finite applications of functions SysWrite and Flush in a simple and elegant way, as follows:</p><formula xml:id="formula_9">{ true } SysWriteDA(s: System) { some d:</formula><formula xml:id="formula_10">{Init(s) ∧ P (s)} (SysWriteDA(s) + FlushDA(s)) * {P (s )}</formula><p>More generally, suppose now that we want to show that a property Q is invariant under sequences of applications of arbitrary operations O1, . . . , O k , starting from states s described by a formula Init. The specification of this assertion in our setting is done via the following formula:</p><formula xml:id="formula_11">{Init(x ) ∧ Q(x)} (O1(x) + • • • + O k (x)) * (4) {Q(x )}</formula><p>Notice that there is no need to mention traces in the specification of the previous properties. This is because finite traces get determined by the semantics of reflexive-transitive closure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Analysis of DynAlloy Specifications</head><p>Alloy's design was deeply influenced by the intention of producing an automatically analyzable language. While Dy-nAlloy is, to our understanding, better suited than Alloy for the specification of properties of executions, the use of ticks and traces as defined in <ref type="bibr" target="#b6">[6]</ref> has as an advantage that it allows one to automatically analyze properties of executions.</p><p>Therefore, an almost mandatory question is whether DynAlloy specifications can be automatically analyzed, and if so, how efficiently. The main rationale behind our technique is the translation of partial correctness assertions to first-order Alloy formulas, using weakest liberal preconditions <ref type="bibr" target="#b1">[1]</ref>. The generated Alloy formulas, which may be large and quite difficult to understand, are not visible to the end user, who only accesses the declarative DynAlloy specification.</p><p>We define below a function wlp : program × formula → formula that computes the weakest liberal precondition of a formula according to a program (composite action). We will in general use names x1, x2 . . . for program variables, and will use names x 1 , x 2 , . . . for the value of program variables after action execution. We will denote by α| v x the substitution of all free occurrences of variable x by the fresh variable v in formula α.</p><p>When an atomic action a specified as pre, post (x) is used in a composite action, formal parameters are substituted by actual parameters. Since we assume all variables are input/output variables, actual parameters are variables, let us say, y. In this situation, function wlp is defined as follows:</p><formula xml:id="formula_12">wlp[a(y), f] = pre| y x =⇒ all n " post| n x | y x =⇒ f | n y " .<label>(5)</label></formula><p>A few points need to be explained about <ref type="bibr" target="#b5">(5)</ref>. First, we assume that free variables in f are amongst y , x0. Variables in x0 are generated by translation pcat given in <ref type="bibr">(7)</ref>. Second, n is an array of new variables, one for each variable modified by the action. Last, notice that the resulting formula has again its free variables amongst y , x0. This is also preserved in the remaining cases in the definition of function wlp.</p><p>For the remaining action constructs, the definition of function wlp is the following:</p><formula xml:id="formula_13">wlp[g?, f] = g =⇒ f wlp[p1 + p2, f] = wlp[p1, f] ∧ wlp[p2, f] wlp[p1 ;p2, f] = wlp[p1, wlp[p2, f]] wlp[p * , f] = V ∞ i=0 wlp[p i , f] .</formula><p>Notice that wlp yields Alloy formulas in all these cases, except for the iteration construct, where the resulting formula may be infinitary. In order to obtain an Alloy formula, we can impose a bound on the depth of iterations. This is equivalent to fixing a maximum length for traces. A function Bwlp (bounded weakest liberal precondition) is then defined exactly as wlp, except for iteration, where it is defined by:</p><formula xml:id="formula_14">Bwlp[p * , f] = n î=0 Bwlp[p i , f] .<label>(6)</label></formula><p>In <ref type="bibr" target="#b6">(6)</ref>, n is the scope set for the depth of iteration. We now define a function pcat that translates partial correctness assertions to Alloy formulas. For a partial correctness assertion {α(y)} P (y) {β(y, y )}</p><formula xml:id="formula_15">pcat ({α} P {β}) = ∀y " α =⇒ " Bwlp h p, β| x 0 y i" | y y | y x 0 " .<label>(7)</label></formula><p>Of course this analysis method where iteration is restricted to a fixed depth is not complete, but clearly it is not meant to be; from the very beginning we placed restrictions on the size of domains involved in the specification to be able to turn first-order formulas into propositional formulas. This is just another step in the same direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE DYNALLOY TOOL</head><p>The Alloy tool <ref type="bibr" target="#b5">[5]</ref> is open source. This contributes greatly toward developing extensions of the tool. DynAlloy is an extension of the Alloy tool that allows the user to write and analyze specifications involving actions. Once a DynAlloy specification (involving actions) is opened, executing the Build command first translates the DynAlloy specification to Alloy using function pcat , and then compiles the Alloy specification thus obtained.</p><p>In this section we discuss some modifications on the definition of function pcat provided in <ref type="bibr">(7)</ref> that will allow us to analyze specifications efficiently. We also describe some implementation details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Translating Partial Correctness Assertions to Alloy</head><p>In Section 3.4 we showed how to compute the weakest liberal precondition wlp and its bounded version Bwlp for an arbitrary composite action. For atomic actions a and b, Bwlp(a;b, α) is a formula whose shape is roughly</p><formula xml:id="formula_16">prea(s) ⇒ ∀s1(posta(s, s1) ⇒ (pre b (s1) ⇒ ∀s2 (post b (s1, s2) ⇒ α(s2)))) . (8)</formula><p>When Alloy was fed with a formula like (8) for three actions, two problems arose:</p><p>1. Compilation time was almost unacceptable.</p><p>2. Analysis time was in general worse than the time obtained using traces.</p><p>Notice that the quantifiers binding variables s1 and s2 can be promoted to the front of the formula by simple logical manipulations, yielding ∀s1∀s2(prea(s) ⇒ (posta(s, s1) ⇒</p><formula xml:id="formula_17">(pre b (s1) ⇒ (post b (s1, s2) ⇒ α(s2))))) . (9)</formula><p>Feeding Alloy with a formula like (9) produced running times that were, in general, significantly better than those achieved in Alloy using traces. On the negative side, for an action of the form (a1 +a2) n , the resulting formula was considerably large. For n = 2, using the definition of Bwlp, we obtain:</p><formula xml:id="formula_18">Bwlp `(a+b) 2 , α = Bwlp ((a+b);(a+b), α) = Bwlp (a+b, Bwlp (a+b, α)) = Bwlp (a, Bwlp (a+b, α)) ∧ Bwlp (b, Bwlp (a+b, α)) = prea ⇒ (posta ⇒ Bwlp (a+b, α)) ∧ pre b ⇒ (post b ⇒ Bwlp (a+b, α)) . (<label>10</label></formula><formula xml:id="formula_19">)</formula><p>Simple logical properties allow us to rewrite (10) as</p><formula xml:id="formula_20">(prea ∧ posta) ⇒ Bwlp (a+b, α) ∧ (pre b ∧ post b ) ⇒ Bwlp (a+b, α) . (<label>11</label></formula><formula xml:id="formula_21">)</formula><p>At this point, notice that the formula Bwlp(a+b, α) appears twice in (11). Thus computing Bwlp ((a+b) n , α) yields a formula whose size is exponential as a function of n. Feeding Alloy with a formula like (11) produced, for small values of n, analysis times that were significantly better that those achieved using traces. Unfortunately, compilation time grew exponentially, proving that analysis using this translation was unfeasible for reasonable values of n.</p><p>Once again, elementary properties of first-order logic allow us to transform (11) to the equivalent formula</p><formula xml:id="formula_22">((prea ∧ posta) ∨ (pre b ∧ post b )) ⇒ Bwlp (a+b, α) . (<label>12</label></formula><formula xml:id="formula_23">)</formula><p>Formula Bwlp (a+b, α) occurs only once in (12). Applying this simple transformation made the previous exponentialsize formulaes become linear-size. This is the translation that is implemented in the DynAlloy tool.</p><p>Running times very much depend on the chosen SAT solver, and while our translation works well in all of them, different optimizations can be applied depending on the particular SAT solver chosen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation Details</head><p>Not only the source code for Alloy is publicly available. All the necessary software and tools required in order to generate the source code are freely available, too. For instance, the Alloy grammar specification, as required by JavaCC (a parser generator for Java), is also supplied. We extended this grammar specification to a specification of DynAlloy's grammar. Combining the use of the tools JJTree and JavaCC, we built a parser and abstract syntax tree generator for Dy-nAlloy. Given a tree for a DynAlloy model, we apply transformations leading to an Alloy specification.</p><p>In order to make this process invisible to the end user, we modified distribution 2.0 of the Alloy Analyzer.We changed the original Alloy Build command so that it now first translates a DynAlloy specification to Alloy, and then compiles the resulting model, in the way standard Alloy does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CASE-STUDIES</head><p>In this section we analyze two case-studies. The first one is an assertion whose validity follows from the specification, and, therefore, has no counterexamples. It will serve us as a stress test for Alloy and DynAlloy. The second assertion has counterexamples, and is useful for verifying how efficiently can these be found using DynAlloy. The analysis was carried out using a Sun Sunblade 2000, with two 1GHz processors, and 2 GB of RAM. For the analysis we will impose a limit of 60'. Those runs that did not finish within 60' were stopped and marked in the tables as "&gt; 60 ".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Case-Study 1: DirtyInv</head><p>The problem we will analyze is whether function Dirty-Inv, defined in <ref type="bibr" target="#b2">(2)</ref>, is an invariant with respect to finite applications of operations SysWrite and Flush. Its Alloy specification is the following: The corresponding DynAlloy specification is:</p><p>assert DirtyInvAssertionDynAlloy { {DirtyInv(s)} (SysWriteDA(s) + FlushDA(s))* {DirtyInv(s')} } Notice that these specifications are quite similar, in the sense that both predicate only about the initial and final states. In Tables 1-3 we compare running CPU times for the analysis of both specifications for different trace lengths, domain sizes, and the available SAT solvers.</p><p>The "check" condition used in the Alloy specification for traces of length n and domains of size k, is: check DirtyInvAssertionAlloy for k but n+1 Tick, 1 SystemTrace.</p><p>For the DynAlloy specification, we use: check DirtyInvAssertionDynAlloy for k. Table <ref type="table">3</ref>: Verification time for the assertion DirtyInv using the SAT solver Berkmin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Case-Study 2: FreshDir</head><p>Given an initially empty CacheSystem whose set of addresses has size k, we will assert that every sequence of applications of the operations SysWrite and Flush still leaves a "fresh" address, that is, an address that has never been written into. This is a flawed assertion. In order to write the assertion, we require a function specifying that a CacheSystem is empty, and another describing the fresh address property. They are given next.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>problem ::= decl * form decl ::= var : typexpr typexpr ::= type | type → type | type ⇒ typexpr form ::= expr in expr (subset) |!form (neg) | form &amp;&amp; form (conj) | form || form (disj) | all v : type/form (univ) | some v : type/form (exist) expr ::= expr + expr (union) | expr &amp; expr (intersection) | exprexpr (difference) |∼ expr (transpose) | expr.expr (navigation) | +expr (transitive closure) | {v : t/form} (set former) | V ar V ar ::= var (variable) | V ar[var] (application)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>: Memory, d : Data, a : Addr) {m .map = m.map ++ (a → d)} .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>M</head><label></label><figDesc>[{α}p{β}]e = M [α]e =⇒ ∀e `˙e, e ¸∈ P [p] =⇒ M [β]e Ṕ : program → P (env × env ) P [ pre, post ] = A( pre, post ) P [α?] = { e, e : M [α]e ∧ e = e } P [p1 + p2] = P [p1] ∪ P [p2] P [p1 ;p2] = P [p1];P [p2] P [p * ] = P [p] *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Semantics of DynAlloy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>assert DirtyInvAssertionAlloy { all tr: SystemTrace | DirtyInv(tr.state[tr.first]) =&gt; DirtyInv (tr.state[tr.last])}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 : Verification time for the assertion DirtyInv using the SAT solver MChaff.</head><label>1</label><figDesc></figDesc><table><row><cell>Tr. length →</cell><cell></cell><cell>≤ 2</cell><cell></cell><cell>≤ 3</cell><cell></cell><cell>≤ 4</cell></row><row><cell># elems ↓</cell><cell>Alloy</cell><cell>DAlloy</cell><cell>Alloy</cell><cell>DAlloy</cell><cell>Alloy</cell><cell>DAlloy</cell></row><row><cell>3</cell><cell>0 01</cell><cell>0 01</cell><cell>0 04</cell><cell>0 02</cell><cell>0 20</cell><cell>0 07</cell></row><row><cell>4</cell><cell>0 13</cell><cell>0 01</cell><cell>3 04</cell><cell>0 11</cell><cell>45 25</cell><cell>1 48</cell></row><row><cell>5</cell><cell>1 40</cell><cell>0 03</cell><cell>34 40</cell><cell>0 59</cell><cell>&gt; 60</cell><cell>31 17</cell></row><row><cell>6</cell><cell>5 52</cell><cell>0 06</cell><cell>&gt; 60</cell><cell>2 24</cell><cell>&gt; 60</cell><cell>&gt; 60</cell></row><row><cell>Tr. length →</cell><cell></cell><cell>≤ 2</cell><cell></cell><cell>≤ 3</cell><cell cols="2">≤ 4</cell></row><row><cell># elems ↓</cell><cell>Alloy</cell><cell>DAlloy</cell><cell>Alloy</cell><cell>DAlloy</cell><cell>Alloy</cell><cell>DAlloy</cell></row><row><cell>3</cell><cell>0 02</cell><cell>0 06</cell><cell>0 07</cell><cell>2 17</cell><cell>0 24</cell><cell>31 53</cell></row><row><cell>4</cell><cell>0 16</cell><cell>0 18</cell><cell>6 48</cell><cell>1 57</cell><cell>&gt; 60</cell><cell>&gt; 60</cell></row><row><cell>5</cell><cell>5 31</cell><cell>0 40</cell><cell>&gt; 60</cell><cell>9 53</cell><cell>&gt; 60</cell><cell>&gt; 60</cell></row><row><cell>6</cell><cell>&gt; 60</cell><cell>0 58</cell><cell>&gt; 60</cell><cell>&gt; 60</cell><cell>&gt; 60</cell><cell>&gt; 60</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 : Verification time for the assertion DirtyInv using the SAT solver ZChaff.</head><label>2</label><figDesc></figDesc><table><row><cell>Tr. length →</cell><cell></cell><cell>≤ 2</cell><cell></cell><cell>≤ 3</cell><cell></cell><cell>≤ 4</cell></row><row><cell># elems ↓</cell><cell>Alloy</cell><cell>DAlloy</cell><cell>Alloy</cell><cell>DAlloy</cell><cell>Alloy</cell><cell>DAlloy</cell></row><row><cell>3</cell><cell>0 01</cell><cell>0 01</cell><cell>0 01</cell><cell>0 01</cell><cell>0 06</cell><cell>0 01</cell></row><row><cell>4</cell><cell>0 05</cell><cell>0 01</cell><cell>0 29</cell><cell>0 02</cell><cell>4 35</cell><cell>0 09</cell></row><row><cell>5</cell><cell>0 16</cell><cell>0 01</cell><cell>2 01</cell><cell>0 10</cell><cell>20 18</cell><cell>0 47</cell></row><row><cell>6</cell><cell>0 55</cell><cell>0 04</cell><cell>8 15</cell><cell>0 32</cell><cell>&gt; 60</cell><cell>5 29</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Given a n-ary relation R, dom (R) denotes the set { a1 : ∃a2, . . . , an such that a1, a2, . . . , an ∈ R }.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In order to guarantee that there are n addresses, we check the assertion imposing a scope of n for signature Addr and include as part of the model a fact asserting that there are n distinct elements for this signature. So, we verify the Alloy assertion using the command check FreshDirAssertionAlloy for 3 but n Addr, n+1 Memory, n+1 System, n+1 Tick, 1 SystemTrace.</p><p>For DynAlloy we use check FreshDirAssertionDynAlloy for 3 but n Addr, n+1 Memory, n+1 System. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS AND FURTHER WORK</head><p>We believe that using actions within Alloy in order to represent state change is a methodological improvement. Effectively, using actions favors a better separation of concerns, since models do not need to be reworked in order to describe the adequate notion of trace modeling the desired behavior. Using actions the problem reduces to describing how actions are to be composed. This methodological improvement is supported by empirical results evidencing that analysis can be done more efficiently than resorting to traces.</p><p>The shape of the formulas obtained during the translation of partial correctness assertions into Alloy gives us the opportunity of parallelizing their analysis process, allowing for the analysis of larger models.</p><p>Different SAT solvers react differently to the formulas resulting from the translation. While all of them behave satisfactorily, we can still generate different translations depending on the chosen SAT solver, in order to improve the analysis time.</p><p>Finally, a new version of Alloy (Alloy 3.0) has been made recently available. All our developments will be ported to this new version as soon as its source code is released.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Predicate calculus and program semantics</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Scholten</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">BerkMin: A fast and robust sat-solver</title>
		<author>
			<persName><forename type="first">E</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Novikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Design, automation and test in Europe</title>
		<meeting>the conference on Design, automation and test in Europe</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="142" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Dynamic logic. Foundations of Computing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tiuryn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Alloy: a lightweight object modelling notation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A micromodels of software: Lightweight modelling and analysis with Alloy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jackson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Association for the Computer Machinery</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Shlyakhter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sridharan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th European software engineering conference held together with the 9th ACM SIGSOFT international symposium on Foundations of software engineering</title>
		<meeting>the 8th European software engineering conference held together with the 9th ACM SIGSOFT international symposium on Foundations of software engineering<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
	<note>A micromodularity mechanism</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Chaff: engineering an efficient SAT solver</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th conference on Design automation</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Rabaey</surname></persName>
		</editor>
		<meeting>the 38th conference on Design automation<address><addrLine>Las Vegas, Nevada, United States</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="530" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Understanding Z: a specification language and its formal semantics</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Spivey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
