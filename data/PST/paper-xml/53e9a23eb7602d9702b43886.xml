<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Online Competitive Algorithms for Maximizing Weighted Throughput of Unit Jobs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yair</forename><surname>Bartal</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution">The Hebrew University of Jerusalem</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Francis</forename><forename type="middle">Y L</forename><surname>Chin</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Information Systems</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marek</forename><surname>Chrobak</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Stanley</forename><forename type="middle">P Y</forename><surname>Fung</surname></persName>
							<email>pyfung@csis.hku.hk</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Information Systems</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wojciech</forename><surname>Jawor</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ron</forename><surname>Lavi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution">The Hebrew University of Jerusalem</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jiří</forename><surname>Sgall</surname></persName>
							<email>sgall@math.cas.cz.</email>
							<affiliation key="aff3">
								<orgName type="institution">Mathematical Institute, AS CR</orgName>
								<address>
									<addrLine>Žitná 25</addrLine>
									<postCode>CZ-11567</postCode>
									<settlement>Praha 1</settlement>
									<country>Czech Republic. Email</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tomáš</forename><surname>Tichý</surname></persName>
							<email>tichy@math.cas.cz.</email>
							<affiliation key="aff3">
								<orgName type="institution">Mathematical Institute, AS CR</orgName>
								<address>
									<addrLine>Žitná 25</addrLine>
									<postCode>CZ-11567</postCode>
									<settlement>Praha 1</settlement>
									<country>Czech Republic. Email</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Online Competitive Algorithms for Maximizing Weighted Throughput of Unit Jobs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7E0BC5AF2275F018FFC91F422258B52E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study an online buffer management problem for networks supporting Quality-of-Service (QoS) applications. Packets with different QoS values arrive at a network switch and are to be sent along an outgoing link. Due to overloading conditions, some packets have to be dropped. The objective is to maximize the total value of packets that are sent. We formulate this as an online scheduling problem for unit-length jobs, where each job is specified by its release time, deadline, and a nonnegative weight (QoS value). The goal is to maximize the weighted throughput, that is the total weight of scheduled jobs.</p><p>We first give a randomized algorithm RMix with competitive ratio of e/(e -1) ≈ 1.582. This is the first algorithm for this problem with competitive ratio smaller than 2. Then we consider s-bounded instances where the span of each job (deadline minus release time) is at most s. We give a 1.25-competitive randomized algorithm for 2-bounded instances, matching the known lower bound. We give a deterministic algorithm Edf α , whose competitive ratio on s-bounded instances is at most 2 -2/s + o(1/s). For 3-bounded instances its ratio is φ ≈ 1.618, matching the lower bound. Previously, an upper bound of φ was known for 2-bounded instances, and our work extends this result.</p><p>Next, we consider 2-uniform instances, where the span of each job is exactly 2. We prove a lower bound of 4 -2 √ 2 ≈ 1.172 for randomized algorithms. For deterministic memoryless algorithms, we prove a lower bound of √ 2 ≈ 1.414, matching a known upper bound. Finally, we consider the multiprocessor case and give an 1/(1 -( M M +1 ) M )-competitive algorithm for M processors. We also show improved lower bounds for the general and 2-uniform cases.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Network protocols today offer only the 'best-effort service', the term -misnomer, in fact -that describes the most basic level of service that does not involve firm guarantees for packet delivery. Next-generation networks, however, will provide support for differentiated services, to meet various quality-of-service (QoS) demands from the users. In this paper we consider an online buffer management problem that arises in such QoS applications.</p><p>In the bounded delay buffer problem <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b3">4]</ref>, packets arrive and are buffered at network switches. At each integer time step, only one packet can be sent along the link. Each packet is characterized by its QoS value, which can be thought of as a benefit gained by forwarding the packet. Network switches can use this QoS value to prioritize the packets. Each packet has a deadline that indicates the latest time when a packet can be sent. In overload conditions, some packets will not be sent by their deadline. Such packets do not contribute to the benefit value, and can as well be dropped. The objective is to maximize the total value of the forwarded packets, that is the weighted throughput.</p><p>It is easy to see that this buffer management problem is equivalent to the following unit-job scheduling problem. We are given a set of n unit-length jobs, with each job j specified by a triple (r j , d j , w j ) where r j and d j are integral release times and deadlines, and w j is a non-negative real weight. One job can be processed at each integer time. We use the term weighted throughput or gain for the total weight of the jobs completed by their deadline. The goal is to compute a schedule for the given set of jobs that maximizes the weighted throughput. In Graham's notation, this problem can be described as 1|p j = 1, r j | j w j U j .</p><p>In this paper we focus on the online version of this problem, where each job arrives at its release time. At each time step, an online algorithm needs to schedule one of the pending jobs, without the knowledge of the jobs released later in the future. An online algorithm A is called R-competitive, if its gain on any instance is at least 1/R times the optimum (offline) gain on this instance. The smallest such value R is called the competitive ratio of A. The competitive ratio is commonly used as a performance measure for online algorithms, and we adopt this measure in this paper.</p><p>For unit jobs, some restrictions on instances have been proposed in the literature <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b10">11]</ref>. In s-bounded instances, the span of the jobs (defined as the difference between the deadline and the release time) is at most s, and in s-uniform instances the span of each job is exactly s. In the context of QoS buffer management, these cases correspond to QoS situations in which the end-to-end delay is critical and only a small amount of delay is allowed at each node <ref type="bibr" target="#b14">[15]</ref>.</p><p>The unit-job scheduling problem is related to another scheduling problem which also arises from QoS applications. In metered-task model <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12]</ref>, each job is specified by four real numbers: release time, deadline, processing time (not necessarily unit), and weight. Preemptions are allowed. Unlike in classical scheduling, even non-completed jobs contribute to the overall gain. Specifically, the gain of a job is proportional to the amount of it that was processed. This problem arises as a QoS problem of transferring large images over a network of low bandwidth <ref type="bibr" target="#b7">[8]</ref>. It is also related to a problem called imprecise computation in real-time systems, and has applications in numerical computation, heuristic search, and database query processing (see <ref type="bibr" target="#b15">[16]</ref>).</p><p>Past work. A naive greedy algorithm that always schedules the heaviest job is known to be 2competitive <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref>. No better algorithm, deterministic or randomized, is known for the general case. For the deterministic case, a lower bound of φ ≈ 1.618 was shown in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14]</ref>. In the randomized case, <ref type="bibr" target="#b10">[11]</ref> give a lower bound of 1.25. (The proof in <ref type="bibr" target="#b10">[11]</ref> was for metered tasks, but it carries over to unit jobs.) Both of those lower bounds apply even to 2-bounded instances.</p><p>For the 2-bounded case, a φ-competitive (and thus optimal) algorithm was presented in <ref type="bibr" target="#b14">[15]</ref>. Deterministic algorithms for 2-uniform instances were studied by <ref type="bibr" target="#b3">[4]</ref>, who established a lower bound of 1  2 ( √ 3 + 1) ≈ 1.366 and an upper bound of √ 2 ≈ 1.414. In <ref type="bibr" target="#b14">[15]</ref>, a version of the buffer management problem was studied in which the output port has bandwidth M (that is, M packets at a time can be sent). This corresponds to the problem of scheduling unit-time jobs on M processors. In <ref type="bibr" target="#b14">[15]</ref> a lower bound of 4 -2 √ 2 was presented that applies even to the 2-bounded model. For the 2-uniform case, a lower bound of 10/9 was given.</p><p>Other models of buffer management were considered in the literature <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b1">2]</ref>. For example, in the FIFO model, the buffer has finite capacity, and packets must be forwarded in the same order as they arrive, although some packets can be dropped (in the preemptive version). An online algorithm needs to decide which packets to admit into the buffer, and then which packets to drop. In <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> switches with many input queues and a single output queue have been considered.</p><p>Our results. First, we give a randomized algorithm with competitive ratio e/(e -1) ≈ 1.582, which is the first algorithm for this problem with competitive ratio below 2. Our algorithm has been inspired by the techniques developed in <ref type="bibr" target="#b11">[12]</ref> for metered tasks.</p><p>For 2-bounded instances, we give a 1.25-competitive randomized algorithm, matching the known lower bound from <ref type="bibr" target="#b10">[11]</ref>.</p><p>We also give a deterministic algorithm Edf α whose competitive ratio on 3-bounded instances is φ = 1.618, matching the lower bound. This result extends previous results from the literature for 2-bounded instances <ref type="bibr" target="#b14">[15]</ref>, and it provides evidence that a φ-competitive deterministic algorithm might be possible for the general case. For 4-bounded instances, Edf α is √ 3 ≈ 1.732 competitive, and for s-bounded instances it is 2 -2/s + o(1/s) competitive. However, without the restriction on the span, it is only 2-competitive.</p><p>For 2-uniform instances, we prove a lower bound of 4 -2 √ 2 ≈ 1.172 for randomized algorithms, improving the 10/9 bound from <ref type="bibr" target="#b14">[15]</ref>. In the deterministic case, we prove a lower bound of √ 2 ≈ 1.414 on algorithms that are memoryless and scale-invariant (that is, the algorithm's decision is invariant under multiplying all weights of pending jobs by a constant.) This matches the previously known upper bound in <ref type="bibr" target="#b3">[4]</ref>. We remark that all competitive algorithms for unit-job scheduling in the literature are memoryless and scale-invariant.</p><p>The known bounds are summarized in the Finally, we study the multiprocessor case, M |online-time, p j = 1, r j | j w j U j in Graham's notation, that corresponds to the buffer management problem in which the output port has bandwidth M , meaning that it can send M packets at a time. We give a 1/(1 -( M M +1 ) M )-competitive algorithm for the case of M processors. For randomized algorithms, we also show improved lower bounds of 1.25 for the general and 4 -2 √ 2 ≈ 1.172 for the 2-uniform cases. In addition to those results, we introduce a new algorithm called Bal β , where β is a parameter, and we analyze it in several cases. On 2-uniform instances, Bal √ 2/2 is √ 2-competitive, matching the bound from <ref type="bibr" target="#b3">[4]</ref>. On 2-bounded instances, Bal β is φ-competitive (and thus optimal) for two values of β ∈ {2φ, φ -1}. It is also φ-competitive for 3-bounded instances. Although we can show that Bal β cannot be φ-competitive in general, we conjecture that for some values of β its ratio is better than 2.</p><p>Our results show the power of randomization for the problem of scheduling unit jobs. For the general version, our randomized algorithm outperforms all deterministic algorithms, even on the special case of span 2. For span 2, we give a tight analysis of the randomized case, showing a surprisingly low competitive ratio of 1.25, compared to 1.618 in the deterministic case.</p><p>Our understanding of the power of randomization in online problems, and scheduling in particular, is still very limited. The best known online problem where randomization provably helps and the analysis of the competitive ratio of randomized algorithms is tight is caching <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b0">1]</ref>. In the area of scheduling, for the basic problem of makespan scheduling on identical machines, the case of two machines is fully understood <ref type="bibr" target="#b6">[7]</ref>, there are some partial results for a small number of machines <ref type="bibr" target="#b18">[19]</ref>, and a randomized algorithm for the general case that outperforms the known deterministic algorithms was found only recently <ref type="bibr" target="#b2">[3]</ref>. We believe that our results and techniques contribute to better understanding of randomization in the online setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Unit job scheduling. As we noted in the introduction, the QoS buffer management problem is equivalent to the unit-job scheduling problem. We will henceforth use job scheduling terminology in this paper. We number the jobs 1, 2, . . . , n. Each job j is specified by a triple (r j , d j , w j ), where r j and d j are integral release times and deadlines, and w j is a non-negative real weight. A schedule S specifies which jobs are executed, and for each executed job j it specifies an integral time t when it is scheduled, where r j ≤ t &lt; d j . Only one job can be scheduled at any given time step. The throughput or gain of a schedule S on instance I, denoted gain S (I), is the total weight of the jobs in I that are executed in S. Similarly, if A is a scheduling algorithm, gain A (I) is the gain of the schedule computed by A on I. The optimal gain on I is denoted by opt(I). We say that an instance is s-bounded if d jr j ≤ s for all jobs j. Similarly, an instance is s-uniform if d jr j = s for all jobs j. The difference d jr j is called the span of a job j. A job i is pending in schedule S at t if r i ≤ t &lt; d i and i has not been scheduled before t.</p><p>Earliest-deadline schedules. We often assume that (offline) schedules are (canonical) earliestdeadline. In such schedules, for each time t, the job that is scheduled at t is chosen (from the ones that are executed in the schedule) as the pending job with the earliest deadline. Any schedule can be easily converted into an earliest-deadline schedule by rearranging its jobs. To break ties, jobs with the same deadline are ordered in order of decreasing weights. (Jobs with equal weights are ordered arbitrarily, but consistently, namely our algorithms and the adversary are assumed to break such ties in the same way; alternatively we may assume that no weights are exactly equal.)</p><p>Competitive analysis. We often view the behavior of an online algorithm A as a game between A and an adversary. Both algorithms schedule jobs released by the adversary who tries to maximize the ratio opt(I)/gain A (I). Most of the proofs are based on a potential function argument. In such proofs, we define a potential function Φ that maps all possible configurations into real numbers. At each time step, an online algorithm and the adversary execute a job. The proofs are based on the following lemma which can be proven by a simple summation over all steps. Lemma 2.1 Let A be an online algorithm for scheduling unit jobs. Let Φ be a potential function that is 0 on configurations with no pending jobs, and at each step satisfies R • ∆gain A ≥ ∆adv + ∆Φ, where ∆Φ represents the change of the potential, and ∆gain A , ∆adv represent A's and the adversary gain in this step. Then A is R-competitive.</p><p>The lemma above applies to randomized algorithms as well. In that case, however, ∆gain A and ∆Φ are the expected values of the corresponding quantities, with respect to the algorithm's random choices at the given step.</p><p>In some proofs we use a different approach called charging. In a charging scheme, the weight of each of the jobs in the adversary schedule is charged to a job, or several jobs, in our schedule, in such a way that each job in our schedule is charged at most R times its weight. If such a charging scheme exists, it implies that our algorithm is R-competitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Metered tasks.</head><p>As discussed in the introduction, our problem is related to the metered-task model. Consider the discrete metered-task model, in which jobs have integral release times, deadlines and processing lengths, and the algorithm can only switch jobs at integral times. (In <ref type="bibr" target="#b10">[11]</ref> this model is called non-timesharing.) Then: Theorem 2.2 The unit-job scheduling problem with a single processor is equivalent to the single processor discrete metered-task model. The unit-job scheduling problem with M processors is a special case of the M -processor discrete metered-task model (assuming jobs are migratory); they are equivalent when, in addition, all jobs in the metered-task model are of unit length.</p><p>The theorem can be easily proved by observing that each job in the discrete metered-task model of length p can be transformed into p unit-length jobs, each having the same release time, deadline and weight as the original job. Note that for the multiprocessor case and arbitrary jobs, the problems are not equivalent because a long job cannot be processed by several processors simultaneously, while a number of different unit-length jobs can be processed in this way.</p><p>The continuous version of the metered-task model <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b10">11]</ref> bears some resemblance to the randomized case of unit-job scheduling, although it is not clear whether the results from the former model can be automatically translated into results for the latter model. One may attempt to convert a deterministic algorithm D for metered tasks into a randomized R algorithm for unit jobs, by setting the probability of R executing a given job j to be equal to D's fraction of the processor power devoted to j. It is not hard to see, however, that, in general, the expected gain of R will not be the same as the gain of D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Randomized Algorithm RMix</head><p>In this section we give a randomized algorithm for scheduling unit jobs with competitive ratio e/(e -1) ≈ 1.582. This is the first algorithm for unit jobs with competitive ratio smaller than 2.</p><p>Algorithm RMix. At each step, we inductively select a sequence of pending jobs h 1 , . . . , h k as follows: (i) h 1 is the heaviest job, (ii) h i+1 is the heaviest job j such that w j &gt; w h 1 /e and d j &lt; d h i ; if such j does not exist, we set k = i. In case of ties, prefer jobs with earlier deadlines. Denote v i = w h i for i = 1, . . . , k and v k+1 = w h 1 /e. The algorithm executes job h i with probability</p><formula xml:id="formula_0">δ i = ln(v i ) -ln(v i+1 ). (Note that k i=1 δ i = ln v 1 -ln v k+1 = 1.) Theorem 3.1 Algorithm RMix is e e-1 ≈ 1.582-competitive.</formula><p>Proof: At a given time step, let X be the set of pending jobs in RMix, and let Y be the set of pending jobs in the adversary schedule that the adversary will schedule in the future. We assume that the adversary schedule is canonical earliest-deadline.</p><p>Define the potential Φ = i∈Y -X w i . Job arrivals and expirations cannot increase the potential as these jobs are not in Y -X: the arriving job is always in X and the expiring job is never in Y by the definition of Y . So we only need to analyze how the potential changes after job execution. Consider a given time step. Using the notation from the algorithm, the expected gain of RMix is ω = k i=1 δ i v i . Thus, by Lemma 2.1, denoting by j the job scheduled by the adversary, it sufficient to prove that w j + ∆Φ ≤ e e-1 ω. Suppose first that j ∈ Y -X. Executing j by the adversary decreases Φ by w j . At the same time, one of h 1 , . . . , h k may be added to Y -X, h i with probability δ i , increasing the expected value of Φ by at most ω. So ∆Φ ≤ -w j + ω. It follows that</p><formula xml:id="formula_1">w j + ∆Φ ≤ ω ≤ e e-1 ω. Now assume that j ∈ Y ∩ X. Inequality ln x ≤ x -1 for x = v i+1 /v i implies that, for any i ≤ k, v i -v i+1 ≤ v i (ln v i -ln v i+1 ) = δ i v i .<label>(1)</label></formula><p>We have w j ≤ v 1 as j ∈ X. Let p ∈ {1, . . . , k + 1} be the largest index such that w j ≤ v p . By the assumption that the adversary schedule is earliest-deadline, we know that he will not execute any h i , i = p, . . . , k, in the future, so these are not in Y . The expected increase of Φ is then at most p-1 i=1 δ i v i . So, using v k+1 = v 1 /e and (1), we have</p><formula xml:id="formula_2">w j + ∆Φ ≤ v p + p-1 i=1 δ i v i = e e-1 (v p -v k+1 ) + 1 e-1 (v 1 -v p ) + p-1 i=1 δ i v i = e e-1 k i=p (v i -v i+1 ) + 1 e-1 p-1 i=1 (v i -v i+1 ) + p-1 i=1 δ i v i ≤ e e-1 k i=p δ i v i + 1 e-1 p-1 i=1 δ i v i + p-1 i=1 δ i v i = e e-1 ω. 2</formula><p>4 An Optimal Randomized Algorithm for 2-Bounded Instances</p><p>In this section we give a randomized algorithm for 2-bounded instances with competitive ratio 1.25. This matches the lower bound from <ref type="bibr" target="#b10">[11]</ref>, and thus completely resolves this case. To simplify terminology and notation, we will use the weights of jobs to identify jobs. Thus, we will say "job w" meaning "the job with weight w".</p><p>Algorithm R2b. Define p ab = 1 if a ≥ b and p ab = 4a 5b otherwise. Let q ab = 1p ab . Let a and b denote the heaviest jobs of span 1 and span 2, respectively, released at this time step. If the currently pending job is x, let u = max(x, a). Execute u with probability p ub and b with probability q ub . Theorem 4.1 Algorithm R2b is 1.25-competitive.</p><p>Proof: Without loss of generality, we can assume that at each step (except last) exactly one job of span 1 is issued. All jobs of span 1 except the heaviest one can be simply ignored; if no job is issued, we treat it as a job of weight 0. Similarly, we can assume that at each step (except last) exactly one job of span 2 is issued. This can be justified as follows: If, at a given time t, the optimum schedule contains a job of span two released at t, we can assume that it is the heaviest such job. A similar statement holds for Algorithm R2b, since its decision at each step depends only on the heaviest job of span 2. Thus all the other jobs of span 2 can be ignored in this step, and treated as if they are issued with span 1 in the following time step.</p><p>First note that p ab satisfies the following properties for any a, b ≥ 0.</p><formula xml:id="formula_3">5p ab a ≥ 4a -b (2) 5(p ab a + q ab b) ≥ 4b (3) 5p ab a + 2q ab b ≥ 4a (4) 5p ab a + 2q ab b ≥ b (5)</formula><p>Algorithm R2b is memoryless and randomized, so its state at each step is given by a pair x, s , where x is the job of span 2 issued in the previous step, and s is the probability that x was executed in the previous step (i.e., no job is pending). Denote t = 1s the probability that x is pending.</p><p>Denoting by z ∈ {0, x} the pending job of the adversary, the complete configuration at this step is described by a triple x, s, z . Let Φ xsz denote the potential function in the configuration x, s, z . We put Φ xs0 = 0 and Φ xsx = 1  4 x • max(5s -1, 3s). Consider one step, where the configuration is x, s, z , two jobs a, b are issued, of span 1 and span 2, respectively. The new configuration is b, s ′ , z ′ , where s ′ = sq ab + tq x ′ b , x ′ = max(a, x), and z ′ ∈ {0, b}. Using Lemma 2.1, we need to show that for each adversary move:</p><formula xml:id="formula_4">R • ∆gain R2b -Φ bs ′ z ′ + Φ xsz ≥ ∆adv (6)</formula><p>where ∆gain R2b is the expected weight of a job scheduled by R2b and ∆adv the weight of the job scheduled by the adversary. </p><formula xml:id="formula_5">′ = b, Φ bs ′ z ′ = 1 4 b • max(5s ′ -1, 3s ′ ), and ∆gain R2b = s ′ b + sp ab a + tp x ′ b x ′ . Substituting into (6), it is sufficient to prove that min(b, 2s ′ b) + 5sp ab a + 5tp x ′ b x ′ + 4 • Φ xsz ≥ 4 • ∆adv<label>(7)</label></formula><p>Case 2.1: Adversary schedules a. Then ∆adv = a ≤ x ′ and Φ xsz ≥ 0. For the first term of the minimum, we use (2) twice and get b+5sp ab a+5tp</p><formula xml:id="formula_6">x ′ b x ′ = s(b+5p ab a)+t(b+5p x ′ b x ′ ) ≥ 4sa+4tx ′ ≥ 4a.</formula><p>For the second term of the minimum, we use (4) twice and get 2s ′ b + 5sp ab a + 5tp</p><formula xml:id="formula_7">x ′ b x ′ = s(5p ab a + 2q ab b) + t(5p x ′ b x ′ + 2q x ′ b b) ≥ 4sa + 4tx ′ ≥ 4a</formula><p>Case 2.2: Adversary schedules z = x. It must be the case that x ′ = x ≥ a, as otherwise the adversary would prefer to schedule a. We have ∆adv = x. If x ≥ b, then p xb = 1. We use 4Φ xsz = 4Φ xsx ≥ (5s -1)x and obtain 5tp xb x + 4Φ xsz ≥ 5tx + 5sxx = 4x, which implies <ref type="bibr" target="#b6">(7)</ref>.</p><p>It remains to consider the case x &lt; b. Using (2), ( <ref type="formula">5</ref>) and ( <ref type="formula">4</ref> The 2-bounded (deterministic) case is now well understood. A φ-competitive algorithm was given in <ref type="bibr" target="#b3">[4]</ref>, matching the lower bound from <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref>. In this section, we extend the upper bound of φ to 3-bounded instances.</p><p>For the general case, the best known competitive ratio for deterministic algorithm is 2, attained for example by a simple greedy algorithm which always schedules the heaviest job <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref>. It is known that this algorithm, as well as other natural ones, is not better than 2-competitive.</p><p>We define two algorithms. They both use a real-valued parameter denoted α and β and they are both φ-competitive for 3-bounded instances for an appropriate value of the parameter. In this section, h always denotes the heaviest pending job.</p><p>The first algorihtm simply schedules a relatively heavy job with the smallest deadline:</p><p>Algorithm Edf α : Let f be the earliest-deadline job such that w f ≥ αw h . Execute f . We prove that Edf φ-1 is φ-competitive for 3-bounded instances.</p><p>The idea of the second algorithm is to balance the maximum gain in the next step against the discounted projected gain in the following steps, if no new jobs are issued. A plan (at time t) is an optimal schedule of jobs pending at time t. A plan can be computed by iteratively scheduling pending jobs, from heaviest to lightest, at their latest available slots.</p><p>Algorithm Bal β . At each step, execute the job j that maximizes w j + βπ j , where π j is the total weight of the plan in the next time step, if j is executed in the current step. (In a case of a tie, the algorithm chooses the earliest-deadline job, and if there are several, the heaviest one among those.)</p><p>We conjecture that Bal is better than 2-competitive for general instances. We establish the following facts about Bal β . All positive results can be shown using Lemma 2.1. In the following x is a pending job of Bal β and y is a pending job of the adversary.</p><p>• Let β ∈ {φ -1, 2 -φ}, where φ ≈ 1.618 is the golden ratio. Then Bal β is φ-competitive for instances. For β = 2φ = 1 -1/φ, the function Φ = [yx] + can be used as potential, where [z] + = max(z, 0); for β = φ -1, use Φ = max(x, y)φx.</p><p>• Bal √ 2/2 is √ 2-competitive for 2-uniform instances (this is the best ratio for memoryless algorithms, as discussed in Section 6). The proof uses the potential Φ = (</p><formula xml:id="formula_8">√ 2 -1)[y -2x + √ 2(y -x) + ]. • Bal φ-1 is φ-competitive for 3-bounded instances.</formula><p>The proof is quite complicated and omitted.</p><p>• Bal φ-1 is not φ-competitive for 8-bounded instances. See Appendix B. Theorem 5.1 Edf φ-1 is φ-competitive for 3-bounded instances.</p><p>Proof: We fix a canonical earliest-deadline adversary schedule A. Let E be the schedule computed by Edf φ-1 . We use the following charging scheme: Suppose that j is the job scheduled by the adversary at time t. If j is executed in E before time t, charge j to its copy in E. Otherwise, charge j to the job in E scheduled at time t.</p><p>Fix some time step t, and let f be the job scheduled in E at time t. Let also h be the heaviest pending job in E at time t. By the definition of Edf φ-1 , f is the earliest-deadline job with w f ≥ (φ -1)w h = w h /φ. Denote also by j the job scheduled in A at time t.</p><p>Job f receives at most two charges: one from j and one from itself, if f is executed in A at some later time. Ideally, we would like to prove that the sum of the charges is at most φw f . It turns out that in some cases this is not true, and, if so, we then show that for the job g scheduled by E in the next step, the total of all charges to f and g is at most φ(w f + w g ). Summing over all such groups of one or two jobs, the φ-competitiveness of Edf φ-1 follows.</p><p>If f receives only one charge, it is at most φw f : If this charge is from f , it is trivially at most w f . If the charge is from j (not scheduled before t in E), then j is pending at t in E and thus w j ≤ w h ≤ φw f , by the definition of Edf φ-1 . In this case the group consist of a single job and we are done.</p><p>It remains to handle the case when f receives both charges. Since in A job j is before f , we have d j ≤ d f (and for d j = d f , the tie is broken in favor of j -recall our tie-breaking convention.) But at time t, Edf φ-1 chooses f , so j is not eligible for execution by Edf φ-1 , that is w j &lt; (φ -1)w h .</p><p>If w f = w h , then f is charged at most w f + w j ≤ (1 + φ -1)w h = φw f , and we have a group with a single job again.</p><p>Otherwise, w f &lt; w h and the adversary does not schedule f at time t, hence d f ≥ t + 2. By the rule of Edf φ-1 , d h &gt; d f . As the span is bounded by 3, it has to be the case that d h = t + 3 and d f = t + 2. Thus the adversary schedules f at time t + 1. The weight of the job g scheduled at time t + 1 in E is w g ≥ (φ -1)w h , as h = f is still pending in E. Furthermore, g gets only the charge from itself, as the adversary at time t + 1 schedules f which is charged to itself. The total weight of the jobs charged to f and g is thus at most w j + w f + w g ≤ (φ -1)w h + w f + w g ≤ 3 2 (w f + w g ), since both w h and w f are at least (φ -1)w h . In this case we have a group of two jobs. 2</p><p>Extending the idea in the proof above easily yields an upper bound of 2 -Θ(1/s) on the competitive ratio of Edf α on s-bounded instances, for an appropriately chosen α. The proof of the following more precise bound is presented in Appendix A. Theorem 5.2 For each s ≥ 4, algorithm Edf 1/λs is λ s -competitive for s-bounded instances, where λ s is the unique non-negative solution of equation</p><formula xml:id="formula_9">(2 -λ s )(λ 2 s + ⌊ s 3 ⌋λ s + s -2 -2⌊ s 3 ⌋) = λ 2 s -λ s .</formula><p>We get λ 4 = √ 3 ≈ 1.732. For larger s, the equation is cubic. It can be verified that 2-2 s ≤ λ s ≤ 2-1 s , and in the limit for s → ∞, λ s = 2 -2/s + o(1/s). Some numerical values are given in Table <ref type="table" target="#tab_1">1</ref>.</p><p>Recall that, by Theorem 2.2, results for discrete metered tasks can be applied to unit-job scheduling. Here we describe two such results. We say a pending job i dominates another pending job j if d i ≤ d j and w i &gt; w j . A pending job is dominant if no other pending job dominates it. In <ref type="bibr" target="#b9">[10]</ref>, the authors considered the case of the metered-task model when there are at most s dominant jobs at each time, and proposed an online algorithm Gap for this case. In s-bounded instances there can be at most s pending dominant jobs at any time, since there can be at most one dominant job for each span value. Thus, the results from <ref type="bibr" target="#b9">[10]</ref> imply that: Theorem 5.3 Gap is r s -competitive for s-bounded instances, where r s is the unique positive real root of the equation r s = 1 + r -1/(s-1) s .</p><p>We can show that r s = 2 -Θ( 1 s ). Table <ref type="table" target="#tab_1">1</ref> gives a comparison of Edf α (with α = 1/λ s ) and Gap. Edf α has a smaller competitive ratio for s-bounded instances, on the other hand Gap can be applied also to the more general set of instances that have at most s dominant jobs at any time. also be slightly modified to give the same performance without knowing the value of s in advance.</p><p>In <ref type="bibr" target="#b8">[9]</ref>, an algorithm Fit was presented for the discrete metered-task model. Its competitive ratio is better than 2 when the importance ratio, that is the ratio of maximum to minimum job weights, is at most ξ (without any restriction on s). By Theorem 2.2, we have:</p><formula xml:id="formula_10">Theorem 5.4 Fit is (2 -1/(⌈lg ξ⌉ + 2)</formula><p>)-competitive for unit-job scheduling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">2-Uniform Instances</head><p>In this section we consider 2-uniform instances, where d j = r j + 2 for each job j. We first prove a lower bound of 4 -2 √ 2 ≈ 1.172 on the competitive ratio of randomized algorithms. This improves a lower bound of 10/9 from <ref type="bibr" target="#b14">[15]</ref>. Theorem 6.1 No randomized algorithm can be better than (4 -2 √ 2)-competitive for 2-uniform instances.</p><p>Proof: We use Yao's minimax principle <ref type="bibr" target="#b19">[20]</ref>, by showing a distribution on instances that forces each online algorithm A to have ratio at least 4 -2 √ 2. We will generate instance randomly. Fix a large integer n and let a = √ 2 + 1 and p = 1/a = √ 2 -1. Each instance consists of stages 0, 1, . . . , where in stage j we have three jobs: two jobs j, j ′ of weight a j issued at time 2j and one job j ′′ of weight a j+1 issued at time 2j + 1. After each stage j ≤ n, we continue with probability p or stop with probability 1p. After stage n, at time 2n + 2, we issue two jobs of weight a n+1 , and stop.</p><p>Fix a deterministic online algorithm A. We compute the expected gain of A and the adversary in stage j ≤ n, conditioned on stage j being reached. At time 2j, A executes a job of weight a j (it has no choice), say j. If it executes j ′′ at time 2j + 1, its gain in stage j is a j + a j+1 = (1 + a)a j = (2 + √ 2)a j . If it executes j ′ , its gain is either 2a j + a j+1 or 2a j , depending on whether we stop, or continue generating more stages. Thus its expected gain is (1p) • (2a j + a j+1 ) + p • 2a j = (2 + √ 2)a j , same as in the previous case. Since the probability of reaching this stage is p j , the contribution of this stage to A's expected gain is 2 + √ 2. We now calculate the adversary gain in stage j (again, condition on this stage being generated). If we stop, the adversary gains 2a j + a j+1 , otherwise he gains a j + a j+1 , so his expected gain is (1p) • (2a j + a j+1 ) + p • (a j + a j+1 ) = a j (2p + a) = 4a j . Thus the contribution of this stage to the adversary's gain is 4.</p><p>Summarizing, for each step, except the last one, the contributions towards the expected value are 2 + √ 2 for A and 4 for the adversary independent of j. The contributions of stage n + 1 are different, but also constant. So the overall ratio will be, in the limit for n → ∞, the same as the ratio of the contributions of stages 0, . . . , n, which is 4/(2 + √ 2) = 4 -2 √ 2, as claimed. 2 Deterministic algorithms for 2-uniform instances were studied in <ref type="bibr" target="#b3">[4]</ref>, where an upper bound of √ 2 was given. The same upper bound can be achieved using algorithm Bal √ 2/2 . As we show below, it is not possible to beat ratio √ 2 by choosing a different parameter β in Bal β , nor with any deterministic memoryless, scale-invariant algorithm. Recall that we define an online algorithm A to be memoryless if its decision at each step depends only on the pending jobs (including those released at the current step.) We say that A is scale-invariant if its decision is invariant under scaling of weights (multiplying the weights of all pending jobs by a positive real number does not affect the choice of the job to be executed). Theorem 6.2 No deterministic memoryless algorithm can achieve competitive ratio better than √ 2 for 2-uniform instances.</p><p>Proof: Let A be a deterministic memoryless algorithm. Adversary will issue at most one pending job at each step. Suppose that y &gt; 0 is a pending job (or, more precisely, the weight of the pending job). We will have two types of moves: Note that in step (a), A has no choice but to execute a job of weight y. Further, it does not matter which job it chooses for execution. Consider steps of type (b). A's decision is only a function of b/y. For any ǫ &gt; 0 there are two constants a 1 , a 2 with |a 1a 2 | ≤ ǫ, such that A executes y when b/y = a 1 and b when b/y = a 2 . (If one of a 1 , a 2 does not exist, A is not competitive at all.) To simplify the proof, we will further assume that a 1 = a 2 = a, and allow the adversary to break the tie and determine which job will be executed by A when b/y = a. The argument below can be easily modified by replacing a by a 1 or a 2 to force A to make the desired decision, and then taking the limit with ǫ → 0.</p><p>Choose some large integer n. The adversary uses three instances. In instance I 1 we issue two jobs of weight 1 at step 0 and one job of weight a at step 1. The adversary forces A to execute job a at step 1. The gain of A is 1 + a, the adversary gains 2 + a, so the ratio is R 1 (a) = (a + 2)/(a + 1).</p><p>In instance I 2 , we start with two jobs of weight 1 at step 0. Then, at each time j = 1, . . . , n we issue a job j of weight a j , and at time n+1 we issue two jobs n ′ , n ′′ of weight a n . The adversary breaks the tie so that A executes job j at time j + 1, for j = 1, ..., n. So the gain of A is 2 + n j=1 a j + a n , and the gain of the adversary is 1 + n j=1 a j + 2a n . Taking the limit with n → ∞, so that we can ignore low-order terms, the ratio is R 2 (a) = (3a -2)/(2a -1).</p><p>The last instance I 3 has the same jobs as I 2 , except that at time n + 2 we also issue job n * of weight a n+1 . The adversary forces A to execute this job at time n + 2. The gain of A is 2 + n j=1 a j + a n+1 , and the gain of the adversary is 1 + n j=1 a j + 2a n + a n+1 . In the limit, the ratio is</p><formula xml:id="formula_11">R 3 (α) = 1 + 2/a -2/a 2 .</formula><p>The overall ratio is R(a) = max {R 1 (a), R 2 (a), R 3 (a)}. By routine calculations, this ratio is minimized for a ∈ √ 2, 2 + √ 2 , and for those values R(a) = √ 2. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">The Multiprocessor Case</head><p>In this section we consider the multiprocessor case. The greedy 2-competitive algorithm <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref> applies to both uniprocessor and multiprocessor cases. We show an algorithm that for M processors achieves competitive ratio (1 -</p><formula xml:id="formula_12">( M M +1 ) M ) -1 ,</formula><p>showing that with a larger number of processors we can improve the competitive ratios. When M → ∞ this ratio tends to e/(e -1) ≈ 1.58, beating the φ ≈ 1.618 bound for M = 1 <ref type="bibr" target="#b10">[11]</ref>. The basic idea of our algorithm is similar to algorithm Mixed for metered tasks in <ref type="bibr" target="#b10">[11]</ref>. It also has some similarity to our randomized algorithm RMix. We divide the processing effort between M processors, such that each processor works on the earliest-deadline job with weight above a certain threshold. This threshold decreases geometrically for each processor. If no job is above the threshold, we select the heaviest remaining job, and reset the threshold to the weight of this job. Throughout this section let</p><formula xml:id="formula_13">β = M/(M + 1), R = (1 -( M M +1 ) M ) -1 .</formula><p>Algorithm DMix-M . Let X be the set of pending jobs at a given time t. The algorithm chooses jobs h 1 , . . . , h M as shown in the pseudocode below and schedules them for execution.</p><formula xml:id="formula_14">i ← 1 : repeat g ← heaviest job in X -{h 1 , ..., h i-1 } : h i ← g : j ← i repeat i ← i + 1 f ← earliest-deadline job in X -{h 1 , ..., h i-1 } with w f ≥ β i-j w g if f exists then h i ← f until f does not exist</formula><p>Fix a time step t. Denote v i = w h i for all i. Normalize the weights so that v 1 = 1. We call those h i selected in the outer repeat loop g-jobs. We only prove the case of two g-jobs, and leave the complete proof to the full paper. Suppose the g-jobs are h 1 and h k , 1 &lt; k ≤ M . By the choices of DMix-M , we have v i ≥ β i-1 for i ∈ {1, 2, ..., k -1}, v k &lt; β k-1 , and v i ≥ v k β i-k for i ∈ {k +1, ..., M }. We need the following lemma, with proof omitted.</p><formula xml:id="formula_15">Lemma 7.1 (i) (k -1) + (M -k + 1)v k ≤ R • k-2 i=0 β i + v k M i=k β i-k . (ii) M β p-k v k + p i=1 v i ≤ R • M i=1 v i for any positive integer p ∈ {k, k + 1, ..., M }. Theorem 7.2 DMix-M is R-competitive for M processors, where R = (1 -( M M +1 ) M ) -1 .</formula><p>Proof: (Sketch.) For a given input instance, let D be a schedule of DMix-M and A the adversary schedule. As we assume that A is canonical earliest-deadline. Fix time step t. Let H = {h 1 , ..., h M }, the jobs executed by DMix-M at time t J = the set of M jobs executed by the adversary at time t X = the pending jobs of DMix-M at time t Y = the pending jobs of the adversary at time t that will be executed at time t or later For a set of jobs I, let w(I) = i∈I w i denote the total weight of I. Define the potential function Φ = w(Y -X). By Lemma 2.1, it is thus sufficient to show that w(J) + ∆Φ ≤ R • w(H).</p><p>Job arrivals and expirations cannot increase the potential. So we only need to analyze how the potential changes after job executions. The change in the potential due to the adversary executing the jobs in J is -w(J -X), as the jobs in J -X contribute to the current potential but will not contribute in the next step. A job h i executed by DMix-M does not contribute to the potential in the current step, but if h i ∈ Y -J, then, in the next step, h i will be pending in A but not in D, so it will contribute to the new potential. Thus the change due to DMix-M executing the jobs in H is w(H ∩ Y -J). We conclude that ∆Φ = -w(J -X) + w(H ∩ Y -J). Therefore, in order to prove the theorem it is sufficient to show that w(J ∩ X) + w(H ∩ Y -J) ≤ R • w(H). Case 1: H ∩ Y -J = ∅. Jobs j ∈ J ∩ X must have weight at most 1, at most k -1 of them can have weights larger than v k , since otherwise DMix-M would choose the g-jobs differently. Thus, using Lemma 7.1, we get:</p><formula xml:id="formula_16">w(J ∩ X) + w(H ∩ Y -J) ≤ (k -1) + (M -k + 1)v k + 0 ≤ R • k-2 i=0 β i + v k M i=k β i-k ≤ R • k-1 i=1 v i + M i=k v i = R • w(H). Case 2: H ∩ Y -J = ∅.</formula><p>Let p be the largest index for which h p ∈ Y -J. In other words, h p is the highest-indexed job in H that will be executed in A at a later time. Since A is earliest-deadline, we have d j ≤ d hp for all j ∈ J. We distinguish two subcases. Case 2.1: p ≥ k. In this case, w j &lt; β p-k v k for any j ∈ J ∩ X -H, since otherwise they would be scheduled instead of h k . Thus by Lemma 7.1, w(J ∩X)+w(H ∩Y -</p><formula xml:id="formula_17">J) = w(J ∩X -H)+w(H ∩Y ) ≤ M β p-k v k + p i=1 v i ≤ R • w(H). Case 2.2: p ≤ k.</formula><p>We have w j ≤ v k for any j ∈ J ∩ X -{h 1 , ..., h k }, since otherwise they would be scheduled instead of h k . Thus by Lemma 7.1 with p = k, w(J ∩ X)</p><formula xml:id="formula_18">+ w(H ∩ Y -J) = w(J ∩ X - H) + w(H ∩ Y ) ≤ j∈∩X-{h 1 ,...,h k } w j + p i=1 v i ≤ M v k + k i=1 v i ≤ R • w(H). 2</formula><p>The lower bound proofs in <ref type="bibr" target="#b10">[11]</ref> and Theorem 6.1 can easily be generalized to the multiprocessor case, improving the bounds in <ref type="bibr" target="#b14">[15]</ref> (4 -2 √ 2 for the general case and 10/9 for the 2-uniform case):</p><p>Theorem 7.3 No deterministic or randomized algorithm can be better than 5/4-competitive, for any number of processors M . No deterministic or randomized algorithm can be better than 4 -2 √ 2competitive, for 2-uniform instances on any number of processors M .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Final Remarks</head><p>We have completely resolved the 2-bounded randomized and 3-bounded deterministic cases of our problem. For general instances, we have given a randomized 1.58-competitive algorithm.</p><p>The main unit-job scheduling question, of whether there exists a (2-ǫ)-competitive deterministic algorithm, remains open, and it appears to be a challenging problem. The problem of how to tighten the gap between the bounds 1.25 and 1.58 in the randomized model also remains open.</p><p>A Appendix: Proof of Theorem 5.2</p><p>Proof: Throughout the proof, we put α = 1/λ s and write and Edf instead of Edf(1/λ s ). By Edf we also denote any schedule generated by Edf. For any time t, let M t be the maximal weight of a job available to Edf at time t; define M t = 0 if no job is available.</p><p>First we show that we can restrict ourselves to instances where all the jobs have weights α i for some integer i. To achieve this, we slightly relax the rule of Edf. If a job with weight equal to M t /α is available, Edf may arbitrarily choose to consider it as a candidate to be scheduled or not. Precisely, Edf schedules the earliest deadline job among those with weight strictly bigger than M t /α (preferring heavier jobs if deadlines are equal), or an arbitrary job with earlier deadline and weight equal to M t /α.</p><p>Call a weight bad if it is not equal to α i for an integral i. Now we show that any with some bad weights can be converted to an instance with a smaller number of bad weights and with the same or larger competitive ratio on some valid run of Edf. Express each bad weight of job j as a j α i j for i j integer and 0 &lt; a j &lt; α. Let x min = min j a j and x max = min j (αa j ) (the minima are taken over all bad jobs). Now replace each weight of a bad job by (a j + x)α i j , for some x ∈ [-x min , x max ]. From the definition of x min and x max , it follows that the order of the weights of jobs does not change, as well as the result of comparisons of one weight to another weight divided by α, except possibly for creating new ties. Consequently, any valid run of Edf on the original instance is also a valid run on the new instance, and the set of jobs scheduled in the original optimal solution gives also an optimal solution of the new instance. As the total weight of jobs scheduled both in Edf and OPT is linear in x, their ratio is monotone in [-x min , x max ] and thus it is maximized either for x = -x min or x = x max . Choose the appropriate x of these two possibilities and the corresponding modified instance. By the definition of x min and x max , the number of bad weights has decreased.</p><p>On the restricted instances, Edf at time t schedules either a job of weight M t or M t /α. If a job of weight M t /α is scheduled, the job with weight M t remains available at time t + 1 (if its deadline were t + 1, Edf would schedule such a job at time t), thus M t+1 ≥ M t .</p><p>We fix an earliest-deadline schedule Adv and define a similar charging scheme as in the proof for s = 3. For any integer time t, suppose q is the job scheduled at t in Adv and z the job scheduled in Edf. If q is completed in Edf before time t and w q ≥ M t , charge q to q in Edf. Otherwise, charge q to z in Edf.</p><p>Each job z in Edf scheduled at time t receives charges from at most two jobs in Adv: one from z itself at t or a later time, and another one from the Adv job scheduled at t. Ideally, we would like to prove that the sum of the charges is at most αw z . In some cases this fails, we then find a contiguous segment of Edf starting with z such that the total of all charges to the jobs in the segment is at most α times their total weight. Summing over all such groups, α competitiveness follows.</p><p>We start by two general observations. (I) If job z scheduled at time t in Edf receives only one charge, it is at most α times its weight. If this charge is from z, it is trivially at most w z . If the charge is from a job q scheduled before t in Edf, the charge is at most M t /α ≤ w z by the definition of the charging scheme. If the charge is from a job q not scheduled before t in Edf, then q is available at t to Edf and thus w q ≤ M t ≤ αw z , by the definition of Edf.</p><p>(II) If job z scheduled at time t receives both charges, the charge from the job q scheduled in Adv at time t is at most M t /α. It could be more only if q is not scheduled before t in Adv and w q &gt; M t /α; in that case q is available to Edf and has a sufficient weight, since Adv has also available both q and z and prefers q, and the ties are broken consistently, Edf also prefers q and cannot schedule z. This also implies that if w z = M t , then the z is charged at most (1 + 1/α)w z ≤ αw z , using α ≥ φ.</p><p>By the observations above, it remains to handle the case when z receives two charges and w z = M t /α. If s = 3 this cannot happen: z has a deadline strictly smaller than a job with weight M t , necessarily the deadline of z is t + 2, Adv schedules it at time t + 1 when the job of weight M t is still available, and z is not charged to z in Edf. Thus the proof for s = 3 is complete.</p><p>For the rest of the proof we renormalize so that t = 0 and M 0 = α. Let z i be the job scheduled by Edf at time i and let m be the smallest index such that w zm = M m . (It exists, as eventually a maximal job is scheduled.) Thus w z i = M i /α for i &lt; m and α = M 0 ≤ M 1 ≤ • • • ≤ M m . Let Z be the set of jobs z 0 , . . . , z m-1 .</p><p>Let k ≥ 0 be such that M m = α k+1 . Let X i , i = 1, . . . , k, be the set of all jobs in Z with weight M m /α i that receive two charges. Let X = X i be the set of all jobs in Z that receive two charges. Let</p><formula xml:id="formula_19">x i = |X i |, x = |X|.</formula><p>Using (I), each job in Z -X is charged at most α times its weight. Let W = k i=1 x k /α i , i.e., W M m = α k+1 W is the total weight of jobs in X. Using (II), the jobs in X and z m are charged total at most 2W M m + (1 + 1/α)M m and their weight is W M m + M m . To finish the proof of α-competitiveness, it is sufficient to show that</p><formula xml:id="formula_20">α ≥ 2W + 1 + 1/α W + 1 = 2 - 1 -1 α W + 1 .</formula><p>The right-hand side increases with W , thus we need to determine the largest possible value of W . Since the jobs in X receive also their own charge, each of them is scheduled in Adv and scheduled at time m + 1 or later. By the definition of Z, Edf schedules first all jobs in X k , then X k-1 , . . . , up to X 1 (possibly some jobs in Z -X are scheduled in between the jobs from X).</p><p>We claim that for each i,</p><formula xml:id="formula_21">x i + x + 2 ≤ s.<label>(8)</label></formula><p>Let i ′ ≥ i be such that the last job finished by Adv from X i ∪ • • • ∪ X k belongs to X i ′ . Let q be a job of maximal weight available when Edf schedules the first job of X i ′ . Since q is scheduled by Edf only after all jobs in X i ′ despite the fact that its weight is larger, it must have strictly larger deadline than all the jobs in X i ′ . Between the start of the first job in X i ′ in Edf and time m + 1, Edf schedules all jobs in X i ′ ∪ X i ′ -1 ∪ • • • ∪ X 1 and z m , Between time m + 1 and the time Adv the last job of X i ′ , Adv schedules all jobs in X i ∪ • • • ∪ X k . Since the span of job q covers all of this and at least one time step after Adv finishes X i ′ , we have</p><formula xml:id="formula_22">s ≥ x i ′ + x i ′ -1 + • • • + x 1 + 1 + x i + • • • + x k ≥ x i + x + 2.</formula><p>Suppose that integers x i satisfy (8) and maximize W . Then we claim that • x i ≥ x i+1 for any i ≥ 1: otherwise switching the values of x i and x i+1 is feasible and increases W ;</p><p>• x i = 0 for any i ≥ 3: otherwise decreasing x i-1 and x i both by 1 and increasing x 1 by 1 increases W by at least 1/α -1/α 2 -1/α 3 ≥ 0, since α ≥ φ.</p><p>• 2x 1 + x 2 = s -2: otherwise increasing x 1 by 1 and decreasing x 2 by 1 is feasible and increases W ;</p><p>• x 1 ≤ x 2 + 2: otherwise increasing x 2 by 2 and decreasing x 1 by 1 is feasible and increases W .</p><p>Thus the optimal values are x 1 = ⌊s/3⌋ and x 2 = s -2 -2⌊s/3⌋ and for any case we have</p><formula xml:id="formula_23">2 - 1 -1 α W + 1 ≤ 2 - 1 -1 α 1 + ⌊ s 3 ⌋ α + s-2-2⌊ s 3 ⌋ α 2 = 2 - α 2 -α α 2 + ⌊ s 3 ⌋α + s -2 -2⌊ s 3 ⌋ = α</formula><p>by the definition of α. 2</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Case 1 :</head><label>1</label><figDesc>Adversary schedules b. Then Φ xsz ≥ 0, ∆adv = b, z ′ = 0, and Φ bs ′ z ′ = 0. For a fixed value of u in the algorithm, the expected gain of the algorithm is p ub u+q ub b and (3) implies 5 4 (p ub u+q ub b) ≥ b. By averaging over u ∈ {a, x ′ } we get R • ∆gain R2b ≥ b, which implies (6). Case 2: Adversary does not schedule b. Then z</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 5</head><label>2</label><figDesc>) we obtain b+5tp xb x ≥ b+t(4x-b) = 4tx+sb and 2s ′ b+5sp ab a+5tp xb x = s(2q ab b+5p ab a)+t(2q xb b+5p xb x) ≥ sb+4tx. Together with with 4Φ xsz = 4Φ xsx ≥ 3sx and x &lt; b this implies min(b, 2s ′ b)+5sp ab a+5tp xb x+4Ψ xsz ≥ 4tx+sb+3sx ≥ 4x and (7) follows. Deterministic Algorithm for s-Bounded Instances</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Issue two jobs with weight y. (b) Issue one job with weight b &gt; y.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>table below. Our results are marked with [ * ]. A blank entry indicates that the bound in this entry follows from another bound in the same column.</figDesc><table><row><cell></cell><cell cols="2">deterministic</cell><cell cols="2">randomized</cell></row><row><cell></cell><cell>upper bound</cell><cell cols="3">lower bound upper bound lower bound</cell></row><row><cell>General</cell><cell>2 [15]</cell><cell></cell><cell>1.582... [ * ]</cell><cell></cell></row><row><cell cols="2">s-bounded 2 -2/s + o(1/s) [ * ] 4-bounded 1.732... [ * ]</cell><cell></cell><cell></cell><cell></cell></row><row><cell>3-bounded</cell><cell>1.618... [ * ]</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2-bounded</cell><cell>1.618... [15]</cell><cell>1.618... [4, 11]</cell><cell>1.25 [ * ]</cell><cell>1.25 [11]</cell></row><row><cell>2-uniform</cell><cell>1.414... [4]</cell><cell>1.366... [4]</cell><cell></cell><cell>1.172.... [ * ]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Comparison of the upper bounds for Edf and Gap.</figDesc><table><row><cell>Gap can</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by an RGC research grant. {chin,Supported by NSF grants CCR-9988360 and CCR-0208856. Partially supported by Institute for Theoretical Computer Science, Prague (project LN00A056 of M ŠMT ČR) and grant 201/01/1195 of GA ČR.</p><p>¶ Partially supported by cooperative grant KONTAKT-ME476/CCR-9988360-001 from M ŠMT ČR and NSF.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>B Appendix: Proof that Bal φ-1 is not φ-Competitive Although we believe that Bal β is better than 2-competitive for some β, we can show that it cannot achieve competitive ratio φ. Even for 2-bounded instances the only values of β that can give ratio φ are 2φ and φ -1, and it is not hard to give an example that Bal 2-φ is not φ-competitive in general. The hardest case is when β = φ -1 which we examine now.</p><p>Lemma B.1 Let p 1 , . . . , p s be real numbers, such that 1 ≤ p 1 , p 2 , . . . , p s ≤ φ + 1. Let P = s i=1 p i and let ǫ &gt; 0 be arbitrarily small. Then there exists an instance (allowing negative time slots) such that at time 0, Bal φ-1 has pending exactly s jobs with weight p i and deadline i, for i = 1, . . . , s, and before time 0, Bal φ-1 has scheduled jobs of total weight (φ -1)Pǫ. In addition, there exists a schedule which schedules jobs with total weight φ • Pǫ before time 0 (and has no jobs pending).</p><p>Proof: Let {q i } s i=1 be the numbers p 1 , . . . , p s ordered non-decreasingly. Consider (a long segment of) a backwards infinite sequence of jobs of span s, releasing one at each time step, with weights q 1 φ -2n , q 2 φ -2n , ..., q s φ -2n 1 n=∞ , arranged so that the last job, with weight q s φ -2 is released at time -s and has deadline 0. At time -s + 1 we release a job of weight q 1 with deadline j such that p j = q 1 . At times -s + 2, . . . , -1 we continue with jobs of weights q 2 , . . . , q s with appropriate deadlines so that at time 0, the s pending jobs have distinct deadlines and satisfy the requirements in the lemma.</p><p>At each time, a plan contains all pending jobs and the first job in the plan is tight. By the restriction on the weights q i and their ordering, it follows that Bal φ-1 always schedules the planned job. The total scheduled weight is given by summing the infinite geometric sequence</p><p>The adversary can schedule all the jobs as soon as they are released. 2</p><p>Now we use the lemma to show that Bal φ-1 is not φ-competitive. The plan we start with, after applying the lemma, is 2, 2, φǫ, φ + 1, φ + 1 for a small ǫ. Each job in the plan has a tight deadline. Note that P = 3φ + 6ǫ. The remaining jobs issued by the adversary are (in the (r, d, w) format):</p><p>(0, 2, 2), (0, 4, φ</p><p>The adversary schedules always the first job in the pair upon its release and then the two jobs of weight φ + 1 + 10ǫ. So its total gain (omitting O(ǫ)terms) is:</p><p>Bal φ-1 schedules the second jobs of the first two pairs since</p><p>Then, at time 2, Bal φ-1 schedules the job with weight φ + 1 and deadline 4, the comparison is</p><p>Finally, at time 3, Bal φ-1 schedules the job with weight φ + 1 and deadline 5, the comparison is</p><p>The total gain of Bal φ-1 is gain = (φ -1)P + 4(φ + 1) = 3 + 6(φ -1) + 4(φ + 1) = 10φ + 1. Therefore we have φ • gain = 11φ + 10 &lt; 12φ + 9 = adv, so Bal φ-1 is not φ-competitive.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Competitive analysis of randomized paging algorithms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Achlioptas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chrobak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">234</biblScope>
			<biblScope unit="page" from="203" to="218" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Competitive queue policies for differentiated services</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajagopolan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE INFOCOM</title>
		<meeting>of the IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On randomized online scheduling</title>
		<author>
			<persName><forename type="first">S</forename><surname>Albers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 34nd STOC</title>
		<meeting>of the 34nd STOC</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="134" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Competitive queueing policies for QoS switches</title>
		<author>
			<persName><forename type="first">N</forename><surname>Andelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 14th ACM-SIAM SODA</title>
		<meeting>of the 14th ACM-SIAM SODA</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="761" to="770" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Management of mulit-queue switches in QoS networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Azar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Richter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 35nd STOC</title>
		<meeting>of the 35nd STOC</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="82" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Competitive on-line switching policies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bar-Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Landa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th ACM-SIAM SODA</title>
		<meeting>of the 13th ACM-SIAM SODA</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="525" to="534" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">New algorithms for an ancient scheduling problem</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Bartal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Karloff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vohra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal Computer Systems Science</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="359" to="366" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Competitive online scheduling with level of service</title>
		<author>
			<persName><forename type="first">E.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Annual International Computing and Combinatorics Conference</title>
		<meeting>7th Annual International Computing and Combinatorics Conference</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="453" to="462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Online scheduling with partial job values and bounded importance ratio</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Y L</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P Y</forename><surname>Fung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Computer Symposium</title>
		<meeting>of International Computer Symposium</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="787" to="794" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Improved competitive algorithms for online scheduling with partial job values</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Y L</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P Y</forename><surname>Fung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International Computing and Combinatorics Conference</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Online scheduling for partial job values: does timesharing or randomization help? Algorithmica</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Y L</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P Y</forename><surname>Fung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Preemptive scheduling in overloaded systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chrobak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sgall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Stee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tichy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vakhania</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 29th ICALP</title>
		<meeting>of 29th ICALP</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="800" to="811" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Competitive paging algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Mcgeoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sleator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="685" to="699" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the competitiveness of online scheduling of unit-length packets with hard deadlines in slotted time</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hajek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference in Information Sciences and Systems</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Buffer overflow management in QoS switches</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kesselman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lotker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Patt-Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sviridenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 33rd STOC</title>
		<meeting>of the 33rd STOC</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="520" to="529" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Algorithms for scheduling imprecise computations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-K</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Shi Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="58" to="68" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Nearly optimal FIFO buffer management for DiffServ</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Lotker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Patt-Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st ACM Symp. on Principles of Distributed Computing</title>
		<meeting>of the 21st ACM Symp. on Principles of Distributed Computing</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="134" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A strongly competitive randomized paging algorithm</title>
		<author>
			<persName><forename type="first">L</forename><surname>Mcgeoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sleator</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="816" to="825" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Online randomized multiprocessor scheduling</title>
		<author>
			<persName><forename type="first">S</forename><surname>Seiden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="173" to="216" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Probabilistic computations: Towards a unified measure of complexity</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th FOCS</title>
		<meeting>of the 18th FOCS</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="222" to="227" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
