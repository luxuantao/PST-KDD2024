<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Does Code Decay? Assessing the Evidence from Change Management Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Stephen</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
							<email>eick@research.bell</email>
						</author>
						<author>
							<persName><forename type="first">Todd</forename><forename type="middle">L</forename><surname>Graves</surname></persName>
							<email>graves@niss.org..</email>
						</author>
						<author>
							<persName><forename type="first">Alan</forename><forename type="middle">F</forename><surname>Karr</surname></persName>
							<email>karr@niss.org</email>
						</author>
						<author>
							<persName><forename type="middle">J S</forename><surname>Marron</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<postCode>60566</postCode>
									<settlement>Naperville</settlement>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Statistical Sciences MS F600</orgName>
								<orgName type="institution">Los Alamos National Laboratory</orgName>
								<address>
									<postCode>87545</postCode>
									<settlement>Los Alamos</settlement>
									<region>NM</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">National Institute of Statistical Sciences</orgName>
								<address>
									<addrLine>Research Triangle Park</addrLine>
									<postBox>PO Box 14006</postBox>
									<postCode>27709-4006</postCode>
									<region>NC</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
								<address>
									<addrLine>111 New West, Chapel Hill</addrLine>
									<postCode>27599-3260</postCode>
									<region>NC</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Does Code Decay? Assessing the Evidence from Change Management Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5AC83DB206136B3579219F44C22B6D61</idno>
					<note type="submission">received 10 Mar. 1998; revised 13 Apr. 1999; accepted 15 Apr. 1999. Recommended for acceptance by D. Hamlet.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>AbstractÐA central feature of the evolution of large software systems is that changeÐwhich is necessary to add new functionality, accommodate new hardware, and repair faultsÐbecomes increasingly difficult over time. In this paper, we approach this phenomenon, which we term code decay, scientifically and statistically. We define code decay and propose a number of measurements (code decay indices) on software and on the organizations that produce it, that serve as symptoms, risk factors, and predictors of decay. Using an unusually rich data set (the fifteen-plus year change history of the millions of lines of software for a telephone switching system), we find mixed, but on the whole persuasive, statistical evidence of code decay, which is corroborated by developers of the code. Suggestive indications that perfective maintenance can retard code decay are also discussed.</p><p>Index TermsÐSoftware maintenance, metrics, statistical analysis, fault potential, span of changes, effort modeling.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>B ECAUSE the digital bits that define it are immutable, software does not age or ªwear outº in the conventional sense. In the absence of change to its environment, software can function essentially forever as it was originally designed. However, change is not absent but ubiquitous in two principal senses. First, the hardware and software environments surrounding a software product do change. For example, hardware is upgraded, or the operating system is updated. Second, and equally important, the required functionality (both features and performance) sometimes changes abruptly. For example, a telephone system must, over time, offer new features, become more reliable and respond faster.</p><p>Then, necessarily, the software itself must be changed through an ongoing process of maintenance. As part of our experience with the production of software for a large telecommunications system, we have observed a nearly unanimous feeling among developers of the software that the code degrades through time and maintenance becomes increasingly difficult and expensive.</p><p>Whether this code decay is real, how it can be characterized, and the extent to which it matters are the questions we address in this paper. The research reported here is based on an uncommonly rich data set: the entire change management history of a large, fifteen-year old real-time software system for telephone switches. Currently, the system is comprised of 100,000,000 1 lines of source code (in C/C++ and a proprietary state description language) and 100,000,000 lines of header and make files, organized into some 50 major subsystems and 5,000 modules. (For our purposes, a module is a directory in the source code file system, so that a code module is a collection of several files. This terminology is not standard.) Each release of the system consists of some 20,000,000 lines of code. More than 10,000 software developers have participated.</p><p>In Section 2, we begin with a brief discussion of the software change process and the change management data with which we work. The handling, exploration, and visualization of these data are important issues in their own right and are treated in <ref type="bibr" target="#b0">[1]</ref>.</p><p>In Section 3, we propose a conceptual model for code decay: A unit of code (in most cases, a module) is decayed if it is harder to change than it should be, measured in terms of effort, interval, and quality. Associated with the model is a compelling medical metaphor of software as patient, which enables one to reason in terms of causes, symptoms, risk factors, and prognoses.</p><p>The scientific link between the model and the conclusions is a series of code decay indices (CDIs) presented in Section 4, which quantify symptoms or risk factors (and so are like medical tests) or predict key responses (a prognosis). The indices introduced here are directly relevant to the statistical analyses that follow; many others could be formulated and investigated.</p><p>Our four principal results treat specific manifestations of decay. Three of these results are evidence that code does decay: 1) the span of changes, which is shown to increase over time (Section 5.1), 2) breakdown of modularity, which is exhibited by means of network-style visualizations (Section 5.2), 3) fault potential, the likelihood of changes to induce faults in the software system (in Section 5.3, we show that the distribution of faults is explained by the distribution of large, recent changes to the software), and 4) prediction of effort quantifies the impact of decay required to make a change using code decay indices that encapsulate characteristics of changes (Section 5.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Early investigations of aging in large software systems by Belady and Lehman <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>, reported the nearimpossibility of adding new code to an aged system without introducing faults. Work such as <ref type="bibr" target="#b4">[5]</ref> on software maintenance for Cobol programs running on an IBM online transaction processing system addressed program complexity, modularity, and modification frequency as explanatory variables, but found that these variables accounted only for 12 percent of the variation in the repair maintenance rate.</p><p>Bendifallah and Scacchi <ref type="bibr" target="#b5">[6]</ref> consider software maintenance and its effect on cost, interval, and quality. Particularly noteworthy, because of its historical summary of large scale software development, is <ref type="bibr" target="#b6">[7]</ref>. Kemerer and Ream survey empirical work on software maintenance <ref type="bibr" target="#b7">[8]</ref>.</p><p>Our conceptualization of code decay in medical terms was inspired by Parnas <ref type="bibr" target="#b8">[9]</ref>. In work related to our fault CDI, Ohlsson and Alberg <ref type="bibr" target="#b9">[10]</ref> identify fault-prone modules in switching system software.</p><p>Two early fundamental papers relating software data collection and its analysis are <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CHANGES TO SOFTWARE</head><p>Our definition of a change to software is driven by the data that are available: A change is any alteration to the software recorded in the change history data base. The specific data with which we deal are described in Section 2.2 and Section 5.</p><p>The changes we study fall naturally into three main classes (see <ref type="bibr" target="#b12">[13]</ref> and <ref type="bibr" target="#b13">[14]</ref>) that define the evolution of a software product. Adaptive changes add new functionality to a system (for example, caller ID in a telephone switch), or adapt the software to new hardware or other alterations in its environment. Corrective changes fix faults in the software. Perfective changes are intended to improve the developers' ability to maintain the software without altering functionality or fixing faults. Perfective maintenance has also been called ªmaintenance for the sake of maintenanceº or ªreengineering.º</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Change Process</head><p>For the system we study, changes to the source code follow a well-defined process. Features (for example, call waiting or credit card billing) are the fundamental requirements units by which the system is extended.</p><p>Changes that implement a feature or solve a problem are sent to the development organization as Initial Modification Requests (IMRs); implementation of a feature typically requires hundreds of IMRs. The supervisor responsible for the IMR distributes the work to the developers. Developers implementing parallel changes (as in <ref type="bibr" target="#b14">[15]</ref>) must wait for unavailable files.</p><p>Each IMR generates a number of Modification Requests (MRs), which contain information representing the work to be done to each module. (Thus, an IMR is a problem, while an associated MR is all or part of the solution to the problem.) To perform the changes, a developer ªopensº the MR, makes the required modifications to the code, checks whether the changes are satisfactory (within a limited context, i.e., without a full system build), and then submits the MR. Code inspections and integration and system tests follow.</p><p>An editing change to an individual file is embodied in a delta: The file is ªchecked outº of the version management system, edited, and then ªchecked in.º Lines added and lines deleted by a delta are tracked separately. (To change a line, a developer first deletes it, then adds the new version of the line.) 2  A major organizational paradigm shift (see <ref type="bibr" target="#b15">[16]</ref>) for one of the organizations working on the system during its lifetime has been a transition from developer ownership of modules (with a feature implemented by all developers who own modules that are touched) to developer ownership of features, with the feature owner(s) making changes wherever necessary. Implications of this are discussed in Sections 5.1 and 5.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Change Management Data</head><p>Data pertaining to the change history of the code itself reside in a version management system, which tracks changes at the feature, IMR, MR, and delta levels. Within the version management system, the structure of the changes is as follows (see Fig. <ref type="figure" target="#fig_1">1</ref>).</p><p>Each IMR has an extensive record containing priority, date opened and closed, point in the development process when it was initiated (requirements, design, coding, testing, field operation), and a number of other fields (89 in all).</p><p>Data for each MR include the parent IMR, dates and affected files, and an English text abstract describing the change and the reasons for it. There is no explicit format on how and what information is entered in the abstract; the purpose is for other developers to understand what change was made and why.</p><p>2. This preserves the capability to build earlier versions of the software. The data for each delta list the parent MR and the date and time when the change was submitted to the version management system, as well as numbers of lines added, deleted, and unmodified by that change.</p><p>Desirable questions for change data to answer are: WHAT files were changed and which lines were added and deleted? HOW MANY modules, files, and lines were affected? WHO made the change? WHY was the change made, did it add new functionality to the code or fix a fault? WHEN was the change made? HOW LONG did the change take in calendar time? HOW MUCH EFFORT did the change require in developer-hours?</p><p>The extent to which the version management database satisfies these requirements, and at which levels of aggregation of changes, is shown in Table <ref type="table">1</ref>. In Table <ref type="table">1</ref>, ªDº indicates items directly in the database, while ªAº denotes items obtained by aggregation over constituent software sub-units. Elements denoted by ªD*º have problematic aspects discussed in <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A CONCEPTUAL MODEL FOR CODE DECAY</head><p>In this section, we explore a medical metaphor: Software suffering from decay can be thought of as diseased. After defining code decay in Section 3.1, we list some causes of the decay disease in Section 3.2. The software ªpatientº may exhibit the symptoms (Section 3.3), which, as with medical symptoms, suggest that code decay is present. Risk factors (Section 3.4) are reasons for concern about decay, even in the absence of symptoms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">What is Code Decay?</head><p>Code is decayed if it is more difficult to change than it should be, as reflected by three key responses:</p><p>1. COST of the change, which is effectively only the personnel cost for the developers who implement it, 2. INTERVAL to complete the change, the calendar/ clock time required, and 3. QUALITY of the changed software.</p><p>In the system we study, the interval and quality responses are constrained, schedules must be met, and quality standards must be attained, so to a significant extent the key question becomes the cost (effort) necessary to achieve the requisite interval and quality. Even so, interval and quality merit study. Prediction of interval, for example, is crucial in resource allocation decisions. Similarly, quality during the maintenance process is measurable, in terms of errors or unexpected behavior introduced into the system (but later removed).</p><p>Several points should be noted. First, code decay is a temporal phenomenon and it may be useful to add a ªmore difficult to change than it used to beº phrase to the definition.</p><p>Second, not all increase in difficulty results from decay: It is possible that the inherent difficulty of the desired changes is increasing.</p><p>Third, decay is distinct from the ability of the software to meet requirements: Code can be ªcorrectº and still be decayed, if it is excessively difficult to add new functionality or make other changes.</p><p>Fourth, software that is decaying may nevertheless be increasing in value. Indeed, the very changes that ªcauseº decay also increase the value of the software.</p><p>Fifth, implicit in our definition is the idea that code decay is the result of previous changes to the software. <ref type="foot" target="#foot_0">3</ref> Thus, there are ªactionableº means to prevent, retard, or remediate code decay. However, the ªno decay without changeº concept operates only at a high level. That a region of the code can decay as the result of changes elsewhere is entirely possible.</p><p>Finally, the ªharder to change than it should beº aspect of code decay, while central, is also elusive. Some code is simply inherently hard to change and to attribute this to decay is misleading. Many of the code decay indices in Section 4 adjust for this by means of scaling, for either the size of code units or time. In addition, difficulty of change is a function of the developer making the change. A definitive adjustment for developer ability has not been devised and usually we must relegate developer variability to ªnoiseº terms in our models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Causes of Code Decay</head><p>In a sense, change to code is the cause of decay. As change is necessary to continue increasing the value of the software, a useful concept of a cause must allow it to be present or absent in a project under active development. Causes of decay reflect the nature of the software itself, as well as the organizational milieu within which it is embedded. Examples include: <ref type="foot" target="#foot_1">4</ref>1. Inappropriate architecture that does not support the changes or abstractions required of the system. 2. Violations of the original design principles, which can force unanticipated changes to violate the original system assumptions. Changes that match the original design tend to be comparatively easy, while violations not only are difficult to implement, but also can lead future changes to be difficult as well. For example, in switching systems, many of the original system abstractions assume that subscriber phones remain in fixed locations. The changes required to support wireless phones that roam among cell sites were unanticipated by the original system designers. Note that this cause can be difficult to distinguish from inappropriate architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>Imprecise requirements, which can prevent programmers from producing crisp code, cause developers to make an excessive number of changes. 4. Time pressure, which can lead programmers to take shortcuts, write sloppy code, use kludges (see Section 3.3), or make changes without understanding fully their impact on the surrounding system. 5. Inadequate programming tools, i.e., unavailability of computer-aided software engineering (CASE) tools. 6. Organizational environment, manifested, for instance, in low morale, excessive turnover, or inadequate communication among developers, all of which can produce frustration and sloppy work. 7. Programmer variability, i.e., programmers who cannot understand or change delicate, complex code written by their more skilled colleagues. 8. Inadequate change processes, such as lack of a version control system or inability to handle parallel changes <ref type="bibr" target="#b14">[15]</ref>. (This cause is particularly pertinent in today's world of Web distribution of open source software.) Bad project management may amplify the effects of any of these causes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Symptoms of Code Decay</head><p>In our conceptual model, symptoms are measurable manifestations of decay, in the same way that chest pains are a symptom of heart disease. Some of the code decay indices in Section 4 are measurements of symptoms. Below we list plausible symptoms of decay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Excessively complex (bloated) code is more complicated</head><p>than it needs to be to accomplish its task. If rewritten, bloated code could become easier to understand and simpler to maintain. Standard software ªmetricsº are potential means to measure complexity, but they are designed to measure de facto complexity rather than the difference between de facto and inherent complexity. Based on discussions with developers, one promising candidate is nesting complexity: The nesting complexity of a line of code is the number of loops and conditionals enclosing it. 5 An alternative form of complexity, which is especially troublesome to developers, is treated in item 6. 2. A history of frequent changes, also known as code churn, suggests prior repairs and modifications. If change is inherently risky, then churn signifies decay. 3. Similarly, code with a history of faults may be decayed, not only because of having been changed frequently, but also because fault fixes may not represent the highest quality programming. 6  4. Widely dispersed changes are a symptom of decay because changes to well-engineered, modularized code are local. As discussed in Section 5.1, this symptom produces clear scientific evidence of code decay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>Kludges in code occur when developers knowingly make changes that could have been done more elegantly or efficiently. 7 While not an ªofficialº categorization, kludged code is often identified literally as such in MR abstracts. That kludged code will be difficult to change is almost axiomatic. 6. Numerous interfaces (i.e., entry points) are cited frequently by developers when they describe their intuitive definition of code decay. As the number of interfaces increases, increasing attention must be directed to possible side-effects of changes in other sections in the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Risk Factors for Code Decay</head><p>Risk factors, as in medicine, increase the likelihood of code decay or exacerbate its effect. By themselves, they are not necessarily indicators or causes of decay, but are cause for concern even in the absence of symptoms.</p><p>1. The Size of a module m, best measured in our analyses by xgvm (the number of noncommentary source lines 8 ), is clear cause for concern. Each of the symptoms in Section 3.3 is more likely to be present in a large module. 2. The Age of code is a clear risk factor, but intuition regarding age is complicated. On the one hand, aged code may be a risk factor for decay if the code is neglected or simply because older code units have had more opportunity to be changed and their original environment is less likely to have persisted.</p><p>On the other hand, code that is so stable that no change is necessary may not be decayed at all. Indeed, because of conflicting pressures, variability of age within a code unit may be the essential characteristic. 3. Inherent complexity is a risk factor for decay despite our defining code decay in a manner that adjusts for complexity (ªharder to change than it should beº). Inherent complexity is also relevant when comparing one system to another: Because it is inherently more complex, real-time software is more likely to decay than standard MIS applications. 4. Organizational churn (i.e., turnover or reorganization) increases the risk of decay by degrading the knowledge base and can also increase the likelihood of inexperienced developers changing the code (see item 7). Organizational churn is not readily discerned from the version management database; however, a parallel organizational study, reported in part in <ref type="bibr" target="#b15">[16]</ref>, links decay to events in the history of AT&amp;T and Lucent. 5. Ported or reused code was originally written in a different language, for a different system, or for another hardware platform. Both the porting (reuse) process itself and the new milieu are risks for decay. 6. Requirements load, when heavy, means that the code has extensive functionality and is subject to many constraints. Multiple requirements are hard to understand and the associated functionality is hard 5. Nesting complexity would capture the addition of features to the system by means of conditionals.</p><p>6. Of course, fault-prone code may also simply be inherently complicated. <ref type="bibr" target="#b6">7</ref>. For example, in response to schedule pressure. 8. Obtained by summing over all files f belonging to m.</p><p>to implement, resulting in a higher risk of decay. In addition, a heavy requirement load is likely to have accreted over time, so that the code is doing things it was not designed to do. 7. Inexperienced developers can be either new to programming or new to particular code. They increase the risk of decay because of lack of knowledge, a lack of understanding of the system architecture, and (for those early in their careers) potential for lower or less-developed skills.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CODE DECAY INDICES</head><p>In the software engineering literature there is a rich history of studies involving software measurement and measurement theory (see <ref type="bibr" target="#b16">[17]</ref>). Our code decay indices follow in this tradition, by being both quantified and observable in the version management data base. Pursuing the medical metaphor, CDIs may be interpreted as quantified symptoms, quantified risk factors, or prognoses, which are predictors of the responses (cost, interval, quality). Ordinarily, prognoses are functions of quantified symptoms and risk factors.</p><p>In order to define actionable priorities to remediate decay, indices must encapsulate developer knowledge and discriminate over both time and location in the software. Also, several of the indices can be visualized in compelling ways, as we illustrate in Sections 4.2.4 and 5.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">General Considerations</head><p>When defining a CDI, one confronts three critical issues. The first issue is to select appropriate levels of aggregation for both changes and software units. Of the levels of changes described in Section 2, MRs seem in most instances to be the most informative: The associated data sets are rich enough to be interesting, but not so large as to create intractability.</p><p>For most of the system we study, software can be aggregated to any of three levels. 9 Files are the atomic unit of software. Modules are collections of related files, corresponding physically to a single directory in the software hierarchy. A subsystem is a collection of modules implementing a major function of the software system. In our studies, modules typically yield the most insight.</p><p>The second issue is scaling: In some cases it is helpful to scale a CDI to convert it into a rate per unit time or per unit of software size (usually, NCSL, the number of noncomment source lines). In addition to being scaled for time, indices may also be functions of time, in order to illuminate the evolution of code decay.</p><p>The third issue is transformation: An index can sometimes be improved by transforming a variable mathematically, for example, by taking logarithms, powers, or roots. In some cases, the rationale may be physical, while in others it will be statistical, in order to improve the ªfitº of models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Example CDIs</head><p>Here, we present example CDIs that appear in the analyses in Section 5. They represent symptoms, risk factors, and prognoses of decay. Candidates for other symptoms and risk factors will be presented in future papers.</p><p>We use the following notation: denotes changes (as noted above, most often MRs), denotes lines of code, f denotes files, and m denotes modules. None of these objects are subscripted, so that (for example) denotes a sum over all changes.</p><p>For a change and software unit m, e b m means that ª touches m:º some part of m is changed by . Also Ifeg, the indicator of the event e, is equal to one if e occurs and zero otherwise.</p><p>In addition, several of the CDIs (all computable directly from the version management data base) depend on characteristics of changes:</p><p>hive numer of delts ssoited with ehh numer of lines dded y hiv numer of lines deleted y hei the dte on whih is ompletedY whih we term the dte of sx the intervl of Y the lendr time required to implement hi numer of developers implementing X</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">History of Frequent Changes</head><p>The historical count of changes is expressed by the CDI where jsj is the length of the time interval s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Span of Changes</head><p>The span of a change is the number of files it touches (here, files yield a more sensitive index than modules), leading to the CDI</p><formula xml:id="formula_0">psvi f If e b fgX Q</formula><p>In Section 5.4, we will provide evidence that psvi predicts the effort necessary to make changes. There are three primary reasons why changes touching more files are more difficult to accomplish and, hence, that span is a symptom of decay. First is the necessity to get expertise about unfamiliar files from other developers; this is especially vexing in large-scale software, where each developer has a localized knowledge of the code. Second is the breakdown of encapsulation and modularity. Wellengineered code is modular and changes are localized. Changes spanning multiple files are more likely to modify an interface. Third is the size: Touching multiple files significantly increases the size of the change. 9. Lines, even though tracked in the version management data base, simply lack sufficient structure to be appropriate.</p><p>In the subsystem we study (Section 5), psvi increases over time, so that this CDI produces clear scientific, symptomatic evidence of code decay, as discussed in Section 5.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Size</head><p>The size of a module m has already been defined as xgvm, the number of noncommentary source lines, obtained by summing over all files f belonging to m. Although we do not elaborate in Section 5, extensive analyses show most standard software ªcomplexityº metrics ( <ref type="bibr" target="#b17">[18]</ref>) are almost perfectly correlated with xgv in our data sets, so that size is effectively synonymous with complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Age</head><p>We define the age eqim of a software unit m as the average age of its constituent lines. The use of eqi in a predictive CDI is illustrated in Section 4.2.5.</p><p>Also interesting is the variability of the ages of the lines in a code unit. The SeeSoft view <ref type="bibr" target="#b18">[19]</ref> in Fig. <ref type="figure" target="#fig_4">2</ref> shows the variability of age in one module. The files are represented by boxes (labels have been changed for confidentiality) and the source code lines are represented by colored lines within the boxes. The lengths of these colored lines are proportional to the numbers of characters in the lines of source code, so this view can be interpreted as looking at a listing of the code from a distance. The color of a line represents its age: Files in which age is highly variable stand out with most of the rainbow colors. The files that changed little since their creation contain mostly a single hue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.5">Fault Potential</head><p>Predictive CDIs are functions of CDIs that quantify symptoms or risk factors and are intended to predict the key responses of effort, interval, and quality. We present three such indices, two dealing with quality and one with effort, which are discussed more thoroughly in Sections 5.3 and 5.4.</p><p>Predictors of the number of faults that will have to be fixed in module m (and, thus, of the quality response) in a future interval of time, taken from <ref type="bibr" target="#b19">[20]</ref>, include the weighted time damp model where Á is the entire set of deltas 10 up to time t and eqi is discussed in Section 4.2.4 and where , , I , and P are estimated using statistical analysis. Both of these indices illuminate change as the primary agent creating faults. (Even though faults do not arise spontaneously, this is not a tautology: The absence of other terms such as size and complexity is highly informative.) The indices depict differing temporal effects. In (4), the effects of changes are ªdampedº and attenuate over time, while in (5), faults are less likely in older code (provided is estimated to be less than one, as in our data). Statistical analyses of the models appear in Section 5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.6">Effort</head><p>One may construct predictors of the effort (person-hours) required to implement a change by fitting regression equations for measurements of effort as functions of factors that affect effort. A sample form for such a regression relationship is:</p><formula xml:id="formula_1">ipp H I psvi P f If e b fgjfj Q ehh R hiv S sx T hiX</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T</head><p>Here, jfj denotes the size in NCSL of the file f. One motivation for the form used in ( <ref type="formula">6</ref>) is to distinguish the dependency overhead associated with a change, captured in the terms involving H , I , and P , from the nominal effort, represented by the terms involving Q and R . The remaining terms incorporate interval and developer overhead. A statistical analysis of this index appears in Section 5.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">THE EVIDENCE FOR DECAY</head><p>In this section, we discuss some of our major results to date. All of these analyses are based on a single subsystem of the code, consisting of approximately 100 modules and 2,500 files. The change data consist of roughly 6,000 IMRs, 27,000 MRs, and 130,000 deltas. Some 500 different login names made changes to the code in this subsystem.</p><p>The results yield very strong evidence that code does decay. First, in Section 5.1, statistical smoothing demonstrates that the span of changes (see ( <ref type="formula">3</ref>)) increases over time, which is a clear symptom of code decay. This analysis is extended, in Section 5.2, by network-based visualizations showing that the increase in span is accompanied by (and may cause) a breakdown in the modularity of the code.</p><p>Our other results show how decay affects two of the three key responses, namely, quality and effort. In Section 5.3, we present models involving the fault potential CDIs of Section 4.2.5. Finally, in Section 5.4, we present a statistically estimated version of the CDI ipp in ( <ref type="formula">6</ref>), together with some intriguing implications, including indications that changes with large spans tend to require large efforts. This underscores the importance of the preceding sections that demonstrate increasing span of changes.</p><p>Not all of the evidence is conclusive or complete, and in some cases, multiple interpretations are possible. For example, some of the increase in span of changes (Section 5.1) and decrease in modularity (Section 5.2) can be attributed merely to growth of the subsystem. Similarly, the fault potential analysis in Section 5.3, identifies change as a causal agent for faults, but does not differentiate decay among modules.</p><p>Collectively, the results show that our change-based conceptual model of decay is the right one. That change is the agent of decay is borne out by the data, which is crucial since there are then actionable means to retard or reverse decay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Temporal Behavior of the Span of Changes</head><p>The CDI FILES of (3) measures the difficulty of a change by how many code units (files) need to be changed in order to implement it. An increase in the span of changes, then, is symptomatic of decay, as discussed in Section 4.2.2.</p><p>Fig. <ref type="figure" target="#fig_5">3</ref> shows that span is increasing for the subsystem under study. There, we display the chance that at any given time an MR touches more than one file by smoothing data in which each point corresponds to an MR. A point's xcoordinate is time represented by the opening date and its y-coordinate is one when more than one file is touched and zero otherwise. Three local linear smooths (see, e.g., <ref type="bibr" target="#b20">[21]</ref> and <ref type="bibr" target="#b21">[22]</ref> for introduction and discussion.) are shown in the top plot. These smooths are essentially weighted local averages, where the weights have a Gaussian shape and the widths of the windows (i.e., standard deviation of the weight function) are h HXQ (purple curve), h IXS (multicolored curve), and h UXS (blue curve).</p><p>The central curve, h IXS, shows an initial downward trend, which is natural because many files are touched by common changes in the initial development phase, followed by a steady upward trend starting in 1990. This last trend reflects breakdown in the modularity of the code, as we discuss further in Section 5.2. That this is a substantial increase comes from the fact that values on the y-axis represent probabilities (local in time) that a change will touch more than one file, which more than doubles from a low of less than 2 percent in 1989 to more than 5 percent in 1996.</p><p>In the absence of more detailed analysis, the results in the top plot in Fig. <ref type="figure" target="#fig_5">3</ref> depend on the window width h. The larger window width, h UXS, shows only the upward trend, while the smaller window width, h HXQ, shows a lot of additional structure, which may be ªmicrotrendsº or may instead be spurious sampling artifacts. But how can we be sure? Furthermore, how do we know the features observed in the h IXS smooth, which contains the important lessons, are real?</p><p>The bottom half of Fig. <ref type="figure" target="#fig_5">3</ref> is a SiZer map, 11 which addresses this issue. Each location corresponds to a date and to a window width h and is shaded blue (red) when the smooth at that window width and date is statistically significantly increasing (decreasing, respectively). Regions where there is no significant change are shaded in the intermediate color purple.</p><p>The smallest window width, h HXQ, in the top plot is represented by the bottom white line in the lower plot and is shaded purple in the top plot, since this window width is shaded purple at all dates in the SiZer map. This is interpreted as ªwhen the data are studied at this level of resolution, there are no significant increases or decreases,º i.e., the wiggles in the curve are not statistically significant.</p><p>The intermediate window width, h IXS, runs through both the red and blue shaded regions. This same coloring is used in the curve in the top plot, which shows that the structure is statistically significant. In particular, there is an important downward trend at the beginning and upward trend after 1990.</p><p>11. SiZer, its properties, and some variations are discussed in <ref type="bibr" target="#b22">[23]</ref>.</p><p>The large window width, h UXS, runs through the region that is shaded entirely blue in the bottom plot and, thus, inherits this color in the top plot. This shows that when the data are smoothed nearly to the point of doing a simple linear least squares fit, the resulting line slopes significantly upwards.</p><p>These conclusions are complementary rather than inconsistent, because SiZer shows what is happening at each scale of resolution. When the data are not smoothed too much, there can be a decrease in one region, which, when the data are smoothed very strongly, becomes overwhelmed by the increases elsewhere.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Time Behavior of Modularity</head><p>A key tenet of modern programming practice is modularity: code functionality should be local, so that changes will be also. In the system we analyzed, subsystems are divided into modules by functionality and this division is successful to the extent which, when working on one module, a developer need not devote significant attention to the effects on other modules. Conversely, changes that require modifications of many modules are likely to be more difficult to make correctly.</p><p>Alone, the increase in span of changes described in Section 5.1 does not imply breakdown of the modularity of the subsystem. Some increase in span could reflect simply the growth of the subsystem and even changes of wider span need not cross module boundaries. The network visualization tool NicheWorks <ref type="bibr" target="#b23">[24]</ref>, which helps display structure (including clusters) in networks, allows us to address the question of whether modularity is breaking down over time, and leads to the results in Fig. <ref type="figure" target="#fig_6">4</ref>, which suggest strongly that it is.</p><p>The head of each tadpole-like shape in the upper left panel of Fig. <ref type="figure" target="#fig_6">4</ref> corresponds to a module; the positions of the modules have been chosen by NicheWorks in a manner that places pairs of modules nearby if they have been changed together as part of the same MRs a large number of times. More precisely, the weights are defined in terms of the ªnumber of changesº CDI of ( <ref type="formula">1</ref> Ifhei P sg is the number of MRs touching both m and m H . In the upper left panel, the heads show this network view using all the change data through the end of calendar year 1988 (corresponding to one choice of s), while the tails of the segments display the same view at the end of 1987 (an earlier choice of s).</p><p>In this way, one can see how relationships among modules evolved through time. In the top panel of Fig. <ref type="figure" target="#fig_6">4</ref>, there are two main clusters of roughly a dozen modules each. However, in the center panel, which displays the change data through the end of 1989 in the locations of the heads (the 1988 data appear here as the locations of the segments' endpoints), these two clusters have mostly merged. The merging process continued and at the end of 1996 the clusters are no longer visible. While the logic of the code was originally intended to see to it that some modules would be essentially independent of each other, new and unanticipated functionality may have helped to destroy this independence.</p><p>The weights in <ref type="bibr" target="#b6">(7)</ref> constitute a compromise between simple counts wmY m H grxqmY m H Y sY which tend to place too close together pairs of modules that are touched together frequently only because they are touched large numbers of times in total and</p><formula xml:id="formula_2">wmY m H grxqmY m H Y s grxqmY s Â grxqm H Y s p Y Y V</formula><p>which can be interpreted as a correlation (it is dimensionless and lies between zero and one), but which can exaggerate relationships between modules that are rarely touched at all. One shortcoming is that the weights of ( <ref type="formula">7</ref>) (unlike those of ( <ref type="formula">8</ref>)) are not invariant with numbers of changes. However, the following dispersion analysis provides further evidence of the decline of modularity. In 1988, the mean square distance between points in the small, eleven-point cluster and its centroid is HXQSS, while the average distance between points in the larger, 26-point cluster and its centroid is HXSPT. The intercluster distance, or the distance between the centroids of the two clusters, is PXUV. An intuitively appealing measure of distance between clusters, then, is PXUVa HXQSS Â HXSPT p TXRQ. The analogous quantity for 1989 is IXQSa HXQHT Â HXRIW p QXUU. After the large decrease in 1989, this measurement continues to shrink, albeit not as rapidly, reaching IXRHa HXQQH Â HXRTW p QXST in 1996.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Prediction of Faults</head><p>In Section 3.1, we identified quality as one of three key responses to code decay. Here we summarize research linking faults in the software to symptoms of code decay, using the predictive CDIs p h of (4) and p qvw of (5). More complete discussion of this fault potential modeling appears in <ref type="bibr" target="#b19">[20]</ref>. In this work, the authors counted the numbers of faults whose fixes touched each of the modules in a subsystem of the 5ESS 2 code in a two year period and developed statistical models for these fault counts using measurements on the modules that were calculable before the start of the two year period. The thrust of these models is to predict the distribution of future faults over modules in the subsystem from the modules' change history. The best models predicted numbers of faults using numbers of changes to the module in the past, the dates of these changes (i.e., the negative of their ages, measured in years), and their sizes, as in (4):</p><formula xml:id="formula_3">p h m G e b m e HXUSÂhei Â log ehhY m hivY m Y W</formula><p>with the parameter XUS determined by statistical analysis (see <ref type="bibr" target="#b19">[20]</ref>). Thus, large, recent changes add the most to fault potential and the number of times a module has been changed is a better predictor than its size of the number of faults it will suffer in the future. That T H is the primary (and direct) evidence that changes induce faults: Where H, past changes of the same size would be indistinguishable from one another and, hence, none could be posited to have any specific effect. The model ( <ref type="formula">9</ref>) does provide evidence that some modules are more decayed than others. In principle, this issue could be addressed by allowing to be module dependent, but we have not yet done this.</p><p>An alternative (and less powerful) model, using the CDI of ( <ref type="formula">5</ref>) and the same data as <ref type="bibr" target="#b8">(9)</ref>, a generalized linear model, is</p><formula xml:id="formula_4">p qvw m XHIU Â If e b mg Â XTR eqim X IH</formula><p>This model implies that code having many lines that have survived for a long time is likely to be relatively free of faults. More precisely, according to <ref type="bibr" target="#b9">(10)</ref>, code a year older than otherwise similar code tends to have only two-thirds as many faults.</p><p>One way to evaluate these models is by comparison with a ªnaiveº model that predicts the number of future faults in given locations to be proportional to the number of past faults. As discussed in <ref type="bibr" target="#b19">[20]</ref>, in some cases, <ref type="bibr" target="#b9">(10)</ref> is only marginally superior to the naive model (as measured by a Poisson deviance). Nevertheless, this still means that a model suggesting causality (deltas cause faults) has the same explanatory power as a model positing simply that the distribution of faults over modules is stationary over time.</p><p>Simulations of deviances provide strong evidence that the model ( <ref type="formula">9</ref>) is superior to that of <ref type="bibr" target="#b9">(10)</ref>. In particular, this means that treating changes individually improves the predictions.</p><p>Equally important is that other variables did not improve the predictions, once size and time of changes are taken into account. In particular, predictions do not improve by including either module size or other measures (metrics) of software complexity (which in our data are correlated essentially completely with size). Thus, changes to code are more responsible for faults than the complexity of the code.</p><p>Moreover, the number of developers touching a module had no effect on its fault potential. <ref type="foot" target="#foot_2">12</ref> One possible explanation is that strong organization programming standards attenuate any such effects. The change from code ownership to change ownership ( <ref type="bibr" target="#b15">[16]</ref>) is a confounding factor in this regard.</p><p>Finally, concurrent changes with large numbers of other modules did not contribute to fault potential. In one sense, this suggests that the decline of modularity described in Section 5.2 may not be harmful, but since the size of changes is correlated with their span, it is more likely that we are simply seeing the size variable mask the effect of span.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Models for Effort</head><p>Here, we assess the evidence for ªbottom lineº relevance of code decay: Can the effort required to implement changes be predicted from symptoms and risk factors for decay? The analysis employs a variant of the predictive CDI EFF of (6), with the ªsum of touched file sizesº term in (6) omitted. The results are suggestive but, because of the small sample size, not definitive.</p><p>The model was fit using data from a set of 54 features. As noted in Section 2.1, features are the units of system functionality (e.g., call waiting) by which the system is extended and are too aggregated for most purposes. However, effort data (person hours) are available only at this level. (Further analysis of factors affecting effort, based on larger data sets but requiring the imputation of effort for individual changes given aggregated effort values, is in <ref type="bibr" target="#b24">[25]</ref>.)</p><p>Extreme variability of the feature-level data necessitated taking logarithms of all variables. (The actual transformation, logI Á, avoids negative numbers.) The resultant model is logI ipp XQP XIQ logI psvi P À XHWlogI hiv P XIP logI ehh logI hiv XII logI sx À XRU logI hiveX II All coefficients shown are statistically significantly different from zero; the multiple P value is XQV. Despite the danger that this model is ªoverfit,º removal of any of the variables decreases the quality of the fit dramatically. Some interpretations of (11) seem clear. First, dependence on psvi confirms that the span of changes is indeed a symptom of decay; that the dependence is quadratic hints that moderate span may not be serious. Second, as hypothesized in Section 4.2.6, dependency overhead (in <ref type="bibr" target="#b10">(11)</ref>, embodied in ipp) can be distinguished from nominal effort (terms involving ehh and hiv).</p><p>Other interpretations seem more problematic. For example, the negative coefficient for logI hiv P deletions are accomplished relatively quickly (which makes sense), but can also be interpreted as simply fitting cases in the data where large numbers of lines are deleted. Similarly, the interaction term between additions and deletions (logI ehh Â logI hiv) may suggest that the hardest changes are those requiring both additions and deletions, but the high level of aggregation mandates caution when trying to extrapolate this to, say, the delta level.</p><p>The negative coefficient for logI hive is puzzling, since it is difficult to believe that features containing large numbers of editing changes are somehow easier to implement. But removing this single term decreases P nearly by one-half, so there is no doubt that the effect is present in the data. Detailed examination of the data suggests that the negative coefficient is picking up the approximately five cases (10 percent of the data) in which effort is large (close to the maximum) effort, but the number of deltas is very small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Confirmatory Evidence</head><p>The results reported in this paper are derived primarily from statistical analysis of change management data. They are corroborated by results reported in <ref type="bibr" target="#b15">[16]</ref>, which is part of the same code decay project.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">SUMMARY</head><p>Using tools developed to handle change management data, a conceptual model of code decay (associated concepts of causes, symptoms and risk factors), code decay indices, and statistical analyses, we have found evidence of decay in the software for a large telecommunications system.</p><p>Four specific analyses were performed. They demonstrate: 1) The increase over time in the number of files touched per change to the code, 2) the decline in modularity of a subsystem of the code, as measured by changes touching multiple modules, 3) contributions of several factors (notably, frequency and recency of change) to fault rates in modules of the code, and 4) that span and size of changes are important predictors (at the feature level) of the effort to implement a change.</p><p>At the same time, evidence of dramatic, widespread decay is lacking. Retrospectively, this is not surprising: The system studied is a fifteen-year old, successful product to which new features can still be added.</p><p>The tools, concepts, and analyses are transferable to any software project for which comparable change management data exist. We anticipate that all projects of sufficiently large scale will exhibit decay to some extent: that is, code decay is a generic phenomenon.</p><p>Current investigations are focusing on the effectiveness and economic efficiency of means to prevent or retard code decay, such as perfective maintenance. Whether (in the medical metaphor), code decay can ultimately be fatal is not clear. However, there are anecdotal reports of systems that have reached a state from which further change is not possible.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Changes to the code (bold boxes) and associated data fields.</figDesc><graphic coords="2,29.14,69.17,245.14,159.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Ithe number of changes to a module m in the time interval s, appears in Section 5.2. In other settings, the frequency of changes may be more relevant, as quantified by pimY s I jsj grxqmY sY P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>linear model p qvw mY t P Â PÁ If e b mg Â eqim Y S</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The SeeSoft view of one module. Color represents the age of a source code line. Rainbow colored boxes represent frequently changed files, while boxes with a single hue represent files that changed little since their creation.</figDesc><graphic coords="6,67.18,69.17,432.17,276.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. SiZer maps of numbers of files touched by change through time. The overall trend has been a significant increase in the difficulty of changes.At a finer resolution, there was a decreasing trend during the developmental phase of the subsystem when changes likely involved multiple files, but this trend reversed before long.</figDesc><graphic coords="8,103.18,69.17,360.11,484.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Top: NicheWorks view of the modules in one subsystem using change data through 1988 to place modules which have been changed at the same time close to one another. Two clusters of modules are evident; a module within one of these clusters is often changed together with other modules in the cluster but not with other modules. Center: NicheWorks view of the modules in the top left, this time incorporating the change history through 1989. The clusters that appear in the top left view are converging in on each other. This suggests that the architecture that was previously successful in separating the functionality of the two clusters of modules is breaking down. Bottom: The breakdown continued and at the end of 1996 there was no suggestion of multiple clusters of modules.</figDesc><graphic coords="9,320.94,69.17,187.60,463.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>), with that for modules m and m H being</figDesc><table><row><cell>wmY m H</cell><cell>R</cell><cell>p</cell><cell>grxqmY m H Y s grxqmY s Â grxqm H Y s</cell><cell>Y</cell><cell>U</cell></row><row><cell cols="5">where s is an interval of time (see below) and where</cell><cell></cell></row><row><cell cols="3">grxqmY m H Y s</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>e b mY e b m H</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>That is, there is no ªnaturalº or ªphysicalº decay.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>There is no implication every cause is present in any given situation.TABLE 1 Summary of Change Data</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_2"><p>One might expect that modules modified by many developers would have confused logic as a result of the different styles and, hence, be difficult to change.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors would like to acknowledge conversations and contributions from Mark Ardis, David Parnas, Harvey Siy, Lawrence Votta, and David Weiss. We would also like thank the associate editor and three anonymous referees. This research was supported in part by U.S. National Science Foundation grants SBR-9529926 and DMS-9208758 to the National Institute of Statistical Sciences.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Stephen G. Eick received his BA from Kalamazoo College <ref type="bibr">(1980)</ref>. He received his PhD, in statistics, and MA both from the University of Minnesota, Madison, in 1985. He is the CTO of Visual Insights, a Lucent New Ventures Company. He and his colleagues have developed a suite of visualizations including tools for displaying geographic and abstract networks, software source code, text corpora, log files, program slices, and relational databases. He is an active researcher, is widely published, and holds several software patents. He was the program cochair of the Information Visualization '96 Symposium, Statistical Graphics program chair for the 1996 ASA Conference, and on many program committees. He is particularly interested in visualizing databases associated with large software projects, networks, and building high-interaction user interfaces. He is a member of the IEEE. He is interested in inventing ways to describe and understand large, dynamic, and complex systems, such as large software systems, human populations, or a human brain. His goal is to find ways to summarize system evolution data, to gain new insights, and to design new analysis methods and tools that would significantly improve the understanding and control of such systems. He is a member of the IEEE.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Karr</surname></persName>
		</author>
		<title level="m">ªOn Measurement and Analysis of Software Changes,º technical report</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>National Inst. of Statistical Sciences</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Belady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Lehman</surname></persName>
		</author>
		<title level="m">ªProgramming System Dynamics, or the Meta-Dynamics of Systems in Maintenance and Growth,º technical report</title>
		<imprint>
			<date type="published" when="1971">1971</date>
		</imprint>
		<respStmt>
			<orgName>IBM T.J. Watson Research Center</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Belady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Lehman</surname></persName>
		</author>
		<title level="m">ªA Model of Large Program Development,º IBM Systems J</title>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="225" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Belady</surname></persName>
		</author>
		<title level="m">Program Evolution: Processes of Software Change</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName><forename type="first">I</forename><surname>Vessey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªSome Factors Affecting Program Repair Maintenance: An Empirical Study</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="128" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ªUnderstanding Software Maintenance Work</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bendifallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Scacchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="311" to="323" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ªManaging Software Engineering Projects: A Social Analysis</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Scacchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="59" />
			<date type="published" when="1984-01">Jan. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Kemerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Ream</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªEmpirical Research on Software Maintenance: 1981±1990,º technical report</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Parnas</surname></persName>
		</author>
		<title level="m">ªSoftware Aging,º Proc. 16th Int&apos;l Conf. Software Eng</title>
		<imprint>
			<date type="published" when="1994-05">May 1994</date>
			<biblScope unit="page" from="279" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Ohlsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Alberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªPredicting Fault-Prone Software Modules in Telephone Switches</title>
		<imprint>
			<date type="published" when="1996-12">Dec. 1996</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="886" to="894" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Perricone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªSoftware Errors and Complexity: An Empirical Investigation</title>
		<imprint>
			<date type="published" when="1984-01">Jan. 1984</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="42" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">ªA Methodology for Collecting Valid Software Engineering Data</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Basili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="728" to="737" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Swanson</surname></persName>
		</author>
		<title level="m">ªThe Dimensions of Maintenance,º Proc. Second Conf. Software Eng</title>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="492" to="497" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>An</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Gustafson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Melton</surname></persName>
		</author>
		<title level="m">ªA Model for Software Maintenance,º Proc. Conf. Software Maintenance</title>
		<imprint>
			<date type="published" when="1987-09">Sept. 1987</date>
			<biblScope unit="page" from="57" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Siy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Votta</surname></persName>
		</author>
		<title level="m">ªParallel Changes in Large Scale Software Development: An Observational Case Study,º Proc. Int&apos;l Conf. Software Eng</title>
		<imprint>
			<date type="published" when="1998-04">Apr. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Staudenmayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Siy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Votta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªAdapting to a New Environment: How a Legacy Software Organization Copes with Volatility and Change</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Pfleeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jeffery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kitchenham</surname></persName>
		</author>
		<title level="m">ªStatus Report on Software Measurement,º IEEE Software</title>
		<imprint>
			<date type="published" when="1997-04">Mar./Apr. 1997</date>
			<biblScope unit="page" from="33" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Zuse</surname></persName>
		</author>
		<title level="m">Software Complexity: Measures and Methods</title>
		<meeting><address><addrLine>Berlin, New York</addrLine></address></meeting>
		<imprint>
			<publisher>de Gruyter</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">ªSoftware Visualization in the Large</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">º IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="33" to="43" />
			<date type="published" when="1996-04">Apr. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ªPredicting Fault Incidence Using Software Change History</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Karr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Siy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="653" to="661" />
			<date type="published" when="2000-07">July 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Wand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kernel</forename><surname>Smoothing</surname></persName>
		</author>
		<author>
			<persName><surname>London</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Chapman and Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Gijbels</surname></persName>
		</author>
		<title level="m">Local Polynomial Modelling and Its Applications</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Chapman and Hall</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ªSiZer for Exploration of Structures in Curves</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Marron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Am. Statistical Assoc</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="issue">447</biblScope>
			<biblScope unit="page" from="807" to="823" />
			<date type="published" when="1999-09">Sept. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">ªNicheworksÐInteractive Visualization of Very Large Graphs</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Wills</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Computational and Graphical Statistics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="190" to="212" />
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">ªInferring Change Effort from Configuration Management Databases</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Fifth Int&apos;l Symp. Software Metrics</title>
		<imprint>
			<date type="published" when="1998-11">Nov. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
