<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Tableau Decision Procedure for SHOIQ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-07-06">6 July 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<addrLine>Oxford Road</addrLine>
									<postCode>M13 9PL</postCode>
									<settlement>Manchester</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<addrLine>Oxford Road</addrLine>
									<postCode>M13 9PL</postCode>
									<settlement>Manchester</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Ulrike</forename><surname>Sattler</surname></persName>
							<email>ulrike.sattler@manchester.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<addrLine>Oxford Road</addrLine>
									<postCode>M13 9PL</postCode>
									<settlement>Manchester</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<addrLine>Oxford Road</addrLine>
									<postCode>M13 9PL</postCode>
									<settlement>Manchester</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Tableau Decision Procedure for SHOIQ</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-07-06">6 July 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">0B7C23B30AA080C361EE7F597CECB6E8</idno>
					<idno type="DOI">10.1007/s10817-007-9079-9</idno>
					<note type="submission">Received: 24 April 2006 / Accepted: 23 February 2007 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Description logic • Decision procedures</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>OWL DL, a new W3C ontology language recommendation, is based on the expressive description logic SHOIN . Although the ontology consistency problem for SHOIN is known to be decidable, up to now there has been no known "practical" decision procedure, that is, a goal-directed procedure that is likely to perform well with realistic ontology derived problems. We present such a decision procedure for SHOIQ, a slightly more expressive logic than SHOIN , extending the well-known algorithm for SHIQ, which is the basis for several highly successful implementations.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Description logics (DLs) are a family of logic-based knowledge representation formalisms <ref type="bibr" target="#b0">[1]</ref>. Although they have a range of applications (e.g., configuration <ref type="bibr" target="#b27">[28]</ref> and information integration <ref type="bibr" target="#b9">[10]</ref>), they are perhaps best known as the basis for widely used ontology languages such as OIL, DAML+OIL, and OWL <ref type="bibr" target="#b23">[24]</ref>, the last of which is now a World Wide Web Consortium (W3C) recommendation <ref type="bibr" target="#b4">[5]</ref>.</p><p>The OWL specification describes three language "species" -OWL Lite, OWL DL, and OWL Full -two of which (OWL Lite and OWL DL) are based on expressive description logics. <ref type="foot" target="#foot_0">1</ref> The decision to base these languages on DLs was motivated by a requirement that key inference problems (such as ontology consistency) be decidable and hence that it should be possible to provide reasoning services to support ontology design and deployment <ref type="bibr" target="#b23">[24]</ref>.</p><p>OWL Lite and OWL DL are based on the DLs SHIF and SHOIN , respectively -in fact, OWL Lite is just a syntactic subset of OWL DL <ref type="bibr" target="#b23">[24]</ref>. <ref type="foot" target="#foot_1">2</ref> Standard reasoning problems include the computation of the subsumption hierarchy between concepts defined in a given ontology, deciding the satisfiability of all concepts defined in a given ontology and retrieving all instances of a concept expression. In SHOIN , these standard reasoning problems can all be reduced to the ontology consistency problem, which is known to be decidable: this is a consequence of a reduction of DLs with transitive roles to DLs without such roles <ref type="bibr" target="#b36">[37]</ref> and the fact that applying this reduction to SHOIN yields a fragment of the two-variable fragment of firstorder logic with counting quantifiers <ref type="bibr" target="#b28">[29]</ref>. To the best of our knowledge, however, the algorithm described here is the first "practical" decision procedure for SHOIN , that is, the first goal-directed procedure that is likely to perform well with realistic ontology-derived problems <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b36">37]</ref>.</p><p>In this paper, we present a goal-directed decision procedure for SHOIQ, that is, SHOIN extended with qualified number restrictions <ref type="bibr" target="#b20">[21]</ref>. The algorithm extends the well-known tableau algorithm for SHIQ <ref type="bibr" target="#b25">[26]</ref>, which is the basis for several highly successful implementations <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b34">35]</ref>.</p><p>As its name indicates, SHOIQ extends SHIQ with nominals, 3 that is, concepts with a singleton extension <ref type="bibr" target="#b10">[11]</ref>. Nominals are a prominent feature of hybrid logics <ref type="bibr" target="#b5">[6]</ref> and can also be viewed as a powerful generalization of ABox individuals <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b31">32]</ref>. A form of nominals was already present in early DL systems such as Classic <ref type="bibr" target="#b6">[7]</ref> and Crack <ref type="bibr" target="#b7">[8]</ref>, and they occur naturally in ontologies, for example, when describing a concept such as EUCountries by enumerating its members, that is, {Austria, . . . , UnitedKingdom} (such an enumeration is equivalent to a disjunction of nominals). This allows applications to infer, for example, that persons who visit only EUCountries can visit at most 15 countries.</p><p>It has long been recognized that there is a close connection between DLs and propositional modal and dynamic logics <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b32">33]</ref>. One reason why all these logics enjoy good computational properties, such as being robustly decidable, is that they have some form of tree model property <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b39">40]</ref>: that is, if an ontology is consistent, then it has a model whose relational structure forms a tree or can be seen as a tree. This feature is crucial in the design of tableau algorithms, allowing them to search only for treelike models. More precisely, DL tableau algorithms decide consistency of an ontology by trying to construct an abstraction of a model for it, a so-called completion graph. For logics with the tree model property, we can restrict our search or construction to tree-shaped completion graphs. For expressive DLs, this restriction is crucial because tableau algorithms for them employ a cycle detection technique called blocking to ensure termination. This is of special interest for SHIQ, where the interaction between inverse roles and number restrictions results in the loss of the finite model property; that is, there are consistent ontologies that admit only infinite models <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b32">33]</ref>. On such an input, the SHIQ tableau algorithm generates a finite, tree-shaped completion graph that can be "unravelled" into an infinite tree model, and where a node in the completion graph may stand for infinitely many elements of the model <ref type="bibr" target="#b25">[26]</ref>. Even when the language includes nominals but excludes one of number restrictions or inverse roles <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b24">25]</ref>, or if nominals are restricted to ABox individuals <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b31">32]</ref>, we can work on forest-shaped completion graphs, with each nominal (individual) being the root of a treelike section; this causes no inherent difficulty because the size of the nontree part of the graph is restricted by the number of individuals or nominals in the input.</p><p>The difficulty in extending the SHOQ or SHIQ algorithms to SHOIQ is due to the interaction between nominals, number restrictions, and inverse roles, which leads to the almost complete loss of the tree model property and causes the complexity of the ontology consistency problem to jump from ExpTime to NExpTime <ref type="bibr" target="#b35">[36]</ref>. To see this interaction, consider an ontology containing the following two axioms involving a nominal o and a non-negative integer n:</p><formula xml:id="formula_0">˙ ∃U.o o ˙ ( n U -.F).</formula><p>The first statement requires that, in a model of this ontology, every element has a U-edge leading to o; the second statement restricts the number of inverse U-edges going from o to instances of F to at most n. Thus the interaction between the nominal and the number restriction on the inverse of U imposes an upper bound of n on the number of instances of the concept F. If we add further axioms, we might need to consider arbitrarily complex relational structures among instances of F. For example, if we add the following axiom, then each instance of F is necessarily R-related to every instance of F, including itself:</p><formula xml:id="formula_1">F ˙ ( nR.F).</formula><p>Similarly, the following axiom would enforce S-cycles over instances of F:</p><formula xml:id="formula_2">F ˙ ( 1S.F) ( 1S -.F).</formula><p>Hence a tableau algorithm for SHOIQ needs to be able to handle arbitrarily complex relational structures, and thus we cannot restrict our attention to completion trees or forests.</p><p>Matters are further complicated by the fact that SHOIQ does not enjoy the finite model property, and hence there are SHOIQ axioms that enforce the existence of an infinite number of instances of a concept. For example, the concept ¬N ∃P.N is satisfiable w.r.t. the following axiom but only in models with infinitely many instances of N: N ˙ ( 1P -. ) ∃P.N. Now consider an ontology that contains, among others, all the above-mentioned axioms. The consistency of this ontology then crucially depends on the relations enforced between instances of F and N. For example, the additional axioms N ˙ ∃V.F and F ˙ ( kV -.N) yield an inconsistent ontology since our at most n instances of F cannot play the rôle of V-fillers for infinitely many instances of N when each of them can be the V-filler of at most k instances of N.</p><p>In summary, a tableau algorithm for SHOIQ needs to be able to handle both arbitrarily complex relational structures and finite tree structures representing infinite trees and to make sure that all constraints are satisfied -especially number restrictions on relations between these two parts -while still guaranteeing termination.</p><p>Two key intuitions have allowed us to devise a tableau algorithm that meets all of these requirements. The first intuition is that, when extending a SHOIQ completion graph, we can distinguish those nodes that may be arbitrarily interconnected (socalled nominal nodes) from those nodes that still form a tree structure (so-called blockable nodes). Fixing a (double exponential) upper bound on the number of nominal nodes is crucial to proving termination; it is not enough to guarantee termination, however, as we may repeatedly create and merge nominal nodes -a so-called yo-yo. <ref type="foot" target="#foot_3">4</ref>The second intuition is that the yo-yo problem can be overcome by "guessing" the exact number of new nominal nodes resulting from interactions between existing nominal nodes, inverse roles, and number restrictions. This guessing is implemented by a new expansion rule, the NN-rule, which, when applied to a relevant nR.C concept in the label of a nominal node, generates (nondeterministically) between 1 and n new nominal nodes, all of which are pairwise disjoint. This prevents the repeated yo-yo construction, and termination is now guaranteed by the upper bound on the number of nominal nodes and the use of standard blocking techniques for the blockable nodes. The nondeterminism introduced by this rule will clearly be problematic for large values of n, but large values in number restrictions are already known to be problematic for SHIQ. Moreover, the rule has excellent "pay as you go" characteristics: <ref type="foot" target="#foot_4">5</ref> If number restrictions are functional (i.e., where n is 1), <ref type="foot" target="#foot_5">6</ref>the new rule becomes deterministic; if there are no interactions between number restrictions, inverse roles, and nominals, the rule will never be applied; if there are no nominals, the new algorithm will behave like the algorithm for SHIQ; and if there are no inverse roles, the new algorithm will behave like the algorithm for SHOQ. The algorithm has, in fact, already been implemented in the well-known Fact++ and Pellet systems and has shown very promising behavior with realistic ontologies <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b38">39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>In this section, we introduce the DL SHOIQ. This includes the definition of syntax, semantics, and inference problems. We start with SHOIQ-roles, then introduce some abbreviations, and finally define SHOIQ-concepts.</p><p>Definition 1 Let R be a set of role names, with a set R + ⊆ R of transitive role names. The set of SHOIQ-roles (or roles for short) is R ∪ {R -| R ∈ R}. A role inclusion axiom is of the form R S, for two roles R and S. A role hierarchy is a finite set of role inclusion axioms.</p><p>An interpretation I = I , • I consists of a nonempty set I , the domain of I, and a function • I that maps every role to a subset of I × I such that, for P ∈ R and R ∈ R + ,</p><p>x, y ∈ P I iff y, x ∈ P -I , and if x, y ∈ R I and y, z ∈ R I , then x, z ∈ R I .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An interpretation I satisfies a role hierarchy</head><formula xml:id="formula_3">R if R I ⊆ S I for each R S ∈ R; such an interpretation is called a model of R.</formula><p>We introduce some notation to make the following considerations easier. 1. To avoid considering roles such as R --, we define a function Inv that returns the inverse of a role:  The interpretation function • I of an interpretation I = I , • I maps, addition- ally, every concept to a subset of I such that</p><formula xml:id="formula_4">Inv(R) := R -if R is a role name, S if R = S -for a role name S.</formula><formula xml:id="formula_5">(C D) I = C I ∩ D I , (C D) I = C I ∪ D I , ¬C I = I \C I , for all o ∈ C, o I = 1 (∃R.C) I = {x ∈ I | There is a y ∈ I with x, y ∈ R I and y ∈ C I }, (∀R.C) I = {x ∈ I | For all y ∈ I , if x, y ∈ R I , then y ∈ C I }, ( nR.C) I = {x ∈ I | R I (x, C) n}, ( nR.C) I = {x ∈ I | R I (x, C) n},</formula><p>where, for a set M, we denote the cardinality of M by M and R I (x, C) is defined as {y | x, y ∈ R I and y ∈ C I }. </p><formula xml:id="formula_6">if T ∪ {a ˙ C | a : C ∈ A} ∪ {a ˙ ∃R.b | (a, b ) : R ∈ A}, R is consistent [1].</formula><p>As for other propositionally closed logics, subsumption and satisfiability can be reduced to each other. We can also reduce satisfiability of concepts w.r.t. a knowledge base to knowledge base consistency: C is satisfiable w.r.t. (T , R) if and only if (T ∪ {o ˙ C}, R) is consistent, for o a nominal that does not occur in C or T . As a consequence, in the remainder of this paper and without loss of generality, we will restrict our attention to knowledge base consistency.</p><p>We did not choose to make a unique name assumption; that is, two nominals might refer to the same individual. We can, however, use an axiom o i ˙ ¬o j to assert that nominals o i and o j do not refer to the same individual, and we can use a set of such axioms for each o i = o j occurring in T to mimic the effect of the unique name assumption. Similarly, the inference algorithm presented below can easily be adapted to the unique name case by a suitable initialization of the inequality relation . =.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Tableau for SHOIQ</head><p>For ease of presentation, we assume all concepts to be in negation normal form (NNF). Each concept can be transformed into an equivalent one in NNF by pushing negation inward, making use of de Morgan's laws and the duality between existential and universal restrictions and between atmost and atleast number restrictions <ref type="bibr" target="#b26">[27]</ref>.</p><p>For a concept C, we use nnf(C) to denote the NNF of C, we use ¬C for the NNF of ¬C, and we use sub(C) to denote the set of all subconcepts of C (including C).</p><p>For a knowledge base (T , R), we define the set of "relevant subconcepts" cl(T , R) as follows:</p><formula xml:id="formula_7">cl(T , R) := C ˙ D∈T cl(nnf(¬C D), R) where cl(E, R) := sub(E) ∪ { ¬C | C ∈ sub(E)} ∪ {∀S.C | ∀R.C ∈ sub(E) or ¬∀R.C ∈ sub(E) and S occurs in T or R }.</formula><p>When R is clear from the context, we use sub(T ) instead of sub(T , R). Note that the set of relevant subconcepts is closely related to the Fischer-Ladner closure <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref> and extends the notion of subconcepts to take into account the fact that the tableau expansion rules may introduce some new concepts that do not occur syntactically in the input knowledge base.</p><p>Next, we define a tableau as a useful abstraction of a model to make the correctness proof of our algorithm more readable. Intuitively, a tableau contains all the relevant information from a model, with the possible exception of transitive roles and their super-roles. That is, in a tableau, we represent the fact that t is an R-successor of s as s, t ∈ E(R), but we do not impose that, if Trans(R) and s, t , t, u ∈ E(R), then t, u ∈ E(R). To compensate for these possibly missing edges, (P6) ensures that value restrictions on (super-roles of) transitive roles are "pushed" correctly over relevant edges. Compared with a tableau for SHIQ, the only difference is the addition of (P12) and (P13), which ensure that nominals are handled correctly. Please note that, like models, tableaux may be infinite and for some knowledge bases may even be necessarily infinite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 If (T , R</head><p>) is a SHOIQ knowledge base and R T ,R the set of roles occurring in T or R together with their inverses, a tableau T for (T , R) is defined to be a triple (S, L, E) such that S is a set of individuals, L : S → 2 cl(T ) maps each individual to a set of concepts that is a subset of cl(T ), E : R T ,R → 2 S×S maps each role in R T ,R to a set of pairs of individuals. For all s, t ∈ S, C, C 1 , C 2 ∈ cl(T ), and R, S ∈ R T ,R , the following holds.</p><formula xml:id="formula_8">(P0) If C ˙ D ∈ T , then nnf(¬C D) ∈ L(s). (P1) If C ∈ L(s), then ¬C / ∈ L(s). (P2) If C 1 C 2 ∈ L(s), then C 1 ∈ L(s) and C 2 ∈ L(s). (P3) If C 1 C 2 ∈ L(s), then C 1 ∈ L(s) or C 2 ∈ L(s). (P4) If ∀R.C ∈ L(s) and s, t ∈ E(R), then C ∈ L(t). (P5) If ∃R.C ∈ L(s), then there is some t ∈ S such that s, t ∈ E(R) and C ∈ L(t). (P6) If ∀S.C ∈ L(s) and s, t ∈ E(R) for some R * S with Trans(R), then ∀R.C ∈ L(t). (P7) If ( nS.C) ∈ L(s), then {t ∈ S | s, t ∈ E(S) and C ∈ L(t)} n. (P8) If ( nS.C) ∈ L(s), then {t ∈ S | s, t ∈ E(S) and C ∈ L(t)} n. (P9) If ( nS.C) ∈ L(s) and s, t ∈ E(S), then {C, ¬C} ∩ L(t) = ∅. (P10) If s, t ∈ E(R) and R * S, then s, t ∈ E(S). (P11) s, t ∈ E(R) iff t, s ∈ E(Inv(R)). (P12) If o ∈ L(s) ∩ L(t) for some o ∈ C o , then s = t. (P13) For each o ∈ C o occurring in T , there is some s ∈ S with o ∈ L(s).</formula><p>Please note that, in (P1), we use ¬C and not ¬C: this suffices for the following lemma and makes the proof of Lemma 7 easier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4 A SHOIQ knowledge base (T , R) is consistent iff there exists a tableau for (T , R).</head><p>Proof (sketch) This proof is analogous to the proof found in <ref type="bibr" target="#b25">[26]</ref>. As for SHIQ, we construct a model I from a tableau by taking S as its interpretation domain and adding the missing role-successorships for transitive roles. Then, by induction on the structure of formulas, we prove that, if C ∈ L(s), then s ∈ C I . Because of the restriction to simple roles in number restrictions, these additional rolessuccessorships do not lead to any violation of atmost number restrictions. (P0) ensures that I is indeed a model of T . (P6) ensures, as for SHIQ, that the additional role-successorships can be added without violating any value restrictions. (P12) and (P13) ensure that nominals are indeed interpreted as singletons.</p><p>For the converse, we can easily view any model as a tableau.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Tableau Algorithm for SHOIQ</head><p>From Lemma 4, an algorithm that constructs a (finite) representation of a (possibly infinite) tableau for a SHOIQ knowledge base can be used as a decision procedure for consistency of SHOIQ knowledge bases and thus to decide satisfiability and subsumption of SHOIQ-concepts w.r.t. knowledge bases. Such an algorithm will now be described in detail.</p><p>We first define and comment on the underlying data structure and corresponding operations. Next, we provide an example of the algorithm's behavior and explain the techniques we have chosen to design a terminating, sound, and complete algorithm. We then prove that our algorithm indeed is terminating, sound, and complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definition of the Algorithm</head><formula xml:id="formula_9">Definition 5 Let (T , R) be a SHOIQ knowledge base. A completion graph for (T , R) is a directed graph G = (V, E, L, . =) where each node x ∈ V is labeled with a set L(x) ⊆ cl(T ) ∪ C o ∪ {( mR.C) | ( nR.C) ∈ cl(T ) and m ≤ n}</formula><p>and each edge x, y ∈ E is labeled with a set of role names L( x, y ) Containing (possibly inverse) roles occurring in T or R. Additionally, we keep track of inequalities between nodes of the graph with a symmetric binary relation . = between the nodes of G.</p><p>In the following, we often use R ∈ L( x, y ) as an abbreviation for x, y ∈ E and R ∈ L( x, y ).</p><p>If x, y ∈ E, then y is called a successor of x, and x is called a predecessor of y. Ancestor is the transitive closure of predecessor, and descendant is the transitive closure of successor. A node y is called an R-successor of a node x if, for some R with</p><formula xml:id="formula_10">R * R, R ∈ L( x, y ); x is called an R-predecessor of y if y is an Inv(R)-successor of x. A node y is called a neighbor (R-neighbor) of a node x if y is either a successor (R-successor) or a predecessor (R-predecessor) of x.</formula><p>For a role S and a node x in G, we define the set of x's S-neighbors with C in their label, S G (x, C), as follows:</p><formula xml:id="formula_11">S G (x, C) := {y | y is an S-neighbor of x and C ∈ L(y)}.</formula><p>G is said to contain a clash if 1. For some concept name A ∈ C and node x of G, {A, ¬A} ⊆ L(x), or 2. For some role S and node x of G, ( nS.C) ∈ L(x) and there are n+1 S-neighbors y 0 , . . . , y n of x with C ∈ L(y i ) for each 0 ≤ i ≤ n and y i . = y j for each</p><formula xml:id="formula_12">0 ≤ i &lt; j ≤ n, or 3. For some o ∈ C o , there are nodes x . = y with o ∈ L(x) ∩ L(y).</formula><p>If o 1 , . . . , o are all the nominals occurring in T , then the tableau algorithm starts with the completion graph G = ({r 1 . . . , r }, ∅, L, ∅) with L(r i ) = o i for 1 ≤ i ≤ . G is then expanded by repeatedly applying the expansion rules given in Figs. <ref type="figure" target="#fig_2">1</ref> and<ref type="figure" target="#fig_0">2</ref>, stopping if a clash occurs.</p><p>Before describing the tableau algorithm in more detail, we define some terms and operations used in the (application of the) expansion rules and directly comment on them.  Comment: Like ABox individuals, nominal nodes can be arbitrarily interconnected. In contrast, blockable nodes are found only in treelike structures rooted in nominal nodes; a branch of such a tree may simply end, possibly with a blocked node (defined below) as a leaf, or have an edge leading to a nominal node. If a branch ends in a blocked node, we use standard unraveling to construct a tableau from the completion graph, and thus the resulting tableau will contain infinitely many copies of the nodes on the path from the blocking node to the blocked node. This is why there must be no nominal nodes on this path. In the NN-rule, we use new nominals to create new nominal nodes -intuitively, to fix the identity of certain constrained neighbors of nominal nodes. As we will show, it is possible to fix an upper bound on the number of nominal nodes that can be generated in a given completion graph; this procedure is crucial for termination of the construction, given that blocking cannot be applied to nominal nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Nominal Nodes and Blockable Nodes</head><p>Blocking A node x is label blocked if it has ancestors x , y, and y such that 1. x is a successor of x and y is a successor of y , 2. y, x and all nodes on the path from y to x are blockable, 3. L(x) = L(y) and L(x ) = L(y ), and 4. L( x , x ) = L( y , y ).</p><p>In this case, we say that y blocks x. A node is blocked if either it is label blocked or it is blockable and its predecessor is blocked.</p><p>Comment: Blocking is defined as for SHIQ, with the only difference being that, in the presence of nominals, we must take care that none of the nodes between a blocking and a blocked one is a nominal node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generating and Shrinking Rules and Safe Neighbors</head><p>The -, ∃and NN-rules are called generating rules, and the -, o -and the o-rule are called shrinking rules. An R-neighbor y of a node x is safe if <ref type="bibr" target="#b0">(1)</ref> x is blockable or if <ref type="bibr" target="#b1">(2)</ref> x is a nominal node and y is not blocked.</p><p>Comment: Generating rules add new nodes to the completion graph, whereas shrinking rules remove nodes -they merge all information concerning one node into another one (e.g., to satisfy atmost number restrictions) and then remove the former node. We need the safety of R-neighbors to ensure that enough R-neighbors are generated for nominal nodes.</p><p>Pruning When a node y is merged into a node x, we "prune" the completion graph by removing y and, recursively, all blockable successors of y. More precisely, pruning a node y (written Prune(y)) in G = (V, E, L, . =) yields a graph that is obtained from G as follows:</p><p>1. For all successors z of y, remove y, z from E and, if z is blockable, Prune(z); 2. Remove y from V.</p><p>Comment: The treelike structure of the blockable parts of G ensures that pruning removes only subtrees. If blockable parts of G did not have a treelike structure, for example, if they were cyclical, then pruning might remove y's predecessor, the node x into which y is being merged, and/or the node on whose label the rule responsible for the merge is operating.</p><p>Merging In some rules, we "merge" one node into another node. Intuitively, when we merge a node y into a node x, we add L(y) to L(x), "move" all the edges leading to y so that they lead to x and "move" all the edges leading from y to nominal nodes so that they lead from x to the same nominal nodes; we then remove y (and blockable subtrees below y) from the completion graph. More precisely, merging a node y into a node x (written Merge(y, x)) in G = (V, E, L, . =) yields a graph that is obtained from G as follows:</p><p>1. For all nodes z such that z, y ∈ E</p><formula xml:id="formula_13">a. If { x, z , z, x } ∩ E = ∅, then add z, x to E and set L( z, x ) = L( z, y ), b. If z, x ∈ E, then set L( z, x ) = L( z, x ) ∪ L( z, y ), c. If x, z ∈ E, then set L( x, z ) = L( x, z ) ∪ {Inv(S) | S ∈ L( z, y )}, and d. Remove z, y from E; 2. For all nominal nodes z such that y, z ∈ E a. If { x, z , z, x } ∩ E = ∅, then add x, z to E and set L( x, z ) = L( y, z ), b. If x, z ∈ E, then set L( x, z ) = L( x, z ) ∪ L( y, z ), c. If z, x ∈ E, then set L( z, x ) = L( z, x ) ∪ {Inv(S) | S ∈ L( y, z )}, and d. Remove y, z from E; 3. Set L(x) = L(x) ∪ L(y); 4. Add x .</formula><p>= z for all z such that y . = z; and 5. Prune(y).</p><p>If y was merged into x, we call x a direct heir of y, and we use being an heir of another node for the transitive closure of being a "direct heir."</p><p>Comment: Merging is the generalization of what is often done to satisfy an atmost number restriction for a node x in case that x has too many neighbors. However, since we might need to merge nominal nodes that are related in some arbitrary, nontreelike way, merging gets slightly trickier because we must take care of all incoming and outgoing edges. The usage of "heir" is quite intuitive because after y has been merged into x, x has "inherited" all of y's properties: its label, its inequalities, and its incoming and outgoing edges (except for any outgoing edges removed by Prune).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Level (of Nominal Nodes)</head><p>Recall that o 1 , . . . , o are all the nominals occurring in the input TBox T . We define the level of a node inductively as follows:</p><p>-Each (nominal) node x with an o i ∈ L(x), 1 ≤ i ≤ , is of level 0, and -A nominal node x is of level i if x is not of some level j &lt; i and x has a neighbor that is of level i -1.</p><p>Comment: If a node with a lower level is merged into another node, the level of the latter node may be reduced, but it can never be increased because Merge preserves all edges connecting nominal nodes. The completion graph initially contains only level 0 nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Strategy (of Rule Application)</head><p>The expansion rules are applied according to the following strategy.</p><p>1. The o-rule is applied with highest priority. 2. Next, the o -and the NN-rule are applied, and they are applied first to nominal nodes with lower levels (before they are applied to nodes with higher levels). 3. All other rules are applied with a lower priority.</p><p>Comment: This strategy is necessary for termination and, in particular, to ensure that the blockable parts of the completion graph remain tree shaped. In practice, more elaborate strategies may be used for efficiency reasons <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b37">38]</ref>.</p><p>We now describe the tableau expansion rules and discuss the intuition behind their definitions. Please note that the definition of successor and predecessor and the way in which the expansion rules introduce new nodes ensure that these relations reflect the origin of a node.</p><p>The rules in Fig. <ref type="figure" target="#fig_2">1</ref> are very similar to the expansion rules for SHIQ <ref type="bibr" target="#b25">[26]</ref>. The ˙ -rule reflects the semantics of GCIs and corresponds to (P0) of Definition 3 (of a SHOIQ tableau); the -, -, ∃-, and ∀-rules directly reflect the semantics of the relevant concept constructors and correspond to (P2)-(P5). A new feature of the ∃-rule with respect to its SHIQ counterpart is that only safe S-neighbors are considered. The reason is that a nominal node might have an unsafe S-neighbor (i.e., a blocked S-predecessor) that would not correspond to an individual in the tableau and so would not satisfy (P5)</p><p>The ∀ + -rule corresponds to (P6) of Definition 3 and ensures that the effects of universal restrictions are propagated as necessary in the presence of nonsimple roles.</p><p>The -, -, and ch-rules correspond to (P7)-(P9) of Definition 3. For a concept ( nS.C) ∈ L(x), if x does not already have n suitable S-neighbors (note that, as for the ∃-rule, only safe S-neighbors are considered), then the -rule generates them. To prevent the -rule from merging the new nodes, it sets y i . = y j for each 1 ≤ i &lt; j ≤ n. Conversely, if ( nS.C) ∈ L(x) and x has more than n S-neighbors that are labeled with C, then the -rule chooses two of them that are not in . = and merges them. Part (2) of the definition of a clash takes care of the situation where the . = relation makes it impossible to merge any two S-neighbors of x, while the ch-rule ensures that all S-neighbors of x are labeled with either C or ¬C.</p><p>Note that the generating rules are not applicable to blocked nodes, thereby preventing the algorithm from attempting to generate an infinite completion graph, for example, when { ˙ S } ⊆ T . The other rules are applicable to all nodes, even blocked nodes. This strategy is necessary because, in the presence of inverse roles, applying expansion rules to blocked nodes could result in information being added to the labels of unblocked nodes, possibly resulting in a clash or in previously blocked nodes becoming unblocked <ref type="bibr" target="#b25">[26]</ref>.</p><p>The rules in Fig. <ref type="figure" target="#fig_0">2</ref> deal with nominals. The o-rule corresponds to (P12) of Definition 3 and ensures that any two nodes having the same nominal in their label are immediately merged. The combination of the NN-rule and the o -rule ensure that the blockable parts of the completion graph are always tree shaped (which is necessary in order to ensure that pruning can only remove blockable subtrees), and prevent the repeated generation and merging of new nominal nodes. The blockable part of the graph could become non-tree shaped if a blockable predecessor of a nominal node were merged with another blockable neighbor. In order to prevent this situation arising, if a nominal node x has a blockable S-predecessor y such that C ∈ L(y) and ( nS.C) ∈ L(x), then the NN-rule guesses the exact number m n of S-neighbors of x with C in their label. It then generates m new nominal S-neighbors z 1 , . . . , z m of x, with L(z i ) = {C, o i }, where o i ∈ C o is a new nominal, that is, a nominal not already occurring in G. Finally, in order to prevent these new nodes from being merged, it additionally sets z i . = z j for each 1 ≤ i &lt; j ≤ n. The o -rule ensures that each blockable S-neighbor of x with C in its label is merged with one of the new nominal S-neighbors of x. The o -rule is applied with a higher priority than the -rule, ensuring that blockable neighbors of x cannot be merged with each other before being merged into the new nominal nodes. An extended example of the action of these rules, and the need for them, will be presented in Section 4.2.</p><p>We are now ready to finish the description of the tableau algorithm. A completion graph is complete if it contains a clash or when none of the rules is applicable. If the expansion rules can be applied to G in such a way that they yield a complete, clash-free completion graph, then the algorithm returns "(T , R) is consistent," and "(T , R) is inconsistent" otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Example Application of the Algorithm</head><p>We consider three examples, starting with an easy one. First, consider the TBox</p><formula xml:id="formula_14">T = {A ˙ ∃R(A ∃R.A), A ˙ o o ˙ A}.</formula><p>Our tableau algorithm starts with a completion graph consisting of a single node, r, with L(r) = {o}. After three applications of the ˙ -rule, we obtain a completion graph with</p><formula xml:id="formula_15">L(r) = {o, ¬A ∃R.(A ∃R.A), ¬A o, ¬o A}.</formula><p>The only way to apply the -rule without causing clashes adds A and ∃R(A ∃R.A) to L(r). Next, we can choose to apply the ∃-rule, the -rule, and the ∃-rule again, thereby yielding two new nodes x 0 and x 1 , where x 0 is an R-successor of r and x 1 is an R-successor of x 0 , with L(x 0 ) = {A ∃R.A, A, ∃R.A}, L(x 1 ) = {A}.</p><p>To these nodes, we can apply the ˙ -, -, and the -rule, and we are free to choose where we apply them first. If we apply these rules to x 0 first, and in such a way as to avoid clashes, the result is that</p><formula xml:id="formula_16">L(x 0 ) ⊇ {A ∃R.A, A, ∃R.A, o, ∃R.(A ∃R.A)}.</formula><p>Following our rule application strategy, we now need to apply the o-rule. This rule merges x 0 into r, makes r an R-neighbor of itself, and removes x 1 through pruning. As a result, we have a clash-free and complete completion graph, and thus our algorithm returns "satisfiable." Indeed, it corresponds to a model I with a single element r, R I = {(r, r)}, and A I = o I = {r}. Please note that, for termination, it was crucial that we removed x 1 : otherwise, we could have generated an R-successor of x 1 before adding o to L(x 1 ) and merging x 1 with r, and we could have repeated this "generateand-merge" action without ever terminating. Alternatively, we could have chosen to apply the ˙ -rule to x i only w.r.t. A ˙ ∃R.(A ∃R.A), along with applications of the ∃-, -, and -rules such that clashes are avoided. This approach will lead to the generation of one or more sequences of R-successor nodes that will eventually give rise to blocking conditions. At this point, (clash avoiding) applications of the ˙ -and -rules will lead to the addition of o to the label of some node, followed by an application of the o-rule. Pruning will ensure that this does not lead to any further applications of the ∃-rule, and further (clash avoiding) applications of the ˙ -, -and o-rules will eventually cause all the nodes to collapse into a clash-free and complete completion graph consisting, as before, of a single node that is an R-neighbor of itself.</p><p>We note that the eager application of the o-rule is necessary for termination in this latter case because adding o to a node label might prevent blocking (there can be no nominal nodes on the path between blocking and blocked nodes) and thus would allow us to continue with applications of the ∃-rule.</p><p>Our second example is motivated by the observation that the above mentioned "generate-and-merge" problem is very similar to the well-known yo-yo effect<ref type="foot" target="#foot_7">8</ref> but that it was solved in a different manner: we use pruning to prevent "yo-yo"-ing, whereas, in other tableau algorithms such as the one described in <ref type="bibr" target="#b3">[4]</ref>, a strategy of rule applications sufficed. Since pruning means discarding work that may subsequently need to be repeated, we present the next example to demonstrate that it is indeed necessary.</p><p>Consider the following TBox, which is similar to the previous one, but with the difference that, because of the universal value restriction, we do not find the nominal o in a node's label until after we have generated an R-successor, by which time it is already too late to prevent a repetition of the generate-and-merge cycle.</p><formula xml:id="formula_17">T = {A ˙ ∃R.(A ∃R.(A ∀R -.o)), o ˙ A}.</formula><p>Similarly to the first example, we start with a single node r with L(r) = {o}, and, after the application of a few rules, we have expanded our completion graph to contain a chain r, x 0 , and x 1 of R-successors with</p><formula xml:id="formula_18">L(r) ⊇ {o, A, ∃R.(A ∃R.(A ∀R -.o))}, L(x 0 ) ⊇ {A, ∃R.(A ∀R -.o)}, L(x 1 ) ⊇ {A, ∀R -.o}.</formula><p>Application of the ∀-rule to x 1 adds o to L(x 0 ) and thus leads immediately to the o-rule merging x 0 into r and removing x 1 . Please note that not removing x 1 would potentially lead to nontermination: we could apply the ˙ -and the -rule to x 1 and thus find ∃R.(A ∀R -.o) in L(x 1 ). Hence we would apply the ∃-rule again, create an R-successor x 2 of x 1 with (A ∀R -.o) ∈ L(x 2 ), and could continue this generation and merging forever.</p><p>Our third example is presented to demonstrate that the NN-rule is indeed needed. Assume we want to decide the consistency of the following TBox.</p><formula xml:id="formula_19">T = {o 1 ˙ ( 2R - 1 .A) ∀R - 1 .∃S 1 .∃S - 2 .(A ∃R 2 .o 2 ) ∃R - 1 A, o 2 ˙ ( 2R - 2 .A) ∀R - 2 .∃S 2 .∃S - 1 .(A ∃R 1 .o 1 )</formula><p>} We start the algorithm with two nodes, say r 1 and r 2 , with o i ∈ L(r i ). After a few applications of the ˙ -and the -rule, we find</p><formula xml:id="formula_20">L(r 1 ) ⊇ {o 1 , ( 2R - 1 .A), ∀R - 1 .∃S 1 .∃S - 2 .(A ∃R 2 .o 2 ), ∃R - 1 A, }, L(r 2 ) ⊇ {o 2 , ( 2R - 2 .A), ∀R - 2 .∃S 2 .∃S - 1 .(A ∃R 1 .o 1 )}.</formula><p>Next, we apply the ∃-rule to ∃R - 1 .A ∈ L(r 1 ). This creates an R - 1 -successor x 0 of r 1 , and we can thus apply the ∀-rule to ∀R -</p><formula xml:id="formula_21">1 .∃S 1 .∃S - 2 .(A ∃R 2 .o 2 ) ∈ L(r 1</formula><p>). Next, we can apply the ∃-rule three more times and obtain a chain of the following form: r 1 has an R - 1 -successor x 0 , which has an S 1 -successor x 1 , which has an S - 2 -successor x 2 , which has an R 2 -successor x 3 with o 2 ∈ L(x 3 ). Thus we need to apply the o-rule and merge x 3 into r 2 , which becomes an R 2 -successor of x 2 . As a consequence, the NN-rule becomes applicable and has highest priority. We guess m = 2 and create two new</p><formula xml:id="formula_22">R - 2 -successors n 1 , n 2 of r 2 with L(n i ) = { ôi } and n 1 . = n 2 . Now r 2 has three R -</formula><p>2 -neighbors, and we apply the o -rule to r 2 and choose to merge x 2 into n 1 . Figure <ref type="figure" target="#fig_7">3</ref> shows the completion graph in a slightly later stage, with arrows that indicate successorship rather than whether a role name or an inverse role labels an edge, and where an edge is dotted to indicate that it has been removed during merging.</p><p>Since</p><formula xml:id="formula_23">n 1 is an R - 2 -neighbor of r 2 , the ∀-rule adds ∃S 2 .∃S - 1 .∃R 1 .o 1 to L(n 1 )</formula><p>. Three more applications of the ∃-rule yield a chain similar to the first one: r 2 has an R - 2 -successor n 1 , which has an S 2 -successor x 1 , which has an S - 1 -successor x 0 , which has an R 1 -successor y with o 1 ∈ L(y). Next, y is merged with r 1 , and thus r 1 is an R 1 -successor of x 0 . Again, as a consequence, the NN-rule becomes applicable, and we guess again m = 2 and create two new</p><formula xml:id="formula_24">R - 1 -successors m 1 , m 2 of r 1 with L(m i ) = { õi } and m 1 .</formula><p>= m 2 ; the resulting completion graph is shown in Fig. <ref type="figure" target="#fig_7">3</ref>. We apply the Fig. <ref type="figure" target="#fig_7">3</ref> Completion graph of the third example</p><formula xml:id="formula_25">m 2 x 1 x 1 r 1 r 2 n 1 n 2 x 0 x 0 x 2 m 1</formula><p>o -rule to r 1 and choose to merge both x 0 and x 0 into m 1 . <ref type="foot" target="#foot_8">9</ref> Please note that the orule makes us indeed merge the blockable nodes x 0 and x 0 into nominal nodes.</p><p>After this, we can apply the ∀-rule to add</p><formula xml:id="formula_26">∃S 1 .∃S - 2 .(A ∃R 2 .o 2 ) to L(m 2 ) and ∃S 2 .∃S - 1 .(A ∃R 1 .o 1 ) to L(n 2</formula><p>). This procedure yields two more chains between r 1 and r 2 , but then the tableau algorithm stops with a complete and clash-free completion graph. This graph is shown in Fig. <ref type="figure">4</ref>, where the successors of x 3 and x 4 are not shown explicitly, and we assume that the o -rule has merged x 3 's successor into m 2 and x 4 's successor into n 1 .</p><p>We point out three important properties of our algorithm that were crucial for correctness and termination in this last example. First, as we have illustrated in the introduction, we need to take care of the relations between the finite, arbitrarily complex relational structure around instances of the "original" nominals o i and the treelike structure induced by blockable nodes. The reason is that a blocking situation represents an infinite tree and that we need to take care that atmost restrictions on nominal nodes are satisfied even when considering this infinite tree explicitly. The details will become clearer in the proof of Lemma 7 when we construct a tableau from a complete and clash-free completion graph. We have chosen the NN-rule as a means to take care of these relations.</p><p>Second, we can apply the NN-rule only to a nominal node r and some ( nR.C) ∈ L(r) if there is a blockable node x that has r as its R --successor. Hence we could apply it to r 1 only after we merged the blockable node y into it. Also, the resulting new nominal nodes will never be pruned since pruning removes only blockable nodes, and they will never be merged because of the use of . =. Third, the newly created nominal nodes n and m j made us merge existing and newly created R - i -neighbors of r i immediately into n and m j . The explicit inequalities between these new nominal nodes n , m j and the o -rule are crucial to prevent another kind of yo-yo effect: without them, when applying the -rule to ( 2R - i .A) ∈ L(r i ), we could have merged n 2 into n 1 and m 2 into m 1 and -even with some modifications to our algorithm, for example, to make the blockable sibling node of n and m j a nominal node -the ∀-rule would add ∃S i .∃S - j .(A ∃R j .o j ) to each R i -neighbor of r i , thereby continuously causing new paths to be built from r i to r j , which we could have merged in a similar way, thus causing nontermination. The algorithm constructs a graph that consists of a set of arbitrarily interconnected nominal nodes and "trees" of blockable nodes with each such tree rooted in a nominal node, and where branches of these trees might end in an edge leading to a nominal node.</p><p>Termination is a consequence of the usual SHIQ conditions with respect to the blockable tree parts of the graph, plus the fact that there is a bound on the number of new nominal nodes that can be added to G by the NN-rule. More precisely, termination is due to the following five properties, the first of which establishes that the blockable parts of the graph are indeed tree-shaped, the second, third, and fourth of which are very similar to those used in the termination proof for SHIQ given in <ref type="bibr" target="#b25">[26]</ref>, and the fifth of which establishes an upper bound on the number of new nominal nodes generated by the NN-rule.</p><p>1. The structure among blockable nodes is tree-shaped. More precisely, no blockable node can have more than one predecessor node.</p><p>Let us assume that at some stage during rule application the structure among blockable nodes is indeed tree-shaped but that, after applying one of the rules, there is some blockable node x with predecessors y 1 and y 2 such that y 1 = y 2 . This can happen only as a result of an application of a shrinking rule: the generating rules always generate new "leaf" nodes, and the remaining rules do not change the structure of the graph. In fact, it is easy to see that this can happen only if y 1 and y 2 each have blockable successors, one of which is x and one of which is, say, x , and an application of the -rule causes x to be merged into x; this in turn implies the existence of some node z and role R such that both x and x are R-neighbors of z, ( nR.C) ∈ L(z), and C ∈ L(x) ∩ L(x ). Moreover, -z must be a nominal node: otherwise the structure among blockable nodes is already non-tree-shaped; and -z must be a successor of at least one of x or x : otherwise, either y 1 = y 2 = z or the structure among blockable nodes is already non-tree-shaped since x or x has two different predecessors.</p><p>As a consequence, there must be some m n such that ( mR.C) ∈ L(z) and z has m nominal R-neighbors z 1 , . . . , z m with C ∈ L(z i ) and z i . = z j for all 1 ≤ i &lt; j ≤ m: otherwise the NN-rule would be applicable to z and, according to our strategy would be applied before the -rule could merge x and x . Next, the o would be applicable with highest priority and would merge both x and x in one or the other of z 1 , . . . , z m . Thus, the o -rule together with the high priority of the NN-rule and the o -rule ensure that the tree shape among blockable is preserved. 2. All but the shrinking rules strictly extend the completion graph by adding new nodes (and edges) or extending node labels, while neither removing nodes (or edges) nor removing elements from node labels. This is an obvious consequence of the definition of the rules. 3. New nodes are added only by the generating rules, and each of these rules can be triggered at most once for a given concept in the label of a given node x. This is obvious if no shrinking rule is applied. If such a rule is applied, then, intuitively, this observation is due to the fact that, if an S-neighbor y of x is merged into a node z, then L(y) is added to L(z), z "inherits" all of the inequalities from y, and either z is an S-neighbor of x (if x is a nominal node or if y is a successor of x), or x is removed from the graph by an application of Prune(x) (if x is a blockable node and x is a successor of y). Since pruning removes only blockable nodes, and since these form a tree structure (as we have shown in property 1 above), we remove neither x nor any of its predecessors. More precisely, we distinguish the following three cases.</p><p>-For the ∃-rule, if it is applied to a concept ∃S.C ∈ L(x), then a new node y of x is created with L( x, y ) = S and L(y) = C. Subsequently, either x is removed from the graph, or x has an S-neighbor y that is an heir of y, that is, with C ∈ L(y ). Hence the ∃-rule is no longer applicable to ∃S.C ∈ L(x). -For the -rule, if it is applied to a concept ( nS.C) ∈ L(x), then n new nodes y 1 , . . . , y n are created with L( x, y i ) = {S}, L(y i ) = {C}, and y i . = y j for 1 ≤ i &lt; j ≤ n. Subsequently, either x is removed from the graph, or x has n S-neighbors y 1 , . . . , y n that are heirs of the y i , that is, C ∈ L(y i ) and y i . = y j for 1 ≤ i &lt; j ≤ n. Hence the -rule is no longer applicable to ( nS.C) ∈ L(x).</p><p>-For the NN-rule, if it is applied to a concept ( nS.C) ∈ L(x), then for some m with 1 m n, m new nominal nodes y 1 , . . . , y m are created with L( x, y i ) = {S}, L(y i ) = {C}, y i . = y j for 1 ≤ i &lt; j ≤ m, and ( mS.C) ∈ L(x). Subsequently, either x is removed from the graph, or ( mS.C) remains in L(x) and x has m S-neighbors y 1 , . . . , y m that are heirs of the y i , that is, C ∈ L(y i ) and y i . = y j for 1 ≤ i &lt; j ≤ m. Hence the NN-rule is no longer applicable to ( nS.C) ∈ L(x).</p><p>As for the SHIQ case, a generating rule being applied to a concept in the label of a node x can generate at most n blockable successors. As there are at most m concepts in L(x), a node can have at most mn blockable successors. 4. As for SHIQ <ref type="bibr" target="#b25">[26]</ref>, the blocking condition ensures that the length of a path consisting entirely of blockable nodes is bounded by λ. This is due to the fact that, for x a blockable node, L(x) ⊆ cl(T ) and thus does not contain any nominals, neither those contained in the input nor those added later by the NN-rule. 5. The number of nominal nodes is bounded by O( (mn) λ ).</p><p>First, we observe that new nominal nodes are generated only by the NN-rule and that the NN-rule is applicable only after a nominal has been added to the label of a blockable node x in a branch of one of the blockable "trees" rooted in a nominal node; otherwise, it is not possible that a blockable node has a nominal node as a successor. The only nominals that can be added to the label of a blockable node are those that occur in cl(T ), namely, o 1 , . . . , o . Let us consider the blockable node x to whose label one of the o i was added: by definition, x is a level 0 node, and the o-rule -which is applied with top priority -will ensure that x is immediately merged with an existing level 0 node r i having the same nominal in its label.</p><p>As a consequence of this merging of x with r i , two things might happen: (a) the NN-rule might become applicable to r i , and (b) the predecessor x of x might be merged into a neighbor of r i by the o -rule -please note that, due to the pruning part of merging, this cannot happen to a successor of x and, by definition of the o -rule, x is merged into a nominal neighbor of r i , say n 1 . If this argument is repeated, it is possible that all ancestors of x are merged into nominal nodes. Moreover, as the maximum length of a sequence of blockable nodes is λ, blockable ancestors of x can be merged only into nominal nodes of level below λ. This together with the precondition of the NN-rule implies that we can apply the NN-rule only to nominal nodes of level below λ. Concerning (a), as we have seen above, the strategy of rule application implies that the NN-rule is applied to r i before the -or the o -rule, thereby ensuring that any predecessor x of x is indeed merged into a nominal node. Moreover, when the NN-rule has been applied to a concept ( nR.C) in the label of a node y, the way in which edges are "inherited" in the definition of merging ensures that it can never be applied again to ( nR.C) in the label of y or an heir of y. (mn) i = m 1mn λ 1mn on the number of times that the NN-rule can be applied and an upper bound of 0&lt;i λ (mn) i = 1mn λ+1 1mn on the number of nominal nodes that can be generated.</p><p>To sum up, there is a bound O( (mn) λ ) on the number of nominal nodes that can be generated, and this, along with the tree-shaped structure of the blockable parts of G, implies a bound on the number of blockable nodes that can be generated. Hence any sequence of rule applications must eventually result in G being complete.</p><p>Lemma 7 If, when started with a SHOIQ knowledge base (T , R), the expansion rules can be applied in such a way as to yield a complete and clash-free completion graph, then there exists a tableau for (T , R).</p><formula xml:id="formula_27">Proof Let G = (V, E, L, .</formula><p>=) be a complete and clash-free completion graph yielded by the expansion rules when started with (T , R). We can obtain a tableau T = (S, L , E) for (T , R) from G as described below.</p><p>First, let us define paths. For a label blocked node x ∈ V, let b(x) denote a node that blocks x. A path is a sequence of pairs of blockable nodes of G of the form p = (x 0 , x 0 ), . . . , (x n , x n ) . For such a path, we define Tail( p) := x n and Tail ( p) := x n . With p|(x n+1 , x n+1 ) we denote the path (x 0 , x 0 ), . . . , (x n , x n ), (x n+1 , x n+1 ) . The set Paths(G) is defined inductively as follows:</p><p>(a) For each blockable node x of G that is a successor of a nominal node, (x, x) ∈ Paths(G), and (b) For a path p ∈ Paths(G) and a blockable successor y of Tail( p):</p><p>-If y is not blocked, then p|(y, y) ∈ Paths(G), and -If y is blocked, then p|(b (y), y) ∈ Paths(G).</p><p>Please note that, due to the construction of Paths, all nodes occurring in a path are blockable and, for p ∈ Paths(G) with p = p |(x, x ) , x is not blocked, x is blocked iff x = x , and the predecessor of x in G is not blocked. Furthermore, the blocking condition implies L(x) = L(x ).</p><p>It is easy to see that, when G does not contain any blocks, the elements of Paths(G) are in direct correspondence with the blockable nodes in V: for each blockable node x ∈ V there is exactly one path p ∈ Paths(G) such that Tail( p) = Tail ( p) = x. When G contains one or more blocks, it constitutes a finite representation of an infinite tableau: we can think of each blocked node x as being identified with the node b(x) that is blocking x, and Paths(G) as being obtained by repeatedly "unravelling" the resulting cycles. This is made possible by the fact that both x and b(x) must occur in the same blockable tree-shaped part of the graph.</p><p>The reason for using pairs of nodes in a path is that there might be a node z with two successors x and y, both of which are blocked by the same node, i.e., b(x) = b(y).</p><p>If paths mentioned only the blocking node, then the paths corresponding to the two successors would be the same, and (P7) of Definition 3 might not be satisfied in the resulting tableau (e.g., if x and y are both S-successors of z, with C ∈ L(x), C ∈ L(y) and ( 2S.C) ∈ L(z)).</p><p>Next, we use Nom(G) for the set of nominal nodes in G and define a tableau T = (S, L , E) from G as follows.</p><formula xml:id="formula_28">S = Nom(G) ∪ Paths(G) L ( p) = L(Tail( p)) if p ∈ Paths(G) L( p) if p ∈ Nom(G) E(R) = { p, q ∈ Paths(G) × Paths(G) | q = p|(x, x ) and x is an R-successor of Tail( p) or p = q|(x, x ) and x is an Inv(R)-successor of Tail(q)}∪ { p, q ∈ Paths(G) × Nom(G) | x is an R-neighbor of Tail( p)}∪ { x, p ∈ Nom(G) × Paths(G) | Tail( p) is an R-neighbor of x}∪ { x, y ∈ Nom(G) × Nom(G) | y is an R-neighbor of x}</formula><p>We already commented above on S, and L is straightforward. Unfortunately, E is slightly cumbersome because we must distinguish between blockable and nominal nodes.</p><p>Claim: T is a tableau for (T , R).</p><p>It suffices to prove that T satisfies each (Pi) of Definition 3.</p><p>1. (P0) to (P3) are trivially implied by the definition of L and the fact that G is a complete completion graph (CCG). 2. For (P4), consider a tuple s, t ∈ E(R) with ∀R.C ∈ L (s). We distinguish four different cases:  In all four cases, by definition of L , we have C ∈ L (t). -If x is a nominal node, then s, x ∈ E(R) and C ∈ L (x).</p><p>-If x is a blockable node, then x is a safe R-neighbor of s and thus not blocked. Hence there is a path p ∈ Paths(G) with Tail( p) = x, s, p ∈ E(R) and C ∈ L ( p).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">(P6</head><p>) is analogous to (P4). 5. For (P7), consider some s ∈ S with ( nR.C) ∈ L (s).</p><p>a. If s ∈ Nom(G), then G being a CCG implies the existence of n safe Rneighbors y 1 , . . . , y n of s, with y j = y j for each i = j, and C ∈ L(y i ) for each 1 ≤ i ≤ n. By construction, each y i corresponds to a t i ∈ S with t i = t j , for each i = j:</p><p>-If y i is blockable, then it cannot be blocked since it is a safe R-neighbor of s. Hence there is a path p|(y i , y i ) ∈ S and s p|(y i , y i ) ∈ E(R).</p><p>-If y i is a nominal node, then s, y i ∈ E(R). b. If s ∈ Paths(G), then G being a CCG implies the existence of n R-neighbors y 1 , . . . , y n of Tail(s), with y j = y j for each i = j, and C ∈ L(y i ) for each 1 ≤ i ≤ n. By construction, each y i corresponds to a t i ∈ S, with t i = t j for each i = j:</p><p>-If y i is blockable, then it can be blocked if it is a successor of Tail(s). In this case, the "pair" construction in our definition of paths ensures that, even if b(y i ) = b(y j ), for some i = j, we still have p|(b(y i ),</p><formula xml:id="formula_29">y i ) = p|(b(y j ), b j ) . -If y i is a nominal node, then s, y i ∈ E(R).</formula><p>Hence all t i are different and, by construction, C ∈ L (t i ), for each 1 ≤ i ≤ n.</p><p>6. For (P8), consider some s ∈ S with ( nR.C) ∈ L (s). Clash-freeness implies the existence of atmost n R-neighbors y i of s with C ∈ L(y i ). By construction, each t ∈ S with s, t ∈ E(R) corresponds to an R-neighbor y i of s or Tail(s), and none of these R-neighbors gives rise to more than one such y i . Moreover, since L (t) = L(y i ), (P8) is satisfied. 7. (P9) is satisfied as a result of to G being a CCG and the fact that each t ∈ S with s, t ∈ E(R) corresponds to an R-neighbor of s (in case s ∈ Nom(G)) or of Tail(s) (in case s ∈ Paths(G)).</p><p>8. (P10) and (P11) are immediate consequences of the definition of "R-successor" and "R-neighbor." 9. (P12) is due to G being a CCG and the fact that nominal nodes are not "unravelled." 10. (P13) is due to the way in which G was initialized, the fact that nominal nodes are never removed through pruning, and the fact that the labels of merged nodes are merged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 8</head><p>If there exists a tableau of a SHOIQ knowledge base (T , R), then, when started with (T , R), the expansion rules can be applied in such a way as to yield a complete and clash-free completion graph.</p><p>Proof Given a tableau T = (S, L , E) for (T , R), we can apply the nondeterministic rules, that is, the -, choose-, -, o -, and NN-rule, in such a way that we obtain a complete and clash-free completion graph: inductively with the generation of new nodes, we define a mapping π from nodes in the completion graph to individuals in S in such a way that the following four properties hold throughout the run of the tableau algorithm: We first explain why a completion graph satisfying (C1)-(C4) is clash-free: because of (C1), (P1), and the fact that node labels outside of cl(T , R) are either new nominals or atmost number restrictions, the completion graph does not contain a clash of the first kind; as a consequence of (C1)-(C3) and (P8) or as a consequence of (C2)-(C4), the completion graph does not contain a clash of the second kind; and as a consequence of (C1), (C3), and (P12), the completion graph does not contain a clash of the third kind.</p><p>Next, we show by induction on the number of rule applications how the expansion rules can be applied in such a way that (C1)-(C4) are preserved. We initialize π as follows: the initial completion graph contains, for each nominal o i in T , a node r i with L(r i ) = {o i }, and thus we set π(r i ) = s i for s i ∈ S with o i ∈ L (s i ). (P13) ensures that such s i do indeed exist. Obviously, π satisfies (C1)-(C4).</p><p>For the induction step, it is not hard to see that (C4) may be violated only through an application of the NN-rule. By definition of the semantics, the application of the -and the ˙ -rule preserve (C1), and all other conditions are preserved trivially. By definition of the semantics, we can choose to apply the -rule such that (C1) is preserved, and again all other conditions are preserved trivially. For the ∃and the -rule, we need to extend π to the newly introduced nodes -by definition of the semantics, this is possible in such a way that (C1)-(C3) are preserved, and the proof is analogous to the one in <ref type="bibr" target="#b25">[26]</ref>. Similarly, the fact that we can apply all remaining rules from Fig. <ref type="figure" target="#fig_2">1</ref> without violating (C1)-(C3) can be found in <ref type="bibr" target="#b25">[26]</ref>. Thus we concentrate on the new rules in Fig. <ref type="figure" target="#fig_0">2</ref>.</p><p>If the o-rule is applied to x and y with o ∈ L(x) ∩ L(y), the fact that the NNrule is the only one introducing new nominals and that it always introduces only new ones implies that o ∈ cl(T , R). Hence (C1) implies that o ∈ L (π(x)) ∩ L (π(y)), and thus (P12) implies π(x) = π(y). As a consequence, applying the o-rule preserves (C1)-(C3).</p><p>If the NN-rule is applied to x with ( nS.C) ∈ L(x), let m = S T (π(x), C), and note that the preconditions of the NN-rule imply that it has not been applied before to ( nS.C) ∈ L(x). As a consequence, ( nS.C) ∈ cl(T , R), and thus (C1) and (P8) imply that m ≤ n. Hence we can apply it with m := m and extend π in the obvious way to map each newly introduced node to a different member of S T (π(x), C) without violating (C1)-(C4).</p><p>If the o -rule is applied to ( nS.C) ∈ L(x), y, and z i as in the precondition of the o -rule, then (C1) together with (P8) or (C4) imply that n ≤ S T (π(x), C). Hence (C2) and the inequalities z i . = z j for all i &lt; j ≤ n together with (C3) imply π(y) = π(z i ) for some 1 ≤ i ≤ m, and thus we can apply the o -rule in such a way that it preserves (C1)-(C4).</p><p>Summing up, we can use T to steer the application of the nondeterministic rules to preserve (C1)-(C4), thereby avoiding clashes. From Lemma 6, this leads to a complete and clash-free completion graph.</p><p>As an immediate consequence of Lemmas 4, 6, 7, and 8, the tableau algorithm always terminates, and answers with "(T , R) is consistent" iff (T , R) is consistent. As mentioned in Section 2, satisfiability and (non)subsumption can be reduced to knowledge base consistency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 9</head><p>The tableau algorithm presented in Definition 5 is a decision procedure for consistency of SHOIQ knowledge bases and for satisfiability and subsumption of SHOIQ concepts w.r.t. knowledge bases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Outlook</head><p>In this paper, we have presented what is, to the best of our knowledge, the first goaldirected decision procedure for SHOIQ (and so SHOIN ). Given that SHOIQ is NExpTime-complete <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b35">36]</ref>, it is clear that, in the worst case, any decision procedure will behave very badly, that is, not terminate in practice. Our algorithm is far from being optimal in the worst case: it creates, in a nondeterministic way, a structure of size double exponential in the size of the input. However, it is designed to behave well in many typically encountered cases and to exhibit a "pay as you go" behavior: if an input knowledge base and concept(s) do not involve any one of inverse roles, number restrictions, or nominals, then the NN-rule will not be applied, and the corresponding nondeterministic guessing is avoided. This is true even for inputs that do involve all of these three constructors, but only in a "harmless" way. Hence, our SHOIQ algorithm can be implemented to perform just as well on SHIQ knowledge bases as state-of-the-art DL reasoners for SHIQ <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b21">22]</ref>; it has, in fact, already been implemented in the well-known Fact++ and Pellet systems and has been shown to work well in practice <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b38">39]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 .</head><label>2</label><figDesc>Since set inclusion is transitive and R I ⊆ S I implies Inv(R) I ⊆ Inv(S) I , for a role hierarchy R, we introduce * R as the transitive-reflexive closure of on R ∪ {Inv(R) Inv(S) | R S ∈ R}. We use R ≡ R S as an abbreviation for R * R S and S * R R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>For C and D (possibly complex) concepts, C ˙ D is called a general concept inclusion (GCI), and a finite set of GCIs is called a TBox. An interpretation I satisfies a GCI C ˙ D if C I ⊆ D I , and I satisfies a TBox I if I satisfies each GCI in T ; such an interpretation is called a model of T . A concept C is called satisfiable with respect to a role hierarchy R and a TBox T if there is a model I of R and T with C I = ∅. Such an interpretation is called a model of C w.r.t. R and T . A pair (T , R) is called a SHOIQ knowledge base and is said to be consistent if there exists a model of T and R. A concept D subsumes a concept C w.r.t. (T , R) (written C R,T D) if C I ⊆ D I holds in every model I of (T , R). Two concepts C, D are equivalent w.r.t. (T , R), (written C ≡ R,T D) if they are mutually subsuming w.r.t. (T , R). For an interpretation I, an individual x ∈ I is called an instance of a concept C iff x ∈ C I . Note that the above definition of a SHOIQ knowledge base does not include an ABox, that is, a set of assertions of the form a : C or (a, b ) : R, for a and b nominals, C a concept and R a role, where an interpretation I satisfies a : C if a I ∈ C I , and satisfies (a, b ) : R if a I , b I ∈ R I . The reason is that, in the presence of nominals, such assertions can be transformed into semantically equivalent TBox axioms: a : C is equivalent to a ˙ C, and (a, b ) : R is equivalent to a ˙ ∃R.b . An ABox A is consistent with respect to a knowledge base (T , R) (i.e., there exists a model of A, T and R) if and only</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1</head><label>1</label><figDesc>Fig.1The tableau expansion rules for SHIQ</figDesc><graphic coords="10,46.67,54.22,345.87,409.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2</head><label>2</label><figDesc>Fig.2The three new expansion rules for SHOIQ</figDesc><graphic coords="11,46.67,54.20,345.87,248.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 2 x 4 . 3</head><label>4243</label><figDesc>Fig. 4 Final completion graph of the third example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>a. if s, t ∈ Paths(G) × Paths(G), then ∀R.C ∈ L(Tail(s)) and either -Tail (t) is an R-successor of Tail(s), and G being a CCG implies C ∈ L(Tail (t)), and either Tail (t) = Tail(t) or the blocking condition implies L(Tail (t)) = L(Tail(t)); or -Tail (s) is an Inv(R)-successor of Tail(t), and hence either Tail (t) = Tail(t) or the blocking condition implies ∀R.C ∈ L(Tail (s)), and thus G being a CCG implies that C ∈ L(Tail(t)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>b.</head><label></label><figDesc>If s, t ∈ Nom(G) × Nom(G), then ∀R.C ∈ L(s) and t is an R-neighbor of s. Hence G being a CCG implies C ∈ L(t). c. If s, t ∈ Nom(G) × Paths(G), then ∀R.C ∈ L(s) and Tail(t) is an Rneighbor of s. Hence G being a CCG implies C ∈ L(Tail(t)). d. If s, t ∈ Paths(G) × Nom(G), then ∀R.C ∈ L(Tail(s)) and t is an Rneighbor of Tail(s). Hence nonapplicability of the ∀-rule implies C ∈ L(t).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>3 .</head><label>3</label><figDesc>For (P5), consider some s ∈ S with ∃R.C ∈ L (s). a. If s ∈ Paths(G), then ∃R.C ∈ L(Tail(s)), Tail(s) is not blocked, and G being a CCG implies the existence of an R-neighbor y of Tail(s) with C ∈ L(y). -If y is a nominal node, then y ∈ S, C ∈ L (y), and s, y ∈ E(R). -If y is blockable and a successor of Tail(s), then s|( ỹ, y) ∈ S, for ỹ = y or ỹ = b(y), C ∈ L ( s|( ỹ, y) ), and s s|( ỹ, y) ∈ E(R). -If y is blockable and a predecessor of Tail(s), then s = p|(y, y)| (Tail(s), Tail (s)) , C ∈ L ( p|(y, y) ), and s, p|(y, y) ∈ E(R). b. If s ∈ Nom(G), then G being a CCG implies the existence of some Rsuccessor x of s with C ∈ L(x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>( C1 )</head><label>C1</label><figDesc>For each node x, L(x) ∩ cl(T , R) ⊆ L (π(x)), (C2) For each pair of nodes x, y and each role R, if y is an R-successor of x, then π(x), π(y) ∈ E(R), (C3) x . = y implies π(x) = π(y), and (C4) If ( nS.C) ∈ L(x) \ cl(T , R), then S T (π(x), C) = n,where S T (s, C) = {t ∈ S | s, t ∈ E(S) and C ∈ L (t)}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>In the following, if R is clear from the context, then we may abuse our notation and use * and Trans(S) instead of * R and Trans(S, R).</figDesc><table><row><cell>(R) is a transitive role name. In order to avoid these case distinctions, the function Trans returns true if R is a transitive role -regardless of whether it is a role name, the inverse of a role name, or equivalent to a transitive role name (or its inverse): Trans(S, R) := true if, for some P with P ≡ R S, P ∈ R + or Inv(P) ∈ R + ; Trans(S, R) := false otherwise. Note that the interpretation of S may be transitive even if Trans(S, R) returns false; this can arise, for example, if the TBox contains an axiom ∀S(∀S.⊥). 4. A role R is called simple w.r.t. R if Trans(S, R) = false for all S * R R, that is, if it is neither transitive nor has a transitive subrole. If a role is nonsimple, then it may lead to implicit role relationships as a result of transitive (sub)role chains. For example, if S * R R and Trans(S, R), then { x, y , y, z } ⊆ S I implies x, z ∈ R I . Counting the number of fillers of a nonsimple role is, therefore, rather tricky, and it is known that allowing nonsimple roles in number restrictions results in the undecidability of standard reasoning problems [26]. set of SHOIQ-concepts (or concepts for short) is the smallest set such that 1. Every concept name C ∈ C is a concept; 2. If C and D are concepts and R is a role, then (C D), (C D), (¬C), (∀R.C), and (∃R.C) are also concepts (the last two are called universal and existential restrictions, resp.); and 3. If C is a concept, R is a simple role and n ∈ IN, then ( nR.C) and ( nR.C) are 5. Definition 2 Let C be a sets of concept names with a subset C o ⊆ C of nominals. The also concepts (called atmost and atleast number restrictions). 7</cell></row></table><note><p>3. Obviously, a role R is transitive if and only if its inverse Inv(R) is transitive. However, in cyclic cases such as R ≡ R S, S is transitive if R or Inv</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The remainder is a simple counting exercise: the NN-rule can be applied at most m times to a given nominal node, and each such application can generate at most n new nominal nodes. As G was initialized with nominal nodes, the NN-rule can be applied at most m times to each level 0 node, and each application generates at most n new nodes, we can generate at most mn level 1 nodes; similarly, the NN-rule can be applied at most m times to each level i node to generate n new nodes, thereby generating at most (mn) i+1 level i + 1 nodes. As the NN-rule is applicable only to nodes with level &lt; λ and the level of a node or its heirs can only decrease, this gives an upper bound of</figDesc><table><row><cell>m</cell></row><row><cell>0 i&lt;λ</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>OWL Full uses the same language vocabulary as OWL DL but does not restrict its use to wellformed formulas.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>OWL also includes datatypes, a simple form of concrete domain<ref type="bibr" target="#b1">[2]</ref>. These can, however, be treated exactly as in SHOQ(D)/SHOQ(D n )[18, 25,  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>30], so we will not complicate our presentation by considering them here.<ref type="bibr" target="#b2">3</ref> For naming conventions of DLs, see the Appendix of<ref type="bibr" target="#b0">[1]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Franz Baader introduced this term for a similar problem that needs to be overcome in similar algorithms such as those described in<ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>In the sense that the behavior of the algorithm will depend on the expressive power actually used in the input ontology<ref type="bibr" target="#b30">[31]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>A feature of many realistic ontologies; see, for example, the DAML ontology library at http://www. daml.org/ontologies/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Since SHOIQ extends SHIN , we need to restrict roles in number restrictions to simple ones in order to yield a decidable logic<ref type="bibr" target="#b25">[26]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>For example, this effect led to the introduction of "fork elimination" in<ref type="bibr" target="#b1">[2]</ref> and is described in detail in<ref type="bibr" target="#b3">[4]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>Moreover, pruning causes x 1 to be removed, but a similar path will be rebuilt and merged into r 2 and either n 1 or n 2 .</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<title level="m">The Description Logic Handbook: Theory, Implementation, and Applications</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A schema for integrating concrete domains into concept languages</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hanschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Joint Conference on Artificial Intelligence (IJCAI&apos;91)</title>
		<meeting>the 12th International Joint Conference on Artificial Intelligence (IJCAI&apos;91)</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="452" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A terminological knowledge representation system with complete inference algorithms</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hollunder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Processing Declarative Knowledge</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the First International Workshop on Processing Declarative Knowledge<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">572</biblScope>
			<biblScope unit="page" from="67" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An overview of tableau algorithms for description logics</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stud. Log</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="40" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Bechhofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/owl-ref/" />
		<title level="m">OWL Web ontology language reference. W3C Recommendation</title>
		<meeting><address><addrLine>Stein, L.A.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hybrid languages</title>
		<author>
			<persName><forename type="first">P</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seligman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Lang. Inf</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="251" to="272" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Living with CLASSIC: when and how to use a KL-ONE-like language</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Brachman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Resnick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Borgida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Semantic Networks</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Sowa</surname></persName>
		</editor>
		<meeting><address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="401" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Implementing and testing expressive description logics: preliminary report</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bresciani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Franconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 Description Logic Workshop (DL&apos;95)</title>
		<meeting>the 1995 Description Logic Workshop (DL&apos;95)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="131" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Decidable reasoning in terminological knowledge representation systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buchheit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Donini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schaerf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="109" to="138" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Description logic framework for information integration</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;98)</title>
		<meeting>the 6th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;98)<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="2" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Decidability of class-based knowledge representation formalisms</title>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Dipartimento di Informatica e Sistemistica, Università di Roma</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Boosting the correspondence between description logics and propositional dynamic logics (extended abstract)</title>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th National Conference on Artificial Intelligence (AAAI-94)</title>
		<meeting>the 12th National Conference on Artificial Intelligence (AAAI-94)<address><addrLine>Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">TBox and ABox reasoning in expressive description logics</title>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on the Principles of Knowledge Representation and Reasoning (KR&apos;96)</title>
		<meeting>the 5th International Conference on the Principles of Knowledge Representation and Reasoning (KR&apos;96)<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="316" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Using terminological reasoning in hybrid systems</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Donini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Commun. -Eur. J. Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="128" to="138" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Propositional dynamic logic of regular programs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="194" to="211" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Framework for an automated comparison of description logic reasoners</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gardiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tsarkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 International Semantic Web Conference (ISWC</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2006 International Semantic Web Conference (ISWC<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="volume">4273</biblScope>
			<biblScope unit="page" from="654" to="667" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Why are modal logics so robustly decidable?</title>
		<author>
			<persName><forename type="first">E</forename><surname>Grädel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Current Trends in Theoretical Computer Science: Entering the 21st Century</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Paun</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</editor>
		<meeting><address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="393" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The description logic ALCN H R+ extended with concrete domains: a practically motivated approach</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference on Automated Reasoning</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the International Joint Conference on Automated Reasoning<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2083</biblScope>
			<biblScope unit="page" from="29" to="44" />
		</imprint>
	</monogr>
	<note>a</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">RACER System description</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference on Automated Reasoning</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the International Joint Conference on Automated Reasoning<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001b</date>
			<biblScope unit="volume">2083</biblScope>
			<biblScope unit="page" from="701" to="705" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tableau systems for SHIO and SHIQ</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hladik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Model</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 Description Logic Workshop</title>
		<meeting>the 2004 Description Logic Workshop</meeting>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
	<note>CEUR. Available from ceur-ws.org</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Qualifying number restrictions in concept languages</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hollunder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<idno>RR-91-03</idno>
	</analytic>
	<monogr>
		<title level="m">An abridged version appeared in Proceedings of the 2nd International Conference on the Principles of Knowledge Representation and Reasoning (KR&apos;91</title>
		<meeting><address><addrLine>Kaiserslautern (Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">FaCT and DLP: Automated reasoning with analytic tableaux and related methods</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Analytic Tableaux and Related Methods (TABLEAUX&apos;98)</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the 2nd International Conference on Analytic Tableaux and Related Methods (TABLEAUX&apos;98)<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1397</biblScope>
			<biblScope unit="page" from="27" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimizing description logic subsumption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Log. Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="267" to="293" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">From SHIQ and RDF to OWL: the making of a web ontology language</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semantics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="26" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Ontology reasoning in the SHOQ(D) description logic</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI 2001)</title>
		<meeting>the 17th International Joint Conference on Artificial Intelligence (IJCAI 2001)<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="199" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Practical reasoning for expressive description logics</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Logic for Programming and Automated Reasoning (LPAR&apos;99)</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting>the 6th International Conference on Logic for Programming and Automated Reasoning (LPAR&apos;99)<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1705</biblScope>
			<biblScope unit="page" from="161" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Reasoning with individuals for the description logic SHIQ</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Conference on Automated Deduction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</editor>
		<meeting>the 17th International Conference on Automated Deduction<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="volume">1831</biblScope>
			<biblScope unit="page" from="482" to="496" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An industrial strength description logic-based configuration platform</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intell. Syst</title>
		<imprint>
			<biblScope unit="page" from="69" to="77" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Complexity of two-variable logic with counting</title>
		<author>
			<persName><forename type="first">L</forename><surname>Pacholski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Szwast</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tendera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th IEEE Symposium on Logic in Computer Science (LICS&apos;97)</title>
		<meeting>the 12th IEEE Symposium on Logic in Computer Science (LICS&apos;97)<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="318" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Web ontology reasoning with datatype groups</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2003 International Semantic Web Conference (ISWC 2003)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Fensel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Sycara</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</editor>
		<meeting>of the 2003 International Semantic Web Conference (ISWC 2003)<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2870</biblScope>
			<biblScope unit="page" from="47" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Term subsumption languages in knowledge representation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Owsnicki-Klew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kobsa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Guarino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Macgregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nebel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schmiedel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Mag</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="16" to="23" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Reasoning with individuals in concept languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schaerf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl. Eng</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="141" to="176" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A correspondence theory for terminological logics: preliminary report</title>
		<author>
			<persName><forename type="first">K</forename><surname>Schild</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Joint Conference on Artificial Intelligence (IJCAI&apos;91)</title>
		<meeting>the 12th International Joint Conference on Artificial Intelligence (IJCAI&apos;91)<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="466" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">From wine to water: optimizing description logic reasoning for nominals</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the 10th International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="page" from="90" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Pellet: a practical OWL-DL reasoner</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cuenca</surname></persName>
		</author>
		<author>
			<persName><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalyanpur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semantics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="51" to="53" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The complexity of reasoning with cardinality restrictions and nominals in expressive description logics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="199" to="217" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Complexity results and practical algorithms for logics in knowledge representation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>LuFG Theoretical Computer Science, RWTH-Aachen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Ordering heuristics for description logic reasoning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsarkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005)</title>
		<meeting>the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005)<address><addrLine>Los Altos</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="609" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">FaCT++ description logic reasoner: system description</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tsarkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference on Automated Reasoning (IJCAR</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the International Joint Conference on Automated Reasoning (IJCAR<address><addrLine>Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="volume">4130</biblScope>
			<biblScope unit="page" from="292" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Why is modal logic so robustly decidable</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">DIMACS Series in Discrete Mathematics and Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="149" to="184" />
			<date type="published" when="1997">1997</date>
			<publisher>American Mathematical Society</publisher>
			<pubPlace>Providence, RI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
