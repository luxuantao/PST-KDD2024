<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The quantum query complexity of approximating the median and related statistics *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1998-11-15">15 Nov 1998</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Ashwin</forename><surname>Nayak</surname></persName>
							<email>ashwin@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Division</orgName>
								<address>
									<region>UC Berkeley</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Felix</forename><surname>Wu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Division</orgName>
								<address>
									<region>UC Berkeley</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The quantum query complexity of approximating the median and related statistics *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1998-11-15">15 Nov 1998</date>
						</imprint>
					</monogr>
					<idno type="MD5">B0776482EAB402D55B9BDA56F991930B</idno>
					<idno type="arXiv">arXiv:quant-ph/9804066v2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:03+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Let X = (x 0 , . . . , x n-1 ) be a sequence of n numbers. For ǫ &gt; 0, we say that x i is an ǫapproximate median if the number of elements strictly less than x i , and the number of elements strictly greater than x i are each less than (1+ǫ)n/2. We consider the quantum query complexity of computing an ǫ-approximate median, given the sequence X as an oracle. We prove a lower bound of Ω(min{ 1 ǫ , n}) queries for any quantum algorithm that computes an ǫ-approximate median with any constant probability greater than 1/2. We also show how an ǫ-approximate median may be computed with O( <ref type="formula">1</ref>ǫ log( 1 ǫ ) log log( 1 ǫ )) oracle queries, which represents an improvement over an earlier algorithm due to Grover <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>. Thus, the lower bound we obtain is essentially optimal. The upper and the lower bound both hold in the comparison tree model as well.</p><p>Our lower bound result is an application of the polynomial paradigm recently introduced to quantum complexity theory by Beals et al. <ref type="bibr" target="#b0">[1]</ref>. The main ingredient in the proof is a polynomial degree lower bound for real multilinear polynomials that "approximate" symmetric partial boolean functions. The degree bound extends a result of Paturi [15]  and also immediately yields lower bounds for the problems of approximating the kth-smallest element, approximating the mean of a sequence of numbers, and that of approximately counting the number of ones of a boolean function. All bounds obtained come within polylogarithmic factors of the optimal (as we show by presenting algorithms where no such optimal or near optimal algorithms were known), thus demonstrating the power of the polynomial method.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction 1.Synopsis</head><p>Proving non-trivial lower bounds for any universal model of computation is a formidable task, and quantum computers are no exception to this. It is thus natural to seek bounds in restricted settings. The first such step in the field of quantum computation was taken by Bennett et al. <ref type="bibr" target="#b1">[2]</ref>. They prove that we cannot solve NP-complete problems in sub-exponential time on a quantum computer merely by adopting the brute-force strategy of "guessing" solutions and checking them for correctness. Nonetheless, Grover's search algorithm <ref type="bibr" target="#b9">[10]</ref> shows that a quadratic speed-up over classical algorithms is possible in this case. Thus, while the parallelism and the potential for interference inherent in quantum computation are not sufficient to significantly speed up certain strategies for solving problems, they do give some advantage over probabilistic computation. These results motivate the question as to whether similar speed up is possible in other scenarios as well.</p><p>Strategies such as 'brute-force search' may formally be modelled via "black-box" computations, in which information about the input is supplied to the algorithm by an oracle. For example, the black-box search problem may be defined as follows: given oracle access to n bits X = (x 0 , . . . , x n-1 ), compute an index i such that x i = 1, if such an index exists. A simpler formulation would require a yes/no answer according to whether such an index exists or not. This amounts to computing the logical OR of the input bits. In the black-box setting, strategies are evaluated by studying the query complexity of the problem, i.e., the minimum, over all algorithms, of number of times the oracle is accessed (in the worst case) to solve the problem. In the case of the abstract search problem, the query complexity is the number of bits that need to be examined (in the worst case) in order to compute the logical OR of the n bits.</p><p>Considerable success has been achieved in the study of the query complexity of computing boolean functions in the quantum black box model, both in terms of optimal lower bounds for specific functions <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b0">1]</ref>, and in terms of general techniques for proving such lower bounds <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b0">1]</ref>. However, few approaches were known for the study of more general functions. Consider, for example, the problem of approximating the median of n numbers. An ǫ-approximate median of a sequence X = (x 0 , . . . , x n-1 ) of n numbers is a number x i such that the number of x j less than it, and the number of x j more than it are both less than (1 + ǫ) n 2 . The problem then is to compute such an x i , given, as an oracle, the sequence X of input values, and an explicitly specified parameter ǫ &gt; 0 (which may be assumed to be at least 1  2n ). Grover gave an algorithm for finding an ǫ-approximate median that makes Õ( 1 ǫ ) queries to the input oracle <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>. (Here, the Õ notation suppresses factors involving log( 1 ǫ ) and M , where M is the size of the domain the numbers are picked from.) Thus, an almost quadratic speed up over the best classical algorithm was achieved (assuming M to be constant). However, it was still open whether this algorithm could be improved upon. In particular, known techniques such as the "hybrid argument" yielded a lower bound of Ω( 1 √ ǫ ) for the number of queries <ref type="bibr" target="#b17">[18]</ref>, whereas O( 1 ǫ ) was suspected to be optimal. In this paper, we prove a lower bound of Ω( 1 ǫ ) for the query complexity of the approximate median problem, thus showing that Grover's algorithm is almost optimal. We also present a new O( <ref type="formula">1</ref>ǫ log( 1 ǫ ) log log( 1 ǫ )) query algorithm for the problem, thereby eliminating the dependence of the upper bound on M . The upper and the lower bound both also hold in the comparison tree model, in which one is interested in the number of comparisons between the input elements required to compute an ǫ-approximate median.</p><p>Our lower bound is derived via the polynomial method recently introduced to the area of quantum computing by Beals et al. <ref type="bibr" target="#b0">[1]</ref>. They show that the acceptance probability of a quantum algorithm making T queries to a boolean oracle can be expressed as a real multilinear polynomial of degree at most 2T in the oracle input. Thus, if the algorithm computes a boolean function of the oracle input with probability at least 2/3, the polynomial approximates the function to within 1/3 at all points in the boolean hypercube. So, by proving a lower bound on the degree of polynomials approximating the boolean function, we can derive a lower bound on the number of queries T the quantum algorithm makes. We cannot, however, follow this particular route for the problem of approximating the median, since the restriction of the problem to boolean inputs does not yield a well-defined function. Nonetheless, the restriction does yield a partial boolean function, i.e., a function that is not defined at all points of the domain. Our result is thus based on a degree lower bound for polynomials that "approximate" partial boolean functions. This degree lower bound generalizes a bound due to Paturi <ref type="bibr" target="#b14">[15]</ref>, and also gives lower bounds for the problems of approximating the kth smallest element, approximating the mean of a sequence of numbers, and that of approximately counting the number of ones of a boolean function. All bounds obtained are almost tight (as we show by presenting algorithms where no such optimal or near optimal algorithms were know), demonstrating the power of the polynomial method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Summary of results</head><p>Consider a partial boolean function f : {0, 1} n → {0, 1}. We say a real n-variate polynomial p approximates the partial function f to within c, for a constant 0 ≤ c &lt; 1/2, if 1. for all X ∈ {0, 1} n , p(X) ∈ [-c, 1 + c], and 2. for all points X at which f is defined, |p(X)f (X)| ≤ c.</p><p>Our main theorem gives a degree lower bound for polynomials approximating partial boolean functions of the following type. For X = (x 0 , . . . , x n-1 ) ∈ {0, 1} n , let |X| = n-1 i=0 x i be the number of ones in X. Further, let ℓ, ℓ ′ be integers such that 0 ≤ ℓ = ℓ ′ ≤ n. Define the partial boolean function f ℓ,ℓ ′ on {0, 1} n as</p><formula xml:id="formula_0">f ℓ,ℓ ′ (X) = 1 if |X| = ℓ 0 if |X| = ℓ ′ Let m ∈ {ℓ, ℓ ′ } be such that n 2 -m is maximized, and let ∆ ℓ = |ℓ -ℓ ′ |.</formula><p>Theorem 1.1 Let p be any real n-variate polynomial which approximates the partial boolean function f ℓ,ℓ ′ to within c, for some constant c &lt; 1/2. Then, the degree of p is Ω( n/∆ ℓ + m(nm)/∆ ℓ ).</p><p>This theorem subsumes a degree lower bound given by Paturi <ref type="bibr" target="#b14">[15]</ref> for polynomials approximating (total) symmetric boolean functions.</p><p>We say that an algorithm A, possibly with access to an oracle, computes a partial function f on {0, 1} n , if Pr[A(X) = f (X)] ≤ δ for all inputs X for which f is defined, where δ is some constant less than 1/2. For boolean f , we say that the algorithm accepts an input X if A(X) = 1. Theorem This lower bound also holds for the expected query complexity of computing the partial function f ℓ,ℓ ′ . Using an approximate counting algorithm of Brassard et al. <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b5">6]</ref>, we show that our query lower bound is optimal to within a constant factor.</p><p>Theorem 1.3 The quantum query complexity of computing the partial function f ℓ,ℓ ′ , given the input as an oracle, is O( n/∆ ℓ + m(nm)/∆ ℓ ).</p><p>The result of Beals et al. mentioned above then immediately implies that the degree lower bound of Theorem 1.1 is also optimal to within a constant factor.</p><p>Corollary 1.4 For any constant 0 &lt; c &lt; 1/2, there is a real, n-variate polynomial p of degree O( n/∆ ℓ + m(nm)/∆ ℓ ) that approximates the function f ℓ,ℓ ′ to within c.</p><p>Corollary 1.2 enables us to prove lower bounds for the query complexity of computing the statistics listed below, given, as an oracle, a list X = (x 0 , . . . , x n-1 ) of (rational) numbers in the range [0, 1] and an explicitly specified real parameter ǫ &gt; 0 or ∆ &gt; 0. We may assume ǫ to be in the range [1/(2n), 1), and ∆ to be in [1/2, n).</p><p>1. ǫ-approximate median. A number x i such that |{j : x j &lt; x i }| &lt; (1 + ǫ)n/2 and |{j :</p><formula xml:id="formula_1">x j &gt; x i }| &lt; (1 + ǫ)n/2.</formula><p>2. ∆-approximate kth-smallest element. (Defined for 1 ≤ k ≤ n.) A number x i that is a jthsmallest element of X for some j in the range (k -∆, k + ∆).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ǫ-approximate</head><formula xml:id="formula_2">mean. A number µ such that |µ -µ X | &lt; ǫ, where µ X = 1 n n i=0 x i is the mean of the n input numbers. 4. ∆-approximate count. (Defined when x i ∈ {0, 1} for all i.) A number t such that |t -t X | &lt; ∆,</formula><p>where t X = |X| = n i=0 x i is the number of ones in X.</p><p>5. ǫ-approximate relative count. (Defined when x i ∈ {0, 1} for all i.) A number t such that |tt X | &lt; ǫt X , where t X is defined as above.</p><p>Note that some of the problems defined above are very closely related to each other. Problem 2 is a natural generalization of problem 1; problem 4 is, of course, the restriction of problem 3 to boolean inputs (with ∆ defined appropriately), and problem 5 is a version of problem 4 where we are interested in bounding relative error rather than additive error. In the case of problems 1 and 2, we may relax the condition that the approximate statistic be a number from the input list (with a suitable modification to definition 2 above); our results continue to hold with the relaxed definitions. (Problem 1 was first studied by Grover <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> with this relaxed definition.)</p><p>We first prove a lower bound for approximating the kth-smallest element by showing reductions from partial functions of the sort described above.</p><p>Theorem 1.5 At least Ω( n/∆ + k(nk)/∆) oracle queries are made by any quantum black-box algorithm for computing a ∆-approximate kth-smallest element.</p><p>We thus get a lower bound for the approximate median problem as well.</p><p>Corollary 1.6 The quantum query complexity of computing an ǫ-approximate median is Ω(1/ǫ).</p><p>We also propose an algorithm for approximating the kth-smallest element that comes within a polylogarithmic factor of the optimum.</p><formula xml:id="formula_3">Theorem 1.7 Let N = n/∆ + k(n -k)/∆.</formula><p>There is a quantum black-box algorithm that computes a ∆-approximate kth-smallest element of n numbers given via an oracle, with O(N log(N ) log log(N )) queries.</p><p>This gives us a new algorithm for estimating the median. Our algorithm represents an improvement over the algorithm of Grover <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> when the input numbers are allowed to be drawn from an arbitrarily large domain.</p><formula xml:id="formula_4">Corollary 1.8 O( 1 ǫ log( 1 ǫ ) log log( 1 ǫ</formula><p>)) queries are sufficient for computing an ǫ-approximate median in the black-box model. This gives us an almost quadratic speed up over classical algorithms in the worst case.</p><p>A very natural measure of complexity of computing functions such as the kth-smallest element of a given list of numbers is the number of comparisons between the input elements required for the computation.</p><p>To study this aspect of such problems, one considers algorithms in the comparison tree model. In this model, the algorithm is provided with an oracle that returns the result of the comparison x i &lt; x j when given a pair of indices (i, j), rather than an oracle that returns the number x i on a query i, where the x i 's are understood to be the input numbers. The query complexity of a problem such as computing the minimum or the median then exactly corresponds to the number of comparisons required to solve the problem. The lower and the upper bounds given above for estimating the kth-smallest element and the median continue to hold in the comparison tree model. In particular, if we set ∆ = 1, we get an almost optimal Õ( k(nk + 1) ) comparison algorithm for computing the kth-smallest element (c.f. Theorems 1.5 and 1.7). (An optimal O( √ n) comparison algorithm was already known for computing the minimum of n numbers <ref type="bibr" target="#b7">[8]</ref>.) This should be contrasted with the bound of Θ(n) in the classical case <ref type="bibr" target="#b2">[3]</ref>.</p><p>Corollary 1.9 Let N = k(nk + 1). Any comparison tree quantum algorithm that computes the kthsmallest element of a list of n numbers makes Ω(N ) comparisons. Moreover, there is a quantum algorithm that solves this problem with O(N log(N ) log log(N )) comparisons.</p><p>Another application of Corollary 1.2 is to the problem of approximating the mean. Grover <ref type="bibr" target="#b11">[12]</ref> recently gave an O( 1 ǫ log log 1 ǫ ) query algorithm for this problem, which is again an almost quadratic improvement over classical algorithms. When the inputs are restricted to be 0/1, the problem reduces to the counting problem. Using the approximate counting algorithm of Brassard et al. mentioned above, we show that the computation of the mean can be made sensitive to the number of ones in the input, thus getting better bounds when |tn/2| is large. Theorem 1.10 There is a quantum black-box algorithm that, given a boolean oracle input X, and an integer ∆ &gt; 0, computes a ∆-approximate count and makes an expected O( n/∆ + t(nt)/∆) number of queries on inputs with t ones.</p><p>We show that this algorithm is optimal to within a constant factor, and, in the process, get an almost tight lower bound for the general mean estimation problem.</p><p>Theorem 1.11 Any quantum back-box algorithm that approximates the number of ones of a boolean oracle to within an additive error of ∆ makes Ω( n/∆ + t(nt)/∆) queries on inputs with t ones.</p><p>Corollary 1.12 The quantum query complexity of the ǫ-approximate mean problem is Ω( 1 ǫ ).</p><p>Brassard et al. <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b5">6]</ref> study the version of the approximate counting problem in which one is interested in bounding the relative error of the estimate. We show that their algorithm is optimal to within a constant factor (when t ≤ (1ǫ)n). Finally, we would like to point out that in view of Corollary 1.4, the lower bounds stated above cannot be improved using the method we employ in this paper. In fact, we believe that the lower bounds are optimal, and that the upper bounds can be improved to match them (up to constant factors).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The lower bound theorem and its applications</head><p>This section is devoted to deriving a polynomial degree lower bound, and to showing how lower bounds for the query complexity of the different black-box problems defined in Section 1.2 follow from it. We first prove the degree lower bound for polynomials in Section 2.1, and then apply the result to quantum black-box computation in Section 2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A degree lower bound for polynomials</head><p>We now prove our main result, Theorem 1.1, which gives a lower bound for polynomials approximating symmetric partial functions. The bound is derived using a technique employed by Paturi <ref type="bibr" target="#b14">[15]</ref> for polynomials that approximate non-constant symmetric boolean functions. Our bound generalizes and subsumes the Paturi bound.</p><p>We refer the reader to Appendix A for the definition of the concepts involved in the proof. Appendix A also summarizes the various facts about polynomials that we use to derive the bound.</p><p>Our proof rests heavily on the inequalities of Bernstein and Markov (Facts A.6 and A.5). The essence of these inequalities is that if there is a point in [-1, 1] at which a polynomial has a "large" derivative, and if the point is suitably close to the middle of the interval, the polynomial has "high" degree.</p><p>Proof of Theorem 1.1: Recall from Section 1.2 that f ℓ,ℓ ′ (X) is a partial boolean function on {0, 1} n which is 1 when |X| = ℓ and 0 when |X| = ℓ ′ , that m is one of the integers ℓ, ℓ ′ such that |n/2 -m| is maximized, and that ∆ ℓ = |ℓℓ ′ |. We assume that p is an n-variate polynomial of degree d which approximates the partial function f to within 1/3 in the sense defined in Section 1.2. The constant 1/3 may be replaced by any constant less than 1/2; the proof continues to hold for that case. Without loss of generality, we assume that ℓ &gt; ℓ ′ (we work with the polynomial 1p, which approximates 1f , if ℓ &lt; ℓ ′ ).</p><p>We begin by replacing p with its symmetrization p sym and then using Fact A.1 to transform it to an equivalent univariate polynomial q. (Since x 2 = x for x ∈ {0, 1}, we may assume that p is multilinear.) We show a degree lower bound for q, thus giving a degree lower bound for p.</p><p>In order to apply the derivative inequalities above, we scale to transform the polynomial q to an equivalent polynomial q over the interval [-1, 1], where q(x) = q((1+x)n/2). For i = 0, 1, . . . , n, let a i = 2i/n-1. Clearly, q has the following properties:</p><p>1. q has degree at most d.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">|q(a</head><formula xml:id="formula_5">i )| ≤ 4/3 for 0 ≤ i ≤ n.</formula><p>3. q(a ℓ ) ≥ 2/3 and q(a ℓ ′ ) ≤ 1/3. Thus, by the Mean Value Theorem, there is a point a in the interval [a ℓ ′ , a ℓ ] such that q′ (a) ≥ (2/3 -1/3)/(a ℓa ℓ ′ ) = n/(6∆ ℓ ).</p><p>We prove two lower bounds for d, which together imply the theorem. The first of the lower bounds follows by applying the Markov Inequality (Fact A.5.1) directly to q.</p><p>Lemma 2.1 d = Ω( n/∆ ℓ ).</p><p>Proof: We consider two cases:</p><p>Case (a). q &lt; 2. Combining property 3 of q listed above and Fact A.5.1, we get</p><formula xml:id="formula_6">d 2 ≥ q′ (a)/ q ≥ n/(12∆ ℓ ). So d = Ω( n/∆ ℓ ).</formula><p>Case (b). q ≥ 2. From property 2 of q listed above, every point at which q attains its norm is no more than 2/n away from a point a i at which |q(x)| ≤ 4/3. Hence, by the Mean Value Theorem, there is a point â ∈ [-1, 1] such that q′ (â) ≥ ( q -4/3)/(2/n) ≥ n q /6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Markov inequality then implies</head><formula xml:id="formula_7">d = Ω( √ n ) = Ω( n/∆ ℓ ).</formula><p>The second of the lower bounds now follows from an application of the Bernstein Inequality for algebraic and trigonometric polynomials (Facts A.5.2 and A.6, respectively).</p><p>Lemma 2.2 d = Ω( m(nm)/∆ ℓ ).</p><p>Proof: Note that if q has norm less than 2, property 3 in conjuntion with Fact A.5.2 implies that</p><formula xml:id="formula_8">2d ≥ q d ≥ 1 -a 2 q′ (a) ≥ 1 -a 2 (n/6∆ ℓ ). But since a ∈ [a ℓ ′ , a ℓ ], we have 1 -a 2 ≥ 1 -a 2 m = 1 -(2m/n -1) 2 = 4m(n -m)/n 2 . So, d = Ω( m(n -m)/∆ ℓ ).</formula><p>Now suppose that q ≥ 2. The proof in this case is not as straightforward as in Case (b) of the proof of Lemma 2.1, since Fact A.5.2 only gives us a bound which is sensitive to the point at which q has high derivative. However, it is possible to "damp" the value of the polynomial outside a suitable interval, and thus obtain the required bound.</p><p>Let b be a point in [-1, 1] at which min x {|x| : |q(x)| ≥ 2} is attained, and let c be one of the numbers b, a ℓ such that |c| is minimized. We assume that c ≥ 0, since the proof in the other case is similar. Let C be a constant such that 0 &lt; C &lt; 0.01. We distinguish between two cases.</p><p>Case (a). c ≤ 1 -C. We consider a polynomial r defined as:</p><formula xml:id="formula_9">r(x) = q(x + c)(1 -x 2 ) d 1</formula><p>where d 1 = 6/C 2 d. The degree D of r is clearly O(d), so it suffices to prove the claimed lower bound for D.</p><p>Suppose r &lt; 2. Then, the following property of r gives us the required bound. If c = a ℓ , then r(0) ≥ 2/3, and we also have r(a ℓ ′c) ≤ 1/3. If c = b, then |r(0)| ≥ 2, and moreover, there is a point ĉ &lt; c at a distance at most 2/n from c such that |r(ĉc)| ≤ 4/3. In either case, there is a point â ∈ [a ℓ ′a ℓ , 0] such that |r ′ (â)| = Ω(n/∆ ℓ ). We may assume, without loss of generality, that ∆ ℓ ≤ n/4, so that â ∈ [-1/2, 0]. (Indeed, since d ≥ 1, we already have d = Ω( m(nm)/∆ ℓ ), if ∆ ℓ &gt; n/4). We may now invoke the Mean Value Theorem and Fact A.5.2 to conclude that D = Ω(n/∆ ℓ ) = Ω( m(nm)/∆ ℓ ).</p><p>We now focus on the case when r ≥ 2. We show in Claim 2. It only remains to prove the following claim to complete the analysis of Case (a).</p><formula xml:id="formula_10">Claim 2.3 For all x ∈ [-1, -C] ∪ [C, 1], we have |r(x)| ≤ 1.</formula><p>Proof: Note that q = max 0≤x≤n |q(x)|. By Fact A.2, we thus have q ≤ (4/3)</p><formula xml:id="formula_11">• 2 d . In partic- ular, |q(x + c)| ≤ (4/3) • 2 d ≤ (4/3) • e 5d for x ∈ [-1, 1 -c].</formula><p>We give the same bound for |q(x + c)| for x ∈ [1c, 1] by using Fact A.3:</p><formula xml:id="formula_12">|q(x + c)| ≤ q • T d (x + c) ≤ (4/3) • 2 d • e 2 √ 3 d ≤ (4/3) • e 5d , since c ≤ 1. Further, if C ≤ |x| ≤ 1, we have (1 -x 2 ) d 1 ≤ e -x 2 d 1 ≤ e -6d</formula><p>. Combining these two inequalities, we may bound r as follows:</p><formula xml:id="formula_13">|r(x)| = |q(x + c)| (1 -x 2 ) d 1 ≤ (4/3) • e 5d • e -6d ≤ 1 for x in the region [-1, -C] ∪ [C, 1].</formula><p>We now turn to the remaining case.</p><p>Case (b). c &gt; 1 -C. Without loss of generality, we assume that ∆ ℓ ≤ ℓ ′ , ℓ ≤ n -∆ ℓ (otherwise, the bound we seek follows from Lemma 2.1 above, since m(nm)/∆ ℓ ≤ n/∆ ℓ ). This implies, in particular, that c &lt; 1. Let α c = cos -1 c. Since 0.99 &lt; 1 -C &lt; c &lt; 1, we have 0 &lt; α c &lt; 1/4.</p><p>We prove a degree lower bound for a trigonometric polynomial s derived from q. The polynomial s is defined as:</p><formula xml:id="formula_14">s(θ) = q(cos θ)[cos(d 1 (θ -α c ))] d 2 ,</formula><p>where d 1 = ⌊1/(2α c )⌋ and d 2 = c 1 ⌈d/d 1 ⌉, for some integer constant c 1 ≥ 1 to be specified later. Let D be the degree of the polynomial s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 2.4 D = O(d).</head><p>Proof: First, note that since cos θ ≥ 1θ 2 /2 for θ ∈ [0, π/2], we have</p><formula xml:id="formula_15">α c ≥ 2 √ 1 -cos α c = 2 √ 1 -c ≥ 2 2∆ ℓ /n.</formula><p>The last inequality follows from the assumption that ℓ ≤ n -∆ ℓ . So</p><formula xml:id="formula_16">d 1 ≤ 1/(2α c ) = O( n/∆ ℓ ) which is O(d)</formula><p>, by Lemma 2.1. We may now bound D as follows:</p><formula xml:id="formula_17">D ≤ d + d 2 d 1 = d + c 1 ⌈d/d 1 ⌉ d 1 ≤ d + c 1 (d + d 1 ). So D = O(d).</formula><p>Thus, it suffices to prove a lower bound of Ω( m(nm)/∆ ℓ ) for D, which we do next.</p><p>Let α i = cos -1 a i , for i = 0, . . . , n.</p><p>Again, if s is bounded by 2, we get the lower bound easily: if c = b, then |s(α c )| ≥ 2, and there is a point a i at a distance at most 2/n to the left of c such that |s(α i )| ≤ 4/3. We therefore have, for some α ∈ [α c , α i ], that |s ′ (α)| ≥ (2/3)/(α i -α c ). Moreover, by the Mean Value Theorem, we have</p><formula xml:id="formula_18">α i -α c = |cos α i -cos α c | / sin α for some α ∈ [α c , α i ]. Note that sin α ≥ sin α c ≥ sin α ℓ ≥ sin α m = 1 -a 2 m . Thus, |s ′ (α)| ≥ (2/3) 1 -a 2 m /(2/n), which gives us D = Ω( m(n -m) ) = Ω( m(n -m)/∆ ℓ )</formula><p>, when combined with Fact A.6, the Bernstein Inequality for trigonometric polynomials. If c = a ℓ , we can similarly argue that D = Ω( m(nm)/∆ ℓ ).</p><p>We now examine the case when s &gt; 2. Claim 2.5 below shows that |s(θ)| is bounded by</p><formula xml:id="formula_19">1 when θ ∈ [-π, -π + α c /2] ∪ [-α c /2, α c /2] ∪ [π -α c /2, π].</formula><p>We may assume that the point where the norm (which is greater than 2) is attained is in [0, π]; the proof proceeds in an analogous manner in the other case. This point is then close to some point α i ∈ [α c /2, πα c /2] where |s(α i )| ≤ 4/3. Arguing as before, we get that, for some points α, β</p><formula xml:id="formula_20">∈ [α c /2, π -α c /2], |s ′ (α)| ≥ s (sin β)/3(2/n). Further, sin β ≥ sin α c 2 ≥ α c 4 ≥ sin α c 4 ≥ sin α m 4 .</formula><p>From Fact A.6, we now get D = Ω( m(nm)) = Ω( m(nm)/∆ ℓ ).</p><p>We now prove that s is bounded in the region mentioned above.</p><formula xml:id="formula_21">Claim 2.5 For all θ ∈ [-π, -π + α c /2] ∪ [-α c /2, α c /2] ∪ [π -α c /2, π], we have |s(θ)| ≤ 1.</formula><p>Proof: We prove the claim for θ ∈ [0, α c /2]. The analysis for θ in the other intervals is similar (one exploits the fact that q(cos θ) is an even function of θ, and that the corollary to Fact A.3 limits its behaviour outside</p><formula xml:id="formula_22">[α c , π -α c ]). Let h(θ) = [cos(d 1 (θ -α c ))] d 2 . Then, for θ ∈ [0, α c ], |h(α c -θ)| = |cos(d 1 θ)| d 2 ≤ (1 -(d 1 θ) 2 /4) d 2 ≤ e -d 2 (d 1 θ) 2 /4 ≤ e -c 1 dθ 2 /(16αc) .</formula><p>The first inequality follows from the fact that cos φ ≤ 1φ 2 /4 for φ ∈ [0, π/2] and that 0</p><formula xml:id="formula_23">≤ d 1 α c ≤ 1/2.</formula><p>The second is a consequence of 1 + x ≤ e x . The remaining steps follow from the definitions of d 1 , d 2 and the fact that α c ≤ 1/4.</p><p>Further, Corollary A.4 gives us the following bound on the value of q outside the interval [-c, c]:</p><formula xml:id="formula_24">|q(c + x)| ≤ 2 |T d (1 + x/c)| ≤ 2 • e 2d √ 3x/c for x ∈ [0, 1 -c]. Since, for θ ∈ [0, α c ], cos(α c -θ) = cos α c cos θ + sin α c sin θ ≤ cos α c + α c θ = c + α c θ, we have |q(cos(α c -θ))| ≤ 2 • e 2d √ 3αcθ/c ≤ 2 • e 4d √ αcθ . So, for θ ∈ [0, α c /2], |s(θ)| = |q(cos(α c -(α c -θ)))| |h(α c -(α c -θ))| ≤ 1,</formula><p>provided c 1 is chosen large enough (as may readily be verified, bearing in mind that 1/α c = O(d)).</p><p>This completes the derivation of the second lower bound on the degree d of the polynomial q.</p><p>Lemmas 2.1 and 2.2 together imply that d = Ω max n/∆ ℓ , m(nm)/∆ ℓ , which is equivalent to the bound stated in Theorem 1.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Applications to quantum black-box computation</head><p>In this section, we use our degree lower bound in conjunction with a result of Beals et al. <ref type="bibr" target="#b0">[1]</ref> to derive lower bounds for the quantum black-box complexity of approximating the statistics defined in Section 1.2.</p><p>The key lemma of <ref type="bibr" target="#b0">[1]</ref> which we require is the following. Lemma 2.6 (Beals, Buhrman, Cleve, Mosca, de Wolf ) Let A be a quantum algorithm that makes T calls to a boolean oracle X. Then, there is a real multilinear polynomial p(x 0 , . . . , x n-1 ) of degree at most 2T such that the acceptance probability of A on oracle input X = (x 0 , . . . , x n-1 ) is exactly p(x 0 , . . . , x n-1 ).</p><p>We deduce Corollary 1.2 from Theorem 1.1 using this lemma.</p><p>Proof of Corollary 1.2: Consider an oracle quantum algorithm A that computes the partial function f ℓ,ℓ ′ with constant error probability c &lt; 1/2 by making at most T oracle queries. From the lemma above, we deduce that there is a multilinear polynomial p(x 0 , . . . , x n-1 ) of degree at most 2T that gives the acceptance probability of A with the oracle input X = (x 0 , . . . , x n-1 ). Clearly, p approximates f ℓ,ℓ ′ to within c: p(X) ≥ 1c when |X| = ℓ and p(X) ≤ c when |X| = ℓ ′ , and, moreover, the value of p(X) is restricted to the interval [0, 1] for all X ∈ {0, 1} n . Theorem 1.1 now immediately implies the result.</p><p>In the remainder of this section, we show how to reduce from partial function computations of the type given in Corollary 1.2 to approximating the kth-smallest element and to approximate counting, and show how bounds for approximating the median and the mean follow. In this way, we are able to show new quantum query lower bounds for the computation of these approximate statistics.</p><p>The following two lemmas specialize Corollary 1.2 to cases of interest to us. The first deals with functions f ℓ,ℓ ′ such that neither ℓ ′ nor ℓ is "close" to 0 or n, and the second covers the remaining case. Lemma 2.7 Let k, ∆ &gt; 0 be integers such that 2∆ &lt; k &lt; n -2∆. Then, the quantum query complexity of f k-∆,k+∆ is Ω( n/∆ + k(nk)/∆).</p><p>Proof: We assume that k ≤ n/2; the other case is symmetric. In applying Corollary Since the problem of approximate counting is a restriction of the more general problem of estimating the mean of n numbers, the lower bound for the latter problem follows directly from Theorem 1.11.</p><formula xml:id="formula_25">1.2, ∆ ℓ = 2∆. Since k ≤ n/2, m = k -∆. Moreover, (k -∆)(n -k + ∆) &gt; (k/2)(n -k).</formula><p>Proof of Corollary 1.12: If the input numbers are all 0/1, multiplying an ǫ-approximate mean by n gives us an ǫn-approximate count. From Theorem 1.11, we get that in the worst case (i.e., when the number of ones in the input is ⌊n/2⌋), the number of queries required to solve the approximate mean problem is Ω(1/ǫ).</p><p>Finally, we sketch the proof of the lower bound for approximate counting to within some relative error.</p><p>Proof of Theorem 1.13: To derive a lower bound for the number of queries T made to approximate the number of ones for X such that t X = t, we consider a truncated version of the algorithm obtained by running the algorithm till it returns a value between (1ǫ)t and (1 + ǫ)t with probability at least 2/3 for such inputs. Since the algorithm correctly approximates the count to within a relative error of ǫ for all inputs, we can use it to compute the functions f t,t+1 , when ǫt ≤ 1/4, and f t ′ ,t , where t ′ = ⌊(1ǫ)t/(1 + ǫ)⌋, when 1/4 &lt; ǫt. Corollary 1.2 now gives us the claimed bound.</p><p>3 Some optimal or essentially optimal algorithms</p><p>We now show that the quantum black-box bounds obtained in the previous section are either tight or essentially tight by giving algorithms for the problems for which no such (optimal or near optimal) algorithm was known.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">An optimal distinguisher</head><p>Recall the problem of computing the partial function f ℓ,ℓ ′ defined in Section 1.2. In this section, we show how this partial function may be computed optimally, i.e., within a constant factor of the lower bound of Corollary 1.2, thus proving Theorem 1.3. Along with Lemma 2.6, this implies that the polynomial degree lower bound we show in Theorem 1.1 is within a constant factor of the optimal, and hence that it is not possible to obtain better lower bounds for the problems we consider using our technique.</p><p>Our algorithm actually computes the partial function fℓ,ℓ ′ : {0, 1} n → {0, 1}, where 0 ≤ ℓ ′ &lt; ℓ ≤ n, defined as: fℓ</p><formula xml:id="formula_26">,ℓ ′ = 1 if |X| ≥ ℓ 0 if |X| ≤ ℓ ′</formula><p>Clearly, any algorithm for this partial function also computes f ℓ,ℓ ′ , and thus the lower bound for the latter also holds this function. (To compute f ℓ,ℓ ′ when ℓ &lt; ℓ ′ , it suffices to compute f ℓ ′ ,ℓ and negate the output.)</p><p>The algorithm D(X, ℓ ′ , ℓ) for fℓ,ℓ ′ , which we call a distinguisher, is, in fact, an immediate derivative of an approximate counting algorithm of Brassard et al. <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b5">6]</ref>, which enables us to estimate the number of ones t Y of a boolean function Y in a useful manner. </p><formula xml:id="formula_27">|t Y -t| ≤ t Y (n -t Y ) P + |n -2t Y | 4P 2</formula><p>probability, this estimate is within O(min {t X , nt X } + ∆) of the actual count t X . The algorithm then invokes C again, with P = c 1 ( n/∆ + t(nt)/∆) (for a suitable constant c 1 ) and outputs the value returned by C. It is easy to verify that with high (constant) probability, the approximate count obtained is within the required range. An analysis similar to that of the exact counting algorithm mentioned above yields the bound of Theorem 1.10 on the expected number of queries made by the algorithm.</p><p>This fact follows easily from an examination of the Lagrange interpolation for the polynomial p; the details are omitted.</p><p>The next fact bounds the value of a polynomial outside the interval [-1, 1], in terms of its norm (i.e., its maximum value inside the interval A proof of this fact may be found in Section 2.7 of <ref type="bibr" target="#b16">[17]</ref>. We require an easy corollary of this fact. At the heart of our lower bound proof is the following set of inequalities, due to Bernstein and Markov, which relate the size of the derivative p ′ of a polynomial p to the degree of p. Proofs of these may be found in Section 3.4 of <ref type="bibr" target="#b15">[16]</ref> and Section 2.7 of <ref type="bibr" target="#b16">[17]</ref>.  B Proofs of some claims made in Section 3</p><formula xml:id="formula_28">[-1, 1]). Let T d (x) = 1 2 [(x + √ x 2 -1) d + (x - √ x 2 -1) d ].</formula><p>Proof of Claim 3.2: Recall that m ∈ {ℓ, ℓ ′ } is such that n 2m is maximized, and that ℓ ′ &lt; ℓ. We prove the claim when m ≤ n/2; the analysis of the other case is symmetric and is omitted. If m ≤ n/2, then m = ℓ ′ . Theorem 3.1 says that with probability at least 2/3,</p><formula xml:id="formula_29">|t X -t| ≤ t X (n -t X ) P + |n -2t X | 4P 2 .</formula><p>Then, if t X ≤ ℓ ′ = m ≤ n/2, and if c is large enough,</p><formula xml:id="formula_30">|t -t X | &lt; √ ℓ ′ n c ℓ ′ n/2/∆ ℓ + n 4(c 2 n/∆ ℓ ) &lt; ∆ ℓ 2 .</formula><p>So t &lt; t X + ∆ ℓ /2 ≤ ℓ ′ + ∆ ℓ /2. At the same time, we also have t ≥ g(t X ), where g(x) is the function</p><formula xml:id="formula_31">g(x) = x - √ xn P - n 4P 2 .</formula><p>We show that g is an increasing function of x for x ≥ ℓ and that g(ℓ) &gt; ℓ -∆ ℓ /2 = ℓ ′ + ∆ ℓ /2, provided c is chosen large enough.</p><p>The derivative of g,</p><formula xml:id="formula_32">g ′ (x) = 1 - √ n 2P √ x</formula><p>is an increasing function of x &gt; 0, and if c is large enough,</p><formula xml:id="formula_33">g ′ (ℓ) ≥ 1 - √ n 2c n/∆ ℓ √ ℓ &gt; 0,</formula><p>since ℓ ≥ ∆ ℓ . So g ′ (x) &gt; 0 for all x ≥ ℓ, and g is increasing for such x. Moreover, if c is large enough, we have It follows from the observations made above, that</p><formula xml:id="formula_34">g(ℓ) = ℓ - √ ℓn P - n 4P 2 &gt; ℓ - ∆ ℓ 2 ,</formula><p>and t ≥ g(t X ) &gt; ℓ -∆ ℓ /2 for all X such that t X ≥ ℓ.</p><p>This completes the proof of the claim.</p><p>Proof of Lemma 3.3: We examine, for every number in the input list, the probability that it is ever selected in step 2 of the algorithm. The expected number of stages is the sum of these probabilities; we show that this sum is O(log N ). We concentrate on the case when ∆ ≤ k ≤ n -∆. The analysis in the other cases is similar.</p><p>Consider any arrangement of the numbers in the input list in sorted order. For -1 ≤ i 0 &lt; k &lt; j 0 ≤ n, let p(l, i 0 , j 0 ) denote the probability that the index of the lth number in the sorted list is ever chosen in step 2 of the algorithm after i = i 0 and j = j 0 . We are interested in bounding p(l, -1, n) for each l in</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>3 below that |r(x)| is bounded by 1 for C ≤ |x| ≤ 1. This implies that r (which is at least 2) is attained within [-C, C]. Note that r is bounded by 4/3 at points a ic separated by at most 2/n in [-C, C]. So there is a point â ∈ [-C, C] at which |r ′ (â)| ≥ n r /6. Applying Fact A.5.2 to r at the point â, we get D = Ω(n) = Ω( m(nm)/∆ ℓ ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Corollary 1.2 now gives us the claimed bound.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 3 . 1 (</head><label>31</label><figDesc>Brassard, Høyer, Mosca, Tapp) There is a quantum black-box algorithm C(Y, P ) that, given oracle access to a boolean function Y = (y 0 , . . . , y n-1 ), and an explicit integer parameter P , makes P calls to the oracle Y and computes a number t ∈ [0, n] such that</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 √</head><label>2</label><figDesc>This polynomial is known as the Chebyshev polynomial of degree d. Note that |T d | is an even function of x, and that |T d (1 + x)| ≤ e 2x+x 2 , for x ≥ 0. Fact A.3 Let p be a polynomial of degree at most d. Then, for |x| &gt; 1, |p(x)| ≤ p • |T d (x)| .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Corollary A. 4</head><label>4</label><figDesc>If p is a polynomial of degree at most d and |p(x)| ≤ c for |x| ≤ a, for some a &gt; 0, then |p(x)| ≤ c |T d (x/a)| for all x with |x| ≥ a.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fact A. 5</head><label>5</label><figDesc>Let p be a polynomial of degree d. Then, for x ∈ [-1, 1],1. (Markov) |p ′ (x)| ≤ d 2 p ; 2. (Bernstein) √ 1x 2 |p ′ (x)| ≤ d p .The next fact, which is a more general version of the Bernstein Inequality for algebraic polynomials, deals with trigonometric polynomials. A trigonometric polynomial t(x) of degree d is a real linear combination of the functions cos ix and sin ix, where i is an integer in the range [0, d]. For a trigonometric polynomial t, we define its norm to be t = max -π≤x≤π |t(x)|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fact A. 6</head><label>6</label><figDesc>Let t be a trigonometric polynomial of degree d. Then, for x ∈ [-π, π], t ′ (x) ≤ d t .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>4 ; 2 .</head><label>42</label><figDesc>2 n/∆ ℓ ) &lt; ∆ ℓ if ℓ ′ &gt; ∆ ℓ , then ℓ = ℓ ′ + ∆ ℓ &lt; 2ℓ ′ ,and ℓ ′ ≤ ∆ ℓ , then ℓ ≤ 2∆ ℓ , and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Any quantum black-box algorithm that computes the partial boolean function f ℓ,ℓ ′ , given the input as an oracle, makes Ω( n/∆ ℓ + m(nm)/∆ ℓ ) queries.</figDesc><table><row><cell>1.1, when combined</cell></row><row><cell>with a characterization due to Beals et al. (Lemma 4.2 of [1]) of the probability of acceptance of a quantum</cell></row><row><cell>algorithm on a boolean input oracle, in terms of polynomials, gives us the following result.</cell></row><row><cell>Corollary 1.2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Theorem 1.13 Any quantum back-box algorithm that solves the ǫ-approximate relative count problem makes</figDesc><table><row><cell>Ω</cell><cell>n ⌈ǫ(t + 1)⌉</cell><cell>+</cell><cell>t(n -t) ⌈ǫ(t + 1)⌉</cell></row><row><cell>queries on inputs with t ones.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Lov Grover for stimulating discussions, Michele Mosca for sending us a copy of <ref type="bibr" target="#b13">[14]</ref> and explaining the details of the exact counting algorithm therein, and Umesh Vazirani for his guidance and useful suggestions.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Part of this work was done when the first author was at the 1998 Elsag-Bailey -I.S.I. Foundation research meeting on quantum computation. . Supported by JSEP grant FDF 49620-97-1-0220-03-98. Supported by an NDSEG Fellowship.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Lemma 2.8 Let k, ∆ be integers such that 0 &lt; ∆ ≤ n/4 and 0 ≤ k ≤ 2∆. Then, the quantum query complexity of f 0,k+∆ is Ω( n/∆ + k(nk)/∆). The same bound holds for f k-∆,n if k ≥ n -2∆.</p><p>Proof: We prove the first part of the lemma; the other part follows by symmetry. In applying Corollary 1.2, we have ∆ ℓ = k + ∆ ≤ 3∆, and m = 0. Hence, we get a bound of Ω( n/∆) for f 0,k+∆ . For the lemma to hold, we need only show that the second term in the claimed lower bound is of the order of the first term: k(nk)/∆ ≤ (2∆)n/∆ = O( n/∆).</p><p>We now prove the rest of the lower bound theorems of Section 1.2 by exhibiting reductions from suitable problems. We first consider the problem of estimating the kth-smallest element.</p><p>Proof of Theorem 1.5: We need only prove the bound when ∆ ≤ n/4, since it holds trivially otherwise. We assume that ∆ is integral. The same proof works with ⌈∆⌉ substituted for ∆ for general ∆.</p><p>Note that the query complexity of computing f ℓ,ℓ ′ is the same as that of computing f n-ℓ,n-ℓ ′ , since we may negate the oracle responses in an algorithm for the former to get an algorithm for the latter, and vice-versa. We now consider two cases:</p><p>Case (a). 2∆ &lt; k &lt; n -2∆. Any algorithm for computing a ∆-approximate kth-smallest element clearly also computes f n-k+∆,n-k-∆ , and hence, by Lemma 2.7 and the observation above makes at least Ω( n/∆ + k(nk)/∆) queries.</p><p>we reduce from the function f n,n-k-∆ to our problem. Lemma 2.8 along with the observation above now gives us the required bound. Similarly, for k ≥ n -2∆, we reduce from f n-k+∆,0 and get the bound. This completes the proof of the theorem.</p><p>Since the problem of approximating the median is really a special case of the more general problem of estimating the kth-smallest element, we get a lower bound for this problem as well.</p><p>Proof of Corollary 1.6: For n odd, an ǫ-approximate median is a ∆-approximate kth smallest element for k = (n + 1)/2, and ∆ = ⌈(ǫn + 1)/2⌉. The lower bound of Ω(1/ǫ) now follows from Theorem 1.5.</p><p>The lower bounds for estimating the median and the kth-smallest element continue to hold in the comparison tree model, since any comparison between two input numbers (which is made by querying a comparison oracle in this model) can be simulated by making at most 4 queries to an oracle of the sort we consider above.</p><p>The proofs for the lower bounds for approximate counting is similar to that of Theorem 1.5 above; we only sketch them here.</p><p>Proof of Theorem 1.11: We may assume that ∆ ≤ n/6, since the lower bound is trivial otherwise. Consider any algorithm that approximately counts to within an additive error of ∆. Fix any 0 ≤ t ≤ n. Suppose for any input X with |X| = t, the algorithm outputs a ∆-approximate count after T queries with probability at least 2/3. We then consider the truncated version of the algorithm which stops after making T queries and outputs 1 if the approximate count obtained (if any) lies in the range (t -∆, t + ∆) and 0 otherwise. Since the original algorithm approximates to within ∆ for all inputs, the truncated algorithm computes f t,t+⌈2∆⌉ and/or f t,t-⌈2∆⌉ whenever these partial functions are well-defined (i.e., when t + 2∆ ≤ n and/or t -2∆ ≥ 0). Now, by considering the four cases t ≤ 4∆, nt ≤ 4∆, 4∆ &lt; t ≤ n/2 and n/2 &lt; t &lt; n -4∆ separately, and reducing from a suitable partial function (out of f t,t+⌈2∆⌉ and f t,t-⌈2∆⌉ ) in each of these cases, we get the claimed lower bound.</p><p>with probability at least 2/3.</p><p>Let X be the input to the distinguisher D, and let m and ∆ ℓ be defined as in Section 1.2. Further, let P = c( n/∆ ℓ + m(nm)/∆ ℓ ) , where c is a constant to be determined later, and let t = C(X, P ). The algorithm D(X, ℓ ′ , ℓ) returns 0 if t &lt; ℓ ′ + ∆ ℓ /2 and 1 otherwise. The correctness of the algorithm follows from the claim below; its optimality is clear from the choice of P . Claim 3.2 With probability at least 2/3, if t X ≤ ℓ ′ , then t &lt; ℓ ′ + ∆ ℓ /2, and if t X ≥ ℓ, then t &gt; ℓ ′ + ∆ ℓ /2.</p><p>We give the proof of this claim in Appendix B. We will see in the next section that this distinguishing capability of D also allows us to search for an element of a desired rank nearly optimally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Approximating the kth-smallest element</head><p>Consider the problem of approximating the the kth-smallest element in the black-box model. Recall that when provided with a list X = (x 1 , . . . , x n-1 ) of numbers as an oracle, and an explicit parameter ∆ &gt; 1/2, the task of is to find an input number x i (or the corresponding index i) such that x i is a jth-smallest element for a j ∈ (k -∆, k + ∆). Notice that we may round ∆ to ⌈∆⌉ without changing the function to be computed. We therefore assume that ∆ is an integer in the sequel.</p><p>The description of the function to be computed in terms of ranks of numbers in the input list needs to be given carefully, since there may be repetition of numbers in the list. To accommodate repetitions, we let rank(x i ) denote the set of positions j ∈ {1, . . . , n} at which x i could occur when the list X is arranged in non-decreasing order. A ∆-approximate kth-smallest element is thus a number x i such that rank</p><p>In this section we give a near optimal quantum black-box algorithm for computing a ∆-approximate kthsmallest element. No non-trivial algorithm was known for this problem for general k. Our algorithm is inspired by the minimum finding algorithm of Dürr and Høyer <ref type="bibr" target="#b7">[8]</ref>, and builds upon the general search algorithm of Boyer et al. <ref type="bibr" target="#b3">[4]</ref> and the distinguisher of the last section obtained from the approximate counting algorithm of Brassard et al. <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b5">6]</ref>. To compute an ǫ-approximate median within the bound stated in Corollary 1.8, one only has to run this algorithm with the parameters k and ∆ chosen appropriately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An abstract algorithm</head><p>We first present the skeleton of our algorithm using two hypothetical procedures S(• , •) and K(•). For convenience, we define x -1 = -∞, and x n = ∞. The procedure S(i, j) returns an index chosen uniformly at random from the set of indices l such that x i &lt; x l &lt; x j , if such an index exists. The procedure</p><p>Our algorithm, which we refer to as A(S, K), performs a binary search on the list of input numbers with a random pivot using S and K. It thus has the following form:</p><p>2. l ← S(i, j).</p><p>3. If K(l) returns 'yes', output x l (and/or l) and stop.</p><p>Else, if K(l) returns '&lt;', i ← l, go to step 2.</p><p>Else, if K(l) returns '&gt;', j ← l, go to step 2.</p><p>Call an execution of steps 2 and 3 a stage. This algorithm always terminates and produces a correct solution within n -2∆ + 2 stages. However, the following lemma tells us that the expected number of stages before termination is small. Let N = n/∆ + k(nk)/∆.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.3</head><p>The algorithm A(S, K) terminates with success after an expected O(log N ) number of stages.</p><p>We defer the proof of this lemma to Appendix B. Note that the lemma guarantees that, with probability at least 3/4, the algorithm A(S, K) terminates within O(log N ) stages.</p><p>We now consider the behaviour of the algorithm A when the (deterministic) procedure K(•) is replaced by a randomized subroutine K ′ (•) with the following specification. On input i (for some 0 ≤ i &lt; n):</p><p>• else, if rank(x i ) is at least k -∆ + 1 and at most k -∆/2, probabilistically output either 'yes' or '&lt;';</p><p>• else, if rank(x i ) is at least k + ∆/2 and at most k + ∆ -1, probabilistically output either 'yes' or '&gt;'.</p><p>The algorithm A(S, K ′ ) obtained by replacing the subroutine K(•) by K ′ (•) clearly also always computes a correct solution. Although it may require more iterations of steps 2 and 3 to arrive at a solution, we show that the increase is by at most a constant factor. Lemma 3.4 Let X be any input oracle. The expected number of stages of the algorithm A(S, K ′ ) with oracle X and parameter ∆ is at most the expected number of stages of A(S, K) on inputs X and ∆/2. Appendix B contains a proof of this lemma. In light of Lemma 3.3, this implies that A(S, K ′ ) also terminates after an expected O(log N ) number of stages.</p><p>Finally, we analyse the behaviour of the algorithm A(S, K ′ ) when the procedures S and K ′ are allowed to either report failure or output an incorrect answer with some small probability. As mentioned above, we may restrict the number of stages of the algorithm to O(log N ) and yet achieve success with probability at least 3/4. Now, if any of S or K ′ fails (or errs) with probability o(1/ log N ), the net probability of success will still be at least, say, 2/3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A realization of the algorithm</head><p>We are now ready to spell out the implementation of the two procedures S and K ′ out of which the algorithm is built.</p><p>The subroutine S is derived from the generalized search algorithm of Boyer et al. <ref type="bibr" target="#b3">[4]</ref>, which enables us to sample uniformly from the set of ones of a boolean function. Theorem 3.5 (Boyer, Brassard, Høyer, Tapp) There is a quantum black-box algorithm with access to a boolean oracle Y = (y 0 , . . . , y n-1 ) that makes O( n/t ) queries and returns an index i chosen uniformly at random from the set {j : y j = 1} with probability at least 2/3 if |Y | ≥ t.</p><p>Note that the success probability of the procedure described above may be amplified to 1 -2 Ω(T ) by repeating it at most O(T ) times, and returning a sample as soon as a 'one' of Y is obtained. It can easily be verified that a sample so generated has the uniform distribution over the ones of Y . The procedure S(i, j) is implemented by defining a boolean function Y = (y 0 , . . . , y n-1 ) by y l = 1 if and only if x i &lt; x l &lt; x j , and using the above sampling procedure. Every time S is invoked in A, there are at least Ω(∆) ones in Y , and hence this implementation meets the targeted specification if the parameter t in Theorem 3.5 is chosen to be Ω(∆), and the number of repetitions T of the sampler is chosen to be Θ(log log N ). Each "query" to the function Y requires two queries to the input oracle X. Our sampling procedure thus makes O( n/∆ log log N ) queries and succeeds with probability 1o(1/ log N ).</p><p>The subroutine K ′ (i) is implemented by using the dintinguisher D of Section 3.1 to detect whether x i has rank that is "far" from k or not, by looking at both, the number of elements smaller, and the number of elements larger than it. The probability of correctness of D may be boosted to 1 -2 Ω(T ) by repeating the algorithm O(T ) times, and returning the majority of the answers so obtained. We require that the probability of error of our implementation be o(1/ log N ), so we take T to be Θ(log log N ). The detailed description the implementation follows:</p><p>Define a boolean function Y over a domain of size n, with y j = 1 if and only if x j &lt; x i . If the distinguisher D(Y, t 0 , t 1 ) returns '0', go to step 2. Else, output '&gt;'.</p><p>2. If k -∆ &lt; 0, return 'yes', otherwise continue. Let t 0 = n -⌊k -∆/2⌋ -1, and t 1 = nk + ∆. Note that we again have 0 ≤ t 0 &lt; t 1 ≤ n. Define a boolean function Y over a domain of size n, with y j = 1 if and only if x j &gt; x i . If the distinguisher D(Y, t 0 , t 1 ) returns '0', output 'yes'. Else, output '&lt;'.</p><p>It is easy to verify that this meets the specification for K ′ with probability 1o(1/ log N ), and that it makes O(N log log N ) queries to the oracle X.</p><p>By Lemma 3.4, we conclude that the total number of queries made to the oracle is O(N log(N ) log log N ), as claimed in Theorem 1.7. Observe that our implementation of S and K ′ uses only comparisons between the inputs numbers, and thus may be adapted to work in the comparison tree model as well, with the same bound on the number of oracle queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Optimal approximate counting</head><p>Recall from Section 1.2 that the problem of computing a ∆-approximate count consists of computing a number in [0, n] which is within an additive error of ∆ from the number of ones t X of a given boolean oracle input X = (x 0 , . . . , x n-1 ).</p><p>The algorithm we propose is entirely analogous to the exact counting algorithm of Brassard et al. <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b5">6]</ref>, and we give only a sketch of it here. The algorithm consists of first invoking the procedure C(X, P ) of Theorem 3.1 a few times (say, five times), with P = c n/∆ (for some suitable constant c), and getting an estimate t by taking the median of the approximate counts returned by C. With high (constant)</p><p>A Some properties of polynomials</p><p>In this section, we present some properties of polynomials and define some concepts that we will use for our results.</p><p>The symmetrization p sym of a multivariate polynomial p(x 0 , . . . , x n-1 ) is defined to be p sym (x 0 , . . . , x n-1 ) = π∈Sn p(x π(0) , . . . , x π(n-1) ) n! , where S n is the set of permutations on n symbols.</p><p>If p is a multilinear polynomial of degree d, then p sym is also a multilinear polynomial of degree d.</p><p>Clearly, p sym is a symmetric function. The following fact attributed to Minsky and Papert <ref type="bibr" target="#b12">[13]</ref> says that there is a succint representation for p sym as a univariate polynomial.</p><p>Fact A.1 If p : R n → R is a multilinear polynomial of degree d, then there exists a polynomial q : R → R, of degree at most d, such that q(x 0 +</p><p>In the remainder of this section, we will deal only with univariate polynomials over the reals.</p><p>The properties of polynomials that we use involve the concept of the uniform or Chebyshev norm of a polynomial (denoted by p , for a polynomial p), which is defined as follows: p = max -1≤x≤1 |p(x)|.</p><p>We will refer to the uniform norm of a polynomial as simply the norm of the polynomial.</p><p>The first property we require is a bound on the value of a polynomial in an interval, given a bound on its values at integer points in the interval. ) Suppose l ≤ k -∆. We get the following recurrence by considering the result of the first invocation of S after i = i 0 , j = j 0 :</p><p>(The inequality is due to the fact that there may be repetitions of numbers in the input list.) Furthermore, p(l, l -1, k + ∆) ≤ 1/(k + ∆l). By induction, we now get p(l, i 0 , j 0 ) ≤ 1 k + ∆l for all -1 ≤ i 0 &lt; l ≤ k -∆ and k + ∆ ≤ j 0 ≤ n. Similarly, when l ≥ k + ∆, we get p(l, i 0 , j 0 ) ≤ 1 l + ∆k for all -1 ≤ i 0 ≤ k -∆ and k + ∆ ≤ l &lt; j 0 ≤ n. The expected number of stages is thus bounded by Proof of Lemma 3.4: Call a sequence of elements generated by some choice of random coin tosses of the procedure S in an execution of the algorithm A(S, K) or A(S, K ′ ) till termination, a run. We compare runs of the algorithm A(S, K ′ ) with parameter ∆ with the runs of the algorithm A(S, K) with parameter ∆/2. Observe that when we condition on a set of decisions D of K ′ for every input index, each run of A(S, K ′ ) is also a prefix of runs of A(S, K), that the sum of the probabilities of the occurrence of the runs of A(S, K) of which a particular run of A(S, K ′ ) is a prefix, is equal to the probability of the occurrence of that run of A(S, K ′ ), and, finally, that exactly one prefix of any run of A(S, K) is consistent with the set of decisions D we condition on. A straightforward calculation of the expected length of a run of A(S, K ′ ) now gives us the required bound.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Quantum lower bounds by polynomials</title>
		<author>
			<persName><forename type="first">R</forename><surname>Beals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Buhrman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cleve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mosca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th Annual IEEE Symposium on Foundations of Computer Science</title>
		<meeting>the 39th Annual IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Strengths and weaknesses of quantum computing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Vazirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1510" to="1523" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Time bounds for selection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="448" to="461" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tight bounds on quantum searching</title>
		<author>
			<persName><forename type="first">M</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Høyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tapp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Forschritte Der Physik</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="493" to="505" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Quantum counting</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Høyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tapp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Colloquium on Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 25th International Colloquium on Automata, Languages and Programming</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1443</biblScope>
			<biblScope unit="page" from="820" to="831" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Quantum amplitude amplification and estimation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Høyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mosca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tapp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Quantum vs. classical communication and computation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Buhrman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cleve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 30th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="63" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A quantum algorithm for finding the minimum</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Høyer</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/quant-ph/9607014" />
	</analytic>
	<monogr>
		<title level="m">Quantum Physics e-Print archive</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A limit on the speed of quantum computation in determining parity</title>
		<author>
			<persName><forename type="first">E</forename><surname>Farhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Goldstone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gutmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/quant-ph/9802045" />
	</analytic>
	<monogr>
		<title level="m">Quantum Physics e-Print archive</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A fast quantum mechanical algorithm for database search</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Grover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM Symposium on Theory of Computing</title>
		<meeting>the 28th ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="212" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A fast quantum mechanical algorithm for estimating the median</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Grover</surname></persName>
		</author>
		<ptr target="http://xxx.lanl.gov/abs/quant-ph/9607024" />
	</analytic>
	<monogr>
		<title level="m">Quantum Physics e-Print archive</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A framework for fast quantum mechanical algorithms</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Grover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 30th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="53" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Minsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Papert</surname></persName>
		</author>
		<author>
			<persName><surname>Perceptrons</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Quantum searching, counting and amplitude amplification by eigenvector analysis. Proceedings of the Workshop on Randomized Algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mosca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the degree of polynomials that approximate symmetric boolean functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Paturi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 24th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="468" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Rational approximation of real functions</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Petrushev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Popov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The Chebyshev polynomials</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Rivlin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">U</forename><surname>Vazirani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
