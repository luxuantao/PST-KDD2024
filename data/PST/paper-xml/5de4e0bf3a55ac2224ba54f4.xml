<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GraphZero: Breaking Symmetry for Efficient Graph Mining</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2019-11-28">28 Nov 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
							<email>dmawhirt@mymail.mines.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Colorado School of Mines</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts at Amherst</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sam</forename><surname>Reinehr</surname></persName>
							<email>swreinehr@mymail.mines.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Colorado School of Mines</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts at Amherst</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Connor</forename><surname>Holmes</surname></persName>
							<email>cholmesd@mymail.mines.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Colorado School of Mines</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts at Amherst</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tongping</forename><surname>Liu</surname></persName>
							<email>tongping@umass.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Colorado School of Mines</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts at Amherst</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Colorado School of Mines</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts at Amherst</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">GraphZero: Breaking Symmetry for Efficient Graph Mining</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2019-11-28">28 Nov 2019</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1911.12877v1[cs.PF]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph mining for structural patterns is a fundamental task in many applications. Compilation-based graph mining systems, represented by AutoMine, generate specialized algorithms for the provided patterns and substantially outperform other systems. However, the generated code causes substantial computation redundancy and the compilation process incurs too much overhead to be used online, both due to the inherent symmetry in the structural patterns.</p><p>In this paper, we propose an optimizing compiler, GraphZero, to completely address these limitations through symmetry breaking based on group theory. GraphZero implements three novel techniques. First, its schedule explorer efficiently prunes the schedule space without missing any high-performance schedule. Second, it automatically generates and enforces a set of restrictions to eliminate computation redundancy. Third, it generalizes orientation, a surprisingly effective optimization that was mainly used for clique patterns, to apply to arbitrary patterns. Evaluated on multiple graph mining applications and complex patterns with 7 real-world graph datasets, GraphZero demonstrates up to 40X performance improvement and up to 197X reduction on schedule generation overhead over AutoMine.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Graph data is ubiquitous and used in numerous domains thanks to its flexibility. Graph mining searches for structural patterns in large-scale graphs, which is important for Bioinformatics <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b44">45]</ref>, social networks <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b46">47]</ref>, fraud detection <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b10">11]</ref>, and so on. Triangle counting represents a simple graph mining task, where the pattern is a triangle and the goal is to count all its instances in an input graph. While triangle counting is much more costly to solve than many graph traversal problems, mining larger patterns (e.g., size-5 cliques) involves even more complex algorithms and may need hours or days to finish.</p><p>Graph mining has attracted significant attention in the data analytics community. A common approach is to design efficient algorithms for individual patterns <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b50">51]</ref>. IEEE, Amazon and MIT organize an annual challenge to rank the submitted implementations for triangle counting <ref type="bibr">[1]</ref>. However, this approach is not scalable for general graph mining as there exist too many patterns of dramatically varying structures. Moreover, the number of patterns increases exponentially in the pattern size. For example, there exist 112 size-6 patterns but 853 size-7 patterns.</p><p>Many software systems have been proposed to mine arbitrary patterns <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b49">50]</ref>. Despite their generality, these systems usually have poor performance due to two reasons. First, they implement a generic algorithm that handles arbitrary patterns but does not perform particularly well for any of them. It is why manual implementations of specialized algorithms for specific patterns are still popular. Second, they need to run some kind of isomorphism testing online to verify whether a produced embedding matches the pattern of interest, which may incur substantial overhead for non-trivial patterns.</p><p>The compilation approach for graph mining has unique advantages as shown by systems like EmptyHeaded <ref type="bibr" target="#b3">[4]</ref>, Graph-Flow <ref type="bibr" target="#b20">[21]</ref> and AutoMine <ref type="bibr" target="#b30">[31]</ref>. They generate specialized algorithms for the given pattern and compile them to efficient low-level code. The code has a nested-loop structure, each growing the embedding by one vertex towards the pattern through set operations on the neighbor lists (e.g, set intersection). If an embedding is identified by the innermost loop, it guarantees to match the pattern and avoids online isomorphism testing.</p><p>AutoMine represents the state of the art for compilationbased graph mining systems and often substantially outperforms other systems. But it has three problems. The first problem is that its generated code incurs significant computation redundancy because it may identify the same instance multiple times. For a size-7 chordal cycle, which is a clique with one absent edge, AutoMine identifies each of its embeddings 120 times. The second problem is AutoMine's slow compilation speed. Provided with a pattern, AutoMine uses a brute-force approach to enumerate all possible schedules. As a result, its search algorithm may unnecessarily traverse schedules that generate the same code. If used as an offline compiler, the compilation overhead may be acceptable especially because most real-world applications only mine small patterns. But it may be problematic if AutoMine is used as a just-in-time compiler for dynamic queries where the overhead lies on the critical path. Finally, AutoMine, as well as other graph mining systems, can only apply the orientation optimization <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b41">42]</ref> to clique patterns, which only allows edge traversals from lower-degree vertices to higher-degree vertices. However, it is one of the most effective optimizations for graph mining. Triangle counting, for instance, enjoys up to tens of times performance improvements from this technique alone <ref type="bibr" target="#b38">[39]</ref>.</p><p>Addressing the three problems faces substantial challenges. First, patterns and their inner structures have symmetry. Consider the rectangle pattern. All four vertices are initially equivalent due to the four-way rotational symmetry. After fixing one vertex, there is still a two-way mirrored symmetry between the two vertices attached to the first, leading to a total multiplicity of 8. The symmetry leads to different ways to map the pattern to the vertices in the graph. However, the set operations can only recognize the topology and are hence not sufficient to break symmetry. Second, the schedule space can be enormous, and different schedules may produce programs that differ dramatically in performance. Although we can naively prune the schedule space by setting an upper bound on the number of explored schedules, this may miss highly performant schedules. Third, the orientation optimization can be applied to clique patterns because they are perfectly symmetric, meaning that any pair of vertices can be exchanged yet still preserving the pattern. Most patterns do not have this property, so it is unclear whether they can also benefit from this optimization.</p><p>In this paper, we present GraphZero, an optimizing compiler for graph mining that systematically addresses these challenges based on symmetry breaking using group theory. GraphZero contains three key components: a schedule explorer, a redundancy optimizer, and an orientation optimizer. Given the patterns of interest, the schedule explorer can search for an optimized schedule in a few milliseconds. The redundancy optimizer automatically generates a set of restrictions for the found schedule and enforces the restrictions on it to completely eliminate computation redundancy. The orientation optimizer successfully generalizes the application of the orientation optimization to arbitrary patterns.</p><p>The fundamental idea for GraphZero to break symmetry is to use more than the topology information, such as vertex IDs. We observe that the different ways to identify the same embedding are essentially automorphisms, which are isomorphisms from the instance to itself. The number of automorphisms determines the degree of redundancy. By enforcing a set of automatically generated restrictions between discovered vertices, GraphZero reduces the number of automorphisms to one. Consequently, the generated code identifies each instance exactly once. GraphZero extends this idea to schedule pruning and only discovers one of the schedules that correspond to the same automorphism group. It does not miss the optimal schedule because all these schedules order the set operations in the same way and hence have the same performance. Finally, GraphZero enjoys a byproduct of the enforced restrictions, which is that for each restriction it can also restrict an edge traversal order and thus generalizes the orientation optimization.</p><p>We have extensively evaluated all the three components of GraphZero by comparing it with AutoMine on 7 realworld graphs of different scales. Our experimental results show that GraphZero achieves up to 8X, 10X, 22X, and 40X performance improvements for Motif-4 counting, Motif-5 counting, Pentagon mining and size-7 chordal cycle mining. We observe that the more complex the pattern is, the more benefit GraphZero provides. GraphZero generates highperformance schedules up to 197X faster for multiple complex patterns. Moreover, GraphZero's generalized orientation optimization produces up to 40x performance improvement over AutoMine on non-clique patterns.</p><p>We make the following contributions in this paper: 1) We reveal that the inherent symmetry in graph patterns is the fundamental reason for both AutoMine's computation redundancy and its slow compilation speed; 2) We propose to use group theory to break symmetry through automatically generated and enforced restrictions, which not only completely eliminates redundancy in the generated code but also substantially prunes the schedule search space; 3) We generalize the orientation optimization to arbitrary patterns by leveraging the generated restrictions; 4) We present an optimizing compiler that integrates the proposed techniques to substantially outperform AutoMine with a much faster compilation speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Motivation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">AutoMine basics</head><p>The AutoMine <ref type="bibr" target="#b30">[31]</ref> system introduces a topological compiler for graph mining. Unlike the general graph mining systems that preceded it <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b43">44]</ref>, AutoMine uses an offline compilation process to analyze the given pattern and generate code to identify all its instances in an input graph. Interestingly, the paper shows that any arbitrary connected pattern can be identified by a series of set intersection and set subtraction operations called a schedule. This set-centric representation turns out to be powerful and substantially reduces memory consumption compared with other systems, leading to hundreds of times performance improvements over other systems for many patterns and real-world graphs.</p><p>Figure <ref type="figure" target="#fig_2">1</ref> (a) demonstrates the basic workflow of AutoMine. Given a pattern of interest (i.e., a rectangle in the example), it assigns a distinct label to each of the vertices in the pattern represented by {A, B, C, D}. AutoMine then generates a colored complete graph (i.e., the logical pattern) with existing edges in black and absent edges in red. AutoMine then produces a discovery sequence of the labeled vertices, making sure that any vertex in the sequence except the first one is connected to at least one earlier vertex through a black edge. A schedule can then be naturally generated following this sequence with black edges encoded by set intersections    and red edges encoded by set subtractions. For example, D is connected to both B and C through black edges and A through a red edge, AutoMine understands that D should be in the intersection of B's and C's neighbor sets but not in A's neighbor set. Finally, AutoMine compiles the schedule into a nested loop structure, the inner-most loop of which identifies the instances of the pattern. Since the discovery sequence determines a schedule, we use a total order on the label set to represent the schedule. For example, the schedule shown in Figure <ref type="figure" target="#fig_2">1</ref> (a) can be represented by (A, B, C, D).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Problems and Challenges</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Computation redundancy</head><p>Every graph mining system needs a way to test isomorphism, that is, determine what pattern a particular subgraph matches. AutoMine embeds the isomorphism test in the generated code itself, using the nested loop structure to filter embeddings down to those that match the desired structural pattern. Doing so discovers the vertices in a particular order, what we call a mapping from the pattern's labeled vertices to the embedded vertices in the graph. However, for the same embedding AutoMine may map the label set to its vertices in different ways. Figure <ref type="figure" target="#fig_11">1 (b)</ref> shows that there exists eight different mappings for a rectangle instance, leading to eight times over-counting (also called multiplicity) and computation redundancy.</p><p>AutoMine partially solves the problem by introducing the concept of root symmetry. It checks whether a schedule's first two vertices are equivalent and if so only processes that first "root" edge in one direction. For many patterns, this successfully cuts the computation redundancy in half. However, as Figure <ref type="figure" target="#fig_4">2</ref> shows, the number of possible mappings explodes with the number of vertices in the pattern. Ideally, the system should only identify each instance exactly once and so completely eliminate computation redundancy.</p><p>Challenges The scheduling approach of AutoMine is fundamentally unequipped to handle this multiplicity problem. All the mappings correspond to the same topology and cannot be differentiated by only set operations. As such, the symmetries in a pattern induce the same multiplicity in any possible schedule for that pattern. The symmetry may express itself in different ways in different schedules, as the vertices that can satisfy a particular mapping depend on  both the schedule and the previously explored vertices. This diversity is a key reason the problem is both challenging to handle and valuable to solve. Our approach must find all the symmetries and a way to break them to make the mapping unique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Brute-force Schedule Generation</head><p>AutoMine uses a naive approach to schedule generation. It first enumerates all the possible schedules and removes infeasible ones (i.e., there exists a vertex in the discovery sequence which is not connected to any previous vertex through a black edge). A performance model then evaluates all of the feasible schedules and selects a final one. This process is inefficient because many schedules generate the same code and thus have the same performance. AutoMine takes over 147 seconds to generate schedules for 7-vertex motif counting. When used as a just-in-time compiler, this latency can be problematic because the schedule search overhead lies on the critical path.</p><p>Challenges The compilation process introduces a chickenand-egg problem: we want to avoid an exhaustive search of the scheduling space while still exploring all the relevant points, but we do not know the relevant points until after exploring the space. We can run isomorphism testing to filter out schedules that produce the same code, but the testing itself involves an exponential algorithm. Moreover, estimating the performance of schedules is more complex if we want to reduce the computation redundancy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Generalization of Orientation Optimization</head><p>Orientation is a popular optimization for triangle counting <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b41">42]</ref>. By only allowing higher-degree vertices to be discovered after lower-degree vertices to form triangles, the optimization effectively prunes half of the edges (i.e., the ones from higher-degree vertices to lower-degree vertices) but still preserves the structure of all triangle embeddings. But it can achieve significant speedups much larger than 2X because the time complexity of triangle counting grows super-linearly with the maximum degree. AutoMine observes that the clique pattern is perfectly symmetric and can hence enforce an order to discover the vertices in each embedding from low to high degree. It can then apply the orientation optimization to any-size clique pattern. However, most patterns are not perfectly symmetric and cannot enjoy the benefit from the orientation optimization in AutoMine.</p><p>Challenges Generalizing the orientation optimization to cover arbitrary patterns is difficult. Enforcing an order for vertex discovery based on degree conceptually prunes edges from the graph data. Doing so may miss embeddings of interest because it may be necessary to discover a vertex from a higher-degree vertex but the edge is not present. While manual application of the optimization for specific patterns is possible, automating it in a compiler entails a systematic approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Overview of GraphZero</head><p>The overall workflow of GraphZero has four stages as shown in Figure <ref type="figure" target="#fig_5">3</ref>. Taking a pattern as the input, the schedule explorer searches only part of the schedule space while guaranteeing that the optimal schedule is discovered. Based on a performance model, the schedule explorer estimates the performance of the searched schedules and produces a highperformance schedule for the redundancy optimizer. The redundancy optimizer then generates a set of restrictions and enforces them on the schedule to perform redundancy-free computation. The orientation optimizer, which is optional, reindexes the vertices in the input graph based on decreasing degree and leverages the generated restrictions to conceptually prune the corresponding edges from higher-degree to lower-degree vertices while keeping the entire graph. Finally, the optimized schedule can run on the reindexed graph to mine the input pattern. Although the discussion focuses on one pattern for simplicity, if provided multiple patterns GraphZero merges the schedules to only generate one mining program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Redundancy-Free Code Generation</head><p>We delay the discussion of schedule generation to the next section because the insights from this section will be needed to accelerate that process. In this section, we first explain the essential reason for computation redundancy and build the connection between redundancy and automorphisms, which is the key concept from group theory to address the problem.</p><p>We next describe the approach to completely eliminating computation redundancy through automatically generated and enforced restrictions, followed by a method to minimize the overhead to implement the restrictions in the generated schedule. Finally, we show what the output looks like with and without these restrictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Computation Redundancy and Automorphism</head><p>The computation redundancy problem caused by over-counting roots from the symmetry in the pattern. For example, given an embedding of the rectangle pattern, each of the four vertices in the embedding can be indistinguishably mapped to the first label in the schedule. Once the first vertex in the embedding is mapped, both its neighbor vertices can be mapped to the second label of the schedule. The multiplicative mapping choices result in the eight times over-counting. Note that selecting a better schedule does not solve the problem because the symmetry cannot be broken by only set operations.</p><p>A mapping represents a one-to-one relationship between the labels in the pattern and the vertices in the embedding. If we give a total ordering to the embedding vertices, each mapping can be represented by a total ordering of the labels. Consider the example in Figure <ref type="figure" target="#fig_2">1</ref>. We have (A, B, C, D) to denote the schedule, so a total ordering of the embedding vertices can be (2, 3, 8, 7). The mapping from (A, B, C, D) to (2, 8, 3, 7) can then be represented by the total ordering of the labels: (A, C, B, D). We call a total ordering of the labels that corresponds to a mapping a valid ordering. Not all total orderings correspond to a mapping. For instance, (A, C, D, B) is not a valid ordering because C and D are connected in the pattern, but the embedding vertices 3 and 8 are not.</p><p>Each valid ordering is essentially a permutation of the total ordering representing the schedule<ref type="foot" target="#foot_0">1</ref> . Each such permutation function is called an automorphism in group theory, which is an isomorphism from the pattern to itself and hence preserves the structure of the pattern. If an automorphism repositions a label A to the original position of another label B (e.g., (A, B, C, D) ‚Üí (B, A, C, D)), we say that the automorphism moves A to B for simplicity. All the automorphisms for the same pattern form an automorphism group. The size of the automorphism group determines the number of times for over-counting. Ideally, we want to reduce the size of the group to one to completely eliminate computation redundancy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Breaking Symmetry through Restrictions</head><p>The key idea is that we can enforce restrictions on the IDs of the embedding vertices to break the symmetry inherent in the pattern. Vertices are not reused within the same embedding, so there is a natural total ordering on the IDs. Consider the rectangle pattern in Figure <ref type="figure" target="#fig_2">1</ref> again. We have observed that the first label in the schedule can be mapped to any of the four embedding vertices. The restriction we  <ref type="formula">8</ref>, 2, 7, 3) respect the restrictions. We then enforce another restriction that the ID of the second mapped vertex should be larger than that of the third mapped vertex. The end result is that the only way to identify the embedding is through the mapping (A, B, C, D) ‚Üí (8, 7, 2, 3), which completely solves the over-counting problem.</p><p>We make two observations on the example. First, the restrictions are each a transitive binary relation (i.e., larger than) between the IDs of two embedding vertices. Second, we can use a binary ordering relation on the labeled vertices of the pattern to represent the restriction on the embedding vertices. As such, the partial ordering {(A, B), (A, C), (A, D), (B, C)} should be sufficient to generate all restrictions.</p><p>Algorithm 1 generalizes the idea and generates such a partial ordering for an arbitrary pattern with a given schedule. The algorithm at the beginning computes the automorphism group by trying all permutations of the vertex labels and filtering out invalid ones, which do not preserve the pattern. It then iterates through all labeled vertices in the schedule.</p><p>In each iteration, it determines all the labeled vertices indistinguishable from the traversed vertex v after prior partial ordering. For each of of these labeled vertices x(v), which the automorphism x maps v to, the algorithm adds a binary relation (v, x(v)) to the resultant partial ordering. At the end of the for loop, only automorphisms that do not move the traversed vertices are used to generate binary relations for the next traversed vertex.</p><p>The following theorem allows us to use these relations to uniquely discover each embedding exactly once.</p><p>Theorem 1. : For an arbitrary pattern P and its schedule S, let L be the partial ordering on the label set in P generated by Algorithm 1. Given an instance of P, denoted by e, in a graph G there exists exactly one mapping M from P to e if for each binary ordering relation (S[i], S[j]) in L, we add a restriction M(S[i]).id &gt; M(S[j]).id.</p><p>We omit the proof here but include it in the appendix. The proof has two steps. We first show that there is at most one mapping that follows all the restrictions, as otherwise there is a restriction that is not enforced. We then show there is at Aut ‚Üê stabilized_aut least one mapping that satisfies the restrictions, if one exists at all. Algorithm 1 and Theorem 1 demonstrate the possibility to completely remove computation redundancy. Implementing the restrictions in the code generator is trivial. The compiler needs to insert bound checks when generating a for loop as demonstrated in Figure <ref type="figure">4</ref> (a).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Minimizing the Overhead of Enforcing</head><p>Restrictions Figure <ref type="figure">4</ref> (a) shows that when discovering one vertex the code may need to perform multiple checks, which may incur non-trivial overhead especially for large patterns. We want to minimize the number of checks we need to perform to increase performance. For example, within 3(a), the v 0 &lt; v 2 check is made redundant by the v 0 &lt; v1 check and the v 1 &lt; v 2 checks. These correspond to the (A, C),(A, B) and (B, C) relations generated by the schedule, respectively. The following theorem generalizes this process, and shows that we only need to enforce at most one restriction. Hence, it is sufficient to perform at most one check when discovering a new vertex, and we only need to generate the relation corresponding to that check. The proof is available in the appendix. These relations impose restrictions on the IDs. The key intuition arises when assuming that a vertex may be restricted above by two unrestricted vertices, which would require independent checks. The two restrictions imply that both vertices have an automorphism mapping them to the double-restricted vertex, otherwise the restrictions would not exist. This implies the two unrestricted vertices would have an automorphism mapping between them, which implies a restriction between them, breaking the assumption. Therefore, we only need to consider at most one relation bounding above any given vertex.</p><p>We can utilize Theorem 2 to modify Algorithm 1 to store a map of chosen relations. Instead of adding (v, x(v)) as a relation, we set the value in the map for x(v) to be v, representing that the only relation that needs to be checked for x(v) is (v, x(v)). Figure4 (b) shows the generated code for rectangle counting after applying this optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Fast Schedule Generation</head><p>In this section, we first explain the reason schedules of the same pattern have dramatically different performance. We describe the schedule generation algorithm used in Au-toMine and show why it incurs tremendous overhead, followed by the algorithm used in GraphZero's schedule explorer to efficiently prune the search space. We finally present GraphZero's method of estimating performance of schedules bounded with restrictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance Differences</head><p>The performance of different schedules can vary significantly. To illustrate this, we compare two schedules for tailed triangle. As shown in Figure <ref type="figure">5</ref>, the two schedules search for the vertices in [A, B, C, D] and [C, D, B, A] order according to the labels in the diagram. The key difference between these schedules is intuitive: the schedule [C, D, B, A] executes its innermost loop once for each triangle embedding in the graph, while the schedule [A, B, C, D] does it once for every wedge (i.e., a two-edge path). In some of the graphs we evaluate for this paper, wedges may appear over 500X more frequently than triangles. So if the amount of work done inside the innermost loop is comparable, the schedule [C, D, B, A] should have much better performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Brute-Force Schedule Generation</head><p>To avoid missing high-performance schedules, AutoMine takes a conservative approach and tests if each permutation of the labeled vertices is a valid schedule as shown in Algorithm 2. Recall that a schedule is considered valid if each vertex, except for the first, is directly connected to at least one vertex that comes before it. This allows it to be described as a member of a composition of set differences and intersections of the neighbor sets of previous vertices. We can easily improve the schedule generation using Algorithm 3, which recursively searches only valid schedules. However, the algorithm is still inefficient for non-trivial patterns. To understand the complexity of traversing all valid schedules, we consider a path of length n. There are n starting vertices to choose from and picking any vertex except the two end vertices leaves the remaining task as finding the valid schedules for the two sub-paths on the two sides. We omit the proof but just show that there exist a total of 2 n‚àí2 valid schedules. In another example, a clique of n vertices, all n! possible schedules are valid. </p><formula xml:id="formula_0">count ‚Üê count + |s| count ‚Üê count / 2 begin count ‚Üê 0 for ùë£ 0 ‚àà ùëâ do for ùë£ 1 ‚àà ùëÅ ùë£ 0 do for ùë£ 2 ‚àà ùëÅ ùë£ 1 ‚àí ùëÅ ùë£ 0 do s ‚Üê ùëÅ ùë£ 1 ‚à© ùëÅ ùë£ 2 ‚àí ùëÅ ùë£ 0 count ‚Üê count + |s| count ‚Üê count / 2 A B D C C D B A A B C D Figure 5</formula><p>. Tailed triangle counting with two different schedules</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Pruning the Valid Schedule Space</head><p>The vast scheduling space described previously is expensive to search exhaustively, so we need an efficient method to prune the space without missing any potentially highperformance schedule. A key observation we have is based on the clique example. Although it has n! schedules, all of them generate the same sequence of set intersection operations and hence generate the same code. We call such schedules equivalent schedules. If two schedules are not equivalent, we call them distinct schedules. In general, any two schedules are equivalent if and only if there is an automorphism that maps one to the other. As an example, (A, B, C, D) and (A, B, D, C) are equivalent schedules for the tailed triangle in Figure <ref type="figure">5</ref>. Recall that the multiplicity, M, of all valid schedules is the same because it is an inherent property of the pattern. Therefore, if K schedules are valid for a pattern, there exist K/M distinct schedules. The goal of the schedule explorer is to only generate these distinct schedules. Algorithm 4 describes GraphZero's schedule search approach which efficiently prunes the search space without missing high-performance schedules. The optimizations appear in two places: 1) valid schedule generation and 2) equivalent schedule pruning.</p><p>Each recursive invocation of the procedure recursive_–¥enerate tries to include one more vertex into the input schedule until the schedule covers all vertices in the pattern. To avoid generating invalid schedules, after the first vertex has been selected only vertices adjacent to at least one vertex already in the schedule are considered for extending the schedule (lines 9-12,23). These are the vertices contained within valid_next.</p><p>The insight to prune the schedule space is similar to the idea used in Algorithm 1. When extending the partial schedule to include a vertex from valid_next, selecting different vertices may produce equivalent partial schedules due to automorphisms. Algorithm 4 leverages the automorphisms to partition valid_next into disjoint sets, such that for any two vertices x, y in a set, any schedule generated by considering x next is equivalent to one considering y next. This property exists if and only if there is an automorphism remaining that moves x to y. Hence, the algorithm only expands the partial schedule by including the first vertex in each set and marks the rest as processed (line 22). A processed vertex is never considered to extend the partial schedule, thus pruning the schedule space.</p><p>Theorem 3. For a given Pattern, Algorithm 4 generates all distinct schedules, and generates no two equivalent schedules.</p><p>We include the proof in the appendix but show its basic idea. We can consider this proof to have two aspects. The first that no two generated schedules are equivalent is obvious from the first vertex at which they differ. If one of these were processed, it would have marked the other. The second, proving that every distinct schedule is generated, is equivalent to proving that every valid schedule is equivalent to one Algorithm 4 generates. This is understood by noting that every possible trace of Algorithm 3 is equivalent to one of the paths we explore with <ref type="bibr">Algorithm</ref>  it never marks (or prunes) a vertex that does not have an indistinguishable vertex it has included in a partial schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Performance Model</head><p>Now that we have successfully generated all distinct schedules, we need a performance model to select a high-performance schedule. Recall that once a schedule is generated, it is naturally mapped to a nested loop structure with restrictions as explained in Section 4. Figure <ref type="figure">4</ref> (b) shows the nested loop structure with one restriction per nested for loop for rectangle counting. The performance model needs to estimate for each nested for loop 1) the number of iterations and 2) the number of iterations in which the restriction is satisfied. For the third for loop in the example, the performance model should estimate the number elements in N (v 0 ) ‚àí N (v 1 ) and the number of times v 1 &lt; v 2 holds. The absolute numbers depend on the graph because in general the larger the graph is the bigger those numbers are. We therefore build a probabilistic model, assuming n vertices in the graph and a probability p for an edge to exist. For a for loop, given that its number of iterations is determined by k1 set intersections and and k2 set differences, the number of iterations is estimated as np k1+1 (1 ‚àíp) k 2 by assuming that edge edge is equally likely to occur in a set operation.</p><p>Note that given the estimation above, we only need to model the probability of satisfying the restriction. However, it is more difficult because the probability to satisfy the restriction in one for loop depends on the restrictions in all the for loops above it. We therefore model the probability of satisfying all checks up to the restriction of the considered for loop. The exact value of these probabilities is detailed within the appendix. Finally, we sum up the cost of all for loops to estimate the performance of the schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Generalizing Orientation-Based Optimization</head><p>In this section, we first explain why the orientation optimization is important for graph mining and the problems of generalizing it for arbitrary patterns. We then present GraphZero's method to leverage the automatically generated restrictions for the generalization. Orientation optimization enforces an order to discover vertices by only allowing higher-degree vertices being discovered after lower-degree vertices. It works well for triangle counting because every instance of the triangle pattern can be represented by a DAG, starting from the lowest-degree vertex and ending with the highest-degree vertex. The optimization allows pruning all edges from a higher-degree vertex to a lower-degree vertex but still guarantees that every triangle instance can be identified.</p><p>While the optimization only reduces the number of edges to process by a factor of 2, it substantially reduces the neighbor set size of √¢ƒÇƒ≤hot√¢ƒÇƒ∞ vertices, which appear more frequently in patterns. Consider a star topology graph of N + 1 vertices with the center "hot" vertex connected to each of the other vertices. With orientation optimization, its neighbor set becomes empty. But in the original graph, the neighbor set of size N needs to be accessed N times.</p><p>Generalizing the orientation optimization faces two problems. First, the direction of the pruned edge may interfere with the discovery order determined by the schedule. For instance, a restriction of the schedule may require that two mapped vertices v i and v j should satisfy v i .I D &gt; v j .I D, but v i 's degree is larger than v j 's degree. In this case, the pruned edge is necessary for the schedule to discover v j from v i . Second, the orientation optimization must prune edges to </p><formula xml:id="formula_1">N(v 1 ) = N(v 2 ) = 0 90 0 Intersection(N(v 1 ),N(v 2 )) ‚Üí Bounded_Intersection(N(v 1 ),N(v 2 ),V 1 .ID) ‚Üí 0 21 90 V 1 .ID = 1; V 2 .ID = 62</formula><p>Figure <ref type="figure">7</ref>. Bounded Intersection Benefits gain benefit, but the same graph may also be used by other applications which may not work with the modified dataset.</p><p>GraphZero generalizes the orientation optimization on arbitrary patterns without pruning any edge by implementing two techniques. The first technique reindexes the vertices such that the higher-degree vertices must have a smaller ID than that of the lower-degree vertices, as shown in Figure <ref type="figure">5</ref>. It uses the original IDs for tie-breaking when vertices have the same degree. Recall that when GraphZero enforces a restriction (v i .I D &gt; v j .I D), it also respects the discovery order from lower-degree vertices to higher-degree vertices by only allowing v j to be discovered after v i . The second technique extends the set operations to leverage the restrictions for early exit (i.e., reducing the accessed elements in neighbor sets). Given a restriction (v i .I D &gt; v j .I D), when discovering v j we are only interested in the neighbors in v i 's neighbor set whose ID is less than v i .I D. We can hence use v i .I D as a bound to perform the set operations. Because the neighbor sets are stored as sorted lists of integers, a linear scan finds the output vertices in sorted order, and can terminate whenever a bound condition is met. The technique is particularly useful for large-degree vertices as shown in Figure <ref type="figure">7</ref>. After the reindexing, v 1 , a large-degree vertex, has a small ID as 1. If there exists a restriction involving v 1 , the intersection can use v 1 .I D as the bound. In the example, the original intersection needs to traverse all elements in N (v 1 ) while the bounded intersection only traverses three elements in total.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graphs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>#Vertices #Edges Description</head><p>CiteSeer <ref type="bibr" target="#b13">[14]</ref> 3264 4536 Publication citations Wiki-Vote <ref type="bibr" target="#b26">[27]</ref> 7115 100762 Wiki Editor Voting MiCo <ref type="bibr" target="#b13">[14]</ref> 96638 1080156 Co-authorship Patents <ref type="bibr" target="#b27">[28]</ref> 3.8M 16.5M US Patents LiveJournal <ref type="bibr" target="#b6">[7]</ref> 4.8M 42.9M Social network Orkut <ref type="bibr" target="#b1">[2]</ref> 3.1M 117.2M Social network Twitter <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b23">24]</ref> 41.7M 1.2B Social network</p><p>Table <ref type="table">1</ref>. Graph Datasets</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation</head><p>In this section, we evaluate GraphZero and compare it with AutoMine, a state-of-the-art graph mining system that substantially outperforms other systems. The highlights of the results are as follows: 1) For 10 different workloads on realworld graphs, GraphZero is up to 40X faster than AutoMine running on the same system. 2) The compilation time reduction opens up the potential for a just-in-time compilation process with up to 197X speedup over the AutoMine compiler.</p><p>3) The generalized orientation optimization obtains the benefits of AutoMine's clique-specific optimization for arbitrary patterns yielding up to 88.6X speedup.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Methodology</head><p>Experimental Setup Table <ref type="table">1</ref> shows the 7 real-world graphs used in the experiments. AutoMine uses 5 of them to demonstrate that it outperforms prior mining systems including Arabesque <ref type="bibr" target="#b40">[41]</ref> and RStream <ref type="bibr" target="#b43">[44]</ref> by up to 4 orders of magnitude. We hence also use these graphs to experiment with GraphZero. We include Wiki-Vote to observe scalaibility to large patterns and Twitter to evaluate scalability to large graphs. We run experiments on machines with 2 8-core Intel Xeon E5-2670 CPUs (hyperthreading disabled) and 64GB of memory. Each machine runs Red Hat Enterprise Linux 6.9 with Linux kernel version 2.6 and gcc version 4.4.7, which we use with optimization level O3. Figure <ref type="figure">8</ref> shows the 8 patterns we focus on for this evaluation, which range in size from 3 to 7 vertices. We choose cliques of 3 (triangles) and 4 vertices, a near-clique of 7 vertices (missing one edge), cycles of 4 (rectangle) and 5 (pentagon) vertices, then some interesting patterns of 5 and 6 vertices. We also perform motif counting, a popular application used to evaluate many other graph mining systems <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b43">44]</ref>, on up to 5 vertices using aggregate schedules to efficiently count all motifs on a particular number of vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Performance Comparison</head><p>Individual Patterns We run 6 mining applications, corresponding to the non-clique target patterns in Figure <ref type="figure">8</ref>, on the 5 smaller graphs with both AutoMine and GraphZero. This directly showcases the improvements that multiplicity  <ref type="figure">9</ref>, GraphZero outperforms AutoMine by up to 40X for Clique-7-Minus and 22X for Pentagon, running on Wiki-Vote and Patents respectively. The best case scenario for those is expected to be 120X and 5X if the multiplicity reduction provided linear speedup, but GraphZero's generalized orientation optimization allows us to exceed that in the case of Pentagon.</p><p>Motif Counting Motif Counting finds all connected patterns of a specified number of vertices, for our purpose between 3 and 5. Both the complexity of each pattern and the number of patterns increase quickly with the number of vertices, with only 2 patterns on 3 vertices, but 21 on 5 vertices. We run Motif Counting for 3, 4, and 5 vertices on all 7 graphs with a 72 hour timeout. Table <ref type="table" target="#tab_5">2</ref> shows all of the results that completed within the time limit. We observe that GraphZero outperforms AutoMine for all workloads with the smallest speedup of 1.75X and largest speedup of 14X. Notice that as the motif size increases, there is a corresponding sharp increase in the computational costs. We therefore only successfully finish the experiments on Motif-3 and Motif-4 with LiveJournal and Orkut and Motif-3 with Twitter. For the five smallest graphs, where the speedup is relatively small for Motif-3 (up to 3.8X), we see a trend of increasing speedup relative to AutoMine. On Motif-5, the speedup ranges from 4.7X to 14X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Schedule Generation Compilation Speed Comparison for Individual Patterns</head><p>Considering patterns individually provides a direct comparison between the compilers in a pattern query scenario. Figure <ref type="figure" target="#fig_11">10</ref> shows that where the AutoMine compiler takes up to 121ms for clique_7-1, the GraphZero compiler takes just 0.6ms, a 197X speedup. Other 7-vertex patterns may take even longer. Of the 853 patterns of 7 vertices, the 4 most expensive (shown as 7_804, 7_775, 7_835 and 7_796) take over 149ms on their own in AutoMine. GraphZero completes all of these in under 30ms each, with an average speedup of over 8.7X and a maximum of 15.1X on the 7_775 pattern (meaning index 775 in pattern discovery order). The results demonstrate that GraphZero's compilation technique has promise for use in a just-in-time compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compilation Speed Comparison for Motifs</head><p>Combining the schedules for multiple patterns improves performance through data reuse, but can be expensive at compilation time. For Motif-7, each individual pattern is expensive to compile, and the aggregate compilation for all 853 patterns takes AutoMine over 2.5 minutes to complete. The speedup that GraphZero achieves on individual patterns naturally benefits the combined case, with a total compilation time of just 37 seconds, a 4X performance improvement. This trend will only continue with larger patterns, and with this performance, GraphZero has the potential to consider even larger patterns in the future.</p><p>Performance Modeling The performance model, as discussed in Section 5, estimates the number of operations each schedule needs to perform. It does not have to estimate real runtime, as its only purpose is to find the highest performance schedule. The estimates are computed in terms of number of operations performed in a uniform random graph with 1000 vertices and an average degree of 5. We show in Figures 11 that the estimated cost and real performance are strongly correlated. The Coefficient of Determination describes the strength of statistical correlation, with 1 being a correlation that is perfectly defined by the data. We observe that for Patents this value comes out as 0.94, demonstrating the strong relative predictive capabilities of the performance model. The selected schedule according to the heuristic described in Section 5.4 was the best schedule on Patents, though run-to-run variation can be up to 5%. According to these results, we conclude that the performance model  and heuristic successfully ensure that GraphZero selects a high-performance schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Orientation Optimization</head><p>Cliques The AutoMine work generalizes the orientation optimization to any-size cliques, but requires manually pruning all edges from higher-degree vertices to lower-degree vertices. GraphZero's schedules automatically implement the optimization when running on the oriented graph. Figure <ref type="figure" target="#fig_11">12</ref> uses the automatically generated code from AutoMine as the baseline and shows the speedups of AutoMine with manual pruning and GraphZero with both unoriented and oriented graphs on triangles and Clique-4. We only show the four largest graphs in which triangle counting takes at least 100ms. The manual pruning makes AutoMine much faster than the baseline, producing on average a 24.9X speedup for Triangles and 7.7X for Clique-4. GraphZero without orientation achieves up to 94% of its performance on MiCo Triangles, but falls behind in most other cases. The oriented graph, however, allows GraphZero to achieve up to 1.4X and up to 2X speedup over AutoMine with Manual Pruning on Triangles and Clique-4, respectively, both with MiCo. We point out that GraphZero with orientation and AutoMine with manual pruning process the same amount of graph data (i.e., the edges from lower-degree vertices to higher-degree vertices). The extra performance benefit from GraphZero with orientation is from better load balance because of the degree-based sorting. GraphZero's final performance beats default AutoMine by an average of 30.7X on Triangles and 9.4X on Clique-4. It is especially interesting that GraphZero achieves a 192X speedup over the baseline for Twitter from using the orientation technique for Triangles. A plausible reason is that because Twitter is the largest graph, its high-degree vertices contribute to a greater portion of the runtime than for other graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>General Patterns</head><p>We evaluate the speedup directly attributed to the orientation in GraphZero for three patterns -  Cost Benefit Analysis Using the oriented graph typically improves performance, but not necessarily for free. Applying the orientation optimization in GraphZero incurs overhead for the reindexing process. If the processing happens offline, there is no runtime overhead since the resultant graph is structurally equivalent to the original. We also consider the possibility of reindexing the graph just-in-time, as the operations have low complexity compared to large pattern mining. Table <ref type="table" target="#tab_7">3</ref> reports the reindexing overhead for all the graphs used for evaluation. On CiteSeer, the smallest graph with only 4536 edges, even the 3.3ms time is large compared to the total mining time, so it is not worth applying the optimization. However, as the graph size increases, the benefit of orientation substantially outweighs the overhead. For the largest graph Twitter, reindexing takes 77.7 seconds, but saves over 4 hours of processing for Triangles. while the absolute cost to orient the graph indeed grows with the graph, the performance benefit scales up far faster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>Many graph processing systems, including GraphLab <ref type="bibr" target="#b28">[29]</ref>, Graph <ref type="bibr" target="#b24">[25]</ref>, Gemini <ref type="bibr" target="#b51">[52]</ref>, Pregel <ref type="bibr" target="#b29">[30]</ref>, GridGraph <ref type="bibr" target="#b52">[53]</ref>, XStream <ref type="bibr" target="#b34">[35]</ref>,</p><p>and Ligra <ref type="bibr" target="#b37">[38]</ref>, expose a think-like-a-vertex or think-likean-edge abstraction, which makes it easy to express graph traversal algorithms such as breadth first search. The distributed systems focus on optimizing communication <ref type="bibr" target="#b36">[37]</ref>, locality <ref type="bibr" target="#b15">[16]</ref>, and load balance <ref type="bibr" target="#b21">[22]</ref>, whereas the single-machine systems heavily optimize I/O scheduling <ref type="bibr" target="#b47">[48]</ref>, minimize data loading <ref type="bibr" target="#b42">[43]</ref>, or trade off accuracy for performance <ref type="bibr" target="#b22">[23]</ref>. However, none of these systems can be easily used to compose graph mining applications, because of the gap between the low-level abstraction and the structural patterns. Arabesque <ref type="bibr" target="#b40">[41]</ref> is the first distributed graph mining system that supports high-level interfaces for user to easily specify and mine patterns. A number of graph mining systems are then proposed with optimized memory consumption <ref type="bibr" target="#b9">[10]</ref>, depth-first search <ref type="bibr" target="#b12">[13]</ref>, out-of-core processing <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b49">50]</ref>, or approximate mining support <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b31">32]</ref>. As pointed out in <ref type="bibr" target="#b30">[31]</ref>, these systems implement generic but inefficient mining algorithms and incur unnecessary global synchronizations.</p><p>AutoMine is a unique graph mining system built upon a set-based representation. Given a list of patterns, its compiler can automatically generate a nested loop structure of set intersection and subtraction operations to identify all of them. It substantially outperforms prior graph mining systems and is hence used as the baseline to evaluate GraphZero. EmptyHeaded <ref type="bibr" target="#b3">[4]</ref> and GraphFlow <ref type="bibr" target="#b20">[21]</ref> are similar systems, but they focus on optimizing set intersection operations and cannot handle missing edges in patterns. For example, they may consider the two-edge path in a triangle as an instance of the wedge pattern, which is unacceptable in many applications. In contrary, GraphZero, like AutoMine, supports arbitrary patterns and completely eliminates redundancy in both schedule search and code execution.</p><p>Many compilers for graph analytics perform sophisticated optimizations once the graph algorithm is clearly expressed using the provided domain-specific language. GraphIt <ref type="bibr" target="#b48">[49]</ref> enables user to describe the graph algorithm in the algorithm language and how the algorithm should be optimized in the scheduling language. This separation allows the user to focus on algorithm design and offload the optimization tasks to the compiler. Green-Marl <ref type="bibr" target="#b17">[18]</ref>, SociaLite <ref type="bibr" target="#b35">[36]</ref>, and Abelian <ref type="bibr" target="#b14">[15]</ref> can automatically parallelize and optimize graph algorithms but the optimization space they can explore is significantly smaller compared with GraphIt. Pai and Pingali <ref type="bibr" target="#b33">[34]</ref> propose a set of compiler optimization techniques to efficiently map graph algorithms to the GPU architecture. None of these compilers can generate efficient graph mining algorithms, let alone remove redundancy, which is one of GraphZero's most important contributions.</p><p>The orientation optimization was first proposed by Latapy <ref type="bibr" target="#b25">[26]</ref> for triangle counting. Shun et al. <ref type="bibr" target="#b38">[39]</ref> and Voegele et al. <ref type="bibr" target="#b41">[42]</ref> extend it for parallel triangle counting. Hu et al. <ref type="bibr" target="#b18">[19]</ref> applies it to triangle counting on GPUs. AutoMine is the first work that generalizes the optimization for any-size clique patterns. To our knowledge, no prior work could apply the optimization to arbitrary patterns, which is made possible in GraphZero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>We proposed an optimizing compiler, GraphZero, that systematically addresses the limitations of AutoMine, a state-ofthe-art graph mining system. GraphZero breaks symmetry in patterns, which causes serious performance and compilation overhead problems in AutoMine, through automatically generated and enforced restrictions. It leverages the generated restrictions and generalizes an important optimization for graph mining to arbitrary patterns based on a reindexing technique. The experiments showed that GraphZero substantially outperformed AutoMine for multiple patterns on real-world graphs with a much faster compilation speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Appendix</head><p>Theorem 1. For an arbitrary pattern P and its schedule S, let L be the partial ordering on the label set in P generated by Algorithm 1. Given an instance of P, denoted by e, in a graph G there exists exactly one mapping M from P to e if for each binary ordering relation (S[i], S[j]) in L, we add a restriction M(S[i]).id &gt; M(S[j]).id.</p><p>Proof. This proof is split into two components. The first shows that at most one mapping exists that follows the ordering. The second shows that any instance that matches a mapping has at least one mapping that follows the restrictions.</p><p>To prove that at most one mapping exists, we perform a proof by contradiction. Assume two distinct mappings, M 1 and M 2 . Then, M 1 and M 2 must differ in at least one vertex. Let the first vertex in which they differ be d. Then, there is an automorphism that doesn't change any of the vertices of S which come before d, which maps M 1 to M 2 . There is therefore an automorphism A such that M</p><formula xml:id="formula_2">1 (A(x)) = M 2 (x). Note that M 2 (d) M 1 (d), so M 2 (d) = M 1 (A(d)) &lt; M 1 (d)</formula><p>is a restriction that is enforced. However, note that this symmetrically, we also have M 1 (d) &lt; M 2 (d). These two form a contradiction, so there cannot be two distinct mappings that both obey the partial orderings. This concludes the proof that at most one is achieved.</p><p>To see that there is at least one mapping that satisfies the restrictions imposed by the binary relations, note that we can satisfy each of the restrictions in order by performing an automorphism to bring the maximum into the desired location at each step. There is an important property of these automorphisms that allow us to apply them without changing any relations, maintaining satisfcation of them, which is explained with the following lemma. )) is a binary relation in the original set. Therefore, the set of binary relations after the automorphism is a subset of the binary relations before the automorphism. Then, symmetrically, since the automorphism is invertible with an automorphism, the before must obviously satisfies (c, k) as a restriction. Note then that there is therefore an automorphism that takes c to k, and thus one that takes k to c, which doesn't change anything for j &lt; c, and similarly doesn't change anything for j &lt; z. Then, since (k, z) is a restriction, there is an automorphism that takes z to k that doesn't move j &lt; z. Hence, there is an automorphism taking z to c that doesn't move any j &lt; z. Thus, (z, c) is also a relation, which is already enforced by the inductive hypothesis. Since the restrictions are transitive, and (z, c) and (c, k) are both enforced, (z, k) is enforced, as desired. Therefore, enforcing the chosen relations enforces all relations (S[a], S[b]) for b ‚â§ k, completing the induction. ‚ñ° Theorem 3. For a given Pattern, Algorithm 4 generates all distinct schedules, and generates no two equivalent schedules.</p><p>Proof. We first prove that it generates no two equivalent schedules. Say that it produces two equivalent schedules, S 1 and S 2 . Let the first vertex at which S 1 and S 2 differs be V 1 in S 1 and V 2 in S 2 . There is necessarily an automorphism mapping S 1 to S 2 . When the algorithm produces the two schedules, at the point where V 1 and V 2 are processed, neither must be marked by the other. However, since there is an automorphism mapping S 1 to S 2 , V 1 would mark V 2 and V 2 would mark V 1 . This is a contradiction. Therefore it is impossible for two equivalent schedules to be generated by the algorithm. Now, we must prove that every valid schedule is equivalent to one generated by the algorithm. This becomes obvious if we can prove the following: The automorphisms that move v to v for v ‚àà sched partition valid_next into disjoint sets, such that for any two vertices x, y in a set, any schedule generated by considering x next is equivalent to one considering y next. When we consider the fact that these automorphisms form a permutation group, known as a stabilizer group, and let these partitions be the orbits of elements within the group. An automorphism mapping x to y maps any schedule with x next to a schedule with y next, and there is necessarily such an automorphism if they're within the same orbit. ‚ñ°</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Performance model</head><p>To understand the probability evaluation, we model the probability that all restrictions only on vertices discovered in loops up to and including that layer are satisfied. The probability of all the relations being satisfied is 1 z i , where z i is the number of vertices which are at most v i (including v i ), under restrictions imposed up to that layer.</p><p>The explanation of this quantity is as follows: If we assume x 0 , x 1 , ‚Ä¢ ‚Ä¢ ‚Ä¢ , x k are uniformly randomly distributed variables in (0, 1), it is the probability that, for any binary relation we enforce in the schedule, (S[i], S[j]), where 0 ‚â§ i ‚â§ j ‚â§ k x j &lt; x i As established by Theorem 2, each variable only needs one upper bound. We can then compute this probability with a series of nested integrals. At each point of integration, if we integrate in order from x k to x 0 , the power of x i will be the number of x j where j &gt; i and x j &lt; x i . This power is z i ‚àí 1, which integrates to 1/z i x z i . This naturally results in the quantity established above as the value of the entire nested integral.</p><p>For example, with the rectangle, of which 1/8th follow the restriction, there are 4 which are at most v 0 , 2 which are at most v 1 , and 1 each which are at most v 2 and v 3</p><formula xml:id="formula_3">‚à´ 1 0 ‚à´ x 0 0 ‚à´ x 1 0 ‚à´ x 0 0 1dx 3 dx 2 dx 1 dx 0 = ‚à´ 1 0 ‚à´ x 0 0 ‚à´ x 1 0 x 0 dx 2 dx 1 dx 0 = ‚à´ 1 0 ‚à´ x 0 0 ‚à´ x 1 0 x 0 dx 2 dx 1 dx 0 = ‚à´ 1 0 ‚à´ x 0 0 x 0 x 1 dx 1 dx 0 = ‚à´ 1 0 x 0 (x 2 0 /2)dx 0 = 1 4 * 1 2</formula><p>For the bottommost layer, the quantity expressed above is equal to the reciprocal of the multiplicity, as expected.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>ùê¥ ùê∂ ‚àà ùëÅ ùê¥ ‚àí ùëÅ ùêµ ùê∑ ‚àà ùëÅ ùêµ ‚à© ùëÅ ùê∂ ‚àí ùëÅ(ùê¥) Pseudocode For A in V: For B in N(A): For C in N(A) -N(B): For D in N(B) &amp; N(C) -N(A): Found(A, B, C, D) // N(v) -&gt; Neighbor set of v (a) Scheduling Phase</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The full process of AutoMine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. The computation redundancy explosion problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Overview of GraphZero</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 2 .</head><label>2</label><figDesc>Given the set of binary relations generated by Algorithm 1, for each k (0 ‚â§ k &lt; |S |) where S is the input schedule, we only keep (S[z], S[k]) where z is maximized for k, we still properly enforce all the original binary relations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 2 :</head><label>2</label><figDesc>Automine's schedule generation input : P : the pattern. output : schedules : the list of all valid schedules 1 begin 2 for permutation S of the vertices in P do 3 if S is a valid schedule then 4 add S to schedules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 .Figure 10 .</head><label>910</label><figDesc>Figure 9. Individual Pattern Performance ("TO" represents time out)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 .Figure 12 .</head><label>1112</label><figDesc>Figure 11. Estimated versus Actual Performance on Patents</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Speedup from Orientation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Lemma 1 .</head><label>1</label><figDesc>Consider any automorphism A, which maps S[i] to S[i], for i &lt; k. A does not change the set of binary relations (S[a], S[b]) where a &lt; k, if we apply the automorphism to each binary relation (X , Y ) to become (A(X ), A(Y )), over all automorphisms. As a consequence, applying such an automorphism does not break the relations. Proof. First, for any b &lt; k, the binary relations do not move, so they are automatically satisfied. Now, consider (S[a], S[b]) as a binary relation, where b ‚â• k. Then, there exists an automorphism that doesn't move S[j] for j &lt; a that maps S[a] to S[b]. There is then an automorphism, which can be obtained by composition, which maps S[a] to A(S[b]) which doesn't move S[j] for j &lt; a, which is the composition of those two automorphisms. Hence (S[a], A(S[b]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 .</head><label>2</label><figDesc>Motif Counting Performance reduction offers. Notice that in Figure</figDesc><table><row><cell cols="2">Triangle Clique-4</cell><cell>Rectangle</cell><cell>Pentagon</cell></row><row><cell cols="4">House Hourglass Cycle-6-Tri Clique-7-Minus</cell></row><row><cell cols="4">Figure 8. Individual Pattern Workloads.</cell></row><row><cell>Graph</cell><cell cols="3">App. AutoMine GraphZero</cell></row><row><cell></cell><cell>3-MC</cell><cell>1.6ms</cell><cell>0.9ms</cell></row><row><cell>CiteSeer</cell><cell>4-MC</cell><cell>11.9ms</cell><cell>2.4ms</cell></row><row><cell></cell><cell>5-MC</cell><cell>537ms</cell><cell>38ms</cell></row><row><cell></cell><cell>3-MC</cell><cell>34.5ms</cell><cell>9.2ms</cell></row><row><cell>Wiki-Vote</cell><cell>4-MC</cell><cell>11.5s</cell><cell>1.7s</cell></row><row><cell></cell><cell>5-MC</cell><cell>5300s</cell><cell>500s</cell></row><row><cell></cell><cell>3-MC</cell><cell>230ms</cell><cell>60ms</cell></row><row><cell>MiCo</cell><cell>4-MC</cell><cell>45.2s</cell><cell>15.2s</cell></row><row><cell></cell><cell>5-MC</cell><cell>5.56h</cell><cell>1.2h</cell></row><row><cell></cell><cell>3-MC</cell><cell>1.9s</cell><cell>0.74s</cell></row><row><cell>Patents</cell><cell>4-MC</cell><cell>82.1s</cell><cell>10.2s</cell></row><row><cell></cell><cell>5-MC</cell><cell>117m</cell><cell>12.7m</cell></row><row><cell>LiveJournal</cell><cell>3-MC 4-MC</cell><cell>13.4s 367m</cell><cell>4.04s 54m</cell></row><row><cell>Orkut</cell><cell>3-MC 4-MC</cell><cell>82.2s 43.7h</cell><cell>23.1s 7.4h</cell></row><row><cell>Twitter</cell><cell>3-MC</cell><cell>31.3h</cell><cell>3.9h</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 .</head><label>3</label><figDesc>Graph reindexing overhead</figDesc><table><row><cell>Rectangle, Pentagon, and Hourglass, on which AutoMine</cell></row><row><cell>cannot apply the optimization. Figure 13 demonstrates the</cell></row><row><cell>speedup of GraphZero with orientation over GraphZero</cell></row><row><cell>without orientation. The performance improves by up to</cell></row><row><cell>4.2X, with Pentagon seeing the most benefit at an average of</cell></row><row><cell>2.9X and Hourglass seeing the lowest benefit at an average</cell></row><row><cell>of 2.1X. These results are expected because the sparsity of</cell></row><row><cell>Rectangle and Pentagon patterns makes them more likely to</cell></row><row><cell>include high-degree vertices, whereas the dense subpatterns</cell></row><row><cell>(triangles) in Hourglass filter out many of those high-degree</cell></row><row><cell>vertices. But the benefit from orientation optimization is</cell></row><row><cell>maximized on high-degree vertices.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">A total ordering is a set plus the relation on the set, but we treat it as a label array to simplify the discussion</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>be a subset of the after. Hence, the set of relations is the same before and after the automorphism is applied.</p><p>‚ñ°</p><p>That is, we can apply a sequence of N automorphisms, and make a corresponding sequence of labelings, M 0 , M 1 , M 2 , ‚Ä¢ ‚Ä¢ ‚Ä¢ M N . Each member of these labelings will satisfy the following: M j satisfies all relations of the form (S[z], S[k]), where k &lt; j is the 0-based index in the schedule, and z is anything. Note that we can allow M 0 to be M. We shall prove that we can construct this sequence iteratively.</p><p>We consider M k and construct M k +1 . Let z be the index such that M k (S[z]) is maximized, and where</p><p>) is a relation we have. Otherwise, we do the following. There is an automorphism</p><p>). This is required for the restriction to exist.</p><p>We shall prove that letting )is also a restriction, since there is an automorphism mapping</p><p>Thus, M k +1 satisfies the restrictions we desired. This completes the recursive step.</p><p>Therefore, we can construct M N , which is a mapping that satisfies all the binary relations in the partial ordering. Therefore, we have proved that it will find every distinct mapping at least once and at most once, so it finds each one exactly once, as desired. ‚ñ° ) cannot be a restriction. We prove the theorem inductively. That is, if for j &lt; k, we only enforce chosen relations of the form (S[x], S[j]) for j, that enforcing the chosen relation for k, if there is one, without considering the others, still enforces all relations for j ‚â§ k. The base case, where no restrictions need to be enforced, is trivial. If there is no ordering (a, k) then the recursive step is trivial. Note that if (z, k) is required by the partial ordering, there is an automorphism mapping z to k that doesn't move j for j &lt; z. Let (c, k) be the one the chosen relation for k. We know that for all z c such that (z, k) is a restriction, z &lt; c. Applying the chosen restriction</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C] [a</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D] [b</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C] [b</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D] [b</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">]</forename></persName>
		</author>
		<ptr target="https://graphchallenge.mit.edu/" />
		<imprint>
			<pubPlace>A,C] [B,A] [B,C] [A,D] [B,D] [A,B,D] [A,B,C] [B,A,D] [B,C,A] [B,A,C] [B,C,D] Phase 1</pubPlace>
		</imprint>
	</monogr>
	<note>B,C,A,D] References [1] 2019. graphchallenge</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<ptr target="http://snap.stanford.edu/data/com-Orkut.html" />
	</analytic>
	<monogr>
		<title level="j">Orkut social network</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalemine: scalable parallel frequent subgraph mining in a single large graph</title>
		<author>
			<persName><forename type="first">Ehab</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ibrahim</forename><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Panos</forename><surname>Kalnis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zuhair</forename><surname>Khayyat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fuad</forename><surname>Jamour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis<address><addrLine>SC; Salt Lake City, UT, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-11-13">2016. 2016. November 13-18, 2016</date>
			<biblScope unit="page" from="716" to="727" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Emptyheaded: A relational engine for graph processing</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Christopher R Aberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andres</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kunle</forename><surname>N√∂tzli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Olukotun</surname></persName>
		</author>
		<author>
			<persName><surname>R√©</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page">20</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient Graphlet Counting for Large Networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nesreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><forename type="middle">A</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><forename type="middle">G</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><surname>Duffield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE International Conference on Data Mining, ICDM 2015</title>
				<meeting><address><addrLine>Atlantic City, NJ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-11-14">2015. November 14-17, 2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Graph-based Anomaly Detection and Description: A Survey</title>
		<author>
			<persName><forename type="first">Leman</forename><surname>Akoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hanghang</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danai</forename><surname>Koutra</surname></persName>
		</author>
		<idno>CoRR abs/1404.4679</idno>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Group Formation in Large Social Networks: Membership, Growth, and Evolution</title>
		<author>
			<persName><forename type="first">Lars</forename><surname>Backstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangyang</forename><surname>Lan</surname></persName>
		</author>
		<idno type="DOI">10.1145/1150402.1150412</idno>
		<ptr target="https://doi.org/10.1145/1150402.1150412" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD &apos;06)</title>
				<meeting>the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD &apos;06)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="44" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Layered Label Propagation: A MultiResolution Coordinate-Free Ordering for Compressing Social Networks</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Rosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Santini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on World Wide Web</title>
				<editor>
			<persName><forename type="first">Sadagopan</forename><surname>Srinivasan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Krithi</forename><surname>Ramamritham</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Arun</forename><surname>Kumar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Ravindra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Elisa</forename><surname>Bertino</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ravi</forename><surname>Kumar</surname></persName>
		</editor>
		<meeting>the 20th international conference on World Wide Web</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="587" to="596" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The WebGraph Framework I: Compression Techniques</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Thirteenth International World Wide Web Conference</title>
				<meeting>of the Thirteenth International World Wide Web Conference<address><addrLine>Manhattan, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="595" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">G-Miner: an efficient task-oriented graph mining system</title>
		<author>
			<persName><forename type="first">Hongzhi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunjian</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Da</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth EuroSys Conference</title>
				<meeting>the Thirteenth EuroSys Conference<address><addrLine>Porto, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-04-23">2018. 2018. April 23-26. 2018</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Selectivity based approach to Continuous Pattern Detection in Streaming Graphs</title>
		<author>
			<persName><forename type="first">Sutanay</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">B</forename><surname>Holder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Chin</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">Khushbu</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Feo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Extending Database Technology, EDBT 2015</title>
				<meeting>the 18th International Conference on Extending Database Technology, EDBT 2015<address><addrLine>Brussels, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-03-23">2015. March 23-27, 2015</date>
			<biblScope unit="page" from="157" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Triangle Listing in Massive Networks</title>
		<author>
			<persName><forename type="first">Shumo</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Knowl. Discov. Data</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">32</biblScope>
			<date type="published" when="2012-12">2012. Dec. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fractal: A General-Purpose Graph Pattern Mining System</title>
		<author>
			<persName><forename type="first">Vin√≠cius</forename><surname>Vitor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santos</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><forename type="middle">H C</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Guedes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meira</forename><surname>Wagner</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, SIGMOD Conference</title>
				<meeting>the 2019 International Conference on Management of Data, SIGMOD Conference<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-06-30">2019. 2019. June 30 -July 5, 2019</date>
			<biblScope unit="page" from="1357" to="1374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">GRAMI: Frequent Subgraph and Pattern Mining in a Single Large Graph</title>
		<author>
			<persName><forename type="first">Mohammed</forename><surname>Elseidy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ehab</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Spiros</forename><surname>Skiadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Panos</forename><surname>Kalnis</surname></persName>
		</author>
		<idno type="DOI">10.14778/2732286.2732289</idno>
		<ptr target="https://doi.org/10.14778/2732286.2732289" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="517" to="528" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Abelian: A Compiler for Graph Analytics on Distributed, Heterogeneous Platforms</title>
		<author>
			<persName><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Loc</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Parallel Processing</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="249" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Study of Partitioning Policies for Graph Analytics on Largescale Distributed Platforms</title>
		<author>
			<persName><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Loc</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/pvldb/vol12/p321-gill.pdf" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="321" to="334" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A combinatorial approach to graphlet counting</title>
		<author>
			<persName><forename type="first">Tomaz</forename><surname>Hocevar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janez</forename><surname>Demsar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="559" to="565" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Green-Marl: a DSL for easy and efficient graph analysis</title>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edic</forename><surname>Sedlar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kunle</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="349" to="362" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">TriCore: parallel triangle counting on GPUs</title>
		<author>
			<persName><forename type="first">Yang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage, and Analysis</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage, and Analysis<address><addrLine>SC; Dallas, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-11-11">2018. 2018. November 11-16. 2018</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Shivaram Venkataraman, Vladimir Braverman, and Ion Stoica</title>
		<author>
			<persName><forename type="first">Anand Padmanabha</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zaoxing</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Jin</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/osdi18/presentation/iyer" />
	</analytic>
	<monogr>
		<title level="m">13th USENIX Symposium on Operating Systems Design and Implementation (OSDI 18). USENIX Association</title>
				<meeting><address><addrLine>Carlsbad, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
	<note>ASAP: Fast, Approximate Graph Pattern Mining at Scale</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Graphflow: An active graph database</title>
		<author>
			<persName><forename type="first">Chathura</forename><surname>Kankanamge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><surname>Sahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedbhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
				<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1695" to="1698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multilevelk-way partitioning scheme for irregular graphs</title>
		<author>
			<persName><forename type="first">George</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vipin</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed computing</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="96" to="129" />
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient Processing of Large Graphs via Input Reduction</title>
		<author>
			<persName><forename type="first">Amlan</forename><surname>Kusum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iulian</forename><surname>Neamtiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM International Symposium on High-Performance Parallel and Distributed Computing, HPDC 2016</title>
				<meeting>the 25th ACM International Symposium on High-Performance Parallel and Distributed Computing, HPDC 2016<address><addrLine>Kyoto, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-05-31">2016. May 31. June 04, 2016</date>
			<biblScope unit="page" from="245" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">What is Twitter, a social network or a news media</title>
		<author>
			<persName><forename type="first">Haewoon</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changhyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hosung</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sue</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on World wide web</title>
				<meeting>the 19th international conference on World wide web</meeting>
		<imprint>
			<publisher>AcM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="591" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">GraphChi: Large-scale Graph Computation on Just a PC</title>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation</title>
				<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="31" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Main-memory triangle computations for very large (sparse (power-law)) graphs. Theor</title>
		<author>
			<persName><forename type="first">Matthieu</forename><surname>Latapy</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2008.07.017</idno>
		<ptr target="https://doi.org/10.1016/j.tcs.2008.07.017" />
	</analytic>
	<monogr>
		<title level="j">Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">407</biblScope>
			<biblScope unit="page" from="458" to="473" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Predicting positive and negative links in online social networks</title>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on World wide web</title>
				<meeting>the 19th international conference on World wide web</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="641" to="650" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Graphs over time: densification laws, shrinking diameters and possible explanations</title>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><forename type="middle">M</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
				<meeting>the Eleventh ACM SIGKDD International Conference on Knowledge Discovery and Data Mining<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-08-21">2005. August 21-24, 2005</date>
			<biblScope unit="page" from="177" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Distributed GraphLab: A Framework for Machine Learning in the Cloud</title>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="716" to="727" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Pregel: A System for Large-scale Graph Processing</title>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">H</forename><surname>Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Aart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilan</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naty</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><surname>Czajkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data (SIG-MOD &apos;10)</title>
				<meeting>the 2010 ACM SIGMOD International Conference on Management of Data (SIG-MOD &apos;10)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">AutoMine: harmonizing high-level abstraction and high performance for graph mining</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM Symposium on Operating Systems Principles</title>
				<meeting>the 27th ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="509" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">ApproxG: Fast Approximate Parallel Graphlet Counting Through Accuracy Control</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dinesh</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chao</forename><surname>Ai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing</title>
				<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-05-01">2018. 2018. May 1-4, 2018</date>
			<biblScope unit="page" from="533" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The structure and function of complex networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM REVIEW</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="167" to="256" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A compiler for throughput optimization of graph algorithms on GPUs</title>
		<author>
			<persName><forename type="first">Sreepathi</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="1" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">X-Stream: Edge-centric Graph Processing Using Streaming Partitions</title>
		<author>
			<persName><forename type="first">Amitabha</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivo</forename><surname>Mihailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP &apos;13</title>
				<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP &apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="472" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">SociaLite: Datalog extensions for efficient social network analysis</title>
		<author>
			<persName><forename type="first">Jiwon</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE 29th International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="278" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Fast and Concurrent RDF Queries with RDMA-Based Distributed Graph Exploration</title>
		<author>
			<persName><forename type="first">Jiaxin</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Youyang</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feifei</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Operating Systems Design and Implementation</title>
				<meeting><address><addrLine>Savannah, GA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-11-02">2016. 2016. November 2-4, 2016</date>
			<biblScope unit="page" from="317" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Ligra: A Lightweight Graph Processing Framework for Shared Memory</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;13)</title>
				<meeting>the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Multicore triangle computations without tuning</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kanat</forename><surname>Tangwongsan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st IEEE International Conference on Data Engineering, ICDE 2015</title>
				<meeting><address><addrLine>Seoul, South Korea</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-04-13">2015. April 13-17, 2015</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A distributed approach for graph mining in massive networks</title>
		<author>
			<persName><forename type="first">Nilothpal</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10618-016-0466-x</idno>
		<ptr target="https://doi.org/10.1007/s10618-016-0466-x" />
	</analytic>
	<monogr>
		<title level="j">Data Min. Knowl. Discov</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1024" to="1052" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Arabesque: a system for distributed graph mining</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Carlos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><forename type="middle">J</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgos</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><forename type="middle">J</forename><surname>Siganos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP 2015</title>
				<meeting>the 25th Symposium on Operating Systems Principles, SOSP 2015<address><addrLine>Monterey, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-10-04">2015. October 4-7, 2015</date>
			<biblScope unit="page" from="425" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Parallel triangle counting and k-truss identification using graph-centric methods</title>
		<author>
			<persName><forename type="first">Chad</forename><surname>Voegele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sreepathi</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPEC.2017.8091037</idno>
		<ptr target="https://doi.org/10.1109/HPEC.2017.8091037" />
	</analytic>
	<monogr>
		<title level="m">2017 IEEE High Performance Extreme Computing Conference</title>
				<meeting><address><addrLine>Waltham, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-09-12">2017. 2017. September 12-14, 2017</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Load the Edges You Need: A Generic I/O Optimization for Disk-based Graph Processing</title>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/atc16/technical-sessions/presentation/vora" />
	</analytic>
	<monogr>
		<title level="m">2016 USENIX Annual Technical Conference (USENIX ATC 16). USENIX Association</title>
				<meeting><address><addrLine>Denver, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="507" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">RStream: Marrying Relational Algebra with Streaming for Efficient Graph Mining on A Single Machine</title>
		<author>
			<persName><forename type="first">Kai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiqiang</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Thorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><forename type="middle">Quang</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoqing</forename><forename type="middle">Harry</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Symposium on Operating Systems Design and Implementation</title>
				<meeting><address><addrLine>Carlsbad, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-10-08">2018. 2018. October 8-10. 2018</date>
			<biblScope unit="page" from="763" to="782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">FANMOD: A Tool for Fast Network Motif Detection</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Wernicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Rasche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1152" to="1153" />
			<date type="published" when="2006-05">2006. May 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">gSpan: Graph-Based Substructure Pattern Mining</title>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDM.2002.1184038</idno>
		<ptr target="https://doi.org/10.1109/ICDM.2002.1184038" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE International Conference on Data Mining (ICDM 2002</title>
				<meeting>the 2002 IEEE International Conference on Data Mining (ICDM 2002<address><addrLine>Maebashi City, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-12">2002. December 2002</date>
			<biblScope unit="page" from="721" to="724" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Node, Motif and Subgraph: Leveraging Network Functional Blocks Through Structural Convolution</title>
		<author>
			<persName><forename type="first">Carl</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mengxiong</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><forename type="middle">W</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<idno type="DOI">10.1109/ASONAM.2018.8508729</idno>
		<ptr target="https://doi.org/10.1109/ASONAM.2018.8508729" />
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM 2018 International Conference on Advances in Social Networks Analysis and Mining, ASONAM 2018</title>
				<meeting><address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08-28">2018. August 28-31. 2018</date>
			<biblScope unit="page" from="47" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Wonderland: A Novel Abstraction-Based Out-Of-Core Graph Processing System</title>
		<author>
			<persName><forename type="first">Mingxing</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongwei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Youwei</forename><surname>Zhuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuehai</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengying</forename><surname>Huan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kang</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS 2018</title>
				<meeting>the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS 2018<address><addrLine>Williamsburg, VA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-03-24">2018. March 24-28. 2018</date>
			<biblScope unit="page" from="608" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">GraphIt: a highperformance graph DSL</title>
		<author>
			<persName><forename type="first">Yunming</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mengjiao</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riyadh</forename><surname>Baghdadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shoaib</forename><surname>Kamil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saman</forename><forename type="middle">P</forename><surname>Amarasinghe</surname></persName>
		</author>
		<idno type="DOI">10.1145/3276491</idno>
		<ptr target="https://doi.org/10.1145/3276491" />
	</analytic>
	<monogr>
		<title level="j">OOPSLA</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">30</biblScope>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Kaleido: An Efficient Out-of-core Graph Mining System on A Single Machine</title>
		<author>
			<persName><forename type="first">Cheng</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhibin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tianqi</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xueqi</forename><surname>Cheng</surname></persName>
		</author>
		<idno>CoRR abs/1905.09572</idno>
		<ptr target="http://arxiv.org/abs/1905.09572" />
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Fast Rectangle Counting on Massive Networks</title>
		<author>
			<persName><forename type="first">Rong</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhaonian</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianzhong</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDM.2018.00100</idno>
		<ptr target="https://doi.org/10.1109/ICDM.2018.00100" />
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Mining, ICDM 2018</title>
				<meeting><address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-11-17">2018. November 17-20. 2018</date>
			<biblScope unit="page" from="847" to="856" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Gemini: A Computation-Centric Distributed Graph Processing System</title>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaosong</forename><surname>Ma</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/osdi16/technical-sessions/presentation/zhu" />
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Operating Systems Design and Implementation</title>
				<meeting><address><addrLine>Savannah, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="301" to="316" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">GridGraph: Large-Scale Graph Processing on a Single Machine Using 2-Level Hierarchical Partitioning</title>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wentao</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/atc15/technical-session/presentation/zhu" />
	</analytic>
	<monogr>
		<title level="m">2015 USENIX Annual Technical Conference (USENIX ATC 15</title>
				<meeting><address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="375" to="386" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
