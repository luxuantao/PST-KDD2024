<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatically Scheduling Halide Image Processing Pipelines</title>
				<funder>
					<orgName type="full">Oracle</orgName>
				</funder>
				<funder ref="#_FNmu2UD">
					<orgName type="full">National Science Foundation</orgName>
				</funder>
				<funder>
					<orgName type="full">AMD</orgName>
				</funder>
				<funder ref="#_tjNuNAv">
					<orgName type="full">DARPA</orgName>
				</funder>
				<funder>
					<orgName type="full">Intel</orgName>
				</funder>
				<funder ref="#_5pw4jDS">
					<orgName type="full">Intel Corporation</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ravi</forename><forename type="middle">Teja</forename><surname>Mullapudi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Carnegie Mellon University ? Google</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Adams</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Dillon</forename><surname>Sharlet</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jonathan</forename><surname>Ragan-Kelley</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kayvon</forename><surname>Fatahalian</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Carnegie Mellon University ? Google</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Automatically Scheduling Halide Image Processing Pipelines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2897824.2925952</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>image processing</term>
					<term>optimizing compilers</term>
					<term>Halide Concepts:</term>
					<term>Computing methodologies ? Graphics systems and interfaces;</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Halide image processing language has proven to be an effective system for authoring high-performance image processing code. Halide programmers need only provide a high-level strategy for mapping an image processing pipeline to a parallel machine (a schedule), and the Halide compiler carries out the mechanical task of generating platform-specific code that implements the schedule. Unfortunately, designing high-performance schedules for complex image processing pipelines requires substantial knowledge of modern hardware architecture and code-optimization techniques. In this paper we provide an algorithm for automatically generating high-performance schedules for Halide programs. Our solution extends the function bounds analysis already present in the Halide compiler to automatically perform locality and parallelism-enhancing global program transformations typical of those employed by expert Halide developers. The algorithm does not require costly (and often impractical) auto-tuning, and, in seconds, generates schedules for a broad set of image processing benchmarks that are performance-competitive with, and often better than, schedules manually authored by expert Halide developers on server and mobile CPUs, as well as GPUs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Image processing pipelines are essential components of a wide range of applications spanning computer graphics, computer vision, computational photography, medical imaging, and basic science. Trends such as the increasing sophistication of modern pipelines, growing resolution of image sensors, and deployment of image processing applications on resource-constrained devices has created an acute need for highly efficient image processing pipeline implementations.</p><p>In recent years, the Halide image processing language [Ragan- <ref type="bibr" target="#b12">Kelley et al. 2012;</ref><ref type="bibr" target="#b12">Ragan-Kelley et al. 2013</ref>] has proven to be an effective system for authoring high-performance image processing code, and it is now used to synthesize production code used in datacenters and on hundreds of millions of smartphones. The key benefit of Halide is that it provides abstractions that enable programmers to rapidly explore the space of code optimizations most relevant to image processing workloads. Programmers need only provide a compact, functional description of an image processing algorithm and a separate, high-level description of how to globally optimize the Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. ? 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM. SIGGRAPH '16 Technical Paper, July 24 -28, 2016, Anaheim, CA, ISBN: 978-1-4503-4279-7/16/07 DOI: http://dx.doi.org/10.1145/2897824.2925952 algorithm's execution on a machine (called a schedule). The Halide compiler then handles the tedious, mechanical task of generating platform-specific code that implements the schedule (e.g., spawning threads, managing buffers, generating SIMD instructions).</p><p>Although Halide provides high-level abstractions for expressing schedules, designing schedules that perform well on modern hardware is hard; it requires expertise in modern optimization techniques and hardware architectures. For example, around 70 software engineers at Google currently write image processing algorithms in Halide, but they rely on a much smaller cadre of Halide scheduling experts to produce the most efficient implementations. Further, production image processing pipelines are long and complex, and are difficult to schedule even for the best Halide programmers. Arriving at a good schedule remains a laborious, iterative process of schedule tweaking and performance measurement. Also, in large production pipelines, software engineering considerations (e.g., modularity, code reuse) may preclude experts from having the global program knowledge needed to create optimal schedules.</p><p>In this paper we address this problem by providing an algorithm for automatically generating high-performance schedules for Halide programs. Our approach is to leverage the function bounds analysis already present in the Halide compiler to automatically perform locality enhancing global program transformations similar to those employed by expert Halide developers. The algorithm does not require costly (and often impractical) auto-tuning, and, in seconds, generates schedules that are competitive with, and sometimes better than, the best manually-created schedules for server and mobile CPUs, as well as GPUs. Because it is built using Halide's intervalbased bounds-analysis system, our analyses apply to a broader set of image processing workloads than recent prior work. We demonstrate this advantage by presenting automatic scheduling results for a large set of complex image processing and image analysis benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Prior Work</head><p>There have been a number of recent efforts to automatically generate efficient image processing pipelines from high-level programs. <ref type="bibr" target="#b12">Ragan-Kelley et al. [2013]</ref> employed auto-tuning guided by genetic search to automatically generate Halide schedules that were performance competitive with hand-tuned implementations. However, the search was guided by fragile, sometimes benchmark-specific, heuristics (that do not work with the modern formulation of the Halide language), and required a day or more to find high-quality schedules. A more general Halide auto-tuner was later implemented within the OpenTuner framework <ref type="bibr" target="#b2">[Ansel et al. 2014]</ref>. This system was able to find efficient schedules for simpler pipelines (e.g., bilateral filtering) in about an hour, but fails to converge to good solutions on more complex pipelines. OpenTuner output for more complex pipelines such as RAW camera processing, pyramid blending, and multi-scale interpolation is five to ten times slower than hand-tuned implementations <ref type="bibr" target="#b11">[Mullapudi et al. 2015]</ref>.</p><p>While auto-tuning may seem like an attractive strategy for optimizing Halide programs, its use in a production setting is problematic for several reasons. First, the large size of production image processing pipelines presents convergence problems for auto-tuning systems-the choice space is too large and complex for brute force search. Second, programs can take minutes to compile and must be deployed to target devices to benchmark (e.g., a cell phone or tablet) since build machines have different performance characteristics than deployment targets. This build-deploy-benchmark cycle can make tuning strategies that rely on measuring the real performance of a large number of program variants infeasibly slow. While programmers must also test the performance of their code on real machines, experts make judicious choices of which strategies to test, and learn quickly from each measurement, allowing them to converge to good solutions from a smaller number of benchmarking samples.</p><p>Other recent efforts have achieved high performance by limiting the space of image processing programs considered. For example, Darkroom <ref type="bibr" target="#b7">[Hegarty et al. 2014</ref>] limits pipelines to contain only fixed-size stencil operations and no resampling, and adopts a line-buffered scheduling strategy that is ideal for the performance concerns of FPGA architectures. These constraints allow pipeline scheduling to be formulated as an integer linear programming problem that can be solved in seconds for storage-optimal schedules. This strategy can be combined with image tiling optimizations to achieve good performance on multi-core CPUs. However, Darkroom's analysis does not extend to data-dependent image processing operations, reductions, or resampling and rate changes. Building upon Darkroom, Rigel employs the synchronous dataflow model to further extend pipeline scheduling capabilities to multi-resolution operations and dynamic filtering <ref type="bibr" target="#b8">[Hegarty et al. 2016</ref>], but in doing so it sacrifices fully automatic scheduling.</p><p>PolyMage <ref type="bibr" target="#b11">[Mullapudi et al. 2015</ref>] extends polyhedral analysis techniques to schedule image processing pipelines implemented in a Halide-like dataflow language. Although the space of possible schedules for these programs is large, PolyMage demonstrates that good solutions lie in a subspace of schedules that consider only pipeline stage fusion and overlapped tiling of the output image. While Poly-Mage uses polyhedral analysis to generate efficient loop nests once stages have been fused, it relies on auto-tuning over a range of tile sizes to make stage-fusion decisions. Data-dependent operations (histograms, lookup tables), non-affine programs, and computations that feature significant input data reuse (deep neural networks, matrix multiplication) fall outside the scope of PolyMage's polyhedral overlapped tiling analysis (which is limited to stencils and up/downsampling). We adopt PolyMage's grouping-then-tiling approach, but use interval analysis, rather than polyhedral techniques, to do so, yielding completely different, and more practical, compiler internals. Our solution does not require autotuning, features wider application scope, and emits human-understandable Halide schedules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Representing and Scheduling Programs</head><p>The top half of Figure <ref type="figure" target="#fig_0">1</ref> illustrates the current workflow of developing an efficient Halide program. A programmer first authors a functional description of an image processing application. Next, a programmer (potentially a different one, with code optimization expertise) develops a schedule for the application. Finally the Halide compiler uses the program definition and schedule to generate efficient multi-threaded, vectorized code for a target machine. While the Halide compiler is responsible for the mechanical details of code generation, it is the schedule writer that is responsible for using global knowledge of the Halide application to perform the most critical program transformations.</p><p>In this section we summarize common global program restructuring decisions made by Halide developers when authoring efficient schedules. We assume familiarity with the Halide system, and refer the reader to <ref type="bibr" target="#b12">[Ragan-Kelley et al. 2012;</ref><ref type="bibr" target="#b12">Ragan-Kelley et al. 2013]</ref> for a comprehensive description of the language and its features.</p><p>A Halide program is a DAG of computation, where each node in the DAG corresponds to a function defined on an n-D domain. For example, the top of Figure <ref type="figure">2</ref> shows a simple Halide program which performs a two-pass image blur, as well as its corresponding DAG.</p><p>The program contains two functions (blurx and out), each defined on a 2-D domain parameterized by variables x and y. Edges in the DAG correspond to data dependencies between functions. For example, there is an edge from blurx to out because each value of out is the sum of three values produced by blurx.</p><p>A Halide algorithm only specifies what computations are needed to evaluate the output function out at points in its domain. It does not specify the order in which different points in the domain are computed, or the order of intermediate computations necessary to produce these points. It is the job of a Halide schedule to specify an efficient execution order for all points in the output domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Scheduling for Producer-Consumer Locality</head><p>One plausible execution order for the blur pipeline is given by Schedule 1 in Figure <ref type="figure">2</ref>. When applied to a 6 megapixel (3k ? 2k) output image, the implementation computes all required elements of blurx, stores them in a large buffer, then uses this buffer to compute all elements of out. This solution is simple, trivially parallelizable, but suffers from poor producer-consumer locality. All outputs of blurx are stored to memory before they are subsequently loaded in the computation of blur. The implementation will be memory-bandwidth bound, and perform poorly on most modern processors.</p><p>Schedules 2 and 3 in Figure <ref type="figure">2</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Scheduling for Input Reuse</head><p>In addition to increasing locality by moving the computation of values closer in time to their consumption (placing code for producer functions inside the loop nest of their consumer), it is also possible to increase the locality of multiple reads of the same value  by reordering the consumer's loop nest. This can be the preferred approach when the locality of data reuse is more important than producer-consumer locality.</p><p>The canonical example of such a workload is dense matrix-matrix multiplication, illustrated in Figure <ref type="figure" target="#fig_1">3</ref>. When this program is executed on inputs A and B of size N ? N , computing C will access each element of A and B a total of N times. Note that in Schedule 1, an entire row or column of the input functions is accessed between accesses to the same input value (the reuse distance is proportional to the size of the input matrices). For large input matrices, input values will no longer be resident in the processor's cache, yielding low performance. A well-known optimization, shown in Schedule 2, is to tile the program's loop dimensions to reduce the problem to a sequence of smaller matrix multiplications whose inputs do remain cache resident. Loop tiling to maximize input locality is a key optimization in workloads featuring dense linear algebra or convolutional neural networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Function Bounds Analysis</head><p>Halide's scheduling primitives (compute_at, reorder, and tile) enable programmers to specify a wide range of locality-increasing program transformations such as the ones described above. In order to implement these strategies, the compiler must be able to determine the appropriate loop bounds and intermediate buffer sizes. For example, in Figure <ref type="figure">2</ref>, Schedule 1, three values of blurx from the interval (x,y-1..y+1) must be computed and stored prior to computing the value of out at domain point (x,y).</p><p>The Halide compiler infers symbolic function bounds via interval analysis on expressions used to define functions. For example, in the case of Figure <ref type="figure">2</ref> Starting from the output function, bounds inference propagates up the function dependency chain, ascribing bounds to all functions in the program DAG. When the Halide compiler cannot infer tight bounds for a function (e.g., due to data-dependent access by a consumer), the programmer can explicitly provide bounds to assist the compiler in generating efficient code (e.g., the programmer may have static knowledge that all accesses to a lookup table will be in the range 0..8). Our automatic scheduling algorithm relies heavily on the results of bounds analysis to make decisions about how and when to employ the program restructuring optimizations described in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithm</head><p>In this section we describe an algorithm for automatically generating efficient schedules for Halide programs. The main idea is to partition the functions in a large Halide program into groups (subprograms), and independently perform producer-consumer locality and input reuse locality transformations on these groups.</p><p>As an overview of the method, Figure <ref type="figure">4</ref> illustrates a Halide program DAG containing five functions, organized into two groups. While Halide allows many possible computation orderings for a group, to make exploration of the optimization space tractable, our system follows <ref type="bibr" target="#b11">Mullapudi et al. [2015]</ref> and only considers a narrower space schedules that tile the loop nest corresponding to the group's output function. The computation of all other functions in the group is placed within this tiled loop (a single placement decision is made for all producers). As we demonstrate in Section 5, we are able to find high-performance schedules in this subspace.</p><p>The bottom of Figure <ref type="figure">4</ref> shows one possible schedule that results from applying these rules to the illustrated groups. (Loop bounds are written assuming functions are simple vertical stencils with support 3.) Notice that all functions are computed within the loop nest of the group's output function (gray regions), and that producer-consumer relationships in a group are managed through small intermediate buffers (A,C,D) that will likely remain resident in cache. Dependencies between groups are implemented via communication (via buffer B) through main memory.</p><p>Our auto-scheduler can analyze all programs expressible in the current version of the Halide language, with one exception: input programs are constrained to use only one update rule per function. Thus far we have not found this restriction to be too limiting, as our system is able to process a superset of the programs studied in all prior Halide publications.</p><p>In addition to an unmodified Halide program, the auto-scheduler requires as input an estimate of concrete bounds for the domain of the program's output function (e.g., the size of the outputs) as well as concrete bounds for any inputs that cannot be directly inferred from the output bounds. This extra requirement is reasonable for image processing workloads: it is common to know the approximate size of images a program will process as well as the size of inputs such as lookup tables whose bounds cannot be inferred due to data-dependent access. Also, when manually scheduling programs, programmers typically must estimate such sizes when making optimization decisions. The supplied concrete bounds need only be estimates: if the size of inputs supplied at runtime differ widely from the statically estimated bounds, generated schedules may be less efficient, but the compiled program will still be functionally correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Function Preprocessing</head><p>The first step in our analysis is to precompute properties of each function in the input program that will be useful when making scheduling decisions. For each function f we: Estimate arithmetic cost. We estimate the arithmetic cost of computing one value of the function, given values for all required inputs. For example, the function out consists of three additions. We assign unit cost to most arithmetic operations and higher costs to more complex operations such as division and transcendentals.</p><p>Compute concrete bounds. We use Halide's bounds analysis to compute concrete bounds for all functions. This is possible since the programmer has supplied concrete bounds for the program's output function, as well as for all functions whose bounds cannot be inferred from the output.</p><p>Compute per-direction input reuse. To make scheduling decisions, it is helpful to know, for each function, which domain-iteration order yields the highest amount of input data reuse. For example, consider computing elements of out in row-major order as is the case in Figure <ref type="figure" target="#fig_2">5</ref>-left. Since computing each output only requires inputs from the same column of values of blurx, each element of out requires a new set of inputs. There is no input data reuse, as evidenced by the non-overlapping yellow and blue bars in the figure. In contrast, if out was computed in column-major order, then successful computations would reuse two or three required inputs from blurx (Figure <ref type="figure" target="#fig_2">5</ref>-right).</p><p>We estimate average input reuse of values from producer function g due to domain-traversal along a particular axis of consumer function f by computing input bounds on g for two adjacent strips of f . We compute the intersection of these two input regions as an estimate of input reuse. For example, to compute reuse due to domain-traversal in the x direction: mid = c_xmin + (c_xmin + c_xmax) / 2 b1 = bounds(f, g, mid..mid+1, c_ymin..c_ymax, ...) b2 = bounds(f, g, mid+1..mid+2, c_ymin..c_ymax, ...) b_reuse = intersect(b1, b2)</p><p>The function bounds above returns a concrete bound on elements of g needed to compute elements within the specified bound on f . The preprocessing step computes reuse bounds for all f 's ancestors, for all domain directions. It is sufficient to sample reuse along a single strip of the domain since Halide's loops iterate over rectangular domains (the overlap estimate will apply throughout the domain).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Function Grouping and Tiling</head><p>Following preprocessing, the algorithm begins the process of function grouping. Grouping seeks to identify points in the program where it is beneficial to restructure computation ordering to improve producer-consumer locality. This requires determining if and how to tile consumer loop nests and where to place the computation of producer functions within these loop nests.</p><p>The algorithm makes these decisions using a greedy, agglomerative process that iteratively assigns functions in the Halide program into groups. The scheduling of each group is performed independently, and different ordering/tiling decisions are made per group. All groups containing multiple functions are constrained to have only a single output function (all dependency edges leaving the group are from the same function), and all other functions in the group will be computed within the loop nest of the output function. The iterative grouping process is similar to that employed by <ref type="bibr" target="#b11">Mullapudi et al. [2015]</ref>. However, while their work makes grouping decisions given a predetermined loop tiling structure, our solution jointly makes grouping and loop tiling decisions.</p><p>Function grouping begins by placing each function in the program in its own group. Each of these singleton groups is initially tiled to maximize input data reuse (if reuse opportunities exist). Then, each iteration attempts to increase producer-consumer locality by merging two existing groups. The process terminates when the autoscheduler estimates there is no performance benefit to merging any of the remaining groups. Each iteration of the function grouping process involves the following steps:</p><p>? Enumerate all remaining group merging opportunities.</p><p>? For each merging opportunity, estimate the performance benefit of merging the two groups. The act of evaluating the benefit of a merge requires determining a tiled loop-nest structure for the potential merged group. Listing 1: tile_singleton_group selects a loop tiling that minimizes the estimated number of cache misses when accessing input data.</p><p>? Select the merge that yields the greatest performance benefit (provided at least one merge that provides benefit does exist) and merge the two groups.</p><p>We now describe the process of determing an initial tiling for all functions, and key steps in each merging iteration in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Initialization: Tiling for Input Data Reuse</head><p>Before grouping functions to improve the program's producerconsumer locality, the auto-scheduler attempts to find loop tilings that improve locality of input data accesses by each non-pure function. (Pure functions-functions that do not contain Halide update definitions or reduction domains, such as small stencils-exhibit high input locality without tiling.) Pseudocode for this decision process is given in Listing 1. The analysis adopts a simple model of a single-level memory hierarchy with a cache size given by the parameter CACHE_SIZE.</p><p>The method makes the simplifying assumption that when a nonpure function is not tiled, all its input data accesses are cache misses (counted in total_load_ops), and that when tiling the function all input data needed to compute one tile of output (group_tile_footprint) fits in cache (they are loaded exactly once per tile). The algorithm then seeks to find a tile size that minimizes the number of loads required to compute the final output. To accelerate the search over tile sizes, tile size selection is biased toward sizes that are elongated in the directions of most input reuse. (We defer description of the auto-scheduler's tile size selection process to Section 4.2.3.) The auto-scheduler also rejects tile sizes that result in too few tiles to adequately parallelize computation across all the target machine's cores. Listing 2: evaluate_group_merge estimates the performance benefit of merging producer group prod into consumer group cons. It selects a consumer loop tiling that balances increased producer-consumer locality with redundant computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Enumerating Merging Opportunities</head><p>The purpose of grouping functions is to increase producer-consumer locality between functions in the group. Therefore, two groups g1 and g2 are candidates for merging if the output of group g1 is consumed by a function in g2.</p><p>Since computing a function within two different loop nests would require duplicating its evaluation, grouping only attempts to merge groups where the output of g1 is consumed by functions in exactly one group. For example, in Figure <ref type="figure">4</ref>, function pairs A-B, C-E, and D-E are potential merging opportunities, but B-C and B-D are not. This condition ensures that all groups containing multiple functions have exactly one output function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Evaluating Potential Merges</head><p>A merge is likely to benefit overall program performance if the performance benefit of reducing memory traffic outweighs the cost of introducing additional redundant computation. This trade-off is evaluated by the function evaluate_group_merge in Listing 2, which accepts as input two function groups (a producer group and a consumer group that depends on the output of the producer). evaluate_group_merge determines the best schedule for the merged group (a loop tiling of the output function and loop nest placement of all other functions) and returns an estimate of the performance benefit of performing the merge.</p><p>Generating tile sizes. Different tilings of the output loop nest yield different locality-redundant-compute trade-offs, so it is important for the auto-scheduler to establish the best tile size when estimating the benefit of a merge. It is cost-prohibitive for the auto-scheduler to evaluate the cost of all possible tilings (high-dimensional domains, such as the 5-D domains present in convolutional neural network layers, quickly explode the space of possible tile sizes), so we bias the set of tile dimensions using knowledge of the group output function's directional input reuse (Section 4.1). Specifically, we constrain tile sizes to be n-D hypercubes or n-D volumes elongated in the dimensions of greatest output function reuse. Redundant computation introduced by tiling is reduced when tiles have large extents in these dimensions. We further require tile sizes to have a minimum extent in the output functions innermost dimension (it's innermost loop). This minimum is set to a small multiple of the target machine vector width to avoid tile sizes that produce loop nests that cannot be efficiently vectorized. Tile sizes that are too large: they either result in a group's intermediate storage overflowing the cache, or yield too few tiles to enable parallel execution on the target machine, are immediately discarded. Note that evaluating the function group_tile_footprint (line 27) requires the compiler to determine the size of required temporary buffer allocations by scheduling the merged group's loop nest according to the candidate tile size.</p><p>Comparing costs. For each candidate tile size, the auto-scheduler estimates and compares the cost of performing a group merge (computing input group functions within the tile loop of the group's output function) with the cost of not merging the groups. The cost of not merging is given by the arithmetic cost of the producer and consumer groups (arith_cost, Listing 2, lines 14,16), plus the cost incurred by these groups to loads their inputs from memory (group_loads). The total number of loads (over the entire program's execution) is given by the concrete bounds of their output function (lines 11-12) and the chosen tiling of the groups. Loads from main memory are assumed to incur a cost specified by the auto-scheduler parameter LOAD_COST.</p><p>Assuming that all merged group intermediates are stored in cache resident buffers (footprint check in line 30), the cost of producing a tile of merged output (line 35) is the arithmetic cost of the operation, plus the size of the inputs needed to compute a single tile of the merged group (group_tile_loads). The total cost of the merged group is obtained by multiplying this estimate by the total number of tiles. evaluate_group_merge returns the estimated performance benefit of the best tiling found (if any benefit due to merging the groups exists).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Function Inlining</head><p>In addition to grouping functions (placing producers in the loop nests of consumers), it can be advantageous to inline producer functions into their consumers (a manually written Halide schedule requests this optimization using the inline directive). Although inlining is conceptually similar to choosing a tile size of one element when merging two groups, inlining in Halide results in more efficient generated code since intermediates are communicated through registers rather than via loads and stores to cached intermediate buffers.</p><p>Although described after grouping in this paper for the purposes of exposition, the compiler performs function inlining optimizations immediately after precomputation, and prior to grouping. Function inlining decisions are made using the same greedy, iterative approach used to make grouping decisions, with the following modifications:</p><p>? Since inlining duplicates the producer function's expression into the consumer, inlining can be applied to functions with multiple consumers. For simplicity, the auto-scheduler makes inlining decisions on a per-function basis. Either a function is inlined into all of its consumers (essentially removing the function from the program DAG), or to none of its consumers (it remains in the DAG and is subsequently considered for grouping as described in Section 4.2).</p><p>? When evaluating the performance benefit of inlining, the autoscheduler must consider the cost of inlining a function into all consumers (not just a single consumer as was the case during group merging decisions).</p><p>? The auto-scheduler does not use bounds analysis to estimate the arithmetic cost of the results of an inlining transformation.</p><p>Instead it substitutes the producer function expression into the consumer function and reevaluates the arithmetic cost of the new expression. This is a more accurate measure of cost because bounds analysis can overestimate the actual number of values required by a consumer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Final Schedule Generation</head><p>After inlining and merging function groups the auto-scheduler is left with a list of groups, each with a specified loop tiling. The final step of scheduling is to perform final optimizations and to generate a complete Halide schedule for each of these groups.</p><p>The first step is to reorder each group output function's loops in order of maximal input locality. This is a general optimization that helps to reduce the reuse distance of accesses to group inputs. To maintain spatial locality of data access and the ability to synthesize efficient vectorized code, loop reordering is constrained to never move the innermost dimension of the output function's loop nest out of its starting position. Next, the auto-scheduler unrolls the innermost loop if it contains only a small number of iterations. It then vectorizes this loop. Finally, the auto-scheduler parallelizes as many outermost dimensions of the loop nest as necessary to obtain sufficient multi-core parallelism for the target machine.</p><p>After these operations, each group has complete, optimized schedule. The Halide compiler then generates machine code for this schedule using its standard compilation process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>We evaluated our auto-scheduling algorithm on the 14 Halide pipelines listed in Table <ref type="table">1</ref>. These benchmarks span a range of computational photography, image processing, and computer vision workloads. Eight of the benchmarks are drawn from public literature <ref type="bibr" target="#b12">[Ragan-Kelley et al. 2012;</ref><ref type="bibr" target="#b12">Ragan-Kelley et al. 2013;</ref><ref type="bibr" target="#b13">Ragan-Kelley et al. 2015]</ref> and the Halide open source community. We also added six new Halide benchmarks:</p><p>? Three computational photography pipelines (LENSBLUR, NLMEANS, and MAXFILTER) written and manually-scheduled by professional Halide developers.</p><p>? Dense matrix-matrix multiplication (MATMUL). Fast bilateral filter using the bilateral grid <ref type="bibr" target="#b3">[Chen et al. 2007</ref>]. Constructs the grid using a histogram reduction, followed by stencil and sampling operations.   Dense matrix-matrix multiplication written as a straightforward reduction, as in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>Table <ref type="table">1</ref>: Fourteen Halide benchmarks spanning a range of computational photography, image processing, and computer vision workloads were used to evaluate the auto-scheduler. The number of functions per benchmark, the size of program inputs (concrete bounds), and auto-scheduler compilation times are given.</p><p>The number of Halide functions in each of these pipelines, the size of pipeline inputs (given as concrete bounds to the auto-scheduler), and the compile time for all benchmarks is given in Table <ref type="table">1</ref>. In nearly all cases, the auto-scheduler generates a schedule within a few seconds (LENSBLUR's 55 second compile time is the only exception).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Server CPU Performance</head><p>We first analyzed the performance of auto-scheduled pipelines on a server-class, Intel Xeon E5-2620 v3 CPU (six 2.4 Ghz Haswell cores). For this machine, we set the auto-scheduler's parameters as follows:</p><p>? VECTOR_WIDTH: 16, twice the native vector width of AVX vector instructions for 32-bit data. ? PARALLELISM_THRESHOLD: 12, a small multiple of core count.</p><p>? CACHE_SIZE: 256 KB, the per-core L2 cache size.</p><p>? LOAD_COST: 10, a rough estimate of the relative cost of DRAM load vs. compute on modern multi-core machines.</p><p>We compare the performance of the auto-scheduler's output against that of several alternative scheduling approaches:</p><p>Baseline. An automatically generated schedule that employs the code analyses described in Section 4, but never groups functions or reorders loops: it only inlines functions (when inlining introduces no redundant computation), parallelizes each outermost loop, and vectorizes each innermost loop. This baseline is representative of the most complex schedule many new Halide programmers are able to write, or the first schedule a skilled Halide programmer designs when starting to optimize.</p><p>Manual. Hand-optimized schedules created by expert Halide developers. Hand-optimized CPU schedules for these pipelines match or significantly outperform the best manually-optimized C or assembly implementations generally available and, in some cases, proprietary commercial implementations (e.g., Photoshop's local Laplacian filters).</p><p>Auto-tune. Since prior work showed that stochastic auto-tuning systems struggled to converge quickly (or at all) on complex pipelines <ref type="bibr" target="#b11">[Mullapudi et al. 2015]</ref>, we implemented a simple, bruteforce auto-tuning system that searched the low-dimensional space of auto-scheduler parameters, rather than the space of Halide schedules. The auto-tuner uses the auto-scheduler to generate schedules for each point in the parameter space, runs the resulting programs to measure real performance on the target machine, and picks the best performing schedule. The auto-tuner searched over 1152 total parameter configurations:</p><p>? PARALLELISM_THRESHOLD={6,12,18,24} This parameter sweep can take hours to days for our more complex benchmarks.</p><p>PolyMage. We approximate the scheduling behavior of Poly-Mage <ref type="bibr" target="#b11">[Mullapudi et al. 2015</ref>] by restricting the auto-scheduler to tile only two spatial dimensions and to consider only a single tile size. Also following PolyMage, we then auto-tune over seven tile sizes in each spatial dimension and three LOAD_COST factors <ref type="bibr">(10,</ref><ref type="bibr">20,</ref><ref type="bibr">40)</ref>, then pick the best performing schedule. Functions with dependence patterns that cannot be analyzed by PolyMage are scheduled using the baseline scheduler.</p><p>Figure <ref type="figure" target="#fig_8">6</ref>, which plots the performance of pipelines generated by each scheduling approach (relative to the throughput of the best schedule for each benchmark), shows that the auto-scheduled pipelines (orange bars) consistently deliver performance competitive with expert-tuned schedules (yellow bars). Absolute running times for all the bechmarks are shown in Table <ref type="table">2</ref>. Auto-scheduled performance is within 12% of, or better than, that of the manual schedules for eight of the 14 benchmarks. Auto-scheduled performance is never slower than a factor of two (UNSHARP). The reference schedule uses a much smaller tiling granularity hence fitting in L1 and achieving better locality, this performance gap is completely bridged when the auto-scheduler uses the L1 cache size to generate a schedule.</p><p>Comparison of the resulting schedules indicates that the manually authored schedule for CAMERA benefits from loop unrolling decisions that simplify conditional logic in inner loops of the pipeline (it may be possible for the auto-scheduler to consider hoisting conditionals in the future) and that in the case of BILATERAL, the expert programmer chose to fuse the grid computation with sampling operation that uses the grid whereas the auto-scheduler did not.</p><p>In addition to comparing auto-scheduled output against other Halide schedules, we also compared the performance of auto-scheduled VGG pipeline to that of Caffe <ref type="bibr" target="#b9">[Jia et al. 2014</ref>], a widely used DNN framework. (We configure Caffe to use the Intel Math Kernel library 11.2.4.) The auto-scheduled implementation of VGG outperforms Caffe/MKL by 1.5? on a 12-core, two-socket server with a Intel Xeon E5-2620 v3 CPU in each socket.</p><p>Comparison to auto-tuning. Although the auto-scheduler generates schedules significantly faster than the auto-tuning alternatives (seconds as opposed to minutes or hours) and avoids the need to run code on a target machine, the auto-tuning experiments provide a high watermark that provides insight into the quality of resulting schedules and the importance of various auto-scheduler parameters. Although auto-tuning based on actual performance measurement does find better schedules in many situations (lightblue bar, Figure <ref type="figure" target="#fig_8">6</ref>), the auto-scheduler's generated code always remains within a factor of two for all benchmarks, and is within 25% of the best auto-tuned schedule in nine of 14. Analysis of auto-tuning results indicates that the auto-scheduler's output is largely invariant to PARALLELISM_THRESHOLD (provided sufficient parallelism exists), but can be sensitive to choice of CACHE_SIZE (some benchmarks are best tuned for L1, others L2) and LOAD_COST. We Gains from image-size specialization (on HARRIS) and bin count specialization (LOCAL_LAP) are modest.</p><p>find that a reduced auto-tuning search that varies only CACHE_SIZE <ref type="bibr">(32,</ref><ref type="bibr">128,</ref><ref type="bibr">256 KB)</ref> and LOAD_COST (10,20) completes in under ten minutes for our benchmarks, but yields results comparable to the full brute search taking hours to days (dark blue bar in Figure <ref type="figure" target="#fig_8">6</ref>). When auto-tuning to achieve greater performance is acceptable, this simple six-configuration auto-tuning scheme may serve as a practical and effective alternative to prior work utilizing advanced stochastic search techniques to explore the full space of Halide schedules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Specializing Schedules to Problem Size</head><p>Automatic scheduling presents the opportunity to aggressively specialize schedules to specific dataset sizes. For example, nine of the 13 convolutional layers in the VGG-16 network operate on datasets of different size (the first convolutional layer's input is 224?224?3, while the last layer's input is 14 ? 14 ? 512). To understand the value of specializing schedules to different input configurations, we compared the performance of schedules generated specifically for each layer's input size, with the performance of a single fixed schedule. (The single fixed schedule was chosen to be the schedule that performed best on average when run on all layers.) Figure <ref type="figure" target="#fig_9">7</ref>-top shows that several layers do benefit from schedule specialization. The maximum performance benefit of a specialized schedule was 1.8?. We observe the auto-scheduler makes different global optimization decisions (exploiting reuse of layer weights or input feature maps) based on problem size.</p><p>We further explored the sensitivity of schedule performance to problem size by performing similar experiments that varied image size in HARRIS (the single, fixed schedule was created for 2000?2000 images) and the number of bins in LOCAL_LAP (fixed scheduled assumes 8 bins). In both cases, modest benefits (but no more than 40% on HARRIS, 20% on LOCAL_LAP) are observed by providing the auto-scheduler accurate estimates of the problem size used at runtime. In general we find that while it is possible to gain additional performance by auto-scheduling for various input sizes, for many image processing pipelines the performance of an auto-scheduled pipeline generated for a reasonable estimate of average problem dimensions is robust across a range of sizes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Comparison with Manual Scheduling Effort</head><p>The previous subsections demonstrated that the auto-scheduler produces schedules yielding performance on par with the best known manually-optimized schedules. To better understand how long it would take for an expert Halide developer to match the performance of the auto-scheduler when starting from scratch, we recruited two professional Halide developers to "race" the auto-scheduler. (These developers are authors on the paper.)</p><p>The experts selected three benchmarks (LENSBLUR, NLMEANS, and MAXFILTER) they had never scheduled before, and implemented the original Halide algorithm for these programs. For each benchmark, each expert programmer independently developed a schedule in a single programming session. The programmer stopped optimizing after converging on a solution they considered their best. While developing the schedules the developers documented their progress by measuring the performance of their current schedule at various points of time in each session. We then compared the auto-scheduled code's performance to that of the manually authored schedules.</p><p>Results of the comparison, are shown in Figure <ref type="figure" target="#fig_10">8</ref>. The X-axis in each of the graphs indicates development time (in minutes) for the manually developed schedules. The Y-axis shows the performance of the benchmark (measured as pixel throughput, so higher is better). The horizontal line corresponds to the performance of the schedule generated by the auto-scheduler (produced in seconds). The yellow and gray lines each correspond to the progress of a programmer. The races were conducted using four cores of an Intel E5-2690 Xeon CPU owned by the developers, not the 6-core Xeon CPU used in our prior results.</p><p>On both the LENSBLUR and NLMEANS pipelines, the auto-scheduler outperforms the experts (by nearly a factor of two on NLMEANS). The experts outperform the auto-scheduler on MAXFILTER. (One of the experts found a solution nearly three times faster on their machine, but the performance difference between this schedule and the auto-scheduler's result is narrower on the 6-core machine used to  generate Figure <ref type="figure" target="#fig_8">6</ref>). The expert schedule reduces memory footprint by fusing a function with high input data reuse with its consumer, and then choosing a tile size that simultaneously achieved both input reuse and producer-consumer locality. The auto-scheduler does not perform this fusion since the cost model deems exploiting reuse on both the functions individually to be the better choice.</p><p>As shown in Figure <ref type="figure" target="#fig_10">8</ref>, arriving at a good schedule requires significant optimization effort, even for experts. Even in the case of MAXFILTER, where the experts devise schedules that outperform the auto-scheduler, they only reach this point after 25 minutes of optimization. In the other examples, the experts optimized for nearly an hour or two without matching the performance of the auto-scheduler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Portability to Different Architectures</head><p>We also evaluated the ability of the auto-scheduler to target the quadcore ARM Cortex-A57 CPU (1.9 GHz, shared 2MB L2 cache) in the NVIDIA Tegra X1 and an NVIDIA K40 discrete GPU.</p><p>ARM CPU performance. To generate pipelines for the X1's ARM Cortex CPU, we made no changes to the auto-scheduler other than adjusting its parameters to match the processor as follows:</p><p>? VECTOR_WIDTH: 8, twice the native vector width of NEON vector instructions for 32-bit data. ? PARALLELISM_THRESHOLD: 8, a small multiple of core count.</p><p>? CACHE_SIZE: 512 KB, the per-core fraction of the L2 cache.</p><p>? LOAD_COST: 10, the same value as used for Xeon CPUs.</p><p>Figure <ref type="figure" target="#fig_11">9</ref> shows that the auto-scheduled pipelines for ARM execute faster than manually tuned schedules for all benchmarks but CAM-ERA and BLUR. (Manual schedules are the same schedules used in the prior Xeon CPU experiments.) Although we do not provide perbenchmark results in this paper, the benefits of auto-tuning schedules for ARM follows similar trends as those reported for Xeon. GPU Performance. Figure 9 also provides results of using the auto-scheduler to generate schedules for a NVIDIA K40 GPU. We configure the auto-scheduler to target the GPU by setting the PARALLELISM_THRESHOLD to 128, VECTOR_WIDTH to 32, and CACHE_SIZE to 48 KB. Additionally, we add two new parameters TARGET_THREADS_PER_BLOCK and MAX_THREADS_PER_BLOCK whose values are set to 128 and 2048 respectively. These parameters enable the auto-scheduler to avoid tiling configurations that generate too few or too many threads per GPU thread block. The inlining, tiling, and grouping processes are otherwise similar to the CPU case. Groups resulting from merging are mapped to CUDA kernels by designating the outer tile loops as GPU block grid dimensions and the inner tile loops as GPU thread block dimensions. All intermediate buffers within a group are allocated in GPU shared memory.</p><p>We compared the performance of the auto-scheduled pipelines against that of a set of manually created GPU schedules. (We manually authored a new set schedules for the K40 GPU.) Auto-scheduled performance is nearly as good as, or better than, manually scheduled pipelines on eight of the 14 benchmarks. The faster manual schedules for UNSHARP and MATMUL reduce the total number of loads performed by unrolling inner loops in cases where multiple loop iterations reload the same values. This unrolling serves as a another form of tiling for locality, and we believe that a future auto-scheduler could be modified to perform such optimizations by treating registers as an additional level of the memory hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>In this paper we have demonstrated the ability to automatically schedule Halide programs, obtaining results competitive with those obtained by the world's best Halide developers. We are excited that users of Halide may no longer require expert code-optimization knowledge in order to obtain the benefits of highly optimized code. We believe that by generating compiled solutions in seconds, avoiding the need for auto-tuning, and operating entirely within the Halide compiler, our solution is an attractive for use in production environments. We also believe our system will be valuable to expert Halide developers. In the process of evaluating our generated schedules professional developers remarked that the auto-scheduler was making decisions they had not thought of before.</p><p>Of course, this work constitutes only an initial attempt at efficiently scheduling Halide programs. Extending our approach to hierarchical levels of tiling and reasoning about the effects of data layout on vector code generation are all areas of immediate future system improvement. We predict these improvements would allow autoscheduling to meet or surpass manually authored schedules in most of our benchmarks.</p><p>The design philosophy of Halide has always involved mixed responsibilities between the compiler and a human programmer to achieve efficient code. While our auto-scheduling algorithm makes it possible for the system to take on the full responsibility of schedule generation, a developer (particularly an expert) may still wish to intervene if necessary. We are interested in exploring interfaces for the auto-scheduler to accept partially written schedules by experts, and then fill in the missing details. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Our system automatically generates schedules for Halide programs, a task currently performed by expert Halide programmers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Tiling the output and reduction loop dimensions of matrixmultiplication (Schedule 2) improves locality of access to the inputs A and B, significantly improving program performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>TraverseFigure 5 :</head><label>5</label><figDesc>Figure 5: Domain iteration order impacts the locality of data access. The shaded regions indicate values of blurx required to compute two sequential columns (left) or rows (right) of out (note region overlap on the right). The auto-scheduler uses estimates of data reuse from different domain orderings to generate candidate tile sizes and to reorder loops.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>83: 5 ?</head><label>5</label><figDesc>Automatically Scheduling Halide Image Processing Pipelines ACM Trans. Graph., Vol. 35, No. 4, Article 83, Publication Date: July 2016 return total_tiles * group_tile_loads(g, tile_cbounds)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>of an image's luminance channel and performs back projection using the normalized histogram. Uses reductions to compute the histogram and point-wise operations to perform color-scale conversion and back projection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>in a deep neural network<ref type="bibr" target="#b10">[Krizhevsky et al. 2012</ref>] (DNN). The layer evaluates a large filter bank at each spatial location of the input feature map followed by a rectified linear unit. Convolutional layers dominate the cost of evaluating and training DNNs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>VGG-16 object detection network<ref type="bibr" target="#b15">[Simonyan and Zisserman 2014]</ref>. The network has 22 layers. 9 of the network's 13 convolutional layers operate on filter banks and input feature maps of different sizes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Performance (in throughput: 1/sec) of auto-scheduled Halide programs relative to baseline, expert manually-optimized, auto-tuned, and PolyMage-like schedules. For each benchmark, performance is normalized to the fastest implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure7: Specializing schedules to specific problem sizes of individual VGG-16 network layers yields up to 1.8? benefit (compared to the schedule that performs best on average across all layers). Gains from image-size specialization (on HARRIS) and bin count specialization (LOCAL_LAP) are modest.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure8: Two professional Halide developers were tasked with developing schedules for new programs. In two of three cases, even after nearly an hour of work, the manually-authored schedules perform worse than auto-scheduled results (generated in seconds).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Performance (in throughput: 1/sec) of auto-scheduled Halide programs relative to baseline and expert manually-optimized schedules for quad-core ARM mobile CPU and K40 GPU platforms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>83:9 ? Automatically Scheduling Halide Image Processing Pipelines ACM Trans. Graph., Vol. 35, No. 4, Article 83, Publication Date: July 2016</figDesc><table><row><cell></cell><cell cols="11">Throughput: 4-core ARM mobile CPU and NVIDIA K40 GPU (relative to fastest per-platform implementation)</cell><cell></cell></row><row><cell>1.0 0.5 Relative throughput 0</cell><cell>BLUR ARM</cell><cell>GPU</cell><cell cols="2">UNSHARP ARM GPU</cell><cell cols="2">HARRIS ARM GPU</cell><cell>CAMERA ARM GPU</cell><cell>NL MEANS ARM GPU</cell><cell cols="2">MSCALE INTERP ARM GPU</cell><cell cols="2">LOCAL LAP ARM GPU</cell></row><row><cell>1.0</cell><cell cols="2">LENSBLUR</cell><cell cols="2">MAXFILTER</cell><cell cols="2">BILATERAL</cell><cell>HIST EQ</cell><cell>CONVLAYER</cell><cell>VGG</cell><cell></cell><cell cols="2">MATMUL</cell></row><row><cell>0.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0</cell><cell>ARM</cell><cell>GPU</cell><cell>ARM</cell><cell>GPU</cell><cell>= Baseline ARM</cell><cell>GPU</cell><cell>= Manual expert-tuned ARM GPU</cell><cell>= Auto-scheduler ARM GPU</cell><cell>ARM</cell><cell>GPU</cell><cell>ARM</cell><cell>GPU</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Trans. Graph., Vol. 35, No. 4, Article 83, Publication Date: July 2016</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="7">Acknowledgements</head><p>This research was supported by the <rs type="funder">National Science Foundation</rs> (<rs type="grantNumber">IIS-1539069</rs>), the <rs type="funder">Intel Corporation</rs>, a <rs type="grantName">Google Faculty Research Award</rs>, <rs type="funder">DARPA</rs> agreement <rs type="grantNumber">FA8750-14-2-0009</rs>, the <rs type="institution">Stanford Pervasive Parallelism Lab</rs> (supported by <rs type="funder">Oracle</rs>, <rs type="funder">AMD</rs>, <rs type="funder">Intel</rs>, and NVIDIA), and by equipment donations from NVIDIA.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_FNmu2UD">
					<idno type="grant-number">IIS-1539069</idno>
				</org>
				<org type="funding" xml:id="_5pw4jDS">
					<orgName type="grant-name">Google Faculty Research Award</orgName>
				</org>
				<org type="funding" xml:id="_tjNuNAv">
					<idno type="grant-number">FA8750-14-2-0009</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p># number of loads needed to compute region of output 2 def group_loads(g, cbounds): 3 total_tiles = num_tiles(cbounds, g.tile_size) 4 tile_cbounds = tile_bounds(group, g.tile_size)</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Execution time (in ms) for the auto-scheduled (auto) and manually created (manual) schedules for all benchmarks. Auto-scheduling for the Xeon CPU was performed with the settings given in Section 5.1 (targeting a 6-core CPU). The 1-and 12-core (dual socket Xeon</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>results are provided to illustrate the multi-core scaling of this schedule</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The frankencamera: An experimental platform for computational photography</title>
		<author>
			<persName><forename type="first">Adams</forename><surname>References</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Talvala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-V</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Ajdin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gelfand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dolson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vaquero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tico</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lensch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P A</forename><surname>Matusik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pulli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2010-07">2010. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">OpenTuner: An extensible framework for program autotuning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Veeramachaneni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosboom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U.-M</forename><surname>O'reilly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Parallel Architectures and Compilation</title>
		<meeting>the 23rd International Conference on Parallel Architectures and Compilation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="303" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Real-time edgeaware image processing with the bilateral grid</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Durand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2007-07">2007. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast nonlocal filtering applied to electron cryomicroscopy</title>
		<author>
			<persName><forename type="first">J</forename><surname>Darbon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cunha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Osher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISBI 2008. 5th IEEE International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="1331" to="1334" />
		</imprint>
	</monogr>
	<note>Biomedical Imaging: From Nano to Macro</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Convolution pyramids</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Farbman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fattal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lischinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">8</biblScope>
			<date type="published" when="2011-12">2011. Dec</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A combined corner and edge detector</title>
		<author>
			<persName><forename type="first">C</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stephens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Fourth Alvey Vision Conference</title>
		<meeting>of Fourth Alvey Vision Conference</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="147" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Darkroom: compiling high-level image processing code into hardware pipelines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hegarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Brunhaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vasilyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2014-07">2014. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Rigel: Flexible multi-rate image processing hardware</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hegarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2016-07">2016. July</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1408.5093</idno>
		<title level="m">Caffe: Convolutional architecture for fast feature embedding</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1097" to="1105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">PolyMage: Automatic optimization for image processing pipelines</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Mullapudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vasista</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Bondhugula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="429" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Halide: A language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Hasinoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kautz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ama-Rasinghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Du-Rand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2011-07">2011. July. 2012. July. 2013</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="519" to="530" />
		</imprint>
	</monogr>
	<note>Decoupling algorithms from schedules for easy optimization of image processing pipelines</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An introduction to Halide</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sharlet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 2015 Courses, ACM</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">160</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fast cost-volume filtering for visual correspondence and beyond</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rhemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hosni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bleyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rother</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gelautz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the 2011 IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="3017" to="3024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.1556</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
