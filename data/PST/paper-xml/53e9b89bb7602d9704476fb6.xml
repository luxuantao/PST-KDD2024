<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Equality Saturation: a New Approach to Optimization *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ross</forename><surname>Tate</surname></persName>
							<email>rtate@cs.ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Stepp</surname></persName>
							<email>mstepp@cs.ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zachary</forename><surname>Tatlock</surname></persName>
							<email>ztatlock@cs.ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sorin</forename><surname>Lerner</surname></persName>
							<email>lerner@cs.ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Equality Saturation: a New Approach to Optimization *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0779B76673D408A79B3DC333A87CA239</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.4 [Programming Languages]: Processors -Compilers; Optimization General Terms Languages</term>
					<term>Performance Compiler Optimization</term>
					<term>Equality Reasoning</term>
					<term>Intermediate Representation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Optimizations in a traditional compiler are applied sequentially, with each optimization destructively modifying the program to produce a transformed program that is then passed to the next optimization. We present a new approach for structuring the optimization phase of a compiler. In our approach, optimizations take the form of equality analyses that add equality information to a common intermediate representation. The optimizer works by repeatedly applying these analyses to infer equivalences between program fragments, thus saturating the intermediate representation with equalities. Once saturated, the intermediate representation encodes multiple optimized versions of the input program. At this point, a profitability heuristic picks the final optimized program from the various programs represented in the saturated representation. Our proposed way of structuring optimizers has a variety of benefits over previous approaches: our approach obviates the need to worry about optimization ordering, enables the use of a global optimization heuristic that selects among fully optimized programs, and can be used to perform translation validation, even on compilers other than our own. We present our approach, formalize it, and describe our choice of intermediate representation. We also present experimental results showing that our approach is practical in terms of time and space overhead, is effective at discovering intricate optimization opportunities, and is effective at performing translation validation for a realistic optimizer.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In a traditional compilation system, optimizations are applied sequentially, with each optimization taking as input the program produced by the previous one. This traditional approach to compilation has several well-known drawbacks. One of these drawbacks is that the order in which optimizations are run affects the quality of the generated code, a problem commonly known as the phase ordering problem. Another drawback is that profitability heuristics, which decide whether or not to apply a given optimization, tend to make their decisions one optimization at a time, and so it is difficult for these heuristics to account for the effect of future transformations.</p><p>In this paper, we present a new approach for structuring optimizers that addresses the above limitations of the traditional approach, and also has a variety of other benefits. Our approach consists of computing a set of optimized versions of the input program and then selecting the best candidate from this set. The set of candidate optimized programs is computed by repeatedly inferring equivalences between program fragments, thus allowing us to represent the effect of many possible optimizations at once. This, in turn, enables the compiler to delay the decision of whether or not an optimization is profitable until it observes the full ramifications of that decision. Although related ideas have been explored in the context of super-optimizers, as Section 8 on related work will point out, super-optimizers typically operate on straight-line code, whereas our approach is meant as a general-purpose compilation paradigm that can optimize complicated control flow structures.</p><p>At its core, our approach is based on a simple change to the traditional compilation model: whereas traditional optimizations operate by destructively performing transformations, in our approach optimizations take the form of equality analyses that simply add equality information to a common intermediate representation (IR), without losing the original program. Thus, after each equality analysis runs, both the old program and the new program are represented.</p><p>The simplest form of equality analysis looks for ways to instantiate equality axioms like a * 0 = 0, or a * 4 = a &lt;&lt; 2. However, our approach also supports arbitrarily complicated forms of equality analyses, such as inlining, tail recursion elimination, and various forms of user defined axioms. The flexibility with which equality analyses are defined makes it easy for compiler writers to port their traditional optimizations to our equality-based model: optimizations can work as before, except that when the optimization would have performed a transformation, it now simply records the transformation as an equality.</p><p>The main technical challenge that we face in our approach is that the compiler's IR must now use equality information to represent not just one optimized version of the input program, but multiple versions at once. We address this challenge through a new IR that compactly represents equality information, and as a result can simultaneously store multiple optimized versions of the input program. After a program is converted into our IR, we repeatedly apply equality analyses to infer new equalities until no more equalities can be inferred, a process known as saturation. Once saturated with equalities, our IR compactly represents the various possible ways of computing the values from the original program modulo the given set of equality analyses (and modulo some bound in the case where applying equality analyses leads to unbounded expansion).</p><p>Our approach of having optimizations add equality information to a common IR until it is saturated with equalities has a variety of benefits over previous optimization models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimization order does not matter.</head><p>The first benefit of our approach is that it removes the need to think about optimization ordering. When applying optimizations sequentially, ordering is a problem because one optimization, say A, may perform some transformation that will irrevocably prevent another optimization, say B, from triggering, when in fact running B first would have produced the better outcome. This so-called phase ordering problem is ubiquitous in compiler design. In our approach, however, the compiler writer does not need to worry about ordering, because optimizations do not destructively update the program -they simply add equality information. Therefore, after an optimization A is applied, the original program is still represented (along with the transformed program), and so any optimization B that could have been applied before A is still applicable after A. Thus, there is no way that applying an optimization A can irrevocably prevent another optimization B from applying, and so there is no way that applying optimizations will lead the search astray. As a result, compiler writers who use our approach do not need to worry about the order in which optimizations run. Better yet, because optimizations are allowed to freely interact during equality saturation, without any consideration for ordering, our approach can discover intricate optimization opportunities that compiler writers may not have anticipated, and hence would not have implemented in a general purpose compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Global profitability heuristics.</head><p>The second benefit of our approach is that it enables global profitability heuristics. Even if there existed a perfect order to run optimizations in, compiler writers would still have to design profitability heuristics for determining whether or not to perform certain optimizations such as inlining. Unfortunately, in a traditional compilation system where optimizations are applied sequentially, each heuristic decides in isolation whether or not to apply an optimization at a particular point in the compilation process. The local nature of these heuristics makes it difficult to take into account the effect of future optimizations.</p><p>Our approach, on the other hand, allows the compiler writer to design profitability heuristics that are global in nature. In particular, rather than choosing whether or not to apply an optimization locally, these heuristics choose between fully optimized versions of the input program. Our approach makes this possible by separating the decision of whether or not a transformation is applicable from the decision of whether or not it is profitable. Indeed, using an optimization to add an equality in our approach does not indicate a decision to perform the transformation -the added equality just represents the option of picking that transformation later. The actual decision of which transformations to apply is performed by a global heuristic after our IR has been saturated with equalities. This global heuristic simply chooses among the various optimized versions of the input program that are represented in the saturated IR, and so it has a global view of all the transformations that were tried and what programs they generated.</p><p>There are many ways to implement this global profitability heuristic, and in our prototype compiler we have chosen to implement it using a Pseudo-Boolean solver (a form of Integer Linear Programming solver). In particular, after our IR has been saturated with equalities, we use a Pseudo-Boolean solver and a static cost model for every node to pick the lowest-cost program that computes the same result as the original program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Translation validation.</head><p>The third benefit of our approach is that it can be used not only to optimize programs, but also to prove programs equivalent: intuitively, if two programs are found equal after equality saturation, then they are equivalent. Our approach can therefore be used to perform translation validation, a technique that consists of automatically checking whether or not the optimized version of an input program is semantically equivalent to the original program. For example, we can prove the correctness of optimizations performed by existing compilers, even if our profitability heuristic would not have selected those optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions.</head><p>The contributions of this paper can therefore be summarized as follows:</p><p>• We present a new approach for structuring optimizers. In our approach optimizations add equality information to a common IR that simultaneously represents multiple optimized versions of the input program. Our approach obviates the need to worry about optimization ordering, it enables the use of a global optimization heuristic (such as a Pseudo-Boolean solver), and it can be used to perform translation validation for any compiler. Sections 2 and 3 present an overview of our approach and its capabilities, Section 4 makes our approach formal, and Section 5 describes the new IR that allows our approach to be effective. • We have instantiated our approach in a new Java bytecode optimizer called Peggy (Section 6). Peggy uses our approach not only to optimize Java methods, but also to perform translation validation for existing compilers. Our experimental results (Section 7) show that our approach (1) is practical both in terms of time and space overhead, ( <ref type="formula">2</ref>) is effective at discovering both simple and intricate optimization opportunities and ( <ref type="formula">3</ref>) is effective at performing translation validation for a realistic optimizer -Peggy is able to validate 98% of the runs of the Soot optimizer <ref type="bibr" target="#b34">[35]</ref>, and within the remaining 2% it uncovered a bug in Soot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview</head><p>Our approach for structuring optimizers is based on the idea of having optimizations propagate equality information to a common IR that simultaneously represents multiple optimized versions of the input program. The main challenge in designing this IR is that it must make equality reasoning effective and efficient.</p><p>To make equality reasoning effective, our IR needs to support the same kind of basic reasoning that one would expect from simple equality axioms like a * (b + c) = a * b + a * c, but with more complicated computations such as branches and loops. We have designed a representation for computations called Program Expression Graphs (PEGs) that meets these requirements. Similar to the gated SSA representation <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b18">19]</ref>, PEGs are referentially transparent, which intuitively means that the value of an expression depends only on the value of its constituent expressions, without any side-effects. As has been observed previously in many contexts, referential transparency makes equality reasoning simple and effective. However, unlike previous SSA-based representations, PEGs are also complete, which means that there is no need to maintain any additional representation such as a control flow graph (CFG). Completeness makes it easy to use equality for performing transformations: if two PEG nodes are equal, then we can pick either one to create a well-formed program, without worrying about the implications on any underlying representation.</p><p>In addition to being effective, equality reasoning in our IR must be efficient. The main challenge is that each added equality can potentially double the number of represented programs, thus making the number of represented programs exponential in the worst case. To address this challenge, we record equality information of PEG nodes by simply merging PEG nodes into equivalence classes. We call the resulting equivalence graph an E-PEG, and it is this E-PEG representation that we use in our approach. Using equivalence classes allows E-PEGs to efficiently represent exponentially many ways of expressing the input program, and it also allows the equality saturation engine to efficiently take into account previously discovered equalities. Among existing IRs, E-PEGs are unique in their ability to represent multiple optimized versions of the input program. A more detailed discussion of how PEGs and E-PEGs relate to previous IRs can be found in Section 8. We illustrate the main features of our approach by showing how it can be used to implement loop-induction-variable strength reduction. The idea behind this optimization is that if all assignments to a variable i in a loop are increments, then an expression i * c in the loop (with c being loop invariant) can be replaced with i, provided all the increments of i in the loop are appropriately scaled by c.</p><p>As an example, consider the code snippet from Figure <ref type="figure" target="#fig_0">1</ref>(a). The use of i*5 inside the loop can be replaced with i as long as the two increments in the loop are scaled by 5. The resulting code is shown in Figure <ref type="figure" target="#fig_0">1</ref>(b).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Program Expression Graphs</head><p>A Program Expression Graph (PEG) is a graph containing: (1) operator nodes, for example "plus", "minus", or any of our built-in nodes for representing conditionals and loops (2) "dataflow" edges that specify where operator nodes get their arguments from. As an example, the PEG for the use of i*5 in Figure <ref type="figure" target="#fig_0">1</ref>(a) is shown in Figure <ref type="figure" target="#fig_1">2</ref>(a). At the very top of the PEG we see node 1, which represents the i*5 multiply operation from inside the loop. Each PEG node represents an operation, with the children nodes being the arguments to the operation. The links from parents to children are shown using solid (non-dashed) lines. For example, node 1 represents the multiplication of node 2 by the constant 5. PEGs follow the notational convention used in E-graphs <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b12">13]</ref> and Abstract Syntax Trees (ASTs) of displaying operators above the arguments that flow into them, which is the opposite convention typically used in Dataflow Graphs <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b1">2]</ref>. We use the E-graph/AST orientation because we think of PEGs as recursive expressions.</p><p>Node 2 in our PEG represents the value of variable i inside the loop, right before the first instruction in the loop is executed. We use θ nodes to represent values that vary inside of a loop. Intuitively, the left child of a θ node computes the initial value, whereas the right child computes the value at the current iteration in terms of the value at the previous iteration. In our example, the left child of the θ node is the constant 0, representing the initial value of i. The right child of the θ node uses nodes 3, 4, and 5 to compute the value of i at the current iteration in terms of the value of i from the previous iteration. The two plus nodes (nodes 4 and 5) represent the two increments of i in the loop, whereas the φ node (node 3) represents the merging of the two values of i produced by the two plus nodes. As in gated SSA <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b18">19]</ref>, our φ nodes are executable: the first (left-most) argument to φ is a selector that is used to select between the second and the third argument. Our example doesn't use the branch condition in an interesting way, and so we just let δ represent the PEG sub-graph that computes the branch condition.</p><p>From a more formal point of view, each θ node produces a sequence of values, one value for each iteration of the loop. The first argument of a θ node is the value for the first iteration, whereas the second argument is a sequence that represents the values for the remaining iterations. For example, in Figure <ref type="figure" target="#fig_1">2</ref>, the nodes labeled 3 through 5 compute this sequence of remaining values in terms of the sequence produced by the θ node. In particular, nodes 3, 4 and 5 have been implicitly lifted to operate on this sequence.</p><p>PEGs are well-suited for equality reasoning because all PEG operators, even those for branches and loops, are mathematical functions with no side effects. As a result, PEGs are referentially transparent, which allows us to perform the same kind of equality reasoning that one is familiar with from mathematics. Even though all PEG operators are pure, PEGs can still represent programs with state by using heap summary nodes. Section 6 explains how our Peggy compiler uses such heap summary nodes to represent the state of Java objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Encoding equalities using E-PEGs</head><p>A PEG by itself can only represent a single way of expressing the input program. To represent multiple optimized versions of the input program, we need to encode equalities in our representation. To this end, an E-PEG is a graph that groups together PEG nodes that are equal into equivalence classes. As an example, Figure <ref type="figure" target="#fig_1">2(b)</ref> shows the E-PEG that our engine produces from the PEG of Figure <ref type="figure" target="#fig_1">2(a)</ref>. We display equalities graphically by adding a dashed edge between two nodes that have become equal. These dashed edges are only a visualization mechanism. In reality, PEG nodes that are equal are grouped together into an equivalence class.</p><p>Reasoning in an E-PEG is done through the application of optimizations, which in our approach take the form of equality analyses that add equality information to the E-PEG. An equality analysis consists of two components: a trigger, which is an expression pattern stating the kinds of expressions that the analysis is interested in, and a callback function, which should be invoked when the trigger pattern is found in the E-PEG. The saturation engine continuously monitors all the triggers simultaneously, and invokes the necessary callbacks when triggers match. When invoked, a callback function adds the appropriate equalities to the E-PEG.</p><p>The simplest form of equality analysis consists of instantiating axioms such as a * 0 = 0. In this case, the trigger would be a * 0, and the callback function would add the equality a * 0 = 0. Even though the vast majority of our reasoning is done through such declarative axiom application, our trigger and callback mechanism is much more general, and has allowed us to implement equality analyses such as inlining, tail-recursion elimination, and constant folding.</p><p>The following three axioms are the equality analyses required to perform loop-induction-variable strength reduction. They state that multiplication distributes over addition, θ, and φ:</p><formula xml:id="formula_0">(a + b) * m = a * m + b * m (1) θ(a, b) * m = θ(a * m, b * m) (2) φ(a, b, c) * m = φ(a, b * m, c * m) (3)</formula><p>After a program is converted to a PEG, a saturation engine repeatedly applies equality analyses until either no more equalities can be added, or a bound is reached on the number of expressions that have been processed by the engine. As Section 7 will describe in more details, our experiments show that 84% of methods can be completely saturated, without any bounds being imposed.</p><p>Figure <ref type="figure" target="#fig_1">2</ref>(b) shows the saturated E-PEG that results from applying the above distributivity axioms, along with a simple constant folding equality analysis. In particular, distributivity is applied four times: axiom (2) adds equality edge A, axiom (3) edge B, axiom (1) edge C, and axiom (1) edge D. Our engine also applies the constant folding equality analysis to show that 0 * 5 = 0, 3 * 5 = 15 and 1 * 5 = 5. Note that when axiom (2) adds edge A, it also adds node 7, which then enables axiom (3). Thus, equality analyses essentially communicate with each other by propagating equalities through the E-PEG. Furthermore, note that the instantiation of axiom (1) adds node 12 to the E-PEG, but it does not add the right child of node 12, namely θ(. . .) * 5, because it is already represented in the E-PEG.</p><p>Once saturated with equalities, an E-PEG compactly represents multiple optimized versions of the input program -in fact, it compactly represents all the programs that could result from applying the optimizations in any order to the input program. For example, the E-PEG in Figure <ref type="figure" target="#fig_1">2</ref>(b) encodes 128 ways of expressing the original program (because it encodes 7 independent equalities, namely the 7 dashed edges). In general, a single E-PEG can efficiently represent exponentially many ways of expressing the input program.</p><p>After saturation, a global profitability heuristic can pick which optimized version of the input program is best. Because this profitability can inspect the entire E-PEG at once, it has a global view of the programs produced by various optimizations, after all other optimizations were also run. In our example, starting at node 1, by choosing nodes 6, 8, 10, and 12, we can construct the graph in Figure 2(c), which corresponds exactly to performing loop-inductionvariable strength reduction in Figure <ref type="figure" target="#fig_0">1(b)</ref>.</p><p>More generally, when optimizing an entire function, one has to pick a node for the equivalence class of the return value and nodes for all equivalence classes that the return value depends on. There are many plausible heuristics for choosing nodes in an E-PEG. In our Peggy implementation, we have chosen to select nodes using a Pseudo-Boolean solver, which is an Integer Linear Programming solver where variables are constrained to 0 or 1. In particular, we use a Pseudo-Boolean solver and a static cost model for every node to compute the lowest-cost program that is encoded in the E-PEG. In the example from Figure <ref type="figure" target="#fig_1">2</ref>, the Pseudo-Boolean solver picks the nodes described above. Section 6.3 describes our technique for selecting nodes in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Benefits of our approach</head><p>Optimization order does not matter. To understand how our approach addresses the phase ordering problem, consider a simple peephole optimization that transforms i * 5 into i &lt;&lt; 2 + i.</p><p>On the surface, one may think that this transformation should always be performed if it is applicable -after all, it replaces a multiplication with the much cheaper shift and add. In reality, however, this peephole optimization may disable other more profitable transformations. The code from Figure <ref type="figure" target="#fig_0">1</ref>(a) is such an example: trans-forming i * 5 to i &lt;&lt; 2 + i disables loop-induction-variable strength reduction, and therefore generates code that is worse than the one from Figure <ref type="figure" target="#fig_0">1(b)</ref>.</p><p>The above example illustrates the ubiquitous phase ordering problem. In systems that apply optimizations sequentially, the quality of the generated code depends on the order in which optimizations are applied. Whitfield and Soffa <ref type="bibr" target="#b39">[40]</ref> have shown experimentally that enabling and disabling interactions between optimizations occur frequently in practice, and furthermore that the patterns of interaction vary not only from program to program, but also within a single program. Thus, no one order is best across all compilation.</p><p>A common partial solution consists of carefully considering all the possible interactions between optimizations, possibly with the help of automated tools, and then coming up with a carefully tuned sequence for running optimizations that strives to enable most of the beneficial interactions. This technique, however, puts a heavy burden on the compiler writer, and it also does not account for the fact that the best order may vary between programs.</p><p>At high levels of optimizations, some compilers may even run optimizations in a loop until no more changes can be made. Even so, if the compiler picks the wrong optimization to start with, then no matter what optimizations are applied later, in any order, any number of times, the compiler will not be able to reverse the disabling consequences of the first optimization.</p><p>In our approach, the compiler writer does not need to worry about the order in which optimizations are applied. The previous peephole optimization would be expressed as the axiom i * 5 = i &lt;&lt; 2 + i. However, unlike in a traditional compilation system, applying this axiom in our approach does not remove the original program from the representation -it only adds information -and so it cannot disable other optimizations. Therefore, the code from Figure <ref type="figure" target="#fig_0">1</ref>(b) would still be discovered, even if the peephole optimization was run first. In essence, our approach is able to simultaneously explore all possible sequences of optimizations, while sharing work that is common across the various sequences.</p><p>In addition to reducing the burden on compiler writers, removing the need to think about optimization ordering has two additional benefits. First, because optimizations interact freely with no regard to order, our approach often ends up combining optimizations in unanticipated ways, leading to surprisingly complicated optimizations given how simple our equality analyses are -Section 3 gives such an example. Second, it makes it easier for end-user programmers to add domain-specific axioms to the compiler, because they </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Global profitability heuristics.</head><p>Profitability heuristics in traditional compilers tend to be local in nature, making it difficult to take into account the effect of future optimizations. For example, consider inlining. Although it is straightforward to estimate the direct cost of inlining (the code-size increase) and the direct benefit of inlining (the savings from removing the call overhead), it is far more difficult to estimate the potentially larger indirect benefit, namely the additional optimization opportunities that inlining exposes.</p><p>To see how inlining would affect our running example, consider again the code from Figure <ref type="figure" target="#fig_0">1</ref>(a), but assume that instead of use(i * 5), there was a call to a function f, and the use of i*5 occurred inside f. If f is sufficiently large, a traditional inliner would not inline f, because the code bloat would outweigh the call-overhead savings. However, a traditional inliner would miss the fact that it may still be worth inlining f, despite its size, because inlining would expose the opportunity for loop-inductionvariable strength reduction. One solution to this problem consists of performing an inlining trial <ref type="bibr" target="#b11">[12]</ref>, where the compiler simulates the inlining transformation, along with the effect of subsequent optimizations, in order to decide whether or not to actually inline. However, in the face of multiple inlining decisions (or more generally multiple optimization decisions), there can be exponentially many possible outcomes, each one of which has to be compiled separately.</p><p>In our approach, on the other hand, inlining simply adds an equality to the E-PEG stating that the call to a given function is equal to its body instantiated with the actual arguments. The resulting E-PEG simultaneously represents the program where inlining is performed and where it is not. Subsequent optimizations then operate on both of these programs at the same time. More generally, our approach can simultaneously explore exponentially many possibilities in parallel, while sharing the work that is redundant across these various possibilities. In the above example with inlining, once the E-PEG is saturated, a global profitability heuristic can make a more informed decision as to whether or not to pick the inlined version, since it will be able to take into account the fact that inlining enabled loop-induction-variable strength reduction.</p><p>Translation Validation. Unlike traditional compilation frameworks, our approach can be used not only to optimize programs, but also to establish equivalences between programs. In particular, if we convert two programs into an E-PEG, and then saturate it with equalities, then we can conclude that the two programs are equivalent if they belong to the same equivalence class in the saturated E-PEG. In this way, our approach can be used to perform translation validation for any compiler (not necessarily our own), by checking that each function in the input program is equivalent to the corresponding optimized function in the output program.</p><p>For example, our approach would be able to show that the two program fragments from Figure <ref type="figure" target="#fig_0">1</ref> are equivalent. Furthermore, it would also be able to validate a compilation run in which i * 5 = i &lt;&lt; 2 + i was applied first to Figure <ref type="figure" target="#fig_0">1(a)</ref>. This shows that we are able to perform translation validation regardless of what optimized program our own profitability heuristic would choose.</p><p>Although our translation validation technique is intraprocedural, we can use interprocedural equality analyses such as inlining to enable a certain amount of interprocedural reasoning. This allows us to reason about transformations like reordering function calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Reasoning about loops</head><p>This section shows how our approach can be used to reason across nested loops. The example highlights the fact that a simple axiom set can produce unanticipated optimizations which traditional compilers would have to explicitly search for.</p><p>We start in Sections 3.1 and 3.2 by describing all PEG constructs used to represent loops. We then show in Section 3.3 how our approach can perform an inter-loop strength reduction optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Single loop</head><p>Consider the simple loop from Figure <ref type="figure" target="#fig_2">3(a)</ref>. This loop iterates 15 times, incrementing the value of i each time by 2. Assume that the variable i is used inside the loop, and it is also used after the loop (as indicated by the two use annotations). The PEG for this code is shown in Figure <ref type="figure" target="#fig_2">3(d)</ref>. The value of i inside the loop is represented by a θ node. Intuitively, this θ node produces the sequence of values that i takes throughout the loop, in this case [0, 2, 4, . . .]. The value of i after the loop is represented by the eval node at the top of the PEG. Given a sequence s and an index n, eval (s, n) produces the n th element of sequence s. To determine which element to select from a sequence, our PEG representation uses pass nodes. Given a sequence s of booleans, pass(s) returns the index of the first element in the sequence that is true. In our example, the ≥ node uses the result of the θ node to produce the sequence of values taken on by the boolean expression i ≥ 29 throughout the loop. This sequence is then sent to pass, which in this case produces the value 15, since the 15 th value (counting from 0) of i in the loop (which is 30) is the first one to make i ≥ 29 true. The eval node then selects the 15 th element of the sequence produced by the θ node, which is 30. In our previous example from Section 2, we omitted eval /pass from the PEG for clarity -because we were not interested in any of the values after the loop, the eval /pass nodes would not have been used in any reasoning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Nested loops</head><p>We now illustrate, through an example, how nested loops can be encoded in our PEG representation. Consider the code snippet from Figure <ref type="figure" target="#fig_2">3</ref>(b), which has two nested loops. We are interested in the value of sum inside the loop, as indicated by the use annotation. The PEG for this code snippet is shown in Figure <ref type="figure" target="#fig_2">3</ref>(e). Each θ, eval and pass node is labeled with a subscript indicating what loop depth it operates on (we previously omitted these subscripts for clarity). The node labeled suminner represents the value of sum at the beginning of the inner loop body. Similarly, sumouter is the value of sum at the beginning of the outer loop body. Looking at suminner , we can see that: (1) on the first iteration (the left child of suminner ), suminner gets the value of sum from the outer loop; (2) on other iterations, it gets one plus the value of sum from the previous iteration of the inner loop. Looking at sumouter , we can see that: (1) on the first iteration, sumouter gets 0; on other iterations, it gets the value of sum right after the inner loop terminates. The value of sum after the inner loop terminates is computed using a similar eval /pass pattern as in Figure <ref type="figure" target="#fig_2">3(d)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Inter-loop strength reduction</head><p>Our approach allows an optimizing compiler to perform intricate optimizations of looping structures. We present such an example here, with a kind of inter-loop strength reduction. Consider the code snippet from Figure <ref type="figure" target="#fig_2">3</ref>(c), which is equivalent to one we've already seen in Figure <ref type="figure" target="#fig_2">3(b)</ref>. However, the code in 3(b) is faster because sum++ is cheaper than i * 10 + j. We show how our approach can transform the code in Figure <ref type="figure" target="#fig_2">3</ref>(c) to the code in Figure <ref type="figure" target="#fig_2">3(b)</ref>.</p><p>Figure <ref type="figure" target="#fig_2">3</ref>(f) shows the PEG for i*10 + j, which will be the focus of our optimization. We omit eval and pass in this PEG because they are not used in this example, except in one step that we will make explicit.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the saturated E-PEG that results from running the saturation engine on the PEG from Figure <ref type="figure" target="#fig_2">3</ref>(f). The checkmarks indicate which nodes will eventually be selected -they can be ignored for now. To make the graph more readable, we sometimes label nodes, and then connect an edge directly to a label name, rather than connecting it to the node with that label. For example, consider node j in the E-PEG, which reads as θ2(0, 1 + j). Rather than explicitly drawing an edge from + to j, we connect + to a new copy of label j.</p><p>In drawing Figure <ref type="figure" target="#fig_3">4</ref>, we have already performed loop-induction variable strength reduction on the left child of the topmost + from Figure <ref type="figure" target="#fig_2">3</ref>(f). In particular, this left child has been replaced with a new node i, where i = θ1(0, 10 + i). We skip the steps in doing this because they are similar to the ones described in Section 2.2.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the relevant equalities that our saturation engine would add. We describe each in turn.</p><p>• Edge A is added by distributing + over θ2:</p><formula xml:id="formula_1">i + θ2(0, 1 + j) = θ2(i + 0, i + (1 + j))</formula><p>• Edge B is added because 0 is the identity of +, i.e.: i + 0 = i.</p><p>• Edge C is added because addition is associative and commutative: i + (1 + j) = 1 + (i + j) • Edge D is added because 0, incremented n times, produces n:</p><formula xml:id="formula_2">eval (id , pass (id ≥ n)) = n where id = θ (0, 1 + id )</formula><p>This is an example of a loop optimization expressible as a simple PEG axiom.</p><p>• Edge E is added by distributing + over the first child of eval 2:</p><formula xml:id="formula_3">eval 2(j, k) + i = eval 2(j + i, k) • Edge F is added because addition is commutative: j+i = i+j</formula><p>We use checkmarks in Figure <ref type="figure" target="#fig_3">4</ref> to highlight the nodes that Peggy would select using its Pseudo-Boolean profitability heuristic. These nodes constitute exactly the PEG from Figure <ref type="figure" target="#fig_2">3</ref>(e), meaning that Peggy optimizes the code in Figure <ref type="figure" target="#fig_2">3</ref>(c) to the one in Figure <ref type="figure" target="#fig_2">3</ref>(b).</p><p>Summary. This example illustrates several points. First, it shows how a transformation that locally seems undesirable, namely transforming the constant 10 into an expensive loop (edge D), in the end leads to much better code. Our global profitability heuristic is perfectly suited for taking advantage of these situations. Second, it shows an example of an unanticipated optimization, namely an optimization that we did not realize would fall out from the simple equality analyses we already had in place. In a traditional compilation system, a specialized analysis would be required to perform this optimization, whereas in our approach the optimization simply happens without any special casing. In this way, our approach essentially allows a few general equality analyses to do the work of many specialized transformations. Finally, it shows how our approach is able to reason about complex loop interactions, something that is beyond the reach of current super-optimizer-based techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Formalization of our Approach</head><p>Having given an intuition of how our approach works through examples, we now move to a formal description. Figure <ref type="figure" target="#fig_4">5</ref> shows the Optimize function, which embodies our approach. Optimize takes four steps: first, it converts the input CFG into an internal representation of the program; second, it saturates this internal representation with equalities; third, it uses a global profitability heuristic to select the best program from the saturated representation; finally, it converts the selected program back to a CFG.</p><p>An instantiation of our approach therefore consists of three components: <ref type="bibr" target="#b0">(1)</ref> an IR where equality reasoning is effective, along with the translation functions ConvertToIR and ConvertToCFG, (2) a saturation engine Saturate, and (3) a global profitability heuristic SelectBest. Future sections will show how we instantiate these three components in our Peggy compiler. Saturation Engine. The saturation engine Saturate infers equalities by repeatedly running a set A of equality analyses. Given an equality analysis a ∈ A, we define ir1 a → ir 2 to mean that ir 1 produces ir 2 when the equality analysis a runs and adds some equalities to ir 1. If a chooses not to add any equalities, then ir2 is simply the same as ir 1.</p><p>We define a partial order on IRs, based on the equalities they encode: ir 1 ir 2 iff the equalities in ir1 are a subset of the equalities in ir 2. Immediately from this definition, we get:</p><formula xml:id="formula_4">(ir 1 a → ir2) ⇒ ir 1 ir 2<label>(4)</label></formula><p>We define an equality analysis a to be monotonic iff:</p><formula xml:id="formula_5">(ir 1 ir 2) ∧ (ir 1 a → ir 1 ) ∧ (ir 2 a → ir 2 ) ⇒ (ir 1 ir 2 )</formula><p>Intuitively, our approach addresses the phase ordering problem because applying an equality analysis a before b cannot make b less effective, as stated in the following non-interference theorem. THEOREM 1. If a and b are monotonic then:</p><formula xml:id="formula_6">(ir 1 a → ir 2) ∧ (ir 2 b → ir 3) ∧ (ir 1 b → ir 4) ⇒ (ir 4 ir 3)</formula><p>The above follows immediately from monotonicity and Property 4.</p><p>We now define ir 1 → ir 2 as:</p><formula xml:id="formula_7">ir 1 → ir 2 ⇐⇒ ∃a ∈ A . (ir 1 a → ir 2 ∧ ir 1 = ir 2)</formula><p>The → relation formalizes one step taken by the saturation engine.</p><p>We also define → * to be the reflexive transitive closure of →. The → * relation formalizes an entire run of the saturation engine. Given a set A of monotonic equality analyses, if the saturation engine terminates, then it is canonizing, where canonizing means that for any ir 1, there is a unique ir 2 with the following properties:</p><p>(1) ir 1 → * ir 2 and (2) there is no ir 3 such that ir 2 → ir 3. In this case the saturation engine computes this canonical saturated IR, which means that Optimize returns the same result no matter what order optimizations run in.</p><p>Because in general saturation may not terminate, we bound the number of times that analyses can run. In this case we cannot provide the same canonizing property, but the non-interference theorem (Theorem 1) still implies that no area of the search space can be made unreachable by applying an equality analysis (a property that traditional compilation systems lack).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PEGs and E-PEGs</head><p>The first step in instantiating our approach from the previous section is to pick an appropriate IR. To this end, we have designed a new IR called the E-PEG which can simultaneously represent multiple optimized versions of the input program. We first give a formal description of our IR (Section 5.1), then we present its benefits (Section 5.2), and finally we give a high-level description of how to translate from CFGs to our IR and back (Section 5.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Formalization of PEGs and E-PEGs</head><p>A PEG is a triple (N , L, C ), where N is a set of nodes, L : N → F is a labeling that maps each node to a semantic function from a set of semantic functions F , and C : N → list[N ] is a function that maps each node to its children (i.e. arguments).</p><p>Types. Before giving the definition of semantic functions, we first define the types of values that these functions operate over. Values that flow through a PEG are lifted in two ways. First, they are ⊥-lifted, meaning that we add the special value ⊥ to each type domain. The ⊥ value indicates that the computation fails or does not terminate. Formally, for each type τ , we define b τ = τ ∪ {⊥}. Second, values are loop-lifted, which means that instead of representing the value at a particular iteration, PEG nodes represent values for all iterations at the same time. Formally, we let L be a set of loop identifiers, with each ∈ L representing a loop from the original code (in our previous examples we used integers). We assume a partial order ≤ that represents the loop nesting structure: &lt; means that is nested within . An iteration index i captures the iteration state of all loops in the PEG. In particular, i is a function that maps each loop identifier ∈ L to the iteration that loop is currently on. Suppose for example that there are two nested loops in the program, identified as 1 and 2. Then the iteration index i = [ 1 → 5, 2 → 3] represents the state where loop 1 is on the 5 th iteration and loop 2 is on the 3 rd iteration. We let I = L → N be the set of all loop iteration indices (where N denotes the set of non-negative integers). For i ∈ I, we use the notation i[ → v] to denote a function that returns the same value as i on all inputs, except that it returns v on input . The output of a PEG node is a map from loop iteration indices in I to values. In particular, for each type τ , we define a loop-lifted version e τ = I → b τ . PEG nodes operate on these loop-lifted types.</p><p>Semantic Functions. The set of semantic functions F is divided into two: F = Prims ∪ Domain where Prims contains the primitive functions like φ and θ, which are built into the PEG representation, whereas Domain contains semantic functions for particular domains like arithmetic. Figure <ref type="figure" target="#fig_5">6</ref> gives the definition of the primitive functions Prims = {φ, θ , eval , pass }. These functions are polymorphic in τ , in that they can be instantiated for various τ 's, ranging from basic types like integers and strings to complicated types like the heap summary nodes that Peggy uses to represent Java objects. The definitions of eval and pass make use of the function monotonize , whose definition is given in Figure <ref type="figure" target="#fig_5">6</ref>. The monotonize function transforms a sequence so that, once an indexed value is undefined, all following indexed values are undefined. The monotonize function formalizes the fact that once a value is undefined at a given loop iteration, the value remains undefined at subsequent iterations.</p><p>The domain semantic functions are defined as Domain = { e op | op ∈ DomainOp}, where DomainOp is a set of domain operators (like +, * andin the case of arithmetic), and e op is a ⊥-lifted, and then loop-lifted version of op. Intuitively, the ⊥-lifted version of an operator works like the original operator except that it returns ⊥ if any of its inputs are ⊥, and the loop-lifted version of an operator applies the original operator for each loop index.</p><p>As an example, the semantic function of + in a PEG is e +, and the semantic function of 1 is e 1 (since constants like 1 are simply nullary operators). However, to make the notation less crowded, we omit the tildes on all domain operators. Node Semantics. For a PEG node n ∈ N , we denote its semantic value by n . We assume that • is lifted to sequences list[N ] in the standard way. The semantic value of n is defined as:</p><formula xml:id="formula_8">n = L(n)( C (n) )<label>(5)</label></formula><p>Equation 5 is essentially the evaluation semantics for expressions. The only complication here is that our expression graphs are recursive. In this setting, one can think of Equation 5 as a set of recursive equations to be solved. To guarantee that a unique solution exists, we impose some well-formedness constraints on PEGs.</p><formula xml:id="formula_9">φ : e B × e τ × e τ → e τ θ : e τ × e τ → e τ φ(cond, t, f)(i) = 8 &gt; &lt; &gt; : if cond(i) = ⊥ then ⊥ if cond(i) = true then t(i) if cond(i) = false then f (i) θ (base, loop)(i) = ( if i( ) = 0 then base(i) if i( ) &gt; 0 then loop(i[ → i( ) -1]) eval : e τ × e N → e τ pass : e B → e N eval (loop, idx )(i) = ( if idx (i) = ⊥ then ⊥ else monotonize (loop)(i[ → idx (i)]) pass (cond )(i) = ( if I = ∅ then ⊥ if I = ∅ then min I where I = {i ∈ N | monotonize (cond )(i[ → i]) = true}</formula><p>where monotonize : e τ → e τ is defined as: 1. All cycles pass through the second child edge of a θ 2. A path from a θ , eval , or pass to a θ implies ≤ or the path passes through the first child edge of an eval or pass 3. All cycles containing eval or pass contain some θ with &lt; Condition 1 states that all cyclic paths in the PEG are due to looping constructs. Condition 2 states that a computation in an outer-loop cannot reference a value from inside an inner-loop. Condition 3 states that the final value produced by an inner-loop cannot be expressed in terms of itself, except if it's referencing the value of the inner-loop from a previous outer-loop iteration.</p><formula xml:id="formula_10">monotonize (value)(i) = ( if ∃ 0 ≤ i &lt; i( ). value(i[ → i]) = ⊥ then ⊥ if ∀ 0 ≤ i &lt; i( ). value(i[ → i]) = ⊥ then value(i)</formula><p>THEOREM 2. If a PEG is well-formed, then for each node n in the PEG there is a unique semantic value n satisfying Equation <ref type="formula" target="#formula_8">5</ref>.</p><p>The proof is by induction over the strongly-connected-component DAG of the PEG and the loop nesting structure ≤.</p><p>Evaluation Semantics. The meaning function • can be evaluated on demand, which provides an executable semantics for PEGs. For example, suppose we want to know the result of eval (x, pass (y)) at some iteration state i. To determine which case of eval 's definition we are in, we must evaluate pass (y) on i. From the definition of pass , we must compute the minimum i that makes y true. To do this, we iterate through values of i until we find an appropriate one. The value of i we've found is the number of times the loop iterates, and we can use this i back in the eval function to extract the appropriate value out of x. This example shows how an on-demand evaluation of an eval /pass sequence essentially leads to the traditional operational semantics for loops.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E-PEG Semantics.</head><p>An E-PEG is a PEG with a set of equalities E between nodes. An equality between n and n denotes value equality: n = n . The set E forms an equivalence relation, which in turn partitions the PEG nodes into equivalence classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Built-in Axioms.</head><p>We have developed a set of PEG built-in axioms that state properties of the primitive semantic functions. These axioms are used in our approach as a set of equality analyses that enable reasoning about primitive PEG operators. Some important built-in axioms are given below, where • denotes "don't care":</p><formula xml:id="formula_11">θ (A, B) = θ (eval (A, 0), B) eval (θ (A, •), 0) = eval (A, 0) eval (eval (A, B), C) = eval (A, eval (B, C)) pass (true) = 0 pass (θ (true, •)) = 0 pass (θ (false, A)) = pass (A) + 1</formula><p>One of the benefits of having a well-defined semantics for primitive PEG functions is that we can reason formally about these functions. In particular, using our semantics, we have proved all the axioms presented in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">How PEGs enable our approach</head><p>The key feature of PEGs that makes our equality-saturation approach effective is that they are referentially transparent, which intuitively means that the value of an expression depends only on the values of its constituent expressions <ref type="bibr" target="#b4">[5]</ref>. In our PEG representation, referential transparency can be formalized as follows:</p><formula xml:id="formula_12">∀(n, n ) ∈ N 2 . " L(n) = L(n )∧ C (n) = C (n ) « ⇒ n = n</formula><p>This property follows from the definition in Equation ( <ref type="formula" target="#formula_8">5</ref>), and the fact that for any n, L(n) is a pure mathematical function. Referential transparency makes equality reasoning effective because it allows us to show that two expressions are equal by only considering their constituent expressions, without having to worry about side-effects. Furthermore, referential transparency has the benefit that a single node in the PEG entirely captures the value of a complex program fragment, enabling us to record equivalences between program fragments by using equivalence classes of nodes. Contrast this to CFGs, where to record equality between complex program fragments, one would have to record subgraph equality.</p><p>Finally, PEGs allow us to record equalities at the granularity of individual values, for example the iteration count in a loop, rather than at the level of the entire program state. Again, contrast this to CFGs, where the simplest form of equality between program fragments would record program-state equality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Translating between CFGs and PEGs</head><p>To incorporate PEGs and E-PEGs into our approach, we have developed the ConvertToIR and ConvertToCFG functions from Figure <ref type="figure" target="#fig_4">5</ref>. We give only a brief overview of these algorithms, with more details in a technical report <ref type="bibr" target="#b32">[33]</ref>.</p><p>Transforming a CFG into a PEG. The key challenge in constructing a PEG from a CFG is determining the branching structure of the CFG. We perform this task with a function that, given paths from one CFG basic block to another, produces a PEG expression with φ, eval , and pass operations, specifying which path is taken under which conditions. We use this to determine the break conditions of loops and the general branching structure of the CFG. We also identify nesting depth, entry points, and back-edges of loops to construct θ nodes. We piece these components together with the instructions of each basic block to produce the PEG. Lastly, we apply some basic simplifications to remove conversion artifacts. Our conversion algorithm from CFG to PEG handles arbitrary control flow, including irreducible CFGs (by first converting them so they become reducible).</p><p>Transforming a PEG into a CFG. Intuitively, our algorithm first groups parts of the PEG into sub-PEGs; then it recursively converts these sub-PEGs into CFGs; and finally it combines these sub-CFGs into a CFG for the original PEG. The grouping is done as follows: φ nodes are grouped together whose conditions are equal, thus performing branch fusion; θ nodes are grouped together that have equal pass conditions, thus performing loop fusion. The pure mathematical nature of PEGs makes it easy to identify when two conditions are equal, which makes branch/loop fusion simple to implement.</p><p>PEGs follow the insight from Click of separating code placement issues from the IR <ref type="bibr" target="#b8">[9]</ref>. In particular, PEGs do not represent code placement explicitly. Instead, placement is performed during the translation back to a CFG. As a result, the translation from a CFG to a PEG and back (without any saturation) ends up performing a variety of optimizations: Constant Propagation, Copy Propagation, Common Subexpression Elimination, Partial Redundancy Elimination, Unused Assignment Elimination, Unreachable Code Elimination, Branch Fusion, Loop Fusion, Loop Invariant Branch Hoisting/Sinking, Loop Invariant Code Hoisting/Sinking, and Loop Unswitching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">The Peggy Instantiation</head><p>We have instantiated our approach in a Java bytecode optimizer called Peggy. Recall from Figure <ref type="figure" target="#fig_4">5</ref> that an instantiation of our approach consists of three components: <ref type="bibr" target="#b0">(1)</ref> an IR where equality reasoning is effective, along with the translation functions ConvertToIR and ConvertToCFG, (2) a saturation engine Saturate, and (3) a global profitability heuristic SelectBest. We now describe how each of these three components work in Peggy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Intermediate Representation</head><p>Peggy uses the PEG and E-PEG representations which, as explained in Section 5, are well suited for our approach. Because Peggy is a Java bytecode optimizer, an additional challenge is to encode Java-specific concepts like the heap and exceptions in PEGs.</p><p>Heap. We model the heap using heap summaries which we call σ nodes. Any operation that can read and/or write some object state may have to take and/or return additional σ values. Because Java stack variables cannot be modified except by direct assignments, operations on stack variables are precise in our PEGs and do not involve σ nodes. None of these decisions of how to represent the heap are built into the PEG representation. As with any heap summarization strategy, one can have different levels of abstraction, and Function Saturate(peg : PEG, A : set of analyses) : EPEG we have simply chosen one where all objects are put into a single summarization object σ.</p><p>Exceptions. In order to maintain the program state at points where exceptions are thrown, we bundle the exception state into our abstraction of the heap, namely the σ summary nodes. As a result, operations like division which may throw an exception, but do not otherwise modify the heap, now take and return a σ node (in addition to their regular parameters and return values). This forces the observable state at the point where an exception is thrown to be preserved by our optimization process. Furthermore, to preserve Java semantics, Peggy does not perform any optimizations across try/catch boundaries or synchronization boundaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Saturation Engine</head><p>The saturation engine's purpose is to repeatedly dispatch equality analyses. In our implementation an equality analysis is a pair (p, f ) where p is a trigger, which is an E-PEG pattern with free variables, and f is a callback function that should be run when the pattern p is found in the E-PEG. While running, the engine continuously monitors the E-PEG for the presence of the pattern p, and when it is discovered, the engine constructs a matching substitution, which is a map from each node in the pattern to the corresponding E-PEG node. At this point, the engine invokes f with this matching substitution as a parameter, and f returns a set of equalities that the engine adds to the E-PEG. In this way, an equality analysis will be invoked only when events of interest to it are discovered. Furthermore, the analysis does not need to search the entire E-PEG because it is provided with the matching substitution.</p><p>Figure <ref type="figure">7</ref> shows the pseudo-code for Peggy's saturation engine. The call to CreateInitialEPEG on the first line takes the input PEG and generates an E-PEG that initially contains no equality information. The Match function invoked in the loop condition performs pattern matching: if an analysis trigger occurs inside an E-PEG, then Match returns the matching substitution. Once a match occurs, the saturation engine uses AddEqualities to add the equalities computed by the analysis into the E-PEG.</p><p>A remaining concern in Figure <ref type="figure">7</ref> is how to efficiently implement the existential check on line 2. To address this challenge, we adapt techniques from the AI community. In particular, the task of finding the matches on line 2 is similar to the task of determining when rules fire in rule-based expert or planning systems. These systems make use of an efficient pattern matching algorithm called the Rete algorithm <ref type="bibr" target="#b16">[17]</ref>. Intuitively, the Rete algorithm stores the state of partially completed matches in a set of FSMs, and when new information is added to the system, it transitions the appropriate FSM. Our saturation engine uses an adaptation of the Rete algorithm for the E-PEG domain to efficiently implement the check on line 2.</p><p>In general, equality saturation may not terminate. Termination is also a concern in traditional compilers where, for example, inlining recursive functions can lead to unbounded expansion. By using triggers to control when equality edges are added (a technique also used in automated theorem provers), we can often avoid infinite expansion. The trigger for an equality axiom typically looks for the left-hand-side of the equality, and then makes it equal to the right-hand-side. On occasion, though, we use more restrictive triggers to avoid expansions that are likely to be useless. For example, the trigger for the axiom equating a constant with a loop expression used to add edge D in Figure <ref type="figure" target="#fig_3">4</ref> also checks that there is an appropriate "pass" expression. In this way, it does not add a loop to the E-PEG if there wasn't some kind of loop to begin with. Using our current axioms and triggers, our engine completely saturates 84% of the methods in our benchmarks.</p><p>In the remaining cases, we impose a limit on the number of expressions that the engine fully processes (where fully processing an expression includes adding all the equalities that the expression triggers). To prevent the search from running astray and exploring a single infinitely deep branch of the search space, we currently use a breadth-first order for processing new nodes in the E-PEG. This traversal strategy, however, can be customized in the implementation of the Rete algorithm to better control the searching strategy in those cases where an exhaustive search would not terminate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Global Profitability Heuristic</head><p>Peggy's SelectBest function uses a Pseudo-Boolean solver called Pueblo <ref type="bibr" target="#b30">[31]</ref> to select which nodes from an E-PEG to include in the optimized program. A Pseudo-Boolean problem is an integer linear programming problem where all the variables have been restricted to 0 or 1. By using these 0-1 variables to represent whether or not nodes have been selected, we can encode the constraints that must hold for the selected nodes to be a well-formed computation. In particular, for each node or equivalence class x, we define a pseudoboolean variable that takes on the value 1 (true) if we choose to evaluate x, and 0 (false) otherwise. The constraints then state that:</p><p>(1) we must select the equivalence class of the return value; (2) if an equivalence class is selected, we must select one of its nodes;</p><p>(3) if a node is selected, we must select its children's equivalence classes; (4) the chosen PEG is well-formed.</p><p>The cost model that we use assigns a constant cost Cn to each node n. In particular, Cn = basic cost (n) • k depth (n) , where basic cost (n) accounts for how expensive n is by itself, and k depth(n) accounts for how often n is executed. We use depth(n) to denote the loop nesting depth of n, and k is simply a constant, which we have chosen as 20. Using Cn, the objective function we want to minimize is P n∈N Bn • Cn, where N is the set of nodes in the E-PEG, and Bn is the pseudo-boolean variable for node n. Peggy asks Pueblo to minimize this objective function subject to the well-formedness constraints described above. The nodes assigned 1 in the solution that Pueblo returns are selected to form the PEG that SelectBest returns. This PEG is the lowest-cost PEG that is represented in the E-PEG, according to our cost model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Evaluation</head><p>In this section we use our Peggy implementation to validate three hypotheses about our approach for structuring optimizers: our approach is practical both in terms of space and time (Section 7.1), it is effective at discovering both simple and intricate optimization opportunities (Section 7.2), and it is effective at performing translation validation (Section 7.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Time and space overhead</head><p>To evaluate the running time of the various Peggy components, we compiled SpecJVM, which comprises 2,461 methods. For 1% of these methods, Pueblo exceeded a one minute timeout we imposed on it, in which case we just ran the conversion to PEG and back. We imposed this timeout because in some rare cases, Pueblo runs too long to be practical.</p><p>The following table shows the average time in milliseconds taken per method for the 4 main Peggy phases (for Pueblo, a timeout counts as 60 seconds).</p><p>CFG to PEG Saturation Pueblo PEG to CFG Time 13.9 ms 87.4 ms 1,499 ms 52.8 ms All phases combined take slightly over 1.5 seconds. An endto-end run of Peggy is on average 6 times slower than Soot with all of its intraprocedural optimizations turned on. Nearly all of our time is spent in the Pseudo-Boolean solver. We have not focused our efforts on compile-time, and we conjecture there is significant room for improvement, such as better pseudo-boolean encodings, or other kinds of profitability heuristics that run faster.</p><p>Since Peggy is implemented in Java, to evaluate memory footprint, we limited the JVM to a heap size of 200 MB, and observed that Peggy was able to compile all the benchmarks without running out of memory.</p><p>In 84% of compiled methods, the engine ran to complete saturation, without imposing bounds. For the remaining cases, the engine limit of 500 was reached, meaning that the engine ran until fully processing 500 expressions in the E-PEG, along with all the equalities they triggered. In these cases, we cannot provide a completeness guarantee, but we can give an estimate of the size of the explored state space. In particular, using just 200 MB of heap, our E-PEGs represented more than 2 103 versions of the input program (using geometric average).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Implementing optimizations</head><p>The main goal of our evaluation is to demonstrate that common, as well as unanticipated, optimizations result in a natural way from our approach. To achieve this, we implemented a set of basic equality analyses, listed in Figure <ref type="figure">8</ref>(a). We then manually browsed through the code that Peggy generates on a variety of benchmarks (including SpecJVM) and made a list of the optimizations that we observed. Figure <ref type="figure">8(b)</ref> shows the optimizations that we observed fall out from our approach using equality analyses 1 through 6, and Figure <ref type="figure">8</ref>(c) shows optimizations that we observed fall out from our approach using equality analyses 1 through 7.</p><p>With effort similar to what would be required for a compiler writer to implement the optimizations from part (a), our approach enables the more advanced optimizations from parts (b) and (c). Peggy performs some optimizations (for example 15 through 19) that are quite complex given the simplicity of its equality analyses. To implement such optimizations in a traditional compiler, the compiler writer would have to explicitly design a pattern that is specific to those optimizations. In contrast, with our approach these optimizations fall out from the interaction of basic equality analyses without any additional developer effort, and without specifying an order in which to run them. Essentially, Peggy finds the right sequence of equality analyses to apply for producing the effect of these complex optimizations.</p><p>In terms of generated-code quality, Peggy generates code whose performance is comparable to the code generated by Soot's intraprocedural optimizations, which include: common sub-expression elimination, lazy code motion, copy propagation, constant propagation, constant folding, conditional branch folding, dead assignment elimination, and unreachable code elimination. However, intraprocedural optimizations on Java bytecode generally produce only small gains (on the order of a few percent). In the rare cases where significant gains are to be had from intraprocedural optimizations, Peggy excelled. Soot can also perform interprocedural optimizations, such as class-hierarchy-analysis, pointer-analysis, and method-specialization. We did not enable these optimizations when performing our comparison against Soot, because we have not yet attempted to express any interprocedural optimizations. We  With the addition of domain-specific axioms, our approach enables even more optimizations, as shown in part (c). To give a flavor for these domain-specific optimizations, we describe two examples.</p><p>The first is a ray tracer application (5 KLOCs) that one of the authors had previously developed. To make the implementation clean and easy to understand, the author used immutable vector objects in a functional programming style. This approach however introduces many intermediate objects. With a few simple vector axioms, Peggy is able to remove the overhead of these temporary objects, thus performing a kind of deforestation optimization. This makes the application 7% faster, and reduces the number of allocated objects by 40%. Soot is not able to recover any of the overhead, even with interprocedural optimizations turned on. This is an instance of a more general technique where user-defined axioms allow Peggy to remove temporary objects (optimization 23 in Figure <ref type="figure">8</ref>).</p><p>Our second example targets a common programming idiom involving Lists, which consists of checking that a List contains an element e, and if it does, fetching and using the index of the element. If written cleanly, this pattern would be implemented with a branch whose guard is contains(e) and a call to indexOf(e) on the true side of the branch. Unfortunately, contains and indexOf would perform the same linear search, which makes this clean way of writing the code inefficient. Using the equality axiom l.contains(e) = (l.indexOf(e) = -1), Peggy can convert the clean code into the hand-optimized code that programmers typically write, which stores indexOf(e) into a temporary, and then branches if the temporary is not -1. An extensible rewrite system would not be able to provide the same easy solution: although a rewrite of l.contains(e) to (l.indexOf(e) = -1) would remove the redundancy mentioned above, it could also degrade performance in the case where the list implements an efficient hash-based contains. In our approach, the equality simply adds information to the E-PEG, and the profitability heuristic can decide after saturation which option is best, taking the entire context into account. In this way our approach transforms contains to indexOf, but only if indexOf would have been called anyway.</p><p>These two examples illustrate the benefits of user-defined axioms. In particular, the clean, readable, and maintainable way of writing code can sometimes incur performance overheads. Userdefined axioms allow the programmer to reduce these overheads while keeping the code base clean of performance-related hacks. Our approach makes domain-specific axioms easier to add for the end-user programmer, because the programmer does not need to worry about what order the user-defined axioms should be run in, or how they will interact with the compiler's internal optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Translation Validation</head><p>We used Peggy to perform translation validation for the Soot optimizer <ref type="bibr" target="#b34">[35]</ref>. In particular, we used Soot to optimize a set of benchmarks with all of its intraprocedural optimizations turned on. The benchmarks included SpecJVM, along with other programs, comprising a total of 3,416 methods. After Soot finished compiling, for each method we asked Peggy's saturation engine to show that the original method was equivalent to the corresponding method that Soot produced. The engine was able to show that 98% of methods were compiled correctly.</p><p>Among the cases that Peggy was unable to validate, we found three methods that Soot optimized incorrectly. In particular, Soot incorrectly pulled statements outside of an intricate loop, transforming a terminating loop into an infinite loop. It is a testament to the power of our approach that it is able not only to perform optimizations, but also to validate a large fraction of Soot runs, and that in doing so it exposed a bug in Soot. Furthermore, because most false positives are a consequence of our coarse heap model (single σ node), a finer-grained model can increase the effectiveness of translation validation, and it would also enable more optimizations.</p><p>Our equality saturation engine can easily be extended so that, after each translation validation, it generates a machine-checkable proof of equivalence. With this in place, the trusted computing base for our translation validator would only be: (1) the proof checker, (2) the built-in axioms used in translation validation, most of which we have proved by hand, and (3) the conversion from Java bytecode to PEG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related Work</head><p>Superoptimizers. Our approach of computing a set of programs and then choosing from this set is related to the approach taken by super-optimizers <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b15">16]</ref>. Superoptimizers strive to produce optimal code, rather than simply improve programs. Although super-optimizers can generate (near) optimal code, they have so far scaled only to small code sizes, mostly straight line code. Our approach, on the other hand, is meant as a general purpose paradigm that can optimize branches and loops, as shown by the inter-loop optimization from Section 3.</p><p>Our approach was inspired by Denali <ref type="bibr" target="#b20">[21]</ref>, a super-optimizer for finding near-optimal ways of computing a given basic block. Denali represents the computations performed in the basic block as an expression graph, and applies axioms to create an E-graph data structure representing the various ways of computing the values in the basic block. It then uses repeated calls to a SAT solver to find the best way of computing the basic block given the equalities stored in the E-graph. The biggest difference between our work and Denali is that our approach can perform intricate optimizations involving branches and loops. On the other hand, the Denali cost model is more precise than ours because it assigns costs to entire sequences of operations, and so it can take into account the effects of scheduling and register allocation.</p><p>Rewrite-based optimizers. Axioms or rewrite-rules have been used in many compilation systems, for example TAMPR <ref type="bibr" target="#b5">[6]</ref>, ASF+SDF <ref type="bibr" target="#b35">[36]</ref>, the ML compilation system of Visser et al. <ref type="bibr" target="#b36">[37]</ref>, and Stratego <ref type="bibr" target="#b6">[7]</ref>. These systems, however, perform transformations in sequence, with each axiom or rewrite rule destructively updating the IR. Typically, such compilers also provide a mechanism for controlling the application of rewrites through built-in or userdefined strategies. Our approach, in contrast, does not use strategies -we instead simultaneously explore all possible optimization orderings, while avoiding redundant work. Furthermore, even with no strategies, we can perform a variety of intricate optimizations.</p><p>Optimization Ordering. Many research projects have been aimed at mitigating the phase ordering problem, including automated assistance for exploring enabling and disabling properties of optimizations <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref>, automated techniques for generating good sequences <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b21">22]</ref>, manual techniques for combining analyses and optimizations <ref type="bibr" target="#b7">[8]</ref>, and automated techniques for the same purpose <ref type="bibr" target="#b22">[23]</ref>. However, we tackle the problem from a different perspective than previous approaches, in particular, by simultaneously exploring all possible sequences of optimizations, up to some bound. Aside from the theoretical guarantees from Section 4, our approach can do well even if every part of the input program requires a different ordering.</p><p>Translation Validation. Although previous approaches to translation validation have been explored <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b41">42]</ref>, our approach has the advantage that it can perform translation validation by using the same technique as for program optimization.</p><p>Intermediate Representations. Our main contribution is an approach for structuring optimizers based on equality saturation. However, to make our approach effective, we have also designed the E-PEG representation. There has been a long line of work on developing IRs that make analysis and optimizations easier to perform <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b28">29]</ref>. The key distinguishing feature of E-PEGs is that a single E-PEG can represent many optimized versions of the input program, which allows us to use global profitability heuristics and to perform translation validation.</p><p>We now compare the PEG component of our IR with previous IRs. PEGs are related to SSA <ref type="bibr" target="#b10">[11]</ref>, gated SSA <ref type="bibr" target="#b33">[34]</ref> and thinnedgated SSA <ref type="bibr" target="#b18">[19]</ref>. The μ function from gated SSA is similar to our θ function, and the η function is similar to our eval /pass pair. However, unlike PEGs, all these variants of SSA are tried to an underlying CFG representation.</p><p>Program Dependence Graphs <ref type="bibr" target="#b14">[15]</ref> and the Program Dependence Web <ref type="bibr" target="#b27">[28]</ref> represent control information by grouping together operations that execute in the same control region. However, these IRs are still statement based, and maintain explicit control edges.</p><p>Like PEGs, the Value Dependence Graph <ref type="bibr" target="#b37">[38]</ref> (VDG) is a complete functional representation. VDGs use λ nodes (i.e. regular function abstraction) to represent loops, whereas we use specialized θ, eval and pass nodes. These specialized nodes, combined with simple axioms about them, allow us to perform intricate optimizations across loops, such as the optimization from Section 3.</p><p>Dependence Flow Graphs <ref type="bibr" target="#b28">[29]</ref> (DFGs) are a complete and executable representation of programs based on dependencies. However, DFGs employ a side-effecting storage model with an imperative store operation, whereas our representation is entirely functional, making equational reasoning more natural.</p><p>Dataflow Languages. Our PEG intermediate representation is related to the broad area of dataflow languages <ref type="bibr" target="#b19">[20]</ref>. The most closely related is the Lucid programming language <ref type="bibr" target="#b2">[3]</ref>, in which variables are maps from iteration counts to possibly undefined values, as in our PEGs. Lucid's first/next operators are similar to our θ nodes, and Lucid's as soon as operator is similar to our eval /pass pair. However, Lucid and PEGs differ in their intended use and application. Lucid is a programming language designed to make formal proofs of correctness easier to do, whereas Peggy uses equivalences of PEG nodes to optimize code expressed in existing imperative languages. Furthermore, we incorporate a monotonize function into our semantics and axioms, which guarantees the correctness of our conversion to and from CFGs with loops.</p><p>Theorem Proving. Because most of our reasoning is performed using simple axioms, our work is related to the broad area of automated theorem proving. The theorem prover that most inspired our work is Simplify <ref type="bibr" target="#b12">[13]</ref>, with its E-graph data structure for representing equalities <ref type="bibr" target="#b26">[27]</ref>. Our E-PEGs are in essence specialized E-graphs for reasoning about PEGs. Furthermore, the way our analyses communicate through equality is conceptually similar to the equality propagation approach used in Nelson-Oppen theorem provers <ref type="bibr" target="#b25">[26]</ref>.</p><p>Execution Indices. Execution indices identify the state of progress of an execution <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b40">41]</ref>. The call stack typically acts as the interprocedural portion, and the loop iteration counts in our semantics can act as the intraprocedural portion. As a result, one of the benefits of PEGs is that they make intraprocedural execution indices explicit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusion and future work</head><p>We have presented a new approach to structuring optimizers that is based on equality saturation. Our approach has a variety of benefits over previous compilation models: it addresses the phase ordering problem, it enables global profitability heuristics, and it performs translation validation.</p><p>There are a variety of directions for future work. One direction is to extend Peggy so that it generates a proof of correctness for the optimizations it performs. Each step in this proof would be the application of an equality analysis. Since the majority of our analyses are axiom applications, these proofs would be similar to standard mathematical proofs. We would then like to use these proofs as a way of automatically generating optimizations. In particular, by determining which nodes of the original PEG the proof depends on, and what properties of these nodes are important, we will explore how one can generalize not only the proof but also the transformation. Using such an approach, we hope to develop a compiler that can learn optimizations as it compiles.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Loop-induction-variable strength reduction: (a) shows the original code, and (b) shows the optimized code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Loop-induction-variable Strength Reduction using PEGs: (a) shows the original PEG, (b) shows the E-PEG that our engine produces from the original PEG and (c) shows the optimized PEG, which results by choosing nodes 6, 8, 10, and 12 from (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Various loops and their PEG representations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. E-PEG that results from running the saturation engine on the PEG from Figure 3(f). By picking the nodes that are checkmarked, we get the PEG from Figure 3(e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FunctionFigure 5 .</head><label>5</label><figDesc>Figure 5. Optimization phase in our approach. We assume a global set A of equality analyses to be run.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Definition of primitive PEG functions. The important notation: L is the set of loop identifiers, N is the set of non-negative integers, B is the set of booleans, I = L → N, b τ = τ ∪ {⊥}, and e τ = I → b τ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 :Figure 7 .</head><label>17</label><figDesc>Figure 7. Peggy's Saturation Engine. We use S to denote the set of all substitutions from pattern nodes to E-PEG nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>1. Built-in E-PEG axioms Axioms from Section 5.1 stating properties of primitive PEG nodes (φ, θ, eval , pass) 2. Basic Arithmetic Axioms Axioms stating properties of arithmetic operators like +, -, * , /, &lt;&lt;, &gt;&gt; Domain-specific Redundancy Removal Removes redundant computations based on domain axioms 23. Temporary Object Removal Removes temporary objects created by calls to matrix/vector libraries 24. Specialization of Math Libraries Specializes vector/matrix algorithms based on, for example, the size of the vector/matrix 25. Design-pattern Optimizations Removes overhead of certain design patterns, like the indirection or interpreter pattern 26. Method Outlining Replaces code by call to a method performing the same computation, but more efficiently 27. Specialized Redirection Replaces method call with call to a more efficient version based on the calling context</figDesc><table><row><cell>3. Constant Folding</cell><cell>Equates a constant expression with its constant value</cell></row><row><cell>4. Java-specific Axioms</cell><cell>Axioms stating properties of Java-specific operators like field and array accesses</cell></row><row><cell>5. Tail-recursion Elimination</cell><cell>Replaces the body of a tail-recursive procedure with a loop</cell></row><row><cell>6. Method Inlining</cell><cell>Inlining based on intraprocedural class analysis to disambiguate dynamic dispatch</cell></row><row><cell>7. Domain-specific Axioms</cell><cell>User-provided axioms about certain application domains (optional)</cell></row><row><cell>(b) Optimizations</cell><cell>Description</cell></row><row><cell>8. Constant Propagation and Folding</cell><cell>Traditional Constant Propagation and Folding</cell></row><row><cell>9. Algebraic Simplification</cell><cell>Various forms of traditional algebraic simplifications</cell></row><row><cell>10. Peephole Strength Reduction</cell><cell>Various forms of traditional peephole optimizations</cell></row><row><cell>11. Array Copy Propagation</cell><cell>Replace read of an array element by the expression it was previously assigned</cell></row><row><cell>12. CSE for Array Elements</cell><cell>Remove redundant array accesses</cell></row><row><cell>13. Loop Peeling</cell><cell>Pulls the first iteration of a loop outside of the loop</cell></row><row><cell>14. LIVSR</cell><cell>Optimization described in Section 2, namely Loop-induction-variable Strength Reduction</cell></row><row><cell>15. Interloop Strength Reduction</cell><cell>Optimization described in Section 3</cell></row><row><cell>16. Entire-loop Strength Reduction</cell><cell>Transforms entire loop into one operation, e.g. loop doing i incrs becomes "plus i"</cell></row><row><cell>17. Loop-operation Factoring</cell><cell>Factors expensive operations out of a loop, for example multiplication</cell></row><row><cell>18. Loop-operation Distributing</cell><cell>Distributes an expensive operation into a loop, where it cancels out with another operation</cell></row><row><cell>19. Partial Inlining</cell><cell>Inlines part of a method in the caller but keeps the call for the rest of the computation</cell></row><row><cell>(c) Domain-specific Optimizations</cell><cell>Description</cell></row><row><cell>20. Domain-specific LIVSR</cell><cell>LIVSR, but with domain operations like matrix/vector addition and multiply</cell></row><row><cell>21. Domain-specific code hoisting</cell><cell>Code hoisting based on domain-specific invariance axioms</cell></row><row><cell cols="2">22. Figure 8. Optimizations performed by Peggy</cell></row><row><cell cols="2">conjecture that interprocedural optimizations can be expressed as</cell></row><row><cell cols="2">equality analyses, and leave this exploration to future work.</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported in part by NSF CAREER grant CCF-0644306.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Finding effective compilation sequences</title>
		<author>
			<persName><forename type="first">L</forename><surname>Almagor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Grosul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Reeves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Torczon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Waterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LCTES</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Detecting equality of variables in programs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Alpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zadeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1988-01">January 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lucid, a nonprocedural language with iteration</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Ashcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Wadge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="519" to="526" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic generation of peephole superoptimizers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Introduction to Functional Programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The TAMPR program transformation system: simplifying the development of numerical software. Modern software tools for scientific computing</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">M</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Terence</forename><forename type="middle">J</forename><surname>Harmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">L</forename><surname>Winter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Stratego/XT 0.17. A language and toolset for program transformation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bravenboer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">T</forename><surname>Kalleberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vermaas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="52" to="70" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Combining analyses, combining optimizations</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Click</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="181" to="196" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Global code motion/global value numbering</title>
		<author>
			<persName><forename type="first">C</forename><surname>Click</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optimizing for reduced code space using genetic algorithms</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Schielke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LCTES</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An efficient method for computing static single assignment form</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cytron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ferrante</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zadeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1989-01">January 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Towards better inlining decisions using inlining trials</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on LISP and Functional Programming</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Simplify: A theorem prover for program checking</title>
		<author>
			<persName><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saxe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="365" to="473" />
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Go to statement considered harmful</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="27" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The program dependence graph and its use in optimization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ferrante</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ottenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="319" to="349" />
			<date type="published" when="1987-07">July 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">BURG -fast optimal instruction selection and tree parsing</title>
		<author>
			<persName><forename type="first">Christopher</forename><forename type="middle">W</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">R</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">A</forename><surname>Proebsting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="68" to="76" />
			<date type="published" when="1992-04">April 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Expert Systems -Principles and Programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Giarratano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Riley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>PWS Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Eliminating branches using a superoptimizer and the GNU C compiler</title>
		<author>
			<persName><forename type="first">Torbjorn</forename><surname>Granlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Kenner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Construction of thinned gated single-assignment form</title>
		<author>
			<persName><forename type="first">P</forename><surname>Havlak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Languages and Compilers for Parallel Computing</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Advances in dataflow programming languages</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Johnston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R P</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Millar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="34" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Denali: a goal-directed superoptimizer</title>
		<author>
			<persName><forename type="first">R</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Randall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Adaptive optimizing compilers for the 21st century</title>
		<author>
			<persName><forename type="first">L</forename><surname>Torczon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Supercomputing</title>
		<imprint>
			<biblScope unit="page" from="7" to="22" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Composing dataflow analyses and transformations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Superoptimizer: a look at the smallest program</title>
		<author>
			<persName><forename type="first">Henry</forename><surname>Massalin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Translation validation for an optimizing compiler</title>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Simplification by cooperating decision procedures</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Oppen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="257" />
			<date type="published" when="1979-10">October 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Fast decision procedures based on congruence closure</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Oppen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="356" to="364" />
			<date type="published" when="1980-04">April 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The program dependence web: a representation supporting control-, data-, and demand-driven interpretation of imperative languages</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ottenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ballance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maccabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Dependence flow graphs: an algebraic approach to program dependencies</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pengali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1991-01">January 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Translation validation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Singerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Pueblo: A hybrid pseudo-boolean SAT solver</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sheini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal on Satisfiability, Boolean Modeling and Computation</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="61" to="96" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The value flow graph: A program representation for optimal program transformations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Knoop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ruthing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Programming</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Translating between PEGs and CFGs</title>
		<author>
			<persName><forename type="first">Ross</forename><surname>Tate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Tatlock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sorin</forename><surname>Lerner</surname></persName>
		</author>
		<idno>CS2008- 0931</idno>
		<imprint>
			<date type="published" when="2008-11">November 2008</date>
		</imprint>
		<respStmt>
			<orgName>University of California, San Diego</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Efficient building and placing of gating functions</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Padua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Soot -a Java optimization framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Co</surname></persName>
		</author>
		<editor>CASCON</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Compiling language definitions: the ASF+SDF compiler</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G J</forename><surname>Van Den Brand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Olivier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Building program optimizers with rewriting strategies</title>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Benaissa</surname></persName>
		</author>
		<author>
			<persName><surname>Tolmach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Value dependence graphs: Representation without taxation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Weise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Crew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Steensgaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An approach to ordering optimizing transformations</title>
		<author>
			<persName><forename type="first">Debbie</forename><surname>Whitfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><forename type="middle">Lou</forename><surname>Soffa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PPOPP</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">An approach for exploring code improving transformations</title>
		<author>
			<persName><forename type="first">Deborah</forename><forename type="middle">L</forename><surname>Whitfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><forename type="middle">Lou</forename><surname>Soffa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1053" to="1084" />
			<date type="published" when="1997-11">November 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Efficient program execution indexing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008-06">June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">VOC: A methodology for the translation validation of optimizing compilers</title>
		<author>
			<persName><forename type="first">Lenore</forename><surname>Zuck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="223" to="247" />
			<date type="published" when="2003-03">March 2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
