<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ELFies: Executable Region Checkpoints for Performance Analysis and Simulation</title>
				<funder>
					<orgName type="full">Intel Corporation</orgName>
				</funder>
				<funder ref="#_MRuaAEs">
					<orgName type="full">National University of Singapore</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Harish</forename><surname>Patil</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Isaev</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wim</forename><surname>Heirman</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alen</forename><surname>Sabu</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">National University</orgName>
								<address>
									<country>Singapore Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ali</forename><surname>Hajiabadi</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">National University</orgName>
								<address>
									<country>Singapore Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Trevor</forename><forename type="middle">E</forename><surname>Carlson</surname></persName>
							<affiliation key="aff5">
								<orgName type="institution">National University</orgName>
								<address>
									<country>Singapore Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ELFies: Executable Region Checkpoints for Performance Analysis and Simulation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>record and replay</term>
					<term>dynamic program analysis</term>
					<term>performance monitoring</term>
					<term>simulation region selection Region Selection Region Information Application</term>
					<term>Inputs Region Capture ELFie Generation Application Pinball Simulation Region Analysis Application ELFie Dynamic Program Analysis Native Performance Analysis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We address the challenge faced in characterizing long-running workloads, namely how to reliably focus the detailed analysis on interesting execution regions. We present a set of tools that allows users to precisely capture any region of interest in program execution, and create a stand-alone executable, called an ELFie, from it. An ELFie starts with the same program state captured at the beginning of the region of interest and then executes natively. With ELFies, there is no fastforwarding to the region of interest needed or the uncertainty of reaching the region. ELFies can be fed to dynamic programanalysis tools or simulators that work with regular program binaries. Our tool-chain is based on the PinPlay framework and requires no special hardware, operating system changes, recompilation, or re-linking of test programs. This paper describes the design of our ELFie generation tool-chain and the application of ELFies in performance analysis and simulation of regions of interest in popular long-running single and multi-threaded benchmarks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Workload characterization is the process of understanding the behavior of computer systems. Characterization can be performed for the whole system or for individual programs. Typical characterization approaches include using hardware performance counters, program instrumentation with tools such as Pin <ref type="bibr" target="#b0">[1]</ref>, and performance simulation <ref type="bibr" target="#b1">[2]</ref>- <ref type="bibr" target="#b3">[4]</ref>. These approaches incur a varying amount of overhead depending on the degree of detail they provide. Since the detailed analysis of entire program runs can be prohibitively expensive, most approaches use sampling techniques to focus on key regions of interest <ref type="bibr" target="#b4">[5]</ref>- <ref type="bibr" target="#b6">[7]</ref>. Phase-based sampling techniques, such as SimPoint <ref type="bibr" target="#b4">[5]</ref>, are very effective in finding representative regions for architecture simulation. However, finding regions of interest can be time-consuming and it is desirable to be able to share such regions among researchers so the cost of generating them is amortized. One challenge is how to re-run the regions of interest once found. In addition, with native program execution, starting hardware performance counting exactly at the point of interest can be difficult. While the task may be easier with program analysis tools and simulators, given the run-to-run variation in program execution, especially for multi-threaded programs, a region of interest found in an earlier run may not always be reachable in a subsequent execution.</p><p>The PinPoints toolkit from Intel <ref type="bibr" target="#b7">[8]</ref> automates the tedious task of profiling an x86 application, finding phases, and creating a checkpoint called a pinball for each representative region. These checkpoints are self-contained and can be shared among researchers easily. In fact, researchers have made SPEC CPU2006 and CPU2017 pinballs <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref> publicly available. However, pinballs only work with Pin-based simulators and analysis tools. There is a need for a sharing mechanism that is not dependant on Pin. We believe that having regions of interest represented as x86 binaries is one possible solution.</p><p>To accomplish this, we present a set of tools for precisely capturing interesting program regions in the form of standalone executables called ELFies. An ELFie is an executable in the Executable and Linkable format, ELF <ref type="bibr" target="#b10">[11]</ref>, capturing a portion of another program's execution. ELFies themselves are statically linked binaries and can be generated from executions of other statically or dynamically linked, single or multithreaded, x86 binaries (32 or 64-bit). They can be fed to any characterization tool that accepts ELF binaries. No changes to the characterization tools are required as ELFies behave like regular program executables for all practical purposes. Further, ELFies are easier to share among researchers than the original applications and they will start executing exactly at the point in the original application execution that was captured.</p><p>Our approach is based on the Pin-based framework for program capture and deterministic replay called PinPlay <ref type="bibr" target="#b11">[12]</ref>. We used the publicly available version of the PinPlay toolkit <ref type="bibr" target="#b12">[13]</ref>, with the ability to generate fat pinballs (see Subsection II-A). The overall approach for ELFie generation is shown in Figure <ref type="figure" target="#fig_0">1</ref>. We run the test program under the PinPlay logger tool providing it a specification for the region of interest, selected for instance by program phase analysis. The logger captures the specified portion of the program execution in a set of files collectively called a pinball. The pinball contains, among other things, a memory image (a .text file common to all threads), and the architectural register values at the beginning of the region (one .reg file per thread, which also includes register changes from system calls and signals). Next, our pinball2elf tool reads a pinball and generates an ELF binary by translating the pinball memory image pages to ELF sections and adding a startup code section at the entry address. The startup code creates the required number of threads, initializes each thread's architectural registers, and jumps to the beginning of the actual program code inherited from the original pinball. Other data in the pinball that is needed for constrained execution, like the details for injection of system call side-effects and the enforcement of shared memory access order of various threads, are ignored during this conversion.</p><p>Checkpoint/restore in user space (CRIU) <ref type="bibr" target="#b13">[14]</ref> is a Linux tool that allows one to capture the state of a process tree to disk and to restore it later on the same or similar machine. It supports multiple usage scenarios including process migration and the debugging and analysis of applications. With ELFies, we focus on regions-of-interest from a single-process, multithreaded application for targeted analysis. A CRIU checkpoint is a snapshot at a particular point in the execution with no specified end. ELFies represent a bounded region in the execution as captured in the corresponding pinball. ELFies are Linux binaries and hence can be run by themselves and can be used with tools that run with binaries. Since pinballs can be generated on operating systems other than Linux, one can imagine tools similar to pinball2elf that convert pinballs to other executable formats such as Portable Executable (PE) format on Windows and Mach-O on MacOS.</p><p>Table <ref type="table" target="#tab_0">I</ref> compares ELFies, the target of this work, with pinballs. ELFies can be run natively and without any extra overhead. They can be run with any tool that otherwise accepts an ELF executable-no modifications to the tool are necessary. This flexibility allows ELFies to be used for a variety of purposes. However, since pinball2elf only uses the initial memory and register state from a pinball to create an ELFie ignoring the rest of the files required for enforcing determinism, an ELFie run is non-deterministic 1 . Also, pinball2elf currently 1 PinPlay only guarantees that shared-memory access order in multithreaded pinballs is repeated exactly as opposed to a guaranteed total order of instructions from various threads. Hence, we prefer the term constrained over deterministic replay. does not add any debug information to ELFies hence they do not support symbolic debugging.</p><p>Two questions relevant for the use of ELFies are (1) How will system calls behave? and (2) How will an ELFie run end?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The System Call Handling Challenge</head><p>During a pinball replay, most system calls are skipped, and their register results are injected from the .reg files. Program memory, changed by system calls, is inserted at use time based on automatically logged values <ref type="bibr" target="#b14">[15]</ref>. This guarantees that the results of non-repeatable system calls such as gettimeofday() will be the same during replay as was during logging. ELFies do not have any injection mechanism to handle system calls-they are simply re-executed natively. So, at times, some control-flow decisions based on system call results may cause ELFie execution to go on a different path compared to a pinball replay. Also, some system calls may rely on OS resources such as open file descriptors which will not be available during an ELFie run and will fail. For example, consider a file opened before a region of interest and used in the region. The region pinball replay will skip the file read and return the stored results, however an ELFie will try to repeat the file read system call and fail. Luckily, the constrained replay of the parent pinball acts as a reference for an ELFie execution in terms of the system calls it will execute and files it will access. We can use this information to guide ELFie execution in many cases. In fact, we have developed a SYSSTATE technique to ensure correct re-execution with filerelated and other common Linux system calls. In particular, a Pin-tool re-constructs the file and heap state with replay-based analysis for the test pinball and stores it in a sysstate directory. pinball2elf embeds references to the sysstate contents in the startup code of the ELFie created from the pinball.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The Graceful Exit Challenge</head><p>ELFies contain only the memory (data + text) pages captured in the pinball. If the execution of an ELFie goes on a new path, it may try to access/execute a page that has not been captured, resulting in an ungraceful exit. On the other hand, while a pinball replay will always terminate after the desired number of instructions (recorded in the pinball), at times an ELFie may continue to execute far beyond the desired number of instructions-as long as it stays within the captured memory range. We support graceful exit of ELFies using hardware performance counters. Pinball2elf can program a hardware counter, one per thread, to count retired instructions and create a callback to exit each thread on reaching the expected instruction count for the region of interest captured in the incoming pinball. If an ELFie is used by some other program, such as a simulator, the graceful exit of ELFie can be ensured by that program instead.</p><p>Despite the two challenges above, we found ELFies to be quite suitable for use cases such as native performance measurement or tool-based analysis and simulation for regions of interest. For instance, verifying the quality of simulation region selection requires running both the whole-program and all selected regions using the same methodology, yet whole-program simulation is prohibitively expensive. ELFies allow us to perform the evaluation using native runs instead, thus enabling accurate representative generation of extremely long-running programs (see Section IV-A). A graceful exit can be forced by analysis tools after the desired number of instructions. The effect of system calls can be minimized by choosing the regions appropriately. If an ELFie run fails consistently before reaching the desired instruction count, starting with an alternative region of interest may help. In our experiments we used alternate region selection (i.e., the second or third best representative for a given phase/cluster that SimPoint provides), to increase coverage (the sum of the weights of correctly executing ELFies) up to 90%+ in most cases, while still maintaining high accuracy. Without any guarantee of repeat-ability or a graceful exit, other more general uses of ELFies may not be possible. In those cases, pinballs with their constrained replay guarantee may be more appropriate.</p><p>In this paper, we present details of how the pinball2elf tool works and how we are using the ELFies it generates for focused analysis of regions of interest of long-running applications. Our main contributions are as follows:</p><p>1) We describe the tool-chain (PinPlay + pinball2elf) for converting user-level checkpoints (pinballs) to executables (ELFies) as shown in Figure <ref type="figure" target="#fig_0">1</ref>. To our knowledge, the idea of creating a stand-alone executable for an arbitrary portion of a multi-threaded x86 program execution is novel. 2) We show the use of ELFies, among other things, for validating simulation region selection techniques. Traditionally, the validation is done using simulation and hence is very slow. With ELFie-based validation, we use native hardware instead of simulators which allows for validation of really long-running programs. Pinballs have provided a way to share regions of interest among researchers <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>. We hope ELFies can play a similar role for x86-binary-based tools/simulators. We have open-sourced pinball2elf tool to facilitate that <ref type="bibr" target="#b15">[16]</ref>.</p><p>The rest of this paper is organized as follows. Section II describes the implementation of the pinball2elf tool. Section III is about typical applications of ELFies. Section IV presents some case studies showcasing advantages of using ELFies for performance analysis and simulation. Section V summarizes other work in this area and section VI concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. IMPLEMENTATION</head><p>This section presents an overview of the changes made to PinPlay and details of the pinball2elf tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. PinPlay Changes</head><p>The motivation for creating an ELFie is that it should always start with the program state captured at the beginning of a region of interest but should then run in an un-restricted manner, without any enforcement of determinism, using any memory it requires. A pinball, on the other hand, is designed for constrained replay and hence captures only the memory pages that were actually used in the logging run. An unrestricted ELFie run could, at times, diverge from the recorded control flow, try to access an un-captured memory page, and fail. To alleviate this problem, we requested the PinPlay team to make a few changes to the PinPlay logger. First, a new switch, -log:whole_image, was added that records all the loaded sections, including global static data, for the test image. Second, since the logger by default creates text/data page injection records lazily, another switch, -log:pages_early, was added, which puts the pages in the initial memory image (the .text file). The two new switches can be combined with a single switch -log:fat. We call the resulting pinball a fat pinball. All the pinballs we generated for ELFie evaluation were fat pinballs. Depending on the number and sizes of shared libraries used by a program, a fat pinball can be much larger than a regular pinball. Finally, a new replay switch, -replay:injection, was added, which when set to zero, attempts replay without any system-call side-effect injection or enforcement of thread order. Such injection-less replay mimics the execution of an ELFie (while still running under Pin) and hence is useful in debugging ELFie failures.</p><p>A fat pinball for a region has all the memory used inside the region pre-loaded in the initial memory image file. This includes text/data pages from any libraries dynamically loaded inside the region and any heap pages accessed inside the region. However, heap pages that are allocated but not accessed are not included in the initial memory image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The Pinball2elf Tool</head><p>Pinball2elf is a tool to create executable or object files from pinballs. The executables generated by pinball2elf are statically linked and hence are self-contained without any dependence on shared libraries. During execution, an ELFie has the same memory layout as the original pinball, i.e., all memory regions are mapped to the same addresses as during the pinball recording run. That makes ELFies useful for memory-characterization studies.</p><p>1) Overview of the ELF Format: The Executable and Linkable Format (ELF) <ref type="bibr" target="#b10">[11]</ref> is a standard, flexible, and extensible format for representing binary code in a system. ELF is used for object files, executables, shared libraries, core dumps, and kernel modules. An ELF file usually consists of an ELF header followed by other headers describing the file layout and of sections or segments containing data. Depending on the type, an ELF file can include a program header table and a section header table. A typical layout of object and executable ELF files is illustrated in Figure <ref type="figure">2</ref>. The ELF header must be located at the beginning of the file and is used to locate other parts of the file. This structure defines sizes and file offsets of the section header and program header tables, specifies the virtual address of the program entry point, and stores other useful information.</p><p>The section header table is an array of section-header structures, each of which describes a section. A section header structure defines the file offset of each section, its type and size, its attributes (allocatable, executable, and writable), and its virtual address (if allocatable, i.e., if it will appear in the memory image of the process for the executable). Some sections in an ELF file have pre-defined meanings and hold program data or are used by the system loader. For example, .text holds executable instructions of a program, .data holds initialized data, and .symtab contains information needed to locate a program's symbolic definitions and references.</p><p>2) Pinball to ELF Mapping: We chose to make ELFies statically linked because a statically-linked executable contains a set of object files and libraries which are bound at linktime with all references resolved and hence is completely selfcontained. A fat pinball's .text file holds the memory dump of the captured program region (all pages mapped into the memory). The .reg files contain initial register contents of program threads at the beginning of the region. Each region from the .text file which consists of consecutive pages is represented with a section in the ELF file with the virtual  address set to the virtual address of the start page of the region. Thread register contents are packed and written into a separate data section with the virtual address mapping to some memory range that is not used by the pinball. The resulting ELF object is then statically linked with a startup code that creates the required number of threads and initializes the thread contexts from the ELF file. The layout of such an executable is shown in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>3) Stack Collision: An ELFie generated from a fat pinball contains all the memory pages that were mapped into the memory of the traced process and includes code and data from the program binary, code and data from shared objects, and the program stack. When an ELFie is run natively, the system ELF loader first parses the ELFie file, maps its various program segments into memory, sets up the entry point, and finally initializes the stack for the ELFie process. The stack is populated in the normal way to contain command line arguments, auxiliary vectors, and arrays of pointers to environment variables of the process. However, the ELFie binary already has the stack pages from the pinball which may overlap with the address range of the new stack-which the loader is trying to reserve for the ELFie process. Even though the bottom of the stack can vary slightly from process to process, because of Linux's stack randomization feature, there is a possibility that the virtual addresses of the two stack regions, one requested by the loader and the other mapped from pinball, intersect. If such a collision happens, the loader will be able to reserve only a very small amount of the memory for the new stack which can be insufficient to pass the environment, program arguments, etc. In this case the process will be killed before any ELFie code is executed. Figure <ref type="figure">4</ref> illustrates the stack-collision problem.</p><p>Fortunately, the stack-collision problem can be solved. The sections in an ELFie corresponding to the stack from the parent pinball can be marked as non-allocable, which prevents the ELF loader from mapping them into memory during process initialization and lets the loader allocate the stack for the new process freely. At the very beginning of ELFie startup code, the pages of the newly created stack colliding with the stack from the parent pinball are unmapped, and replaced with pages  <ref type="figure">5</ref> shows the code implementing such a procedure. Note that the remapping can be done safely for all pages from the pinball (and not just the stack pages) which is the most portable way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) Thread Creation and Initialization:</head><p>The rest of the startup code creates threads and initializes their contexts.  .quad &lt; THREAD_N_START_ADDRESS &gt; Fig. <ref type="figure">6</ref>. ELFie startup: thread entry Creation of threads is performed in a small loop that uses the clone() system call. It passes a pointer to the thread context data as the stack pointer of the thread being created and a pointer to the code loading the context (thread initialization function) as the thread function.</p><p>The context structure fully matches a thread's initial register state from the parent pinball and has two parts. The first part includes the X87/MMX, SSE, AVX, AVX-512, MPX, and other extended states. The layout of this part is the same as the FXSAVE/XSAVE area defined in the Intel Software Developers Manual <ref type="bibr" target="#b16">[17]</ref>. This part of the context can be loaded either using the FXRSTOR or the XRSTOR instruction, depending on the CPU micro-architecture of the pinball. The second context structure part contains values of segment selectors (FS and GS bases), the flag register, and the general purpose registers (GPRs). The thread-initialization function receives these registers on the stack, and it pops and sets the flag and the GPRs. At the bottom of the thread-initialization function stack resides the pointer to a small piece of code which is called the thread entry. It sets up the stack pointer of the thread to the 'real' value and jumps to the thread's 'real' code. There are as many thread entries as there are threads in the parent pinball, one for each thread. Figure <ref type="figure">6</ref> shows an example of the thread entry. Note that the ELFie startup code only creates those threads that were created before the program region starts. New threads may still be created by the application itself during execution of the region, through the clone system call as normal.</p><p>5) Other Pinball2elf Features: The ideas described above are implemented in the pinball2elf tool. The tool can generate both ELF object files (without any startup code) and statically linked ELF executables (with startup code) from single and multi-threaded pinballs. Additionally, pinball2elf allows users to link in extra code to be called at the beginning of each thread entry. It creates a linker script which gives users explicit control over the process of linking an ELFie object file with an object file containing user's extra code. The linker script contains the parent pinball memory layout, which is preserved in the resulting linked executable. Pinball2elf can also dump initial thread contexts in the form of assembly listing which can help users to write their own startup code. For ELFie debugging purposes, pinball2elf inserts symbols for all functions from the startup code, symbols for most of the elements of thread initial states in a format .t&lt;N&gt;.&lt;object&gt; (for example .t0.rax, .t0.xmm or .t0.ext_area2), and symbols pointing to the start of each thread.</p><p>Callback Support: Pinball2elf allows users to add calls to functions of their choice at two points early in ELFie execution:</p><p>1) -p elfie_on_start() after start-up but before starting application code execution, 2) -t elfie_on_thread_start() just before a thread jumps to user code.</p><p>These functions can be used to initialize hardware performance counters, for example, for native performance analysis of embedded application region. Another switch, -e elfie_on_exit(), causes a monitor thread to be created first. This thread spawns the main application thread and waits for it to exit. When the main application thread exits, a call to user-defined elfie_on_exit() is made. This function, for example, can be used to output final values of any hardware performance counters that were initialized on ELFie start.</p><p>Marker Support: When an ELFie is used for analysis or simulation, the startup code needs to be skipped. pinball2elf can add special 'marker' instructions at the beginning of application code using the switch --roi-start [TYPE:]TAG where type can be one of sniper, ssc, or simics respectively for Sniper <ref type="bibr" target="#b2">[3]</ref>, Pintools <ref type="bibr" target="#b17">[18]</ref>, and Simics <ref type="bibr" target="#b18">[19]</ref>.</p><p>Creating Custom ELFies: Depending on the intended application (performance analysis or simulation), users can add the right callback routines and markers. The pinball2elf distribution has wrapper scripts with the sources for the required callback routines for common use cases. The execution flow of a typical custom ELFie is shown in Figure <ref type="figure" target="#fig_3">7</ref>.</p><p>Debugging ELFies: The pages inside an ELFie containing application code are marked as not loadable hence tools, such as the GNU debugger (gdb), can not 'see' application pages inside an ELFie right away after the initial loading of an ELFie. For setting breakpoints at an application instruction, the suggested way is to first break on elfie_on_start() at which point all application pages are guaranteed to be in memory and then set a breakpoint at the desired application address(hex). Symbolic debugging of application code is currently not supported with ELFies although pinball2elf can be extended to add application debug information for symbolic debugging. ELFie generation scripts make sure debug information does exist for ELFie callback routines hence  they can be debugged symbolically. For debugging multithreaded ELFies with gdb, first doing a set detach-on-fork off followed by break elfie_on_thread_start and using info inferior and inferior N commands works well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. ELFie Execution Challenges</head><p>As outlined earlier, there are two main challenges in ELFie execution.</p><p>1) The Graceful Exit Challenge: Figure <ref type="figure" target="#fig_3">7</ref> shows a typical ELFie execution flow. Once an ELFie thread starts executing application code, it can continue going, until it encounters an exit() or exit_group() system call. However, since an ELFie only represents a region of execution, it has data and text pages only to support that region. If an ELFie execution diverges from the captured execution or goes past the captured region, it might access a text or data page not present in memory and exit ungracefully. Therefore, we need a way to stop ELFie execution after the captured region ends. If a custom ELFie is being used by some dynamic analysis tool or a simulator, they can end ELFie execution explicitly using some region ending criterion (typically the instruction count recorded in the corresponding pinball). For ending a stand-alone execution of an ELFie, pinball2elf provides support for custom callback routines to program hardware performance counters for ending ELFie execution after the desired number of instructions (as recorded in the pinball) are executed (retired).</p><p>2) The System Call Handling Challenge: Unlike pinballs, ELFies do not have any injection mechanism to handle system calls-they are simply re-executed natively. Many system calls, such as gettimeofday() can be safely re-executed. However some system calls that rely on operating system resources, e.g., read() from an open file descriptor need special handling. Capturing all the operating system state in a checkpoint, as done by the CRIU infrastructure <ref type="bibr" target="#b13">[14]</ref>, can be quite a daunting task. Luckily, since ELFies only need to execute the captured region correctly, we know which system calls occur in the region (from pinball analysis) and need to handle them correctly. Based on our experience with mostly user-level programs (which are a good match for Pin-based analysis anyway), we found two classes of system calls that need handling: (1) file-related system calls such as open(), lseek() and ( <ref type="formula">2</ref>) heap memory handling system call brk. We have developed a Pintool, pinball sysstate that looks at system calls in a pinball and extracts file-related state and puts it in a pinball.sysstate directory. Figure <ref type="figure">8</ref> shows an example output from the pinball_sysstate tool. Files that are opened inside the pinball region get a proxy version created with the right name and it is populated solely based on the relevant read() system calls in the region. Files opened prior to the region, and hence only referred via a file descriptor, have a proxy file with a dummy name FD n, where n is the relevant file descriptor. The pinball2elf toolkit provides a generic elfie_on_start() callback that preopens any FD n files in the sysstate directory and assigns them the right file-descriptor using the dup() system call. An supposed to be executed in the sysstate/workdir directory created by the pinball_sysstate tool. Files that were opened using an absolute path-name during the pinball region, are copied to their rightful location (alternatively, the Linux command chroot, with the sysstate directory as the special root, can be used to execute the ELFie). The same Pintool, pinball_sysstate, also outputs the return values of the first and the last brk() system call in the pinball region in a file called BRK.log. A custom elfie_on_start() callback uses these values to set the memory layout for the ELFie process using the prctl() system call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. APPLICATIONS</head><p>In this section we describe the use of ELFies for dynamic analysis, performance analysis, and simulation of regions of interest they represent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Dynamic Analysis with Pin</head><p>Pin <ref type="bibr" target="#b0">[1]</ref> is a popular dynamic instrumentation framework that works with x86 binaries and hence can handle ELFies. However, an ELFie executes some startup code before it jumps to the actual embedded code from the captured region of interest. Therefore, we need a way to skip Pin-based analysis of ELFie startup code. That can be done in multiple ways. Pinball2elf can add special marker instructions (cpuid or a special nop) and the Pintool doing the analysis can start the actual analysis only after reaching the special marker.</p><p>Pinball2elf can be used to add a special callback function in an ELFie to be called before the application code executes and then Pin-based analyis can begin on seeing this function. Graceful exit of analysis can be achieved using a Pin-based instruction counting mechanism (based on the instruction count of the corresponding pinball) or using the hardware performance counter based exit mentioned in Section I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Native Performance Analysis</head><p>ELFie captures a region of interest from an application execution and provides a precise way to focus performance analysis on that region. While Linux utilities like perf stat will work with ELFies, they need a way to avoid measuring the startup code and handling exit gracefully. Pinball2elf features for adding process-wide and per-thread callback functions are useful in this context. Pinball2elf provides a library, libperfle.a, with an API for initializing hardware performance counters. Per-process and per-thread callback functions can be used to program desired hardware performance counters and also to exit each thread gracefully on executing its expected (as listed in the pinball) instruction count. A callback on process exit can also be inserted using pinball2elf which causes a monitor thread to be created that watches the (graceful) exit of the application process and then can output the final values of various performance counters programmed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Workload Simulation</head><p>While a Pin-based simulator, such as Sniper <ref type="bibr" target="#b2">[3]</ref>, can be modified to work with replay of pinballs, it does require extra work. With ELFies, which are x86 Linux binaries, simulations can be performed for the region of interest without having to modify the simulator. There is still a requirement to be able to skip the startup code during simulation which can be done using special marker instructions or special instruction/callback function addresses as described in Section II-B5.</p><p>We have tested ELFies with three different x86 simulators: 1) Pin-based multi-core simulator: Sniper <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref> is a Pinbased x86 multi-core simulator which works with x86 Linux binaries. It has been modified to include the PinPlay library <ref type="bibr" target="#b12">[13]</ref> and hence can simulate pinballs as well. We use Sniper to evaluate the performance of both a set of multi-threaded pinballs and the corresponding ELFies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) SDE and Simics-based x86 simulator: CoreSim is an</head><p>Intel-internal cycle-accurate x86 many-core simulator. This simulator supports SDE <ref type="bibr" target="#b19">[20]</ref> as a front-end (which itself is based on Pin, but adds emulation of future instructions) as well as Simics <ref type="bibr" target="#b18">[19]</ref> to enable full-system simulation. Given that CoreSim is an execution-driven simulator, ELFies can run on CoreSim natively just like any Linux executable. We added Simics magic instructions to the ELFies so we can enable the performance model only after the ELFie startup code has been executed. 3) Binary-driven x86 simulator: gem5 <ref type="bibr" target="#b3">[4]</ref> is an open source computer architecture simulator supporting multi-ple ISAs, including x86. gem5 can simulate a complete system and an OS in Full-System (FS) mode, or user space only programs where system services are provided directly by the simulator in Syscall Emulation (SE) mode. Often, gem5 is used with atomic CPU and fastmem options to collect Basic Block Vectors (BBVs) as input to a sampling methodology such as SimPoint <ref type="bibr" target="#b4">[5]</ref>. However, generating pinballs and ELFies is much faster, which is useful for studies that involve frequent recompilation of binaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CASE STUDIES</head><p>In this section, we present some case studies showing the application of ELFies to performance analysis and simulation. Although the focus mostly is architecture simulation, many other dynamic analyses can benefit from the ability to focus on regions of interest via ELFies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Validating Simulation Region Selection with ELFies</head><p>Simulation region selection is an active research area. To measure the quality of simulation region selection, the standard practice is to report an error in projection based on simulation of just the selected regions. The error is computed by comparing some metric, such as cycles per instruction (CPI) obtained two ways: (1) with simulation of the entire program (gives the true value) and ( <ref type="formula">2</ref>) with simulation of just the selected region, and by using simulation region weights to compute the estimate for the entire execution (gives the predicted value). The problem with this approach is that (1) requires simulation of the entire program which can take a really long time and hence prompts the need for simulation region selection in the first place. To make the validation practical, researchers either use a reduced length benchmark run (e.g. train instead of ref for SPEC2006/2017) or use a faster, but crippled, version of their simulator. ELFies provide quite an elegant way out of this situation by enabling hardware counter based metric computation for selected regions. Interesting metrics can now be collected by running the entire program and ELFies for selected regions to get true and predicted values. Using real hardware instead of a simulator, simulation region selection for really long-running programs can be quickly validated.</p><p>1) Validating Train SPEC2017 Simulation Regions: The objectives of this case-study were (1) to compare ELFiebased and tranditional, simulation-based, simulation validation techniques; and (2) to show the use of ELFies in the tuning of simulation region selection.</p><p>We applied the PinPoints <ref type="bibr" target="#b7">[8]</ref> simulation region selection methodology to train runs of SPEC CPU2017 <ref type="bibr" target="#b20">[21]</ref> rate, int subset. All the benchmarks in the suite were compiled using the GCC (version 8) with optimizations enabled (-O2) and built for the 64-bit instruction-set architecture. We used a slicesize (region length) parameter of 200 million instructions, a warmup region of 800 million instructions and maxK (maximum number of phases/regions) value of 50. The dynamic instruction count of the benchmarks used was in the range 1.3-452 billion.  We did validation of these PinPoints using the traditional approach first, where both the region and whole-program cyclesper-instructions (CPI) were computed with detailed simulation using CoreSim. Even though we used train inputs to keep the whole-program simulation time reasonable, it still took a few weeks for the longest simulation to finish. With ELFiebased validation, real hardware was used instead of simulation for getting whole-program and region CPI values. We did ten trials for each measurement and took the average. Still, the entire process finished within one hour which is a drastic reduction over the few weeks of turnaround time with the traditional approach. We use a common definition of prediction error: ((whole program CPI) -(region predicted CPI)) / (whole program CPI). How did the prediction errors compare with the two approaches? Figure <ref type="figure" target="#fig_5">9</ref> shows the prediction errors with simulation-based approach and two instances of ELFiebased validation. While the errors do not match exactly, they follow similar trends.</p><p>Figure <ref type="figure" target="#fig_5">9</ref> shows some high errors, especially for gcc which is notoriously hard to represent and requires some PinPoints tuning to bring down the prediction error. In this case, increasing the size of warm-up region from 800 million instructions to 1.2 billion instructions brought down the prediction error as shown in Table <ref type="table" target="#tab_0">II</ref>.</p><p>2) Validating Ref SPEC2017 Simulation Regions: The objective of this case-study was to validate simulation region selection for long-running workloads. We applied the PinPoints methodology to ref runs of SPEC CPU2017 <ref type="bibr" target="#b20">[21]</ref> rate int and fp, again compiled using GCC 8 with optimizations enabled (-O2), a slicesize of 200 million instructions, 800 million instructions warmup and a maxK value of 50. Some basic statistics for our benchmarks are shown in Table <ref type="table" target="#tab_0">III</ref>. With  The objectives of this case study were to <ref type="bibr" target="#b0">(1)</ref> show the use of multi-threaded ELFies for simulation and (2) compare the simulation of an ELFie and its parent pinball.</p><p>For multi-threaded pinball and ELFie simulation with Sniper, we specified end of simulation as a (PC,count) pair where PC was the address of a specific instruction at the end of the code region outside any spin-loops or synchronization code and count was its execution count (globally, across all threads) determined using a separate profiling run.</p><p>We present our results comparing the simulation performance of arbitrary multi-threaded regions of SPEC CPU2017 applications (the OpenMP subset from the speed version) collected as pinballs and the corresponding ELFies. For this case study, we use a configuration that mimics an Intel Gainestown out-of-order 8-core processor.</p><p>For our experiments with Sniper, we use the speed version of the SPECCPU2017 benchmark suite with train inputs running with eight threads. The benchmarks are compiled using Intel C++ Compiler with -O2 optimization enabled and built for the 64-bit instruction-set architecture. We collect fixed-length regions from the execution of each application in the benchmark suite as pinballs. These can be replayed or simulated later, following the recorded memory access patterns and synchronization among the threads. We keep the size of the chosen multi-threaded region close to 2.4 billion instructions (aggregate for eight threads). We use active wait policy in OpenMP for the threads, which means that the threads use CPU cycles while waiting.</p><p>The thread ordering during replay of multi-threaded pinballs is pre-determined at various synchronization and memory access points. This means that the simulation is constrained and can introduce an artificial stall among certain threads, that yields inaccurate simulation results <ref type="bibr" target="#b21">[22]</ref>. However, simulating a multi-threaded ELFie is totally un-restricted, and therefore, the simulation results are more realistic. Figure <ref type="figure" target="#fig_8">11</ref> shows the comparison of Sniper simulation results using ELFies and pinballs. We observe that the instruction counts of pinball simulations and the corresponding recorded instruction counts of the pinballs closely match. However, the instruction counts of similar ELFie simulations are much higher because of the presence of spin-loops, and the threads behaving in a non-deterministic way, unlike pinball replay. The runtime prediction of both sets do not match which is expected as the simulation for pinballs is constrained and that for ELFies is not. Among the applications presented here, 657.xz s.1 is single-threaded, therefore the instruction count remains the same for un-constrained simulation using ELFies as well as for constrained simulation using pinballs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Application-Level vs. Full System Simulation with CoreSim</head><p>The objectives of this case study were <ref type="bibr" target="#b0">(1)</ref> to show the use of ELFies with a system-level, Simics-based, simulator, and (2) to compare user-level (SDE-based) and system-level (Simics-based) simulation for the same set of ELFies.</p><p>Conventional wisdom is that for compute-bound applications, instructions executed by the operating system have little effect on performance. Many popular academic simulators, including Sniper and several others, are built on Pin as it provides an easy framework for user-space x86 functional    simulation. But how big is the error that this class of simulators make by ignoring OS interference? Using ELFies and CoreSim, we can now make a direct comparison of user-space only vs. full-system simulation, with a realistic workload and input set size. We simulate an identical ELFie (a 10 B instruction single-region SimPoint of 525.x264 from the SPECCPU2017 rate/train suite) on CoreSim's detailed Intel Skylake model, once with SDE as the front-end (simulating user-space instructions only) and once with Simics (providing full-system simulation).</p><p>Results of relevant low-level architectural statistics are shown in Table <ref type="table" target="#tab_0">IV</ref>. The number of simulated instructions in user-space only simulation equals the expected length of the ELFie (just over 10 B instructions). In full-system mode, the number of instructions executed in ring3 (userspace) was equal, but there were an additional 165M instructions executed by the kernel in ring0. These extra 1.6% instructions increased the simulated runtime by 5.2%, in part due to the additional pressure on TLBs and caches. The total data footprint accessed during the run was 45.4% larger in the full-system simulation; the relatively few OS instructions had a disproportionate effect on prefetcher activity and memory bandwidth pressure, especially for applications that have a small data footprint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Binary-Driven Simulation with gem5</head><p>The objective of this case-study was to show the use of ELFies with a popular x86 simulator, gem5, that is not Pinbased while being driven by x86 binaries. Table <ref type="table">V</ref> shows the IPC of 19 applications from SPEC CPU2006 simulated with gem5 for two processor configurations (Intel Nehalem-like and Haswell-like processors) to study the impact of increasing the size of critical resources (like register file, ROB, load/store queues, etc.). We used GCC to compile the programs and SE mode of gem5 to simulate the ELFies. We used SDE <ref type="bibr" target="#b19">[20]</ref> for profiling as gem5 only supports the SSE and SSE2 extensions for the x86 ISA; we also use the SDE -pentium core option to limit the ISA extensions available. The size of each region is 1 B instructions and we use SimPoint to find the most representative region of the code. Total slices (column 2) denotes the number of 1 B instruction regions in entire execution of the program. The representative slice number (column 3) is the slice selected by SimPoint <ref type="bibr" target="#b4">[5]</ref>. The IPC values (column 4) are those reported by the simulator. These results help to demonstrate the flexibility of ELFies.</p><p>V. RELATED WORK Ringenberg and Mudge <ref type="bibr" target="#b22">[23]</ref> present a methodology for converting program execution regions into Intrinsically Checkpointed Assembly Code (ITCY), which can be simulated as a binary application. Based on a functional simulator, static assembly instructions from representative regions are extracted and extra sections added to handle memory initialization, system call emulation, and exit. Application code gets relocated to a new address causing several complications. The resulting binary provides repeatable execution, much like the PinPlay replayer does with one important difference: the simulator sees the extra book-keeping code, possibly perturbing results. Their technique works for single-threaded Alpha workloads. ELFies move away from determinism provided by pinballs and ITCY, supports x86 binaries and multi-threaded workloads.</p><p>Checkpoint/restore in user space (CRIU) <ref type="bibr" target="#b13">[14]</ref> is a very robust and popular check-pointing technique on Linux and was described in Section I. DMTCP <ref type="bibr" target="#b23">[24]</ref> is a user-level checkpointing technique for distributed, multi-threaded checkpointing. A dynamic library is injected in each user process started under their check-point command with a checkpointing manager thread spawned. User-space state is saved, data in the network is drained to process memory, and kernel state (including open file descriptors) is probed and stored in the check-point. The restart under DMTCP has significant complexity around restoring the kernel state. DMTCP does not support statically-linked program binaries. DMTCP checkpoints are not stand-alone executables like ELFies and are, in general, larger. VI. SUMMARY Analyzing entire runs of large programs can be time consuming. Analyzing only interesting portions from longrunning executions poses the challenge of precisely reaching the regions for multiple analyses. We address this challenge by presenting a set of tools that capture regions of interest from program executions into stand-alone executables called ELFies. ELFies always start with the exact same program state captured at the beginning of the regions of interest, avoiding the time and the uncertainty in reaching those regions. While ELFies are generated using a Pin-based tool-chain, they can be run natively or with any analysis tool, Pin-based or not, that executes program binaries. Also, they can be easily shared among researchers for reproducing analysis results and comparing analyses with the exact same input binary.</p><p>As part of our work, we created thousands of ELFies for regions of interest from popular single and multi-threaded benchmarks. We showcase the use of ELFies for simulation, native performance analysis and for validating simulation region selection. We believe that ELFies can be useful in many scenarios and have made our tools publicly available <ref type="bibr" target="#b15">[16]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. ELFie: generation and use.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Pinball to ELF mapping.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>p</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. ELFie execution flow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>File opened prior to the region: file descriptor 1 0x5e64000:Fig. 8 .</head><label>18</label><figDesc>Fig. 8. Example pinball_sysstate output.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Prediction errors: Simulation vs. ELFie-based.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. SPEC CPU2017 ref PinPoints prediction errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Sniper results using multi-threaded ELFies and pinballs (PB).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I</head><label>I</label><figDesc></figDesc><table><row><cell cols="3">PINBALL-ELFIE DIFFERENCES.</cell></row><row><cell></cell><cell>pinballs</cell><cell>ELFies</cell></row><row><cell>Allow constrained replay</cell><cell>Yes</cell><cell>No</cell></row><row><cell>Work across OSes Windows:Linux</cell><cell>Yes</cell><cell>No</cell></row><row><cell>Handle all system calls</cell><cell>Yes</cell><cell>Most (stateless ones)</cell></row><row><cell>Allow symbolic debugging</cell><cell>Yes (with GDB)</cell><cell>No (hex-only with GDB)</cell></row><row><cell>Run natively</cell><cell>No</cell><cell>Yes (Linux only)</cell></row><row><cell>Exit gracefully</cell><cell>Yes</cell><cell>Yes (with performance counters)</cell></row><row><cell>Run with x86 simulators</cell><cell>Yes; simulator modifications needed</cell><cell>Yes; without simulator modifications</cell></row><row><cell>Run-time overhead over a native run</cell><cell>?15X (ST), ?40X (MT)</cell><cell>None (except start-up code overhead)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>ELF header program header table section 1 section header table</head><label></label><figDesc>Fig. 2. Structure of an executable ELF file.</figDesc><table><row><cell>. . .</cell></row><row><cell>. . .</cell></row><row><cell>. . .</cell></row><row><cell>section 2</cell></row><row><cell>. . .</cell></row><row><cell>. . .</cell></row><row><cell>section n</cell></row><row><cell>. . .</cell></row></table><note><p>. . .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>ELF header program header table .text.&lt;page1&gt; .data.&lt;page 5&gt; section header table page 5 (stack) . . . . . . page 4 (data) . . . page 3 (code) page 2 (code) . . . page 1 (code) . . . thread 0 context thread 1 context . . . thread n context startup code from pinball from pinball</head><label></label><figDesc></figDesc><table><row><cell>. . .</cell></row><row><cell>. . .</cell></row><row><cell>. . .</cell></row><row><cell>.text (startup)</cell></row><row><cell>. . .</cell></row><row><cell>.text.&lt;pages2 &amp; 3&gt;</cell></row><row><cell>. . .</cell></row><row><cell>.data (contexts)</cell></row><row><cell>. . .</cell></row><row><cell>.data.&lt;page 4&gt;</cell></row><row><cell>. . .</cell></row><row><cell>. . .</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>978-1-7281-8613-9/21 c 2021 IEEE CGO 2021, Virtual, Republic of Korea Accepted for publication by IEEE. c 2021 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, including reprinting/ republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or reuse of any copyrighted component of this work in other works.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGEMENTS</head><p>This work has benefited tremendously from the support, contribution, and suggestions of many individuals. We sincerely thank all of them. In particular, we acknowledge <rs type="person">Robert Cohn</rs>, <rs type="person">Karthik Sankaranarayanan</rs>, <rs type="person">Ady Tal</rs>, <rs type="person">Moshe Klausner</rs>, <rs type="person">Alexey Klimkin</rs>, <rs type="person">Dan Baum</rs>, <rs type="person">Olivier Serres</rs>, <rs type="person">Carl Beckmann</rs>, and <rs type="person">Christian Karl</rs>. We also thank the anonymous reviewers and artifact evaluators for their suggestions. This work was partially funded by a <rs type="grantName">Startup Grant</rs> from the <rs type="funder">National University of Singapore</rs> and a grant from the <rs type="funder">Intel Corporation</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_MRuaAEs">
					<orgName type="grant-name">Startup Grant</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Hazelwood</surname></persName>
		</author>
		<idno type="DOI">10.1145/1064978.1065034</idno>
	</analytic>
	<monogr>
		<title level="m">Conference on Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2005-06">Jun. 2005</date>
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An evaluation of high-level mechanistic core models</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Heirman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eyerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Eeckhout</surname></persName>
		</author>
		<idno type="DOI">10.1145/2629677</idno>
	</analytic>
	<monogr>
		<title level="j">Transactions on Architecture and Code Optimization</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="2014-08">Aug. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Sniper: Exploring the level of abstraction for scalable and accurate parallel multicore simulation</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Heirman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Eeckhout</surname></persName>
		</author>
		<idno type="DOI">10.1145/2063384.2063454</idno>
	</analytic>
	<monogr>
		<title level="m">International Conference for High Performance Computing, Networking, Storage and Analysis (SC)</title>
		<imprint>
			<date type="published" when="2011-11">Nov. 2011</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The gem5 simulator</title>
		<author>
			<persName><forename type="first">N</forename><surname>Binkert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Reinhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hestness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Hower</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sardashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shoaib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vaish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1145/2024716.2024718</idno>
	</analytic>
	<monogr>
		<title level="s">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2011-08">Aug. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatically characterizing large scale program behavior</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Perelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hamerly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<idno type="DOI">10.1145/605397.605403</idno>
	</analytic>
	<monogr>
		<title level="m">International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
			<biblScope unit="page" from="45" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sampled simulation of multi-threaded applications</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Heirman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Eeckhout</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISPASS.2013.6557141</idno>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
		<imprint>
			<date type="published" when="2013-04">Apr. 2013</date>
			<biblScope unit="page" from="2" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Barrierpoint: Sampled simulation of multi-threaded applications</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Heirman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Van Craeynest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Eeckhout</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISPASS.2014.6844456</idno>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
		<imprint>
			<date type="published" when="2014-06">Jun. 2014</date>
			<biblScope unit="page" from="2" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Pinpoints from Intel</title>
		<ptr target="https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-pinpoints.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">SPEC CPU2006 and Simulation</title>
		<ptr target="https://www.spec.org/cpu2006/research/simpoint.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">SPEC CPU2017 and Simulation</title>
		<ptr target="https://www.spec.org/cpu2017/research/simpoint.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Tool Interface Standard (TIS) Executable and Linking Format (ELF) Specification Version 1.2</title>
		<ptr target="http://refspecs.linuxbase.org/elf/elf.pdf" />
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">PinPlay: A framework for deterministic replay and reproducible analysis of parallel programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stallcup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lueck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cownie</surname></persName>
		</author>
		<idno type="DOI">10.1145/1772954.1772958</idno>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Code Generation and Optimization (CGO)</title>
		<imprint>
			<date type="published" when="2010-04">Apr. 2010</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><surname>Intel</surname></persName>
		</author>
		<ptr target="http://www.pinplay.org" />
		<title level="m">Program Record/Replay Toolkit</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Checkpoint/Restore in Userspace</title>
		<ptr target="http://criu.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Automatic logging of operating system effects to guide applicationlevel architecture simulation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<idno type="DOI">10.1145/1140277.1140303</idno>
	</analytic>
	<monogr>
		<title level="m">Joint International Conference on Measurement and Modeling of Computer Systems (SIGMETRICS)</title>
		<imprint>
			<date type="published" when="2006-06">Jun. 2006</date>
			<biblScope unit="page" from="216" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Pinball2elf (Intel)</title>
		<ptr target="http://pinelfie.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Intel R 64 and IA-32 architectures software developer&apos;s manual volume 1: Basic architecture</title>
		<author>
			<persName><surname>Intel</surname></persName>
		</author>
		<ptr target="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Pintool Regions</title>
		<ptr target="https://software.intel.com/en-us/articles/pintool-regions" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Software and System Development Using Virtual Platforms: Full-System Simulation with Wind River Simics, 1st ed</title>
		<author>
			<persName><forename type="first">D</forename><surname>Aarno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Engblom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Intel Software Development Emulator</title>
		<ptr target="http://www.intel.com/software/sde" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">SPEC CPU2017: Nextgeneration compute benchmark</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-D</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Kistowski</surname></persName>
		</author>
		<idno type="DOI">10.1145/3185768.3185771</idno>
	</analytic>
	<monogr>
		<title level="m">International Conference on Performance Engineering (ICPE)</title>
		<imprint>
			<date type="published" when="2018-04">Apr. 2018</date>
			<biblScope unit="page" from="41" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Reproducible simulation of multithreaded workloads for architecture design exploration</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<idno type="DOI">10.1109/IISWC.2008.4636102</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Workload Characterization (IISWC)</title>
		<imprint>
			<date type="published" when="2008-09">Sep. 2008</date>
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">SuiteSpecks and SuiteSpots: A methodology for the automatic conversion of benchmarking programs into intrinsically checkpointed assembly code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ringenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Mudge</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISPASS.2009.4919654</idno>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
		<imprint>
			<date type="published" when="2009-04">Apr. 2009</date>
			<biblScope unit="page" from="227" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">DMTCP: Transparent checkpointing for cluster computations and the desktop</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Arya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cooperman</surname></persName>
		</author>
		<idno type="DOI">10.1109/IPDPS.2009.5161063</idno>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Parallel Distributed Processing (IPDPS)</title>
		<imprint>
			<date type="published" when="2009-05">May 2009</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
