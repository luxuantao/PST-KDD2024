<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NanoFabrics: Spatial Computing Using Molecular Electronics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Seth</forename><forename type="middle">Copen</forename><surname>Goldstein</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Mihai</forename><surname>Budiu</surname></persName>
							<email>mihaib@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">NanoFabrics: Spatial Computing Using Molecular Electronics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E6AE9686BE8B29C2EC2317D1FE198683</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The continuation of the remarkable exponential increases in processing power over the recent past faces imminent challenges due in part to the physics of deep-submicron CMOS devices and the costs of both chip masks and future fabrication plants. A promising solution to these problems is offered by an alternative to CMOS-based computing, chemically assembled electronic nanotechnology (CAEN).</p><p>In this paper we outline how CAEN-based computing can become a reality. We briefly describe recent work in CAEN and how CAEN will affect computer architecture. We show how the inherently reconfigurable nature of CAEN devices can be exploited to provide high-density chips with defect tolerance at significantly reduced manufacturing costs. We develop a layered abstract architecture for CAEN-based computing devices and we present preliminary results which indicate that such devices will be competitive with CMOS circuits.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We are approaching the end of a remarkably successful era in computing: the era where Moore's Law reigns, where processing power per dollar doubles every year. This success is based in large part on advances in complementary metal-oxide semiconductor (CMOS)-based integrated circuits. Although we have come to expect, and plan for, the exponential increase in processing power in our everyday lives, today Moore's Law faces imminent challenges both from the physics of deep-submicron CMOS devices and from the costs of both chip masks and next-generation fabrication plants.</p><p>A promising alternative to CMOS-based computing under intense investigation is chemically assembled electronic nanotechnology (CAEN), a form of electronic nanotechnology (EN) which uses self-alignment to construct electronic circuits out of nanometer-scale devices that take advantage of quantum-mechanical effects <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b29">30]</ref>. In this paper we show how CAEN can be harnessed to create useful computational devices with more than ½¼ ½¼ gate-equivalents per cm ¾ . The fundamental strategy we will use is to substitute compile time (which is inexpensive) for manufacturing precision (which is expensive). We achieve this through a combination of reconfigurable computing, defect tolerance, architectural abstractions and compiler technology. The result will be a high-density low-power substrate which will have inherently lower fabrication costs than CMOS counterparts.</p><p>Using EN to build computer systems requires new ways of thinking about computer architecture and compilation. CAEN differs from CMOS: CAEN is extremely unlikely to be used to construct complex aperiodic structures. We introduce an architecture based on fabricating dense regular structures, which we call nanoBlocks, that can be programmed after fabrication to implement complex functions. We call an array of connected nanoBlocks a nanoFabric.</p><p>Compared to CMOS, CAEN-based devices have a higher defect density. Such circuits will thus require built-in defect tolerance. A natural method of handling defects is to first configure the nanoFabric for self-diagnosis and then to implement the desired functionality by configuring around the defects. Reconfigurabilty is thus integral to the operation of the nanoFabric. Their nature makes nanoFabrics particularly well suited for reconfigurable computing.</p><p>Reconfigurable computing changes as needed the function of programmable logic elements and their connections to storage, building efficient, highly parallel processing kernels, tailored for the application under execution. The network of processing elements is called a reconfigurable fabric. The data used to program the interconnect and processing elements is called a configuration. Examples of current reconfigurable fabrics are commercial Field Programmable Gate Arrays (FPGAs) such as <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b1">2]</ref>, and research prototypes, e.g. Chimaera <ref type="bibr" target="#b39">[40]</ref> and PipeRench <ref type="bibr" target="#b17">[18]</ref>. As we show later, one advantage of nanoFabrics over CMOS-based reconfigurable fabrics is that the area overhead for supporting reconfiguration is virtually eliminated. This will magnify the benefits of reconfigurable computing, yielding computing devices that may outperform traditional ones by orders of magnitude in many metrics, such as computing elements per cm ¾ and operations per watt.</p><p>In the next section we present some recent research results, which indicate CAEN will be a successful technol-ogy for implementing computing devices. We next analyze how the unique features of CAEN devices can be exploited, and how their limitations can be circumvented. In Section 3 we present an architecture that utilizes the capabilities of CAEN devices without requiring Herculean fabrication technology. In Section 4 we describe our top-level architectural abstraction, the Split-Phase Abstract Machine (SAM), which enables fast compilation of large programs. The simulation results in Section 5 indicate that the SAM abstraction does not hide the efficiency of the nanoFabric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Electronic Nanotechnology</head><p>While CMOS fabrication will soon hit a wall due to a combination of economic and technical factors, <ref type="foot" target="#foot_0">1</ref>we are nowhere near the theoretical limits of physical computation <ref type="bibr" target="#b16">[17]</ref>. In order to achieve these limits at room temperature we must work in the nanoscale regime, which currently involves various technologies that exploit the quantum-mechanical effects of small devices. Among these are single-electron transistors <ref type="bibr" target="#b8">[9]</ref>, nanowire transistors <ref type="bibr" target="#b10">[11]</ref>, quantum dots <ref type="bibr" target="#b36">[37]</ref>, quantum cellular automata <ref type="bibr" target="#b22">[23]</ref>, resonant tunneling devices <ref type="bibr" target="#b5">[6]</ref>, negative differential resistors (NDR) <ref type="bibr" target="#b6">[7]</ref>, and reconfigurable switches <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref>. In all cases, the fabricated devices are on the order of a few nanometers. Given the small sizes involved, these devices must be created and connected through self-assembly and selfalignment instead of lithography.</p><p>In this paper we limit ourselves to molecular devices which have I-V characteristics similar to those of their bulk counterparts. For example, the basis of rectification is different between a silicon-based p-n junction diode and a molecular diode, yet they both have similar I-V curves <ref type="bibr" target="#b3">[4]</ref>. We choose to look at systems that can be built from nanoscale devices with bulk-semiconductor analogs so that (1) we can apply our experience with standard circuits to the system and (2) we can model the system with standard tools such as SPICE.</p><p>While there are still many challenges left in creating fully functional EN computing devices, recent advances indicate that EN could be a very successful post-CMOS technology. Several groups have recently demonstrated CAEN devices that are self-assembled or self-aligned (or both) <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b31">32]</ref>. Advances have also been made in creating wires out of single-wall carbon nanotubes and aligning them on a silicon substrate <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b28">29]</ref>. Even more practical is the fabrication of metal nanowires, which scale down to 5nm and can include embedded devices <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b26">27]</ref>. Combined,these advances compel us to investigate further how to harness CAEN for computing in the post-CMOS age.</p><p>CAEN devices are very small: A single RAM cell will require ½¼¼nm ¾ as opposed to ½¼¼ ¼¼¼nm ¾ for a single laid out CMOS transistor<ref type="foot" target="#foot_1">2</ref> . A simple logic gate or an static memory cell requires several transistors, separate p-and nwells, etc., resulting in a factor of ½¼ difference in density between CAEN and CMOS. CAEN devices use much less power, since very few electrons are required for switching.</p><p>CAEN devices are particularly suited for reconfigurable computing since the configuration information for a switch does not need to be stored in a device separately from the switch itself <ref type="bibr" target="#b9">[10]</ref>. On the other hand, A CMOS-based reconfigurable device requires a static RAM cell to controls each pass transistor. Also, two sets of wires are needed in CMOS: one for addressing the configuration bit and one for the actual signals. Perhaps a more realistic comparison of CAEN is to floating-gate technology which also stores the configuration information at the transistor itself. Like traditional transistors, floating-gate transistors also require two sets of wires. Furthermore, A CAEN switch behaves like a diode, but a floating gate transistor is bi-directional, and thus less useful for building programmable logic.</p><p>Electronic nanotechnology is quickly progressing and promises incredibly small, dense, and low-power devices. Harnessing this power will require new ways of thinking about the manufacturing process. We will no longer be able to manufacture devices deterministically; instead, postfabrication reconfiguration will be used to determine the properties of the device and to avoid defects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Fabrication and Architectural Implications</head><p>Here we briefly outline a plausible fabrication process. The process is hierarchical, proceeding from basic components (e.g. wires and switches), through self-assembled arrays of components, to complete systems. In the first step, wires of different types are constructed through chemical self-assembly. 3 The next step aligns groups of wires. Also through self-assembly, two planes of aligned wires will be combined to form a two-dimensional grid with configurable molecular switches at the crosspoints. The resulting grids will be on the order of a few microns. A separate process will create a silicon-based die using standard lithography. The circuits on this die will provide power, clock lines, an I/O interface, and support logic for the grids of switches. The die will contain "holes" in which the grids are placed, aligned, and connected with the wires on the die.</p><p>Using only self-assembly and self-alignment restricts us to manufacturing simple, regular structures, e.g., rafts of parallel wires or grids composed of orthogonal rafts. A post-fabrication configuration is used to create useful circuits (See Section 3.3). The small size and nondeterministic nature of the self-assembly will also give rise to high defect densities, which can be bypassed through reconfiguration (See Section 3.2).</p><p>While researchers have constructed three-terminal EN devices, the precise alignment required to colocate three wires at the device makes them unsuitable for producing real circuits with inexpensive chemical assembly. We thus assume that CAEN devices will be limited to performing logic using two terminal devices; i.e. diode-resistor logic (see Section 3.1). As the active components will be diodes and configurable switches, there will be no inverters. Because we cannot build inverters, all logic functions will generally compute both the desired output and its complement.</p><p>Even more important, the lack of a transistor means that special mechanisms will be required for signal restoration and for building registers. Using CMOS to buffer the signals is unattractive for two reasons: first, CMOS transistors are significantly larger and would decrease the density of the fabric. Second, the large size of CMOS transistors would slow down the nanoFabric. We have succesfully designed and simulated a molecular latch motivated by work in tunnel diodes <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b25">26]</ref>. The latch is composed of a wire with two inline NDR molecules at either end. The latch combined with a clocking methodology, provides signal restoration, latching, and I/O isolation <ref type="bibr" target="#b30">[31]</ref>. The requirement to condition signals will result in circuits which will be either slow (if transistors are used) or deeply pipelined (if latches are used).</p><p>The fabrication process also disallows the precise alignment required to make end-to-end connections between nanoscale wires. Our architecture ensures that all connections between nanoscale wires occur by crossing the wires.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">NanoFabric</head><p>The architecture of the nanoFabric is designed to overcome the constraints associated with directed assembly of nanometer-scale components and exploit the advantages of molecular electronics. Because the fabrication process is fundamentally non-deterministic and prone to introducing defects, the nanoFabric must be reconfigurable and amenable to self-testing. This allows us to discover the characteristics of each nanoFabric and then create circuits that avoid the defects and use the available resources. For the foreseeable future, the fabrication processes will only produce simple, regular geometries. Therefore, the proposed nanoFabric is built out of simple, two-dimensional, homogeneous structures. Rather than fabricating complex circuits, we use the reconfigurability of the fabric to implement arbitrary functions post-fabrication. The construction process is also parallel; heterogeneity is introduced only at a lithographic scale. The nanoFabric can be configured (and reconfigured) to implement any circuit, like today's FPGAs; the nanoFabric though has several orders of magnitude more resources.</p><p>The nanoFabric is a 2-D mesh of interconnected nanoBlocks. The nanoBlocks are logic blocks that can be programmed to implement a three-bit input to three-bit output Boolean function and its complement (see Figure <ref type="figure" target="#fig_0">1a</ref>). NanoBlocks can also be used as switches to route signals.</p><p>The nanoBlocks are organized into clusters (See Figure <ref type="figure" target="#fig_1">2</ref>). Within a cluster the nanoBlocks are connected to their nearest four neighbors. Long wires, which may span many clusters (long-lines), are used to route signals between clusters. The nanoBlocks on the perimeter of the cluster are connected to the long-lines. This arrangement is similar to commercial FPGAs (allowing us to leverage current FPGA tools) and has been shown to be flexible enough to implement any circuit on the underlying fabric.  The nanoBlock design is dictated by fabrication constraints. Each side of the block can have inputs or outputs, but not both. Thus, the I/O arrangement in Figure <ref type="figure" target="#fig_0">1a</ref> is required. We have arranged it so that all nanoscale wire-towire connections are made between two orthogonal wires; we do not need precise end-to-end alignment. Figures <ref type="figure" target="#fig_0">1 (b</ref>) and (c) show how the outputs of one nanoBlock connect to the inputs of another. We call the area where the input and output wires overlap a switch block. Notice that the outputs of the blocks are either facing south and east (SE) or north and west (NW). By arranging the blocks such that all the SE blocks run in one diagonal and the NW run in the adjacent diagonal we can map any circuit netlist onto the nanoFabric. Since the nanoBlocks themselves are larger than the minimum lithographic dimension (e.g, greater than one micron), they can be positioned precisely at manufacturing time in the desired patterns.</p><p>In addition to the intra-cluster routing there are longlines that run between the clusters to provide low-latency communication over longer distances. The nanowires in these tracks will be of varying lengths (e.g., 1,2,4, and 8 clusters long), allowing a signal to traverse one or more clusters without going through any switches. This layout is essentially that of an island style FPGA <ref type="bibr" target="#b32">[33]</ref>. This general layout has been shown to be efficient and amenable to place-and-route tools <ref type="bibr" target="#b4">[5]</ref>. Notice that all communication between nanoBlocks occurs at the nanoscale. The fact that we never need to go between nanoscale and CMOS components and back again increases the density of the nanoFabric and lowers its power requirements.</p><p>The arrangement of the clusters and the long-lines promote scalability in several ways. First, as the number of components increases we can increase the number of longlines that run between the clusters. This supports routability of netlists. Second, each cluster is designed to be configured in parallel, allowing configuration times to remain reasonable even for very large fabrics. The power requirements remain low because we use molecular devices for all aspects of circuit operation. Finally, because we assemble the nanoFabric hierarchically we can exploit the parallel nature of chemical assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">NanoBlock</head><p>The nanoBlock is the fundamental unit of the nanoFabric. It is composed of three sections (see Figure <ref type="figure" target="#fig_2">3</ref>): (1) the molecular logic array, where the functionality of the block is located, (2) the latches, used for signal restoration and signal latching for sequential circuit implementation, and (3) the I/O area, used to connect the nanoBlock to its neighbors through the switch block.</p><p>The molecular logic array (MLA) portion of a nanoBlock is composed of two orthogonal sets of wires. At each intersection of two wires lies a configurable molecular switch. The switches, when configured to be "on", act as diodes. Designing circuits for the MLA is significantly different than for a programmable logic array, which requires an OR and an AND plane. We have preliminary designs for a "standard cell" library using nanoBlocks, e.g. AND, OR, XOR, and ADDER.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the implementation of an AND gate, while Figure <ref type="figure" target="#fig_4">5</ref> shows the implementation for a half-adder. On the top part of Figure <ref type="figure" target="#fig_4">5</ref> is a schematic of the portion of the circuit used to generate the sum output. This circuit, which is the XOR of A and B is typical of diode-resistor logic. For example, if A is high and B is low, then their complements (A-bar and B-bar) are low and high respectively. Thus, diodes 1, 2, 5 and 6 will be reverse biased and not conducting. Diode 8 will be forward biased, and will  The MLA computes logic functions and routes signals using diode-resistor logic. The benefit of this scheme is that we can construct it by directed assembly, but the drawback is that the signal is degraded every time it goes through a configurable switch. In order to restore signals to proper logic values without using CMOS gates, we will use the molecular latch described in Section 2.1.</p><p>Notice that all the connections between the CMOS layer and the nanoBlock occur either between groups of wires or with a wire that is removed from all the other components. This improves the device density of the fabric. To achieve a specific functionality the cross-points are configured to be either open-connections or to be diodes.</p><p>The layout of the MLA and of the switch block makes rerouting easy in the presence of faults. By examining Figure <ref type="figure" target="#fig_4">5</ref>, one can see that a bad switch is easily avoided by swapping wires that only carry internal values. In fact, the rows can be moved anywhere within the block without affecting the circuit, which makes defect tolerance significantly easier than with CMOS <ref type="foot" target="#foot_3">4</ref> . The number of possible ways to arrange the columns/rows in the MLA combined with the configurable crossbar implemented by the switch block makes the entire design robust to defects in either the switch block or the MLA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Defect Tolerance</head><p>The nanoFabric is defect tolerant because it is regular, highly configurable, fine-grained, and has a rich interconnect. <ref type="foot" target="#foot_4">5</ref> The regularity allows us to choose where a particular function is implemented. The configurability allows us to pick which nanowires, nanoBlocks, or parts of a nanoBlock will implement a particular circuit. The fine-grained nature of the device combined with the local nature of the interconnect reduces the impact of a defect to only a small portion of the fabric (or even a small portion of a single nanoBlock). Finally, the rich interconnect allows us to choose among many paths in implementing a circuit. Thus, with a defect map we can create working circuits on a defective fabric. Defect discovery relies on the fact that we can configure the nanoFabric to implement any circuit, which implies that we can configure the nanoFabric to test its own resources.</p><p>The key difficulty in testing the nanoFabric (or any FPGA) is that it is not possible to test the individual components in isolation. Researchers on the Teramac project <ref type="bibr" target="#b2">[3]</ref> faced similar issues. They devised an algorithm that allowed the Teramac, in conjunction with an outside host, to test itself <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>. Despite the fact that over 75% of the chips in the Teramac have defects, the Teramac is still used today. The basis of the defect mapping algorithm is to configure a set of devices to act as tester circuits. These circuits, e.g. linear-feedback shift-registers, will report a result which if correct indicates with high probability that devices they are made from are fault free.</p><p>The defect mapping process is complicated by the fact there are no known fault-free regions in the nanoFabric at the start of testing and as the defect density increases the chances of finding a good circuit decreases. To address this problem, we will implement in CMOS the components of a basic tester, which will provide the initial fault-free region. A host computer configures testers out of the CMOS testor and portions of the nanoFabric. As the host gains knowledge of the fault free regions of the nanoFabric it replaces more and more of the CMOS tester with configured sections of the nanoFabric.</p><p>After a sufficient number of functioning resources have been discovered by the host, phase two of the testing begins. For this phase, the host downloads a configuration, which performs the testing from within the fabric. In other words, the already tested area of the fabric acts as a host for testing the remainder of the fabric. Because the number of tests required to isolate any specific defect does not grow as the total size of the device grows, the computational work needed to test a device is at worst linear in the size of the device. For very large devices, such defect discovery can be accomplished using many parallel independent test machines.</p><p>Once a defect map has been generated the fabric can be used to implement arbitrary circuits. The architecture of the nanoBlock supports full utilization of the device even in the presence of a significant number of defects. Due to the way we map logic to wires and switches, only about 20% of the switches will be in use at any one time. Since the internal lines in a nanoBlock are completely interchangeable, we generally should be able to arrange the switches that need to be configured in the ON state to be on wires which avoid the defects.</p><p>While the molecules are expected to be robust over time, inevitably new defects will occur over time. Finding these defects, however, will be significantly easier than doing the original defect mapping because the unknown defect density will be very low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Configuration</head><p>The nanoFabric uses runtime reconfiguration for defect testing and to perform its intended function. Thus, it is essential that the time to configure the fabric scale with the size of the device. There are two factors that contribute to the configuration time. The first factor is the time that it takes to download a configuration to the nanoFabric. The second factor is the time that it takes to distribute the configuration bits to the different regions of the nanoFabric. Configuration decoders are required to serialize the configuration process in each nanoBlock. To reduce the CMOS overhead, initially we intend to only configure one nanoBlock per cluster at a time. However, the fabric has been designed so that the clusters can be programmed in parallel. A very conservative estimate is that we can simultaneously configure one nanoBlock in each of 1000 clusters in parallel.</p><p>A molecular switch is configured when the voltage across the device is increased outside the normal operating range. Devices in the switch blocks can be configured directly by applying a voltage difference between the long intercluster lines. In order to achieve the densities presented above, it will also be necessary to develop a configuration approach for the switches in the MLA that is implemented with nanoscale components. In particular, a nanoscale decoder is required to address each intersection of the MLA independently. Instead of addressing accessing each nanoscale wire separately in space we address them separately in the time dimension. This slows down the configuration time, but increases the device density.</p><p>Our preliminary calculations indicate that we can load the full nanoFabric, which is comprised of ½¼ configuration bits at a density of ½¼ ½¼ configuration bits/cm ¾ , in less than one second. This calculation is based on realistic assumptions that, on average, fewer than 10% of the bits are set ON and that the configurations are highly compressible <ref type="bibr" target="#b18">[19]</ref>. It also significant to note that it is not necessary to configure the full fabric for defect testing. Instead, we will configure only the portions under test.</p><p>As the configuration is loaded onto the fabric it will be used to configure the nanoBlocks. Using the configuration decoder this will require ¿¼¼ cycles per nanoBlock, or less than 38K cycles per cluster. Thus, the worst-case time to configure all the clusters at a very conservative 10 MHz requires three seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Putting It All Together</head><p>The nanoFabric is a reconfigurable architecture built out of CMOS and CAEN technology. The support system, i.e., power, ground, clock, and configuration wires, I/O, and basic control, is implemented in CMOS. On top of the CMOS we construct the nanoBlocks and long-lines constructed out of chemically self-assembled nanoscale components.</p><p>Assuming a 100nm CMOS process and 40nm centers with 128 blocks to a cluster and 30 long-lines per channel, our design should yield 750K clusters/cm ¾ (or 1M blocks/cm ¾ ), requiring ¿ ½¼ configuration bits. If the nanoscale wires are on 10nm centers this design yields 1M clusters/cm ¾ . (If, instead of molecular latches, transistors were used for signal restoration then with 40nm centers for the nanoscale wires we obtain 180K cluster/cm ¾ .) SPICE simulations show that a nanoBlock configured to act as a half-adder can operate at between 100MHz and 1GHz. Preliminary calculations show that the fabric as a whole will have a static power dissipation of ½ ¾watts and dynamic power consumption of watts at 100Mhz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The NanoFabric Model</head><p>There are two scenarios in which nanoFabrics can be used: as factory-programmable devices configured by the manufacturer to emulate a processor or other computing device, and as reconfigurable computing devices.</p><p>In a manufacturer-configured device, user applications treat the device as a fixed processor (or potentially as a small number of different processors). Processor designers will use traditional CAD tools to create designs using standard cell libraries. These designs will then be mapped to a particular chip, taking into account the chip's defects. A finished product is thus a nanoFabric chip and a ROM containing the configuration for that chip. In this mode, the configurability of the nanoFabric is used only to accommodate a defectprone manufacturing process. While this provides the significant benefits of reduced cost and increased densities, it ignores much of the potential in a nanoFabric. Since defect tolerance requires that a nanoFabric be reconfigurable why not exploit the reconfigurability to build applicationspecific processors?</p><p>Reconfigurable fabrics offer high performance and efficiency because they can implement hardware matched to each application. Further, the configurations are created at compile time, eliminating the need for complex control circuitry. Research has already shown that the ability of the compiler to examine the entire application gives a reconfigurable device efficiency advantages because it can: ¯exploit all of an application's parallelism: MIMD, SIMD, instruction-level, pipeline, and bit-level.</p><p>¯create customized function units. ¯eliminate a significant amount of control circuitry. ¯reduce memory bandwidth requirements. ¯size function units to the application's natural word size. ¯use partial evaluation and constant propagation to reduce the complexity of operations. However, this extra performance comes at the cost of significant work by the compiler. A conservative estimate for the number of configurable switches in a ½cm ¾ nanoFabric, including all the overhead for buffers, clock, power, etc. is on the order of ½¼ ½½ . Even assuming that a compiler manipulates only standard cells, the complexity of mapping a circuit design to a nanoFabric will be huge, and this creates a compilation scalability problem. Traditional approaches to place-and-route in particular will not scale to devices with billions of wires and devices.</p><p>In order to exploit the advantages listed above, we propose a hierarchy of abstract machines that will hide complexity and provide an intellectual lever for compiler designers while preserving the advantages of reconfigurable fabrics. At the highest level is a split-phase abstract machines (SAM), which allows a program to be broken up into autonomous units. Each unit can be individually placed and routed and then the resulting netlist of pre-placed and routed units, can be placed. This hierarchical approach will allow the CAD tools to scale. In this paper we present simulations of programs that have been decomposed into SAM threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Split-Phase Abstract Machine (SAM)</head><p>The compilation process starts by partitioning the application into a collection of threads. Each thread is a sequence of instructions ending in a split-phase operation. An operation is deemed to be a split-phase operation if it has an unpredictable latency. For example, memory references and procedure calls are all split-phase operations. Thus, each thread, similar in spirit to a Threaded Abstract Machine (TAM) thread <ref type="bibr" target="#b14">[15]</ref>, communicates with other threads asynchronously using split-phase operations. This partitioning allows the CAD tools to concentrate on mapping small isolated netlists and it has all the mechanisms required to support thread-based parallelism.</p><p>Unlike a traditional thread model, where a thread is associated with a processor when executing, each SAM thread will be a custom "processor." While it is possible for a thread to be complex and load "instructions" from its local store, the intention is that it remains fairly simple, implementing only a small piece of a procedure. This allows the threads to act either in parallel or as a series of sequential processes. It also reduces the number of timing constraints on the system, which is vital for increasing defect tolerance and decreasing compiler complexity.</p><p>The SAM model is a simplification of TAM. A SAM thread/processor is similar to a single-threaded codeblock in TAM, and memory operations in SAM are similar to memory operations in Split-C <ref type="bibr" target="#b13">[14]</ref>. In a sense, SAM will implement (in reconfigurable hardware) Active Messages <ref type="bibr" target="#b37">[38]</ref> for all interprocessor communications. While this model is powerful enough to support multi-threading, in this paper we use it only as a way of partitioning large sequential programs in space on a reconfigurable nanoFabric.</p><p>While SAM can support parallel computation, a parallelizing compiler is not necessary. The performance of this model rests on the ability to create custom processors. A compiler could (and in its first incarnations will) construct machines in which only one processor is active at a time. Later, as the compiler technology becomes more mature, the inherently parallel nature of the model can be exploited.</p><p>The SAM model explicitly hides many important details. For example, it neither addresses dynamic routing of messages nor allocation of stacks to the threads. Once an application has been turned into a set of cooperating SAM threads it is mapped to a more concrete architectural model which takes these issues into account. The mapping process will, when required, assign local stacks to threads, insert circuits to handle stack overflow, and create a network for routing messages with runtime computed addresses. For messages with addresses known at compile time it will route signals directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SAM Simulations</head><p>In this section we describe a limit study designed to determine the performance of applications mapped to the SAM model. Our goal was to determine how aggressive compiler technology needs to be for the nanoFabric to compete with a CMOS processor. We estimate the area and simulate the execution time of applications using the simplest SAM model, i.e. each thread executes sequentially, and we do not perform any reconfigurable computing optimizations, e.g., loops are not turned into pipelines.</p><p>In this study we analyze the behavior of programs from the SpecInt95 <ref type="bibr" target="#b34">[35]</ref> and Mediabench <ref type="bibr" target="#b21">[22]</ref> <ref type="foot" target="#foot_5">6</ref> benchmark suites. We assume no parallel execution or pipelining between independent SAM threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Area requirements</head><p>We define the unit of area as the area of the implementation of one memory word (4 bytes). We assume that each integer operation can be also implemented in 1 unit of area. Integer multiplication and division and floating-point operations have a substantially larger area. These assumptions are overly pessimistic for memory, which can probably be packed more densely. We make the very conservative assumption that 1 unit of area is a single cluster. In fact, a cluster will probably be able to map between 1 and 64 units.</p><p>For our benchmarks the total area was between 2,000 and 250,000 units (see Figure <ref type="figure" target="#fig_6">7</ref>), which fits liberally in the available hardware budget. This area includes only the executed instructions and touched memory words. Dead code and unused memory is excluded from this count, but their total size is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Simulation Methodology</head><p>We compare the execution time of the program running native on the CPU (Alpha), and running on a nanoFabric. We include application and library running time. We ignore time spent in the operating system. The simulation consists of two phases: trace collection and analysis, and trace-based simulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Trace Collection and Analysis</head><p>Each application to be simulated is compiled using gcc and optimized with -O4 on the Alpha. The ATOM tool <ref type="bibr" target="#b33">[34]</ref> is used to instrument the program for trace collection and summarization. We instrument each basic block, procedure call and memory access.</p><p>From the trace data we create a weighted undirected graph (with weights both on nodes and edges). Each node represents either a SAM thread or a memory location and its weight is the estimation of the area it requires on the nanoFabric. The weight of an edge represents the total data traffic carried along that edge. Each basic block and each memory address becomes a node. We eliminate some of aliasing of the memory locations by assuming that the stack frame of each function is a different memory region.</p><p>An edge between two basic blocks is weighted with the number of data values transferred across that edge (i.e. the number of register values defined in the first block and used in the second one) <ref type="foot" target="#foot_6">7</ref> . Transfers of control resulting from procedure calls are weighted with the total size of the procedure arguments. An edge between a basic block node and a memory node is weighted with the number of accesses made from the block to that address.</p><p>This graph is next placed on a two-dimensional grid. We strive to place nodes connected by heavy edges together. Assuming that the signal propagation time between two nodes is proportional to their distance, such a placement will minimize signal latency. We do the placement in two stages: clustering and placement.</p><p>¯In the first stage nodes are clustered together into supernodes of approximately the same weight (the weight of a super-node being the sum the weights of all the component nodes). Each supernode is 100 units of area. The clustering is done so to minimize the total edge weight between the super-nodes. For this purpose we use the METIS <ref type="bibr" target="#b19">[20]</ref> graph partitioning tool.</p><p>¯In the second stage we place the super-nodes on a twodimensional grid. We assume that each super-node is a 10x10 square. We next repeatedly "glue" pairs of super-nodes (obtaining progressively larger rectangles and squares: 10x10, 10x20, 20x20, 20x40, 40x40, etc). The ends of the heavier edges are coalesced first. For each pair of nodes we choose the relative orientation that minimizes the total edge cost (i.e. the nodes can be flipped or rotated).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Trace-based simulation</head><p>The second phase of the simulation runs the ATOMinstrumented binary, generating a trace of all important events: control transfer between blocks and memory read operations. We use the same input data that we used for the first phase.</p><p>We use this trace to evaluate the running time of the program when implemented as a circuit whose layout is the one computed by our placement algorithm. The running time of a node contains the following components:</p><p>¯The time to pass control between the source to the destination. This is proportional to the Manhattan distance between the two super-nodes where these nodes belong.</p><p>¯The time to transfer data from the source node to the destination. The registers which are live at the start of the node and used within are assumed to come from the previous node. We assume that the data is pipelined after the message which transfers control from the source, and each additional register value takes one clock cycle.</p><p>¯The time to execute the node itself. We assume full hardware ILP (i.e. all independent instructions are executed in parallel). The time to execute the node is thus the time to execute the critical path. The critical path may depend on      We use the following model for the execution of an instruction:</p><p>¯Each elementary instruction takes one clock cycle. ¯Each read operation takes time proportional to the Manhattan distance to the memory address which is accessed (the signal needs to propagate both ways: one direction with the read address, and the opposite direction with the read data).</p><p>¯Each write instruction takes one cycle and is completed asynchronously. We assume ordered message delivery. All reads to the same address should be executed after the write completes, even if they occur in different nodes.</p><p>¯For floating-point operations we use the double of the latency of the same instruction as executed on Alpha. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Comments</head><p>In some respects our simulation methodology is overly optimistic, in others it is pessimistic. Our goal here is to validate the assumption that we can map an application completely to hardware. In practice, more aggressive compilation and resource sharing would change the resulting configuration substantially. Here, we point out some of the assumptions which will need to be revisited in a more realistic study. Optimistic assumptions:</p><p>¯The placed graph depends on the input data. In general we cannot know what locations and nodes will be used.</p><p>¯The "inputs" (registers live on entry) to a node do not necessarily come from its immediate predecessor.</p><p>¯We assume that control and data transfer can be done directly between the two nodes involved.</p><p>¯We assume that each procedure has a statically allocated stack frame (This cannot be true for recursive procedures).</p><p>¯We underestimate the area by not disambiguating the aliasing caused by the re-allocation of de-allocated memory regions.</p><p>¯We completely ignore routability issues between nodes.</p><p>We assume sufficient wire bandwidth is available.</p><p>¯We ignore the propagation delay introduced by the molecular latches. Pessimistic assumptions:</p><p>¯We "issue" a memory read operation only when the read instruction is executed. Reads could be initiated as soon as the address is known.</p><p>¯No effort is made to customize the circuit for the application. For example, many of these applications have kernels which, when compiled properly, show speedup on the order of 100x over a conventional processor <ref type="bibr" target="#b17">[18]</ref>.</p><p>¯We do not do any speculative or parallel execution. ¯Nodes are strict, having to wait for their inputs before starting execution.</p><p>¯By not disambiguating between the uses of a memory word which is freed and re-allocated we unnecessarily constrain the placement of the graph.</p><p>¯The code we execute had its registers allocated for the Alpha, which has many fewer registers than would be available on the nanoFabric. Spilled registers become unnecessary costly memory operations.</p><p>¯We allocate a lot of area for each memory cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Results</head><p>Figure <ref type="figure" target="#fig_6">7</ref> shows that the hardware area used for each program, including memory. The unit of memory is the area taken by a simple integer instruction. We notice that all the programs will fit within the hardware resources of a 1cm ¾ nanoFabric.</p><p>Before discussing other aspects of the performance of our proposed implementation, we should notice some characteristics of the program graph: although it is sparse (the average node degree is less than 10), the node degree distribution is very skewed (each graph has a few large "stars"). Figure <ref type="figure" target="#fig_11">12</ref> displays one of the smallest graphs, where each square is a super-node, obtained after clustering (for readability). The shading of the squares indicates how many of the objects inside are instructions. A white square contains only code. The edges show communication patterns. The edge width is the logarithm of the number of messages sent across the edge. The edge color indicates the mix of types of messages: dark edge indicates memory reads only, while lighter edges indicates control transfers, with intermediate shadings for edges which carry mixed traffic. Despite the graph being very small, it exhibits some typical features for all our programs, like the big "stars": code regions which touch most of the memory of the program. "Stars" are bad, because there is no way to place all adjacent nodes close to the star's center node; some have to be remote. "Hot" memory locations, which are touched by a lot of basic blocks, are less common.</p><p>For example, the memcpy standard library function was the bottleneck in several programs, because it would access most of the memory used by the program. To reduce the size of the large "stars" we have inlined such functions at all their call sites, in effect duplicating the code. Each inlined copy of memcpy might service a different set of memory locations, to which it can be placed closer. This significantly improves in performance (our figures show the performance after inlining has been done). The area cost of inlining is negligible (less than 1%).</p><p>Inlining was ineffective or inapplicable for functions which were not leaves of the call graph, or which were called from a single place.</p><p>Figures <ref type="figure" target="#fig_5">6,</ref><ref type="figure" target="#fig_7">8</ref>, and 9 explore the impact of the signal propagation speed on the application performance: the light bar is drawn assuming the signals take one clock cycle between two adjacent super-nodes, while the dark bar is for a five clock cycles/super-node latency.</p><p>Figure <ref type="figure" target="#fig_5">6</ref> shows the slowdown of our applications. Negative values indicate speed-ups. The media applications fare better than the SpecInt ones as they tend to have a smaller memory footprint. Figures <ref type="figure" target="#fig_7">8</ref> and<ref type="figure" target="#fig_8">9</ref> show the impact of the propagation delay on the cost of the control flow transfer and of a memory read respectively. Because memory accesses can be executed in parallel to each other or to execution of the code, some of the memory latency is hidden. The cost of control-flow transfers scales better (slower) with increased propagation delay because the locality at the level of the code is much better. There are few "hot" nodes, and they can be placed very close to each other, often within the same super-node.</p><p>Figures <ref type="figure" target="#fig_9">10</ref> and<ref type="figure" target="#fig_10">11</ref> show how the running time of each application was spent for the two signal-propagation speeds. We notice that most often the dominant cost, especially for large signal propagation latencies, is in reading memory. The lack of caches makes remote memory operations costly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Research directions</head><p>Some form of memory data caching is crucial for reducing the dominant runtime cost, memory access. Hardware and software solutions will have to be devised for implementing distributed caches.</p><p>Besides the simple inlining strategy which we used to reduce the size of the "stars" in the graph, we can imagine several other solutions, like making many copies of the function code and randomly calling one of them each time, or inlining non-leaf functions.</p><p>Further code restructuring may be necessary in order to better localize memory accesses. We could improve data placement by using separate memory pools for each type of object.</p><p>The memcpy function can be optimized by a special implementation, as a three-party transaction. Instead of copying the data from source to the code block and then to the destination, it could directly ship the data from the sources to the destination memory nodes.</p><p>Predicated execution, speculative execution and code duplication (for better placement locality) would reduce the cost of control flow transfers.</p><p>Some of the techniques we propose to better handle hot spots will introduce further complications: replicating memory and using speculative execution would invalidate our assumption that consecutive operations to memory reach the memory location in the order they were issued (the triangle inequality can no longer be assumed). Special distributed synchronization mechanisms will have to be devised to preserve the program semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>In this paper we propose a new architecture, the nanoFabric, based on chemically assembled electronic nanotechnology. The nanoFabric is designed to harness the smallness of electronic nanotechnology and to overcome some of the most onerous limitations introduced by chemical assembly. It eliminates the need for transistors, the neccesity of precise alignment and placement of wires, and provides for defect tolerance. In conjunction with CMOS support circuitry it will create a reconfigurable fabric with more than ½¼ ½¼ gate equivalents/cm ¾ .</p><p>The main computing element in the nanoFabric is a molecular-based reconfigurable switch. We exploit the reconfigurable nature of the nanoFabric to provide defect tolerance and to support reconfigurable computing. Reconfigurable computing offers the promise of not only increased performance, but ammortizes the cost of chip manufacturing across many users by allowing circuits to be configured post-fabrication. The molecular-based switch eliminates much of the overhead needed to support reconfigurationthe switch holds its own state and can be programmed without extra wires, making nanoFabrics ideal for reconfigurable computing. As the nanoFabric is a combination of two technologies, CMOS with CAEN, it suggests a hybrid architecture that may combine silicon-based custom circuits with CAEN-based reconfigurable ones.</p><p>To support defect tolerance, ease of placement and routing constraints, and enable faster compilation, we propose a new architectural model, the split-phase abstract machine (SAM). SAM ensures that all operations of potentially unknown latency use split-phase operations. The compilation strategy engendered by SAM is to partition an application into independent threads at all split-phase boundaries. This partitioning will allow compilers and CAD tools to handle the large designs than can fit on a nanoFabric. While the model is powerful enough to express parallel execution, we perform a study which limits the model to sequential execution, and uses only simple scalar compiler optimizations. Our simple compilation strategy produces results whose average performance is within a factor of 2.5 of the performance of an Alpha microprocessor, under the most pessimistic delay assumptions for our fabric. We uncover several performance bottlenecks which hint at future research avenues which will make the nanoFabric a viable substrate.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>NanoBlock Connectivity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. The layout of the nanoFabric with a partial blowup of a single cluster and some of the adjacent long-lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. A schematic of a nanoBlock.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. An AND gate implemented in the MLA of a nanoBlock.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. A half-adder implemented in the MLA of a nanoBlock and the equivalent circuit diagram for the computation of A XOR B = S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Simulated slowdown (simulated/base ½).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Total area for instructions and memory.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Average clock cycles per control transfer.Figure 9. Average clock cycles per memory read.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 .</head><label>9</label><figDesc>Figure 8. Average clock cycles per control transfer.Figure 9. Average clock cycles per memory read.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Breakdown of execution time for 1 clock/square. Idle time is the time spent waiting for memory read operations to complete.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Breakdown of execution time for 5 clocks/square.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. The placed graph for g721 e.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Among the technical issues are ultrathin gate oxides, short channel effects, and doping fluctuations<ref type="bibr" target="#b20">[21]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For the CAEN device we assume that the nanowires are on 10nm centers. A CMOS transistor with a 4:1 ratio in a 70nm process, (even using Silicon on Insulator, which does not need wells) with no wires attached measures 210nm x 280nm. Attaching minimally-sized wires to the terminals increases the size</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>to 350nm x 350nm.<ref type="bibr" target="#b2">3</ref> By chemical self-assembly we mean a process by which the components (e.g., wires or devices) are synthesized and connected together through chemical processes. See<ref type="bibr" target="#b23">[24]</ref> for an overview.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This is because nanowires have several orders of magnitude less resistance than switches. Thus, the timing of a block is unaffected by small permutations in the design.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p><ref type="bibr" target="#b4">5</ref> Defect tolerance through configuration also depends on shorts being significantly less likely to occur than stuck-open faults. We arrange for this by biasing the synthesis techniques to increase the likelihood of a stuckopen fault at the expense of potentially introducing more total faults.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>The other programs from these suites did not work properly with our simulation infrastructure; we present all the applications we could successfully instrument and analyze.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>For a faster calculation, we approximate this value with the number of registers used in the second basic block.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was sponsored in part by DARPA, under the Moletronics Program, by NSF, under a CAREER award, and Hewlett-Packard Corporation. The authors wish to thank the many reviewers for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tunnel devices as switching elements</title>
		<author>
			<persName><forename type="first">I</forename><surname>Aleksander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Scarr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal British IRE</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">43</biblScope>
			<biblScope unit="page" from="177" to="192" />
			<date type="published" when="1962-03">March 1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://-www.altera.com/html/products/apex.html" />
		<title level="m">Apex device family</title>
		<imprint/>
		<respStmt>
			<orgName>Altera Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Teramac-configurable custom computing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Culbertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kuekes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Snider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Workshop on FPGAs for Custom Computing Machines</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Buell</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Pocek</surname></persName>
		</editor>
		<meeting>IEEE Workshop on FPGAs for Custom Computing Machines<address><addrLine>Napa, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-04">Apr. 1995</date>
			<biblScope unit="page" from="32" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Molecular rectifiers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aviram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ratner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Chemical Physics Letters</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="277" to="283" />
			<date type="published" when="1974-11">Nov. 1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Vpr: A new packing, placement and routing tool for fpga research</title>
		<author>
			<persName><forename type="first">V</forename><surname>Betz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Field Programmable Logic and Applications</title>
		<meeting>the International Workshop on Field Programmable Logic and Applications</meeting>
		<imprint>
			<date type="published" when="1997-08">Aug. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mesoscopic phyics and nanoelectronics: Nanoscience and nanotechnology</title>
		<author>
			<persName><forename type="first">F</forename><surname>Buot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physics Reports</title>
		<imprint>
			<biblScope unit="page" from="173" to="174" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Observation of a large on-off ratio and negative differential resistance in an electronic molecular switch</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Rawlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Tour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">286</biblScope>
			<biblScope unit="page" from="1550" to="1552" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Room-temperature negative differential resistance in nanoscale molecular junctions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rawlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Price</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Tour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Phys. Lett</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page">1224</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Singleelectron transistor logic</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Korotov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Likharev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Phys. Lett</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page">1954</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Electronically configurable molecular-based logic gates</title>
		<author>
			<persName><forename type="first">C</forename><surname>Collier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Belohradsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Raymo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Stoddart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Kuekes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Heath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="page" from="391" to="393" />
			<date type="published" when="1999-07">July 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Functional nanoscale electronic devices assembled using silicon nanowire building blocks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">291</biblScope>
			<biblScope unit="page" from="851" to="853" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Teramac Custom Computer: Extending the Limits with Defect Tolerance</title>
		<author>
			<persName><forename type="first">W</forename><surname>Culbertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Amerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kuekes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Snider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems</title>
		<meeting>IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Defect tolerance on the Teramac Custom Computer</title>
		<author>
			<persName><forename type="first">W</forename><surname>Culbertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Amerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kuekes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Snider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 IEEE Symposium on FP-GAs for Custom Computing Machines</title>
		<meeting>the 1997 IEEE Symposium on FP-GAs for Custom Computing Machines</meeting>
		<imprint>
			<date type="published" when="1997-04">April 1997</date>
			<biblScope unit="page" from="116" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallel programming in split-c</title>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lumetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Von Eicken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yelick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Supercomputing &apos;93 Conference</title>
		<meeting>the Supercomputing &apos;93 Conference</meeting>
		<imprint>
			<date type="published" when="1993-11">Nov. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">TAM -a compiler controlled threaded abstract machine</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Schauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Von Eicken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="347" to="370" />
			<date type="published" when="1993-07">July 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Room temperature operation of Si single-electron memory with self-aligned floating dot gate</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Phys. Lett</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page">1742</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Feynman</surname></persName>
		</author>
		<title level="m">Lectures in Computation</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Piperench: A coprocessor for streaming multimedia acceleration</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schmit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cadambi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Laufer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Annual International Symposium on Computer Architecture</title>
		<meeting>the 26th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<biblScope unit="page" from="28" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Configuration compression for the Xilinx XC6200 FPGA</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hauck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Schwabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Trans. on CAD of IC and Systems</title>
		<imprint>
			<date type="published" when="1999-08">August 1999</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1107" to="1113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Multilevel graph partitioning and sparse matrix ordering</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 Intl. Conference on Parallel Processing</title>
		<meeting>the 1995 Intl. Conference on Parallel Processing</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Miniaturization of electronics and its limits</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Keyes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="48" />
			<date type="published" when="1988-01">Jan 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Mediabench: a tool for evaluating and synthesizing multimedia and communications systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Mangione-Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Micro-30, 30th annual ACM/IEEE international symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="330" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A device architecture for computing with quantum dots</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Mallouk</surname></persName>
		</author>
		<ptr target="http://-research.chem.psu.edu/mallouk/nano.pdf" />
		<title level="m">Nanomaterials: Synthesis and assembly</title>
		<imprint>
			<date type="published" when="2000-11">Nov. 2000</date>
		</imprint>
	</monogr>
	<note>Foresight Conference Tutorial</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Orthogonal self assembly on colloidal gold-platinum nanorods</title>
		<author>
			<persName><forename type="first">B</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dermody</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lyon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Natan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mallouk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advanced Materials</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1021" to="1025" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A new RTD-FET logic family</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mathews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sollner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Calawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mahoney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Molvar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">596</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Mbindyo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Keating</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Natan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mallouk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advanced Materials</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The self-assembly of a switchable [2]rotaxane</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S M V</forename><surname>Martinez-Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stoddart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Angewandte Chemie International Edition English</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<date type="published" when="1904">1904. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Fabrication of metallic electrodes with nanometer separation by electromigration</title>
		<author>
			<persName><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alivisatos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mceuen</surname></persName>
		</author>
		<ptr target="www.physics.berkeley.edu/-research/mceuen/topics/nanocrystal/EMPaper.pdf" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Molecular-scale electronics</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1999-04">April 1999</date>
			<biblScope unit="volume">87</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">What makes a good molecular computing device?</title>
		<author>
			<persName><forename type="first">D</forename><surname>Rosewater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldstein</surname></persName>
		</author>
		<idno>CMU-CS-01-114</idno>
		<imprint>
			<date type="published" when="2001-03">March 2001</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Carbon nanotube-based nonvolatile random access memory for molecular computing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Rueckes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Joselevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-L</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">289</biblScope>
			<biblScope unit="page" from="94" to="97" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R S</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vranesic</surname></persName>
		</author>
		<title level="m">Field-Programmable Gate Arrays</title>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Atom: A system for building customized program analysis tools</title>
		<author>
			<persName><forename type="first">A</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Eustace</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Digital Equipment Corporation Western Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Standard Performance Evaluation Corp. SPEC CPU95 Benchmark Suite</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Individual single-wall carbon nanotubes as quantum wires</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">386</biblScope>
			<biblScope unit="issue">6624</biblScope>
			<biblScope unit="page" from="474" to="477" />
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Turton</surname></persName>
		</author>
		<title level="m">The Quantum Dot: A journey into the Future of Microelectronics</title>
		<meeting><address><addrLine>U.K.</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Active messages: a mechanism for integrated communication and computation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Von Eicken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Schauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Symposium on Computer Architecture</title>
		<meeting>the 19th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1992-05">May 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<ptr target="http://www.xilinx.com/products/virtex.htm" />
		<title level="m">Virtex series fpgas</title>
		<imprint/>
		<respStmt>
			<orgName>Xilinx Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Chimaera: A high-performance architecture with a tightly-coupled reconfigurable functional unit</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hauck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Annual International Symposium on Computer Architecture</title>
		<meeting>the 27th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
