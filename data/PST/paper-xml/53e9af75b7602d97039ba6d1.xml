<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">OdeView: The Graphical Interface to Ode</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
						</author>
						<author>
							<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Gehani</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Srinivasan</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">AT&amp;T Bell Laboratories</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">AT&amp;T Bell Laboratories</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">AT&amp;T Bell Laboratories West Lafayette</orgName>
								<address>
									<postCode>47907</postCode>
									<region>IN</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">OdeView: The Graphical Interface to Ode</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">139033BD8BDF0EE6532945C15F56E7F3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>OdeView is the graphical front end for Ode, an object-oriented database system and environment. Ode's data model supports data encapsulation, type inheritance, and complex objects. OdeView provides facilities for examining the database schema (i.e., the object type or class hierarchy), examining class definitions, browsing objects, following chains of references starting from an object, synchronized browsing, displaying selected portions of objects (projection), and retrieving objects with specific characteristics (selection).</p><p>OdeView does not need to know about the internals of Ode objects. Consequently, the internals of specific classes are not hardwired into OdeView and new classes can be added to the Ode database without requiring any changes to or recompilation of OdeView. Just as OdeView does not know about the object internals, class functions (methods) for displaying objects are written without knowing about the specifics of the windowing software used by OdeView or the graphical user interface provided by it.</p><p>In this paper, we present OdeView, and discuss its design and implementation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>OdeView is the graphical front end to Ode <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">2]</ref>, a database system and environment based on the object paradigm. Ode is an attempt to build a database system that offers one integrated data model for both database and general purpose manipulation. The database is defined, queried, and manipulated using the database programming language O++, which is an upwardcompatible extension of the object-oriented programming language C++ <ref type="bibr">[ Stroustrup 1986</ref> ]. O++ extends C++ by providing facilities suitable for database applications, such as facilities for creating persistent and versioned objects, defining and manipulating sets, organizing persistent objects into clusters, iterating over clusters of persistent objects, and associating constraints and triggers with objects.</p><p>OdeView is intended for users who do not want to write programs in Ode's database programming language _ ____________________ * Rakesh Agrawal is now with IBM Almaden Research Center, San Jose, CA 95120 O++ to interact with Ode but instead want to use a friendlier interface to Ode. OdeView is based on the graphical direct manipulation paradigm <ref type="bibr" target="#b26">[26]</ref> that involves selection of items from pop-up menus and icons that can be clicked on and dragged. OdeView provides facilities for examining the database schema (i.e., the object type or class hierarchy), examining class definitions, browsing objects, following chains of references starting from an object, synchronized browsing, displaying selected portions of objects (projection), and retrieving objects with specific characteristics (selection).</p><p>OdeView does not need to know about the internals of Ode objects. Consequently, the internals of specific classes are not hardwired into OdeView and new classes can be added to the Ode database without requiring any changes to or recompilation of OdeView. OdeView uses dynamic linking to call class functions (member functions in C++ or methods), which exist in compiled form. Each class must provide class functions for displaying objects of that class. It is these special ''display'' functions that OdeView calls when objects are to be displayed. OdeView interacts with member functions using a predefined protocol. Just as OdeView does not know about the internals of the objects, the protocol for interacting with OdeView allows the class designer to write functions for displaying an object in one or more ways in different windows without knowing about the specifics of the windowing software used by OdeView or the graphical interface provided by it. Thus objects can be displayed by different versions of OdeView which may be implemented quite differently, for example, these versions may be based on different windowing systems.</p><p>In this paper, we describe OdeView, discuss the issues in the design and implementation of OdeView, and present extensions that we plan to implement in future. Section 2 gives an overview of Ode. Section 3 is a simulation of a user session with OdeView. The design and implementation of OdeView is discussed in Section 4. Section 5 presents the design of some extensions that we are planning for OdeView. Section 6 discusses related work and Section 7 summarizes our experience with OdeView.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ODE OVERVIEW</head><p>The O++ object model is based on the C++ object model, called the class. The class facility supports data encapsulation and multiple inheritance.</p><p>An Ode database is viewed as a collection of persistent objects. Persistent objects of the same type are grouped together into a cluster; the name of a cluster is the same as that of the corresponding type. The database schema is the collection of class definitions of the objects that exist in the databases and the inheritance relationship between these types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A SAMPLE SESSION</head><p>OdeView is the graphical front end (user interface) to the Ode database system. Currently, OdeView provides facilities to browse the database schema which in this case consists of the O++ class definitions and browse objects in the database.</p><p>To give you a flavor of OdeView, we describe a sample session with OdeView.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Initial Configuration and Schema Browsing</head><p>Upon entering OdeView, the user is presented with a scrollable ''database'' window containing the names and iconified images of the current Ode databases (Figure <ref type="figure">1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1: Initial Display</head><p>The user can select a database to interact with by using the mouse to click on the appropriate icon. For example, let us look at the lab database identified by the ATT icon; this a small database about employees in our research center. Upon clicking on the ATT icon, OdeView opens a ''class relationship'' or schema window which displays the hierarchy relationship between the object classes in the ATT database (Figure <ref type="figure" target="#fig_0">2</ref>). The hierarchy relationship between classes is a set of dags and OdeView uses a dag placement algorithm <ref type="bibr" target="#b19">[19]</ref> that minimizes crossovers to display it.</p><p>The user can zoom in and zoom out to examine this dag at various levels of detail. The user can also examine a class in detail by clicking at the node labeled with the class of interest. Clicking results in the opening of a ''class information'' window that has three scrollable subwindows, one for its superclasses, the second for its subclasses, and the third for the meta data associated with this class. For example, clicking on employee shows that it has no superclass, one subclass manager, and that there are 55 objects in the employee cluster (Figure <ref type="figure" target="#fig_1">3</ref>). The class information window also has a button, clicking which shows the class definition (Figure <ref type="figure" target="#fig_2">4</ref>). The user may continue schema browsing by selecting another node in the schema graph, or may click on one of the superclasses or subclasses. For example, clicking on manager opens up another window that shows that manager is the subclass of employee as well as department, that it has no subclasses, and there are 7 instances of managers (Figure <ref type="figure" target="#fig_3">5</ref>). Browsing through the class information and relationship windows can be freely mixed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Object Browsing</head><p>Associated with each class in Ode is a set of persistent objects of that class (this set is called a cluster). The class definition window has an ''objects'' button that allows users to browse through the objects in the cluster. Clicking this button opens the ''object set'' window which consists of two parts: the control and object panels. The control panel consists of buttons reset, next, and previous to sequence through the objects. The object panel has buttons to view the object.</p><p>An Ode object can be displayed in one or more formats depending upon the semantics of the display function associated with the corresponding class. This function is provided by the class designer. The object set window supplies one button each for each of the object display formats. For example, the employee object can be displayed textually or in pictorial form; the object panel for employee provides appropriate buttons to see these displays. Figure <ref type="figure">6</ref> shows an employee object after the user has clicked the text and picture display buttons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6: Employee Object</head><p>In this example, the display state of the employee objects consists of the object being displayed in both text and picture form. OdeView remembers the display state of a cluster and will display other objects in the cluster in the same display state (until the user changes the display state, e.g., by clicking the text button to close the text display).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Browsing Complex Objects</head><p>An object may contain embedded references to other objects. The object panel of an object set window provides buttons for viewing these referenced objects. For example, employee objects refer to department objects; to view the department object associated with an employee, the user may click on the department button. This opens up an ''object'' window 1 which contains buttons to view the referenced department object (Figure <ref type="figure" target="#fig_4">7</ref>): Instead of containing a reference to a single object, an object may contain references to a set of objects. For example, the department object may contain references to all the employees that work in the department. To view employees who work in the same department, the user may click on the employees button. This opens up an ''object set'' window consisting of an object panel to view an employee object and a control panel to sequence through the employees. Figure <ref type="figure" target="#fig_5">8</ref> shows a colleague of rakesh working in the same department: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Synchronized Browsing</head><p>The basic browsing paradigm encouraged by OdeView is to start from an object and then explore the related objects in the database by following the embedded chains of references. To speed up such repetitive navigations, OdeView supports synchronized browsing <ref type="bibr" target="#b22">[22]</ref>. Once the user has displayed a network of objects and the user applies a sequencing operation to any object in this network, the sequencing operation is automatically propagated over the network.</p><p>For example, suppose a user has set up the following display to view an employee's manager by following the chain of references that start from the employee (Figure <ref type="figure" target="#fig_6">9</ref>): When the user looks at the next employee object, the user would also want to see the next employee's department and manager. In other words, we want the chain of displays starting with the employee object to be automatically updated in a ''synchronized'' fashion. OdeView does exactly this. For example, clicking the next button of the employee object-set results in the following display (Figure <ref type="figure" target="#fig_7">10</ref>): Note that we can be examining several databases and their schemas simultaneously, and within a schema we can be examining many classes and their objects simultaneously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DESIGN AND IMPLEMENTATION</head><p>We have built OdeView on top of the UNIX® operating system and using the X environment <ref type="bibr" target="#b25">[25]</ref>.</p><p>We used HP-Xwidgets to build the graphical interface.</p><p>At present, we have completed the implementation of the browsing facilities, both at schema level as well as data level. In this section, we discuss some of the interesting aspects of the OdeView implementation.</p><p>The following are the major issues that we addressed in the OdeView implementation:</p><p>• How an object should be displayed.</p><p>• How to isolate OdeView from the specifics of classes and the class designer from the specifics of the windowing software.</p><p>• How to insulate OdeView from the schema changes (addition, deletion, and modification of class definitions).</p><p>We now discuss these items in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Displaying an Object</head><p>In a relational system, having selected an object (i.e., a tuple), displaying it is rather straightforward: it is simply a matter of displaying the attribute names which are available in the catalog and the corresponding values which are of simple types. Attempting to automatically generate a display for Ode objects runs into the following problems:</p><p>1. Ode objects are not simple tuples. Their components can be of arbitrarily complex types: they can be structures, arrays, sets, etc. For some kinds of objects, it is possible to have fixed display schemes. For example, nested structures may be displayed as indented values, sets as a list of values, and so on. However, if these components represent more than just structured values, these schemes may not be adequate. For example, it will be unsatisfactory to display a circular buffer simply as a linear list of values.</p><p>2. Ode objects can contain references to other objects. When displaying an object, how should the reference be displayed? As a simple value? Or should the referenced object be displayed?</p><p>3. Ode classes support data encapsulation. The encapsulated data represents the implementation of the object, and a user sees only the public part of a class. Therefore, if one respects encapsulation then only the public data and the data made available by calling the public member functions should be displayed. But then how does one decide which member functions should be called? Simply calling all the public member functions will be unacceptable, if not potentially disastrous, because of any potential side effects.</p><p>Moreover, it may sometimes be beneficial to display the data in the private part, perhaps in a privileged mode, say for debugging. This means that it should be possible to selectively violate the encapsulation.</p><p>4. Depending upon the application, an object may be viewed differently or it may simply have multiple views. For example, a document object may be viewed in text form, in Postcript form, or as a bitmap. Thus, it should be possible to display an object in a variety of forms using one or more media.</p><p>5. Some components of an object may have embedded semantics. For example, suppose that one of the components of an object is a string that represents the name of the file containing some pictorial description of the object. Displaying the string itself will not be of much value compared to displaying the pictorial representation which may require processing of the pictorial description.</p><p>In general, it will not possible for a system such as Ode to display an object without some help from the class designer. The class designer knows best how an object is to be displayed. Consequently, we decided that it is the responsibility of class designer to provide a distinguished display function (named display) for displaying objects of the class. If the display function is not provided, then OdeView will synthesize a display function, possibly a rudimentary one. Specifying a display function is similar to specifying constructor and destructor functions of a class in C++ for initializing objects when they are allocated and performing clean up when they are deallocated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Communication Protocol</head><p>Having decided that it is the responsibility of the class designer to supply a display function, we decided to adopt the following ''principle of separation'':</p><p>The class writer should not have to know the specifics of object display (windowing) software and the display software should not have to know about object types.</p><p>To realize this separation, we have defined a interface which is understood by both OdeView and the display function. Specifically, we have defined a set of generic window types corresponding to the kind of windows that are supported by most windowing systems. Some examples of window types are: static text window, static text window with horizontal and vertical scroll bars, and raster image window. These window types may be parameterized to allow the display function to choose the window sizes and to specify the relative placement between the windows. The display function can choose any number of these window types to display an object in multiple ways.</p><p>To display an object, OdeView calls the Ode object manager to the get the stored representation of the object into an object buffer. Then OdeView calls the display function associated with the object class giving as an argument a pointer to the object buffer.</p><p>As Note that the employee object contains a reference to the department object, but the display function associated with the employee class does not contain the code for displaying the department object; the display function associated with the department object is used for this purpose.</p><p>Here is a fragment of the OdeView code for displaying an object of type clname: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Complex Objects</head><p>As mentioned in the previous section, if an object contains embedded references to other objects, then the panel for displaying objects of this type provides buttons for viewing the referenced objects. These buttons are created in windows of type OID (object id), and the corresponding object id and the display function are associated with each such window. When one of the above buttons is clicked, OdeView first calls the Ode object manager to get the corresponding object into an object buffer, and then calls the associated display function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Synchronized Browsing</head><p>When the user follows a chain of embedded references, a tree of windows is dynamically created. This tree maintains the state of each window (open or closed) and pointers to display functions for windows of type OID. When a sequencing action is performed at any node of this tree, the subtree rooted at this node is traversed recursively and data in the corresponding windows is refreshed. Note that the refreshing is done irrespective of whether window is open or closed, as the user may open a window after performing the sequencing operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Dynamic Linker</head><p>To display an object, OdeView calls the display function associated with the corresponding class.</p><p>Because OdeView is written in a compiled language, the simplest way of making the display functions of all the classes in the database available to OdeView would be to link all the display functions with OdeView. However, this approach is unacceptable, given our desire to insulate OdeView from schema and class changes because this would require recompilation of OdeView every time the database schema is changed.</p><p>The solution we used was to use dynamic linking which allows a compiled function to be linked to a load module. Every time OdeView needs to display an object, it dynamically loads the object file containing the appropriate display function (if it is not already loaded). Dynamic linking is not part of the typical compiler based C and C++ environments, but we were able to scavenge the dynamic linker used in a C interpreter <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b23">23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">OdeView Process Structure</head><p>OdeView has been implemented as a collection of UNIX processes. OdeView begins as a single process that allows a user to choose among different databases.</p><p>When the user selects a database, a ''db-interactor'' process is created that provides the interface for the user to interact with that database. This scheme allows for simultaneous interaction with multiple databases. Schema level operations such as viewing the class hierarchy as well as inspecting the class definitions are handled by the db-interactor process.</p><p>When the user wishes to examine objects of a particular class, an ''object-interactor'' process is spawned. This process dynamically loads and executes the display function defined by the class designer and also provides sequencing operations to scan all the persistent objects of that class. The reason we chose to spawn a separate process to handle requests for interacting with objects of a specific class was to isolate effects of software failures. The display function is the code written by the class designer. If there are bugs in this code, then only the corresponding object-interactor process will be affected but not the whole OdeView. Another advantage of using a separate process is that we can give the user the option of choosing where to place the window corresponding to that class (the X window system as an option allows a user to place a new UNIX process anywhere on the display). We experimented with the alternative approach of making OdeView decide where to place windows, but since it is impossible to predict the sequence of operations a user will perform, it turned out to be difficult to automatically generate good placements.</p><p>Complex objects with embedded references to other objects are displayed in a ''lazy'' manner. First only the top-level object is brought into the memory. The display method is loaded and executed by passing a pointer to the top-level object. If the object has constituent subobjects then the corresponding objects and the related display methods are loaded only if the user selects the appropriate buttons for seeing the subobjects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXTENSIONS</head><p>At present OdeView supports only schema and object browsing. We are now extending it to support projection and selection. Our design for these features is discussed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Projection</head><p>A straightforward scheme of allowing the user to project on any public member of a class will be inappropriate since the public members of a C++ class are not limited to being data elements or pure functions -they may be executable functions that do not return a value or cause side effects. We, therefore, require that a class designer provide a function, displaylist that returns as its result the list of attributes on which projection can be performed. A rudimentary displaylist display function is automatically synthesized if not explicitly provided by the class designer. Note that these attributes may or may not correspond to the data members (public or private) of the class in question. For example, an attribute to be displayed may actually be computed using other attributes.</p><p>When a user wants to see a partial view of an object, the user clicks a ''project'' button that results in a set of buttons being created, one each for the displayable attributes of the object. An ALL button is also created to allow projection on all attributes. The user selects the projection attributes by clicking on the desired attributes.</p><p>Internally, OdeView calls the displaylist function of the corresponding class, uses the list of attributes returned to create the buttons, and makes a bit vector corresponding to the attributes selected by the user. The bit positions correspond to the positions of the attributes returned by displaylist. As before, OdeView then calls the object manager to get a stored representation of the object in a buffer, and then invokes the corresponding display function.</p><p>The display function will now be required to take an additional argument. This argument is a bit vector representing the user's selection of attributes to be displayed. The display function uses the bit vector argument to determine which attributes are to be shown in the object displays created by it. If the bit vector argument is not supplied, then the display function uses a default bit vector (chosen by the class designer) to display the object. The attributes displayed by default may be a subset or superset of attributes returned by the displaylist function. Using the bit vector, the display function creates an appropriate display buffer and returns them to OdeView to display the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Selection</head><p>When viewing objects in a cluster, a user may selectively view only a subset of the objects in the cluster. In this case, the user may specify a selection predicate to select the objects to be displayed. As in the case of projection, the user must be informed as to what attributes can be used to construct the selection predicate. Our decision is to limit them to the attributes returned by the selectlist function. A rudimentary selectlist display function is automatically synthesized if not explicitly provided by the class designer.</p><p>Having displayed the list of attributes that can participate in a selection predicate, the user may use them to form the selection expression using a scheme similar to one proposed in <ref type="bibr" target="#b18">[18]</ref>. In this scheme, a predicate is formed by selecting from a menu of attribute names and operators and typing in values (or selecting values if there are only few of them). Another alternative is to use a condition box similar to QBE <ref type="bibr" target="#b35">[34]</ref> and type in the selection condition as a string. Our feeling is that the first scheme is desirable for simple selection predicates whereas the second scheme is preferable for complex predicates.</p><p>Once OdeView has obtained the selection predicate, it passes the selection predicate to the object manager which uses it to filter objects retrieved from the databases. Once an object has been selected and its memory copy is provided to OdeView, it is displayed using the implementation described earlier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Views involving more than one objects</head><p>A related issue is what should be displayed if the view involves a join of two or more objects. This is a symptom of a general view definition problem in object-oriented database systems (see <ref type="bibr" target="#b12">[12]</ref> for recent work). We have decided to display all the objects involved in the join simultaneously -each displayed using the corresponding display function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>One of the first graphical display systems for databases was the Spatial Data Mangement System <ref type="bibr" target="#b13">[13]</ref>. An early browsing-by-navigation implementation was the entity-based interface presented in <ref type="bibr" target="#b6">[6]</ref>. Several other graphical interfaces for databases have been developed since then <ref type="bibr">[3-5, 7-11, 14, 15, 18, 21, 24, 27-33]</ref>. A toolkit for designing graphics-based interfaces for object-oriented databases has been described in <ref type="bibr" target="#b16">[16]</ref>.</p><p>The design of OdeView was directly influenced by SIG <ref type="bibr" target="#b20">[20]</ref>, a system for generating displays of complex objects. In SIG, associated with a class of objects is a display type, which is composed of one or more recipes. Recipes correspond to different states of the object that are to be displayed. A recipe has a selection condition that determines if the particular recipe applies, and ingredients that specify the positions, contents, and rendering of subregions of an display. The display for an object is created by interpreting the associated display type. In OdeView, we associate display functions with a class. The effect of multiple recipes is accomplished by providing the projection capability to let the user create multiple views and letting the display function create multiple representations of an object. OdeView supports display of richer objects in that the SIG objects do not have encapsulation and methods associated with them.</p><p>An ingredient of a SIG's display type may also specify an abstract view. Specifying an abstract view defers decisions on the display of a nested subobject to the display type associated with the subobject. Otherwise, the display type of the object must include information for displaying the embedded subobject. In OdeView, embedded objects are always displayed using the display functions associated with them.</p><p>The navigation model of OdeView was inspired by the object-oriented browser, KIVIEW <ref type="bibr" target="#b22">[22]</ref>. KIVIEW was designed to interface with database models from which a semantic network may be extracted. The design of KIVIEW supports browsing of objects in a class, exploration of related objects starting from an object, and the synchronized browsing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>OdeView is designed to be a user-friendly graphical interface to Ode and is intended for users not wishing to write O++ programs. OdeView can also be used to advantage by O++ programmers who need to understand the relationship between the different classes in the database.</p><p>In building OdeView, we encountered three important issues which we feel we have addressed satisfactorily:</p><p>1. How an object should be displayed: OdeView will in general not know enough about the semantics of an object to display it properly; we therefore require each class designer to provide a display function which constructs object displays. 2. How to isolate OdeView from the specifics of classes and the class designer from the specifics of the windowing software: Isolating the two allows the class designer to write a display function that can be used by any graphical interface to Ode and it will not require the class designer to know the specifics of a particular implementation. On the other hand, OdeView will not need to know about the specifics of each class to display objects of the class. We solved</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Lab Database</figDesc><graphic coords="2,306.51,393.33,200.72,200.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Class Information Window for Employee</figDesc><graphic coords="3,86.61,165.99,198.56,62.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Class Definition</figDesc><graphic coords="3,71.29,301.69,213.67,204.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Class Information Window for Manager</figDesc><graphic coords="3,315.31,110.99,198.56,62.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Employee's Department</figDesc><graphic coords="4,71.80,156.81,202.65,81.53" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Employee's Colleague</figDesc><graphic coords="4,76.82,442.88,207.36,152.87" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Employee's Manager</figDesc><graphic coords="4,300.50,205.77,202.65,149.39" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Synchronized Display</figDesc><graphic coords="5,71.80,134.27,202.65,149.39" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>/</head><label></label><figDesc>*call object mgr to get display function loc.*/ fn_location = get_dispfn(dbname, clname); /*load the display function*/ fn = ld_dispfn(fn_location); /*get the first object in memory*/ pobj = next(dbname, clname, FIRST); /*call display function with pointer to object*/ ptr_dres = (display_resources *)(*fn)(pobj); /*create windows and display object*/ display_obj(ptr_dres); ... /*wait for interrupt for next action: X loop*/ XtMainLoop();</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The code has been modified slightly for the purposes of presentation.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We appreciate the help of Doug Blewett who helped us understand X-Windows and HP Xwidgets and gave us code he had written to implement node widgets. We are also thankful to Ted Kowalski and John Puttress for the dynamic linker, Steve North for the dag placement software, John Amanatides for the bitmap filter, and Don Mitchell for the bitmap scaling routines.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>problem by specifying a communication protocol to be used by OdeView and the display function to communicate with each other. 3. How to insulate OdeView from the schema changes: Since our environment is a compiled language, we did not want to recompile OdeView every time a schema changed. We solved this problem by using dynamic linking.</p><p>The initial reaction to OdeView has been favorable. Users have found the following features particularly attractive:</p><p>• Ability to mix schema browsing with object browsing and to do this simultaneously for more than one database. • Ability to explore the database by starting with one object and then examining related objects. • Use of synchronized browsing which speeds up exploration of the database by automatically refreshing displays of related objects when sequencing through a set of objects.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">&apos;Ode (Object Database and Environment): The Language and the Data Model</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Gehani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM-SIGMOD</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Conf. Management of Data</title>
		<meeting><address><addrLine>Portland, Oregon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-06">May-June 1989</date>
			<biblScope unit="page" from="36" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++&apos;&apos;, 2nd Int&apos;l Workshop on Database Programming Languages</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Gehani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
			<pubPlace>Portland, OR</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">SNAP: A Graphics-Based Schema Manager</title>
		<author>
			<persName><forename type="first">D</forename><surname>Byrce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 2nd Int&apos;l Conf. Data Engineering</title>
		<meeting>IEEE 2nd Int&apos;l Conf. Data Engineering<address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-02">Feb. 1986</date>
			<biblScope unit="page" from="151" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Graphical Query Formulation for an Entity-Relationship Model</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Embley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Czejdo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data and Knowledge Eng</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="89" to="121" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Query By Diagram: A Graphic Query System</title>
		<author>
			<persName><forename type="first">T</forename><surname>Catarci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Santucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int&apos;l Conf. Entity-Relationship Approach</title>
		<meeting>7th Int&apos;l Conf. Entity-Relationship Approach<address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Entity-Based Database Interface</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G G</forename><surname>Cattell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1980 Int&apos;l Conf. on Management of Data</title>
		<meeting>ACM-SIGMOD 1980 Int&apos;l Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="144" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Graphical Query Language Supporting Recursion</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Conf. on Management of Data</title>
		<meeting>ACM SIGMOD Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="16" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">GQL: A Graphical Database Language Using Pattern Images</title>
		<author>
			<persName><forename type="first">H</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Manoochehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Computer Graphics Int&apos;l Conf</title>
		<imprint>
			<date type="published" when="1988-05">May 1988</date>
			<pubPlace>Geneva</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A User-Friendly Interface for Specifying Hierarchical Queries on an ER Graph Database</title>
		<author>
			<persName><forename type="first">R</forename><surname>Elmasri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Larson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int&apos;l Conf. Entity-Relationship Approach</title>
		<meeting>4th Int&apos;l Conf. Entity-Relationship Approach<address><addrLine>Chicago</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-10">Oct. 1985</date>
			<biblScope unit="page" from="236" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Iris: An Object-Oriented Database System</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Fishman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beech</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Connors</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Derrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Hoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lyngbaek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mahbod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Neimat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Shan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Office Information Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="48" to="69" />
			<date type="published" when="1987-01">Jan. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">ISIS: Interface for a Semantic Information System</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1985 Int&apos;l Conf. on Management of Data</title>
		<meeting>ACM-SIGMOD 1985 Int&apos;l Conf. on Management of Data<address><addrLine>Austin, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-05">May 1985</date>
			<biblScope unit="page" from="328" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Object Views: Extending the Vision</title>
		<author>
			<persName><forename type="first">S</forename><surname>Heiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE 6th Int&apos;l Conf. Data Engineering</title>
		<imprint>
			<date type="published" when="1990-02">Feb. 1990</date>
			<pubPlace>Los Angeles, California</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Spatial Management of Data</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Herot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="493" to="513" />
			<date type="published" when="1980-12">Dec. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">PICASSO: A Graphical Query Language</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="169" to="203" />
			<date type="published" when="1988-03">March 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ski: A Semantics-Knowledgeable Interface</title>
		<author>
			<persName><forename type="first">R</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melville</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th Int&apos;l Conf. on Very Large Databases</title>
		<meeting>of the 10th Int&apos;l Conf. on Very Large Databases<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984-08">Aug. 1984</date>
			<biblScope unit="page" from="30" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">FaceKit: A Database Interface Design Toolkit</title>
		<author>
			<persName><forename type="first">R</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Novak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>15th Int&apos;l Conf. Very Large Data Bases<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-08">Aug. 1989</date>
			<biblScope unit="page" from="115" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Integrating Interpretive Technology into a Production Environment</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Diamantidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AT&amp;T Technical Journal</title>
		<imprint>
			<date type="published" when="1990-04">March/April 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pasta-3&apos;s Graphical Query Language: Direct Manipulation, Cooperative Queries, Full Expressive Power</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kuntz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Melchert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>15th Int&apos;l Conf. Very Large Data Bases<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-08">Aug. 1989</date>
			<biblScope unit="page" from="97" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Method for Drawing Graph&apos;&apos;, 1st Symp</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Sandberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry</title>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nordquist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Displaying Database Objects&apos;&apos;, Proc. 1st Int&apos;l Conf. Expert Database Systems</title>
		<imprint>
			<biblScope unit="page" from="15" to="30" />
			<date type="published" when="1986-04">April 1986</date>
			<pubPlace>Charleston, South Carolina</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">BAROQUE: A Browser for Relational Databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Motro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Office Information Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="164" to="181" />
			<date type="published" when="1986-04">April 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Design of KIVIEW: An Object-Oriented Browser</title>
		<author>
			<persName><forename type="first">A</forename><surname>Motro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tarantino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Int&apos;l Conf. Expert Database Systems</title>
		<meeting>2nd Int&apos;l Conf. Expert Database Systems<address><addrLine>Tysons Corner, Virginia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-04">April 1988</date>
			<biblScope unit="page" from="17" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Incremental Loading of Subroutines at Runtime&apos;&apos;, AT&amp;T Bell Laboratories Technical Memorandum</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Puttress</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Goguen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Murray Hill</publisher>
			<pubPlace>New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A Forms Application Development System</title>
		<author>
			<persName><forename type="first">L</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shoens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1979 Int&apos;l Conf. on Management of Data</title>
		<meeting>ACM-SIGMOD 1979 Int&apos;l Conf. on Management of Data<address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982-06">June 1982</date>
			<biblScope unit="page" from="28" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Scheifler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gettys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The X Window System&apos;&apos;, ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="79" to="109" />
			<date type="published" when="1986-04">April 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Direct Manipulation: A Step Beyond Programming Languages</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="57" to="69" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Timber: A Sophisticated Database Browser</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kalash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th Int&apos;l Conf. on Very Large Databases</title>
		<meeting>of the 8th Int&apos;l Conf. on Very Large Databases<address><addrLine>Mexico City, Sept</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Graphical Interfaces for Binary Relationship Data Bases</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Teskey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Holden</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984-04">April 1984</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="67" to="77" />
		</imprint>
	</monogr>
	<note>Information Sys</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Novel Technique to Interact with Relational Databases by Using Graphics Display</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Udagawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Oshuga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Information Processing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="256" to="264" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An Interactive Query Language to Define and Use Hierarchies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ursprung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Zehnder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Entity-Relationship Approach to Software Eng</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Elsevier Science Publishers B.V. (North Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">GUIDE: Graphic User Interface for Database Exploration</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K T</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th Int&apos;l Conf. on Very Large Databases</title>
		<meeting>of the 8th Int&apos;l Conf. on Very Large Databases<address><addrLine>Mexico City, Sept</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="22" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">A New Graphics User Interface for Accessing a Database&apos;&apos;, Advanced Computer Graphics</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A Graphical Query Language for Entity-Relationship</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Databases&apos;&apos;, Entity-Relationship Approach to Software Eng</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Query-By-Example: Operations on the Transitive Closure</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RC</title>
		<imprint>
			<biblScope unit="volume">5526</biblScope>
			<date type="published" when="1975">1975</date>
			<publisher>IBM, Yorktown Hts</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
