<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Genealogy of Control Structures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Henry</forename><forename type="middle">F</forename><surname>Ledgard</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Marcotty</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Massachusetts</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Computer and Information Science Department</orgName>
								<orgName type="department" key="dep2">Computer Science Department</orgName>
								<orgName type="institution">University of Massachusetts</orgName>
								<address>
									<addrLine>M. Marcotty</addrLine>
									<postCode>01002</postCode>
									<settlement>Amherst</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">General Motors Re-search Laboratories</orgName>
								<address>
									<postCode>48090</postCode>
									<settlement>Warren</settlement>
									<region>MI</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Genealogy of Control Structures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A52464E164AF811AA3AECA4CB90B56F2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>structured programming</term>
					<term>contorl structures</term>
					<term>goto statements</term>
					<term>language design</term>
					<term>PASCAL CR Categories: 4.2</term>
					<term>5.24</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The issue of program control structures has had a history of heated controversy. To put this issue on a solid footing, this paper reviews numerous theoretical results on control structures and explores their practical implications.</p><p>The classic result of Biihm and Jacopini on the theoretical completeness of if-then-else and while-do is discussed. Several recent ideas on control structures are then explored. These include a review of various other control structures, results on time/space limitations, and theorems relating the relative power of control structures under several notions of equivalence.</p><p>In conclusion, the impact of theoretical results on the practicing programmer and the importance of one-in, one-out control structures as operational abstractions are discussed. It is argued further that there is insufficient evidence to warrant more than if-then-else, while-do, and their variants.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>629</head><p>Over the last decade, computer science has suffered a loss of innocence. No longer can a programmer be a gullible optimist, convinced of a program's perfection by success with a few chosen data. A program must be seen to be correct, and clarity has become essential. One of the keys to clarity is the set of control structures used, and the debate over the choice of the set has been lively.</p><p>While it may be argued that the control structure issue has been entirely overworked, the debates and polarized opinions remain. On one side, we have the well-known views of Dijkstra <ref type="bibr" target="#b7">[7]</ref> and Mills <ref type="bibr" target="#b19">[19]</ref>, who have advocated the strict use of the if-then-else and while-do control structures and their variants. On the other side, we have the views of Knuth <ref type="bibr" target="#b13">[13]</ref>, who has recently presented interesting arguments on the utility of the goto.</p><p>Over the years, a number of theoretical results have been presented on the limitations of various control structures. Notable are the works of B6hm and Jacopini <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b19">19]</ref>, Cooper <ref type="bibr" target="#b6">[6]</ref>, Knuth and Floyd <ref type="bibr" target="#b14">[14]</ref>, Bruno and Steiglitz <ref type="bibr" target="#b5">[5]</ref>, Peterson, Kasami and Tokura <ref type="bibr" target="#b21">[21]</ref>, and importantly, Kosaraju <ref type="bibr" target="#b15">[15]</ref>. These results have placed the control structure issue on a firm foundation. In this paper we present a framework for reviewing these results and discuss their practical implications.</p><p>The programming language PASCAL <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b11">11]</ref> is used here as communication language. Unfortunately, PASCAL omits several constructs that we consider important in contemporary languages. To remedy this situation, we have made a number of extensions, as required by the examples. We believe that those extensions will pose little problem for the reader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Classes of Control Structures</head><p>This section presents various classes of control structures. Aside from minor variants, these classes embrace the control structures found in most algorithmic languages. Readers who are familiar with these control structures may need only a quick reading of this section to become conversant with the terminology given here.</p><p>(a) D-structures. We begin with the definition of "D-structures", D for Dijkstra, as in <ref type="bibr" target="#b5">[5]</ref>. A D-structure (see Figure <ref type="figure">1</ref>) is any program constructed only from the following one-in, one-out primitive structures:</p><p>(i) basic actions (e.g. assignment statements, procedure calls, input/output statements); (ii) compositions "sl;s.,." of two D-structures; (iii) conditional constructs of the form "if p then sl else s2" based on a predicate p (having no side effects) and two D-structures sl and s2 ; and (iv) loops of the form "while p do s", where p is a predicate (having no side effects) and s is a D-structure. D-structures also include conventional for loop struc-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Communications</head><p>November 1975 of Volume 18 the ACM <ref type="bibr">Number 11</ref> tures. These can be readily defined with basic actions and while-do loops. D-structures have received prominent attention in the literature. Bruno and Steiglitz <ref type="bibr" target="#b5">[5]</ref>, Ashcroft and Manna <ref type="bibr" target="#b2">[2]</ref>, and Knuth and Floyd <ref type="bibr" target="#b14">[14]</ref> have explored the reduction of arbitrarily structured programs into D-structure form. Mills <ref type="bibr" target="#b19">[19]</ref> and Dijkstra <ref type="bibr" target="#b7">[7]</ref> have explored programming with these structures, and numerous other researchers <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b25">25]</ref> have considered these structures in various ways. We next turn to some non-one-in, one-out generalizations of the previous control structures. These generalizations stem from the notions of procedure return statements, loop exits arising from exceptional conditions, and repeated loop invocations from within loops.</p><p>(c) BJ,-structures. First consider a definition of BJ,~-structures (due to B6hm and Jacopini <ref type="bibr" target="#b4">[4]</ref>), where n &gt;__ 1. A BJn-structure is composed of basic actions, compositions, if-then-else structures, and one-in, oneout control structures 9k, where k &lt; n. An ~k-structure (see Figure <ref type="figure" target="#fig_1">3</ref>) contains k successive predicates and actions with k exits, one for each of the k predicates. An ~%-structure is equivalent to the following program schema:</p><formula xml:id="formula_0">loop if Pl then exit; ,s' ~ ; if p2 then exit;</formula><p>if Pk then exit end 1t an ~tk-structure is viewed as a procedure, the exit escapes above would be analogous to pL/I-like return statements. Note that fh is a while-do structure. BJnstructures are similar to the single-level exit structures proposed by Zahn <ref type="bibr" target="#b26">[26]</ref>, Bochmann <ref type="bibr" target="#b3">[3]</ref>, and others.</p><p>(d) RE~-, RECn-, DREw-, and DRECn-structures.</p><p>Next consider the definition of RE,-structures and their variants. An RE,-structure is composed of basic actions, compositions, if-then-else structures, exit commands of the form exit(i), where i is a positive integer constant such that 1 &lt; i &lt; n, and repeat-end constructs of the form</p><formula xml:id="formula_1">repeat s2 ; Sk end</formula><p>where the si are other RE~-structures (see Figure <ref type="figure">4</ref>). On Fig. <ref type="figure">4</ref>. Repeat-exit structures.</p><p>-~ repeat end execution, the commands withip a repeat-end block are to be repeated indefinitely until an exit command is encountered. The execution of an exit(i) command causes termination of i enclosing repeat-end loops. In the case where there are fewer than i enclosing loops, all enclosing loops are terminated. REn-structures are • similar to D-structures, except that loops may be exited at arbitrary points within the loop. REn-structures have been developed from the control structures used in BLISS <ref type="bibr" target="#b25">[25]</ref>. An REC,-structure (see Figure <ref type="figure">5</ref>) is similar to an Fig. <ref type="figure">5</ref>. Repeat-exit-cycle structures.</p><p>[r [ end REn-structure, with the inclusion of additional commands of the form cycle(i). The execution of a cycle(i) command is similar to an exit(i) command, except that the ith enclosing repeat-end loop is re-executed. A DREn-structure is defined as an RE,-structure with the possible inclusion of while-do structures. The execution of an exit(i) command causes termination of the ith enclosing repeat-end loop, ignoring any enclosing 631 while-do loops. A DREC,-structure is defined as a DRE,structure with the addition of cycle(i) commands.</p><p>RE~-structures and their variants conform to conventional programs for which transfers of control can only be made to the end or beginning of an enclosing control loop.</p><p>(e) GP~-structures and L-structures. Finally, a GP,~structure is defined as any structure such that all onein, one-out substructures have at most n different predicates. An L-structure is defined as any well-formed structure, i.e. any structure with no restrictions on the number or configuration of predicates, actions, and transfers of control. An L-structure corresponds to a program with free use of labels and goto statements.</p><p>The above control structures embrace most of the explicit control structures found in conventional languages. It is important to note that these control structures do not take into account various "scope" rules often associated with these control structures. In PASCAL for example, a for-loop control variable is "local" to the for loop, and upon exit its value is undefined. Issues arising from the value of internal variables when control is transferred into or out of a control loop are not treated in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The Notions of Reducibility and Equivalence</head><p>Numerous results on the relative power of control structures are presented in this section. To present these results in a rigorous but conceptually simple framework, we first define five sets of conversion criteria for converting a control structure into another form, and then introduce the notions of "reducibility" and "equivalence" of classes of control structures under these conversion criteria. These notions are motivated by Kosaraju <ref type="bibr" target="#b15">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Conversion Criteria</head><p>In defining the various notions of conversion of a structure $1 to a structure $2, the following five properties are distinguished: P1 For every input, $2 computes the same function as $1 (i.e.S., performs the same computation as $1). P2 The primitive actions and predicates in $2 are precisely those of S1. P3 For every input, the sequence of primitive actions and predicates executed in S~ is identical to that in S~. P4 $2 can be obtained from $1 by "node splitting." (Basically, node splitting allows one to eliminate structures with multiple inputs or outputs by making multiple copies of the paths through the structures, see <ref type="bibr" target="#b21">[21]</ref>.) P5 Each occurrence of a primitive action or predicate in $1 appears at most once in S=, (i.e. multiple copies of predicates and actions in $1 are not allowed).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Communications</head><p>November 1975 of Volume 18 the ACM Number 11</p><p>The conversion criteria can now be easily stated as follows:</p><p>(a) Very strong conversion. A structure St is said to be "very strongly" convertible to a structure $2 if and only if properties P1 through P5 are satisfied.</p><p>"Very strong conversion" is indeed very strong. Basically, the only allowed rewriting rule in converting St to $2 is a reconfiguration of the existing predicates and actions in St. From a programmer's viewpoint, there is one important consideration, namely that S~ and $2 differ only in notational convenience.</p><p>(b) Node-splitting conversion. A structure St is said to be '~node-splitting" convertible to $2 if and only if properties P1 through P4 are satisfied.</p><p>Node-splitting conversion is still quite strong. Basically, $2 must be derivable from St by well-defined rewriting rules (node splitting).</p><p>(c) Path-wise conversion. A structure St is said to be "path-wise" convertible to a structure $2 if and only if properties P1 through P3 are satisfied.</p><p>Path-wise conversion is clearly not as strong as node-splitting conversion for a restructuring of the primitive actions and predicates in &amp; is allowed in $2. Nevertheless, the conversion is still strong in the sense that the computation sequence is St and $2 must still be identical.</p><p>(d) Semantic conversion. A structure S~ is said to be "semantically" convertible to $2 if and only if P1 and P2 hold.</p><p>Semantic conversion implies a significantly less restrictive condition than the above notions of conversion, for the only restriction on the conversion of St to S~ is the prohibition of "new semantics," i.e. new actions, predicates, or variables.</p><p>(e) Functional conversion. A structure S~ is said to be "functionally" convertible to $2 if and only if property P1 is satisfied.</p><p>Functional conversion is indeed weak. For the conversion of St to $2, we only require that the two structures perform the same net computation. Introduction of new predicates, actions, or variables is allowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Reducibility and Equivalence</head><p>The issue of "relative power" of various classes of control structures can now be stated precisely. Given a set of conversion criteria, a class of structures (71 is said to be:</p><p>(a) Reducible to a class C2 (notationally Ct _&lt; C2) if every structure in 6"1 can be converted to a structure in C.,, but not necessarily vice versa.</p><p>(b) Strictly reducible to a class C2 (notationally C1 &lt; C2) if every structure in Ct can be converted to a structure in Ce, but not vice versa.</p><p>(c) Equivalent to a class C2 (notationally Ct ~ C2) if every structure in 6"1 can be converted to a structure in C2 and vice versa.</p><p>Given a set of conversion criteria, reduction of Ct to C2 intuitively implies that C2 is "at least as powerful" as (71, strict reduction of 6'1 to C~ implies that 6"1 is "strictly less powerful" than C2, and equivalence implies that C1 and C~ are "equally powerful." It is important to note here that a result showing that C~ &lt; C2 is stronger if the allowed conversion criteria are weaker, and that a result showing that 6'1 = C2 is stronger if the allowed conversion criteria are stronger.</p><p>Given the notions of: (a) very strong conversion; (b) node-splitting conversion; (c) path-wise conversion; (d) semantic conversion; (e) functional conversion, we shall denote the "reduction," "strict reduction," or "equivalence" of two classes of structures by: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Results on Control Structures</head><p>This section reviews several major results on control structures and discusses their practical significance. These results fall into two main categories: 1. The classic result of Bohm and Jacopini <ref type="bibr" target="#b4">[4]</ref> on the theoretical completeness of D-structures. 2. The results of Kosaraju <ref type="bibr" target="#b15">[15]</ref>, which place all of the control structures given earlier into a hierarchy under semantic conversion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The B6hm and Jacopini Result</head><p>The result of B6hm and Jacopini on the theoretical completeness of D-structures was perhaps the first major (albeit, initially little recognized) result in structured programming. This result is well described in a paper by Mills <ref type="bibr" target="#b19">[19]</ref>. Briefly stated, the B6hm and Jacopini paper I4] makes the following points: (a) D = f L, i.e. any L-structure (including those permitting arbitrary transfer of control) can be converted to a functionally equivalent D-structure; and (b) in the functional conversion of an L-structure to a D-structure, a finite number of boolean control variables may have to be introduced, but their values may be stored in a stack, and only the value of the top (most recent) variable in the stack need be known at any given point in the program.</p><p>The importance of result (a) is that it proves that the goto statement is, at least theoretically, not needed to perform computations, and that three simple but familiar control structures: sequential composition, ifthen-else, and while-do, are in fact theoretically complete control structures.</p><p>An example of the conversion of an L-structure into a D-structure is given in Figure <ref type="figure" target="#fig_3">6</ref>. This example is based on the tree searching and insertion program of Knuth  <ref type="figure">7</ref>. A "typical" structure that is not convertible t9 a D-structure without new variables or new actions. <ref type="bibr" target="#b13">[13]</ref>. The index n e w _ i n d e x denotes the array location into which a variable n e w _ d a t a is to be inserted. The arrays left and r i g h t denote the left and right branches of a tree organization that is superimposed on an array, data. Figure <ref type="figure" target="#fig_3">6</ref>(a) depicts a program that contains two transfers of control back to the structure entry point. Figure <ref type="figure" target="#fig_3">6</ref>(b) shows a functionally equivalent D-structure. The conversion employs an intermediate boolean variable whose value is checked at the beginning of a while-do structure. Two comments are in order here. First, the D-structure of Figure <ref type="figure" target="#fig_3">6</ref>(b) is not obviously less understandable than the L-structure of Figure <ref type="figure" target="#fig_3">6</ref>(a). Second, as we shall discuss later, the L-structure of Figure <ref type="figure" target="#fig_3">6</ref>(a) can also be expressed without goto's using an R E C r control structure.</p><formula xml:id="formula_2">if data [index] &lt; new_data then if left [index] = 0 then begin left [index] := new_index v := true end else index: = left [index] else if right [index] = 0 then begin right [index] = new_index v := true end else &amp;dex := right [index]; data [index] := new_data Fig.</formula><p>The question arises: Under what conditions is a control structure semantically convertible to a Dstructure, i.e. without introducing new boolean variables or changing the particular actions and predicates of a program? The answer to this question <ref type="bibr" target="#b15">[15]</ref> lies in the detection of a loop with two or more distinct exits. In general, an L-structure is convertible to a D-structure under semantic conversion if and only if the structure does not contain a loop with two distinct exits. If a structure contains only loops with one exit, the structure is semantically convertible to a D-structure.</p><p>For example, consider the program schema of Figure <ref type="figure">7</ref>, taken from a program in Gross and Brainerd <ref type="bibr" target="#b9">[9]</ref>. This is a typical structure that cannot be converted to a D-structure without new variables or actions. Here we have a loop consisting of the sequence a3plp2a4p3a~ with two exits, one through a7 and one through a8. Note that the branch to a6 is not an exit from this loop, since the flow of control must return to a3. Similar arguments hold for the structure of Figure <ref type="figure" target="#fig_3">6(a)</ref>. 633</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Kosaraju's H i e r a r c h y of Control Structures</head><p>There have been numerous attempts to discover the limitations of D-structures as well as to explore the expressive power of other control structures. Knuth and Floyd <ref type="bibr" target="#b14">[14]</ref> have shown that D _&lt;v.~ Lp~.. Bruno and Steiglitz <ref type="bibr" target="#b5">[5]</ref>, Kosaraju <ref type="bibr" target="#b15">[15]</ref> and Peterson et al. <ref type="bibr" target="#b21">[21]</ref> have proved that D &lt; ..... L. These results point to the fact that there are indeed fully labeled programs that cannot be converted to D-structure form without changing the length, execution time, or primitives of a given program. Peterson et al. have also shown similar results for RE,,-structures, e.g. RE1 &lt;pw L, and RE3 ~ pwL.</p><p>These results fail to answer one important question: H o w do the structures given earlier relate to each other? The results of Kosaraju <ref type="bibr" target="#b15">[15]</ref> resolve this question.</p><p>The basic results of Kosaraju are outlined in An upward dashed line means that Ca &lt; ..... C2. The main results defined in Figure <ref type="figure" target="#fig_4">8</ref> are summarized as follows. Under the notion of semantic conversion:</p><p>1. For m &lt; n, there exist BJ,-structures which cannot be converted to BJm-structures. In particular, without the introduction of new predicates or actions, BJ2structures are "more powerful" than BJ~-structures, which are identical to D-structures. 2. RE~-structures are "more powerful" than BJ,~structures or D-structures. In particular, any structures allowing arbitrary one-level exits are more powerful than BJ,-or D-structures under semantic conversion.</p><p>3. We conjecture that RE,~-structures are equivalent to REC,-structures. Somewhat surprisingly, it is conjectured that the addition of the cycle(i) command does not add theoretical power to the repeat-exit control structure under semantic conversion. 4. DRE,-structures are more powerful than RE,,-structures. Again somewhat surprisingly, the addition of a while-do control ,structure does in fact add theoretical power to the RE,~-control-structure. 5. Finally, if no a priori bound is placed on the index n, any fully labeled structure is semantically convertible to an RE,-, RECn-, or DRE,~-structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>634</head><p>Other results not shown in Figure <ref type="figure" target="#fig_4">8</ref> are given in <ref type="bibr" target="#b15">[15]</ref>. Important among these is the derived result that GP,~ &lt; ..... L for any finite n. In particular, this implies that, for any finite set of restricted multilevel exit structures, there exist L charts that this set of structures cannot represent without the introduction of new actions and predicates.</p><p>As an example illustrating this hierarchy, consider the structure of Figure <ref type="figure" target="#fig_5">9</ref>(a), which is based on the control structure recently proposed by Zahn <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b13">13]</ref>. This control structure represents a program where a computation sequence is to be repeated until one of a number of "events" occurs. Upon realization of one of the events, the loop is exited. Termination of the loop then invokes a specific action determined by the event that has actually occurred. This control situation is a fairly natural one, and is quite close to a BJn-structure.</p><p>Noting that D &lt; ..... B J , , the conversion of this structure to a D-structure requires a new variable, as shown by the program in Figure <ref type="figure" target="#fig_5">9</ref>(b). On the other hand, noting that BJ~ &lt; ..... REa, this structure can be nicely converted to an REa-structure, which is given in Figure <ref type="figure" target="#fig_5">9</ref>(c).</p><p>As another example of the utility of REl-structures, consider the tree searching and insertion of the program of Figure <ref type="figure" target="#fig_3">6</ref>. This program can be readily converted to an REl-structure, as shown in Figure <ref type="figure" target="#fig_8">10</ref>.</p><p>From the programmer's viewpoint, the results above suggest that there are control situations where higherorder control structures (e.g. BJn-or RE,-structures) are preferable to D-or D'-structures in not requiring new control variables, predicates, or actions. Aside from questions of efficiency the examples also suggest that the use of stronger control structures like RE-structures and their variants may obviate the need for goto's in practice. In the next section, we address this issue and present a key example that, in fact, presents evidence counter to these suggestions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">An Example</head><p>When all is said and done, the practicing programmer is primarily interested in solving problems using the set of control structures provided by a particular language. Although theorems and results on the conversion of one form of flowchart to another may be of some practical interest in that they show the situations where the introduction of boolean variables will be required, conversion is not the basic issue. Of much greater importance is the question of naturalness of expression. That is: Can the control structures of the language under consideration form a natural expression of the algorithm needed to solve the current problem? In particular, are there problems for which D-or D'structures do not provide as clear solutions as REC,structures? In this section we present an example directed at resolving this issue. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Communications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>event</head><p>To sharpen the difference between the two sets of control structures, we have chosen a problem that would apparently be difficult for D'-structures, a requirement to cycle back to a loop entry from within a loop and the need for an escape exit nested within multiple loops. This problem, called the "qualified n a m e " problem, is to write a program segment that sets the value of a variable l e g a l -n a m e to true or false according to whether a given •L/I qualified name is a legal or illegal reference. In PL4I, one can declare "structures" with nested components, e.g. <ref type="bibr">DECLARE</ref>  To solve this problem, a number of primitives are assumed: (a) A linked list of entries called q u a l i f i e d -n a m e , which contains a separate entry for each identifier component of a qualified name. (b) A function b a s e _ e n t r y , which when applied to q u a l i f i e d _ n a m e yields the base entry in the list. F o r example, the base entry in the qualified name A . B . C is the entry for C.      Figure <ref type="figure">11</ref> (a) shows a solution to this problem using REC2-structures and an extension of the PASCAL case statement to allow for multiple case conditions. This solution is quite clear and makes liberal use of cycle and exit statements for escapes from one and two levels. To attempt a conversion of this solution to a D-or D'structure under restricted conditions is impossible without the introduction of new boolean variables. While not intrinsically bad and often making for clearer programs, in this case the additional boolean variables increase the complexity of the program.</p><p>However, by starting again from the original problem statement, it is possible to devise a new functionally equivalent solution using D'-structures. This  , requires neither new variables nor excessive copying of code, and its clarity compares very favorably with the solution using REC.,structures. Thus, the expected superiority of REC.~structures over D'-structures is not supported by the example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>There are four basic conclusions of this paper, which we will discuss separately. 1. From the programmer's viewpoint, theoretical results based on the conversion of one program form to another Under restrictive conditions may not be of practical significance.</p><p>The formal results discussed earlier suggest the limitations of D-and D'-structures. The supporting evidence rests mainly upon the impossibility of converting (under particular restrictions) abstracted program schemata with higher level control structures into equivalent schemata limited to D-or D'-structures. It is tempting to conclude that the practicing programmer would be unduly limited by languages with only D-or D'-structures. However, the practicing programmer is hardly ever concerned with converting programs from one form to another. His concern is centered on the naturalness with which a particular set of control structures can express his algorithmic solution to the problem at hand.</p><p>For the programmer, then, the acid test of the power of control structures must involve their use in the solution of specific problems typical of those met in the programming task. Of course, potential strengths and weaknesses indicated by the theoretical results will guide the choice of particular test problems. For example, the qualified name problem was originally chosen to illustrate the theoretical weakness of D-and D'structures in dealing with exit problems. To make the comparison, separate solutions to the same problem were independently programmed using the control structures under investigation.</p><p>Inevitably, the conventions of a programming language will imprint the way that the solution to a problem is expressed. Starting each solution from the original problem statement will ensure that the peculiarities of one set of control structures do not become obstacles to the clear expression of another solution using a different set. Each qualified name solution was shaped by the particular characteristics of the control structure being used. Had the solution based on the REC2-structure been mechanically con~;erted into one using D'-structures, we would have had to introduce additional complexity, as well as several new boolean variables. The result of this comparison shows how easy it is to gain the wrong impression from a consideration of the theoretical results based alone on conversion under restricted conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The need for higher level (above D or D') control structures remains unproven.</head><p>There have been many papers, e.g. <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b26">26</ref>] suggesting new control structures, higher than D and D'. The supporting evidence for these structures has mainly consisted of short fragments of programs divorced from any problem statement or comparative solutions using D-or D'-structures. These higher forms are generally techniques for implementing exits from within containing structures. In our opinion, such exits seem counter to notions of clarity. The basic function of a control structure is to provide clarity by operational abstraction. Thus the reader of a program should be able to take a level at a time without having to bother with the inner details to find the exit conditions. For this reason, the one-in, one-out structures like D and D' provide very effective abstractions.</p><p>If we consider Figure l l(a), which uses the REC~ structure, we find two exits from the outer repeat loop; one when the whole symbol table has been searched, and another from inside an inner repeat loop, when an exact match has been found. It requires searching through the bodies of the loops to find these exits, yet they should have been prominent in the programmer's mind when the algorithm was constructed. In contrast, the solution in Fig. <ref type="figure">11 (b)</ref>, where the outer loop begins while (st_entry ~ null) /k (~direct_hit) do ... makes the conditions for exit obvious from the loop heading. Although this problem was expected to demonstrate the superiority of REC2-structures over D'structures, there is no evidence that REC2 structures produce a clearer solution to the problem. In fact, as we have just seen, there are good arguments for the superior clarity of solutions using the D'-structures.</p><p>Based upon our reading of the literature and our own experiments, we believe that there is insufficient evidence of a need for these higher forms. Any such evidence should be expressed in terms of realistic problems rather than flowchart transformations. For these higher forms to be advantageous, the gain in naturalness, clarity of expression, and efficiency in solving problems must be sufficient to offset the additional complications to both the language and its compiler that their introduction would bring. The Zahn <ref type="bibr" target="#b26">[26]</ref> structure of Figure <ref type="figure" target="#fig_5">9</ref>(a), for example, does not seem to provide a sufficient gain of clarity, nor an obvious efficiency advantage to be a serious candidate for inclusion in a language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The utility of the goto is seriously questioned.</head><p>This conclusion agrees with the works of Dijkstra <ref type="bibr" target="#b7">[7]</ref>, Mills <ref type="bibr" target="#b19">[19]</ref>, and others. The recent, very comprehensive work of Knuth <ref type="bibr" target="#b13">[13]</ref> presents many opinions on the use of various control structures, particularly the goto statement. We have found no reasons for retaining the goto, and strongly believe that the arguments that Knuth advances in its favor, clarity and efficiency, are not supported by the evidence. In presenting the argument from clarity, Knuth discusses eight example problems and points out the virtues of several solutions that use the goto statement. None of these solutions seems any clearer than those that avoid the goto. Consider, for example, the programs in Figures <ref type="figure" target="#fig_3">6(a</ref>) and 6(b), which were derived from the "tree searching" examples of Knuth. The solution using the goto statement is not significantly clearer than the Dstructure version. Furthermore, changing the name of the boolean variable "v" in Figure <ref type="figure" target="#fig_3">6</ref>(b) to a more descriptive one; e.g. empty_space_found makes the debate almost vacuous. Clarity is, of course, a highly subjective quality, but we believe a thoughtful reading of Knuth's examples will support our contention.</p><p>There are two specific areas where Knuth asserts that the goto provides greater clarity, although no decisive examples are provided. The first is the frequently cited error-exit problem: "Sometimes it is necessary to exit from several l e v e l s . . , and the most graceful way to do this is a direct approach via the goto or its equivalent." <ref type="bibr">[13, p. 269</ref>] The arguments made earlier in the discussion of our second conclusion, although directed at the exit, apply mutatis mutandis to the goto.</p><p>Of the second area, Knuth writes: "There is one remaining use of goto for which I have never seen a good replacement, and in fact it's a situation where I still think goto is the right one. This situation typically occurs after a program has made a multiway branch to a rather large number of different but related cases. A little computation in one case is often sufficient to reduce it to another; and when we've reduced one problem to a simpler one, the most natural thing is for our program to goto the solution to the simpler problem." <ref type="bibr">[13, p. 290]</ref> This seems to be exactly the circumstance where the abstraction of invoking an internal procedure can be used with great clarity. Thus in place of Knuth's interpreted subtraction operation: operand := --operand; goto add; we feel that: operand : = --operand; call add; gives much greater clarity since it preserves the one-in, one-out property and the reader does not have to turn to the add section to discover what happens to the control flow. A typical example of this situation is the SYNTHESIZZ procedure of the xpL compiler <ref type="bibr" target="#b18">[18]</ref>, where internal procedures are used consistently. The usual reason given for not invoking internal procedures is one of implementation overhead. Current compiler technology allows such calls to be performed, even in PL/I, with very low overhead. In summary, we have found no instances where the goto provides any clarity above Dor D'-structures.</p><p>The argument from efficiency, that the goto allows for more efficient programs, is frequently made. For ex-638 ample, Knuth says: "Sooner or later people are going to find their beautifully structured programs are running at only half s p e e d . . . " <ref type="bibr">[13, p. 263</ref>]. He does present several example programs where a solution with goto statements is indeed more efficient than solutions with alternative control structures. However, a factor of two is never obtained, and 12 percent seems to be the maximum. While in some cases we certainly would not argue that a 12 percent gain in efficiency should be ignored, we believe that all Knuth's example programs could be equally efficient given an optimizing compiler using currently known techniques.</p><p>In particular, the technique of "constant folding" <ref type="bibr" target="#b0">[1]</ref>, where a variable that has been assigned a constant value can be used in control flow analysis to eliminate redundant code and tests (see Sites <ref type="bibr" target="#b22">[22]</ref>), can be used to advantage to yield essentially the same code as given in the version with goto statements. While no optimizing compiler can be expected to perform "macro-efficient" optimizations like the conversion of a linear search into a binary one, redundant tests and repeated actions are typical of the "micro-efficient" conditions that can be eliminated by good optimizing compilers, rare though they may be at the present time. It is this type of optimization that is the province of the compiler and not the programmer, who should be primarily interested in developing clear <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b17">17]</ref> macro-efficient programs.</p><p>There may, of course, be situations where the last micro-second must be wrung out of an algorithm. In these circumstances, the use of the goto for efficiency improvement generally entails an increase in flow'of control complexity in exchange for rather imited gains. On these occasions, one should definitely consider an escape hatch into machine language, where there is much more opportunity for improvement while still retaining the clarity of a one-in, one-out abstraction.</p><p>4. The utility of D'-structures over D-structures is supported.</p><p>Readers may have observed the liberal use of the case structure, a D'-structure, in the solution to the qualified name problem shown in Figure <ref type="figure">1</ref> l(b). As we saw earlier, one important difference between D-and D-structures is notational convenience. For example, the use of case structures can often prevent the need for nested if-then-else structures, and the use of repeat-until structures can obviate the need for somewhat artificial while-do structures. Since D'-structures preserve the important one-in, one-out property of D-structures, the notational convenience provided by D'-structures is strongly recomended.</p><p>In parting, we admit that any recommendation for a good set of control structures is indeed subjective. However, we must conclude from this examination that considerable new and definitive evidence is needed before we can agree that D-or D'-structures, with all their clarity and simplicity, are insufficient for the practicing programmer. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. Definition of D-structures. lo actions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Definition of l~k-structures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>&lt;pw and ---pw (d) _&lt; ..... &lt; ..... and ~ ..... (e) _&lt;f &lt;f and -=f</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 (</head><label>6</label><figDesc>Fig. 6(a). A control structure not reducible to a D-structure without new variable or predicates. 1. If data [index] &lt; new_data then if left [index] = 0 then left [index] := new_index else begin index := left [index]; goto 1 end else if right [index] = 0 then right [index] := new_index else begin index := right [index]; goto 1 end data [index] := new_data Fig. 6(b). Use of a new variable to reduce the control structure of Figure 6(a) to a D-structure. v :=false; while -7 v do</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Kosaraju's hierarchy of control structures. RE** REC** =-DRE,,-DREC** -GP, o-L I .-DRE n ~ DREC n 1 I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 9 (</head><label>9</label><figDesc>Fig. 9(a). The control structure proposed by Zahn.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>635</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 (</head><label>9</label><figDesc>Fig. 9(b). Zahn's control structure expressed as a D-structure (under semantic conversion).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Tree-search p r o g r a m of Figure 6 as an RE~-structure. repeat if data [iudex] &lt; new_data then if left [index] = 0 then begin left [index] : = new_index; exit (1) end else index: = left [index] else if right [b~dex] = 0 then begin right [index]: = new_index; exit (1) end else index : = right [index] end; data [index]: = new_data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. l</head><label></label><figDesc>Fig. l l(a). A solution to the Qualified N a m e P r o b l e m as an REC2-structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. l</head><label></label><figDesc>Fig. l l ( b ) . A solution to the Qualified N a m e P r o b l e m as a D 'structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>qn_entry : = base_entry (qualified_name); base_id : = name (qn_entry) ; st_entry := next (null); direct_hit : = false; hum_partial_hits : = O; while (st_entry ~ null) A (-~directJtit) do begin if name (st_entry) = base_id then begin local_qn_entry : = father (qn_entry) ; local_st_entry : = father (st_entry); skip := false; while (local_qn_entry ~ null) A (local_st_entry ~ null) do begin if name (local qn_entry) = name (local_st_entry) then local_qn_entry := father (local_qn_entry) else skip := true; local_st_entry := father (local_st_entry) end; case (Iocal_qn_entry = null, local_st_entry = null) of (t,t) : if skip = true then num_partial_hits := num_partial_hits ~ 1 else direct~it : = true; (t,f) : num_partial_Jffts : = num_partial_hits + 1 ; (f, t): {no operationl; (f,f) : {cannot occur} end {case} end {begin}; st_entry : = next (st_entry) end; if direct_hit V (num_partial_hits = 1) then legal_name : = true else legal_name : = false 636 C o m m u n i c a t i o n s N o v e m b e r 1975 of V o l u m e 18 the A C M N u m b e r 11 solution, shown in Figure ll(b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>of the symbol table in some undefined order, terminated by a null entry. (e) A function father, which when applied to a qualified name entry or symbol table entry, yields the next higher-order entry in the corresponding qualified name or symbol table, or the null entry if there is no father entry. For example, in the linked list for A.B.C, the father of the entry for C is the entry for B, and the father of the entry for A is the null entry. (f) A function name, which when applied to a qualified name component or a symbol table entry yields the identifier for that entry.</figDesc><table><row><cell>qn_entry : = base_entry (qualified_name);</cell></row><row><cell>base_M : = name (qn_entry);</cell></row><row><cell>st_entry : = null;</cell></row><row><cell>direct_Jfft : = false;</cell></row><row><cell>num_partialJtits : = 0;</cell></row><row><cell>repeat</cell></row><row><cell>repeat</cell></row><row><cell>case (Iocal_qn_entry = null,</cell></row><row><cell>local_st_entry = null) of</cell></row><row><cell>(t,t) : if skip</cell></row><row><cell>then num_partial_hits</cell></row><row><cell>: = num_partiaL_hits q-1</cell></row><row><cell>else begin</cell></row><row><cell>direct_hit : = true;</cell></row><row><cell>exit (2)</cell></row><row><cell>end;</cell></row><row><cell>(t,f): hum_partial_hits : = num_partial_hits -}-1;</cell></row><row><cell>(f,t): {no operation} ;</cell></row><row><cell>(f, f ) : begin</cell></row><row><cell>if name (local_qn_entry)</cell></row><row><cell>= name (local_st_entry)</cell></row><row><cell>then local_qn_entry</cell></row><row><cell>: = father (Iocal_qn_eutry)</cell></row><row><cell>else skip : = true;</cell></row><row><cell>local_st_entry : = father (local~t_entry);</cell></row><row><cell>cycle (1)</cell></row><row><cell>end</cell></row><row><cell>end {case};</cell></row><row><cell>cycle (2)</cell></row><row><cell>end { repeat}</cell></row><row><cell>end</cell></row><row><cell>end {case}</cell></row><row><cell>• end;</cell></row></table><note><p>st_entry : = next (st_entry); case (st_entry = null, name (st_entry) = base_id) of (t,f): exit (I); (f,f) : cycle (1); (t,t) : {cannot occur} ; ~t ) : begin Iocal_qn_entry : = father (qn_entry) ; local~t_entry : = father (st_entry); skip : = false; if direct_hit k/ (num_partial_hits = 1) then legal_name : = true else legal_name : = false provide each entry</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We are very grateful to Ran Kosaraju, whose mastery of the theoretical results in structured programming is impeccable, and to Robert Taylor, for his helpful readings of the conclusions.</p><p>Received October 1974; revised December 1974</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Work reported herein was in part supported by the U.S. Army Research Office and the National Bureau of Standards.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>A substantial portion of any programmer's time is spent in debugging. One of the major services of every compiler ought to be to provide as much information as possible about compile-time errors in order to minimize the time required for debugging. Ideally, at compile time, the compiler should discover and report all syntax errors and those semantic errors detectable at that time. At the same time, no error messages should be generated for nonexistent errors. These</p><p>Copyright © 1975, Association for Computing Machinery, Inc. General permission to republish, but not for profit, all or part of this material is granted provided that ACM's copyright notice is given and that reference is made to the publication, to its date of issue, and to the fact that reprinting privileges were granted by permission of the Association for Computing Machinery.</p><p>This research was supported in part by the National Science Foundation under grants GJ-474 and GJ-43318. A preliminary description of this work was presented at the ACM Symposium on Principles of Programming Languages <ref type="bibr" target="#b6">[6]</ref>.</p><p>Authors' addresses: Susan L. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A catalogue of optimizing transformations</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">E</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cocke</surname></persName>
		</author>
		<editor>Randall Rustin</editor>
		<imprint>
			<publisher>Compiler Optimization</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Courant Computer Science Symposium</title>
		<meeting><address><addrLine>Englewood Cliffs, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="1" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The translation of&quot;GOTO&quot; programs to</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ashcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Sci. Dep</title>
		<imprint>
			<date type="published" when="1971">1971</date>
			<publisher>Stanford U</publisher>
		</imprint>
	</monogr>
	<note type="report_type">WHILE&quot; programs. Rep. No. STAN-CS-71-188</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multiple exits from a loop without the GOTO</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Bochmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="443" to="444" />
			<date type="published" when="1973-07">July, 1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Flow diagrams, Turing machines and languages with only two formation rules</title>
		<author>
			<persName><forename type="first">C</forename><surname>B6hm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Jacopini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="366" to="371" />
			<date type="published" when="1966-05">May 1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The expression of algorithms by charts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Steiglitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="517" to="525" />
			<date type="published" when="1972-07">July 1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Some transformations and standard tbrms of graphs with applications to computer programs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Cooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence 2. American</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Dale</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1968">1968</date>
			<biblScope unit="page" from="21" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Notes on structured programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<editor>Structured Programming. W.J. Dahl, E.W. Dijkstra, and C.A.H. Hoare</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Academic Press</publisher>
			<biblScope unit="page" from="1" to="82" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A case for the while-until</title>
		<author>
			<persName><forename type="first">D</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Notices (ACM newsletter)</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="7" to="14" />
			<date type="published" when="1974-07">July 1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Fundamental Programming Concepts</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Brainerd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Harper and Row</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An experiment in structured programming</title>
		<author>
			<persName><forename type="first">P</forename><surname>Henderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Snowdon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BIT</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="38" to="53" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An axiomatic definition ~f the programming language PASCAL</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A H</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta blformatica</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="335" to="355" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernigham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Plauger</surname></persName>
		</author>
		<title level="m">The Elements of Programming Style</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>McGraw-Hill</publisher>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Structured programming with GOTO statements</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="261" to="301" />
			<date type="published" when="1974-12">Dec. 1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Notes on avoiding GO TO statements</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Sci. Dep. Stanford U</title>
		<imprint>
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
	<note type="report_type">Rep. No. CS-148</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Analysis of structured programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kosaraju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. and Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="232" to="255" />
			<date type="published" when="1972">Dec. 1974. 1972</date>
			<publisher>Johns Hopkins U</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. No. 72-11</note>
	<note>Elect. Eng. Dep.</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Programming with(out) me GOTO</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Leavenworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Nat. Conf</title>
		<imprint>
			<biblScope unit="page" from="782" to="786" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Programming Proverbs</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Ledgard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>Hayden Publishing Co</publisher>
			<pubPlace>Rochelle Park, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Mckeeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Horning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Wortman</surname></persName>
		</author>
		<author>
			<persName><surname>Compiler Generator</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1970">1970</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Mathematical foundations for structured programming. FSC 72-6012 Federal System Division</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Mills</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>IBM Corp</publisher>
			<pubPlace>Gaithersburg, Md</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On program control structure</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Neely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Nat. Conf. 1973</title>
		<meeting>ACM Nat. Conf. 1973</meeting>
		<imprint>
			<biblScope unit="page" from="119" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the capabilities of while, repeat, and exit statements</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kasami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tokura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="503" to="512" />
			<date type="published" when="1973-08">Aug. 1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Proving tbat computer programs terminate cleanly</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Sites</surname></persName>
		</author>
		<idno>Rep. No. STAN-CS-74-418</idno>
	</analytic>
	<monogr>
		<title level="j">Comput. Sci. Dep., Stanford U</title>
		<imprint>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The programming language PASCAL. Revised report</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<pubPlace>Zurich</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Eidgenoessische Technische Hochschule</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Program development by stepwise refinement</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="221" to="227" />
			<date type="published" when="1971-04">Apr. 1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">BLISS: A language for systems programming</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Wulf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Habermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="780" to="790" />
			<date type="published" when="1971-12">Dec. 1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A conlrol statement for natural top-down structured programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Zahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sym!b. on Ping. Lang</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Programming</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Languages</forename><surname>Wegbreit</surname></persName>
		</editor>
		<editor>
			<persName><surname>Editor</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1974">1974</date>
			<pubPlace>Paris</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
