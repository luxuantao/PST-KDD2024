<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Reversible Data Hiding Scheme Based on Code Division Multiplexing 1</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bin</forename><surname>Ma</surname></persName>
						</author>
						<author role="corresp">
							<persName><roleName>Fellow, IEEE D</roleName><forename type="first">Yun</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
							<email>shi@njit.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science</orgName>
								<orgName type="institution">Qilu University of Technology</orgName>
								<address>
									<postCode>250014</postCode>
									<settlement>Jinan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">New Jersey Institute of Technology</orgName>
								<address>
									<postCode>07102</postCode>
									<settlement>Newark</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Reversible Data Hiding Scheme Based on Code Division Multiplexing 1</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9F471452FC8398DF6F2B9967A15C74B1</idno>
					<idno type="DOI">10.1109/TIFS.2016.2566261</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2566261, IEEE Transactions on Information Forensics and Security</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Code division multiplexing (CDM)</term>
					<term>embedding capacity</term>
					<term>reversible data hiding (RDH)</term>
					<term>prediction-error</term>
					<term>location-map free</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, a novel code division multiplexing (CDM) algorithm based reversible data hiding (RDH) scheme is presented. The covert data are denoted by different orthogonal spreading sequences and embedded into the cover image. The original image can be completely recovered after the data have been extracted exactly. The Walsh Hadamard matrix is employed to generate orthogonal spreading sequences, by which the data can be overlappingly embedded without interfering each other, and multilevel data embedding can be utilized to enlarge the embedding capacity. Furthermore, most elements of different spreading sequences are mutually cancelled when they are overlappingly embedded, which maintains the image in good quality even with a high embedding payload. A location-map free method is presented in the paper to save more space for data embedding, and the overflow/underflow problem is solved by shrinking the distribution of the image histogram on both ends. This would further improve the embedding performance. Experimental results have demonstrated that the CDM-based RDH scheme can achieve best performance at the moderate-to-high embedding capacity compared with other state-of-the-art schemes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>embedding capacity. Many RDH schemes have been proposed in recent years. They can be roughly classified into two categories: schemes performed in spatial domain and those in transform domain.</p><p>Since the earliest RDH scheme was presented in Barton's patent <ref type="bibr" target="#b0">[1]</ref>, many RDH schemes have been reported in the literature. In the spatial domain, three major approaches have been developed for image RDH. They are RDH based on lossless compression, on histogram modification and on difference expansion (or prediction-error expansion). The lossless compression based approach substitutes part of host image information with the to-be-embedded data and the compressed codes of the substituted part. Fridrich et al. <ref type="bibr" target="#b1">[2]</ref> provided an invertible image authentication method by embedding a hash into the image. By losslessly compressing the lowest bit-plane of the image (or its feature), they could make enough space to insert the image of a hash. Celik et al. <ref type="bibr" target="#b2">[3]</ref> improved Fridrich et al.'s approach by employing the lossless image compression algorithm CALIC (context-based, adaptive, lossless image code) for lossless image compression and achieved higher embedding capacity. Kalker and Willems <ref type="bibr" target="#b3">[4]</ref> derived theoretical capacity bounds for image RDH and proposed the recursive code construction to achieve high data hiding performance. Zhang et al. <ref type="bibr" target="#b4">[5]</ref> embedded the data by recursively utilizing the decompression and compression processes of an entropy code, and proved that the rate-distortion bound of RDH can be approached as long as perfect compression is realized. However, in order to keep imperceptibility of the marked image, the substituted parts generally locate in the least significant bits and it can only provide a limited compression ratio. Thus, the lossless compression based RDH schemes usually provide limited embedding capacity.</p><p>Introduced by Tian <ref type="bibr" target="#b5">[6]</ref>, difference expansion is a very fruitful RDH research field, which expands the difference of a pixel-pair two times, if no overflow or underflow appears, one bit can be added to the expanded difference (the maximum achievable embedding rate is 0.5 bit/pixel). The embeddable pixel-pair is identified by using a location map with one bit for each pair of pixels. Since the location map size is the same as the embedding capacity, its performance is partially decided by the compression efficiency of the location map. Alattar <ref type="bibr" target="#b6">[7]</ref> developed an efficient algorithm to hide several bits into the expansion of the difference between adjacent pixels in a vector, by which they can still hide certain data even though the location map is not compressed. The scheme expands one cell from a pair to a triple, or a quad, to hide more bits per cell in experiments. Simulation results have shown that they can embed larger payload than Tian's at the same image distortion (the maximum achievable embedding rate is 0.67 bit/pixel for triple and 0.75 bit/pixel for quad). Kamstra and Heijmans <ref type="bibr" target="#b7">[8]</ref> presented an alternative method to solve the capacity control problem in Tian's method. The main idea of this technique is sorting pixel pairs according to correlation measures, which can automatically create just enough capacity to embed the desired payload and keep the distortion minimal. Kim et al. <ref type="bibr" target="#b8">[9]</ref> presented a difference expansion method with a simplified location-map and achieved high embedding capacity while keeping the distortion at a low level. The location map only records the ambiguous pixels between expandable and un-expandable parts, and the size is reduced considerably. Its performance is proved to be better than the schemes proposed by Tian and its improved version provided by Kamastra and Heijmans. Thodi and Rodriguez <ref type="bibr" target="#b9">[10]</ref> proposed a histogram shifting technique as an alternative to embedding the location map, which improves the distortion performance at low embedding capacities and mitigates the capacity control problem. They also introduced the prediction-error expansion method which exploits the correlations inherent in the neighborhood of pixels better than Tian's difference expansion scheme. Prediction-error expansion and histogram shifting are combined to form an effective method for RDH. Generally, the prediction-error histogram is Laplacian-like and distributed around zero sharply. Therefore, the better the predictor is, the smaller the prediction-error is, and the higher the embedding capacity would be achieved at low distortion. From then on, many error-prediction algorithms such as the median edge detector (MED) predictor <ref type="bibr" target="#b10">[11]</ref>, the gradient adjusted predictor (GAP) <ref type="bibr" target="#b11">[12]</ref>, simple gradient adjusted predictor (SGAP) <ref type="bibr" target="#b12">[13]</ref> and rhombus-error predictor <ref type="bibr" target="#b13">[14]</ref> <ref type="bibr" target="#b14">[15]</ref> are proposed aiming to provide smaller prediction-errors. Sachnev et al. <ref type="bibr" target="#b14">[15]</ref> employed a rhombus-error predictor to achieve smaller prediction-errors, and a sorting technique is employed to record the prediction-errors based on the magnitude of its local variance. Using sorted prediction-errors and a reduced size location map, they embed more data into the image with less distortion. Chen et al. <ref type="bibr" target="#b15">[16]</ref> investigated the selection of a "model order" for RDH through theoretical analysis and experimental examination. They have demonstrated that the full context predictor can achieve highly fitted modeling at a low order. It is capable of providing better performance than most popular prediction algorithms and need only negligible computing. Li et al. <ref type="bibr" target="#b16">[17]</ref> presented an efficient RDH scheme based on the adaptive pixel selection and the prediction-error expansion techniques, 1 or 2 bits are adaptively embedded into expandable pixels according to local complexity. This doing avoids expanding pixels with large prediction-errors and decreases the pixel value modification. Thus, the embedding capacity is improved and the image quality is well retained. Han et al. <ref type="bibr" target="#b17">[18]</ref> designed a reversible image authentication method that does not memorize the parameters for extracting the embedded authentication data from an image. The hidden data can be extracted without memorization of parameters used in the algorithm. Fujiyoshi et al. <ref type="bibr" target="#b18">[19]</ref> introduced a parameter memorization-free lossless data hiding method accepting various sized payload. The method hides data into consecutive pixel blocks in an ascending order of their roughness, so that it does not need to remember the embedded blocks in the decoding stage. Moreover, the method is free from fixing the payload size. Zhang <ref type="bibr" target="#b19">[20]</ref> established an optimal rule of value modification under a payload-distortion criterion by using an iterative procedure. The estimation errors are modified according to the optimal value transfer rule; the host image is divided into some pixel subsets, and the auxiliary information of a subset is always embedded into the next subset, by which a high-performance practical RDH scheme is achieved. Coltuc <ref type="bibr" target="#b20">[21]</ref> embedded the bits not only into the current pixel, but also into its prediction context simultaneously, which would minimize the mean square errors (MSE) and thus introduced less distortion to the cover image. Dragoi et al. <ref type="bibr" target="#b21">[22]</ref> adopted a local prediction technique in difference-expansion based RDH scheme. The least square predictor is computed on a square block, and the corresponding prediction-error is expanded for data embedding. It can be applied regardless of the prediction order or the prediction context and achieve advanced performance.</p><p>Histogram modification is another popular approach to RDH, in which the prominent histogram bins are selected and the spaces are created into its adjacent bins for data embedding by shifting other histogram bins certain positions. Ni et al. <ref type="bibr">[23][24]</ref> first proposed the RDH scheme using histogram bins of the cover image for data embedding. The peak and the minimum points of the histogram of an image are utilized for data embedding. It changes the pixel value at most by 1 during one-time data embedding, and thus keeping the marked image in good visual quality. However, this method does not work well if the cover image has a "flat" histogram. Lee et al. <ref type="bibr" target="#b24">[25]</ref> utilized histogram of the difference image and modified pixel values slightly to achieve more embedding capacity than Ni et al.'s method. Hong <ref type="bibr" target="#b25">[26]</ref> proposed an adaptive method to increase the number of embeddable spaces by referencing a dual binary tree. This scheme significantly improved the performance especially at a low embedding capacity. Yang et al. <ref type="bibr" target="#b26">[27]</ref> developed an interleaving prediction method that enables the number of prediction-errors to be as many as the number of pixels. All predictive error values are transformed into the histogram to create higher peak values and to improve the embedding capacity. Xuan et al.'s <ref type="bibr" target="#b27">[28]</ref> reversibly embedded data into image prediction-errors by using histogram-pairs with four thresholds for optimal performance. A fluctuation threshold is utilized to choose prediction-errors whose associated neighboring fluctuation is below the threshold to reduce image distortion. Li et al. <ref type="bibr" target="#b28">[29]</ref> presented a general framework to construct the histogram modification-based RDH scheme, and introduced two novel and efficient RDH algorithms to further demonstrate the universality and applicability of the framework. Coatrieux et al. <ref type="bibr" target="#b29">[30]</ref> designed an efficient histogram modulation method which takes care of the local specificities of the image content. They make use of a classification process to enable parts of the image embedded with the most suited reversible modulations, by which the data can be inserted in rough regions where other methods fail to do so.</p><p>Besides the aforementioned schemes, many scientists have studied RDH techniques in transform domain to enhance its security and robustness. Xuan et al. <ref type="bibr" target="#b30">[31]</ref> embedded data into the coefficients of high frequency sub bands of the integer wavelet domain, and adopted compression and expansion T-IFS-05576-2015 3 functions to embed data into the image to achieve high performance in terms of embedding capacity and visual quality. Yang et al. <ref type="bibr" target="#b31">[32]</ref> takes advantage of the character of integer discrete cosine transform (DCT) coefficients' Laplacian-like distribution to embed data in coefficients of different frequencies. Zou et al. <ref type="bibr" target="#b32">[33]</ref> presented a semi-fragile lossless digital watermarking scheme based on 5/3 integer wavelet domain. The hidden message can be retrieved even after incidental alternations or image compression. Lee et al. <ref type="bibr" target="#b33">[34]</ref> divided the cover image into non-overlapping blocks and adaptively embedded covert data into the high-frequency wavelet coefficients of each block, the bit-shiftable blocks in which the data can be embedded with less distortion are found and are utilized for data hiding to minimize the distortion between the marked and the original image. An et al. <ref type="bibr" target="#b34">[35]</ref> introduced a pragmatic framework of wavelet-domain statistical quantity histogram shifting and clustering (WSQH-SC) to enhance RDH robustness and reduce its computing complexity.</p><p>Although RDH has made considerable improvement in recent years, the embedding algorithms are growing more complicated and the computational costs are increasing sharply, in most cases, the image quality degrades rapidly as the payload increases. In this paper, a novel RDH scheme based on CDM algorithm is proposed. The to-be-embedded data are denoted by different orthogonal spreading sequences and embedded into the cover image; the original image can be completely reconstructed after the hidden data have been extracted out exactly. The Walsh Hadamard matrix is adopted to generate orthogonal spreading sequences, by which the data can be overlappingly embedded without interfering each other, and multilevel data embedding can be utilized to enlarge the embedding capacity. Most elements of different spreading sequences are mutually cancelled when they are overlappingly embedded, which maintains image distortion at a lower level even with a high embedding payload. Furthermore, the location map is not needed to identify the embedded locations in this scheme because some pseudo bits are embedded, and they will be dropped during the data extraction. The overflow/underflow problem is solved by shrinking the image histogram distribution from both ends. These would further enhance the embedding performance. Experimental results have demonstrated that the proposed scheme outperforms most existing RDH schemes at the moderate-to-high embedding capacity.</p><p>The rest of this paper is organized as follows. In section II, the principle of CDM-based communication system is introduced. Section III provides a CDM-Based RDH scheme. In Section IV, a location map free method is presented to increase the embedding capacity; the overflow/underflow problem is also solved practically. The implementation of the proposed scheme is provided in Section V. Section VI demonstrates the experimental results. Some discussions are given in section VII. Finally, the conclusion is drawn in section VIII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. CDM-BASED COMMUNICATION SYSTEM</head><p>CDM is a kind of spectrum spreading technique widely used in communication system for secure information transmission and channel multiplexing <ref type="bibr" target="#b35">[36]</ref>. In a CDM-based communication system, the sender is assigned with a predetermined spreading sequence to encode the secret digital signals for transmitting. Only the receiver who knows the same sequence can correctly decode and extract the secret signals.</p><p>The spreading sequence plays an important role in a CDM-based communication system. Generally, the Walsh Hadamard matrix is employed to derive the spreading sequences. It is consists of "1" or "-1", and every two rows or columns are orthogonal to each other. Since the number of "1" and "-1" is equal in each row or column, the sequence created by the row or column of Walsh Hardmard matrix is zero mean and orthogonal to each other. Suppose = is a row or a column from Walsh Hadamard matrix, it thus satisfies</p><formula xml:id="formula_0">{ } 1 1,1 , 0 m g g σ σ σ = ∈ - = ∑<label>(1)</label></formula><p>The cross-correlation of any two different sequences is ( )</p><formula xml:id="formula_1">, 0 T r t r t</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S S S S r t = ⋅ = ≠</head><p>(2) Each user is assigned a binary spreading sequence in a CDM-based communication system; bit "1" is denoted by the sequence itself, and bit "0" is represented by the negative corresponding sequence. Only the receiver, who has the same spreading sequence as the sender, can obtain the correct signals.</p><p>For example, suppose the two spreading sequences from a 4-level Hadamard matrix are 1 (1, 1,1, 1)  S = --and 2 (</p><p>S = --. Clearly, S 1 and S 2 are zero mean and orthogonal to each other. Two binary bits "1" and "0" are represented by S 1 and -S 2 , respectively; the two spreading sequences are added and transmitted together in a CDM-based communication system. On the sender side, the compound signal is ( ) ( )</p><formula xml:id="formula_3">1 2 1 2 0, 0, 2, 2 S S S S S = + -= -=</formula><p>-. On the receiver side, for the receiver with the spreading sequence S 1 , the decoding result is The reversible data hiding process has great similarity with a communication system, where the digital signals are transmitted through public transmission channels to receivers who can reconstruct it completely (the covert data as the digital signals and the cover image as the public transmission channel).</p><p>Inspired by the CDM-based communication system <ref type="bibr" target="#b35">[36]</ref>, we present a CDM-based RDH scheme in this section, which satisfies high embedding capacity, high visual quality, and low computing complexity. After data embedding is discussed, data extraction and image reconstruction are presented; and then multilevel data embedding are explained in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Data Embedding</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Suppose</head><formula xml:id="formula_4">[ ] { } { } ( )<label>1 2</label></formula><p>, , , 1, 0 , 1, 2,...,</p><formula xml:id="formula_5">o n z W z n ω ω ω ω = ⋅⋅⋅⋅⋅ ∈ ∈</formula><p>is the primitive data to be embedded, whose elements are changed to antipodal bits with the following formula</p><formula xml:id="formula_6">1 1; 1 0; z e z if b if ω ω =  =  - =  (3) The modified data is 1 2 [ , , , ] c n W b b b = ⋅⋅⋅⋅⋅ , where { } { } 1,1 , 1, 2,..., e b e n ∈ - ∈ . Choose k mutually orthogonal sequences { } { } ( )<label>1 2</label></formula><p>, , 1, 2,...,</p><formula xml:id="formula_7">i l q q q S i k = ⋅⋅⋅⋅⋅ ∈</formula><p>from a specified Walsh Hadmard matrix. The sequence length l is an even number, and the number of "1" and "-1" in each sequence is equal, which implies that the spreading sequences are zero mean and orthogonal to each other. Let I be the original image with the size of N N × . Select adjacent pixels from the image to form the vector</p><formula xml:id="formula_8">[ ]<label>1 2</label></formula><p>, , ,</p><formula xml:id="formula_9">j l p p p V = ⋅⋅⋅⋅⋅</formula><p>, whose length l is the same as that of i S . The bits can be embedded as</p><formula xml:id="formula_10">1 1 2 2 [ ] j j k k V V b S b S b S α = + + + ⋅⋅⋅ +  (4)</formula><p>where k is the number of to-be-embedded bits, α is the gain factor, which is a positive integer controlling the embedding intensity. The bigger the α value is, the stronger the embedding is, and the noisier the image would be. The marked image is achieved by replacing all j V vectors with j V  .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Data Extraction and Image Recovery</head><p>Let I  be the marked image. Build j V  with the same method as the embedding stage. The j-th embedded data bit can be extracted by calculating the cross correlation between the marked vector j V  and the spreading sequence i S as</p><formula xml:id="formula_11">1 1 2 2 , T T T T T j i j i j i i i k k i V S V S V S bS S b S S b S S α   = ⋅ = ⋅ + ⋅ + ⋅ +⋅⋅⋅+ ⋅    <label>(5)</label></formula><p>Since the spreading sequences are mutually orthogonal, Eq. ( <ref type="formula" target="#formula_11">5</ref>) can be simplified as</p><formula xml:id="formula_12">, T T j i j i e i i V S V S b S S α = ⋅ + ⋅  (6)</formula><p>where the value of e b is "1" or "-1", α is a positive integer and</p><formula xml:id="formula_13">T i i S S ⋅</formula><p>is always positive, the sign of expression</p><formula xml:id="formula_14">T e i i b S S α ⋅ is determined by e b . Therefore, under the condition of &lt; T T j i i i V S S S α ⋅ ⋅ , if 1, e b = we have 0 T T e i i j i b S S V S α ⋅ &gt; ⋅ &gt; , thus , 0 T T j i j i e i i V S V S b S S α = ⋅ + ⋅ &gt;  ; On the other hand, if 1, e b = -we have 0 T T e i i j i b S S V S α ⋅ &lt; -⋅ &lt; , there must be , 0 T T j i j i e i i V S V S b S S α = ⋅ + ⋅ &lt;  . The sign of , j i V S </formula><p>is the same as the sign of e b . Since the value of e b is "1" or "-1", the embedded bit e b can be obtained by the function of ( , )</p><formula xml:id="formula_15">j i sign V S  in this condition. Whenever the condition &lt; T T j i i i V S S S α ⋅ ⋅</formula><p>is satisfied, the embedded bit e b can be extracted correctly according to</p><formula xml:id="formula_16">( , ) ( &lt; ) T T e j i j i i i b sign V S if V S S S α = ⋅ ⋅  (7)</formula><p>Furthermore, at the decoding stage, for the usable vectors, Eq. ( <ref type="formula" target="#formula_30">6</ref>) satisfies , 2</p><formula xml:id="formula_17">T T T j i j i e i i i i V S V S b S S S S α α = ⋅ + ⋅ &lt; ⋅  (8)</formula><p>Then, if the Eq. ( <ref type="formula">8</ref>) is satisfied at the receiver side, the embedded bit can be extracted by the function of ( , )</p><formula xml:id="formula_18">j i sign V S  .</formula><p>Since i S is a zero-mean spreading sequence, the expression</p><formula xml:id="formula_19">T j i V S ⋅</formula><p>is equal to sum the differences of all pixel-pairs in vector j V . The value of</p><formula xml:id="formula_20">T j i V S</formula><p>⋅ would be small if the elements of j V are similar. Considering the redundancy existing in natural image content, the neighboring pixels are quite similar especially in smooth (low-frequency) areas, the product of</p><formula xml:id="formula_21">T j i V S ⋅</formula><p>is usually very small in practice. Thus the bits can be embedded into the image in most cases. In addition, with the increase of α , the value of</p><formula xml:id="formula_22">T i i S S</formula><p>α ⋅ grows rapidly. More pixels would be involved to form the vectors j V that suitable for data embedding, and thus the embedding capacity is enlarged.</p><p>After the extraction of embedded data from the marked image, the original image can be restored with all j V  replaced by j V as</p><formula xml:id="formula_23">[ ] 1 1 2 2 j j k k V V b S b S b S α = - + + ⋅⋅⋅ +  (9)</formula><p>To well explain the idea of our proposed scheme, we choose the first 2×2 pixels in the top-left corner of 512×512 grayscale image Lena to form the vector 1 [165,165,166,166]</p><formula xml:id="formula_24">V = ; let 1 [1, 1,1, 1] S = --, 1 α =</formula><p>, and the to-be-embedded data bit 1 1 b = . The vector after data embedding is 1 1</p><formula xml:id="formula_25">1 1 [166,164,167,165] V V b S α = + =  . At the receiver side, we have<label>1 1 , (166,164,167,165) (1, 1,1, 1) 4 T</label></formula><formula xml:id="formula_26">V S = ⋅ -- =  and 1 1 2 2 (1, 1,1, 1)(1, 1,1, 1) 8 T T S S α ⋅ = -- -- = , the condition 1 1 1 1 , 2 T V S S S α &lt; ⋅ </formula><p>is satisfied. Thus, the embedded bit and the original vector can be recovered according to the equations of</p><formula xml:id="formula_27">1 1 1 , =sign(4)=1 b sign V S =  and 1 1 1 1 [165,165,166,166] V V b S α = - =  .</formula><p>Similarly, in the light of Eq. ( <ref type="formula">7</ref>), all the vectors in the original image satisfy 4</p><formula xml:id="formula_28">T j i V S ⋅ &lt; (i.e., 0<label>, 1, 2, 3 T j i</label></formula><p>V S ⋅ = ± ± ± ) hence are suitable for RDH in this example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Multilevel Data Embedding</head><p>RDH aims to embed covert data into an image while only slightly degrade its quality. Since the embedded data and the cover image can be restored completely from the marked image, multilevel data embedding is feasible. Furthermore, as the spreading sequences are mutually orthogonal, the cross-correlation of any two different spreading sequences is 0; the spreading sequences can be overlappingly embedded without interfering each other.</p><p>For example, regarding the example we just presented above, we can embed another bit into the marked vector 1 V  . Suppose the second to-be-embedded bit is 0 (then, [165,163,168,166]</p><formula xml:id="formula_29">V V b S α = + =   </formula><p>after double data embedding. At the decoding side, the embedded bits and the original vector can be restored according to the following equations (as shown in Table <ref type="table">I</ref>): </p><p>[166,164,167,165]</p><formula xml:id="formula_31">T T T V S S S V S V S S S thus b sign V S sign V V b S α α ω α = --= - ⋅ = ∴ ⋅ = &lt; ⋅ = = -= - = = - =            1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 , (166,164,167,165)(1, 1,1, 1) 4;<label>2 8; , 2 , ( , ) (4) 1; 1;</label></formula><p>[165,165,166,166]</p><formula xml:id="formula_32">T T T T V S S S V S V S S S thus b sign V S sign V V b S α α ω α = -- = ⋅ = ∴ ⋅ = &lt; ⋅ = = = = = - =     </formula><p>In this process, only the second and the third element of the marked vector 1 V   changed by 2 in value; other elements of the marked vector 1 V   are the same as the original vector. The first and the forth element of two embedded spreading sequences are mutually cancelled after two times data embedding. Actually, as most elements of different spreading sequences are mutually cancelled in multilevel data embedding, it enables the proposed scheme to achieve high embedding capacity while restraining distortion to a low level.</p><p>Here, we study the capability of the elements to mutually cancel each other in the case of different spreading sequences that are overlappingly embedded. The gain factor α is predefined as 1. Suppose the spreading sequence is</p><formula xml:id="formula_33">1 [1, 1,1, 1]</formula><p>S = --and the to-be-embedded bit is "1" (i.e. 1 1 b = ) at first, each pixel of vector j V is changed by 1 in grayscale value after the first time of embedding, and we denoted the vector after first embedding as j V  . In the second time of embedding, the bit to-be-embedded maybe "0" or "1", and the statistical probability is 50%, respectively. We define the spreading sequence</p><formula xml:id="formula_34">2 [1,1, 1, 1] S = --</formula><p>, if the to-be-embedded bit is</p><formula xml:id="formula_35">"0" (i.e. 2 1 b = -), then, 2 2 [ 1, 1,1,1] b S α = --</formula><p>would be added to the modified vector j V  , the final change of the elements in</p><formula xml:id="formula_36">j V is 1 1 2 2 [0, 2, 2, 0] b S b S α α + = - . If the to-be-embedded bit is "1" (i.e. 2 1 b = ), 2 2 [1,1, 1, 1] b S α = --</formula><p>will be added to the modified vector j V  . The final change of the elements in j V would be 1 1</p><formula xml:id="formula_37">2 2 [2, 0, 0, 2] b S b S α α + =</formula><p>-. Thus, considering the occurrence probability of the to-be-embedded bits "1" and "0", the probable mean square error (PMSE) can be computed as</p><formula xml:id="formula_38">2 2 2 2 2 ( 2) ( 2) 2 (( ) ( )) / 2 2 4 4 PMSE + - -+ = + = .</formula><p>Similarly, we can obtain the PMSE after third time embedding is 3 PMSE = , and so on. The value of PMSE equals the number of embedding levels. The detailed results are listed in Table <ref type="table">II</ref>. Further investigations demonstrate that the value of PMSE is also the same as the embedding levels when the length of spreading sequence is 2, 8, 16 and so on. As most elements of different spreading sequence are mutually cancelled in multilevel data embedding, the image quality drops slowly when the payload increases.</p><p>Generally, the maximum modification to each pixel is 1 on its grayscale value for single embedding; the PSNR of a marked image is about 48.13dB after the first level embedding (MSE is 1) and 45.12dB after the second level embedding (MSE is 2). Since no degradation is noticeable to the human eyes if the PSNR value above 36dB, the proposed scheme has excellent imperceptibility until the MSE reaches 16 (the PSNR is 36.08dB). That is, the cover image can be overlappingly embedded for 16 times while still maintaining acceptable visual quality (if 1 α = ). On the other hand, as the embedded bit is denoted by a spreading sequence as discussed before, say 1 S or 2 S , in the proposed scheme, there are " " l (l is the length of spreading sequence) pixels would be changed for every bit embedding. Thus, the maximum achievable embedding capacity is 0.5 bpp for one-time data embedding even if the spreading sequence length is 2 (i.e., 2 l = ). The maximum achievable embedding capacity would be 0.5 n × bpp in multilevel data embedding (n is the number of levels of data embedding). In practice, the capacity of each embedding decreases gradually as the redundancy of the marked image becomes less and less in multilevel data embedding. </p><formula xml:id="formula_39">e b = ) [1,-1,1,-1] [1,-1,1,-1] 1( 1 e b = ) [1,1,-1,-1] [2,0,0,-2] 1( 1 e b = ) [1,-1,-1,1] [3,-1,-1,-1] 0( 1 e b = -) [-1,1,1,-1] [1,1,1-3] 0( 1 e b = -) [-1,-1,1,1] [0,-2,2,0] 1( 1 e b = ) [1,-1,-1,1] [1,-3,1,1] 0( 1 e b = -) [-1,1,1,-1] [-1,-1,3,-1] 0( 1 e b = -) [-1,1,-1,1] [-1,1,-1,1] 1( 1 e b = ) [1,1,-1,-1] [0,2,-2,0] 1( 1 e b = ) [1,-1,-1,1] [1,1,-3,1] 0( 1 e b = -) [-1,1,1,-1] [-1,3,-1,-1] 0( 1 e b = -) [-1,-1,1,1] [-2,0,0,2] 1( 1 e b = ) [1,-1,-1,1] [-1,-1,-1,3] 0( 1 e b = -) [-1,1,1,-1] [-3,1,1,1] pMSE 1 2<label>3</label></formula><p>Note: In the column headers of "Difference after 1 st embedding", "Difference after 2 nd embedding" and "Difference after 3 rd embedding", the difference is the change between the Original and Marked Vector. T-IFS-05576-2015 6</p><p>IV. TWO IMPORTANT ISSUS</p><p>In the process of data embedding, some assistant techniques are needed to guarantee that the embedded data can be extracted exactly and the original image can be restored completely. Usually, they contain the following two items: 1) The method to identify those vectors containing embedded bits or not.</p><p>2) The method to solve the problem of overflow/underflow.</p><p>In this section, we present a location-map-free method to record the usable vectors, and develop a "flag array" to solve the problem of overflow/underflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Location Map Free Method</head><p>In most existing data hiding schemes, the location map is employed to locate the data embedding positions. It is generally embedded into the image as auxiliary information together with the payload, which reduces the net embedding capacity and decrease the efficiency of extraction at receiver side. Furthermore, since it is not easy to estimate the size of a location map, the iteration has to be employed to embed data into the cover image. It also reduces the efficiency of the scheme. Thus, a RDH scheme free from the location map is highly desirable and helpful <ref type="bibr">[18][19]</ref>.</p><p>According to Eq. ( <ref type="formula">7</ref>), if the condition</p><formula xml:id="formula_40">&lt; T T j i i i V S S S α ⋅ ⋅</formula><p>is satisfied at encoding stage, then, at decoding stage, we have</p><formula xml:id="formula_41">&lt;2 T T j i i i V S S S α ⋅ ⋅ </formula><p>, and thus the embedded bits can be correctly extracted and the original image can be restored completely. On the other hand, the vector j V is unusable for data embedding if</p><formula xml:id="formula_42">T T j i i i V S S S α ⋅ ≥ ⋅</formula><p>. We handle this case as follows.</p><formula xml:id="formula_43"> If T T j i i i V S S S α ⋅ ≥ ⋅</formula><p>, we let 1 e b = and embed one pseudo bit "1" to the vector j V . Thus ( )</p><formula xml:id="formula_44">, 2 T T T T j i j e i i j i e i i i i V S V b S S V S b S S S S α α α = + ⋅ = ⋅ + ⋅ ≥ ⋅  (10)  If T T j i i i V S S S α ⋅ ≤ - ⋅</formula><p>, we let 1 e b = -and embed one pseudo bit "-1" to the vector j V . Thus , ( ) 2</p><formula xml:id="formula_45">T T T T j i j e i i j i e i i i i V S V b S S V S b S S S S α α α = + ⋅ = ⋅ + ⋅ ≤ - ⋅  (11)</formula><p>Therefore, it is simple to determine whether a vector has been embedded with a bit at the decoding stage. If , 2</p><formula xml:id="formula_46">T j i i i V S S S α &lt; ⋅ </formula><p>, there must be one bit has been embedded in the vector. We restore the original vector with the bit and save it properly. On the other hand, if , 2</p><formula xml:id="formula_47">T j i i i V S S S α ≥ ⋅ </formula><p>, there must be one pseudo bit "1" embedded in the vector j V . Alternatively, if , 2</p><formula xml:id="formula_48">T j i i i V S S S α ≤ - ⋅ </formula><p>, there must be one pseudo bit "-1" embedded in the vector j V . We only restore the original vector with the pseudo bit and then discard it.</p><p>We provide an example to illustrate this method. Considering eight pixels as shown in Table <ref type="table" target="#tab_5">III</ref>, every pixel-pair constitutes one vector j V . Suppose the payload bit stream is (1, 1) (1, 1) 2</p><formula xml:id="formula_49">T T S S α ⋅ = -⋅ - = , thus, 1 1 1 1 = T T V S S S α ⋅ ⋅</formula><p>; so, the first pair is unsuitable for data embedding. We let 1 1 b = , and then the spreading sequence (1,-1) is added to the first vector. The marked vector is changed to (99, 95).</p><p>At the decoding stage, the product of , thus,</p><formula xml:id="formula_50">1 1 1 1 , 2 T V S S S α = ⋅ ⋅  .</formula><p>According to Eq. ( <ref type="formula">10</ref>), one pseudo bit "1" must have been embedded in the first vector. We just remove the spreading sequence from the first embedded vector and then discard the pseudo bit "1". For the second and third vectors, since ) are added onto the vectors according to Eq. ( <ref type="formula">4</ref>). At the decoding side, the embedded bits are achieved by the function of sign of ( )</p><formula xml:id="formula_51">1 ( 2,3) j sign V S j ⋅ = </formula><p>, and the original vectors are restored through removing the corresponding spreading sequences. As for the fourth vector, one pseudo bit of -1 is embedded to the vector because of 1 <ref type="bibr" target="#b3">4</ref> 1 1</p><formula xml:id="formula_52">T T V S S S α ⋅ &lt; - ⋅</formula><p>, the original vector is restored by removing a negative spreading sequence ( 1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S</head><p>-) from the embedded vector and then throw the pseudo bit "-1" away. The detailed data embedding, extraction and pixel recovery process are listed in Table <ref type="table" target="#tab_5">III</ref>. By embedding some pseudo bits, the location map is not needed at the embedding stage. Comparing with most classical works which use location-map to record the embedding positions as overhead, the method of embedding pseudo bits is simple and efficient.</p><p>Actually, the CDM-based RDH scheme can be viewed as a special histogram modification algorithm</p><formula xml:id="formula_53">-&lt; T j j i j i T j j e i j i T j j i j i V V S V S T V V b S T V S T V V S V S T α α α α α α  = - ⋅ ≤ -   = + ⋅ ⋅ &lt;   = + ⋅ ≥      (<label>12</label></formula><formula xml:id="formula_54">)</formula><p>where T is the absolute value of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Prevention of Overflow and Underflow</head><p>In a RDH system, the overflow/underflow may occur after data embedding, i.e., the values of some pixels in a marked 1556-6013 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. image may exceed the upper or/and the lower bound, e.g., 255 or 0 for an eight-bit grayscale image. Since the conventional overflow/underflow map needs to be embedded as overhead, this doing would occupy much embedding space. Here, we use the "flag array" to record the problem vectors. The equation</p><formula xml:id="formula_55">1 1 2 2 0 [ ] 255 j k k V b S b S b S α ≤ + + + ⋅⋅⋅ + ≤</formula><p>is utilized to determine the occurrence of overflow/underflow. One can see that the maximum modification on pixel value is k α after data embedding in a CDM-based scheme (note that α is the gain factor and k is the embedding levels). In order to prevent overflow/underflow, we shrink the histogram distribution from both ends. The range of pixel values of an eight-bit level grayscale image is changed towards the center from ]) in a "flag array" to identify it is an original or a modified one. The modified pixels are recoded as "1" and the original pixels are recoded as "0". Thus, the "flag array" is a binary array and every element corresponding to an overlapping-pixel, its size is the same as the number of overlapping-pixels.</p><p>As far as image Lena is concerned, its pixels' grayscale values distribute from 39 to 247 (as shown in Fig. <ref type="figure" target="#fig_9">2 (a)</ref>). Particularly, at the right-hand side of the histogram, there are 6 pixels with the grayscale values occurring in the range of 236 to 255; and these 6 pixels assume the following 6 different non-zero values, they are 236, 238, 241, 244, 245 and 247, respectively. Thus, if the shrunken threshold is 10, the pixels with grayscale value occurring in the range of [0, 9] would be changed to <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b18">19]</ref> by means of adding 10 to each of these pixel values; and the pixels with their grayscale values occurring in the range of <ref type="bibr">[246,</ref><ref type="bibr">255]</ref> would be reduced to <ref type="bibr">[236,</ref><ref type="bibr">245]</ref> by subtracting 10 from each pixel value. As the minimal pixel grayscale value is 39, no pixels would be overlapped at the left-hand side of the histogram; while, at the right-hand side, the pixel with the value of 247 will be changed to 237 (as shown in Table <ref type="table">IV</ref>). Therefore, we mark the 6 pixels with a binary sequence (i.e., the "flag array") according to their order of appearance in the image (such as from top-left to bottom-right, we have the "flag array" as '010000'). In the data extracting process, if the pixel's value occurs in the range of [236, 245] and its corresponding bit in the "flag array" is 0, we know that it is an original one, otherwise, it is a modified one and we just change it back by adding 10 into the value. Thus, the modified pixel with the value of 237 will be recovered to 247. The original image is then recovered completely. Generally, only one "flag array" is needed for the recovery of the original image no matter how many times data embedding would be executed, which reduces the overhead size significantly. Moreover, the "flags array" is usually very short and no "flag array" is needed for most images. Table <ref type="table">V</ref> is the number of flag bits at different shrunken thresholds; it shows that nearly all images do not need "flag array" for one-time data embedding. In practice, even if the shrunken threshold is 10, the size of a "flag array" is still very small. The embedding of a "flag array" has little impact on embedding capacity. Note: the threshold is the value that the pixel has been changed towards the center from the both ends of the histogram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PROPOSED SCHEME</head><p>A. Formation of Vector j V According to Eq. ( <ref type="formula">7</ref>), the vector j V is suitable for data embedding in the case of</p><formula xml:id="formula_56">&lt; T T j i i i V S S S α ⋅ ⋅</formula><p>. As the elements "1"</p><p>and "-1" are equally distributed in spreading sequence i S , the product of j i V S ⋅ equals the sum of the differences of all element-pairs in vector j V . Hence, the product of j i V S ⋅ would be minimized if the elements of vector j V are similar. The embedding capacity of the proposed scheme depends on the elements similarity in every vector j V . Therefore, it is highly desirable that the vector elements are similar and closely correlated.</p><p>Fortunately, according to the redundancy existing in natural images, the values of pixels in a small local area are quite similar. Then, a vector j V with similar elements can be obtained if it is formed by neighboring pixels; and more vectors suitable for data embedding can be obtained if the cover image has plenty of smooth areas.</p><p>Furthermore, inspired by reference paper, we propose a new approach that using rhombus-error-prediction method to enhance the similarity of the vector elements <ref type="bibr" target="#b13">[14]</ref> <ref type="bibr" target="#b14">[15]</ref>. Fig. <ref type="figure">1</ref> reveals the main idea of the rhombus-error-prediction method. Denote the central pixel value as , x y u , where x and y are subscripts indices of row and column. The four neighboring pixels , 1 1, , <ref type="bibr" target="#b0">1</ref>  </p><formula xml:id="formula_57">- + + -   =    <label>(13)</label></formula><p>The prediction-error , . Since the prediction-errors are usually very small and distribute around zero with a high peak, the vector j V with more similar elements can be obtained, and the embedding capacity is then increased. <ref type="figure">1</ref>. Diagram of rhombus-error predictor. The "Dot" pixel value is predicated by using the four "Cross" neighboring pixel values.</p><formula xml:id="formula_58">× ⊙ × ⊙ × ⊙ × ⊙ ⊙ × ⊙ × ⊙ × ⊙ × × ⊙ × ⊙ × ⊙ × ⊙ ⊙ × ⊙ × ⊙ × ⊙ × × ⊙ × ⊙ × ⊙ × ⊙ ⊙ × ⊙ × ⊙ × ⊙ × × ⊙ × ⊙ × ⊙ × ⊙ ⊙ × ⊙ × ⊙ × ⊙ × Fig.</formula><p>Fig. <ref type="figure">1</ref> indicates that all image pixels are divided into two sets (the "Cross" set and the "Dot" set) in the light of the rhombus-error-prediction method. The four neighbors of a pixel must belong to the set different from the set occupied by the central pixel. In the first embedding stage, the "Cross" set containing pixels with even (x+y) are predicted by the "Dot" set containing pixels with odd (x+y). Pixels in the "Dot" set are not modified and the predicted value , '</p><p>x y u is stable. Then, the decoder can get the same , x y U and , '</p><p>x y u as the encoder, by which the embedded bit and the original pixel can be exactly recovered. Moreover, since the two sets are independent of each other, the "Dot" set can be predicted "cross" set for data embedding in the second stage. The order of two data embedding stages can be exchanged. Fig. <ref type="figure" target="#fig_9">2</ref> shows the histogram of the pixels, the histogram of the differences of adjacent pixel-pairs, and the histogram of the rhombus-prediction-errors of image Lena. It is obvious that the histogram distribution of rhombus-prediction-errors is steeper than the others. The reason is that the rhombus-error-prediction method can exploit image redundancy better, so that the prediction-errors distribute more closely around zero; and thus more elements can be involved for data embedding while introducing less image distortion. The scheme works on the rhombus-prediction-error matrix would achieve better performance practically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Data Embedding and Extraction</head><p>This section describes the data embedding and extraction processes of the proposed scheme step by step (as shown in Fig. <ref type="figure" target="#fig_10">3</ref>  Step 1: Image modification 1) Reserve specific area as "LSB replaceable" block and keep it non-modified. The position of "LSB replaceable" block is fixed or specified by a secret key shared with decoder. Generally, the marginal region of the cover image is taken as the "LSB replaceable" block. 2) According to the payload and image content, predetermine the multi-embedding levels, gain factor α and spreading sequence. In general, the capacity of one time data embedding is about 0.2-0.4 bpp for natural image of size 512×512.</p><p>3) Except for the reserved "LSB replaceable" block, shrink the histogram distribution of the cover image according to the embedding levels and gain factor α , using "flag array" to identify the overlapped pixels.</p><p>Step 2: Data embedding 1) According to the rhombus-error-prediction method, divide the cover image into "Cross" set and "Dot" set. Use the "Dot" set pixels to predict the "Cross"set pixel values and get the prediction-error matrix. 2) Choose elements of the matrix (formed by prediction-errors) to form the vector j V from top-left to bottom-right. Considering the j-th vector j V , if</p><formula xml:id="formula_59">&lt; T T j i i i V S S S α ⋅ ⋅</formula><p>is satisfied, embed one bit according to Eq. ( <ref type="formula">4</ref>), otherwise, embed a pseudo bit to guarantee the reversibility of the scheme.</p><p>3) The output after the "Cross" set embedding is the marked "Cross" set and the unchanged "Dot" set. Then, the data embedding in the "Dot" set is accomplished with prediction-errors generated by the modified pixels from the "Cross" set. The data embedding process can be overlappingly executed until all of the data have been embedded. Then we denote * N as the index of the last vector.</p><p>Step 3: Auxiliary information embedding 1) Record the LSB of the "LSB-replaceable" block to obtain a binary sequence S R . Embed S R consecutively (i.e. the vectors with index of * 1 N + to end N ) with the same method as described in Step 2. Here end N is the last marked vector. 2) Finally, replace the LSB of the "LSB-replaceable" block with auxiliary data including the spreading sequence (16 bits), gain factor α (8 bits), embedding levels (8 bits),</p><formula xml:id="formula_60">embedding index * N ( * 2 log N     ) and end N ( 2 log end N   </formula><p> ), "flag array," and the size of the payload. Thus, the marked image is achieved It should be mentioned that, in order to reduce the image distortion, the gain factor is usually taken as the smallest 1556-6013 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2566261, IEEE Transactions on Information Forensics and Security</p><p>T-IFS-05576-2015 9</p><p>positive integer "1". The data are overlappingly embedded and most elements of different spreading sequences are mutually cancelled in the process of multilevel data embedding. It enables the proposed scheme to achieve higher embedding capacity while restraining distortion to a low level. The data extraction and image restoration is the inverse of the embedding process. The corresponding steps are summarized as follows:</p><p>Step 1: Auxiliary information extraction 1) Read LSB of pixels in "LSB-replaceable" block to obtain the spreading sequence, gain factor, multi-embedding levels, payload size, embedding index and the "flag array".</p><p>Step 2: Data extraction 1) In the reverse order of the data embedding process, divide the marked image into "cross" set and "dot" set. Use "dot" (or "cross") set pixel values to predict the "cross" (or "dot") set pixel values, and achieve the corresponding prediction-error matrix. 2) Scan the object matrix and build the vector j V  the same as in the embedding process, calculate the cross correlation between j V  and the spreading sequence i S to obtain the embedded bit according to Eq. ( <ref type="formula">7</ref>).</p><p>3) Substrate the embedded spreading sequence from vector j V  , and keep the useful bits safely. If it is a pseudo bit, just discard it and move the process ahead. 4) According to the multi-embedding levels, extract the embedded data and substrate the spreading sequence repeatedly.</p><p>Step 3: Original image recovery 1) Replace LSB of the "LSB-replaceable" block by the extracted sequence bits from * 1 N + to end N . 2) Use the "flag array" to identify the overlapped pixels and reconstruct the original image. Finally, the embedded data and the original image are restored completely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIMENTAL RESULTS</head><p>Four 512×512 grayscale images Lena, Airplane, Baboon and Barbara from USC_SIPI database were firstly employed in our experiments. All of these images have been widely used in RDH research community. The four selected images have different features, the image Airplane has more low-frequency (smooth areas) components, Baboon contains more high-frequency components (noisy areas), and Lena and Barbara are rich in moderate-frequency components. Besides, the image Barbara has regions containing many strips, which is unfavorable for error prediction and data embedding. Thus the performance of the proposed scheme can be evaluated comprehensively with these four images.</p><p>We designed a prediction-error based RDH scheme to evaluate the performance of our proposed method. The to-be-embedded bits were denoted by different spreading sequences and embedded into the rhombus-prediction-error matrix. To facilitate comparison, all experiments were performed by embedding and decoding a random binary sequence generated by the Matlab function randint(). The capacity-distortion behavior has been utilized to evaluate the performance of the proposed scheme. The net embedding capacity was calculated in bit per pixel (bpp) and the distortion was measured by peak signal to noise ratio (PSNR).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Results of Different Gain Factor α</head><p>In the proposed scheme, the gain factor α is employed to control the embedding intensity. More pixels would be involved for embedding if α is big and thus the embedding capacity is enlarged. According to Eq. ( <ref type="formula">7</ref>), if the length of spreading sequence is 2 and the gain factor 1 α = , all of the pixel-pairs with differences less than 2 would be employed for data embedding. Similarly, when the gain factor α is 2, all of the pixel-pairs with differences less than 4 would be involved, and so on. Fig. <ref type="figure">4</ref> demonstrates that the performance drops clearly as the value of α increases. As to the image Lena, its PSNR value is 48.63dB at 0.27bpp and 44.82dB at 0.5bpp when the gain factor 1 α = , whereas, it dropped to 46.11dB at 0.27bpp and 42.78dB at 0.5bpp when the gain factor 2 α = . Since the MSE of the marked image is the square of the gain factor α , the PSNR decreases rapidly with the increases of α . The larger the gain factor is, the noisier the image would be. It can be calculated that the PSNR value of a marked image is 48.12dB after one-time data embedding when 1 α = , whereas the PSNR becomes 36.08dB after one-time data embedding when 4 α = (MSE=16). On the other hand, a bigger α can enhance the robustness of a marked image. The data can be exactly extracted even after the marked image suffers from some unintentional attacks during the transmission.</p><p>Moreover, Fig. <ref type="figure">4</ref> also indicates that the PSNR value drops slowly at the moderate-to-high embedding capacity. As to the image Lena, its PSNR value is 54.16dB at 0.1bpp, 44.82dB at 0.5bpp, and still retains at 38.12dB at 1.0bpp. The proposed scheme keeps image in good quality even at high embedding capacity. Since two pixels would be changed after one bit has been embedded into the image in the proposed scheme, the PSNR of the marked image drops rapidly in the process of first time data embedding; whereas, as the payload increases, the data are overlappingly embedded into the image, most elements of different spreading sequences are mutually cancelled in the process of multilevel data embedding, the image quality thus degrades slowly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Results of Different Spreading Sequence Length</head><p>The length of the spreading sequence also impacts the performance of the proposed scheme. The maximum achievable capacity of one-time data embedding is 0.5bpp when the sequence length is 2; but the maximum capacity of single embedding is only 0.25bpp when the sequence length is 4. The short spreading sequence modifies less pixels of the image (or elements of the prediction-error matrix) than the long one for data embedding (if the spreading sequence is 2, 2 pixels/elements would be modified for one bit embedding, whereas 4 pixels/elements would be modified if the spreading sequence is 4), which would cause less distortion at the same embedding capacity. In addition, according to the local consistency of a natural image, the short spreading sequence can exploit more vectors j V suitable for data embedding than a long sequence. To make good use of image redundancy, we form the vector j V in the following three ways to evaluate its impact on data hiding performance. As shown in Fig. <ref type="figure">5</ref>, the adjacent of 2, 4, and 16 pixels/elements are involved to form vector j V .</p><p>(a) (b) (c) Fig. <ref type="figure">6</ref> contains the results of embedding with different lengths of spreading sequences. The superiority of embedding with a short spreading sequence is obvious. The PSNR differences are 2.1, 2.4, 1.8 and 2.7dB, respectively, at 0.2 bpp between 2 and 4 elements spreading sequence for the images Lena, Airplane, Baboon and Barbara.</p><p>The embedding performance drops remarkably when the spreading sequence length is 16 (constitute by 4 × 4 pixels/elements). On one hand, 16 pixels/elements would be modified for one bit embedding. On the other hand, the number of 4×4 group pixels/elements suitable for data embedding is less, thus the PSNR-BPP curve is far below the curves at 2 or 4 elements spreading sequence. Furthermore, with payload increasing, multilevel embedding can be employed to expand embedding capacity, and most elements of different spreading sequences would be mutually cancelled. The difference of PSNR curves resulted from different lengths of spreading sequences is reduced gradually.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Comparison with Other State-of-the-art Schemes 1) Comparisons on six popular used test images</head><p>Here, six images from USC_SIPI are employed to evaluate the performance of our proposed scheme by comparing with some state-of-the-art RDH works. Fig. <ref type="figure" target="#fig_13">7</ref> contains the performance comparisons between the proposed scheme and some state-of-the-art RDH schemes which are proposed by Li et al. <ref type="bibr" target="#b16">[17]</ref>, Sachnev et al. <ref type="bibr" target="#b14">[15]</ref>, Xuan et al. <ref type="bibr" target="#b27">[28]</ref>, Lee et al. <ref type="bibr" target="#b24">[25]</ref> and Dragoi and Coltue <ref type="bibr" target="#b21">[22]</ref>. These five schemes utilize different data embedding strategies, i.e., difference expansion in integer-transform domain, prediction-error expansion and sorting technique, histogram shifting and optimal embedding method, prediction-error expansion and adaptive embedding, local prediction and difference expansion method, respectively. Each of these skills has achieved excellent performance in RDH. Here, to facilitate comparison, we vary the embedding capacity from 0 to 0.9 bpp with a step of 0.1bpp.</p><p>According to Fig. <ref type="figure" target="#fig_13">7</ref>, the performance of our proposed scheme is less than others at low payload. However, it catches up and surpasses other schemes as the payload increases. The gain in PSNR exceeds other state-of-the-art schemes when the embedding bit rate equals to or greater than 0.24, 0.37, 0.08 and 0.58bpp on image Lena, Airplane, Baboon and Barbara, respectively. Moreover, for images Boat and Peppers, it also outperforms other advanced schemes when the embedding bit rate larger than 0.16 and 0.12 bpp respectively. It is noted that these two test images are not as popular as the other four test images used in RDH. Only a very few schemes have reported their performance on them. Experimental results have shown that the performance of our proposed scheme outperforms other state-of-the-art schemes at the moderate-to-large embedding capacity significantly.  The reason that its performance is not the best at the small data embedding rates is as follows. As the payload is small, at least two pixels need to be modified for the proposed method to embed one bit, the performance of the proposed scheme less than those referenced works. But, as the payload increases, multilevel data embedding is employed to enlarge the embedding capacity. Most elements of different spreading sequences are mutually cancelled in the process of multilevel data embedding, and the corresponding distortion-capacity curve drops more slowly than those classical schemes. Therefore, the proposed scheme achieves higher PSNR value than others at the moderate-to-high embedding capacity.</p><p>As to image Barbara, the improvement is not obvious. It is because the image has regions containing many strips, which are unfavorable for the exploitation of redundancy. The proposed scheme achieves better performance compared to other advanced schemes after more levels of data embedding have been executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Comparisons on JPEG2000 test image</head><p>To further evaluate the performance of our proposed scheme, we also employed one of the JPEG2000 test image  <ref type="figure">9</ref>. As Xuan et al.'s method makes the use of four thresholds to search for the optimal performance in RDH, it achieves better performance as the payload is no more than 0.55 bpp. However, as the payload increases, in our proposed scheme, most elements of different spreading sequences are mutually cancelled in the process of multilevel data embedding. Hence, our proposed scheme achieves higher PSNR values than Xuan et al.'s method when the embedding capacity is larger than 0.55 bpp. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. DISCUSSIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Structural Simulation (SSIM) of the Marked Images.</head><p>While the PSNR measures the difference of an image with its original version, SSIM is a perception-based model that considers image perceptual degradation in structural information. As the SSIM can capture the actual image quality closely to visual effects in human eyes, in this paper, we firstly introduce this index to evaluate the quality of marked images. Experimental results have demonstrated that the SSIM and PSNR have similar behaviors in terms of the performance evaluation for a RDH scheme. As shown in Fig. <ref type="figure" target="#fig_17">10</ref>, the SSIM drops clearly with the increases of the embedding capacity, especially for image with plenty of high-frequency component. The SSIM of image Baboon is 0.88 when the bpp of RDH embedding is 0.6; while the value of image Airplane is 0.97 at the same embedding capacity. As less vectors generated from noisy areas are suitable for data embedding than those from smooth areas, multilevel data embedding is needed for a noisy image to hide as much data as an image rich in smooth areas. The SSIM of a noisy image drops faster than those images having massive smooth areas as data have been embedded. The trends of curves obtained by using SSIM are similar to those obtained by using PSNR. Nevertheless, The SSIM provides us a new perception-based way to test the performance of RDH scheme.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. A Parameter Memorization-free Method</head><p>In a RDH system, a parameter memorization-free method is highly desired in order to enlarge the embedding capacity. Motivated by the work of Fujiyoshi et al. <ref type="bibr" target="#b18">[19]</ref>, we arranged the blocks include the usable vectors in ascending order, so that the vectors, whose elements having small variance, are firstly selected for data embedding, and thus the distortion of marked image is reduced especially at low embedding capacity. As shown in Fig. <ref type="figure" target="#fig_18">11</ref>, the embedding performance of the proposed scheme has been improved at the low payload by using the block-ascending method. However, with the increases of payload, the advantage reduces gradually. When the embedding capacity largely increases, the improvement by with the block-ascending method is marginal. This is because the method of block-ascending record the magnitude of local variance, and a vector will be firstly used for data embedding if it has a small variance. Thus, the scheme performs well at low embedding capacity. As the payload increase, the smooth vectors are insufficient and the noisy ones would to be utilized for data embedding, vectors with large prediction-errors will be involved, the image quality thus drops rapidly. When the payload is largely increases, all of the usable vectors would be involved for data embedding; the improvement derives from the using of block-ascending method for embedding position selection is negligible. Then, the performance of data embedding with or without block-ascending method is similar. In short, as far as our proposed scheme is concerned, embedding with a parameter memorization-free lossless data hiding method can improve the performance at low embedding capacity apparently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Security and Computing Complexity</head><p>As the data are embedded through spreading sequences at encoding side, only one who has the same spreading sequence can extract them exactly at decoding side. The security of the scheme not only relies on the method itself but also on the spreading sequence. The spreading sequence can be utilized as the key of the data hiding system, which provides more security than traditional RDH schemes. A short spreading sequence can be employed to enlarge the embedding capacity, whereas a long spreading sequence can be applied to increase security. The choice of the sequence length can be balanced between the embedding capacity and the system security. Furthermore, since the modification of image pixels usually is very small, the quality of the marked image degrades slightly, and it is hard to detect whether the image has been embedded or not. The key spreading sequence cannot be deduced from image analysis. It will be difficult for one to illegally extract the embedded data and recover the original image.</p><p>Additionally, we briefly compare the computational complexity of the proposed method with the methods based on difference expansion and histogram modification. Since all of these three methods can work on the prediction-error matrix derived from the cover image, we only compare the embedding and decoding complexity. The command operations, such as multiplication, addition and shift, are employed to compare the complexity of the three methods. In the embedding process, the difference expansion method includes one multiplication operation and one addition operation for one bit embedding, the histogram shifting method needs one addition operation, and the proposed method needs two addition operations to embed one bit when the length of spreading sequence is 2. However, the difference expansion method generally utilizes a location map to locate the embedded pixels. The compression of the location map is generally high computational cost in practice. The histogram shifting method needs to create an image histogram to choose the prominent bins and then shift all non-selected bins one position for data embedding, which is also quite complex. As to the proposed scheme, only a simple pre-comparison is needed to determine the embedding of one useful or pseudo bit. The decoding process is the reverse of data embedding and possesses the same complexity. Hence, the proposed scheme is less complex compared with other RDH schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>A novel CDM-based RDH algorithm has been proposed in this paper. The covert data are denoted by different spreading sequences and added to the prediction-error matrix of cover image. At the decoding stage, the original image can be recovered completely and the embedded data can be extracted exactly. In the proposed scheme, different orthogonal spreading sequences are overlappingly embedded the cover image to enlarge embedding capacity and most elements of different spreading sequences are mutually cancelled in the process of multilevel data embedding, by which high embedding capacity is achieved while restraining distortion to a low level. This is the first attempt to design a RDH scheme based on CDM algorithm, and the proposed scheme achieves higher performance compared with most state-of-the-art works at the moderate-to-high embedding capacity. However, this algorithm is still fragile as any malicious invasion may cause errors in the decoding of the data hiding image. This issue should be investigated in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>according to Eq. (3); the spreading sequence 1 (1, 1) S = -is utilized for data embedding on each vector and the gain factor is predefined as 1 α = . For the first</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>two vectors are suitable for data embedding, and the corresponding spreading sequences (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>&lt;</head><label></label><figDesc>can be utilized for data embedding, which provides larger embedding capacity than traditional histogram modification-based works. Its superiority lies in that it involves more histogram bins for data embedding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2566261, IEEE Transactions on Information Forensics and Security T-IFS-05576-2015 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>the pixel whose value lies in the overlapping areas are recorded (i.e., pixel values in [ k α</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>can be embedded by modifying of , x y d to , x y D , and then change the original pixel value ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. (a) Histogram of image pixels; (b) Histogram of the differences of adjacent pixel-pairs; (c) Histogram of the prediction-errors of image Lena.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Block diagrams of CDM-based (a) data embedding; (b) data extraction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>α =1 gain factor α =2 gain factor α =3 gain factor α =4 gain factor α =5 (d) Barbara Fig.4. Comparisons of PSNR versus payload with different gain factor α . 1556-6013 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information. This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2566261, IEEE Transactions on Information Forensics and Security T-IFS-05576-2015 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. Formation of vector with adjacent pixels/elements (a) 2, (b) 4, (c) 16</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 7 .</head><label>7</label><figDesc>Fig.7. Comparison of PSNR versus payload between our proposed method and other advanced schemes-Li et al.<ref type="bibr" target="#b16">[17]</ref>, Xuan et al.<ref type="bibr" target="#b27">[28]</ref>, Lee et al.<ref type="bibr" target="#b24">[25]</ref>, Sachnev et al.<ref type="bibr" target="#b14">[15]</ref> and dragoi et al.<ref type="bibr" target="#b21">[22]</ref> .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Woman in our experiments. The size of the image has been reduced from 1920 × 1536 to 960 × 768 to facilitate the comparison. It is observed that most of the above mentioned six widely used images have the two ends of their histogram empty (except for images Baboon and Peppers having one-side of their histogram non-zero), whereas, the both ends of histogram of the image Woman have peaks. The test of our proposed scheme on such an image can further verify its performance. The performance comparison in terms of PSNR versus payload with other prior-arts (Kim et al.'s difference expansion method and Xuan et al.'s histogram modification method) is shown in Fig.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 8 .Fig. 9 .</head><label>89</label><figDesc>Fig. 8. Image Woman used in paper</figDesc><graphic coords="12,147.66,380.34,50.10,63.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Comparison of SSIM versus payload over different images.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Performance comparison of our proposed scheme with or without parameter memorization-free method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2566261, IEEE Transactions on Information Forensics and Security</figDesc><table /><note><p>1556-6013 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2016.2566261, IEEE Transactions on Information Forensics and Security</figDesc><table /><note><p>1556-6013 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE III EXAMPLE</head><label>III</label><figDesc>OF PIXEL VALUE CHANGES OF CDM-BASED DATA EMBEDDING AND DECODING</figDesc><table><row><cell>Original vector</cell><cell cols="4">(98 96) (100 100) (101 100) (102 105)</cell></row><row><cell>1 V S j ⋅</cell><cell>2</cell><cell>0</cell><cell>1</cell><cell>-3</cell></row><row><cell>Embedded pseudo bit</cell><cell>1</cell><cell></cell><cell></cell><cell>-1</cell></row><row><cell>Embedded secret bit</cell><cell></cell><cell>1</cell><cell>-1</cell><cell></cell></row><row><cell>Embedded sequence</cell><cell>(1,-1)</cell><cell>(1,-1)</cell><cell>(-1,1)</cell><cell>(-1,1)</cell></row><row><cell>marked vector</cell><cell cols="4">(99 95) (101 99) (100 101) (101 106)</cell></row><row><cell>1 V S j ⋅ </cell><cell>4</cell><cell>2</cell><cell>-1</cell><cell>-5</cell></row><row><cell>Extracted bit( e b )</cell><cell>1</cell><cell>1</cell><cell>-1</cell><cell>-1</cell></row><row><cell>Extracted Sequence</cell><cell>(1,-1)</cell><cell>(1,-1)</cell><cell>(-1,1)</cell><cell>(-1,1)</cell></row><row><cell>Recoverd vector</cell><cell cols="4">(98 96) (100 100) (101 100) (102 105)</cell></row><row><cell>Secret bit( z ω )</cell><cell>discard</cell><cell>1</cell><cell>0</cell><cell>discard</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>).</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>No</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Original Image</cell><cell>Histogram Shrinking and Space Reservation</cell><cell>Divide Image into Cross Set and Dot Set</cell><cell>(Cross Set) CDM Based Data Embedding</cell><cell>(Dot Set) CDM Based Embedding Data</cell><cell>Embedding Finish? Yes</cell><cell>Image Rebuilt and Embedding Message Auxiliary</cell><cell>Marked Image</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">(b) Data embedding process</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>No</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Marked Image</cell><cell>Auxiliary Message Extraction</cell><cell>Divide Image into Cross Set and</cell><cell>(Dot Set) CDM Based Data</cell><cell>(Cross Set) CDM Based Data</cell><cell>Extraction Finish? Yes</cell><cell>Space Recovery and Histogram</cell><cell>Original Image</cell></row><row><cell></cell><cell></cell><cell>Dot Set</cell><cell>Extraction</cell><cell>Extraction</cell><cell></cell><cell>Expansion</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">(a) Data extraction process</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by Shandong Provincial Natural Science Foundation, China (No. ZR2012F014), the National Natural Science Foundation of China (No. 41202206) and Jinan university &amp; institutes innovation program (JN201402005)</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Method and apparatus for embedding authentication information within digital data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Barton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">US Patent</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="646" to="997" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Invertible authentication，&quot; Photonics West 2001-Electronic Imaging</title>
		<author>
			<persName><forename type="first">，m</forename><surname>Fridrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">，r</forename><surname>Goljan</surname></persName>
		</author>
		<author>
			<persName><surname>Du</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Society for Optics and Photonics</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="197" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lossless generalized-LSB data embedding</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Tekalp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Saber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="266" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Image Processing</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Capacity bounds and constructions for reversible data-hiding</title>
		<author>
			<persName><forename type="first">，fmj</forename><surname>Kalker</surname></persName>
		</author>
		<author>
			<persName><surname>Willems</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Electronic Imaging 2003. International Society for Optics and Photonics</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="604" to="611" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Recursive Histogram Modification: Establishing Equivalency Between Reversible Data Hiding and Loss less Data Compression</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="2775" to="2785" />
			<date type="published" when="2013-07">Jul, 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reversible data embedding using a difference expansion</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. Video Techn</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="890" to="896" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reversible watermark using the difference expansion of a generalized integer transform</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Alattar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions On Image Processing: A Publication Of The IEEE Signal Processing Society</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1147" to="1156" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Reversible data embedding into images using wavelet techniques and sorting</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kamstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Heijmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2082" to="2090" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Image Processing</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A novel difference expansion transform for reversible data embedding</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sachnev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-G</forename><surname>Choo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="456" to="465" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>IEEE Transactions on</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Expansion embedding techniques for reversible watermarking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Thodi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Rodríguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="721" to="730" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Image Processing</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The LOCO-I lossless image compression algorithm: principles and standardization into JPEG-LS</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Weinberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Seroussi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1309" to="1324" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>Image Processing</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Reversible image data hiding based on gradient adjusted prediction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fallahpour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Electronics Express</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page" from="870" to="876" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improved embedding for prediction-based reversible watermarking</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coltuc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="873" to="882" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Information Forensics and Security</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A location-map free reversible data hiding method using block-based single parameter</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fujiyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICIP</title>
		<meeting>IEEE ICIP</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="257" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reversible watermarking algorithm using sorting and prediction</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sachnev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Suresh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="989" to="999" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>Circuits and Systems for Video Technology</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Model order selection in reversible image watermarking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xiong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="592" to="604" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>Selected Topics in Signal Processing</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient reversible watermarking based on adaptive prediction-error expansion and pixel selection</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="3524" to="3533" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Image Processing</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A reversible image authentication method without memorization of hiding parameters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fujiyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Trans. Fundamentals</title>
		<imprint>
			<biblScope unit="page" from="2572" to="2579" />
			<date type="published" when="2009-10">Oct. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A parameter memorization-free lossless data hiding method with flexible payload size</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fujiyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tsuneyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Electronics Express</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">23</biblScope>
			<biblScope unit="page" from="1702" to="1708" />
			<date type="published" when="2010-12">Dec. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reversible data hiding with optimal value transfer</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multimedia, IEEE Transactions on</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="316" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Low Distortion Transform for Reversible Watermarking</title>
		<author>
			<persName><surname>Coltuc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ieee Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="412" to="417" />
			<date type="published" when="2012-01">Jan, 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Local-Prediction-Based Difference Expansion Reversible Watermarking</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">C</forename><surname>Dragoi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Coltuc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ieee Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1779" to="1790" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Circuits and Systems for Video Technology</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="354" to="362" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>Reversible data hiding</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Robust lossless image data hiding</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Circuits &amp; Systems for Video Technology</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="497" to="509" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">H</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reversiblee Image Authentication Based on Watermarking ， &quot; Multimedia and Expo</title>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="page" from="1321" to="1324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Adaptive reversible data hiding method based on error energy control and histogram shifting</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optics Communications</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="101" to="108" />
			<date type="published" when="2012-01-15">Jan 15, 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Improving histogram-based reversible data hiding by interleaving predictions</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Tsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IET Image Processing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="223" to="234" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Optimal histogram-pair and prediction-error based image reversible data hiding</title>
		<author>
			<persName><forename type="first">G</forename><surname>Xuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Forensics and Watermaking</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="368" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">General Framework to Histogram-Shifting-Based Reversible Data Hiding</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="2181" to="2191" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Reversible Watermarking Based on Invariant Image Classification and Dynamic Histogram Shifting</title>
		<author>
			<persName><forename type="first">G</forename><surname>Coatrieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cuppens-Boulahia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cuppens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Roux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="111" to="120" />
			<date type="published" when="2013-01">Jan, 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Lossless data hiding using histogram shifting method based on integer wavelets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Xuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Watermarking</title>
		<imprint>
			<biblScope unit="page" from="323" to="332" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Integer DCT-based reversible watermarking for images using companding technique</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schmucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Funk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Electronic Imaging 2004. International Society for Optics and Photonics</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="405" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A semi-fragile lossless digital watermarking scheme based on integer wavelet transform</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1294" to="1300" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>Circuits and Systems for Video Technology</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Reversible image watermarking based on integer-to-integer wavelet transform</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kalker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Forensics and Security</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="321" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Robust Reversible Watermarking via Clustering and Enhanced Pixel-Wise Masking</title>
		<author>
			<persName><forename type="first">L</forename><surname>An</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="3598" to="3611" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">CDMA: principles of spread spectrum communication</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Viterbi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison Wesley Longman Publishing Co., Inc</publisher>
			<biblScope unit="page" from="112" to="124" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
