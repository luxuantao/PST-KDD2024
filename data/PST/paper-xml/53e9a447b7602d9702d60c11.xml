<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">THE INTEGRATION OF FUNCTIONS INTO LOGIC PROGRAMMING: FROM THEORY TO PRACTICE</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Michael</forename><surname>Hanus</surname></persName>
							<email>mi&amp;ael@mpi-sb.mpg.de</email>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck-Institut fur Informatik</orgName>
								<address>
									<addrLine>Im Stadtwald</addrLine>
									<postCode>D-66123</postCode>
									<settlement>Saarbriicken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Elsevier Science Inc</orgName>
								<address>
									<postCode>1994</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">THE INTEGRATION OF FUNCTIONS INTO LOGIC PROGRAMMING: FROM THEORY TO PRACTICE</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5876578013B405D0E634C5354DC7A7E3</idno>
					<note type="submission">Received May 1993; accepted December 1993.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Functional and logic programming are the most important declarative programming paradigms, and interest in combining them has grown over the last decade. Early research concentrated on the definition and improvement of execution principles for such integrated languages, while more recently efficient implementations of these execution principles have been developed so that these languages became relevant for practical applications. In this paper, we survey the development of the operational semantics as well as the improvement of the implementation of functional logic languages.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Interest in the amalgamation of functional and logic programming languages has increased since the beginning of the last decade. Such integrated languages have advantages from the functional and the logic programming point of view. In comparison with pure functional languages, functional logic languages have more expressive power due to the availability of features like function inversion, partial data structures, and logical variables [ 1091. In comparison with pure logic languages, functional logic languages have a more efficient operational behavior since functions allow more deterministic evaluations than predicates. Hence the integration of functions into logic programming can avoid some of the impure control features of Prolog like the cut operator. These principal considerations were the motivation for integrating both language types. Depending on the initial point of view, the integration of functional and logic programming languages has been tackled in two ways. From a functional programming point of view, logic programming aspects can be integrated into functional languages by permitting logical variables in expressions and replacing the matching operation in a reduction step by unification <ref type="bibr">[ 109]</ref>.'From a logic programming point of view, functions can be integrated into logic languages by combining the resolution principle with some kind of functional evaluation. Since we are mainly interested in logic programming, we concentrate this survey on the latter aspect. However, we want to point out that both views yield similar operational principles for the amalgamated languages.</p><p>The integration of functions into logic programming is very simple from a syntactic point of view. For this purpose, we have to extend the logic language by: 1. A method to define new functions. 2. A possibility to use these functions inside program clauses.</p><p>To realize the first point, we could allow the implementation of functions in an external (functional) language [ 141. A more interesting alternative is the direct integration of function definitions into the logic language. For this purpose one has to permit program clauses defining the equality predicate. Equality "=" is a predefined predicate in Prolog systems which is satisfied iff both arguments are syntactically equal (i.e., syntactic unification of both arguments). Hence this predicate can be defined by the fact x = x.</p><p>By admitting new clauses for "=", we are able to express that syntactically different terms are semantically equal. In particular, a function applied to some argument terms should be equal to its result. For instance, the following equality clauses define the semantics of the function append</p><p>for concatenating lists (we use the Prolog notation for lists [ 1221): Using these clauses for equality, we can prove that the term append</p><formula xml:id="formula_0">( [ 1, 2 ] , [<label>3</label></formula><p>] ) is equal to [ 1,2 , 3 ] . Note that this method of defining functions is the same as in modern functional languages like <ref type="bibr">Haskell [67]</ref>, <ref type="bibr">Miranda [127]</ref>, or ML <ref type="bibr">[63]</ref>, where functions are defined by argument patterns. We can also define functions by conditional equations, where we may use arbitrary predicates in the conditions. For instance, the maximum function on naturals can be defined by the following conditional equations:</p><formula xml:id="formula_1">max(X,Y) = X :- X &gt;= Y. max(X,Y) = Y :- X =&lt; Y.</formula><p>Due to the logic part of the integrated language, the proof of the condition may require a search for the right instantiation of new variables occurring in the condition. This is shown in the following definition of a function computing the last element of a list:</p><formula xml:id="formula_2">last(L) = E :-append(_, [E] ) = L.</formula><p>If such conditional equations should be applied to compute the value of a functional expres-'Other alternatives to integrate logic programming aspects into functional languages are set abstractions <ref type="bibr">(26, 27, 112, 117, 1181 or logical arrays [72]</ref>.</p><p>sion, the validity of the condition must be proved. For instance, in order to evaluate the term last <ref type="bibr">([l,Z]</ref>),wehavetofindasolutiontotheequationappend(_, lE1)= <ref type="bibr">[1,</ref><ref type="bibr">2]</ref>. Techniques to compute such solutions will be presented in Section 2.</p><p>After defining functions by equality clauses, the programmer can use these functions in expressions occurring in goals of the logic program. For instance, if the membership in a list is defined by the clauses member(E, <ref type="bibr">[EIL]</ref>). member <ref type="bibr">(E, [F(L]</ref>) :-member(E,L).</p><p>specifying the predicate member, we can use the append function in goals where list terms are required. In the goal ?-member <ref type="bibr">(E,append([ll,[2]</ref>)).</p><p>the second argument is equal to the list [ 1,2 I and therefore the two answers to this goal are ~=l and E=2. This kind of amalgamated language is known as logic programming with equality and has a clearly defined declarative semantics <ref type="bibr">[50,7 1, 1061.</ref> It is similar to the well-known Horn clause logic <ref type="bibr">[83]</ref>, but with the difference that the equality predicate "=" is always interpreted as the identity on the carrier sets in all interpretations, Therefore, we omit the details of the declarative semantics in this survey.</p><p>The definition of the operational semantics is not so easy. In the last example the evaluation of the goal is obvious: first replace the functional term append <ref type="bibr">( [ l]</ref> , <ref type="bibr">[ 2 ]</ref> ) by the equivalent result term [ 1,2 1 and then proceed with the goal member ( E , <ref type="bibr">[1,</ref><ref type="bibr">2 ]</ref> ) as in logic programming.</p><p>However, what happens if the functional term contains free variables so that it cannot be evaluated to an equivalent term without the function call? For instance, consider the goal ?-append <ref type="bibr">(L, [3,41)</ref> = <ref type="bibr">[1,</ref><ref type="bibr">2,</ref><ref type="bibr">3,</ref><ref type="bibr">4]</ref>.</p><p>Clearly, the variable L should be instantiated to [ 1, 2 ] , which is the unique solution to this equation, but how can we compute such solutions? In general, we have to compute unifiers w.r.t. the given equational axioms which is known as E-uncjication <ref type="bibr">[44]</ref>. Replacing standard unification by E-unification in a resolution step yields a computational mechanism to deal with functions in logic programs <ref type="bibr">[43, 491.</ref> Unfortunately, E-unification can be a very hard problem even for simple equations (see [ 1161 for a survey). For instance, if we state the associativity of the append function by the equation append(append(L,M),N) = append(L,append(M,N) ).</p><p>then it is known that the corresponding E-unification problem is decidable, but there may exist an infinite set of pairwise incomparable E-unifiers. Thus a complete E-unification procedure must enumerate all these unifiers. Moreover, it is also known that E-unification is undecidable even for simple equational axioms like distributivity and associativity of functions <ref type="bibr">[115]</ref>. Therefore, van Emden and Yukawa 11281 state that "one of the reasons why logic programming succeeded where other resolution theorem proving had failed . . . was that in logic programming equality was avoided like the plague." Fortunately, there are restrictions on the definition of the equality predicate which are acceptable from a programming point of view and which ensure the existence of a usable E-unification algorithm.</p><p>In the beginning of research on amalgamated functional logic languages, many proposals were made to restrict the generality of the equality axioms and to develop appropriate execution principles (see <ref type="bibr">[31]</ref> for a good collection of these proposals and [9] for a short survey). Since these execution principles seemed complicated and were not implemented as efficiently as pure logic languages, logic programmers were often doubtful about the integration of functions into logic programming.</p><p>However, this has changed since new efficient implementation techniques have been developed for functional logic languages in recent years. In comparison to implementations of pure logic languages, these new techniques cause no overhead because of the presence of functions. Moreover, in many cases functional logic programs are more efficiently executed than their relational equivalents without using impure control features like "cut."</p><p>In the following text, we survey the operational principles and the implementation techniques of functional logic languages. Section 2 discusses the various operational semantics proposed for functional logic languages. We introduce basic notions by discussing computational methods for a rather general class of functional logic programs in Section 2.1. Then we consider the important subclass of constructor-based programs and discuss eager and lazy evaluation strategies in Sections 2.2 and 2.3. Section 2.4 highlights problems caused by conditional equations, and Section 2.5 introduces a completely different class of evaluation strategies which sacrifice completeness for the sake of efficiency. Implementations of these strategies are discussed in Section 3. Section 3.1 shows straightforward implementations by compiling into high-level languages, and Section 3.2 outlines the various low-level abstract machines developed for the execution of functional logic programs during the last few years.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">OPERATIONAL PRINCIPLES FOR FUNCTIONAL LOGIC LANGUAGES</head><p>In order to give a precise definition of the operational semantics of functional logic languages and to fix the notation used in the rest of this paper, we recall basic notions from term rewriting <ref type="bibr">[32]</ref> and logic programming <ref type="bibr">[83]</ref>. If 3 is a set offunction symbols together with their arity2and X is a countably infinite set of variables, then I(F', X) denotes the set of terms built from 3 and X. If t @ K, then 'Flead(t) is the function symbol heading term t. Var(t) is the set of variables occurring in a term t (similarly for the other syntactic constructions defined below, like literal, clause, etc.) A ground term t is a term without variables, i.e., Vur(t) = 0. A substitution o is a homomorphism from 1(3, X) into I(F, X) such that its domain Dam(a) = {x E X 1 CT(X) # x) is finite. We frequently identify a substitution o with the set {x~+a(x) 1 x E Dam(a)}. The composition oftwo substitutions C#J and u is defined by 4 o a(x) = $(a(~)) for all x E X. A unijier of two terms s and t is a substitution fl with u(s) = o(t). A unifier (T is called most general (mgu) if for every other unifier o', there is a substitution 4 with (T' = 4 o 0. A position p in a term t is represented by a sequence of natural numbers, t Ip denotes the subterm oft at position p, and t[s], denotes the result of replacing the subterm tip by the term s (see <ref type="bibr">[32]</ref> for details). If p and q are positions, we write p 5 q if p is a prefix of q . p . q denotes the concatenation of positions p and q.</p><p>Let + be a binary relation on a set S. Then -+* denotes the transitive and reflexive closure of the relation -+, and ++* denotes the transitive, reflexive, and symmetric closure of -+. + is called terminating if there are no infinite chains et + e2 -+ eg + . . . . -+ is called conjkent if for all e, et, e2 E S with e -+* et and e +* e2, there exists an element e3 E S with et +* eg and e2 +* e3.</p><p>2For the sake of simplicity, we consider only single-sorted programs in this paper. The extension to many-sorted signatures is straightforward [ 1061. We also assume that F contains at least one constant.</p><p>Let P be a set of predicate symbols including the binary equality predicate =. A literal p(t1,..., tn) consists of an nary predicate symbol applied to n argument terms. An equation is a literal with = as predicate symbol. We use the infix notation tl = t2 for equations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A clause has the form</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">I. A Sound and Complete E-UniJication Method: Narrowing</head><p>If we have to evaluate a function applied to ground terms during unification in a functional logic program, we can simply evaluate this function call as in functional languages by applying appropriate rules to this call. For instance, the function call append ( [ I , [ 2 1 ) is evaluated by matching the left-hand side of the first rule for append against this call (this binds variable L in the equation to [ 2 ] ) and replacing this function call by the instantiated right-hand side of the rule (i.e., <ref type="bibr">[ 2 ]</ref> ). This is called a rewrite step. Generally, t + p s is a rewrite step if there exist a position p, a rule I= r E P,4and a substitution CJ with t Ip = a(Z) and s = t[a(r)lp.</p><p>In this case t is called reducible (at position p). The term t is irreducible or in normalform if there is no term t' with t +p t'. If the program P is known from the context, we omit the index p in the rewrite arrow. For instance, the ground term append If there is a function call containing free variables in arguments, then it is generally necessary to instantiate these variables to appropriate terms in order to apply a rewrite step. This can be done by using unification instead of matching in the rewrite step which is called narrowing [ 1191. Hence, in a narrowing step we unify a (nonvariable) subterm of the goal with the left-hand side of a rule and then we replace the instantiated subterm by the instantiated right-hand side of the rule. To be precise, we say a term t is narrowable into a term t' if:</p><formula xml:id="formula_3">( [ 1, 2 ] , [<label>3</label></formula><p>1. p is a nonvariable position in t (i.e., tip $ X).</p><p>2. 1 = r is a new variant50f a rule from P.</p><p>3. The substitution D is a mgu of t I,, and 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">t' = o(t[r],).</head><p>3The completeness of some particular operational semantics requires more conditions on conditional equations like the absence of extra variables in conditions. We will discuss these restrictions later.</p><p>4At the moment we consider only unconditional rules. The extension to conditional rules is discussed in Section 2.4. 5Similarly to pure logic programming, rules with fresh variables must be used in a narrowing step in order to ensure completeness.</p><p>In this case, we write t -Q,,~=~,~I t' or simply t -+pr,o~ t' or t -.+,, t' if the position or rule is clear from the context. If there is a narrowing sequence to -.A~, tl ^"t02 . The final equation can be immediately proved by standard unification which instantiates E to 1. Therefore, the computed solution is <ref type="bibr">[ 11 }.6</ref> Narrowing is a sound and complete method to solve equations w.r.t. a confluent and terminating set of rules E. In order to state a precise proposition on soundness and completeness, we call an equation s = t valid (w.r.t. an equation set E) ifs *&gt; t. By Birkhoff's completeness theorem, this is equivalent to the semantic validity of s = t in all models of E. Therefore, we also write s =E t in this case. Now narrowing is a sound and complete E-unification method in the sense of the following theorem.7</p><p>Theorem 2.1 <ref type="bibr">(H&amp;lot [69]</ref>). Let E be a$nite set of unconditional equations so that +E is confluent and terminating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">(Soundness) Ifs = t -_Tr s' = t' and w is a mgu for s' and t', then &amp;o(s)) =E /-Go(t)). 2. (Completeness) If o'(s)=Eo'(f),</head><p>then there exist a narrowing derivation s = t -z s' = t', a mgu p for s' and t', and a substitution $ with @(p(a(x))) =E a'(x) for all x E Var(s) U Var(t).</p><p>The first proposition states that each substitution computed by narrowing is a unifier w.r.t. E, and the second proposition ensures that each unifier w.r.t. E is covered by a more general computed substitution. This theorem justifies narrowing as the basis to execute functional logic programs. The confluence requirement can often be established by applying a Km&amp;/Bendix completion procedure to transform a set of equations into a corresponding confluent one <ref type="bibr">[77]</ref>. As an alternative, there exist syntactic restrictions which ensure confluence (orthogonal rules) <ref type="bibr">[32]</ref> (see also Section 2.3).</p><p>It is well known that the termination requirement for the completeness of narrowing can be dropped if the class of substitutions is restricted. A substitution (T is called normalized if a(x) is in normal form for all x E Dam(o). If E is a finite set of unconditional equations so that --+E is confluent (and not necessarily terminating), then narrowing is complete w.r.t. normalized substitutions (i.e., the second proposition of Theorem 2.1 holds if a' is normalized).</p><p>The difficulty in a narrowing derivation is the application of a suitable rule at an appropriate subterm in a goal. For instance, if we apply the first append rule to the goal append <ref type="bibr">(L, 12]</ref>)=[1,2l,wewouldobtainthenewgoal t21=11,2l,whichisunsolvable. In general, there is no answer to this problem. In order to be complete and to find all possible solutions, Theorem 2.1 implies that each rule must be applied at each nonvariable subterm of the given goal. Hence using this simple narrowing method to execute functional 6For the sake of readability, we omit the instantiation of clause variables in the substitutions of concrete narrowing derivations.</p><p>7Although we have defined rewrite and narrowing steps only on terms, it is obvious how to extend these definitions to literals and sequences of literals. logic programs yields a huge search space and many infinite paths even for simple programs. In order to use narrowing as a practical operational semantics, further restrictions are necessary which will be discussed in the following text.</p><p>An important restriction which has been known for a long time is basic narrowing <ref type="bibr">[69]</ref>. This means that a narrowing step is only performed at a subterm which is not part of a substitution (introduced by previous unification operations Since the last equation is not syntactically unifiable, there exists no solution to the initial equation. This example shows that the restriction to basic positions can reduce an infinite search space to a finite one.</p><p>Although the number of admissible narrowing positions is reduced and therefore the search space is smaller compared to simple narrowing, basic narrowing is sound and complete in the sense of Theorem 2.1. The important aspect of the basic strategy is that searching for narrowing positions inside substitutions for program variables is superfluous. All such positions must be present in the program, i.e., in the initial term or in the right-hand sides of rules. As we will see in Section 3.2.1. this is the key for an efficient compiier-based implementation of narrowing since the basic narrowing positions can be computed at compile time.</p><p>It is interesting to note that basic narrowing can give a sufficient criterion for the termination of all narrowing derivations:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2.1 (Termination of narrowing [69])</head><p>. Let E = {li = ri 1 i = 1, . . . , n) be a finite set of unconditional equations so that +E is confluent and terminating.</p><p>If any basic narrowing derivation starting from any ri terminates, then all basic narrowing derivations starting from any term are finite.</p><p>Therefore basic narrowing is a decision procedure for E-unification if the conditions of the last proposition hold. In particular, this is the case when all right-hand sides of the rules are variables as in Example 2.1.</p><p>The basic narrowing positions can be further restricted by also discarding those narrowing positions which are strictly left of the position used in a narrowing step. This strategy is called left-to-right basic narrowing and remains to be complete (see 1641 for details). The set of admissible basic narrowing derivations can also be restricted by introducing redundancy tests like normalization properties of the computed substitutions.</p><p>Using a sophisticated set of such tests one can obtain a narrowing procedure where each different narrowing derivation leads to different computed solutions (LSE-narrowing [ 121).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Narrowing Strategies for Constructor-Based Programs</head><p>In order to implement a functional logic language based on basic narrowing we have to manage the set of basic positions and we try to apply all rules at all basic positions in each step. That yields a highly nondeterministic execution principle. On the other hand, pure functional languages deterministically select the position where rules are applied next (innermost position for eager languages and outermost position for lazy languages). An approach to achieve a similar strategy for functional logic languages is the partition of the set of function symbols into a set C of constructors and a set D of dejined functions. Constructors are used to build data types, whereas defined functions operate on these data types. Constructor terms (terms from I(C, X)) are always irreducible, whereas defined functions are defined by rules. According to [41], we call a term innermost if it has the form f (tl, . . . , t,), where f E D and tl, . . . , tn E I(C, X). A functional logic program is constructor-based if the left-hand side of each rule is an innermost term. In constructorbased programs, rules like append(append(L,M),N) = append(L,append(M,N))'. rev(rev(L)) = L.</p><p>are excluded. However, the requirement for constructor-based programs is not a real restriction if we are interested in application programs rather than formulae specifying abstract properties of functions. This is also confirmed by the fact that this restriction on rules is also present in pure functional (and pure logic) programming languages.</p><p>In constructor-based functional logic programs, we can solve equations by innermost narrowing <ref type="bibr">[41]</ref>, which means that the narrowing position must be an innermost term. Innermost narrowing corresponds to eager evaluation (call-by-value) in functional languages. Since innermost narrowing requires the evaluation of inner terms even if it is not necessary to compute an E-unifier, the computed solutions are sometimes too specific. Therefore, innermost narrowing is incomplete, in general (in the sense of Theorem 2.1), as the following example shows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.2.</head><p>Consider the following rules where a is a constructor:</p><formula xml:id="formula_4">f(X) = a. g(a) = a.</formula><p>Since f is a constant function mapping all inputs to a, the identity substitution { } is a solution of the equation f ( g (x) ) =a. However, the only innermost narrowing derivation is f (Cl (Xl ) =a - (Xb-+a]   f(a)=a "$11 a=a , i.e., innermost narrowing computes only the more specific solution (%+a}.</p><p>To formulate a completeness result, <ref type="bibr">Fribourg [41]</ref> considered ground substitutions, i.e., substitutions ~7 with o(x) ground for all x E 270,(g).</p><p>Unfortunately, this is not sufficient for completeness even if the rules are confluent and terminating, because innermost narrowing has problems with partially defined functions. Fribourg presented various additional conditions to ensure completeness. The most important one is: innermost narrowing is complete if all functions are totally de$ned, i.e., the only irreducible ground terms are constructor terms. The next example shows the incompleteness of innermost narrowing in the presence of partial functions.</p><p>Example 2.3.</p><p>Consider the following rules, where a and b are constructors:</p><formula xml:id="formula_5">f(a,Z) = a. g(b) = b.</formula><p>If we want to solve the equation f (X, g (X) ) =a, then there is the successful narrowing derivation f (X, g(X) ) =a -(X-a] a=a by applying the first rule to the term f (X, g (X) ) , i.e., {x-a} is a solution of the initial equation. However, this derivation is not innermost, and the only innermost narrowing derivation is not successful:</p><formula xml:id="formula_6">f(x,g(x) )=a -(X++b) f(b,b)=a .</formula><p>Therefore, innermost narrowing cannot compute the solution.</p><p>If E is a finite set of constructor-based unconditional equations so that -+E is confluent and terminating and all functions are totally defined, then innermost narrowing is complete w.r.t. ground substitutions (i.e., the second proposition of Theorem 2.1 holds ifa' is aground substitution). The restriction to totally defined functions is not so serious from a practical point of view. In practice, most functions are totally defined, and irreducible innermost terms are usually considered as failure situations. If one wants to deal with partially defined functions, it is also possible to combine the innermost strategy with basic narrowing <ref type="bibr">[66]</ref>. The idea of this innermost basic narrowing strategy is to skip over calls to partially defined functions by moving these calls to the substitution part. Due to the basic strategy, these calls need not be activated in subsequent computation steps. For a precise description we represent an equational literal in a goal by a skeleton and an environment part [66, 1031: the skeleton is an equation composed of terms occurring in the original program, and the environment is a substitution which has to be applied to the equation in order to obtain the actual literal. The initial equation E is represented by the pair (E; { 1). If (E; a) is a literal (E is the skeleton equation and u is the environment), then a derivation step in the innermost basic narrowing calculus is one of the following two possibilities. Let p be an innermost position, i.e., E IP is an innermost term:  Innermost basic narrowing is complete for a confluent and terminating constructor-based set of rules <ref type="bibr">[66]</ref>. For instance, a solution of the equation f (X, g (x) ) =a w.r.t. the rules of Example 2.3 will be computed by an innermost reflection step followed by an innermost basic narrowing step:</p><formula xml:id="formula_7">(f(X,s(X))=a;]l) - (f(X,Y)=a;W-+g(X)]) - (a=a; {X-a, Yt+g (a) }),</formula><p>In order to get rid of the various innermost positions in a derivation step, it is possible to select exactly one innermost position for the next narrowing step similarly to the selection function in SLD-resolution (selection narrowing [ 181). For instance, the operational semantics of the functional logic language ALF [53] is based on innermost basic narrowing with a leftmost selection strategy. This has the advantage that the position in the next derivation step is unique and can be precomputed by the compiler (see Section 3.2.1).</p><p>Unfortunately, all these improvements of the simple narrowing method are not better than SLD-resolution for logic programs since <ref type="bibr">Bosco et al. [ 181 have</ref> shown that leftmost innermost basic narrowing is equivalent to SLD-resolution with the leftmost selection rule if we translate functional logic programs into pure logic programs by a flattening transformation (see also Section 3.1). Therefore, we need more sophisticated narrowing methods in order to obtain a real advantage of the integration of functions into logic programming. Fortunately, there are two essential improvements to eliminate unnecessary narrowing derivations. First of all, innermost narrowing strategies have the disadvantage that they continue computations at inner positions of an equation even if the outermost symbols are not unifiable. Therefore, they are too weak in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.4.</head><p>Consider the following rules that define the addition on natural numbers which are constructed by 0 and s:</p><formula xml:id="formula_8">0 + N = N. s(M) + N = s(M+N) .</formula><p>Then there is the following infinite innermost narrowing derivation of the equation x+y=o:</p><formula xml:id="formula_9">X+Y=O ^C)(XHS(X1)) s(Xl+Y)=O -+[Xl++S(X2)) s(s(X2+Y))=O - "..</formula><p>This derivation can be avoided if we check the outermost constructors of both sides of the derived equation: after the first narrowing step the equation has the outermost symbols s and 0 at the left-and right-hand side, respectively. Since these symbols are different constructors, the equation can never be solved. Hence we could stop the derivation at that point.</p><p>The rejection rule motivated by this example is generally defined as follows:</p><p>Rejection:</p><p>If the equations = t should be solved and there is a position p ins and t such that 'Ftead(s lP) # 'Head(t Ip) and tieud(sl,~), Xead(t lpf) E C for all prefix positions p' 5 p, then the equation is rejected, i.e., the narrowing derivation immediately fails.</p><p>Example 2.4 shows that the application of the rejection rule after each narrowing step is a useful optimization to reduce the search space of all narrowing derivations.</p><p>The rejection rule terminates a superfluous narrowing derivation if there are different constructors at the same outer position.*However, if there are defined function symbols around these constructors, the equation cannot be rejected since the defined functions may evaluate to the same term. Therefore, it is important to evaluate functions as soon as possible in order to apply the rejection rule and to eliminate useless derivations.</p><p>For instance, consider the rules for addition of Example 2.4 together with the following rules defining a sum function on naturals:</p><formula xml:id="formula_10">sum(O) = 0. sum(s(N)) = s(N) + sum(N).</formula><p>Then innermost narrowing applied to the equation sum (X) =s ( <ref type="formula">0</ref>) has an infinite search space due to the following infinite narrowing derivation: The rejection rule cannot be applied since the head symbol of the left-hand side of the derived equations is always the defined function +. The situation can be improved if we evaluate the function call to + as soon as possible. That is, if the first argument to + is a term headed by the constructor 0 or s, we can rewrite this function call using the corresponding rule for +. Since rewriting does not bind free variables but replace terms by semantically equal terms, it is a solution preserving transformation. Moreover, repeated application of rewrite steps terminates due to the requirement for a terminating set of rewrite rules. Therefore, it is reasonable to rewrite both sides of the equation to normal form between narrowing steps. The last equation is rejected since the first subterms of the left-and right-hand side are headed by the different constructors s and 0.</p><p>Normalizing narrowing yields more determinism in narrowing derivations. Since the rules are required to be confluent and terminating, normal forms are unique and can be computed by any rewriting strategy. Therefore, rewriting can be implemented as a deterministic computation process like reductions in functional languages, whereas narrowing needs a nondeterministic implementation as in logic languages, i.e., normalizing narrowing unifies the operational principles of functional and logic programming languages in a natural way <ref type="bibr">[35, 361.</ref> The computation of the normal form before a narrowing step implements a strategy where we compute in a deterministic way as long as possible. This may reduce the search space since there are less and shorter normalizing narrowing derivations compared to simple narrowing.</p><p>Example 2.5.</p><p>Consider the following rules for multiplication:</p><p>x * 0 = 0. 0*x=0. but there is only one normalizing narrowing derivation, since the left-hand side can immediately be rewritten to 0 using the second rule:</p><formula xml:id="formula_11">O*N=O + o=o .</formula><p>Thus the preference of deterministic computations can save a lot of time and space (see [55, 781 for benchmarks).</p><p>If t is a large term, then normalizing narrowing immediately deletes t in the term 0 *t by rewriting with the first rule, whereas an innermost narrowing strategy would evaluate this term by costly narrowing steps. The deletion of complete subterms has no correspondence in the equivalent logic programs. Hence normalizing narrowing is superior to SLD-resolution. This is due to the fact that rewriting operates on the term structure which is lost if functional logic programs are transformed into pure logic programs by flattening (cf. Section 3.1). The following example <ref type="bibr">[41]</ref> shows the difference between normalizing narrowing and SLD-resolution. Innermost basic narrowing with normalization is superior to SLD-resolution since SLDresolution is equivalent to innermost basic narrowing <ref type="bibr">[18]</ref>, but the normalization process may reduce the search space. In fact, it can be shown that any logic program can be transformed into a functional logic program so that the transformed program has at least the same efficiency as the original logic program but is more efficient in many cases <ref type="bibr">[56]</ref>. Hence, one of the main motivations of integrating functions into logic programming has been achieved by the innermost basic narrowing strategy with normalization.</p><p>The normalization process between narrowing steps reduces the search space and prefers deterministic computations, but it also has one disadvantage. Since the whole goal must be reduced to normal form after each narrowing step, the normalization process may be costly. However, a careful analysis of this process shows that rewrite steps are only applicable at a few positions after a narrowing step: since the goal is in normal form before the narrowing step is applied and the narrowing step changes only small parts of the goal, rewrite steps can be restricted to a small number of positions in the narrowed goal in order to compute a new normal form. In particular, rewrite steps could only be applied to the replaced subterm (instantiated right-hand side of the applied equation) and to function calls in the goal where an argument variable has been instantiated by the narrowing step. Thus it is sufficient to start the normalization process at these positions, proceed from innermost to outermost positions, and immediately stop if no rewrite step can be performed at a position (since the outer part of the goal is already in normal form). A more detailed description of this incremental rewrite algorithm can be found in <ref type="bibr">[57]</ref>. A further possibility to avoid rewrite attempts is the restriction of the set of rewrite rules. For instance, SLOG <ref type="bibr">[41]</ref> does not use conditional equations (cf. Section 2.4) for normalization in order to avoid a recursive normalization process in conditions. Such a restriction does not influence the soundness and completeness of the operational semantics, but may increase the number of nondeterministic computations steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Lazy Narrowing Strategies</head><p>The narrowing strategies discussed so far correspond to eager evaluation strategies in functional programming.</p><p>However, many modern functional languages like Haskell If we want to evaluate the function call first ( 0 , t ) , a lazy strategy does not evaluate t since it is not necessary in order to compute the result [ 1. This may avoid a lot of superfluous computations if the evaluation of t is expensive. Now consider the function from (N) , which computes the infinite list of naturals starting from N:</p><formula xml:id="formula_12">from(N) = [N( from(s (N) ) ] .</formula><p>Then lazy evaluation of the function call first ( s ( s ( 0 ) ) , from ( 0 ) ) yields the result [ 0 , s ( 0 ) ] , whereas an eager evaluation of the same function call would not terminate.</p><p>In order to apply the idea of lazy evaluation to functional logic languages, there is another class of narrowing strategies that are motivated by this lazy functional programming point of view. A corresponding lazy strategy for narrowing is outermost narrowing, where the next narrowing position must be an outermost one. Unfortunately, this strategy is incomplete as the following example shows <ref type="bibr">[38]</ref>.</p><p>Example 2.7.</p><p>Consider the following rules defining a function f:</p><formula xml:id="formula_13">f(O,O) = 0. f(s(X),O) = 1. f(X,s(Y)) = 2.</formula><p>We want to compute solutions of the equation f ( f ( I , J) , K) = 0. There is the following innermost narrowing derivation:</p><formula xml:id="formula_14">f(f(I,J) ,K)=O -[II+O.JI+O) f(O,K)=O -(KHO) o=o .</formula><p>Therefore, {It-+ 0, JH 0, Kt+ 0} is a solution of the initial equation. Although the rewrite rules are confluent and terminating, there is only one outermost narrowing derivation using the last rule:</p><formula xml:id="formula_15">f(f(I,J) ,K)=O -(Kws(Y)]</formula><p>2=0 .</p><p>Thus outermost narrowing cannot compute the above solution.</p><p>Echahed <ref type="bibr">[38,</ref><ref type="bibr">391 and Padawitz [</ref> 1051 have formulated strong restrictions to ensure the completeness of such outermost strategies.'In addition to confluence and termination of the rules, complete narrowing strategies must satisfy a uniformity condition. Uniformity means that the position selected by the narrowing strategy is a valid narrowing position for all substitutions in normal form applied to it. The outermost strategy is, in general, not uniform since in the last example the top position of the term f ( f ( I, J) , K) is not a valid narrowing position if we apply the substitution {KH 0) to this term. <ref type="bibr">Echahed [38]</ref> has proposed a more constructive condition for the completeness of narrowing strategies: all functions must be totally defined and the left-hand sides of all rules must be pairwise not strictly subunzjiuble. The latter condition means that two subterms at the same position of two left-hand sides are not unifiable by a nontrivial mgu (see <ref type="bibr">[38]</ref> for details). For instance, f ( 0, 0 ) and f ( s (x) , 0 ) are not strictly subunifiable (the mgu of the second arguments 0 and 0 is trivial), but f ( 0, 0 ) and f (X, s (Y) ) are strictly subunifiable since the mgu of the first arguments is the nontrivial substitution {XH 0). Since the requirement for not strictly subunifiable left-hand sides is not satisfied by many functional logic programs, [38] also contains a method to transform a program where all functions are totally defined over the constructors into a program satisfying Echahed's conditions.</p><p>As mentioned above, lazy evaluation strategies should also support the use of infinite data structures. Since the presence of infinite data structures violates the termination requirement on the rewrite relation, narrowing strategies for terminating programs like outermost narrowing are not sufficient. Hence there are various proposals for lazy narrowing strategies which do not require the termination of the rewrite relation <ref type="bibr">[27,</ref><ref type="bibr">47,</ref><ref type="bibr">95,</ref><ref type="bibr">1091</ref>. Lazy narrowing differs from outermost narrowing in the fact that lazy narrowing permits narrowing steps at inner positions if the value at this position is needed in order to apply a narrowing rule at an outer position. For instance, if we want to solve the equation f ( f ( I, J) , K) =0 w.r.t. the rules of Example 2.7, we cannot apply the first rule f ( 0, 0 ) =0 at the root position of the left-hand side unless the first argument f ( I, J) is evaluated to 0. Since the value of the subterm f ( I, J) is needed in order to decide the applicability of the first rule, lazy narrowing permits a narrowing step at the inner position. Hence a possible lazy narrowing derivation is</p><formula xml:id="formula_16">f(f(I,J) ,K)=O -+(IHO,JHO) f(O&lt;K)=O -+(KHO) o=o ,</formula><p>which is also an innermost narrowing derivation. However, in general, an inner narrowing step is allowed only if it is demanded and contributes to some later narrowing step at an outer position (see <ref type="bibr">[97]</ref> for an exact definition of a lazy narrowing redex).</p><p>In narrowing derivations, rules are always applied only in one direction. Hence the confluence of the associated rewrite relation is essential in order to ensure completeness. Since confluence is undecidable and cannot be achieved by completion techniques [77] if the rewrite relation is not terminating, functional logic languages with a lazy operational semantics have the following strong restrictions on the rules in order to ensure completeness [27,47,97]:</p><p>1. Constructor-based: The functional logic program is constructor-based. 9To be more precise, they have investigated conditions for the completeness of any narrowing strategy. However, their most interesting applications are outermost strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Left-linearity: The functional logic program is left-linear, i.e., no variable appears more than once in the left-hand side of any rule. strict equality, i.e., the equality holds only if both sides are reducible to the same ground constructor term. As a consequence, strict equality does not have the reflexivity property t = t for all terms t. In order to assign a denotation to terms like f ( 0 ) , the Herbrand universe is augmented with the constant I representing undefined values, and then completed into a complete partial order (see <ref type="bibr">[47,</ref><ref type="bibr">97]</ref> for more details). Since a lazy narrowing derivation requires a narrowing step at an inner position if the value is demanded at that position, it may be the case that values are demanded at different inner positions by different rules. For instance, consider again the rules of Example 2.7 andthegivenequationf (f(I,J) ,K)=O. Ifwetrytoapplytherulef (O,O)=Otosolve this literal, then the value of the subterm f ( I, J) is demanded, but it is not demanded if the rule f (X , s (Y) ) =2 is applied. Hence a sequential implementation of lazy narrowing has to manage choice points for different narrowing positions as well as choice points for different rules. In order to simplify such an implementation and to avoid backtracking due to different narrowing positions, it is desirable to transform functional logic programs into a corresponding uniform <ref type="bibr">program [95]</ref> which has the property that all rules are flat (i.e., each argument term of the left-hand side is a variable or a constructor applied to some variables) and pairwise not strictly subunifiable (cf. outermost narrowing). The implementation of the functional logic language BABEL proposed in [95] transforms the rules of Example 2.7 into the uniform program</p><formula xml:id="formula_17">f (X,0) = g(X). f(X,s(Y)) = 2. g(0) = 0. g(s(X)) = 1.</formula><p>where g is a new function symbol. Now it is clear that the evaluation of a function call of the form f ( tl , t2 ) always demands the value of the second argument t2.</p><p>In a sequential implementation of lazy narrowing using backtracking, problems may arise if the evaluation of a demanded argument yields infinitely many solutions. For instance, consider the rules <ref type="bibr">[52]</ref> one(O) = s(0). one(s(N)) = one(N). that define the constant function one. Then there are infinitely many narrowing derivations of one (X) to the constructor term s ( 0 ) with the bindings {XH 01, {XH s ( 0 ) }, (XI+ s ( s ( 0 ) ) 1, and so on. As a consequence, a sequential lazy narrowing derivation of the equation one ( one (X) ) =s ( 0 ) does not yield any result since the application of the first rule one ( 0 ) = s ( 0 ) requires the evaluation of the argument term one ( X) to 0. Since there are infinitely many evaluations of one (X) with result s ( 0 ) , the second rule is never tried. On the other hand, a sequential innermost narrowing implementation would compute the bindings enumerated above. This problem of a sequential implementation of lazy narrowing could be solved by a mixed evaluation strategy which combines lazy narrowing with innermost narrowing for demanded arguments. The value of the argument one (X) is demanded in the function call one (one (X) ) for all rules. Therefore, it is evaluated before any rule is selected. After this evaluation, the second rule is applied due to the result s ( 0 ) (see <ref type="bibr">[52]</ref> for more details).</p><p>The previous examples show that a lazy narrowing strategy is more difficult to define than a lazy reduction strategy for the evaluation of pure functional programs. This is due to the fact that we have to choose the position as well as the applied equation in a lazy narrowing step. In contrast to reduction, applying different equations at a particular position may yield different solutions. Furthermore, the attempt to apply different equations may require different arguments to be evaluated. As a consequence, a simple lazy narrowing strategy runs the risk of performing unnecessary computations.</p><p>The following example should explain this subtle point. Thus (X-0, BH true] is a solution of the initial equation.</p><p>To compute a further solution, we attempt to apply the second or third rule for 5, but in both cases it is necessary to evaluate the subterm X+Y. If we choose the rule O+N=N for the latter evaluation, we obtain the lazy narrowing derivation .</p><p>In the second narrowing step, only the first rule for 5 is applicable.</p><p>The computed solution {Xt+ 0, BH true} is identical to the previous one, but the latter derivation contains a superfluous step: to compute this solution, it is not necessary to evaluate the subterm X+Y.</p><p>TO avoid such unnecessary narrowing steps, it is possible to change the order of instantiating variables and applying rules: to evaluate a term of the form xct w.r.t. the previous example, at first we instantiate the variable X either to 0 or to s (_) , and then we decide whether it is necessary to evaluate the subterm t. The right instantiations of the variables and the choice of the appropriate rules can be determined by the patterns of the left-hand sides of the rules (see [7, 871 for more details). This strategy is called needed narrowing and is defined for so-called inductively sequential <ref type="bibr">programs [7]</ref>. The optimal@ of needed narrowing w.r.t. the length of the narrowing derivations and the independence of computed solutions is shown in <ref type="bibr">[7]</ref>. Another approach to avoid unnecessary computations in lazy narrowing derivations by using a sophisticated analysis of demanded arguments is presented in <ref type="bibr">[96]</ref>.</p><p>There are also other lazy evaluation strategies for functional logic programs which are slightly different from lazy narrowing presented so far. You [ 1321 defined outer narrowing derivations which have the property that no later narrowing step at an outer position can be performed earlier in the derivation. Some lazy narrowing strategies generate outer narrowing derivations, but not vice versa, since outer narrowing is able to deal with partial functions which are not reducible to constructor terms. However, outer narrowing has the disadvantage that its definition refers to entire narrowing derivation, whereas lazy narrowing steps have a locally oriented definition. Therefore, outer narrowing requires a more complicated implementation.</p><p>The implementation of the functional logic language K-LEAF [47] is based on a translation into pure logic programs by flattening nested expressions (cf. Section 3.1). However, the flattened programs are not executed by Prolog's left-to-right resolution strategy, but by the outermost resolution strategy. This strategy selects a literal f(t) = x for resolution only if the value of the result variable x is needed. It is related to lazy narrowing in the sense of the correspondence of narrowing derivations and resolution derivations [ 181.</p><p>One motivation for the integration of functions into logic programs is the opportunity to avoid nondeterministic computation steps during program execution in order to reduce the search space. In Section 2.2, we saw that this is possible w.r.t. eager narrowing strategies by the inclusion of a deterministic normalization process between narrowing steps. It is also possible to exploit the deterministic nature of functions in lazy narrowing derivations [88]: If a narrowing step in a lazy derivation is applied to a literal L and no variables from L are bound in this step, then all alternative rules can be discarded for this step due to the nonambiguity requirement of the rules. That is, in a sequential implementation the choice point for the alternative rules can be deleted. This determinism optimization may save space and time since some redundant narrowing steps are omitted. It should be noted that this optimization is a safe replacement of the Prolog "cut" operator because alternative clauses are discarded only if no solutions are lost. Since this is decided at run time, it is also called</p><formula xml:id="formula_18">dynamic cut 1881.</formula><p>Since lazy narrowing avoids many unnecessary computations due to its outermost behavior, one could have the impression that the inclusion of a normalization process as in innermost narrowing has no essential influence on the search space, especially if the determinism optimization is carried out. However, normalization can avoid the creation of useless choice points in sequential implementations and reduce the search space for particular classes of programs as the following example shows. The normalization of the last equation M* 0= s ( 0 ) with the inductive consequence X* 0 = 0 yields the simplified equation O=s ( 0 ) , which is immediately rejected."Due to the termination of this lazy narrowing derivation, the entire search space for this equation is finite. On the other hand, lazy narrowing without normalization or normalizing innermost narrowing with the same inductive consequence have infinite search spaces.</p><p>The last example shows the advantage of lazy narrowing with normalization. However, such strategies have been studied only for terminating rewrite rules <ref type="bibr">[33,</ref><ref type="bibr">59]</ref>.</p><p>loThe addition of the inductive consequence X*0=0 to the program rules is not reasonable since this would increase the search space, in general.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Conditional Equations</head><p>In the previous section, we discussed narrowing strategies to solve equations provided that functions are defined by unconditional equations. However, in many cases it is necessary or useful to define functions by conditional equations as the following definition of the maximum function shows:</p><formula xml:id="formula_19">max(X,Y) = X :- x .= Y. max(X,Y) = Y :- X =i Y.</formula><p>The declarative meaning of such conditional equations is inherited from standard logic programming: the equation must hold for each assignment that satisfies the conditions. To use conditional equations for term rewriting, various rewrite relations have been proposed. The most popular relation is based on the requirement that a conditional equation can be applied only if all equations in the condition part have a rewrite proof <ref type="bibr">[75]</ref>. Hence, the rewrite relation in the presence of conditional equations is defined as follows. Let I= r : -tl = t;, . , t,, = t; be a conditional equation, ' 't a term, and p a position in t. If there are a substitution u with t lp = (T (I) and terms u 1, . . . , u, with ti +* Ui and t( -+* ui for i = 1, . . , II, then t -+ t[a(r)lp. Note that this definition of conditional rewriting is recursive. Hence, the rewrite relation is undecidable for arbitrary conditional equations <ref type="bibr">[75]</ref>. In order to obtain a decidable rewrite relation, it is often required that for all substitutions (T the terms a(ti), (T (tl) in the condition must be smaller than the left-hand side (T (I) w.r.t. a termination ordering <ref type="bibr">[76]</ref> (see <ref type="bibr">[32]</ref> for more references). If this is the case for all conditional equations, the program is called decreasing (other notions arefair or simplifying <ref type="bibr">[76]</ref>).</p><p>If conditional equations are applied in narrowing derivations, it is also necessary to prove the conditions by narrowing rather than rewriting. <ref type="bibr">Kaplan [76]</ref> and <ref type="bibr">Hussmann [70]</ref> proposed narrowing calculi for conditional equations which have been adopted by many other researchers.</p><p>The idea is to extend narrowing derivations to lists or multisets of equations and to add the equations in the condition part to the current equation list if the conditional equation is applied in a narrowing step:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conditional narrowing:</head><p>Let G be a given goal (list of equations), p be a position in G with G],, # X, and A derivation in the conditional narrowing calculus successfully stops if there exists a mgu for all equations in the derived goal. Consider the standard rules for the function append (cf. Section 1) and the following conditional equation defining the function last:</p><formula xml:id="formula_20">last(L) = E :- append(R, [El ) = L.</formula><p>A solution to the equation last (L) =2 can be computed by the following derivation in the conditional narrowing calculus: I1 For the sake of simplicity we consider only equations in the condition part; the extension to predicates in conditions is straightforward by representing predicates as Boolean functions.</p><formula xml:id="formula_21">last(L)=2 ~1 1 append(R, [El ) =L. E=2 -(R,+ [ ] 1 [E]=L, E=2</formula><p>The final equation list is unifiable with mgu {E-2, LW [ 2 ] ), which is a solution of the initial equation. Instead of computing the mgu for all equations in one step, we could successively eliminate each equation by a reflection step which is more appropriate in efficient implementations of functional logic languages. In this case, a narrowing derivation successfully stops if the list of equations is empty.</p><p>Reflection: If Et, . . , E, is a given list of equations, El = s=t, and there is a mgu IS for s and t, then a(E2, . . . , E,) is the next goal derived by reflection, i.e., El,.</p><p>. . , E, -u 0(E2,.</p><p>. . , E,) is a step in the conditional narrowing calculus.</p><p>Similarly to the unconditional case, Hussmann [70] claimed soundness and completeness of the conditional narrowing calculus w.r.t. normalized substitutions if the associated term rewrite relation is confluent. However, conditional narrowing is much more complicated than unconditional narrowing since the proof of the equations in the condition part of a conditional equation requires a recursive narrowing process. Actually, subsequent work has shown that the use of conditional equations is more subtle, even if the term rewriting relation is confluent and terminating. One difficult problem is extru variables in conditions, i.e., variables in a condition which do not occur in the left-hand side of the conditional equation. Solving conditions with extra variables requires, in some cases, the computation of nonnormalized substitutions. Therefore Hussmann's results do not hold in full generality. It is easy to check that the associated rewrite relation is confluent and terminating. The equation b=c is valid w.r.t. these clauses (there exists a rewrite proof using the last clause and instantiating the extra variable X to a), but the only derivation in the conditional narrowing calculus is not successful: Holldobler [66] adapted the eager narrowing strategies for constructor-based programs (cf. Section 2.2) to conditional equations without extra variables. In particular, he showed completeness of conditional innermost basic narrowing with normalization in the presence of confluence and termination.</p><p>However, he has missed another problem of conditional equations which has been pointed out by <ref type="bibr">Middeldorp and Hamoen [94]</ref>: the termination of the rewrite relation does not imply the termination of the entire rewrite process due to the recursive structure of rewrite proofs in the conditional case.</p><p>Example 2.12. Consider the following conditional equations:</p><formula xml:id="formula_22">even(X) = true :-odd(X) = false. odd(X)</formula><p>= false :-even(X) = true.</p><p>The associated rewrite relation is terminating since at most one rewrite step can be performed to evaluate a term headed by even or odd. However, the conditional rewrite process, which has to check the validity of conditions, would loop due to the recursion in the conditions.</p><p>The difference between termination of the rewrite relation and termination of the conditional rewrite process raises no problems for simple narrowing, but it makes basic conditional narrowing incomplete as the next example shows. However, this derivation is not basic since the term d, which belongs to the substitution part after the first narrowing step, is reduced in the second and third narrowing step. In fact, it can be easily shown that there is no successful basic conditional narrowing derivation starting from the initial equation, i.e., basic conditional narrowing is incomplete even in the presence of confluence and termination. conditional equations.</p><p>In order to ensure completeness for the important basic restriction of conditional narrowing, the additional requirement for decreasing conditional equations (see above) is sufficient, i.e., in each conditional equation the condition terms must be smaller than the left-hand side w.r.t. some termination ordering. This requirement excludes extra variables in conditions, but it is also used in tools for checking confluence of conditional equations to ensure the decidability of the rewrite relation <ref type="bibr">[45]</ref> (although the confluence of decreasing conditional equations is only semidecidable <ref type="bibr">[32]</ref>). Nevertheless, extra variables can often be included in decreasing conditional equations by generalizing the latter notion to quasireductive equations [ 1 I] or by restricting the instantiation of extra variables to irreducible terms in the definition of decreasing rules [ 1071. A good survey on the completeness results of (basic) conditional narrowing w.r.t. different classes of equational logic programs can be found in <ref type="bibr">[94]</ref>.</p><p>The discussion on the completeness problems w.r.t. conditional equations may give the impression that functional logic languages are less powerful than logic languages due to the restrictions on extra variables in conditions and decreasing equations. However, these restrictions are necessary only if one wants to use the full power of functional logic languages by specifying functions by overlapping equations. On the other hand, this case rarely occurs, since functional programmers often write programs with (weakly) nonambiguous equations. This is also required in functional logic languages with a lazy operational semantics (cf. Section 2.3). For instance, the functional logic language BABEL [97] allows extra variables in conditions, i.e., each rule 1= r : -C must satisfy only the weak variable condition Var (r) 5 Vu(l) in addition to the usual constructor-based and left-linearity conditions (cf. Section 2.3). Moreover, weak nonambiguity is ensured by one of the following requirements on each pair of equations 11 = rl : -Cl and 12 = r2 : -C2:</p><p>1. 11 and 12 do not unify. 2. a is a most general unifier of 11, and 12, and a(rl) = o(r2). 3. 0 isamostgeneralunifieroflt and12, ando ando are together unsatisfiable (see <ref type="bibr">[97]</ref> for a computable approximation of the latter condition).</p><p>Note that there are no further restrictions like decreasing equations. Therefore, it is obvious that pure logic programming is a subset of BABEL since each relational clause L : -L 1, . , Lk can be translated into the rule L= true : -L1 = true,.</p><p>. . , Lk = true by representing predicates as Boolean functions. The latter conditional equations always satisfy condition 2 of BABEL's nonambiguity conditions. In this case, BABEL's operational semantics (lazy narrowing) corresponds to SLD-resolution, but with the additional feature of exploiting determinism by the dynamic cut [88] (cf. Section 2.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Incomplete Evaluation Principles</head><p>Although the narrowing principle is a sound and complete execution principle for functional logic programs which is more efficient than resolution for pure logic programs (provided that an appropriate narrowing strategy is chosen), it has one disadvantage in comparison to functional programming: if some argument value of a function call to be evaluated is not known, then a value must be guessed in a nondeterministic way. In order to avoid this nondeterminism in functional computations, several researchers have proposed reduction of functional expressions only if the arguments are sufficiently instantiated <ref type="bibr">[3, 14, 102, 1231.</ref> They propose the evaluation of functions only if it is possible in a deterministic way, and all nondeterminism should be represented by predicates. In this case, the basic operational semantics is SLD-resolution for predicates <ref type="bibr">[83]</ref> with an extended unification procedure such that a function call in a term is evaluated before unifying this term with another term. For instance, consider the following definition of the predicate square which relates a number with its square value: square(X, X*X) .</p><p>If a solution of the literal square ( 3 , Z) is computed, this literal must be unified with the literal of the square definition. Hence, 3 is unified with X in the first step. Thus X is bound to 3. Then Z is unified with 3 * 3 (the instantiated second argument). Since the second term is a function call, it is evaluated to 9 and, therefore, Z is bound to 9, which is the solution to this goal.</p><p>The important restriction in this modified unification process is that a function call is evaluated only if it does not contain a variable, i.e., if the function call is evaluable to a unique ground value. 13Therefore, the precise definition of functions is irrelevant. Functions may be defined by rewrite rules [ 1, 1021 or in a completely different language [ 14,821. The only requirement is that a function call must be evaluable if it does not contain variables and the result of the evaluation is a ground constructor term (or perhaps an error message).</p><p>This evaluation principle seems to be preferable to the narrowing approaches since it preserves the deterministic nature of functions, but it is also obvious that it is an incomplete method. For instance, the goal ?-v=3, square(V,9) can be successfully proved w.r.t. the above definition of square, but the logically equivalent goal ?-square(V, 9), V=3</p><p>leads to a failure: the first literal cannot be proved, since 9 and the unevaluable function call V*V are not unifiable (as in Prolog we assume a left-to-right evaluation strategy for goals). In order to avoid these kinds of failures, the evaluation and unification of functions is delayed until the arguments will be instantiated to ground terms. This mechanism is called residuation in Le Fun [3] and is also used in a similar form in LIFE <ref type="bibr">[ 11, NUE-Prolog [ 1021, and Funlog [123]</ref>. It has also been used to connect a logic language with an existing functional language (S-unification <ref type="bibr">[13, 141, P-unification [82]</ref>).</p><p>The residuation principle solves the first literal in the last goal by generating the residuation ~=v*v, which will be proved or disproved as soon as the variable V becomes ground.</p><p>After solving the second literal V=3, V will be bound to 3 and, therefore, the residuation 9 = 3 * 3 can be proved to be true. Hence the entire goal is true.</p><p>The delay principle for function evaluation is satisfactory in many cases, but it is still incomplete if functions are used in a logic programming manner as the following example shows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.14. [58].</head><p>Consider the function append of Section 1. Following the point of 13Some other languages based on this principle also allow evaluations with variables, but then it must be ensured that at most one possible alternative is applicable. Now consider the literal rev ( t a, b, c 1 , RI . Since the arguments of the calls to the function append are never instantiated to ground terms, the residuation principle cannot compute the valid answer R= <ref type="bibr">[c , b , a]</ref> . In particular, there is an infinite derivation path using the residuation principle and applying the second clause infinitely many times (see Figure <ref type="figure" target="#fig_20">1</ref>). The reason for this infinite derivation is the generation of more and more residuations for append by a repeated use of the second clause. At a particular point in the derivation these residuations are together unsolvable, but this is not detected by the residuation principle since the equations are simply delayed (hence they are sometimes called passive constraints 141). On the other hand, a functional logic language based on narrowing can solve this goal and has a finite search space <ref type="bibr">[55]</ref>. Therefore, it is not true that avoiding nondeterministic functional computations by the residuation principle yields a better operational behavior in any case.</p><p>The last example raises the important question for a decidable class of programs for which the residuation principle is able to compute all answers. Since residuation depends on the instantiation of variables in function calls, an accurate characterization of such programs must analyze the possible run-time bindings of the variables. Program analysis methods tailored to such completeness questions can be found in <ref type="bibr">[ 19,</ref><ref type="bibr">21,</ref><ref type="bibr">58]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.">Summary</head><p>In Table <ref type="table" target="#tab_0">1</ref>, we summarize the different execution principles for functional logic programs. Although the table enumerates an impressive number of different strategies, it is still incomplete, but it contains, from our point of view, the milestones and most relevant strategies to execute functional logic programs. In the table, we use the following abbreviations for the completeness requirements on the equational clauses: c: confluence T: termination CB:</p><p>constructor-based ID:</p><p>totally defined functions LFN:</p><p>left-linearity, free variables, and nonambiguity (cf. Section 2.3)</p><p>Similarly to pure logic programming, the execution principles are complete if the specified requirements are satisfied and afair search strategy like breadth-first is used. If we use an unfair search strategy like depth-first implemented by backtracking (as done in most implementations of functional logic languages), nontermination may occur instead of computable answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">IMPLEMENTING FUNCTIONAL LOGIC LANGUAGES</head><p>In this section we review methods used to implement functional logic languages. We restrict this overview to implementations on sequential architectures. Similarly to logic programming, functional logic languages can also be implemented on distributed architectures using concepts like AND-and OR-parallelism (see, for instance, <ref type="bibr">[ 16, 8 1, 1131)</ref>.</p><p>The first implementations of functional logic languages were based on interpreters written in high-level languages and thus could not compete with Prolog implementations based on the compilation of Prolog programs into low-level (abstract) machine code. For instance, early implementations of narrowing like the RAP system <ref type="bibr">[46]</ref> or NARROWER [ 1111, functional logic languages like LPG [lo] or SLOG <ref type="bibr">[41]</ref>, which are based on normalizing innermost narrowing, and the RITE system [73], a system implementing normalizing narrowing by sharing common parts of different solutions, were implemented in high-level languages like Ada, Pascal, or LISP. However, during recent years more advanced implementations have been developed which achieve the same efficiency as implementations of functional or logic languages. In principal, there are two approaches for the efficient implementation of a functional logic language14:</p><p>1. Compilation into another high-level language for which efficient implementations exist [ 1281. 2. Compilation into a low-level machine which is efficiently executable on conventional hardware.</p><p>In the following, we will discuss both alternatives in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Compilation into High-Level Languages</head><p>To implement a functional logic language, we need techniques to:</p><p>14We do not consider the possibility of constructing special hardware, since this alternative seems unreasonable.  Prolog offers built-in solutions for the first two requirements.</p><p>Therefore, it is reasonable to use Prolog as a target language for compiling functional logic programs. Since Prolog applies rules only at the top level (to predicates) and not to subterms of a literal, we have to avoid nested expressions in the target programs. This can be done byJIatteniag the program. A conditional equation 1= r : -L1, . . . , L, isflattened as follows:</p><p>1. If r contains the term f(tl , . . , t,), where f is a defined function, replace this term in r by a new variable Z and add the new condition f (tl , . . . , t,,) = Z. Flatten the new clause.</p><p>2. If some Li contains the subterm f (tl, . . . , t,,), where f is a defined function and this subterm is not the left-hand side in case of an equation, replace this subterm by a new variable Z and add the new condition f (tl , . . . , t,,) = Z. Flatten the new clause.</p><p>In a similar way, any other goal and relational clause containing defined function symbols is flattened. Such a flattening procedure has been used in this or a slightly modified form in <ref type="bibr">[8,</ref><ref type="bibr">18,</ref><ref type="bibr">92,</ref><ref type="bibr">124,</ref><ref type="bibr">1281</ref> to implement functional logic languages via SLD-resolution.</p><p>Example 3. I.</p><p>The flattened form of the rules for append and member (cf. Section 1) and the goal literal member The idea of flattening functional logic programs can also be applied to implement the residuation principle (cf. Section 2.5). Since residuation delays the evaluation of functions until the arguments are sufficiently instantiated, a Prolog system with coroutining [lOI] is necessary. In this case, clauses are flattened as described above, and for each function a delay declaration is added which forces the delay of function calls until arguments are instantiated 151f the symbol "=" is predefined to denote syntactic equality as in most Prolog systems, we have to use another operator symbol for equality.</p><p>such that at most one clause is applicable to the function call. An implementation with NU-Prolog as the target language is described in <ref type="bibr">[102]</ref>, and an implementation using delay predicates to connect an existing functional language to a Prolog system with coroutining is described in <ref type="bibr">[74]</ref>. It is also possible to implement lazy evaluation strategies by flattening if Prolog's evaluation strategy is slightly modified <ref type="bibr">[ 15, 231.</ref> The advantage of implementing narrowing by flattening is its simplicity: functional logic programs can be flattened by a simple preprocessor and then executed by a Prolog system. Due to the existing sophisticated Prolog implementations, we obtain an efficient implementation of a functional logic language with relatively little effort. However, this method also has an important disadvantage. While functional languages compute values in a deterministic way, our implementation is always nondeterministic since functions are mapped into predicates. For instance, if the rules for multiplication of Example 2.5 are given, then a functional language would deterministically evaluate the term 0 * 0 to 0 using one of the rules. On the other hand, a Prolog system would apply both rules, i.e., it computes in a nondeterministic way. Inserting cuts or delay declarations in a Prolog program may improve the efficiency, but it reduces the applicability of the logic program, in general. Moreover, cuts or delay declarations cannot avoid simple infinite loops as the following example demonstrates. if the second clause for append is applied to the first literal. Hence, Prolog runs into an infinite loop, which could be avoided only if the second literal is proved before the first one.</p><p>Hence, a logic language with an operational semantics that prefers the evaluation of deterministic literals (i.e., literals having at most one matching clause) would avoid the infinite loop in the last example. The Andorra computation model <ref type="bibr">[62]</ref> or Prolog with simplification 1421 have this property. Therefore, the flattening technique yields better results if the target of the transformation is a logic programming system with an extended computation model. If an efficient implementation of such an extended computation model is not available, it is also possible to simulate it with a standard Prolog system by a simple metainterpreter. <ref type="bibr">Cheong and Fribourg [24]</ref> developed a method to reduce the overhead of the metainterpreter by using partial evaluation techniques.</p><p>Nevertheless, flattening of functional logic programs into the Andorra computation model or into Prolog with simplification is less powerful than normalization due to the following reasons:</p><p>1. Normalization can delete subterms if there are rules with variables in the left-hand side that do not occur in the right-hand side (e.g., 0*X=0). The application of such rules during normalization would correspond to the deletion of literals in the flattened program. 2. Normalization evaluates terms even if more than one rule is applicable. For instance, the term 0 * 0 is normalized to 0 w.r.t. the multiplication rules of Example 2.5, which are not deterministic in the sense of <ref type="bibr">[42,</ref><ref type="bibr">62]</ref>.</p><p>Example 3.3. Consider the following program for computing the maximum of two natural numbers:</p><formula xml:id="formula_23">max(X,Y) = Y :- le(X,Y). max(X,Y) = X :- le(Y,X). le(O,N). le(s(M)</formula><p>,s(N)) :-le(M,N).</p><p>If we compute the maximum of two identical numbers, e.g., we want to solve the equation max(s(s(O)),s(s(O)))=Z,thenthesolution{z~s(s(O))}wouldbecomputedin a unique way in a functional language or by normalizing narrowing. However, applying SLD-resolution, Prolog with simplification, or the Andorra computation model to this program (it is already in flat form) yields the same solution twice because both max rules are applicable to this equation.</p><p>The last examples have shown the limitations of the flattening approach: it is not ensured that functional expressions are reduced in a purely deterministic way if all arguments of a function are ground values. This important property of functional languages is not preserved since the information about functional dependencies is lost by flattening. Moreover, flattening restricts the chance to detect deterministic computations by the dynamic cut (cf. Section 2.3) which is relevant especially in the presence of conditional equations <ref type="bibr">[88]</ref>. Therefore, several new implementation techniques have been developed for functional logic languages. The characteristic of these new approaches is the use of low-level abstract machines and the compilation of functional logic programs into the code of these machines. In the next section we sketch the basic ideas of these abstract machines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Compilation into Abstract Machines</head><p>The use of "abstract machines" is a well-known technique for the efficient implementation of functional and logic languages on standard hardware. On the one hand, abstract machines have a low-level architecture so that they can be simply compiled or efficiently emulated on standard hardware. On the other hand, the architecture of abstract machines is tailored to the execution of a particular high-level language, and this simplifies the compilation process in comparison to a direct compilation into real machine code. There are a lot of proposals for abstract machines to execute pure functional or logic languages. Since functional logic languages are extensions of pure functional or logic languages, it is a natural idea to extend one of the existing abstract machines to execute functional logic programs. In the following, we will see that this has been successfully translated into action.</p><p>3.2.1. EXTENDING ABSTRACT MACHINES FOR LOGIC LANGUAGES. Most Prolog implementations are based on the "Warren Abstract Machine" (WAM) [2, 1301 or on a refinement of it. The WAM supports logical variables, unification, application of clauses, and backtracking. This is also necessary in any implementation of a functional logic language and thus there are several proposals to extend the WAM in order to deal with narrowing and functional computations.</p><p>As discussed in the previous section, one possible implementation of narrowing is flattening and applying SLD-resolution. If a lazy evaluation principle as in K-LEAF <ref type="bibr">[47]</ref> is implemented, it is necessary to apply a modified resolution strategy where a literal is activated only if it is needed.</p><p>Example 3.4. [ 151 Consider the following functional logic program which is already in flat form:</p><formula xml:id="formula_24">P(1,2) :-q(O). q(O). f(1) = 1. f(2) = 1.</formula><p>In order to prove the literal p ( f (X) , X) , it is transformed into the flat form</p><formula xml:id="formula_25">?-P(V,X), f(X) = v.</formula><p>The new variable V, which is introduced during flattening, is also called produced variable. The outermost resolution strategy selects an equational literal only if the value of its produced variable is required. Hence, the literal p (V, X) is selected in the first resolution step. Applying the first clause yields the bindings (T = (vt-+ 1, X+-+2} and the derived goal</p><formula xml:id="formula_26">?-q(O), f(2) = 1.</formula><p>Since the produced variable v has been instantiated, the literal c (f (x) =v) is selected in the next step (instead of q ( 0 ) ). The application of the fourth clause to this literal generates the new goal q ( 0 ) , which is immediately proved by the second clause.</p><p>To implement this selection strategy, it is necessary to link a produced variable u with the corresponding equational literal f(t) = u. This is implemented in the K-WAM [ 151, an extension of the WAM to implement the outermost resolution strategy of K-LEAF. In the K-WAM each produced variable u contains a pointer to its equational literal f(t) = u. If IJ is instantiated to a nonvariable term during unification, the corresponding literal f(t) = v is added to a global list (force list). The literals in the force list are proved immediately after the unification of the head literal. Therefore, the only changes to the WAM are a new representation for produced variables, a modification in the unification procedure to deal with produced variables, and a switch to the force list after the head unification. All other aspects are fully inherited from the WAM.</p><p>It is interesting to note that <ref type="bibr">Cheong [23]</ref> showed that the outermost strategy can also be implemented in Prolog without any modification of the WAM. For this purpose, it is necessary to compile K-LEAF programs into Prolog programs by changing the representation of terms (in particular, produced variables) and adding clauses for the evaluation of these new terms (see <ref type="bibr">[23]</ref> for details).</p><p>We have seen in Section 3.1 that the flattening approach is problematic if a deterministic computation principle like normalization is included. Fortunately, it is relatively easy to extend the WAM to a direct inclusion of narrowing and normalization.</p><p>To describe the necessary extensions, we recall the main data areas of the WAM: One possible approach is implemented in the A-WAM <ref type="bibr">[53,</ref><ref type="bibr">55]</ref>, an extension of the WAM to implement the functional logic language ALE The operational semantics of ALF is based on SLD-resolution for predicates combined with normalizing innermost basic narrowing for functions which can be specified by conditional equations <ref type="bibr">[53]</ref>. To support term manipulation, the A-WAM has instructions to replace terms in the heap by new terms. These replacements are also stored on the trail in order to undo them in case of backtracking. Using these new instructions, function rules can be compiled similarly to clauses for predicates.</p><p>The main problem for the efficient implementation of an innermost narrowing strategy is the access to the current leftmost innermost subterm in the next narrowing step. A simple solution would be a dynamic search through the term. Obviously, this is too slow. Fortunately, the compiler can determine this position since we use a basic narrowing strategy. Recall that in basic narrowing, all narrowing positions must belong to the initial goal or to the right-hand side of some rule, but not to the substitution part. Consequently, the compiler can compute the basic positions in leftmost innermost order. For instance, if f (g (X) , h (Y) ) is the right-hand side of some rule, then the basic positions are the ones belonging to the subterms g (X) , h (Y) , f ( g (X) , h (Y) ) (in leftmost innermost order). In addition to the WAM, the A-WAM has an occurrence stack, where the basic positions of the current literal are stored in leftmost innermost order, i.e., the top element of this stack is always the leftmost innermost position of the current literal. The compiler generates instructions for the manipulation of the occurrence stack. For instance, if a rule with no defined function symbol on the right-hand side is applied, like 0+X=X, then the compiler generates a pop instruction for the occurrence stack in the translated code of this rule. Similarly, push instructions are generated for right-hand sides containing defined function symbols.'%e push and pop instructions are generated along with the usual term building instructions t6Note that only occurrences of defined function symbols are stored on the occurrence stack since the program is constructor-based and there are no rules for constructors.</p><p>of the WAM and cause no real overhead. The advantage of this approach is the access of the next narrowing position in constant time.</p><p>Altogether, a rule 1 = r is translated into the following scheme of A-WAM instructions:</p><p>(unify the left-hand side 1 with the current subterm) , (replace the current subterm by the right-hand side r) , (update the occurrence stack (delete or add occurrences)) , (proceed with normalization/narrowing at new innermost occurrence)</p><p>The rules used for normalization are translated in a similar way, but the unification of the left-hand side is replaced by matching (unification without instantiating goal variables). Moreover, choice points are not generated during normalization due to its deterministic nature.</p><p>The normalization process before each narrowing step causes a problem since it tries to simplify the current term by applying normalization rules from innermost to outermost positions in the term. If no normalization rule can be applied to a subterm, the next innermost position is tried, i.e., an element is popped from the occurrence stack. This is necessary as the following example shows: If the only rules for the functions f and g are f(Z) = 0. g(0) = 0.</p><p>then the term g (X) cannot be rewritten (only narrowing could be applied), but the term f(c(g(X))) canbesimplifiedtoo. Hence the normalization process pops all elements from the occurrence stack and, therefore, the stack is empty when normalization is finished and a narrowing rule should be applied. Now, in order to avoid a dynamic search for the appropriate innermost occurrence, the A-WAM has a second stack (copy occurrence stack) for storing the deleted occurrences. This stack contains all occurrences if normalization is finished and the original occurrence stack is empty. Thus the occurrence stack can be reinstalled by a simple block-copy operation.</p><p>The advantage of the A-WAM is its efficiency in comparison to the original WAM: a dynamic search inside the term structure can be avoided and the code of the compiled functional logic programs is very similar to the WAM code of the corresponding logic programs obtained by flattening (see <ref type="bibr">[55]</ref> for examples). The overhead of the occurrence stack manipulation is small (around 5%), and the execution of pure functional programs is comparable with implementations of functional languages due to the deterministic normalization process (see <ref type="bibr">[55]</ref> for benchmarks). In Sections 2.2 and 3.1 we saw that a normalizing narrowing strategy is more efficient than SLD-resolution for the flattened programs since the deterministic normalization process can reduce the search space. These theoretical considerations can be proved, in practice, if an efficient implementation of normalizing narrowing like the A-WAM is available. For instance, in the "permutation sort" program, a list is sorted by enumerating all permutations and checking whether they are sorted. The relational version of the program <ref type="bibr">([ 1221, p. 5.5</ref>) enumerates all permutations whereas in the functional version not all permutations are enuaerated since the generation of a permutation is stopped (by normalizing the goal to "fail") if two consecutive elements X and Y have the wrong ordering YIX ([41] p. 182). As a consequence, the A-WAM yields the execution times in seconds onaSun4tosortthelist</p><p>[n, . . . , 2 , 1 I for different values of n [55] as shown in Table <ref type="table" target="#tab_2">2</ref>. In such typical "generate-and-test" programs, the normalization process performs the test part and the narrowing steps perform the generate part of the program. Due to the strategy of normalizing narrowing, the test part is merged into the generate part, which yields a more efficient control strategy than SLD-resolution for equivalent logic programs. This is achieved in a purely clean and declarative way without any user annotations to control the proof strategy. More details on this control aspect can be found in <ref type="bibr">[56]</ref>. Although the permutation sort example is only a toy program, larger applications have been implemented in ALF in order to test the suitability of normalizing narrowing as an operational semantics for functional logic languages. It turns out that the normalization process between narrowing steps is not an overhead even if it does not reduce the search space: most computations are performed by normalization, and narrowing steps are applied only at some few positions. Hence, rewrite steps are the rule and narrowing steps are the exception, in practice. This is similar to the experience that in practical logic programming most computations are functional. Therefore, functional logic languages can help to implement these functional subcomputations in a more efficient way. <ref type="bibr">Muck [98]</ref> has also developed a technique to compile narrowing into a WAM-like architecture. Although he has not included normalization and an efficient management of occurrences in his framework, the proposed method can be used to derive some of the instructions of an abstract narrowing machine in a systematic way: he has shown how functional logic programs can be translated into low-level instructions using partial evaluation techniques.</p><p>3.2.2. EXTENDING ABSTRACT MACHINES FOR FUNCTIONAL LANGUAGES. Another alternative to implement functional logic languages is the extension of abstract machines used for the implementation of pure functional languages. If the functional logic language is based on some kind of narrowing, the necessary extensions are the implementation of logical variables, unification, and backtracking.</p><p>Loogen [ 861 has extended a reduction machine to implement a subset of the functional logic language BABEL <ref type="bibr">[97]</ref>. Reduction machines are designed to compile functional languages. Their main components are a stack of environments (local variables and actual arguments) for function calls and a heap or graph structure to store data terms. The evaluation process is controlled by the stack, i.e., the stack contains the environments for function calls in innermost order if an eager evaluation strategy is implemented.</p><p>In order to implement an innermost narrowing strategy, Loogen has extended such a reduction machine by variable nodes in the graph to represent logical variables and by choice points in the environment stack and a trail to organize backtracking. The overall structure of this narrowing machine is similar to the WAM, but with an explicit data stack to pass arguments and results of function calls. This data stack allows a better management of choice points. Since normalization is not included, defined function symbols need not be represented in the heap. They are directly translated into call instructions of the reduction machine. For instance, an expression like f ( g (X) ) is translated into the instructions load X % load contents of X on the data stack call g/1 8 call code of function g with one argument call f/l % call code of function f with one argument (see <ref type="bibr">[86]</ref> for a formal specification of the machine and the compilation process). The resulting code is very similar to the WAM code obtained by flattening the functional logic program (as described in Section 3.1) and translating the logic program as usual. However, the proposed narrowing machine has an important optimization in comparison to the WAM: if the application of a rule does not bind any goal variables, then the choice point corresponding to this rule is discarded so that alternative rules are not tried (dynamic cut; cf. Section 2.3). This is implemented by a pop instruction which checks the variable bindings after the unification of the left-hand side of the rule <ref type="bibr">[88]</ref>. Due to this optimization, pure functional computations without logical variables are performed with the same deterministic behavior as in pure functional languages. However, there remains a small overhead since choice points are generated and then immediately deleted. As discussed in Section 2.2, pure innermost narrowing is too weak for many applications due to nonterminating derivations. Therefore, [86] also outlines an implementation of lazy narrowing by introducing suspension nodes in the heap representing unevaluated function calls. <ref type="bibr">Chakravarty and Lock [22]</ref> have proposed an abstract machine for lazy narrowing which is an extension of a stack-based reduction machine used to implement functional languages with a lazy evaluation principle. The instruction code of their JUMP machine is a blockstructured intermediate language so that classical code generation techniques can be applied. The main data areas of their machine are a stack for activations records of functions and choice points, a heap to store environments and closures representing logical variables and unevaluated function calls, and a trail to store bindings which must be reset in case of backtracking. Constructor terms, logical variables, and suspended function calls are treated in a similar way: their current value is obtained by jumping to their code address, which eliminates overhead of tag testing as in the WAM. Another difference is the choice point organization. While the WAM creates a choice point if there is more than one rule applicable to a predicate, the JUMP machine creates a choice point for each logical variable during unification of a function call with the left-hand side of a rule. This requires a transformation of the given rules into a set of nonsubunifiable rules (cf. Section 2.3). The advantage of this choice point organization is that ground function calls are automatically computed in a deterministic way. On the other hand, several choice points are created for a function call with several unbound variables. The JUMP machine can also be used to implement innermost narrowing by using another compilation scheme. <ref type="bibr">Lock [85]</ref> has proposed amixed implementation scheme where argument evaluation is implemented by lazy narrowing or innermost narrowing depending on some kind of strictness information for the arguments of a function.</p><p>The main component of the narrowing machines described so far is a stack which contains local data for each function call and choice points. The structure of this stack controls the execution order. The global nature of this stack makes it difficult to base a parallel implementation on it. In functional programming it has been shown that a decentralized graph structure is more appropriate for parallel implementations.</p><p>Hence <ref type="bibr">Kuchen et al. [79]</ref> have proposed a graph-based abstract machine for an innermost narrowing implementation of the language BABEL [97]. The main component of their BAM machine is a graph containing task nodes for each evaluation of a function call. Each task node contains local management information like local code address, return address etc., the list of arguments and local variables of the function call, and a local trail to organize backtracking. The intention of this machine is to support AND-parallelism</p><p>[81]; hence, backtracking is included. Further elements of the graph are special nodes to represent logical variables, constructors (data terms), and partial function applications (BABEL supports curried functions where some arguments are omitted in a function call). The instruction set of this machine consists of local instructions like loading local registers, unifying variables or constructors, creating new graph nodes, etc., and process instructions to activate and terminate tasks. In a sequential implementation of this machine there is always one active task identified by a global pointer. A parallel extension of this machine to support AND-parallelism on a shared memory multiprocessor is described in [8 I].</p><p>[95] describes an extension of the sequential BAM to support a lazy narrowing strategy.</p><p>Wolz [ 13 I] proposed another graph-based abstract machine for the implementation of lazy narrowing. The machine LANAM is an extension of an abstract machine for lazy term rewriting and has also many similarities to the WAM. The main motivation for the graphbased architecture is the sharing of data structures and unevaluated expressions in order to avoid multiple evaluations. The implemented lazy narrowing strategy requires neither constructor-based programs nor nonambiguous rules as other lazy narrowing strategies (cf. Section 2.3). All rules for a function symbol are compiled into a decision tree representing the applicable rules. Initially, all function symbols with defining rules are potentially evaluable. If a function cannot be evaluated since no rule is applicable, it is marked as a constructor that cannot be further evaluated. To apply a rule to an expression, the arguments of the expression corresponding to the nonvariable arguments of the rule are evaluated to their head normal form (a term with a constructor at the top). This process continues on subterms of the arguments as long as the rule has nested argument patterns. Due to this evaluation strategy, a transformation of the source program into a uniform program by flattening the left-hand sides of the rules (cf. Section 2.3) is not necessary. An early detection of nonapplicable rules is supported by a particular strategy to select arguments for evaluation. However, completeness results for the overall lazy narrowing strategy are not provided.</p><p>Most of the various abstract narrowing machines discussed above are highly optimized to obtain an efficient implementation of the chosen narrowing strategy. As a result, the correctness of these implementations is hard to prove. To achieve a verifiable implementation of a functional logic language, <ref type="bibr">Muck [99]</ref> has proposed the CAMEL narrowing machine which is based on the categorical abstract machine (CAM) [25], a relatively simple but efficient abstract machine for the execution of functional languages. The CAM has three data areas (code area, value stack, value area) and a small set of plain instructions. Muck has slightly extended the CAM by a heap to store logical variables, choice points in the value stack to handle backtracking, and some new instructions for unification and backtracking. These extensions enable a simple scheme to compile functional logic programs based on innermost narrowing into CAMEL instructions. In order to achieve the efficiency of sophisticated narrowing implementations, it is necessary to optimize the CAMEL by several refinement steps. Although this approach is not yet implemented, it may be useful to verify and simplify existing narrowing implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Summary</head><p>The most important techniques proposed for the efficient implementation of functional logic languages are summarized in Table <ref type="table" target="#tab_2">2</ref>. These implementations have shown that it is possible  If these two items are carefully selected, functional logic languages have the same efficiency as pure functional or pure logic languages. This is due to the fact that the implementations are similar to the pure languages if the additional features of the amalgamated language are not used. For instance, the A-WAM extends the WAM by several new instructions and a new data structure (occurrence stack). These new instructions and the data structure are used only if defined functions are present in the program. Thus the compiled code is identical to the WAM code as described in [2, 1301 for pure logic programs without defined functions. As an example from the other extreme, consider the JUMP machine which is an extension of an abstract machine used for the efficient implementation of functional languages (spineless tagless G-machine). If logical variables do not occur during run time, no choice point will be generated and the behavior is the same as for a pure functional program. However, if features from both programming paradigms are used in the proposed implementations of functional logic languages, the advantage of the amalgamated approach shows up. The knowledge about functional dependencies is used in the implementation to reduce the nondeterminism, e.g., by the inclusion of a deterministic normalization process or by the inclusion of a dynamic cut.</p><p>Although there are many differences between the various abstract machines due to the implemented narrowing strategies and the different starting points, it is interesting to see that there is a common kernel in the proposed abstract machines which is also present in the WAM: the code area for the program, the heap to store logical variables and evaluated expressions, a (local) stack to store environments and choice points, and a trail to store variable bindings and other changes in the term structure that must be reset in case of backtracking.</p><p>Due to the similarity to the WAM and other "classical" abstract machines, there are many possibilities to improve the current implementations In this survey we have tried to sketch and to relate the various developments of the last decade. Nevertheless, we could not cover all aspects on the integration of functional and logic languages. There are many further topics which have been partly addressed in the past and which are interesting for future work. These include:</p><p>. Better implementation by using program analysis techniques <ref type="bibr">[5, 6, 20, 30, 58, 601. . Distributed implementations [16, 81, 1131</ref>. . Development of programming environments like debugging tools <ref type="bibr">[61]</ref>. . Integration of other features like types <ref type="bibr">[ 1, 54, 114, 1211, constraints [l, 28, 80, 84, 89,90,92]</ref>, or higher-order functions <ref type="bibr">[17,51, 54, 100, 108, 1201.</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>, where LO, . . . , L, are literals. It is called (conditional) equation if LO is an equation, and unconditional equation if LO is an equation and n = 0.3Since unconditional equations I= r and conditional equations I= r : -C will be used only from left to right, we call them (rewrite) rules, where I and r are the left-and right-hand side, respectively. A clause is a variant of another clause if it is obtained by a bijective replacement of variables by other variables. A functional logic program or equational logic program is a finite set of clauses. In the following text, we assume that P is a functional logic program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>] ) is evaluated to its normal form [ 1,2 ,3 ] by the following three rewrite steps, provided that P contains the above rules defining append: append(ll,21,[31</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>. . --A~~ tn, we write to Q-T, t,,witha = u,,o.~.oa;!~a~. Thus in order to solve the equation append ( L , [ 2 1 I= 11, 2 I, we apply the second append rule (instantiating L to [ E ( R] ) and then the first append rule (instantiating R to [</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>), but belongs to an original program clause or goal. Basic narrowing can be defined by managing a set of basic positions. If ro YPl,ll~rl.oll 0 -[p2.12+rzml . . . -[pn.b+mPnl tn is a narrowing derivation, then the sets Bo, . . . , B, of basic positions are inductively defined by Bc = (p 1 p position in to with tolp $ X}, Bi = (Bi-I\{P E Bi-1 I Pi 5 P]&gt; U {pi . p 1 p position in ri with ri JP $ X), i &gt; 0. The above sequence is a basic narrowing derivation if pi E Bi-1 for i = 1, . , n. second narrowing step is not basic since the subterm rev (Xl ) belongs to the substitution part introduced in the first step. In a basic narrowing derivation it is not allowed to reduce this term. Hence the only basic narrowing derivation of the same initial equation is rev(X) =X ~[x~rev(xl)] Xl=rev(Xl).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>r be a new variant of a rule such that o (E jP) and 1 are unifiable with mgu cr.'. Then (Elr],,; d o a) is the next literal derived by an innermost basic narrowing step.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Let u' be the substitution (x~,a(E IP)}, where x is a new variable. Then (E[xlp; a' o a) is the next literal derived by an innermost rejection step (this corresponds to the elimination of an innermost redex [66] and is called "null narrowing step" in [ 181).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>8[37]  describes an extension of the rejection rule where the requirement for different constructors is weakened to incomparable function symbols.Such a narrowing method is called normalizing narrowing[40]. For instance, if we rewrite the second derived equation in the previous example to normal form, we can immediately terminate the narrowing derivation:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Then there are two narrowing derivations of the equation 0 *N= 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Example 2.6. Consider the standard rules for the function append (cf. Section 1). Then the equation append(append( lO]Vl ,W) ,Y) = ll]Zl is rewritten to its normal form [Olappend(append(V,W),Y)l = [l/Z1 using the rules for append. This equation is immediately rejected since 0 and 1 are different constructors. The equivalent Prolog program, append(ll,L,L). append([E]Rl,L,[E]RL]loop for any order of literals and clauses [ 1011. The idea of normalizing narrowing can also be combined with the previously discussed improvements of simple narrowing. Fribourg has shown that normalizing innermost narrowing is complete under the same requirements of innermost narrowing [41]. Normalizing basic narrowing is discussed in [ 103, 1 lo], and Hiilldobler has shown completeness of innermost basic narrowing with normalization [66]. Normalization can be integrated into innermost basic narrowing derivations by applying, first of all, the following rule as long as possible to the literal (E; a) consisting of the skeleton equation and the current substitution (note that the nondeterminism in this rule is don't care, i.e., it is sufficient to select nondeterministically one alternative and disregard all other possibilities): Rewriting: Select a nonvariable position p in E and a new variant I= r of a rule such that U' is a substitution with a(Elp) = a'(l). Then (E[a'(r)lP ; a) is the next goal derived by rewriting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>[67] or Miranda [I271 are based on lazy evaluation principles (see [68] for a discussion on the advantages of lazy evaluation). A lazy strategy delays the evaluation of function arguments until their values are definitely needed to compute the result of the function call. Hence, lazy evaluation avoids unnecessary computations and allows us to deal with infinite data structures, For instance, consider the function first (N , L ) , which computes the first N elements of a given list L: first(O,L) = 11. first(s(N), [E]Ll) = [Elfirst(N,L)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>3. Free variables: If 1 = r is a rule, then Vur(r) E Var(Z). 4. Nonambiguity: If 11 = rl and 12 = r2 are two different rules, then 11 and 12 are not unifiable. Sometimes [97] this condition is relaxed to the requirement: if 11 and 12 are unifiable with mgu cr, then 0 (rl) and CT (r-2) are identical (weak nonambiguity). The nonambiguity condition ensures that normal forms are unique if they exist, i.e., functions are uniquely defined. The strong nonambiguity condition excludes rules like in Example 2.5, whereas the weak nonambiguity condition excludes rules like 0 + N = N. s(O) + N = s(N). s(M) + N = s(M+N) . Due to the presence of nonterminating functions, completeness resultsfor lazy narrowing are stated w.r.t. a domain-based declarative semantics of functional logic programs. For instance, consider the function defined by the single rule f(X) = f(X). A lazy narrowing derivation of the equation f ( 0 ) = f ( 0 ) does not terminate, and hence lazy narrowing would be incomplete w.r.t. the standard interpretation of equality. Therefore, some authors exclude defined functions in the right-hand side of goal equations [ 1041 or include a decomposition rule [66], but most completeness results are established w.r.t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Example 2.8. Consider the following rules for comparing and adding natural numbers: We want to solve the equation XFX+Y = B by lazy narrowing. A first solution could be computed by applying the first rule for 5 without evaluating the subterm X+Y: XFX+Y = B ^Vf(XHO) true=B .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>Consider the rules for the Boolean functions even and or (0, s, false, and true are constructors): evaluate the subterm even (X) in order to decide the applicability of the first or rule. Unfortunately, there are infinitely many narrowing derivations of even (x) to the constructor true with the bindings (XI-+ 0}, {XHS (s ( 0 ) ) ],. . . . Therefore the search space of all possible lazy narrowing derivations is infinite. Moreover, a sequential implementation does not yield any result since the subsequent or rules are never tried. However, if we normalize the equation before applying any narrowing step, we would transform the initial equation into true=true, which is trivially satisfied. Thus the infinite search space would be reduced to a finite one. Normalization between lazy narrowing steps is even more useful if inductive consequences are used. An inductive consequence is an equation which is valid in the least model of the program. For instance, the equation N+O=N is an inductive consequence w.r.t. Example 2.4, but it is not a logical consequence of the rules for addition. It has been shown that the application of inductive consequences is useful in normalizing innermost [4 I ] and normalizing basic [ 1031 narrowing derivations. If inductive consequences are applied, computed solutions are valid in the least model of the program (which is usually the intended model). Proposals to include normalization with inductive consequences into lazy evaluation strategies can be found in [33, 591. The following example demonstrates the search space reduction using normalization with inductive consequences even for strongly nonambiguous rules.Example 2.10.Consider the following rules for addition and multiplication on natural numbers:Then there is the following lazy narrowing derivation of the equation X*Y=s ( 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>1= r : -C be a new variant of a conditional equation such that o (G lP) and 1 are unifiable with mgu 0. Then o (C, G[rlp) is the next goal derived by conditional narrowing, i.e., G -[p,t=r: -c,~I dc, Gb-lp) is a conditional narrowing step (C, G denotes the concatenation of the equation lists C and G).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>condition g ( X , c ) =g (b , X) could be proved if the variable x were instantiated to the reducible term a, but the narrowing calculus does not support such instantiations. The conditional narrowing calculus is complete if it is unnecessary to instantiate extra variables to reducible terms. A simple requirement to achieve this property is to forbid extra variables in conditions [66]. Hence, conditional narrowing is complete w.r.t. normalized substitutions if the set of conditional equations is confluent and does not contain extra variables. Conditional narrowing is complete for arbitrary substitutions if the set of conditional equations is confluent and terminating and does not contain extra variables [76].121f one "Kaplan was the first to prove this result for decreasing rules, but it holds also for nondecreasing wants to use extra variables in conditions, there are stronger criteria to ensure completeness (e.g., level confluence [48], decreasing rules [34], or restricting the instantiation of extra variables to irreducible terms [ 107]), or it may be possible to transform the program into an equivalent one for which conditional narrowing is complete (e.g., Bertling and Ganzinger [ 1 l] proposed such a method).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>The associated rewrite relation is confluent and terminating. The equation f (d) =a is provable in the simple conditional narrowing calculus:f (d)=a ~(1 a=a,d=b, d=c ~(1 a=a, b=b, d=c ~(1 a=a, b=b, c=c.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>FIGURE 1 .</head><label>1</label><figDesc>FIGURE 1. Infinite derivation with the residuation principle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>, CB, TD, not strictly subunifiable; complete w.r.t. ground substitutions CB, LFN CB, LFN; complete w.r.t. strict equality CB, LFN, inductively sequential rules; complete w.r.t. strict equality CB, LFN; complete w.r.t. strict equality (Ground) C, T C, T; see [34,48, 1071 for extra variables C, T, decreasing rules C, T, CB, TD; complete w.r.t. ground substitutions C, T, decreasing rules Incomplete in general, complete for particular programs [ 19, 581 l Deal with logical variables and unification l Organize the search for successful derivations (backtracking in the sequential case) l Apply rules at arbitrary subterms (in the presence of nested expressions).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>(E,L). ?append([l],[2]) = L, member(E,L). This program can be executed by SLD-resolution if we add the clause x = x. for unifying both sides of an equation after the evaluation of functions.15 If the left-to-right order of the new equations generated during flattening equals the innermost-to-outermost positions of the corresponding subterms, then it can be shown [ 181 that applying left-to-right SLD-resolution to the Battened program corresponds to leftmost innermost basic narrowing w.r.t. the original functional logic program. Hence, resolution combined with flattening has the same soundness and completeness properties as narrowing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>Consider the rules for the function append (cf. Section 1) and the literal append(append(X,Y) ,Z) = [I. The solution {XH [ 1, YH [ I, ZH [I ) is computed in two narrowing steps using the first rule for append. However, if the second append rule is applied to the inner subterm, X is instantiated to [E 1 R] and append( IE]append(R,Y) 1 ,Z) = [I is the derived equation. A normalizing narrowing strategy transforms the last equation into its normal form [ E 1 append (append (R, Y) , Z ) ] = [ ] , which is immediately rejected. Hence, an infinite derivation does not occur. On the other hand, the execution of the flattened goal ?-append(X,Y) = T, append(T,Z) = [I. w.r.t. the flattened program (cf. Example 3.1) generates the new goal ?</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head></head><label></label><figDesc>Code area: Contains the WAM code of the compiled program. Local stack: Contains environments (for clause invocations) and choice points. Heap: Contains term structures. Trail: Contains references to variables that have been bound during unification. These variables must be unbound in case of backtracking. The WAM has primitive instructions for unification, clause invocation, and backtracking. Each clause is translated into a sequence of unification instructions for the clause head, followed by a sequence of calls to the predicates in the clause body. Thus goals are represented by instruction sequences and not by proper data structures. On the other hand, narrowing and normalization manipulates the term structure: subterms are replaced by right-hand sides of rules. Hence, a WAM-based implementation of narrowing must support such term manipulations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>logic languages in an efficient way provided that: l An appropriate operational semantics is chosen. l Implementation principles known from pure functional and logic programming languages are adapted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head></head><label></label><figDesc>of functional logic languages by applying optimization techniques for Prolog implementations (e.g., [29, 65, 1261). However, more advanced compilation techniques which depend on a global analysis of the program [93, 125, 1291 require the development of new program analysis methods for functional logic programs [60].4. CONCLUSIONSThe research on functional logic languages during the last decade has shown that functional and logic languages can be amalgamated without loosing the efficiency of current implementations of functional or logic languages. The amalgamated languages have more expressive power in comparison to functional languages and a better operational behavior in comparison to logic languages. Therefore, the original motivation for the research in this area has been satisfied. This goal has been achieved in two basic steps:1. The execution principlesforfinctional logic languages have been refined. The most important operational principle is narrowing, a combination of resolution from logic programming and term reduction from functional programming. Since narrowing is highly inefficient in its simplest form, much work has been carried out to restrict the admissible narrowing derivations without loosing completeness. The development of these refined strategies was the precondition for the efficient implementation of functional logic languages.2. Implementation techniques known from functional and logic languages have beenextended to implement functional logic languages. Due to the refined operational principles, only slight extensions are necessary. The overhead introduced by these extensions is small or disappears if the new features (functions in case of logic programs and logical variables in case of functional programs) are not used. Moreover, the use of functions yields a more efficient behavior in comparison to pure logic programs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE 1 .</head><label>1</label><figDesc>Execution Principles for Functional Logic Languages</figDesc><table><row><cell>Operational Principle</cell><cell>Requirements</cell></row><row><cell>Simple narrowing [69, 1191</cell><cell>"".</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 1 .</head><label>1</label><figDesc>Normalizing Narrowing vs. SLD-Resolution: Permutation Sort</figDesc><table><row><cell>Program:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>n=6</cell><cell>n=8</cell><cell>n = 10</cell></row><row><cell cols="2">Pure logic program</cell><cell cols="2">([ 1221,</cell><cell>p.</cell><cell>55)</cell><cell>0.65</cell><cell>37.92</cell><cell>3569.50</cell></row><row><cell>Functional logic</cell><cell cols="2">program</cell><cell cols="2">[4 1,</cell><cell>p. 1821</cell><cell>0.27</cell><cell>1.43</cell><cell>7.43</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 2 .</head><label>2</label><figDesc>Efficient Implementations of Functional Logic Languages</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The author is grateful to Herbert Kuchen, Rita Loogen, and an anonymous referee for their detailed comments on a previous version of this paper. Sergio Antoy, Bernd Biitow, Rachid Bchahed, Hendrik Lock, Andy Muck, Peter Padawitz, and Christian Prehofer have given further valuable comments to improve the paper.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work has been partially supported by the German Ministry for Research and Technology (BMFT) under grant ITS 9103.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An Overview ofLIFE</title>
		<author>
			<persName><forename type="first">H</forename><surname>Aiit-Kaci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Next Generation Information System Technology</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Schmidt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Stogny Teds</surname></persName>
		</editor>
		<meeting>the Workshop on Next Generation Information System Technology<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">504</biblScope>
			<biblScope unit="page" from="42" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Warren&apos;s Abstract Machine</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ait-Kaci</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Aiit-Kaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nasr</surname></persName>
		</author>
		<title level="m">Proceedings of the 4th IEEE Internat. Symposium on Logic Programming</title>
		<meeting>the 4th IEEE Internat. Symposium on Logic Programming<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="17" to="23" />
		</imprint>
	</monogr>
	<note>Le Fun: Logic, Equations, and Functions</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Functions as Passive Constraints in LIFE</title>
		<author>
			<persName><forename type="first">H</forename><surname>Aiit-Kaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
		<respStmt>
			<orgName>DEC Paris Research Laboratory</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Analyses of Inconsistency for Incremental Equational Logic Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alpuente</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Falaschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Manzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">631</biblScope>
			<biblScope unit="page" from="443" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Narrowing Approximations as an Optimization for Equational Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alpuente</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Falaschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Ramis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vidal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 5th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">714</biblScope>
			<biblScope unit="page" from="391" to="409" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Needed Narrowing Strategy</title>
		<author>
			<persName><forename type="first">S</forename><surname>Antoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Echahed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 21st ACM Symposium on Principles of Programming Languages<address><addrLine>Portland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="268" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">LEAF: A Language which Integrates Logic, Equations and Functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Barbuti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming, Functions, Relations, and Equations</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Degroot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="201" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Relation between Logic and Functional Languages: A Survey</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="217" to="236" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Design and Implementation of a Generic, Logic and Functional Programming Language</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Echahed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Symposium on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the European Symposium on Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">213</biblScope>
			<biblScope unit="page" from="119" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Completion-Time Optimization of Rewrite-Time Goal</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bertling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName><surname>Solving</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Rewriting Techniques and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Conference on Rewriting Techniques and Applications<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">355</biblScope>
			<biblScope unit="page" from="45" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Optimal Narrowing Strategy for General Canonical Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bockmayr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Workshop on Conditional Term Rewriting Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Workshop on Conditional Term Rewriting Systems<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">656</biblScope>
			<biblScope unit="page" from="483" to="497" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Unification in Incompletely Specified Theories: A Case Study</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bonnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">199 1</date>
			<biblScope unit="volume">520</biblScope>
			<biblScope unit="page" from="84" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Towards aClean Amalgamation of Logic Programs with External Procedures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bonnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maluszynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Conference on Logic Programming and 5th Symposium on Logic Programming, (Seattle)</title>
		<meeting>the 5th Conference on Logic Programming and 5th Symposium on Logic Programming, (Seattle)<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="31" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Extension of WAM for K-LEAF: A WAM-Based Compilation of Conditional Narrowing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Bosco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cecchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moiso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International</title>
		<meeting>the Sixth International</meeting>
		<imprint>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
		<title level="m">Conference on Logic Programming</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="318" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Logic and Functional Programming on Distributed Memory Architectures</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Bosco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cecchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moiso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Porta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sofi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh hterflational Conference on Logic Programming</title>
		<meeting>the Seventh hterflational Conference on Logic Programming<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="325" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">IDEAL: An Ideal Deductive Applicative Language</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Bosco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Giovannetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Symposium on Logic Programming</title>
		<meeting>the IEEE International Symposium on Logic Programming<address><addrLine>Salt Lake City</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="89" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Bosco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Giovannetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moiso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Narrowing vs. SLD-Resolution</title>
		<imprint>
			<publisher>Theoret</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="3" to="23" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">S-SLD-resolution-An Operational Semantics for Logic Programs with External Procedures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">528</biblScope>
			<biblScope unit="page" from="383" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Avoiding Dynamic Delays in Functional Logic Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 5th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">714</biblScope>
			<biblScope unit="page" from="12" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Synthesis of Directionality Information for Functional Logic Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Paakki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maluszynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on Static Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Third International Workshop on Static Analysis<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">724</biblScope>
			<biblScope unit="page" from="165" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The Implementation of Lazy Narrowing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M T</forename><surname>Chakravarty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C R</forename><surname>Lock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">528</biblScope>
			<biblScope unit="page" from="123" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Compiling Lazy Narrowing into Prolog</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Cheong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. New Generation Computing</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<pubPlace>Paris</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report 25</note>
	<note>LIENS. To appear</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficient Integration of Simplification into Prolog</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Cheong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fribourg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">528</biblScope>
			<biblScope unit="page" from="359" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The Categorical Abstract Machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cousineau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logical Foundations of Functional Programming</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="25" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The Unification of Functional and Logic Languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Field</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming, Functions, Relations, and Equations</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Degroot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</editor>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="37" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Narrowing and Unification in Functional Programming-An Evaluation Mechanism for Absolute Set Abstraction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Rewriting Techniques andApplications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Conference on Rewriting Techniques andApplications<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">355</biblScope>
			<biblScope unit="page" from="92" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pull</surname></persName>
		</author>
		<title level="m">A New Perspective on Integrating Functional and Logic Languages</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="682" to="693" />
		</imprint>
	</monogr>
	<note>Proceedings of the Fifth Generation Computer Systems</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Register Allocation in a Prolog Machine</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Symposium on Logic Programming</title>
		<meeting>the IEEE International Symposium on Logic Programming<address><addrLine>Salt Lake City</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="267" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Functional Computations in Logic Programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Debray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Languages Syst</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="451" to="481" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m">Logic Programming, Functions, Relations, and Equations</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Degroot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rewrite</forename><surname>Systems</surname></persName>
		</author>
		<title level="m">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="243" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Equation Solving in Conditional AC-Theories</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sivakumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Algebraic and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2nd International Conference on Algebraic and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">463</biblScope>
			<biblScope unit="page" from="283" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Conditional Equational Programming and the Theory of Conditional Term Rewriting</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Okada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Ftfth Generation Computer Systems</title>
		<meeting>the International Conference on Ftfth Generation Computer Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="337" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Logic Programming cum Applicative Programming</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Plaisted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Symposium on Logic Programming</title>
		<meeting>the IEEE International Symposium on Logic Programming<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="54" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Equational Programming</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Plaisted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence II</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hayes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Richards</surname></persName>
		</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="21" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Solving Goals in Equational Languages, in: Proceedings of the 1st International Workshop on Conditional Term Rewriting Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sivakumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">308</biblScope>
			<biblScope unit="page" from="45" to="55" />
			<date type="published" when="1987">1987</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On Completeness of Narrowing Strategies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Echahed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CAAP&apos;88</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the CAAP&apos;88<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">299</biblScope>
			<biblScope unit="page" from="89" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Uniform Narrowing Strategies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Echahed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Internationnl Conference on Algebraic and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd Internationnl Conference on Algebraic and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">632</biblScope>
			<biblScope unit="page" from="259" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">First-Order Unification in an Equational Theory</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Workshop on Automated Deduction</title>
		<meeting>the 4th Workshop on Automated Deduction<address><addrLine>Austin, TX; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="161" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">SLOG: A Logic Programming Language Interpreter Based on Clausal Superposition and Rewriting</title>
		<author>
			<persName><forename type="first">L</forename><surname>Fribourg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Internat. Symposium on Logic Programming</title>
		<meeting>the IEEE Internat. Symposium on Logic Programming<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="172" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Extending SLD-Resolution to Equational Horn Clauses Using E-Unification, 1</title>
		<author>
			<persName><forename type="first">L</forename><surname>Fribourg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Gallier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Raatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic Program</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Fuchi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="3" to="43" />
			<date type="published" when="1988">1988. 1989</date>
			<publisher>Elsevier Science Publishers</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Programming of Future Generation Computers</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Complete Sets of Transformations for General E-Unification</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Gallier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="203" to="260" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">A Completion Procedure for Conditional Equations</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="51" to="81" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Experiences with the RAP System-A Specification Interpreter Combining Term Rewriting and Resolution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Geser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hussmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the of ESOP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the of ESOP<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="339" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Kernel LEAF: A Logic plus Functional Language</title>
		<author>
			<persName><forename type="first">E</forename><surname>Giovannetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moiso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Palamidessi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">I. Computer Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="139" to="185" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A Completeness Result for E-Unification Algorithms Based on Conditional Narrowing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Giovannetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moiso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Foundations of Logic and Functional Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Workshop on Foundations of Logic and Functional Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">306</biblScope>
			<biblScope unit="page" from="157" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Eqlog: Equality, Types, and Generic Modules for Logic Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming, Functions, Relations, and Equations</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Degroot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="295" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Models and Equality for Logical Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the TAPSOFT &apos;87</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the TAPSOFT &apos;87<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">250</biblScope>
			<biblScope unit="page">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">On the Completeness of Narrowing as the Operational Semantics of Functional Logic Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gonzalez-Moreno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Hortala-Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSL&apos;9</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CSL&apos;9<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="216" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">On the Interaction of Lazy Evaluation and Backtracking</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Loogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Winkler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="355" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A Functional and Logic Language with Polymorphic Types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2nd International Workshop on Programming Language Implementation and Logic Programming<address><addrLine>New York; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990. 1990</date>
			<biblScope unit="volume">456</biblScope>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
	<note>Lecture Notes in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Efficient Implementation of Narrowing and Rewriting</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ofthe International Workshop on Processing Declarative Knowledge</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the International Workshop on Processing Declarative Knowledge<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">567</biblScope>
			<biblScope unit="page" from="344" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Improving Control of Logic Programs by Using Functional Logic Languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">631</biblScope>
			<biblScope unit="page">23</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Incremental Rewriting in Narrowing Derivations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference on Algebraic and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Conference on Algebraic and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">632</biblScope>
			<biblScope unit="page" from="228" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">On the Completeness of Residuation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming</title>
		<meeting>the 1992 Joint International Conference and Symposium on Logic Programming<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="192" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Lazy Unification with Simplification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Symposium on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the European Symposium on Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">788</biblScope>
			<biblScope unit="page" from="272" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Towards the Global Optimization of Functional Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Compiler Construction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the International Conference on Compiler Construction<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">786</biblScope>
			<biblScope unit="page" from="68" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">A Debugging Model for Functional Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hanus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Josephs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 5th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">714</biblScope>
			<biblScope unit="page" from="28" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Andorra Prolog: An Integration of Prolog and Committed Choice Languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Haridi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Fifth Generation Computer Systems</title>
		<meeting>the International Conference on Fifth Generation Computer Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="745" to="754" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Macqueen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Standard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">LFCS Report Series ECS-LFCS-86-2</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Narrowing Techniques Applied to Idempotent Unification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Herold</surname></persName>
		</author>
		<idno>SR 86-16</idno>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
		<respStmt>
			<orgName>Univ. Kaiserslautern</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">SEKI-Report</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Global Compilation of Prolog</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hickey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mudambi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Holldobler, S., Foundations of Equational Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989. 1989</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="193" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">Report on the Functional Programming Language Haskell, SIGPLAN Not</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">27</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m" type="main">Why Functional Programming Matters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
		<idno>16</idno>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
		<respStmt>
			<orgName>Programming Methodology Group, University of Goteborg</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Hullot</surname></persName>
		</author>
		<title level="m">Proceedings of the 5th Conference on 70</title>
		<meeting>the 5th Conference on 70</meeting>
		<imprint/>
	</monogr>
	<note>Canonical Forms and Unification</note>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Automated Deduction</title>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="3" to="18" />
			<date type="published" when="1980">1980</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Unification in Conditional-Equational Theories</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hussmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">204</biblScope>
			<biblScope unit="page" from="543" to="553" />
			<date type="published" when="1985">1985</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Proceedings of EU-ROCAL &apos;85</note>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">A Theory of Complete Logic Programs with Equality</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Lassez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="21" to="223" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">A Fully Abstract Semantics for a First-Order Functional Language with Logic Variables</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jagadeesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Panangaden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Languages Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="577" to="625" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">An Implementation of Narrowing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Josephson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="57" to="77" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Enriching Prolog with S-Unification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Klgedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kluiniak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Declarative Programming, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Dietrich</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="51" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Conditional Rewrite Rules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kaplan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="175" to="193" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Kaplan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Simplifying Conditional Term Rewriting Systems: Unification, Termination, and Confluence</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="295" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Simple Word Problems in Universal Algebras</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Bendix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Problems in Abstract Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Leech</surname></persName>
		</editor>
		<imprint>
			<publisher>Pergamon Press</publisher>
			<date type="published" when="1970">1970</date>
			<biblScope unit="page" from="263" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Detecting Redundant Narrowing Derivations by the LSE-SL Reducibility Test</title>
		<author>
			<persName><forename type="first">S</forename><surname>Krischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bockmayr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the RTA&apos;91</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the RTA&apos;91<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">488</biblScope>
			<biblScope unit="page" from="74" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Graph-Based Implementation of a Functional Logic Language</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kuchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Loogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Moreno-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ESOP 90</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the ESOP 90<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">432</biblScope>
			<biblScope unit="page" from="271" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Implementing a Lazy Functional Logic Language with Disequality Constraints</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kuchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Lopez-Fraguas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Moreno-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming</title>
		<meeting>the 1992 Joint International Conference and Symposium on Logic Programming<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Independent AND-Parallel Implementation of Narrowing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kuchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Moreno-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Hermenegildo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">631</biblScope>
			<biblScope unit="page" from="24" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Our LIPS Are Sealed: Interfacing Functional and Logic Programming Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Maluszynski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ogi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="428" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
		<title level="m">Foundations of Logic Programming</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">A Tiny Constraint Functional Logic Programming Language and Its Continuation Semantics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Muck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Streicher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Symposium on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the European Symposium on Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">788</biblScope>
			<biblScope unit="page" from="439" to="453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<title level="m" type="main">The Implementation of Functional Logic Programming Languages</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C R</forename><surname>Lock</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Oldenbourg Verlag</publisher>
			<biblScope unit="volume">208</biblScope>
			<pubPlace>Milnchen</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technical University of Berlin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
	<note>Also available as GMD Report</note>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Relating the Implementation Techniques of Functional and Functional Logic Languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Loogen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="179" to="215" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">A Demand Driven Computation Strategy for Lazy Narrowing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Loogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lopez Fraguas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the PLILP&apos;93</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the PLILP&apos;93<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<monogr>
		<title level="m" type="main">Dynamic Detection of Determinism in Functional Logic 89</title>
		<author>
			<persName><forename type="first">R</forename><surname>Loogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Winkler</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<author>
			<persName><surname>Languages</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">528</biblScope>
			<biblScope unit="page" from="335" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">A General Scheme for Constraint Functional Logic Programming</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Lopez Fraguas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference on Algebraic and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Conference on Algebraic and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">632</biblScope>
			<biblScope unit="page" from="213" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">An Approach to Constraint Functional Logic Programming</title>
		<author>
			<persName><forename type="first">Lopez</forename><surname>Fraguas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mantsivoda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename></persName>
		</author>
		<idno>DIA/91/4</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Processing Declarative Knowledge</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<meeting>the International Workshop on Processing Declarative Knowledge<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991. 1991</date>
			<biblScope unit="volume">567</biblScope>
			<biblScope unit="page" from="257" to="270" />
		</imprint>
		<respStmt>
			<orgName>Universidad Complutense, Madrid</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Flang: A Functional-Logic Language</note>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Flang and Its Implementation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Mantsivoda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ofthe 5th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 5th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">714</biblScope>
			<biblScope unit="page" from="151" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Some Global Optimizations for a Prolog Compiler</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Mellish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="43" to="66" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Counterexamples to Completeness Results for Basic Narrowing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Middeldorp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hamoen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference on Algebraic and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Conference on Algebraic and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">632</biblScope>
			<biblScope unit="page" from="244" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Lazy Narrowing in a Graph Machine</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Moreno-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kuchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Loogen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference on Algebraic and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Second International Conference on Algebraic and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">463</biblScope>
			<biblScope unit="page" from="298" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Efficient Lazy Narrowing Using Demandedness Analysis</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Moreno-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kuchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marino-Carballo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Winkler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 5th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">714</biblScope>
			<biblScope unit="page" from="167" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Logic Programming with Functions and Predicates: The Language BABEL</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Moreno-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez-Artalejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="191" to="223" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Compilation of Narrowing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Muck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ofthe 2nd International Workshop on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2nd International Workshop on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">456</biblScope>
			<biblScope unit="page" from="16" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">CAMEL: An Extension of the Categorical Abstract Machine to Compile Functional/Logic Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Muck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">631</biblScope>
			<biblScope unit="page" from="341" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">An Overview of hProlog</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nadathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th</title>
		<meeting>the 5th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<title level="m">Conference on Logic Programming and 5th Symposium on Logic Programming Seattle</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="810" to="827" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Negation and Control in Prolog</title>
		<author>
			<persName><forename type="first">L</forename><surname>Naish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">238</biblScope>
			<date type="published" when="1987">1987</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Adding Equations to NU-Prolog</title>
		<author>
			<persName><forename type="first">L</forename><surname>Naish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Symposium on Programming Language Implementation and Logic Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">528</biblScope>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Basic Narrowing Revisited</title>
		<author>
			<persName><forename type="first">W</forename><surname>Nutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rtty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="295" to="317" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Strategy-Controlled Reduction and Narrowing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Okui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Padawitz</surname></persName>
		</author>
		<idno>ISE-TR-92-97</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Rewriting Techniques and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Conference on Rewriting Techniques and Applications<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1992. 1987</date>
			<biblScope unit="volume">256</biblScope>
			<biblScope unit="page" from="242" to="255" />
		</imprint>
		<respStmt>
			<orgName>Univ. of Tsukuba</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
	<note>Lazy Narrowing Calculi</note>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><surname>Padawitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computing in Horn Clause Theories</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Generic Induction Proofs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Padawitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Workshop on Conditional Term Rewriting Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 3rd International Workshop on Conditional Term Rewriting Systems<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">656</biblScope>
			<biblScope unit="page" from="175" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Higher-Order Equational Logic Programming</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 21st ACM Symposium on Principles of Programming Languages<address><addrLine>Portland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="254" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Narrowing as the Operational Semantics of Functional Languages</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">S</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Symposium on Logic Programming</title>
		<meeting>the IEEE International Symposium on Logic Programming<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="138" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Improving Basic Narrowing Techniques</title>
		<author>
			<persName><forename type="first">P</forename><surname>R&amp;y</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Rewriting Techniques andApplications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Conference on Rewriting Techniques andApplications<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">256</biblScope>
			<biblScope unit="page" from="228" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">NARROWER: A New Algorithm for Unification and Its Application to Logic Programming</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">?</forename><surname>Rcty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kirchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lescanne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First Conference on Rewriting Techniques and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Dijon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">202</biblScope>
			<biblScope unit="page" from="141" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">LOGLISP: Motivation, Design and Implementation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">E</forename><surname>Sibert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S.-A</forename><surname>Tamlund</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="299" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Quty: A Concurrent Language Based on Logic and Function</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Conference on Logic Programming</title>
		<meeting>the Fourth International Conference on Logic Programming<address><addrLine>Melbourne; Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="1034" to="1056" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">A Typed Functional Extension of Logic Programming</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Nang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Maeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Cho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Computing</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="197" to="221" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Universal Unification and a Classification of Equational Theories</title>
		<author>
			<persName><forename type="first">J</forename><surname>Siekmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Szabo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Conference on Automated Deduction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 6th Conference on Automated Deduction<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="369" to="389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">An Introduction to Unification Theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Siekmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Techniques in ArttQicial Intelligence</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Banerji</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="369" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Set Abstraction in Functional and Logic Programming</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">S K</forename><surname>Silbermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jayaraman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth International Conference on Functional Programming and Computer Architecture</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="3" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">A Domain-Theoretic Approach to Functional and Logic Programming</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">S K</forename><surname>Silbermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jayaraman</surname></persName>
		</author>
		<idno>TUTR 9 I -109</idno>
	</analytic>
	<monogr>
		<title level="j">Also in .I. Functional Program</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="273" to="321" />
			<date type="published" when="1991">1991. 1992</date>
		</imprint>
		<respStmt>
			<orgName>Tulane University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">Automated Theorem-Proving for Theories with Simplifiers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Slagle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commutativity, and Associativity, J. ACM</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="622" to="642" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">Fresh: A Higher-Order Language Based on Unification and Multiple Results</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming, Functions, Relations, and Equations</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Degroot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="469" to="524" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
		<idno>SR-87-11</idno>
		<title level="m">TEL (Version 0.9) Report and User Manual</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>FB Informatik, Univ. Kaiserslautem</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">SEKI Report</note>
</biblStruct>

<biblStruct xml:id="b122">
	<monogr>
		<title level="m" type="main">The Art of Prolog</title>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Subrahmanyam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Funlog</forename></persName>
		</author>
		<title level="m">A Computational Model Integrating Logic Programming and Functional Programming</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Degroot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</editor>
		<meeting><address><addrLine>Prentice-Hall, Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="157" to="198" />
		</imprint>
	</monogr>
	<note>Logic Programming, Functions, Relations, and Equations</note>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">Semantics of a Logic Programming Language with a Reducibility Predicate</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tamaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1984 Symposium on Logic Programming</title>
		<meeting>the 1984 Symposium on Logic Programming</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="259" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">LIPS on a MIPS: Results Form a Prolog Compiler for a RISC</title>
		<author>
			<persName><forename type="first">A</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Logic Programming</title>
		<meeting>the Seventh International Conference on Logic Programming<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="174" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<analytic>
		<title level="a" type="main">Compiler Optimizations for the WAM</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference on Logic Programming London</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Third International Conference on Logic Programming London<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">225</biblScope>
			<biblScope unit="page" from="657" to="662" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">A Non-Strict Functional Language with Polymorphic Types, in: Conference on Functional Programming Languages and Computer Architecture</title>
		<author>
			<persName><forename type="first">D</forename><surname>Turner</surname></persName>
		</author>
		<author>
			<persName><surname>Miranda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">201</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="1985">1985</date>
			<publisher>Springer</publisher>
			<pubPlace>Nancy, France; New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Logic Programming with Equations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Van Emden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Program</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="265" to="288" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<monogr>
		<title level="m" type="main">Can Logic Programming Execute as Fast as Imperative Programming?</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Van Roy</surname></persName>
		</author>
		<idno>No. UCB/CSD 90/600</idno>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Univ. of California Berkeley</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. Thesis, Report</note>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">An Abstract Prolog Instruction Set</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H D</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SRI International</title>
		<imprint>
			<biblScope unit="volume">309</biblScope>
			<date type="published" when="1983">1983</date>
			<pubPlace>Stanford</pubPlace>
		</imprint>
	</monogr>
	<note>Technical Note</note>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Design of a Compiler for Lazy Pattern Driven Narrowing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wolz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Trends in Data Type Specification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">534</biblScope>
			<biblScope unit="page" from="362" to="379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">Enumerating Outer Narrowing Derivations for Constructor-Based Term Rewriting Systems</title>
		<author>
			<persName><forename type="first">J.-H</forename><surname>You</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="3" to="19" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
