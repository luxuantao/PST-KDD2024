<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithms for the coalitional manipulation problem ✩</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-11-24">24 November 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><surname>Zuckerman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Computer Science</orgName>
								<orgName type="institution">The Hebrew University of Jerusalem</orgName>
								<address>
									<postCode>91904</postCode>
									<settlement>Jerusalem</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Ariel</forename><forename type="middle">D</forename><surname>Procaccia</surname></persName>
							<email>arielpro@gmail.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Israel R&amp;D Center</orgName>
								<address>
									<addrLine>13 Shenkar Street</addrLine>
									<postCode>46725</postCode>
									<settlement>Herzeliya</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jeffrey</forename><forename type="middle">S</forename><surname>Rosenschein</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Computer Science</orgName>
								<orgName type="institution">The Hebrew University of Jerusalem</orgName>
								<address>
									<postCode>91904</postCode>
									<settlement>Jerusalem</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Algorithms for the coalitional manipulation problem ✩</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-11-24">24 November 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">359171B961929790ACC5424DCF3A0180</idno>
					<idno type="DOI">10.1016/j.artint.2008.11.005</idno>
					<note type="submission">Received 15 December 2007 Received in revised form 17 November 2008 Accepted 20 November 2008</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Computational social choice Voting Manipulation Computational complexity</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We investigate the problem of coalitional manipulation in elections, which is known to be hard in a variety of voting rules. We put forward efficient algorithms for the problem in Borda, Maximin and Plurality with Runoff, and analyze their windows of error. Specifically, given an instance on which an algorithm fails, we bound the additional power the manipulators need in order to succeed. We finally discuss the implications of our results with respect to the popular approach of employing computational hardness to preclude manipulation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Social choice theory is an extremely well-studied subfield of economics. In recent years, interest in the computational aspects of social choice, and in particular in the computational aspects of voting, has sharply increased.</p><p>In an election, a set of voters submit their (linear) preferences (i.e., rankings) over a set of candidates. The winner of the election is designated by a voting rule, which is basically a mapping from the space of possible preference profiles into candidates. A thorn in the side of social choice theory is formulated in the famous Gibbard-Satterthwaite Theorem <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b25">26]</ref>. This theorem essentially states that for any voting rule that is not a dictatorship, there are elections in which at least one of the voters would benefit by lying. A dictatorship is a voting rule where one of the voters-the dictator-single-handedly decides the outcome of the election.</p><p>Since the 1970s, when this impossibility result was established, an enormous amount of effort has been invested in discovering ways to circumvent it. Two prominent and well-established ways are allowing payments <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b28">29]</ref>, or restricting the voters' preferences <ref type="bibr" target="#b19">[20]</ref>.</p><p>In this paper, we wish to discuss a third path-the "path less taken", if you will-which has been explored by computer scientists. The Gibbard-Satterthwaite Theorem implies that in theory, voters are able to manipulate elections, i.e., bend them to their advantage by lying. But in practice, deciding which lie to employ may prove to be a hard computational problem; after all, there are a superpolynomial number of possibilities of ranking the candidates. Indeed, Bartholdi et al. <ref type="bibr" target="#b2">[3]</ref> put forward a voting rule where manipulation is N P-hard. In another important paper, <ref type="bibr">Bartholdi and</ref> Orlin <ref type="bibr" target="#b1">[2]</ref> greatly strengthened the approach by proving that the important Single Transferable Vote (STV) rule is hard to manipulate.</p><p>This line of research has enjoyed new life in recent years thanks to the influential work of Conitzer, Sandholm, and Lang <ref type="bibr" target="#b6">[7]</ref>. <ref type="foot" target="#foot_0">3</ref> The foregoing paper studied the complexity of coalitional manipulation. In this setting, there is a coalition of potentially untruthful voters, attempting to coordinate their ballots so as to get their favorite candidate elected. The authors further assume that the votes are weighted: some voters have more power than others. <ref type="bibr">Conitzer et al.</ref> show that in a variety of prominent voting rules, coalitional manipulation is N P-hard, even if there are only a constant number of candidates (for more details, see Section 2). This work has been extended in numerous directions, by different authors <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b24">25]</ref>; Elkind and Lipmaa <ref type="bibr" target="#b8">[9]</ref>, for example, strengthened the abovementioned results about coalitional manipulation by employing cryptographic techniques.</p><p>In short, computational complexity is by now a well-established method of circumventing the Gibbard-Satterthwaite Theorem. Unfortunately, a shortcoming of the results we mentioned above is that they are worst-case hardness results, and thus provide a poor obstacle against potential manipulators. Recent work regarding the frequency of manipulation has argued that with many worst-case hard-to-manipulate voting rules, a potential manipulator may be able to compute a manipulation in typical settings <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13]</ref>. In particular, Procaccia and Rosenschein <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> have established some theoretical results regarding the frequency of success of an algorithm for the coalitional manipulation problem. The matter was further discussed by Erdélyi et al. <ref type="bibr" target="#b10">[11]</ref>. In spite of this, the question of the tractability of the manipulation problem, and in particular of the coalitional manipulation problem, in typical settings is still wide-open.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Our approach and results</head><p>We wish to convince the reader that, indeed, the coalitional manipulation problem can be efficiently solved in typical settings under some prominent voting rules, but our approach differs from all previous work. We present efficient heuristic algorithms for the problem that provide theoretical guarantees. Indeed, we characterize small windows of instances on which our algorithms may fail; the algorithms are proven to succeed on all other instances. Specifically, we prove the following results regarding three of the most prominent voting rules (in which coalitional manipulation is known to be N P-hard even for a constant number of candidates):</p><p>Theorem.</p><p>1. In the Borda rule, if there exists a manipulation for an instance with certain weights, Algorithm 2 will succeed when given an extra manipulator with maximal weight. 2. In the Plurality with Runoff rule, if there exists a manipulation for an instance with certain weights, Algorithm 3 will succeed when given an extra manipulator with maximal weight. 3. In the Maximin rule, if there exists a manipulation for an instance with certain weights, Algorithm 1 will succeed when given two copies of the set of manipulators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Significance in Artificial Intelligence</head><p>The sharply increased interest in computational aspects of voting is motivated by numerous applications of voting techniques and paradigms to problems in Artificial Intelligence (AI). These applications include work in AI subfields as diverse as Planning <ref type="bibr" target="#b9">[10]</ref>, Automated Scheduling <ref type="bibr" target="#b16">[17]</ref>, Recommender Systems <ref type="bibr" target="#b13">[14]</ref>, Collaborative Filtering <ref type="bibr" target="#b21">[22]</ref>, Information Extraction <ref type="bibr" target="#b26">[27]</ref>, and Computational Linguistics <ref type="bibr" target="#b20">[21]</ref>.</p><p>Unfortunately, in the application of voting to AI, some of the problems investigated in Social Choice Theory, and in particular the issue of manipulation, become especially acute. Indeed, multiagent systems are often inhabited by heterogeneous, self-interested agents. Such agents, unlike human beings, can be designed to be rational, and constantly engaged in computations meant to increase their utility. In particular, a self-interested agent could seize the opportunity to manipulate an election to its benefit if such an opportunity were computationally easy to recognize (unless specifically programmed not to).</p><p>The agenda of circumventing the Gibbard-Satterthwaite Theorem via computational complexity is, once again, most relevant and compelling when the voters are software agents that populate a multiagent system, since the effective, bounded rationality of such agents is practically governed by the laws of computational complexity. This is why the agenda has become a prominent one in AI, with numerous papers on the subject published in the major AI conferences over the last five years. As of yet, there are few papers on frequency of manipulation, rather than on its worst-case complexity. We feel that this line of work on frequency of manipulation may influence the entire direction of the computational social choice research agenda (see Section 5 for more details regarding work on frequency of manipulation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structure of the article</head><p>In Section 2 we describe the major voting rules and formulate the coalitional manipulation problem. In Section 3 we present and analyze our algorithms in three subsections: Borda, Plurality with Runoff, and Maximin. We provide some results regarding an unweighted setting in Section 4. In Section 5 we describe related work at length. Finally, we discuss our approach in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Voting rules and manipulation problems</head><p>An election consists of a set C = {c 1 , . . . , c m } of candidates and a set S = {v 1 , . . . , v |S| } of voters. Each voter provides a total order on the candidates. To put it differently, each voter submits a ranking of the candidates. The voting setting also includes a voting rule, which is a function from the set of all possible combinations of votes to C .</p><p>We shall discuss the following voting rules (whenever the voting rule is based on scores, the candidate with the highest score wins):</p><p>• Scoring rules. Let α = α 1 , . . . , α m be a vector of non-negative integers such that α 1 α 2 • • • α m . For each voter, a candidate receives α 1 points if it is ranked first by the voter, α 2 if it is ranked second, etc. The score of a candidate is the total number of points the candidate receives. The scoring rules that we will consider are: Borda, where α = m -1, m -2, . . . , 0 ; Veto, where α = 1, 1, . . . , 1, 0 ; and Plurality, where α = 1, 0, . . . , 0 .</p><p>• Maximin. For any two distinct candidates x and y, let N(x, y) be the number of voters who prefer x to y. The maximin score of x is σ (x) = min y =x N(x, y).</p><p>• Copeland. For any two distinct candidates x and y, let C (x, y) = +1 if N(x, y) &gt; N( y, x) (in this case we say that x beats y in their pairwise election), C (x, y) = 0 if N(x, y) = N( y, x), and</p><formula xml:id="formula_0">C (x, y) = -1 if N(x, y) &lt; N( y, x). The Copeland score of candidate x is σ (x) = y =x C (x, y).</formula><p>• Plurality with Runoff. In this rule, a first round eliminates all candidates except the two with the highest plurality scores.</p><p>The second round determines the winner between these two by their pairwise election.</p><p>In some settings the voters are weighted. A weight function is a mapping w : S → N. When voters are weighted, the above rules are applied by considering a voter of weight l to be l different voters.</p><p>Definition 2.1.</p><p>1. In the Constructive Coalitional Weighted Manipulation (CCWM) problem in a voting rule F , we are given a set C of candidates, with a distinguished candidate p ∈ C , a set of weighted voters S that already cast their votes (these are the truthful voters), and a list of weights W for a set of voters T that still have not cast their votes (the manipulators). We are asked whether there is a way to cast the votes in T such that p wins the election under the voting rule F . 2. Constructive Coalitional Unweighted Manipulation (CCUM) problem is a special case of CCWM problem where all the weights equal 1.</p><p>Remark 2.2. We implicitly assume in both questions that the manipulators have full knowledge about the other votes. Unless explicitly stated otherwise, we also assume that ties are broken adversarially to the manipulators, so if p ties with another candidate, p loses. The latter assumption is equivalent to formulating the manipulation problems in their unique winner version, when one assumes that all candidates with maximal score win, but asks that p be the only winner.</p><p>Theorem 2.3. (See <ref type="bibr" target="#b6">[7]</ref>.) The CCWM problem in Borda, Veto, Maximin, Copeland, and Plurality with Runoff is N P-complete, even when the number of candidates is constant.</p><p>Throughout this paper we will use the convention that |C| = m, |S| = N and |T | = n. Whenever the voting rule is based on scores, we will denote by σ S, j (c) the accumulated score of candidate c from the voters in S and the first j voters of T (fixing some order on the voters of T ). Whenever it is clear from the context that S is fixed, we will use simply σ j (c) for the same. Also, for G ⊆ C , 0 j n we will write σ j (G) = {σ j (g) | g ∈ G}. For two lists A, B (ordered multisets), we denote by A + B the list that is obtained after B is appended to A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Weighted coalitional manipulation</head><p>We begin our contribution by presenting a general greedy algorithm for the coalitional manipulation problem. Some of our main results concern this algorithm or its restriction to scoring rules.</p><p>The greedy algorithm is given as Algorithm 1. It works as follows: the manipulators, according to descending weights, each rank p first and rank the other candidates in a way that minimizes their maximum score. This algorithm is a generalization of the one that appeared in Bartholdi et al. <ref type="bibr" target="#b2">[3]</ref>. Definition 3.1. We refer to an iteration of the main for loop in lines 4-12 of the algorithm as a stage of the algorithm.</p><p>We will use the fact that for many voting rules, if there exists a manipulation for a coalition of manipulators with weight list W , then there exists a manipulation for a coalition of manipulators with weight list W where W ⊇ W . Normally, if the coalition is too small then there is no manipulation, and this is indeed what the algorithm will report. On the other hand, if the coalition is large enough, then the greedy algorithm will find the manipulation. So there remains a window of </p><formula xml:id="formula_1">σ j (p) = σ j-1 (p) + w j α 1</formula><p>Put p at the first place of the jth preference list 4:</p><p>Let t 1 , t 2 , . . . ,t m-1 s.t. ∀l, σ j-1 (c t l-1 ) σ j-1 (c t l ) 5:</p><formula xml:id="formula_2">j votes p c t1 • • • c tm-1 6: for l = 1, . . . ,m -1 do</formula><p>Update the scores 7: error, where for some coalitions there could exist a manipulation, but the algorithm may not find it. We are interested in bounding the size of this window. We first formulate the monotonicity property described above. Definition 3.2. In the context of the CCWM problem, a voting rule is said to be monotone in weights if it satisfies the following property: whenever there is a manipulation making p win for manipulator set T with weight list W , there is also a manipulation making p win for manipulator set T with weight list W , where T ⊇ T , W ⊇ W .</p><formula xml:id="formula_3">σ j (c t l ) = σ j-1 (c t l ) + w j α</formula><p>Monotonicity in weights is a prerequisite for the type of analysis we wish to present. However, surprisingly, not all the basic voting rules have this property; in particular, the prominent Copeland rule does not possess it. We show this by example in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Borda</head><p>In this subsection, we analyze the performance of Algorithm 1 with respect to the Borda voting rule. Note that, in the context of scoring rules, Algorithm 1 reduces to Algorithm 2. This algorithm first appeared in Procaccia and Rosenschein <ref type="bibr" target="#b23">[24]</ref>. In this specific instantiation of Algorithm 1, we do not require sorting of the manipulator weights, as this does not play a part in our analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.3. Scoring rules are monotone in weights.</head><p>Proof. Let C be the candidate set; p ∈ C is the preferred candidate, S is the set of truthful voters, and W are the weights for the manipulators</p><formula xml:id="formula_4">T . Denote |C| = m, |S| = N, |W | = |T | = n.</formula><p>It is enough to show that if there is a manipulation for the set T , then for the same instance with manipulators T = T + {v} with weight list W = W + {w}, where w 1 is an integer, there is also a manipulation, and the rest will follow by induction.</p><p>Let α = α 1 , . . . , α m be the score vector of the rule. Let X S be the preference orders of the voters in S, and X T be the preference orders of voters in T that make p win. Fix some order on the voters in T . By definition, for all c ∈ C \ {p}, σ n (c) &lt; σ n (p). Let the additional voter of T rank p at the first place, and report some arbitrary order on the other candidates. Then for all c ∈ C \ {p}, σ n+1 (p) = σ n (p) + wα 1 &gt; σ n (c) + wα 1 σ n+1 (c). Hence, p wins. 2</p><p>We are now ready to present our theorem regarding the Borda rule. Theorem 3.4. In the CCWM problem under Borda, let C be a set of candidates with p ∈ C a preferred candidate, S a set of voters who already cast their votes. Let W be the weight list for the set T . Then:</p><p>1. If there is no ballot making p win the election, then Algorithm 2 will return false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>If there exists a ballot making p win the election, then for the same instance with weight list W + {w 1 , . . . , w k }, where k 1, k i=1 w i max(W ), Algorithm 2 will return true.</p><p>Before we proceed to the theorem's proof, a short discussion is in order. Despite its mathematical formulation, one should not think of Item 2 of the theorem as saying that if the algorithm fails on one instance, it would succeed on another. Rather, the theorem implies that the algorithm succeeds on any given instance such that there is a "smaller" instance (where the manipulators have less weight) on which success is possible. Here the monotonicity in weights property comes into play. Also note that Item 1 of the theorem is true for any constructive algorithm; this item (which also appears in our subsequent theorems) is trivially satisfied.</p><p>Another interesting point is that this theorem can be viewed as implying that Algorithm 2 gives some sort of additive approximation ratio. Formally, it seems unnatural to adopt the notion of approximation algorithms in the context of the CCWM problem. However, the exact way in which the theorem yields approximation guarantees will become apparent when we discuss the unweighted setting, in Section 4.</p><p>A key notion for the proof of the theorem is the definition of the set G W . Let W be list of weights; we define G W as follows. Run the algorithm n + 1 stages with the weights W + {w}, where w is an arbitrary weight.</p><p>Let G 0 W = argmax g∈C \{p} {σ 0 (g)}, and, by induction, for s = 1, 2, . . .</p><formula xml:id="formula_5">: G s W = G s-1 W ∪ {g | g was ranked below some g ∈ G s-1 W in some stage l, 1 l n + 1}. Finally, let G W = 0 s G s W .</formula><p>Informally, G W is constructed by taking candidates that initially have maximum score, and then inductively adding candidates that are ranked by the algorithm below candidates that were already added to the set. Since the algorithm ranks stronger candidates below weaker candidates, only strong candidates are ultimately members of G W . The additional arbitrary weight w, and the existence of stage n + 1 (when there are in fact only n manipulators with weights W ) are just a formality: we are also interested in the way the algorithm would rank the candidates after all the manipulators have cast their ballots, but we do not care about their scores after this final "virtual" ranking.</p><p>Observe that the indices s = 1, . . . are not directly related to stages l = 1, . . . ,n:</p><formula xml:id="formula_6">a candidate c is added to G s W if he is ranked below a candidate c ∈ G s-1</formula><p>W in some stage l = 1, . . . ,n (e.g., not necessarily in stage s). Notice that the above definition is independent of the weight w, as this weight is used only in stage n + 1, so it does not impact the preferences of the voters, and thus it does not impact G W . From the definition, G 0</p><formula xml:id="formula_7">W ⊆ G 1 W ⊆ • • • ⊆ C \ {p}. Furthermore, as |C \ {p}| = m -1, it follows that there exists 0 s m -2 s.t. G s W = G s +1 W , and thus G W = G s W = G m-2</formula><p>W . We are now ready to unfold the proof of Theorem 3.4. The proof relies on Lemmata 3.5-3.13. The general intuition of the proof is as follows. Consider the candidates in G W ; we show that if there exists a manipulation, it must be possible to get the score of p to be higher than their average score. The difficult part is to show that the average score of the candidates in G W is relatively close to the maximal final score. As a result, a few additional manipulators are sufficient to push p above the maximal score as well.</p><p>In the first three lemmata, Lemmata 3.5-3.7, we show that the candidates in G W are the ones with highest scores and we give a connection between their average score and the success of the algorithm in finding a manipulation. The next straightforward lemma formalizes the intuition that the strong candidates in G W are always ranked last by the algorithm. Lemma 3.5. Given W , the candidates in G W were ranked at each stage l, 1 l n + 1 at the |G W | last places, i.e., they were always granted the points |G W | -1, . . . , 0.</p><p>Proof. If, by way of contradiction, there exists c ∈ C \ G W that was ranked in some stage in one of the last |G W | places, then there is g ∈ G W that was ranked above c at this stage. Let s 0 such that g ∈ G s W . By definition, c ∈ G s+1 W ⇒ c ∈ G W , a contradiction. 2 Lemma 3.6, directly building on Lemma 3.5, states that when the algorithm terminates, the candidates in G W have scores that are higher than any candidate outside the set, perhaps except p.</p><formula xml:id="formula_8">Lemma 3.6. For all c ∈ C \ (G W ∪ {p}), it holds that σ n (c) min g∈G W {σ n (g)}.</formula><p>Proof. Suppose, for contradiction, that there are</p><formula xml:id="formula_9">c ∈ C \ (G W ∪ {p}) and g ∈ G W , s.t. σ n (c) &gt; σ n (g). Then in stage n + 1, c would have been ranked below g. Let s 0 s.t. g ∈ G s W . Then c ∈ G s+1 W ⇒ c ∈ G W , a contradiction. 2</formula><p>The next lemma clarifies the connection between the definition of G W and Theorem 3.4. Indeed, it links the average score of the candidates in G W (when the algorithm terminates) and the answer returned by the algorithm. Lemma 3.7. Given W , |W | = n, let G W be as before. Denote by q(W ) the average score of candidates in G W after n stages: q(W ) =</p><formula xml:id="formula_10">1 |G W | g∈G W σ n (g). Then:</formula><p>1. If σ n (p) q(W ) then there is no manipulation that makes p win the election, and the algorithm will return false. 2. If σ n (p) &gt; max g∈G W {σ n (g)}, then there is a manipulation that makes p win, and the algorithm will find it.</p><p>Proof. We first prove part 1. Denote W = {w 1 , . . . , w n }. We have the set G W , and we suppose that σ n (p) q(W ). Let us consider a ballot X T of votes in T , and let σ n (c) be the scores of the candidates c ∈ C implied by this ballot (including all the votes in S). Since in Algorithm 2 p was placed at the top of the preference of each voter in T , we have that:</p><formula xml:id="formula_11">σ n (p) = σ 0 (p) + n j=1 w j (m -1) σ n (p). (1)</formula><p>On the other hand, since by Lemma 3.5, in Algorithm 2 the candidates of G W were ranked by all the voters in T in the last</p><formula xml:id="formula_12">|G W | places, it follows that q(W ) = 1 |G W | g∈G W σ 0 (g) + n j=1 w j |G W |-1 i=0 i 1 |G W | g∈G W σ n (g) =: q (X T ).</formula><p>(</p><formula xml:id="formula_13">)<label>2</label></formula><p>Combining together ( <ref type="formula">1</ref>) and ( <ref type="formula" target="#formula_13">2</ref>) we get that σ n (p) q (X T ). There is at least one g ∈ G W such that σ n (g) q (X T ) (since q (X T ) is the average of the scores), hence σ n (p) σ n (g), and so p will not win when X T is applied.</p><p>Also note that Algorithm 2 returns true only if it constructs a (valid) ballot that makes p win, and so for the case σ n (p) q(W ) the algorithm will return false.</p><p>We now prove part 2 of the lemma.</p><formula xml:id="formula_14">If σ n (p) &gt; max g∈G W {σ n (g)}, then by Lemma 3.6 for all c ∈ C \ {p}, σ n (p) &gt; σ n (c),</formula><p>and so the algorithm will find the manipulation. 2</p><p>Lemma 3.8 is independent of the lemmata before and after it, but is used directly in the proof of Theorem 3.4. It gives a connection between the average score of the candidates in G W +{w} and G W , where w is the weight of some additional manipulator. In other words, it bounds the effect that adding a manipulator has on the average score of the strong candidates. Lemma 3.8. Let G W , q(W ) be as before. Then for w 1, q(W + {w})q(W ) w m-2 2 .</p><p>Proof. First, G W ⊆ G W +{w} , because for all s 0, G s W ⊆ G s W +{w} . Now, for all g ∈ G W +{w} \ G W , g was not ranked in the first n + 1 stages after any candidate in G W , and so for all g ∈ G W , σ n (g) σ n (g ), and hence</p><formula xml:id="formula_15">1 |G W +{w} | g∈G W +{w} σ n (g) 1 |G W | g ∈G W σ n (g ) = q(W ).</formula><p>Now we can proceed:</p><formula xml:id="formula_16">q W + {w} = 1 |G W +{w} | g∈G W +{w} σ n+1 (g) = 1 |G W +{w} | g∈G W +{w} σ n (g) + w |G W +{w} | |G W +{w} |-1 i=0 i q(W ) + w m -1 m-2 i=0 i = q(W ) + w m -2 2 .</formula><p>And so, q(W + {w}) -</p><formula xml:id="formula_17">q(W ) w m-2 2 .</formula><p>2</p><p>The purpose of Lemmata 3.10-3.13 is to show that for any weight list</p><formula xml:id="formula_18">W , |W | = n it holds that max g∈G W {σ n (g)}-q(W ) max(W ) m-2</formula><p>2 . This fact is stated in Lemma 3.13, which is the only one directly used in the proof of Theorem 3.4. First we need to show that the scores of candidates in G W are concentrated, in a sense. This is intuitive, since the algorithm doesn't allow the score of any candidate in G W to "escape" by ranking it close to the bottom if its score becomes too high in some stage. We will require the following definition: Definition 3.9. For an integer w 0, a finite non-empty set of integers A is called w-dense if when we sort the set in</p><formula xml:id="formula_19">nonincreasing order b 1 b 2 • • • b k (such that {b 1 , . . . , b k } = A), it holds that for all 1 j k -1, b j+1 b j -w.</formula><p>So, formally, we want to show (Lemma 3.12) that σ n (G W ) is w max -dense, where w max = max W . This will be accomplished via a number of technical steps. </p><formula xml:id="formula_20">∈ G s W \ G s-1 W there exist g ∈ G s-1</formula><p>W , X ⊆ C \ {p} (perhaps X = ∅) and j, 0 j n, s.t. {σ j (g), σ j (g )} ∪ σ j (X) is w max -dense, where w max = max(W ).</p><formula xml:id="formula_21">Proof. Let s 1 and g ∈ G s W \ G s-1 W . By definition, there exist g ∈ G s-1 W</formula><p>and a minimal j, 1 j n + 1, such that g was ranked below g in stage j. We distinguish between two cases:</p><p>Case 1: j &gt; 1. In this case g was ranked above g in stage j -1. So we have:</p><formula xml:id="formula_22">σ j-1 (g) σ j-1 (g ), (<label>3</label></formula><formula xml:id="formula_23">)</formula><formula xml:id="formula_24">σ j-2 (g) σ j-2 (g ). (<label>4</label></formula><formula xml:id="formula_25">)</formula><p>Denote α d (h) := m-(place of h ∈ C at the preference list of voter d). Further, denote by w d the weight of voter d (so in stage d, h gets w d α d (h) points). g was ranked above g in stage j -1, and hence α j-1 (g) &gt; α j-1 (g ). Denote l = α j-1 (g)α j-1 (g ), and w := w j-1 . Let g = g 0 , g 1 , . . . , g l = g be the candidates that got in stage j -1 the points wα j-1 (g ), w(α j-1 (g ) + 1), . . . , w(α j-1 (g ) + l), respectively. Our purpose is to show that {σ j-1 (g 0 ), . . . , σ j-1 (g l )} is w- dense, and therefore w max -dense. By definition of the algorithm,</p><formula xml:id="formula_26">σ j-2 (g 0 ) σ j-2 (g 1 ) • • • σ j-2 (g l ).</formula><p>(</p><p>Denote u t = σ j-2 (g t ) + wα j-1 (g ) for 0 t l. Then ∀t, 0 t l, σ j-1 (g t ) = u t + wt.</p><p>(</p><formula xml:id="formula_28">)<label>6</label></formula><p>So we need to show that {u t + wt | 0 t l} is w-dense. It is enough to show that:</p><p>(a) For all t, 0 t l, if u t + wt &lt; u 0 , then there exists t , t &lt; t l, s.t. u t + wt &lt; u t + wt u t + w(t + 1), and (b) For all t, 0 t l, if u t + wt &gt; u 0 , then there exists t , 0 t &lt; t, s.t. u t + w(t -1) u t + wt &lt; u t + wt.</p><p>Proof of (a): From (5) we get</p><formula xml:id="formula_29">u 0 • • • u l . (7)</formula><p>Also from (3) and ( <ref type="formula" target="#formula_28">6</ref>) we have u 0 u l + wl. Let 0 t l -1 s.t. u t + wt &lt; u 0 . Let us consider the sequence u t + wt, u t+1 + w(t +1), . . . , u l + wl. Since u t + wt &lt; u 0 u l + wl, it follows that there is a minimal index t , t &lt; t l s.t. u t + wt &lt; u t + wt . Then u t -1 + w(t -1) u t + wt, and thus</p><formula xml:id="formula_30">u t -1 + wt u t + w(t + 1).<label>(8)</label></formula><p>From ( <ref type="formula">7</ref>) u t u t -1 , and then</p><formula xml:id="formula_31">u t + wt u t -1 + wt . (<label>9</label></formula><formula xml:id="formula_32">)</formula><p>Combining ( <ref type="formula" target="#formula_30">8</ref>) and ( <ref type="formula" target="#formula_31">9</ref>) together, we get u t + wt u t + w(t + 1). This concludes the proof of (a). The proof of (b) is analogous, by choosing t to be the maximal index such that u t + wt &lt; u t + wt.</p><p>Case 2: j = 1. We proceed by essentially reducing this case to Case 1. In Case 2 we have that s 2, because otherwise, if</p><formula xml:id="formula_33">s = 1, then g ∈ G 0 W ; therefore σ 0 (g) σ 0 (g ) = max h∈C \{p} {σ 0 (h)} ⇒ g ∈ G 0 W , a contradiction. g / ∈ G s-2</formula><p>W , because otherwise, by definition, g ∈ G s-1 W . Therefore there exists g ∈ G s-2 W s.t. g was ranked below g in some stage j , i.e., σ j -1 (g ) σ j -1 (g ). g has never been ranked below g (because otherwise g ∈ G s-1 W ), and it follows that σ j -1 (g) σ j -1 (g ). By combining the last arguments, we get that σ j -1 (g) σ j -1 (g ).</p><p>Let j 0 be minimal s.t. σ j 0 (g) σ j 0 (g ). As in stage 1g was ranked below g , it holds that σ 0 (g) σ 0 (g ). If j 0 = 0 then σ 0 (g) = σ 0 (g ), hence {σ 0 (g), σ 0 (g )} is 0-dense, and in particular w max -dense.</p><p>Otherwise ( j 0 = 0) it holds that σ j 0 -1 (g) &gt; σ j 0 -1 (g ) by the minimality of j 0 . So, we have that σ j 0 (g ) σ j 0 (g), and σ j 0 -1 (g ) σ j 0 -1 (g).</p><p>These two inequalities are analogous to (3) and ( <ref type="formula" target="#formula_24">4</ref>), with j -1 replaced by j 0 , and the roles of g and g exchanged. From this point we can proceed exactly as in Case 1, keeping in mind these cosmetic changes. 2</p><p>The following lemma asserts that a dense set of the scores of candidates in stage j can be replaced by a dense set of final scores by considering a possibly larger set of candidates. </p><formula xml:id="formula_34">(G W ) is w max -dense. Proof. Let g = g 0 ∈ G W . If g / ∈ G 0 W , then g ∈ G s W \ G s-1 W</formula><p>for some s 1. By Lemma 3.10 there exist</p><formula xml:id="formula_35">g 1 ∈ G s-1 W and X 1 ⊆ C \ {p} s.t. {σ j (g 0 ), σ j (g 1 )} ∪ σ j (X 1</formula><p>) is w max -dense for some 0 j n. By Lemma 3.11 there exists </p><formula xml:id="formula_36">X 1 , X 1 ⊆ X 1 ⊆ C \ {p}, s.t. {σ n (g 0 ), σ n (g 1 )} ∪ σ n (X 1 ) is w max -dense. Denote Z 1 := {g 0 , g 1 } ∪ X 1 . Similarly, if g 1 / ∈ G 0 W , then there exist g 2 ∈ G s-2 W and X 2 s.t. {σ n (g 1 ), σ n (g 2 )} ∪ σ n (X 2 ) is w max -dense. Denote Z 2 := {g 1 , g 2 } ∪ X 2 ,</formula><formula xml:id="formula_37">g s ∈ G 0 W .</formula><p>It is easy to see that for two w-dense sets A, A , if A ∩ A = ∅ then A ∪ A is also w-dense, and hence we get Z g := s+1 t=1 Z t is w max -dense. Note that σ 0 (G 0 W ) is w max -dense, and hence there exists Ẑ , G 0</p><formula xml:id="formula_38">W ⊆ Ẑ ⊆ C \ {p} s.t. σ n ( Ẑ ) is w max - dense. Hence, σ n (Z g ∪ Ẑ ) is w max -dense.</formula><p>The sets Z g ∪ Ẑ , for all g ∈ G W , all intersect in Ẑ , and their union is Ẑ ∪ g∈G W Z g . We deduce that {σ n (g) | g ∈ Ẑ ∪ g∈G W Z g } is w max -dense. By Lemma 3.6, for all h ∈ Ẑ ∪ g∈G W Z g , if h / ∈ G W , then σ n (h) min g∈G W {σ n (g)}, and hence σ n (G W ) is a also w max -dense. 2 Lemma 3.13. Let W be a list of weights, |W | = n, w max = max(W ). Let G W be as before, and denote q(W ) = 1</p><formula xml:id="formula_39">|G W | g∈G W σ n (g), as before. Then max g∈G W {σ n (g)} -q(W ) w max m-2 2 .</formula><p>Proof. Sort the members of G W by their scores after the nth stage, i.e., G W = {g 1 , . . . ,</p><formula xml:id="formula_40">g |G W | } s.t. for all 1 t |G W | -1, σ n (g t ) σ n (g t+1 ). Denote for 1 t |G W |, u t = σ n (g 1 ) -w max (t -1), and let U = {u 1 , . . . , u |G W | }. |U | = |G W |, max U = σ n (g 1 ) = max g∈G W {σ n (g)}.</formula><p>By Lemma 3.12, it is easy to see that for all 1 t |G W |, σ n (g t ) u t . Consequently, q(W )</p><formula xml:id="formula_41">1 |G W | |G W | t=1 u t , hence max g∈G W σ n (g) -q(W ) = u 1 -q(W ) u 1 - 1 |G W | |G W | t=1 u t = w max |G W | -1 2 w max m -2 2 . 2</formula><p>We are finally ready to prove Theorem 3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 3.4.</head><p>Regarding part 1, Algorithm 2 returns true only if it constructs a (valid) ballot that makes p win, and thus if there is no ballot making p win, Algorithm 2 will return false.</p><p>We now prove part 2 of the theorem. Suppose that there exists a ballot making p win for weight list W , |W | = n. Let W := W + {w 1 , . . . , w k } for k 1, k i=1 w i max(W ). By Lemma 3.7, σ n (p) &gt; q(W ). From Lemma 3.8 we get by induction that</p><formula xml:id="formula_42">q(W ) q(W ) + k i=1 w i • m -2 2 . (<label>10</label></formula><formula xml:id="formula_43">)</formula><p>By Lemma 3.13 and (10) we get:</p><formula xml:id="formula_44">max g∈G W σ n+k (g) q(W ) + max(W ) • m -2 2 q(W ) + k i=1 w i • m -2 2 q(W ) + k i=1 w i • (m -2) &lt; σ n (p) + k i=1 w i • (m -1) = σ n+k (p)</formula><p>and hence, by Lemma 3.7 the algorithm will find a ballot making p win for set T with weights W , and will return true.</p><p>This completes the proof of Theorem 3.4. 2</p><p>The following is an example where there is a manipulation for weight list W , but Algorithm 2 will find a manipulation only for weight list W + {w }.  Evidently, for any c ∈ C \ {p}, σ 4 (p) = 29 &gt; σ 4 (c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Maximin</head><p>In this subsection, we show that Algorithm 1 also does well with respect to the Maximin rule.</p><p>Lemma 3.15. Maximin is monotone in weights.</p><p>Proof. Let X S be the preference orders of the voters in S, and let X T be the preference orders of the voters in T that make p win. We need to show that there are preference orders for T = T + {v} with weight list W = W + {w} where w 1 is an integer, that make p win. Fix some order on voters in T . By definition, for all c ∈ C \ {p}, σ n (c) &lt; σ n (p). Let the additional voter of T vote with p at the first place, and some arbitrary order on the other candidates. Then for all</p><formula xml:id="formula_45">c ∈ C \ {p}, σ n+1 (p) = σ n (p) + w &gt; σ n (c) + w σ n+1 (c)</formula><p>, and so we got the ballot of votes of T to make p win. 2</p><p>Theorem 3.16. In CCWM under Maximin, let C be the set of candidates with p ∈ C the preferred candidate, and S the set of voters who already cast their votes. Let W be the weight list for the set T . Then:</p><p>1. If there is no ballot making p win the election, then Algorithm 1 will return false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>If there is a ballot making p win the election, then for the same instance with weight list W s.t. W ⊇ W + W (i.e., W contains two copies of W ), Algorithm 1 will return true.</p><p>Let us introduce some more notation. For candidates g, g ∈ C and 0 j n we denote by N j (g, g ) the total weight of the voters after j stages (including the voters in S) that prefer g over g . So σ j (g) = min g ∈C\{g} N j (g, g ). We also denote for g ∈ C , 0 j n:</p><formula xml:id="formula_46">MIN j (g) = h ∈ C \ {g} | N j (g, h) = σ j (g) .</formula><p>In words, MIN j (g) is the set of candidates that constitute the worst opponents of g in pairwise elections at stage j. Put differently, these are the candidates whose competition against g defines the Maximin score of g at stage j.</p><p>Fixing the set C , p ∈ C , and an order on the weight list W , we denote by f ( j) the maximal score of p's opponents distributed by Algorithm 1 after j stages:</p><formula xml:id="formula_47">f ( j) = max g∈C \{p} σ j (g).</formula><p>In Algorithm 1, p is always placed at the top of each preference, and so with each voter its score grows by the weight of this voter. In our next lemma we will put forward an upper bound on the growth rate of the scores of p's opponents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.17. Consider Algorithm 1 applied to the Maximin rule. Denote by w j the weight of the jth voter processed by the algorithm.</head><p>Then for all 0</p><formula xml:id="formula_48">j n -2, f ( j + 2) f ( j) + max{w j+1 , w j+2 }.</formula><p>To intuitively see why the lemma implies Theorem 3.16, notice that if there are two copies of W , the score of p would increase by 2 • w∈W w, whereas by the lemma the score of the strongest candidate would increase by at most w∈W w.</p><p>We now prove the lemma; the theorem will follow easily.</p><p>Proof. Let 0 j n -2. Let g = p be a candidate. By definition σ j (g) f ( j). We would like to show that σ j+2 (g) f ( j) + max{w j+1 , w j+2 }. If σ j+1 (g) f ( j), then σ j+2 (g) σ j+1 (g) + w j+2 f ( j) + max{w j+1 , w j+2 }, and we are done. So let us assume now that σ j+1 (g) &gt; f ( j).</p><p>Define a directed graph G = (V , E), where</p><formula xml:id="formula_49">V = {g} ∪ x ∈ C \ {p} | x was ranked below g in stage j + 1 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and (x, y) ∈ E iff y ∈ MIN j (x).</head><p>There is at least one outgoing edge from g in E, since otherwise there was g ∈ MIN j (g) that voter j + 1 ranked above g, and then σ j+1 (g) = σ j (g) f ( j), a contradiction. In addition, we claim that for all x ∈ V \ {g} there is at least one outgoing edge from x in E. Indeed, otherwise there is x ∈ MIN j (x) that was ranked above g in stage j + 1. Hence, we have that</p><formula xml:id="formula_50">σ j+1 (x) = σ j (x) f ( j) &lt; σ j+1 (g).</formula><p>This implies that Algorithm 1 should have ranked x above g in stage j + 1, which is a contradiction to the fact that x ∈ V \ {g}.</p><p>For x ∈ V , denote by V (x) all the vertices y in V such that there exists a directed path from x to y. Denote by G(x) the sub-graph of G induced by V (x). It is easy to see that G(g) contains at least one cycle. Let U be one such cycle. Let g ∈ U be the vertex that was ranked highest among the vertices of U in stage j + 1. Let g be the vertex before g in the cycle:</p><p>(g , g ) ∈ U . Since g was ranked below g at stage j + 1, it follows that σ j+1 (g ) = σ j (g ) f ( j).</p><p>Suppose, for contradiction, that σ j+2 (g) &gt; f ( j) + max{w j+1 , w j+2 }. g was ranked by j + 2 at place t * . Then g was ranked by j + 2 above t * , since otherwise when we had reached the place t * , we would pick g (with score σ j+2 (g )</p><formula xml:id="formula_51">f ( j) + w j+2 &lt; σ j+2 (g)) instead of g-a contradiction.</formula><p>Denote by X 1 all the vertices in V (g) that have an outgoing edge to g in G(g). For all x ∈ X 1 , g ∈ MIN j (x), i.e., σ j (x) = N j (x, g ). All x ∈ X 1 were ranked by j + 2 above g, since otherwise, if there was x ∈ X 1 , s.t. until the place t * it still was not added to the preference list, then when evaluating its score on place t * , we would get: σ j+2 (x) N j+2 (x, g ) = N j+1 (x, g ) N j (x, g ) + w j+1 = σ j (x) + w j+1 &lt; σ j+2 (g), and so we would put x instead of g.</p><p>Denote by X 2 all the vertices in V (g) that have an outgoing edge to some vertex x ∈ X 1 . In the same manner we can show that all the vertices in X 2 were ranked in stage j + 2 above g. We continue in this manner, by defining sets X 3 , . . . , where the set X l contains all vertices in V (g) that have an outgoing edge to some vertex in X l-1 ; the argument above shows that all elements of these sets are ranked above g in stage j + 2. As there is a path from g to g in G(g), we will eventually reach g in this way, i.e., there is some l such that X l contains a vertex g 0 with an edge from g to g 0 (see Fig. <ref type="figure" target="#fig_2">1</ref>).</p><p>Thus,</p><formula xml:id="formula_52">σ j+2 (g) N j+2 (g, g 0 ) = N j+1 (g, g 0 ) N j (g, g 0 ) + w j+1 = σ j (g) + w j+1 f ( j) + max{w j+1 , w j+2 } &lt; σ j+2 (g), a contradiction. 2</formula><p>We are now ready to prove Theorem 3.16.</p><p>Proof. We prove part 1. Algorithm 1 returns true only if it constructs a (valid) ballot that makes p win, and thus if there is no ballot making p win, Algorithm 1 will return false.</p><p>We now prove part 2. Suppose that there exists a ballot Z T making p win for weight list W = {w 1 , . . . , w n }. Let σ j (g) be the scores implied by Z T . Then:</p><formula xml:id="formula_53">f (0) &lt; σ n (p) σ 0 (p) + n i=1 w i . (<label>11</label></formula><formula xml:id="formula_54">)</formula><p>Let W = W + W + X , where X is some list of weights (possibly empty). We need to show that σ |W | (p) &gt; f (|W |). In Algorithm 1, after sorting the weights of W , the equal weights of two copies of W will be adjacent, i.e., the order of weights in W will be of the form:</p><p>x 1 , . . . , x q 1 , w 1 , w 1 , x q 1 +1 , . . . , x q 2 , w 2 , w 2 , . . . , w n , w n , x q n +1 , . . . , x |X| .</p><p>By Lemma 3.17, one can prove by induction that:</p><formula xml:id="formula_55">f |W | f (0) + |X| i=1 x i + n i=1 w i . (<label>12</label></formula><formula xml:id="formula_56">)</formula><p>And so by <ref type="bibr" target="#b10">(11)</ref> and <ref type="bibr" target="#b11">(12)</ref> we have:</p><formula xml:id="formula_57">σ |W | (p) = σ 0 (p) + |X| i=1 x i + 2 n i=1 w i &gt; f (0) + |X| i=1 x i + n i=1 w i f |W | . 2</formula><p>In Appendix B we give a simple algorithm, which is tailor-made for Maximin, and also enjoys the implications of Theorem 3.16. However, this algorithm does not extend to other voting rules, as Algorithm 1 does. Moreover, we believe that Algorithm 1 does better when it comes to unweighted manipulation (see Sections 4 and 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Plurality with runoff</head><p>In this subsection we present a heuristic algorithm for the CCWM problem in Plurality with Runoff. The algorithm receives as a parameter a size of window 0 u max(W ) where it can give a wrong answer. Its running time depends on the size of its input and on u (see below). We begin by noting: Lemma 3.18. Plurality with Runoff is monotone in weights.</p><p>Proof. Let C be the candidates, p ∈ C is the preferred candidate, S is the set of truthful voters, and W are the weights for manipulators of T . Suppose that there is a ballot of votes of T that makes p win the election. We need to show that there is a ballot making p win for the set W = W + {w}, where w 1. Let g be the candidate that proceeds with p to the second round in the winning ballot for W . Let the additional voter vote p . . . . Then the plurality score of p and g will not decrease, while the plurality score of any other candidate will remain the same, and so p and g will proceed to the next round in the new ballot as well. In the second round p will beat g in the new ballot, since the total weight of the voters who prefer p to g increased, while the total weight of voters who prefer g to p remained the same. Thus, p will win the election in the new ballot. 2</p><p>We will now give an informal description of the algorithm. We go over all the candidates other than p. To each candidate g we try to assign the voters with minimal total weight, such that if these voters place g first, g continues to the second round; the rest of the voters rank p first. If we succeeded in this way to make g and p survive the first round, and in the second round p beats g, then we found a valid ballot for making p win the election. If no candidate g was found in this way, then we report that there is no ballot.</p><p>A formal description of this algorithm, Algorithm 3, is given below. The following additional notations are required.</p><p>Denote by β X (g) the plurality score of g from voter set X (i.e., the sum of weights of the voters in X that put g at the top of their preferences). We also use N X (g, g ) = v∈U w v , where U is the set of all the voters in X that prefer g to g , and w v is the weight of voter v. Finally, for g, g ∈ C we denote g g if a tie between g and g is broken in favor of g.</p><p>Remark 3.19. In Algorithm 3 we do not rely on the assumption that for all g = p, g p. In fact, the algorithm can deal with any tie-breaking mechanism such that for every two distinct candidates x and y, either x y or y x, regardless of how the manipulators cast their votes. An example of such a tie-breaking mechanism is to favor candidates with smaller indices, according to some order on the candidates. This is not necessarily a reasonable way to break ties in, say, political elections, but roughly speaking it is more general than asking that p be a unique winner, the assumption underlying our previous results.</p><p>More precisely, Plurality with Runoff differs from Borda and Maximin in the sense that it has two different rounds, and therefore two different "scores". Hence, the unique winner model can be interpreted ambiguously in this context. If we always break ties against p (the algorithm supports this), p might be tied against another candidate for the second ticket to the second round, and lose, whereas under another interpretation p would have advanced to the second round, and would have won the second round by a vast majority, thus becoming a unique winner.</p><p>In the next theorem we prove the correctness of Algorithm 3, and analyze its time complexity. We will see that for getting an exact answer (u = 0), we will need running time which is polynomial in max(W ) and the rest of the input. As the weights in W are specified in binary representation, this requires exponential time. However, when the size of the error window increases, the complexity decreases, so for u = Ω( max(W ) log(max(W )) ) the complexity of the algorithm is polynomial in its input.</p><p>Theorem 3.20. In CCWM under Plurality with Runoff, let C be the set of candidates with p ∈ C the preferred candidate, and S be the set of voters who already cast their votes. Let W be the weight list for the set T , and let u 0 be the error window. Then:</p><p>1. If there is no ballot making p win the election, then Algorithm 3 will return false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>If there is a ballot making p win the election, then for the same problem with voter set T = T + {v n+1 , . . . , v n+l } with weight list W = W + {w n+1 , . . . , w n+l }, where l 0, l j=1 w n+ j u, Algorithm 3 will return true. x ← subset-of-weights-approximate(W , λ g , u)</p><p>12:</p><p>x ∈ {0, 1} n minimizes { n j=1 w j x j | n j=1 w j x j λ g , ∀ j, x j ∈ {0, 1}} 13:</p><p>All the voters j s.t. x j = 1 vote g . . .</p><p>Order of candidates except g is arbitrary 14:</p><p>All the voters j s.t. x j = 0 vote p . . .  Proof. We start with part 1. Note that</p><formula xml:id="formula_58">x = (x 1 , . . . , x n ) satisfies n j=1 w j x j n j=1 w j -λ g ⇐⇒ x = 1 -x satisfies n j=1 w j x j λ g ,<label>(13)</label></formula><p>where λ g is defined in Algorithm 3 as the total weight of the votes g needs in order to proceed to the second round, and x is the binary vector of length n computed in the algorithm's subroutine. Thus when voters corresponding to weights returned by the function SUBSET-OF-WEIGHTS-APPROXIMATE() (see Algorithm 3) vote g . . . , they ensure that g proceeds to the second round. It is easy to see that whenever Algorithm 3 returns true, it actually finds a (valid) ballot making p win the election, and so if there is no such ballot, then the algorithm will return false.</p><p>We now move on to part 2. Let A W be an instance of the problem with weight list W . Suppose that there exists ballot X T of votes in T s.t. combined with preferences X S of voters of S, it makes p win the election in A W . We will denote by β Y (g) the plurality score of g from voter set Y under the preferences X S ∪ X T . Also, we denote N Y (g, g ) = v∈U X S ∪X T w v , where U X S ∪X T is the set of all the voters in Y that prefer g to g under X S ∪ X T . Let 0 u max(W ), W = W + {w n+1 , . . . , w n+l }, where l 0, l j=1 w n+ j u. We need to show that Algorithm 3 will return true on the input W , u. There is a candidate g = p that passes together with p to the second round when applying the preferences X T together with X S on A W , and thus for each candidate g / ∈ {p, g} and c ∈ {p, g}, if c g , then β S (c) + β T (c) β S (g ) + β T (g ), and if g c, then β S (c) + β T (c) &gt; β S (g ) + β T (g ). Also,</p><formula xml:id="formula_59">β T (p) + β T (g) n j=1 w j . (<label>14</label></formula><formula xml:id="formula_60">)</formula><p>Now consider Algorithm 3 applied to A W . If it does not reach g in the main loop, then it will exit earlier returning "true", meaning that it will find a desired ballot making p win. Otherwise, it will reach the candidate g. λ g is the minimal sum of weights that ensures that g will continue to the second round, and hence</p><formula xml:id="formula_61">λ g β T (g) n j=1 w j n+l j=1 w j . (<label>15</label></formula><formula xml:id="formula_62">)</formula><p>We will reach the function SUBSET-OF-WEIGHTS-APPROXIMATE(), and enter it with arguments W , λ g and u. By (13), the vector x = (x 1 , . . . , x n+l ) returned by SUBSET-OF-WEIGHTS-APPROXIMATE() satisfies n+l j=1 w j x j λ g , and so g will continue to the next round. Now we show that p will also continue to the next round. x j ∈ {0, 1}, for j = 1, . . . ,n + l. </p><formula xml:id="formula_63">Let J * = { j | x j = 1, x = (x 1 , . . . ,</formula><p>x j ∈ {0, 1}, for j = 1, . . . ,n + l.</p><p>Let J (k) = { j | x j = 1, x = (x 1 , . . . , x n+l ) is the optimal solution to H(k)}. Let P (k) = j∈ J (k) w j . Now, x = (x 1 , . . . , x n+l ) which we obtained in SUBSET-OF-WEIGHTS-APPROXIMATE() satisfies, for k u = u 2(n+l) + 1:</p><formula xml:id="formula_65">n+l j=1 w j x j = j∈ J (k u ) w j j∈ J (k u ) k u w j k u j∈ J * k u w j k u j∈ J * w j -(k u -1) = j∈ J * w j -(k u -1)| J * | = P * -(k u -1)| J * |.<label>(18)</label></formula><p>Hence, the vector x = 1x returned by the function, satisfies: In the context of CCUM in Veto, Algorithm 2 is, in a sense, an instantiation of the simple scheme described above. However, our direct proof of Theorem 4.6, given in Appendix C, is a simpler, but analogous, version of the proof of Theorem 3.4.</p><formula xml:id="formula_66">n+l j=1 w j x j n+l j=1 w j -P * + (k u -1)| J * | n+l j=1 w j -P * + u 2(n + l) (n + l) (<label>19</label></formula><p>Finally, note that Corollary 4.5 and Theorem 4.6 imply that CCUO in Plurality with Runoff and Veto is also in P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Relation to work on frequency of manipulation</head><p>At this point, we would like to give a more in-depth exposition of previous work regarding frequency of manipulation, and connect it with this paper.</p><p>An interesting approach to the abovementioned issue was presented by Conitzer and Sandholm <ref type="bibr" target="#b5">[6]</ref>. They noticed that an election instance can be manipulated efficiently if it satisfies two properties: weak monotonicity-a property which is satisfied by many prominent voting rules-and another, more arguable property: the manipulators must be able to make one of exactly two candidates win the election. Conitzer and Sandholm empirically showed that the second property holds with high probability in different standard voting rules. This empirical validation was carried out only with respect to small coalitions of voters and skewed distributions over election instances.</p><p>Procaccia and Rosenschein <ref type="bibr" target="#b22">[23]</ref> leveraged some of the intuitions provided by Conitzer and Sandholm. They analyzed the probability of the manipulators being able to affect the outcome of the election (i.e., make one of at least two candidates win), conditioned on the fraction of manipulators. They found that for quite general distributions over election instances, if n = o( √ N), the manipulators cannot affect the outcome with high probability; the opposite is true if n = ω( √ N). These results extended previous work on asymptotic strategy proofness <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b27">28]</ref>.</p><p>Another result was recently presented by Friedgut, Kalai and Nisan <ref type="bibr" target="#b12">[13]</ref>. They showed that a single manipulator can find a manipulation with relatively good probability by simply switching to randomly chosen linear preferences (in particular, high probability of success can be achieved by repeating this process a polynomial number of times). This is true provided the voting rule in question is "far from dictatorial" in some well-defined sense. The proof of this theorem is beautiful, but sadly the current proof only works for at most 3 candidates.</p><p>Most closely related to this paper is another work by Procaccia and Rosenschein <ref type="bibr" target="#b23">[24]</ref>, who have attempted to establish a framework which would enable showing that manipulations are typically easy. For this purpose, they have defined the notion of junta distributions, which are intuitively (and arguably) "hard to manipulate", over election instances in the coalitional manipulation setting. Moreover, they have defined a voting rule to be susceptible to manipulation if there is an algorithm that decides CCWM with high probability of success, when the instances are distributed according to a junta distribution. The rationale is that if there is an algorithm that does well with respect to these especially hard junta distributions, it would also do well with respect to other reasonable distributions.</p><p>Procaccia and Rosenschein's main result is that scoring rules are susceptible to manipulation, according to the foregoing definition. Technically, Procaccia and Rosenschein's result is in fact a very loose bound on the window of error of Algorithm 2. Although their analysis holds for any scoring rule, it suffers from two major shortcomings. First, it is much looser than the one given in this paper, and consequently does not allow for corollaries regarding unweighted coalitional manipulation. In contrast, our result regarding Borda is far stronger, since the window of error is much more accurately characterized. The stronger result allowed, e.g., for Corollary 4.2. A second major disadvantage of Procaccia and Rosenschein's analysis is that it only applies to a constant number of candidates, i.e., m = O (1). However, since the result in Procaccia and Rosenschein deals with scoring rules in general and here the only Scoring rules we deal with are Borda and Veto, neither result strictly subsumes the other.</p><p>Erdélyi et al. <ref type="bibr" target="#b10">[11]</ref> discuss the notion of junta distributions at length. They show that the idea of junta distributions, when applied to the SAT problem, is not sufficient to classify hard-to-decide distributions. Their work is inconclusive, however, when it comes to the application of junta distributions to hardness of manipulation problems.</p><p>Still, it seems that at this point we lack a link between a mathematical framework dealing with frequency of manipulation, and hardness on average. In light of this, we shall shortly consider the intuitive frequency of manipulation implications of our results, without being too formal. Our theorems imply that our algorithms err on only very specific configurations of the voters' weights. It might be productive to imagine points on the real line as representing the total weight of T . In the case of Borda, then, our algorithm would give a correct negative answer on all points to the left of some point x, and a correct positive answer on all points to the right of x + max W . The range between x and x + max W is the window of error. This is a simplification of the situation, but a useful one nonetheless. Now, intuitively consider some "reasonable" distribution over the instances of the CCUM problem (such that weights are randomly selected). The fact that the distribution is "reasonable" guarantees that the manipulators' total weight is distributed over a large range. Therefore, the probability of hitting the tiny window of error is extremely small. This (once again, intuitively) means that with high probability, our algorithms would correctly decide the manipulation problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Discussion</head><p>We would like to devote this final section to a short discussion regarding extensions of our results, and their applications to other voting rules.</p><p>We have noted above (and elaborate on, in Appendix A) that Copeland's rule is not monotone in weights. This seems to preclude the type of analysis which we have presented here. Nevertheless, it might be possible to obtain similar results if one endows the manipulators with the option to abstain from voting. In this way, any voting rule must be monotone in weights, as additional manipulators can always abstain. This is also not a major departure from our model, where the manipulators can coordinate their votes; it is only natural to assume that they can also agree not to vote at all.</p><p>The prominent Single Transferable Vote (STV) rule is one that we have not discussed above. In STV, the election proceeds in rounds; each voter casts his vote for the candidate he ranks first among the remaining candidates; the candidate with lowest score is eliminated. It is difficult to apply our approach to STV, for two reasons. First, it does not have a notion of score (but this is also true for Plurality with Runoff). Second, it is a very hard voting rule to manipulate. Indeed, it is well known that STV is hard to manipulate even for a single manipulator <ref type="bibr" target="#b1">[2]</ref>. However, in theory STV is amenable to our type of analysis; this remains a fascinating direction for future research.</p><p>Finally, we conjecture that our analysis of the performance of Algorithm 1 with respect to CCUM in Maximin is not tight: it might be possible to lower the bound from 2 to 3/2 by using a close variant of the algorithm.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Lemma 3 . 10 .</head><label>310</label><figDesc>Let W be a list of weights, |W | = n. Let G W = 0 s G s W , as before. Then for all s 1 and g</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 3 . 14 . 4 Candidate</head><label>3144</label><figDesc>In our example W = {1, 1, 1, 1}, w = 1, so we are actually talking about the special case of unweighted coalitions. Consider the set C = {p, 1, 2, 3, 4, 5, 6}, m = |C| = 7, N = |S| = 5. 3 voters in S voted 6 5 4 3 2 p 1, and the other 2 voters in S voted 2 3 4 5 6 p 1. When applying Algorithm 2 to this input, the voters in T will award the candidates with the following scores (we denote by α j (c) the points that voter j gives to candidate c):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The induced sub-graph G(g).</figDesc><graphic coords="11,188.27,54.04,171.99,84.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 .</head><label>3</label><figDesc>On input C , p, X S , W S , W , u, where |C| = m, |S| = N, |W | = n, u is an integer, s.t. 0 u max(W ), the running time of Algorithm 3 is polynomial in m, N, log(max(W S )), n and max(W ) u+1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Denote by H the maximization problem max</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>1 :</head><label>1</label><figDesc>procedure Greedy(C , p, X S , W ) X S is the set of preferences of voters in S, W is the list of weights for voters in T , |W | = |T | = n ∈ argmin c∈C \P j {Score of c from X S ∪ X ∪ {P j + {c}}}</figDesc><table><row><cell>2:</cell><cell>sort(W )</cell><cell>Sort the weights in descending order</cell></row><row><cell>3:</cell><cell>X ← ∅</cell><cell>Will contain the preferences of T</cell></row><row><cell>4:</cell><cell>for j = 1, . . . ,n do</cell><cell>Iterate over voters by descending weights</cell></row><row><cell>5:</cell><cell>P j ← (p)</cell><cell>Put p at the first place of the jth preference list</cell></row><row><cell>6:</cell><cell>for t = 2, . . . ,m do</cell><cell>Iterate over places of jth preference list</cell></row><row><cell>7:</cell><cell cols="2">Evaluate the score of each candidate if j would put it at the next available place</cell></row><row><cell cols="2">8: Pick c 9: P j = P j + {c}</cell><cell>Add c to j's preference list</cell></row><row><cell>10:</cell><cell>end for</cell><cell></cell></row><row><cell>11:</cell><cell>X ← X ∪ {P j }</cell><cell></cell></row><row><cell>12:</cell><cell>end for</cell><cell></cell></row><row><cell>13:</cell><cell>X T ← X</cell><cell></cell></row><row><cell>14:</cell><cell cols="2">if argmax c∈C {Score of c based on X S ∪ X T } = {p} then</cell></row><row><cell>15:</cell><cell>return true</cell><cell>p wins</cell></row><row><cell>16:</cell><cell>else</cell><cell></cell></row><row><cell>17:</cell><cell>return false</cell><cell></cell></row><row><cell>18:</cell><cell>end if</cell><cell></cell></row><row><cell cols="2">19: end procedure</cell><cell></cell></row><row><cell></cell><cell cols="2">Algorithm 1. Decides CCWM.</cell></row><row><cell cols="2">1: procedure Scoring-rules-Greedy(C , p, σ 0 (C), W )</cell><cell>σ 0 (C) is the list of scores of candidates</cell></row><row><cell></cell><cell cols="2">distributed by voters in S, W is the list of weights for voters in T , |W | = |T | = n</cell></row><row><cell>2:</cell><cell>for j = 1, . . . ,n do</cell><cell>Go over voters in T</cell></row><row><cell>3:</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>end procedure Algorithm 2. Decides CCWM in Scoring rules.</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>l+1</cell></row><row><cell>8:</cell><cell>end for</cell></row><row><cell>9:</cell><cell>end for</cell></row><row><cell cols="2">10: if argmax c∈C {σ n (c)} = {p} then</cell><cell>p wins</cell></row><row><cell>11:</cell><cell>return true</cell></row><row><cell>12:</cell><cell>else</cell></row><row><cell>13:</cell><cell>return false</cell></row><row><cell>14:</cell><cell>end if</cell></row><row><cell>15:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Lemma 3.11. Let W be a list of weights, |W | = n, w max = max(W ). Let H ⊆ C \ {p} s.t. σ j (H) is w max -dense for some 0 j n. Then there exists H , H ⊆ H ⊆ C \ {p} s.t. σ n (H ) is w max -dense. Proof. We have H ⊆ C \ {p} and 0 j n, s.t. σ j (H) is w max -dense. Denote H j := H . Define inductively for t = j, j + 1, . . . ,n -1: H t+1 = {g ∈ C \ {p} | min h∈H t {σ t (h)} σ t (g) max h∈H t {σ t (h)}}. Of course, for all t, H t ⊆ H t+1 . It is easy to see that if for some j t n -1, σ t (H t ) is w max -dense, then σ t+1 (H t+1 ) is also w max -dense. So, we get by induction that σ n (H n ) is w max -dense, and H ⊆ H n ⊆ C \ {p}. 2 Lemma 3.12. Let W be a list of weights, |W | = n, w max = max(W ). Let G W be as before. Then the set σ n</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Note that after 4 stages, the algorithm still did not find a manipulation: σ 4 (p) = 29 &lt; 30 = σ 4<ref type="bibr" target="#b5">(6)</ref>. However, if we change the votes of the third and fourth voters of T , then we find an appropriate ballot:</figDesc><table><row><cell>Candidate c ∈ C</cell><cell>p</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell></row><row><cell>σ 0 (c)</cell><cell>5</cell><cell>0</cell><cell>18</cell><cell>19</cell><cell>20</cell><cell>21</cell><cell>22</cell></row><row><cell>σ 1 (c)</cell><cell>1 1</cell><cell>5</cell><cell>2 2</cell><cell>2 2</cell><cell>2 2</cell><cell>2 2</cell><cell>2 2</cell></row><row><cell>σ 2 (c)</cell><cell>17</cell><cell>10</cell><cell>22</cell><cell>23</cell><cell>24</cell><cell>25</cell><cell>26</cell></row><row><cell>σ 3 (c) σ 4 (c)</cell><cell>23 29</cell><cell>15 20</cell><cell>25 28</cell><cell>27 28</cell><cell>24 28</cell><cell>26 28</cell><cell>28 28</cell></row><row><cell></cell><cell>1 1</cell><cell>5</cell><cell>2 2</cell><cell>2 2</cell><cell>2 2</cell><cell>2 2</cell><cell>2</cell></row><row><cell>σ 2 (c)</cell><cell>17</cell><cell>10</cell><cell>22</cell><cell>23</cell><cell>24</cell><cell>25</cell><cell></cell></row><row><cell>σ 3 (c)</cell><cell>23</cell><cell>15</cell><cell>26</cell><cell>26</cell><cell>26</cell><cell>26</cell><cell></cell></row><row><cell>σ 4 (c)</cell><cell>29</cell><cell>20</cell><cell>26</cell><cell>27</cell><cell>28</cell><cell>29</cell><cell></cell></row><row><cell>σ 5 (c)</cell><cell>35</cell><cell>25</cell><cell>30</cell><cell>30</cell><cell>30</cell><cell>30</cell><cell></cell></row><row><cell>Candidate c ∈ C</cell><cell>p</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell></row><row><cell>σ 0 (c)</cell><cell>5</cell><cell>0</cell><cell>18</cell><cell>19</cell><cell>20</cell><cell>21</cell><cell></cell></row><row><cell>α 1 (c)</cell><cell>6</cell><cell>5</cell><cell>4</cell><cell>3</cell><cell>2</cell><cell>1</cell><cell></cell></row><row><cell>α 2 (c)</cell><cell>6</cell><cell>5</cell><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell></cell></row><row><cell>α 3 (c) α 4 (c)</cell><cell>6 6</cell><cell>5 5</cell><cell>3 3</cell><cell>4 1</cell><cell>0 4</cell><cell>1 2</cell><cell></cell></row><row><cell>Now the cumulative scores are:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>procedure Plurality-with-runoff(C , p, X S , W S , W , u) X S is the set of preferences of voters in S, W S are the weights of voters in S, W = {w 1 , . . . , w n } are the weights of voters in T , u is the if there exists g ∈ argmax g ∈C\{p} β S (g ), g = g s.t. g g ← max g ∈C\{p} β S (g )β S (g) + 1 g ← max g ∈C\{p} β S (g )β S (g)</figDesc><table><row><cell></cell><cell>size of error window</cell><cell></cell></row><row><cell>2:</cell><cell>for g in C \ {p} do</cell><cell>Go over candidates in C \ {p}</cell></row><row><cell>3:</cell><cell></cell><cell>g then</cell></row><row><cell>4:</cell><cell></cell><cell></cell></row><row><cell>5:</cell><cell>else</cell><cell></cell></row><row><cell>6:</cell><cell></cell><cell></cell></row><row><cell>7:</cell><cell>end if</cell><cell></cell></row><row><cell>8:</cell><cell>if λ g &gt; n i=1 w i then</cell><cell>If we cannot make g pass to the next round</cell></row><row><cell>9:</cell><cell>continue</cell><cell>Go to the next candidate in the main loop</cell></row><row><cell>10:</cell><cell>end if</cell><cell></cell></row><row><cell>11:</cell><cell></cell><cell></cell></row></table><note><p><p>1:</p>λ λ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>15 :</head><label>15</label><figDesc>if ∃g ∈ C \ {p, g} s.t. (β S (g ) &gt; β S (p) + β T (p)) S∪T (p, g) &gt; N S∪T (g, p)) or (N S∪T (p, g) = N S∪T(g, p)  and p procedure subset-of-weights-approximate(W , λ g , u) W = {w 1 , . . . , w n } are the weights of voters in T , λ g is the minimum total sum of desired weights, u is the size of error window Decides CCWM in Plurality with Runoff with desired accuracy.</figDesc><table><row><cell>16:</cell><cell>or (β S (g ) = β S (p) + β T (p) and g</cell><cell cols="2">p) then</cell></row><row><cell>17:</cell><cell>continue</cell><cell></cell><cell>p does not pass to next round</cell></row><row><cell>18:</cell><cell>end if</cell><cell></cell></row><row><cell>19:</cell><cell cols="3">if (N g) then</cell></row><row><cell>20:</cell><cell>return true</cell><cell></cell><cell>p beats g in the second round</cell></row><row><cell>21:</cell><cell>else</cell><cell></cell></row><row><cell>22:</cell><cell>continue</cell><cell></cell></row><row><cell>23:</cell><cell>end if</cell><cell></cell></row><row><cell>24:</cell><cell>end for</cell><cell></cell></row><row><cell>25:</cell><cell>return false</cell><cell></cell><cell>No appropriate g was found</cell></row><row><cell cols="2">26: end procedure</cell><cell></cell></row><row><cell>27:</cell><cell></cell><cell></cell></row><row><cell>28: 29:</cell><cell>Check that 0 u max(W )</cell><cell></cell></row><row><cell cols="3">30: k u ← u 2n + 1 31: Solve by dynamic prog.: max{ 32: Let x ∈ {0, 1} n be the vector that maximizes the above sum n j=1 w j j=1 w j x j ku x j | n</cell><cell>n j=1 w j -λ g , ∀ j, x j ∈ {0, 1}}</cell></row><row><cell>33:</cell><cell>return 1 -x</cell><cell></cell><cell>1 is the vector of n 1's</cell></row><row><cell cols="2">34: end procedure</cell><cell></cell></row><row><cell></cell><cell>Algorithm 3.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>x n+l ) is the optimal solution to H}. Denote P * = j∈ J * w j . Let H(k) be the scaled version</figDesc><table><row><cell cols="4">of the above maximization problem:</cell></row><row><cell>max</cell><cell>n+l j=1</cell><cell>w j k</cell><cell>x j</cell></row><row><cell cols="2">n+l</cell><cell></cell><cell>n+l</cell></row><row><cell>s.t.</cell><cell cols="2">w j x j</cell><cell>w j -λ g</cell></row><row><cell cols="2">j=1</cell><cell></cell><cell>j=1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>) one candidate such that the score of p increases by 1 relative to that candidate without changing with respect to any other candidate. Thus, we simply have to count the number of manipulators needed to guarantee that p has more points than any other candidate. Formally, if we denote by σ 0 (c) the score of candidate c based on the votes in S, then clearly there exists a vote for T making p win if and only if c∈C \{p} max σ 0 (c)σ 0 (p) + 1, 0 |T |.</figDesc><table><row><cell></cell><cell>n+l j=1</cell><cell>w j -P  *  +</cell><cell>u 2</cell><cell>.</cell></row><row><cell cols="3">By definition of P  *  , we get:</cell><cell></cell></row><row><cell>n+l</cell><cell></cell><cell>n+l</cell><cell></cell><cell>n+l</cell></row><row><cell>j=1</cell><cell cols="4">w j -P  *  = min w j x min j=1 w j x j | j=1 n w j x j |</cell></row><row><cell></cell><cell></cell><cell>j=1</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(20)</cell></row></table><note><p>j λ g , x j ∈ {0, 1}, 1 j n + l n j=1 w j x j λ g , x j ∈ {0, 1}, 1 j n β T (g).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>Historical note: although we cite the JACM 2007 paper, this work originated in a AAAI 2002 paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>We assumed here that when two candidates have the same scores up until a certain stage, the current voter will award fewer points to the candidate with lower index, but any tie-breaking rule will give the same results.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>We slightly abuse notation here, as we defined the optimization problems for weight set W = {w 1 , . . . , w n+l }, but the definition for the set W is analogous.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>To simplify notation we overload W and identify it with the list of manipulators. It is straightforward that this set can be efficiently found. Indeed, for each weight in the list W , simply check if there is another copy, and if so, place one of them in W 1 and one in W 2 .</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors would like to thank Vincent Conitzer for excellent comments on a draft of this paper, and in particular for pointing out the alternative 2-approximation algorithm for Maximin given in Appendix B. The authors also thank the anonymous AIJ reviewers for insightful comments. This work was partially supported by Israel Science Foundation grant #898/05.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="bibr" target="#b0">1</ref> <p>The author thanks Noam Nisan for a generous grant which supported this work. <ref type="bibr" target="#b1">2</ref> The author was supported in this work by the Adams Fellowship Program of the Israel Academy of Sciences and Humanities.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Combining <ref type="bibr" target="#b18">(19)</ref> and <ref type="bibr" target="#b19">(20)</ref>, we get that for vector x returned by the function SUBSET-OF-WEIGHTS-APPROXIMATE():</p><p>β T (g) = n+l j=1 w j x j β T (g) + u 2 . <ref type="bibr" target="#b20">(21)</ref> In the algorithm, all the voters j s.t. x j = 0 will vote p . . . , and so we will have For any candidate c such that c / ∈ {p, g}, c was never ranked at the top of the preference lists by Algorithm 3, and so β S∪T (c) = β S (c) β S∪T (c). On the other hand, by <ref type="bibr" target="#b21">(22)</ref>,</p><p>Recall that p beats c in the first round under X T . It follows that p beats c in the first round under Algorithm 3, and so p will continue to the next round.</p><p>We now prove that p beats g in the next round. If g p, then in the winning ballot X T , N S (p, g) + N T (p, g) &gt; N S (g, p) + N T (g, p), otherwise N S (p, g) + N T (p, g) N S (g, p) + N T <ref type="bibr">(g, p)</ref>. From <ref type="bibr" target="#b20">(21)</ref> we get:</p><p>Thus, from (23):</p><p>So, for g p we get</p><p>In the same way, for p g we get</p><p>Therefore, p wins the second round of the election, and hence the entire election; the algorithm will return true.</p><p>Next, we prove part 3. Using the notation of the previous part, let P (k) be the maximum sum of weights from W = {w 1 , . . . , w n }, solving the scaled maximization problem H(k). 5 There is a well-known dynamic programming algorithm solving the knapsack problem H(k) in time O (nP (k)) (see, e.g. <ref type="bibr" target="#b18">[19,</ref><ref type="bibr">Chapter 9]</ref>). Furthermore, P (k)</p><p>2n , and so we have:</p><p>Thus we can solve</p><p>). It is easy to see that all the other steps of Algorithm 3 are polynomial in its inputs; hence, the proof is completed. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Unweighted coalitional manipulation</head><p>In this section, we discuss the application of the results given above to unweighted coalitional manipulation (the CCUM problem), and present a new theorem. We will see that some of our theorems can be translated into approximation (in the classical sense) results in this natural setting.</p><p>It is known that the CCUM problem is tractable-with respect to any voting rule that can be computed in polynomial time-when the number of candidates is constant <ref type="bibr" target="#b6">[7]</ref>. However, to the best of our knowledge (at the time of submission) there are no results regarding the complexity of the problem when the number of candidates is not constant, except for the cases of STV and Second Order Copeland where CCUM is hard even when there is only a single manipulator <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. We conjecture that CCUM in Borda and Maximin is N P-complete.</p><p>In the context of unweighted manipulation, one can consider the following optimization problem: Definition 4.1. In the Constructive Coalitional Unweighted Optimization (CCUO) problem, we are given the (unweighted) votes of the truthful voters. We must find the minimum number of manipulators needed in order to make p win (i.e., the minimum number of manipulators that can cast their (unweighted) votes in a way that makes p win).</p><p>Then, our theorems almost directly imply the following corollary:</p><p>1. Algorithm 2 approximates CCUO in Borda up to an additive error of 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Algorithm 1 is a 2-approximation algorithm for CCUO in Maximin.</head><p>Proof. It is enough to show that the minimum number of manipulators needed in order to make p win, in Borda and Maximin, must be polynomial in the rest of the input. Indeed, in this case we can apply brute-force search using Algorithms 2 and 1, respectively, in order to approximate the answer. In other words, we run the algorithm once for every number of manipulators k ∈ {0, . . . , p(n)} for some polynomial p. The minimum k which gives a true answer in Borda (resp., Maximin) is guaranteed to be larger by at most 1 (resp., twice as large) than the optimal answer by Theorem 3.4 (resp., Theorem 3.16).</p><p>So, it is sufficient to prove the following two lemmata. Proof. We show that there exists a ballot making p win for n * = (N + 1)(m -1). Let the manipulator 1 j (N + 1)(m -1) vote p • • • c i+1 , where j -1 ≡ i mod(m -1), 0 i m -2, and the rest of the order is arbitrary. With every m -1 voters the difference between the scores of any candidate c j and p decreases by at least α 1α m . Moreover, for any 1 j m -1, σ 0 (c j ) σ 0 (p) + N(α 1α m ), and so we get: Proof. We show that there exists a ballot making p win for n * = N + 1. Let every manipulator vote p . . . . Then for every candidate c j we get: σ N+1 (c j ) N N+1 (c j , p) N. Moreover, for any candidate c j = p, N N+1 (p, c j ) N + 1, and so σ N+1 (p) N + 1. Hence we get for every candidate c j , σ N+1 (c j ) &lt; σ N+1 (p), implying that p will win. 2</p><p>This concludes the proof of the corollary. 2</p><p>On the other hand, we have the following results: Proof. Follows as a special case of Theorem 3.20, where the error window is u = 0, the number of additional voters is l = 0, and all the weights equal 1. 2</p><p>Theorem 4.6. Algorithm 2 efficiently solves the CCUM problem in Veto.</p><p>A short discussion is in order regarding CCUM in Veto. Indeed, this problem can be solved efficiently by a trivial algorithm. The fact that each manipulator can veto a single candidate may be interpreted as follows: each manipulator picks</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Copeland is not monotone in weights</head><p>When discussing Scoring rules, Maximin, and Plurality with Runoff, we are motivated to look for approximate solutions to the CCWM problem by the fact that these voting rules are monotone in weights. In contrast, Copeland is not monotone in weights. The next example illustrates this fact. Consider the following setting: C = {p, 1, 2, 3}, N = |S| = From the above table we calculate that σ 0 (p) = 1, σ 0 (1) = σ 0 (2) = 0, σ 0 (3) = -1, so p wins the election in this setting.</p><p>However, if we add another voter (with weight 1), then no matter what his vote would be, p would not win the election: if the additional voter puts 1 above 2, then 1 will win, and otherwise 2 will win.</p><p>Remark A.1. It is easy to see, however, that whenever there is a manipulation for the coalition with weights W , then there is also a manipulation for coalition with weights W + {w} + {w}, where w 1 is an integer: the first additional voter makes an arbitrary vote, and the second additional voter reverses the first's ranking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Alternative algorithm for CCWM in maximin</head><p>Consider the following simple algorithm, which we refer to as Algorithm 4. Given the list of weights W , let W = {w 1 , . . . , w k } be the maximal (with respect to set inclusion) list of weighted votes such that W contains two copies of W , i.e.,</p><p>The remaining manipulators all rank p first, and the other candidates arbitrarily. The algorithm returns true iff this ballot makes p win.</p><p>We will now easily show that Theorem 3.16 also applies to Algorithm 4.</p><p>Theorem B.1. In the Maximin rule, let C be the set of candidates with p ∈ C the preferred candidate, and S the set of voters who already cast their votes. Let W be the weight list for the set T . Then:</p><p>1. If there is no ballot making p win the election, then Algorithm 4 will return false.</p><p>2. If there is a ballot making p win the election, then for the same instance with weight list W s.t. W ⊇ W + W (i.e., W contains two copies of W ), Algorithm 4 will return true.</p><p>Proof. Item 1, as always, is obvious since the algorithm is constructive. For item 2, let σ * (c) be candidate c's Maximin score based on the votes in S and the manipulator weights W which make p win. Let σ (c) be c's Maximin score based on the votes in S and the votes in W + W , according to the algorithm (notice that W ⊆ W 1 , W ⊆ W 2 ). Finally, let σ (c) be c's score according to the algorithm, on the weight list W . As before, denote W = {w 1 , . . . , w k }.  </p><p>We denote by α j (x) the number of points x was awarded in stage j.</p><p>By definition, σ n (x * ) σ n (y). We would like to show that σ n (y) σ n (x * ) + 1. Suppose for contradiction that σ n (y)σ n (x * ) 2. Let 1 j n maximal s.t. α j (x * ) = 0. Then:</p><p>Therefore σ j-1 (y)σ j-1 (x * ) 1, and so σ j-1 (y) &gt; σ j-1 (x * ), a contradiction to α j (x * ) = 0. We showed that for all y ∈ Y n , σ n (x * ) σ n (y) σ n (x * ) + 1, and hence for all</p><p>y∈Y n σ n (y). Let Z T be a preference list of voters in T , and σ n (g) be the scores of g ∈ C which are implied by Z T (including votes in S). Then q (n) := 1</p><p>Proof. The above fact is true since in the algorithm, at every stage j, there is some x ∈ X n ⊆ Y n such that α j (x) = 0, and so for every j, the sum y∈Y n α j (y) = |Y n | -1 is minimal. Formally, let us denote by α j (g) the number of points candidate g gets from voter j in Z T . Then:  Proof. By Eq. ( <ref type="formula">29</ref>), for all g ∈ C \ {p}, σ n (g) max(σ n (Y n )), and so if σ n (p) &gt; max(σ n (Y n )), then for all g ∈ C \ {p}, σ n (p) &gt; σ n (g), and so the algorithm will find the manipulation. 2</p><p>Lemma C.4. If σ n (p) max(σ n (Y n )) then there exists no manipulation.</p><p>Proof. Let Z T be a set of preferences of voters in T , and let σ n (g), q (n) and α j (g) be as in Lemma C.2. As for all j, α j (p) = 1 α j (p), it follows that σ n (p) σ n (p). There is at least one g 0 ∈ Y n s.t. σ n (g 0 ) q (n) . By Lemma C.2, q (n) q(n) . By Lemma C.1, q(n) = max(σ n (Y n )). Combining the foregoing steps, we obtain:</p><p>We conclude that p does not win under Z T , and hence there is no ballot of votes in T that makes p win the election. 2</p><p>The proof of Theorem 4.6 is completed.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The asymptotic strategyproofness of scoring and Condorcet consistent rules</title>
		<author>
			<persName><forename type="first">E</forename><surname>Baharad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Neeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Review of Economic Design</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="331" to="340" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Single transferable vote resists strategic voting</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bartholdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Orlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Choice and Welfare</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="341" to="354" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The computational difficulty of manipulating an election</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bartholdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Tovey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Trick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Choice and Welfare</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="227" to="241" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multipart pricing of public goods</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Public Choice</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="17" to="33" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Universal voting protocol tweaks to make manipulation hard</title>
		<author>
			<persName><forename type="first">V</forename><surname>Conitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence (IJCAI&apos;03)</title>
		<meeting>the Eighteenth International Joint Conference on Artificial Intelligence (IJCAI&apos;03)<address><addrLine>Acapulco, Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="781" to="788" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Nonexistence of voting rules that are usually hard to manipulate</title>
		<author>
			<persName><forename type="first">V</forename><surname>Conitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First National Conference on Artificial Intelligence (AAAI&apos;06)</title>
		<meeting>the Twenty-First National Conference on Artificial Intelligence (AAAI&apos;06)<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="627" to="634" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">When are elections with few candidates hard to manipulate?</title>
		<author>
			<persName><forename type="first">V</forename><surname>Conitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hybrid voting protocols and hardness of manipulation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Elkind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><surname>Isaac</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="206" to="215" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Small coalitions cannot manipulate voting</title>
		<author>
			<persName><forename type="first">E</forename><surname>Elkind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><surname>Fc</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A heuristic technique for multiagent planning</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ephrati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rosenschein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="13" to="67" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On approximating optimal weighted lobbying, and frequency of correctness versus average-case polynomial time</title>
		<author>
			<persName><forename type="first">G</forename><surname>Erdélyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Hemaspaandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rothe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Spakowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamentals of Computation Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4639</biblScope>
			<biblScope unit="page" from="300" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The complexity of bribery in elections</title>
		<author>
			<persName><forename type="first">P</forename><surname>Faliszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hemaspaandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Hemaspaandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First National Conference on Artificial Intelligence (AAAI 2006)</title>
		<meeting>the Twenty-First National Conference on Artificial Intelligence (AAAI 2006)<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Elections can be manipulated often</title>
		<author>
			<persName><forename type="first">E</forename><surname>Friedgut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Forty-Ninth Conference on Foundations of Computer Science (FOCS&apos;08)</title>
		<meeting>the Forty-Ninth Conference on Foundations of Computer Science (FOCS&apos;08)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Voting for movies: The anatomy of a recommender system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mundhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Annual Conference on Autonomous Agents</title>
		<meeting>the Third Annual Conference on Autonomous Agents<address><addrLine>Seattle</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="434" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Manipulation of voting schemes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gibbard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="587" to="602" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Incentives in teams</title>
		<author>
			<persName><forename type="first">T</forename><surname>Groves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="617" to="631" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An automated meeting scheduling system that utilizes user preferences</title>
		<author>
			<persName><forename type="first">T</forename><surname>Haynes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nadella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Annual Conference on Autonomous Agents</title>
		<meeting>the First Annual Conference on Autonomous Agents<address><addrLine>Marina del Rey, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="308" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Anyone but him: The complexity of precluding an alternative</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hemaspaandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Hemaspaandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rothe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="255" to="285" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Approximation Algorithms for NP-Hard Problems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Hochbaum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>PWS Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On strategy-proofness and single peakedness</title>
		<author>
			<persName><forename type="first">H</forename><surname>Moulin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Public Choice</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="437" to="455" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Morphological disambiguation by voting constraints</title>
		<author>
			<persName><forename type="first">K</forename><surname>Oflazer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tür</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Conference of the European Chapter</title>
		<meeting>the 8th Conference of the European Chapter</meeting>
		<imprint>
			<publisher>the Association for Computational Linguistics</publisher>
			<date type="published" when="1997">1997. 1997</date>
			<biblScope unit="page" from="222" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Social choice theory and recommender systems: Analysis of the axiomatic foundations of collaborative filtering</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pennock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Horvitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Giles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th National Conference on Artificial Intelligence (AAAI 2000</title>
		<meeting>the 17th National Conference on Artificial Intelligence (AAAI 2000</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="729" to="734" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Average-case tractability of manipulation in elections via the fraction of manipulators</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Procaccia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rosenschein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Sixth International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS 2007)</title>
		<meeting><address><addrLine>Honolulu, Hawaii</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
			<biblScope unit="page" from="718" to="720" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Junta distributions and the average-case complexity of manipulating elections</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Procaccia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rosenschein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="157" to="181" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Multi-winner elections: Complexity of manipulation, control and winner-determination</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Procaccia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Rosenschein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zohar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Twentieth International Joint Conference on Artificial Intelligence (IJCAI 2007)</title>
		<meeting><address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-01">January 2007</date>
			<biblScope unit="page" from="1476" to="1481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Strategy-proofness and Arrow&apos;s conditions: Existence and correspondence theorems for voting procedures and social welfare functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Satterthwaite</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Economic Theory</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="187" to="217" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Combining information extractions systems using voting and stacked generalization</title>
		<author>
			<persName><forename type="first">G</forename><surname>Sigletos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Paliouras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Spyropoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hatzopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1751" to="1782" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">How large should a coalition be to manipulate an election?</title>
		<author>
			<persName><forename type="first">A</forename><surname>Slinko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Social Sciences</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="293" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Counter speculation, auctions, and competitive sealed tenders</title>
		<author>
			<persName><forename type="first">W</forename><surname>Vickrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Finance</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="8" to="37" />
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
