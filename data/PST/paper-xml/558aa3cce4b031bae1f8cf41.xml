<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Timed Communicating Object Z</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Brendan</forename><surname>Mahony</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jin</forename><forename type="middle">Song</forename><surname>Dong</surname></persName>
						</author>
						<title level="a" type="main">Timed Communicating Object Z</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">74736A34D057958C5C1EC2D46916B876</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a timed, multithreaded object modeling notation for specifying real-time, concurrent, and reactive systems. The notation Timed Communicating Object Z (TCOZ) builds on Object-Z's strengths in modeling complex data and algorithms, and on Timed CSP's strengths in modeling process control and real-time interactions. TCOZ is novel in that it includes timing primitives, properly separates process control and data/algorithm issues and supports the modeling of true multi-threaded concurrency. TCOZ is particularly well suited for specifying complex systems whose components have their own thread of control. The expressiveness of the notation is demonstrated by a case study in specifying a multi-lift system that operates in real-time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many formal specification and design notations have tended to concentrate either on data modeling and algorithmic concerns (eg. Z, VDM, etc.) or else on process control concerns (eg. CSP, CCS, Stat-eCharts, etc.). Complex systems often have intricate system states and process control structures involving concurrency and real-time interactions. To formalise such systems, it is necessary to have a notation which is able to capture both the data/algorithmic issues and the process behaviour issues in a smoothly integrated, but also highly structured and modular, manner. In consequence, the blending of state-modeling and process languages has become an active area of research <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b25">25]</ref>.</p><p>Object-Z <ref type="bibr" target="#b20">[20]</ref> is an object oriented extension of the Z formal specification language. Z is a model-oriented specification language with powerful features for describing complex data structures and their operations. Object-Z improves the clarity of large Z specifications through enhanced structuring. However, the process semantics of Object-Z mean that: process execution is single threaded; operations are atomic, there is no notion of the duration of operations; and process control logic is tightly coupled with class structure. Therefore, it is difficult to use Object-Z to model concurrent real-time reactive systems.</p><p>Timed CSP <ref type="bibr" target="#b48">[48]</ref> is an extension of Hoare' s Communicating Sequential Processes (CSP) notation. It builds on CSP' s strengths in modeling process control issues, such as concurrency and synchronisation, by adding primitives for modeling real-time issues. However, CSP has only the most rudimentary mechanisms for modeling data and algorithmic issues and it is cumbersome to capture the state of a complex system. This paper describes an integration of Object-Z and Timed CSP, called Timed Communicating Object Z (TCOZ), and presents a case study on using TCOZ to specify a real-time multi-lift system. TCOZ builds on the respective strengths of the Object-Z and Timed CSP notations in order to provide a single notation for modeling both the state and process aspects of complex systems. The notion of blending Object-Z with CSP has been suggested independently by Fischer <ref type="bibr" target="#b22">[22]</ref> and Smith <ref type="bibr" target="#b51">[51]</ref>. The most obvious novelty of TCOZ is that it is built on Timed CSP and includes primitives for treating timing issues, however in addressing the issue of time it has been necessary to make several inovations which impact positively even on the treatment of `untimed systems' . TCOZ adopts a finer grain of atomicity than either Fischer or Smith. Operations are considered to represent a sequence of (unspecified) update events, rather than to constitute atomic events in themselves. This opens the possibility of treating operation composition and refinement in TCOZ, including the introduction of multithreaded concurrency at the operation level. TCOZ adopts an explicit mechanism for enabling operations (and indeed arbitrary processes) which is distinct from the operation definition itself. This increases the potential for reuse of operation specifications and allows the notions of operation and process refinement to be reconciled. TCOZ adopts the CSP channelbased communications paradigm in its full generality and enhances it by the introduction of a novel network topology operator that allows the communications interfaces of complex TCOZ processes to be visualised through simple network-topology graphs. This improves decoupling of class definitions by simplifying the interfaces between objects. For the most part, these topics can be touched on only briefly in this paper and they will be the subjects of future more detailed correspondences.</p><p>The TCOZ notation has been briefly described and exercised in introductory papers by these authors <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b13">14]</ref>. This paper combines elements of these papers, but describes the notation and its use in greater detail. Important issues such as formal syntax and semantics are explained for the first time.</p><p>The remainder of the paper is organised as follows. In Section 2, Object-Z and Timed CSP notations are briefly introduced. The advantages and disadvantages of the two notations in modeling timing, concurrency, complex data and algorithmic aspects are demonstrated using a common example, a timed collection. In Sec-tion 3, the blended notation, TCOZ, is introduced and the timed collection example used to show how it uses the strengths of the individual notations to address their respective weaknesses. In Section 4, the case study on specifying a real-time multi-lift system is presented. In Section 5, a discussion of related work is presented. Finally, a syntax for TCOZ is presented as Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Object-Z and Timed CSP</head><p>The common example of a generic timed collection is used through out this section and the next section to to illustrate the differences between and to demonstrate the advantages and disadvantages of the Object-Z, Timed CSP, and TCOZ notations respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Generic timed-collection example</head><p>The generic timed-collection denotes a collection of elements of type X with a time stamp. Operations are allowed to add elements to and delete elements from the collection. When deleting an element from the collection, the oldest element should be removed and output to the environment. The collection has the following timing properties. Firstly, that it takes a small but non-zero time (t a and t d respectively <ref type="foot" target="#foot_0">1</ref> ) to update the internal state during a add or delete operation. Secondly, each element of the collection becomes stale if it is not passed on within t o time units of being added to the collection. Stale elements should never be passed on, but are instead purged from the collection upon becoming stale. The purge operation has a duration of t p .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">A model of time</head><p>In this paper, all timing information is represented as real valued measurements in seconds, the SI standard unit of time <ref type="bibr" target="#b31">[31]</ref>.</p><p>Describing time and other physical quantities in terms of standard units of measurement is an important aspect of ensuring the completeness and soundness of specifications of real-time, reactive, and hybrid systems. In order to support the use of standard units of measurement, extensions to the Z typing system suggested by Hayes and Mahony <ref type="bibr" target="#b28">[28]</ref> are adopted. Under this convention, time quantities are represented by the type T== Rs;</p><p>which represents real-valued time measured in seconds. Time literals consist of a real number literal annotated with a symbol representing a unit of time. For example, 3 s is a literal representing a period of three microseconds. All the arithmetic operators are extended in the obvious way to allow calculations involving units of measurement.</p><p>The timing constants associated with the timed-collection example are introduced via axiomatic definitions.</p><p>t a ; t d ; t p ; t o : T</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Object-Z</head><p>The main Object-Z construct is the class definition. A class is a template for objects of that class: for each object of a class, the object' s states are instances of the class' state schema and the object' s state transitions are instances of the class' operation schemas. An object is said to be an instance of a class and to evolve according to the definitions of its class.</p><p>Since Object-Z has no standard conventions for handling timing and process control issues, it is necessary to model these issues explicitly in the class state. One such approach is Timed Object-Z <ref type="bibr" target="#b10">[11]</ref>, which incorporates ideas from various Zbased approaches for specifying real-time requirements <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b42">43]</ref>. The Timed Object-Z approach consists of two conventions. Firstly, environmental factors are modeled as functions of time and are included in the system state. In the timed-collection example, the environment is modeled by functions left and right. These functions represent the participation of the environment in Add and Delete operations respectively. The second extension is to include a global real-time clock, conventionally represented by a distinguished state attribute now. The clock may only be updated during an operation and the next operation must start as soon as the previous one is finished. In order to model the time taken between operations it is thus necessary to introduce a Wait operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Timed-collection in Object-Z</head><p>The use of Timed Object-Z is illustrated by the TimedCollection class in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>The generic function ps (purge stale) is defined in Figure <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X]</head><p>ps : (T F(T X)) ! F(T  In the TimedCollection class, the secondary attributes are now, denoting the current time; and t i , denoting the idle time since the completion of the last operation; the tuple (t;oldest) denoting the oldest element being in the collection, when it is non-empty; and the time variable idle, de-noting the time until the next operation.</p><formula xml:id="formula_0">0 ? now = idle t 0 i = t i + idle</formula><p>The INIT schema describes the allowed initial values for the class attributes, in this case mems. The initial schema implicitly includes the state schema, so that the initial state includes all the class attributes and satisfies the class invariant. The timedcollection initially contains no elements.</p><p>The remaining four schemas are operation schemas which describe the allowed state transitions for the class. The declaration parts of operation schemas may include a -list of those (primary) attributes whose values may change. By convention, any primary attribute not appearing in thelist may not change value. The values of the secondary attributes are always subject to change. Every operation schema implicitly includes the state schema in unprimed form (the state before the operation) and primed form (the state after the operation).</p><p>The timing behaviour of the TimedCollection requires careful explanation. The Add operation may occur only when there is an item available on left. It updates timeouts in the existing collection and purges any stale items (this is described in the ps funtion definition), and adds the new item with the maximum timeout of t o . This activity must take exactly t a and the idle time is set to 0 s.</p><p>The Delete operation is enabled only when the right environment is willing to accept the oldest item, it communicates the item and then deletes it from the collection. The Purge operation is envoked when no communication is possible before the first item goes stale (t i 2 dom mems).</p><p>Each of these operations also implicitly updates the idle attribute according to the requirement in the data invariant. The idle attribute always records the amount of idling required before the next action is enabled and the Wait operation simply consumes this idle time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Transition system interpretation</head><p>Object-Z has a three-stage semantics. The various operations in a class are given a standard Z semantics, then this is used to develop a transition-system semantics, which then determines an event-based process semantics <ref type="bibr" target="#b50">[50]</ref>. The Z operation semantics is best viewed as describing a relation between initial and final states for each operation. The operations of a given class thus form a named collection of relations, which determines a transition system in which a given operation may fire exactly when its Z precondition is satisfied. The Z precondition of an operation schema describes the initial states for which there exists some final state satisfying the schema predicate. The process model for the class consists of all the se-quences of operations/events which can be performed by objects of the class. <ref type="foot" target="#foot_1">2</ref>For example, the TimedCollection object starts with mems empty then evolves by successively performing either Add, Delete, Purge, or Wait operations. This is sometimes expressed semi-formally by an equation such as</p><formula xml:id="formula_1">TCbeh b = (Add 2 Delete 2 Purge 2 Wait); TCbeh:</formula><p>Here TCbeh represents the behaviour of the TimedCollection, ( 2 ) is Object-Z choice between operations,<ref type="foot" target="#foot_2">3</ref> and ( ; ) is Object-Z sequential composition. The choice of which operations are enabled at each point is determined by which preconditions are satisfied by the current state. As an example of a precondition calculation consider the Purge operation. The Z precondition is defined to be 9 mems 0 : F(T X); now 0 ; t 0 i ; idle 0 : T; (t;oldest) : T X Purge:</p><p>By expanding the predicate part of the Purge schema and simplifying, it can be shown that this is equivalent to now ? t i 2 dom mems Thus the Purge operation may only occur when the oldest member of the timedcollection has expired. This entwining of behavioural control matters with algorithmic matters creates unnecessary complexity in the design process and fails to promote a clear separation of concerns. For example, in order to ensure that operations occur in some desired order the designer must painstakingly craft the preconditions of all the operations in a class so as to ensure the desired interactions and may even need to add unnecessary process state in order to represent control state. Since there is no way to progress time except through the action of an operation, it is necessary to introduce pseudooperations such as Wait whose sole purpose is to make sure that there is something to do at each point in time and deep reasoning is required to demonstrate that time does indeed always progress. Perhaps most inconvenient, is the fact that this use of preconditions to control the sequencing of transitions is incompatible with aspects of Z algorithmic refinement.</p><p>In particular, refinement by weakening an operation' s precondition is disallowed in Object-Z. Weakening an operation' s precondition would result in it being enabled more often, thus playing havoc with the process control structure of the original specification. For example, if the precondition for the Purge operation was weakened it would be possible for it to occur either before or after the expiry timestamp of data element, a result completely at odds with the purpose of the timestamp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Summary</head><p>The TimedCollection class describes the data state (mems) and operations of the timed collection well. However, Timed Object-Z requires interactions with the environment and the progress of time to be micro-managed in an intrusive manner. The proliferation of additional attributes required to deal with process control and time result in significant over specification of the system. All too frequently deep reasoning is required to comprehend the subtle and complex interplays between operations and environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Timed CSP</head><p>Timed CSP <ref type="bibr" target="#b48">[48]</ref> extends the well-known CSP (Communicating Sequential Processes) notation of Hoare <ref type="bibr" target="#b30">[30]</ref> with timing primitives. CSP is an event based notation primarily aimed at describing the sequencing of behaviour within a process and the synchronisation of behaviour (or communication) between processes. Timed CSP extends CSP by introducing a capability to quantify temporal aspects of sequencing and synchronisation.</p><p>CSP adopts a symmetric view of process and environment. Events represent a cooperative synchronisation between process and environment. Both process and environment may control the behaviour of the other by enabling or refusing certain events or sequences of events. Although CSP semantics are symmetric with respect to process and environment, we find it helpful in the following to use the words request and block as synonyms for enable and refuse respectively when referring to the environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Process primitives</head><p>A process which may participate in event a then act according to process description P is written a@t ! P(t):</p><p>The event a is initially enabled by the process and occurs as soon as it is requested by its environment, all other events are refused initially. The event a is sometimes referred to as the guard of the process. The (optional) timing parameter t records the time, relative to the start of the process, <ref type="foot" target="#foot_3">4</ref>at which the event a occurs and allows the subsequent behaviour P to depend on its value.</p><p>The second form of sequencing is process sequencing. A distinguished event X is used to represent and detect process termination. The sequential composition of P and Q, written P; Q, acts as P until P terminates by communicating X and then proceeds to act as Q. The termination signal is hidden from the process environment and therefore occurs as soon as enabled by P. The process which may only terminate is written SKIP.</p><p>The parallel composition of processes P and Q, synchronised on event set X, is written P j X ]jQ: No event from X may occur in P j X ]jQ unless enabled jointly by both P and Q. When events from X do occur, they occur in both P and Q simultaneously and are referred to as synchronisations. Events not from X may occur in either P or Q separately but not jointly. For example, in the process described by</p><formula xml:id="formula_2">(a ! P) j a ]j(c ! a ! Q)</formula><p>all a events must be synchronisations between the two processes. Since a is not enabled initially by the right hand process, a cannot occur in the left hand process until the right hand process has performed a c event and the a event becomes enabled in both processes.</p><p>In an asynchronous parallel combination P jjj Q both components P and Q execute concurrently without any synchronisations. Diversity of behaviour is introduced through two choice operators. The external choice operator allows a process a choice of behaviour according to what events are requested by its environment. The process</p><formula xml:id="formula_3">(a ! P) 2 (b ! Q)</formula><p>begins with both a and b enabled. The environment chooses which event actually occurs by requested one or the other first. Subsequent behaviour is determined by the event which actually occurred, P after a and Q after b respectively. When the range of choices is large (possibly infinite), external choice may be written in an intentional form, 2 a : A P(a); which allows the environment to choose any event a from a set A and subsequent behaviour is determined by P(a).</p><p>Internal choice represents variation in behaviour determined by the internal state of the process. The process a ! P u b ! Q may initially enable either a, or b, or both, as it wishes, but must act subsequently according to which event actually occurred. The environment cannot affect internal choice. Again an intentional form is allowed.</p><p>An important derived concept in CSP is the notion of channel. A channel is a collection of events of the form c:n: the prefix c is called the channel name and the collection of suffixes is called the values of the channel. When an event c:n occurs it is said that the value n is communicated on channel c. When the value of a communication on a channel is determined by the environment (external choice) it is called an input and when it is determined by the internal state of the process (internal choice) it is called an output. It is convenient to write c?n : N ! P(n) to describe behaviour over a range of allowed inputs instead of the longer 2 n : N c:n ! P(n). Similarly the notation c!n : N ! P(n) is used instead of u n : N c:n ! P(n) to represent a range of outputs. Expressions of the form c?n and c!n do not represent events, the actual event is c:n in both cases.</p><p>The interrupt process P 1 O e ! P 2 behaves as P 1 until the first occurrence of interrupt event e, then the control passes to P 2 .</p><p>Recursion is used to given finite representations of non-terminating processes. The process expression P a?n : N ! b!f (n) ! P describes a process which repeatedly inputs a natural on channel a, calculates some function f of the input, and then outputs the result on channel b. CSP specifications are typically written as a sequence of simultaneous equations in a finite collection of process variables. Such a specification X == F( X) is implicitly taken to describe the solution to the vector recursion X F( X).</p><p>In general, the behaviour of a process at any point in time may be dependent on its internal state and this may conceivably take an infinite range of values. It is often not possible to provide a finite representation of a process without introducing some notation for representing this internal process state. The approach adopted by CSP is to allow a process definition to be parameterised by state variables. Thus a definition of the form</p><formula xml:id="formula_4">P n:N b = Q(n)</formula><p>represents a (possibly infinite) family of definitions, one for each possible value of n. There is no inherent notion of process state in CSP, but rather these annotations are a convenient way to provide a finite representation of an infinite family of process descriptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Timing primitives</head><p>To the standard CSP process primitives, Timed CSP adds two time specific primitives, the delay and the timeout.</p><p>A process which allows no communications for period t then terminates is written WAIT t. The process WAIT t; P is used to represent P delayed by time t.</p><p>The timeout construct passes control to an exception handler if no event has occurred in the primary process by some deadline. The process (a ! P) .ftg Q will try to perform a ! P, but will pass control to Q if the a event has not occurred by time t, as measured from the invocation of the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3">The timed collection example</head><p>The timed collection can be modeled as a process with two channels, left and right respectively. Elements are added to the collection through communications on the left channel and removed through communications on the right channel. The timing issues of the timed-collection can be described using (Timed CSP' s) delay and timeout constructs. When the first element joins the collection it is stamped with a timeout and the time taken to update the process state is represented by a delay. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.4">Summary</head><p>For such an example Timed CSP is superior to Object-Z as a means of describing process control. Timed CSP also handles the timing issues of delays and timeouts simply and elegantly. The allowed sequences of events are clearly and concisely determined by the CSP code, there is no need to calculate preconditions nor is any other form of deep reasoning required to understand the ways in which the timedcollection may evolve. The Timed Object-Z approach results in a too complex model which over specifies this simple system, even though the timed collection example does not make use of the multi-threading and synchronisation capabilities of Timed CSP which are clearly well beyond the scope of Object-Z' s atomic state transition semantics. On the other hand, the syntactic treatment of internal state in the above is complex and unwielding, distracting strongly from the basically elegant treatment of the delay and timeout issues. Although, for example, Roscoe' s CSP M language <ref type="bibr" target="#b46">[46]</ref> includes some pow- erful data modeling primitives, CSP still has no standard support for state modeling in the form of mathematical toolkits and libraries nor are there modular techniques for constructing and reasoning about complex internal state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TCOZ</head><p>In many ways, Object-Z and Timed CSP complement each other in their capabilities. Object-Z has strong data and algorithm modeling capabilities. The Z mathematical toolkit is extended with object oriented structuring techniques. Timed CSP has strong process control modeling capabilities. The multi-threading and synchronisation primitives of CSP are extended with timing primitives. Moreover, both formalisms are already strongly influenced by the other in their areas of weakness.</p><p>Object-Z supports a number of primitives which have been inspired by CSP notions such as external choice and synchronisation. CSP practitioners tend to make use of notation inspired by the Z mathematical toolkit in the specification of processes with internal state. This is not surprising given their joint associations in the Programming Research Group, Oxford. Another important connection is the wellknown duality between the state transition behavioural model and the event based behavioural model <ref type="bibr" target="#b29">[29]</ref> which makes it a simple matter to develop complementary semantics for the two languages.</p><p>Given these factors it is natural to consider the possibility of blending the two notations into a more complete approach to modeling real-time and/or concurrent systems. Fischer <ref type="bibr" target="#b22">[22]</ref> and Smith <ref type="bibr" target="#b51">[51]</ref> have independently suggested CSP-style semantics for Object-Z classes in which operation calls become CSP events. Operation names take on the role of CSP channels, with input and output parameters being passed down the operation channel as values. This view fits nicely with the Object-Z interpretation of operations being atomic, but is not well suited to considering multi-threading and real-time. Restricting operations to atomic events collapses the spatial and temporal aspects of operations, everything happens at a single point and instantaneously. Identifying channel names with operation names creates unnecessary tensions between the data and process views of objects and considerably reduces the potential for reuse of operation definitions. Another approach is that taken by Galloway in his CCZ language <ref type="bibr" target="#b24">[24]</ref>, based on Z and (value-passing) CCS. There Z operation schemas do not appear as events, but instead appear as prefixes to parameterised CCS output processes. The effect of the operation schema is to restrict the allowed output values in the associated process and to update the values of the process state parameters. Whilst this approach effectively disentangles the communication interface from the operational structure, the need to associate every occurance of an operation with a following output process is a major syntactic inconvenience.</p><p>The approach taken in the TCOZ notation is to identify operation schemas (both syntactically and semantically) with (terminating) CSP processes that perform only state update events; to identify (active) classes with non-terminating CSP processes; and to allow arbitrary (channelbased) communications interfaces between objects.</p><p>The syntactic implications of this approach is that the basic structure of a TCOZ document is the same as for Object-Z. A document consists of a sequence of definitions, including type and constant definitions in the usual Z style. TCOZ varies from Object-Z in the structure of class definitions, which may include CSP channel and processes definitions. In fact, all operation definitions in TCOZ are considered to define CSP processes. The CSP view of an operation schema is that it describes all the sequences of update events which change the system state as required by the schema predicate. The exact nature and granularity of these up-date events is left undetermined in TCOZ (at least at the syntactic level), but by allowing an operation to consist of a number of events, it becomes feasible to specify its temporal properties when describing the operation. Since operation schemas take on the syntactic role of CSP processes, they may be combined with other schemas and even CSP processes using the standard CSP process operators. Thus it becomes possible to represent true multithreaded computation even at the operation level, something that would not be possible with CCZ approach. The Fischer/Smith approach of identifying operation names with CSP channels is not followed, channels are given an independent, first class role. This allows the communications and control topology of a network of objects to be designed orthogonally to their class structure. The CSP channel mechanism is the only (dynamic) way to pass information between objects as the state of objects is encapsulated by hiding all update events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Defining operations</head><p>The operation schema is the basic tool for describing state change in TCOZ. In order to allow treatment of timing issues in schema definitions, a distinguished identifier is introduced to represent the duration of the state calculations performed by the operation. When does not appear in the definition of an operation, the default interpretation is that there be no constraint on the duration of the operation, although individual specification documents may choose to adopt a different convention.</p><p>Although the schema is the basic tool, the true power of TCOZ comes from the ability to make use of Timed CSP primitives is describing the process aspects of an operation' s behaviour. All operation definitions in TCOZ are in fact Timed CSP process definitions, with operation schema being given the syntactic status of terminating Timed CSP processes.</p><p>As an example, consider the specification of the Add operation (see Figure <ref type="figure">4</ref>) of the timed-collection example. left?e@t i ! Add 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4. add operation</head><p>Since TCOZ operations are identified with terminating CSP processes, it is natural to allow their definition in terms CSP primitives, such as event sequencing, as well as through the schema calculus. The novelty of the full TCOZ version of Add lies in the adoption of CSP primitives in its definition. Item inputs are communicated to the Add operation along a channel left. This definition of Add says that after the parameter e has been input on channel left at time t i , the state-calculation Add 0 is performed. Several aspects of TCOZ name-space conventions are raised by this definition.</p><p>Firstly, observe that the parameters e and t i occur in Add 0 with Z-style input decorations and in Add without them. In TCOZ the convention is adopted that the true name of all parameters is the undecorated version. In an operation schema, the ? and ! decorations are used solely to distinguish between inputs and outputs for the purposes of defining the binding semantics of the operation. This is analogous to the convention of using primed and unprimed versions to indicate the final and initial values of a state attribute. In fact, all parameters are treated in the same way as state attributes, with the exception that state attributes are available in every name environment in a class definition. The reason for this convention may be clearly seen in the following example.</p><p>y! : N j y! = f (x)]; c:y ! (x); y? : N j x 0 = g(y?)]</p><p>Clearly it does not make sense to decorate the y in c:y with either the ! or the ?, any more than it would make sense to use a 0 decoration on an attribute variable appearing in a communication.</p><p>This leads to the second observation that may be made of the Add definition. The e : X; t i : T] construct is a local block definition in the state guard style (state guards are explained further below). The other forms of local blocks are the intentionial forms of both internal and external choice, which use the usual Z-style schema-text conventions. For example,</p><formula xml:id="formula_5">u n : N j n &lt; 5 c!n ! P or 2 n : N j n &lt; 5 c?n ! P</formula><p>The state guard serves as an alternate form of external choice, so that the Add process is equivalent to 2 e : X; t i : T left?e@t i ! Add 0</p><p>In TCOZ, the internal and external choice operators must be used explicitly. Decorated communications of the form c!n and c?n have no conventional meaning in TCOZ, simply being syntactic sugar for c:n. They are allowed simply as a form of comment to emphasise the intended direction of communication.</p><p>In TCOZ, the local name space may be changed either by a local block definition as above or else by the occurance of an operation schema. An operation schema removes all its input parameters from scope and replaces them with its output parameters. The output parameters then become available for use in subsequent communication events or as inputs to subsequent operation schemas.</p><p>In the case of the Delete operation (see Figure <ref type="figure">5</ref>), the communication of the deleting element must precede the updating of the collection state and in fact is the enabling event for the operation. Since the name convention is that outputs are only available to the right of a schema, this behaviour cannot be described using an output parameter. Instead, the update operation is described as a simple state update which removes the oldest item (and any others that become stale). The overall delete operation consists of this schema guarded by a communication on the right channel.</p><p>Delete 0 (mems)</p><formula xml:id="formula_6">t i ? : T mems 6 = ? ^ = t d mems 0 = ps(t i + t d ; mems n f(t; oldest)g) Delete b = t i : Tj mems 6 = ?] right!oldest@t i ! Delete 0 Figure 5.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>delete operation</head><p>The first part of the definition of Delete is a novel process control primitive known as a state guard. <ref type="foot" target="#foot_4">5</ref> The adoption of a state guard mechanism allows TCOZ to adopt a proper seperation between algorithm and process design issues. The sequencing of activities in an object is controlled explicitly through state guards rather than implicitly through the operation preconditions. In this way it becomes possible to reclaim the Z-style operation design and decomposition techniques abandoned by standard Object-Z.</p><p>Every process definition has (at least) an initial state which may be addressed using schema notation. This is the function of the first part of the expression defining Delete. It is a schema-based method of re-stricting the action of the process to initial states for which the collection is nonempty. For other states this process will deadlock or block, which is to say refuse any communication.</p><p>Note that the precondition requirement in the Delete 0 schema, though identical, could not achieve the desired restriction on the behaviour of Delete. Failure to satisfy a precondition when control is passed to an operation instead results in divergence, which is to say unspecified subsequent behaviour. Delete 0 places no restrictions at all on its behaviour when the initial queue is empty. The precondition is the state-based equivalent of process divergence and the guard is the state-based equivalent to process deadlock.</p><p>For every operation P (even those constructed using the process calculus) the collection of initial states for which the process will not diverge is called its precondition (written pre P) and the collection of states for which it will not deadlock is called its guard (written grd P).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Schemas and Processes</head><p>A schema expression describes a relationship on or between process state/s, whilst a process expression describes the overall behaviour or evolution of a process. The Z semantic model for operation schemas consists of sets of variable bindings, mappings from variable names to values. An important point is that these sets may be infinite when the operation allows unbounded nondeterminism. Timed CSP has a number of semantic models, but the most common consists of sets of tuples consisting of a timed trace (a sequence of time stamped events) and a refusal (a record of when events are refused by the process). The trace/refusal pair is called a failure and the model the timed failures model. The basic approach taken in the TCOZ semantics is to adopt the timed failures semantic model and to provide an interpretation of the Z semantic model in terms of failures and divergences, though some variations are required to make this possible. Firstly, a variable binding is added to represent the initial values of all the process attributes. Secondly, a new class of events, referred to as update events, is introduced to represent changes to the process attributes. The resulting model is called the state/failures/divergences model. The state of the process at any given time is the initial state updated by all of the updates that have occurred up to that time.</p><p>If an event trace terminates (that is if a X event occurs), then the state at the time of termination is called the final state. Finally, since the unbounded nondeterminism potentially present in Z schemas cannot be treated properly using finite-traces, an infinite-trace variation of the timedfailures model, due to Mislove et al <ref type="bibr" target="#b43">[44]</ref>, is adopted.</p><p>The process model of an operation schema consists of all initial states and update traces (terminated with a X) such that the initial state and the final state satisfy the relation described by the schema. If no legal final state exists for a given initial state, the operation diverges immediately. In the timed-failures model, divergence is represented by allowing arbitrary behaviour from the time of divergence.</p><p>The process model for the state guard consists of replacing the trace part of every behaviour of the guarded process whose initial state does not satisfy the state guard with the empty trace. The empty event trace describes the process being blocked by the failure of the state guard. In addition, divergence cannot occur if the state guard is not satisfied.</p><p>Since schema calculus operators cannot sensibly be applied to arbitrary CSP processes, it is necessary to strictly distinguish the schema calculus from the process calculus (see Appendix ??). The two exceptions to this are the type-casting of operation schema expressions as terminating processes and of initial state schema expressions as state guards. In all other circumstance the schema and process calculi are separate and distinct. For example, if P and Q are operations schema expressions, the expression a ! (P ^Q) is legal whilst the expression (a ! P) ^Q is not. The full power of the schema calculus may be used to construct schema expres-sions, but once a schema expression has been cast into a process-like role it may no longer act in a schema-like role. Some existing Object-Z schema calculus operators, such as 2 , k , and ; , have name-sakes with similar semantics in the CSP process calculus. The convention adopted in TCOZ is that the CSP operator is intended, only `pure logic' schema calculus operators are allowed in TCOZ. This is justified by the superior algebraic properties of the CSP operators.</p><p>When operations are combined using the concurrency primitives k and jjj , the designer is exposed to all the usual dangers of shared variable concurrency.</p><p>The operation OS 1 k OS 2 , where OS 1 and OS 2 are operation schema, will synchronise on all state update events on variables in the respective delta-lists. Thus OS 1 k OS 2 will have much the same pro- cess properties as OS 1 ^OS 2 , with the exception that when the operations are inconsistent for a given initial state, the concurrent composition will deadlock while the logical composition with diverge. For example, consider</p><formula xml:id="formula_7">SQRT == x; x 0 : N j x &gt; 0 ^x02 = x] HALF == x; x 0 : N j x 0 2 = x]:</formula><p>The operations SQRT and HALF can agree only in the case where x = 4. When either of the operations is undefined (for example when x = 2; SQRT is undefined) SQRT k HALF will diverge. When both are defined but in disagreement (for example when x = 16) SQRT k HALF will deadlock at some unspecified time. The process SQRT ^HALF is just x; x 0 : N j x = 4 ^x0 = 2] and will never deadlock.</p><p>The concurrent composition OS 1 jjj OS 2 is even less well behaved, every variable may be updated in any way allowed by either OS 1 or OS 2 . Such a situation is likely to be very difficult to analyse. We strongly recommend that concurrent composition of operations be used sparingly, preferably only in cases where the operations have disjoint delta-lists. Shared data structures should only be utilised when properly protected by the object encapsulation mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Active and passive objects</head><p>The definition in a class of the distinguished process name MAIN indicates that the class is being defined as active. As in CCZ <ref type="bibr" target="#b24">[24]</ref>, the MAIN process is used to determine the behaviour of objects of an active class after initialisation. Initialisation is treated in the usual way through the INIT schema. Active objects have their own thread of control and their mutable state attributes and operation definitions are fully encapsulated (update events are hidden). Distinct objects, even of the same class, share no data and can experience no shared variable interference. Other objects can neither reference an active object' s state attributes nor invoke any of its local operations. Only local constants, such as the object identity attribute self , may be accessed by other classes. All dynamic interactions with an active object must take place through the CSP channel communication mechanism. Active objects are considered to have the syntactic properties of process identifiers and may be composed using CSP operators.</p><p>The MAIN operation is optional in a class definition. If a class is defined without a MAIN process it is called a passive class. Passive objects are controlled by other objects in a system and their state and operations are fully available to the controlling object (unless explicitly hidden). The appearance of MAIN clearly distinguishes the definition of active objects and passive objects in a system.</p><p>Returning to the timed-collection example, the existence of environmental obligations and the need to purge stale elements means that the timed-collection class must have its own thread of control. Assuming that the class operations are defined as in Section 3.1, the timed-collection behaviour is defined by a MAIN process similar to the Timed CSP version presented in Section 2. The most striking difference lies in the use of the operation schemas to subsume the role of the complex annotations present in the Timed CSP version. This represents a clearer and more structured presentation of the basic control logic. A second difference lies in the use of the state guard construct to distinguish between the empty and non-empty behaviours of the timedcollection, thus saving the need to define separate empty and non-empty processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Communication channels</head><p>The class state-schema convention is extended to allow the declaration of communication channels. If c is to be used as a communication channel by any of the operations of a class, then it must be declared in the state schema to be of type chan. Channels are type heterogeneous and may carry communications of any type.</p><p>We have decided on this convention in TCOZ, primarily because we see no compelling reason to associate types with channels and can see some minor advantages in not doing so. Certainly the timedfailures semantics does not require that channels be typed. Channel communication events are simply pairs consisting of the channel name and the value communicated. Neither does the Z bindings semantics require the value be typed, the Z semantics are modelled in untyped set theory. The main argument in favour of extending the typing conventions to channels is that it provides redundancy which will guard against silly errors such as trying to read an input of one type when the output was of another type. Balanced against this, we believe that the ability to send many forms of data over a channel plays a vital role in lowering the complexity of class interfaces and this lower complexity also reduces the likelihood of errors such as listening for an input on the wrong channel. Furthermore we believe it is more instructive to group logically related communications (such as those pertaining to a particular protocol) than to group communications with identical type but logically unrelated function. Thus, we currently adopt the untyped convention with the intention of evaluating our position again as our ex-perience using the notation increases. An interesting analysis of the general benefits of typed and untyped syntax has been made by Lamport and Paulson <ref type="bibr" target="#b36">[37]</ref>.</p><p>Contrary to the conventions adopted for internal state variables, channels are viewed as global rather then as encapsulated entities. This is an essential consequence of their role as communications interfaces between objects. In the situation of multiple instances of objects of the same class in a system, those objects will all share the same channel. For example, if O is a sequence of objects of class C with channel c, then in the process</p><formula xml:id="formula_8">jjj i : dom O O(i)</formula><p>each of the objects O(i) communicates with the environment by sharing channel c with every other object. In the general case there is no way for the environment to know which of the objects it is communicating with when using channel c. If it is necessary to know which object the environment is communicating with, the object identity attribute self <ref type="bibr" target="#b18">[18]</ref> can be included in the communication, for example c:(self ; message):</p><p>(This technique is used frequently in the lift case study.) The introduction of channels to TCOZ reduces the need to reference other classes in class definitions, thereby further enhancing the modularity of system specifications.</p><p>Consider once again the timed-collection example. Using the TCOZ conventions, the class state can be significantly simplified from the Timed Object-Z version (see Figure <ref type="figure" target="#fig_3">6</ref>). The sole remaining primary class attribute is the actual collection itself, none of the timing attributes are required. In addition to the list of mems, the state schema must declare channels left and right. These channels serve much the same role as the corresponding environment variables in the Timed Object-Z version, but here that role is better defined in terms of the CSP process model. The secondary attributes oldest and t remain useful in simplifying the operation definitions and are retained.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">The timed-collection</head><p>Bringing together the various aspects of the TCOZ timed-collection introduced above, we are able to present the entire class definition in Figure <ref type="figure">7</ref>.</p><p>This specification represents a more con-cise, flexible, and scalable treatment of both process and state than is possible in either Object-Z or Timed CSP. The structure of the process' internal state and communications interfaces are prominently documented. The structured schema based approach to describing state transitions, supported as it is by the full power of the Z toolkit and the schema calculus, is better able to handle large and complex process state than the essentially ad hoc state annotation conventions of CSP. Making use of the Timed CSP process definition conventions removes the need to consider process control matters in operation schemas.</p><p>There is a clear separation of process control and algorithmic matters which simplifies the description of both.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Composing classes</head><p>Inheritance is a mechanism for incremental specification, whereby new classes may be derived from one or more existing classes.</p><p>Essentially, all definitions are pooled with the following provisions. Inherited type and constant definitions and those declared in the derived class are merged. The state and initialisation schemas of inherited classes and those declared in the derived class are conjoined. Operation schemas with the same name are also conjoined.</p><p>TCOZ </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">A multi-threaded example</head><p>The timed-collection example made no use of the multi-threaded capabilities of the TCOZ notation. In this section, a specification of a standard buffered consumer/producer process is presented (see Figure <ref type="figure" target="#fig_4">9</ref>) as a demonstration these aspects of TCOZ.</p><p>A simple consumer/producer process accepts inputs of type L on its left channel, calculates some function of the inputs, and outputs the result on its right channel. To ensure that all inputs are accepted and outputs are received, the process is buffered left and right with timedcollection processes (see Figure <ref type="figure" target="#fig_0">10</ref>). The buffered process consists of a left buffer, a right buffer, and an internal consumer/producer, as graphically depicted in Figure <ref type="figure">8</ref>.</p><p>Correct hookup of the timed-collection buffers to the consumer/producer is achieved by renaming the various internal channels. The renaming convention is the In order to retain a consumer/producer like interface, the right channel of the left buffer is renamed to ml, the left channel of the right buffer renamed to mr and the left and right channels of the internal consumer/producer are renamed to ml and mr respectively.</p><p>The internal interfaces are protected from environmental interference by hiding them. The hiding notation is the same as for both Object-Z and Timed CSP, that is (P n c) is P with c protected from external influence. In the case where P is processlike and c is a channel this has the important result of freeing communications on c from the requirement of synchronising with the environment. Thus communications on mr and ml occur as soon as the local processes are ready and cannot be blocked by any other entity.</p><p>The BufConProd class definition allows true multithreading of the two buffers and the consumer/producer. For example, the left buffer may be accepting a new item at the same time as the consumer/producer is processing another item, at the same time as the right buffer is releasing yet another item to the environment. This concurrency is coerced into smooth co-operation through the requirement for synchronisation between the processes when communication occurs on the internal channels ml and mr.</p><p>The addition of these CSP process structuring features represents a significant advance in the scope and size of systems which may be addressed by the Object-Z approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Complex network topologies</head><p>The syntactic structure of the CSP synchronisation operator is convenient only in the case of pipe-line like communication topologies. Expressing more complex communication topologies generally results in unacceptably complicated expressions. For example, consider the communication topology shown in Figure <ref type="figure" target="#fig_6">11</ref>, processes A and B communicate privately through the channel ab, processes A and C communicate privately through the channel ac, and processes B and C communicate privately through the channel bc. One CSP expression for such a network communication system is (A bc 0 =bc] j ab; ac ]j (B ac 0 =ac] j bc ]jC ab 0 =ab]) nab; ac; bc) ab; ac; bc=ab 0 ; ac 0 ; bc 0 ]:</p><p>The hiding and renaming is necessary in order to cover cases such as C being able to communicate on channel ab.</p><p>The above expression not only suffers from syntactic clutter, but also serves to obscure the inherently simple network One reason for this is that it artificially suggests a dominant role for process A. Equivalent, but superficially very different, formulations of the network could be used to assign this "dominant" role to either B or C. We believe that network topologies can be better described by adopting a notation inspired by the graphbased approach embodying in Figure <ref type="figure" target="#fig_6">11</ref>.</p><p>A network topology abstraction is an expression of the form (Figure <ref type="figure" target="#fig_0">12</ref>).</p><p>´</p><formula xml:id="formula_9">v ½ v ¾ v ¿ v½ ch½¾ ¹ v ¾ v ¾ ch¾¿ ¹ v ¿ v ¿ ch½¿ ¹ v ½ µ</formula><p>The variables v ½ v ¾ v ¿ are called the formal network parameters and the network connections</p><formula xml:id="formula_10">v ½ ch½¾ ¹ v ¾ v ¾ ch¾¿ ¹ v ¿ v ¿ ch½¿ ¹ v ½</formula><p>are called the formal network topology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 12. network topology abstraction</head><p>The formal network parameters are abstract names that represent the process that form the nodes of the network topology. It is necessary to use abstract names to allow separate incarnations of processes with identical definition. The formal network topology describes a finite graph in which each edge or network connection generally represents a private channel connection between network nodes. Multiple connections between processes and connections between multiple processes over a single channel are represented by multiple connection expressions. In this case the channel becomes a party line between the various participating processes.</p><p>A network topology abstraction describes a function, which we call a network constructor, that builds a process network using its process arguments as nodes. The network constructor associated with a given network abstraction is built by processing the formal parameters sequentially. At each stage there is a list of remaining formal parameters. Suppose v is the next remaining formal parameter. The local channels on which v is not synchronising are decorated to avoid unwanted synchronisations. The local channels on which it is synchronising with any of the remaining parameters are used to create a synchronisation with the remaining network. Then the rest of the formal parameters are treated one at a time to construct an expression for that remaining network. Finally all the local channels are hidden and any decorations removed.</p><p>The above network topology abstraction thus describes the following network constructor (Figure <ref type="figure" target="#fig_0">13</ref>).</p><p>The system in Figure <ref type="figure" target="#fig_6">11</ref> can be described by applying a suitable network topology abstraction to the processes A, B, and C.</p><formula xml:id="formula_11">( k v 1 ; v 2 ; v 3 v 1 ab -v 2 ; v 2 bc -v 3 ; v 3 ac -v 1 ) (A;B; C)</formula><p>The processes A; B; C are the actual network parameters. When the actual network parameters are all process names, the syntactic conventions are relaxed to allow</p><formula xml:id="formula_12">v ½ v ¾ v ¿ v½ ch ¼ ¾¿ ch ¾¿ ℄ ch ½¾ ch ½¿ ℄ ´v¾ ch ¼ ½¿ ch ½¿ ℄ ch ¾¿ ℄ ´v¿ ch ¼ ½¾ ch ½¾ ℄ ℄ . . . µ µ Òch ½¾ ch ½¿ ch ¾¿ µ ch ½¾ ch ¼ ½¾ ch ½¿ ch ¼ ½¿ ℄</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 13. network topology abstraction</head><p>the formal network topology to act in the guise of a process operator. For example, the network topology of Figure <ref type="figure" target="#fig_6">11</ref> may be described by the lax usage</p><formula xml:id="formula_13">k (A ab -B; B bc -C; C ca -A):</formula><p>Such usage is considered acceptable since the names representing the actual parameter can serve the dual purpose of also identifying the formal parameters. Other forms of lax usage allow network connections with common nodes to be run together, for example</p><formula xml:id="formula_14">k (A ab -B bc -C ca -A);</formula><p>and multiple channels above the arrow, for example k (A ab1;ab2 -B):</p><p>We believe this TCOZ network topology convention to be novel and potentially useful addition to the basic CSP notation. For example, the directed parallel operator in the CSP M language, whilst adopting sim- ilar syntax, addresses the different problem of synchronising on differently named channels without burdensome use of renaming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The lift case study</head><p>The multi-lift system is a standard example used to demonstrate the expressive power of various specification techniques in modeling concurrent reactive systems. <ref type="foot" target="#foot_5">6</ref>People are familiar with the user requirement of a lift system, so they can concentrate on the modeling notations. However, the lift case study is not a trivial example because of the complexity caused by inherent concurrent interaction in the system <ref type="bibr" target="#b54">[54]</ref>. We chose the specification of the lift system as the TCOZ case study also because both CSP and Object-Z have been applied to the lift system allowing a comparison to be drawn. The CSP `lift' model <ref type="bibr" target="#b49">[49]</ref> describes the sequences of events for the lift system well, however, it struggles to capture the data aspects of the lift system. Furthermore, the CSP model has a flat and in places awkward structure and the communications interfaces between the lift system components (i.e. floor-buttons and lifts) are not clearly documented. The Object-Z `lift' model <ref type="bibr" target="#b16">[16]</ref> demonstrates the power of modeling the state change of the lift system in a structured way. However, it is complicated by the need to represent process state as data and it uses a complex, centralised control-model because of the Object-Z' s single thread semantics. Neither the CSP or Object-Z model addresses the real-time issues for the lift system.</p><p>Our goals for the TCOZ specification of the lift system include: a model that captures both the data structures and the behaviour of the lift system; a true multi-threaded specification that captures the concurrent, reactive, and real-time aspects of the lift system; and a component based incremental style specification that is extendible and reusable.</p><p>This case study aims to demonstrate the TCOZ approach for modeling timed reactive systems. Other detailed (lift specific) issues, such as the efficiency of lift scheduling, are not considered in this paper. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">System overview</head><p>A lift system for a building consists of multiple lifts each providing transport between the various floors of the building as dictated by the pressing of a range of service-request buttons. Inside each lift there is a panel of buttons, one for requesting travel to each of the building' s floors.</p><p>The panel buttons of any lift must be in one-to-one correspondence with the floor numbers. In general there are two servicerequest buttons on each floor, for upward and downward travel respectively, though on the first floor and the top floor there is only one button. Any service-request button can be pushed at any time. Once pushed the button is said to be on and it remains on until the requested service is provided. Pressing an internal button requests the lift to visit the corresponding floor. Pressing an external button requests a lift to visit the floor with the desired direction of travel. The lift controller has a queue which stores all current (external) floor requests. When a request arrives from a floor, the system will put the request at the end of the external request queue. When a lift becomes available, the controller will assign the first request of the queue to the lift for service. When visiting a floor, a lift door operates in the order of open-door, wait, then close-door. This normal process can be interrupted by a customer crossing the door as detected by some sensors.</p><p>Furthermore, the following timing proper-ties must be captured in the model: lift travel time between two consequent floors is a constant, however there is a constant time delay for acceleration and braking;</p><p>without interrupts, the lift door should be kept at the `open' state for a fixed time period before closing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Specification structure</head><p>The lift specification is developed in a bottom-up manner, beginning with models of basic (passive) component objects, such as `buttons' , which are then used to develop more complex (active) component objects such as `floors (requests)' , `lifts' and a `controller' . Then the lift system is modeled as an active composite object which composes the component objects with their interactions (through channels).</p><p>Figure <ref type="figure" target="#fig_7">14</ref> illustrates the communication interfaces between lift system components. There are three major components, the service-request panels on each floor, the lifts themselves, and the central controller which mediates service requests from the floors. External requests received by a floor on the request channel cause the floor' s corresponding service button to be lit and the request is communicated to the controller on the enter channel. The button remains lit until a confirmation is received on the service channel. Requests received by the controller on the enter channel are enqueued and sent to idle lifts on the select channel on a first-in-first-out basis. Whenever a lift receives an internal request on the int request channel, the corresponding button is lit and the requested entered into its itinerary. Whilst the lift has local requests pending it services them in strict order according to its current movement direction, reversing direction at the extreme floors. The behaviour of the active lifts is monitored on the check channel and if a request can be serviced en route it is dispatched to the lift in question and dequeued. Once the lift becomes idle, it may accept an external request on the select channel, move to the requested floor, and send a confirmation to the floor panel on the service channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Buttons</head><p>A basic component of the lift system is the button panels on the floors or inside the lifts. Buttons have a common behaviour; they can be pushed `On' by people and turned `Off' by the system.</p><p>ButtonStatus ::= On j Off Buttons are modeled using a simple passive class (Figure <ref type="figure" target="#fig_0">15</ref>) which records their current state and provides operations for turning them on and off. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">The building</head><p>Our model of the building concentrates on the behaviour of the service-request panels on each floor, as depicted in Figure <ref type="figure" target="#fig_3">16</ref>, other floor related issues are elided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Floor panels</head><p>Floors may be divided into two classes, those from which it is possible to travel upward and those from which is possible to travel downward.</p><p>MoveDir ::= Up j Down</p><p>The TopFloor (Figure <ref type="figure" target="#fig_8">17</ref>) is a floor from which only downward travel is possible, A MiddleFloor is a floor from which both upward and downward travel is possible. Object-Z' s class inheritance features are used to allow both upward and downward travel for the MiddleFloor class (Figure <ref type="figure" target="#fig_4">19</ref>).</p><p>Inheritance provides a subclassing mechanism for specification reuse (not a true As a floor can be either top-floor or bottom-floor or middle-floor, the general type of a floor is defined as a classunion <ref type="bibr" target="#b9">[10]</ref>.</p><p>Floor b = TopFloor BottomFloor MiddleFloor</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">The building</head><p>The building is modeled as an aggregate of active floor objects (Figure <ref type="figure">20</ref>). Individual floors do not communicate with each other, but rather with the central controller and with the lifts. Thus the MAIN processes of the individual floor objects are combined using asynchronous composition, jjj . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Lifts</head><p>A lift consists of four parts as depicted in Figure <ref type="figure" target="#fig_0">21</ref>, a door for allowing access to and from the lift, a shaft for transporting the lift, an internal queue for determining the lift itinerary, and a controller for coordinating the behaviour of the other components. This division structures the specification in such a way as to limit the complexity of the individual components and to highlight the potential for concurrency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">Lift door control</head><p>The lift door controller is treated as a separate class so as to ensure a clear description of its timing and safety properties. Under this limited aim, the class may be described entirely within the Timed CSP idiom.</p><p>The controller interfaces on a channel servo with a servomechanism that activates the door to open or close and on a channel sensor to determine when the door is open, closed, or blocked from closing.</p><p>The messages that may be set on these channels are then DoorMess ::= ToOpen j Opened j</p><p>ToClose j Closed j Interrupt:</p><p>The  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Moving the lift</head><p>The essentially analog nature of the movement of the lift presents something of a modeling problem. The technique used throughout this specification has been to abstract real-world interactions as CSP events (eg the request and int request) channels, but the movement betweens floors is by its nature a time-consuming process. We thus adopt the common technique of delimiting the period of movement by start and finish events. The start event of the movement process is a communication to the lift-shaft apparatus of the number of floors to be moved. The finish event is a communication from the lift-shaft apparatus that the lift has arrived at the destination floor. The timing properties of lift movement are described by two time constants: maximum time to move one floor Up or Down t : T acceleration and braking delay delay : T</p><p>The maximum time to pass from one floor to another is t for each floor travelled plus a delay of delay caused by initial acceleration and final braking of the lift. The shaft model is captured in Figure <ref type="figure">23</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Shaft move arrive chan</head><formula xml:id="formula_15">MAIN S ¯ n ¼℄ ¯move n ¼ AE n £ t • delay℄ arrive S</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 23. shaft model</head><p>Such event based models are highly abstract and perhaps are less satisfying when applied to the complex process of moving the lift, than when applied to the more event-like process of pressing a button. However, the channel based interfaces of TCOZ processes mean that such models must be used. In their favour it must be pointed out that from the point of view of the lift controller the matters of essential interest are precisely when the movement commences and when it finishes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.3">Lift itinerary</head><p>The itinerary of the lift is determined by the requests made by passengers using the  </p><formula xml:id="formula_16">Internal Q height AE panel seq Button C int request</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.4">Lift controller</head><p>The lift controller keeps record of the current floor and movement direction and provides the interface between the lift environment and the other lift components. The lift controller exhibits of three modes of behaviour. It is modeled in Figure <ref type="figure" target="#fig_12">25</ref>.</p><p>The lift begins at rest awaiting either a passenger destination request or a dispatch from the central controller. Any passengers inside the lift are given a period of time</p><formula xml:id="formula_17">t p : T [wait for passenger input]</formula><p>to make an internal request before the lift accepts any external requests.</p><p>The controller determines that an internal request is pending through the willingness of the internal queue to perform a scheduling transaction. Once the queue has indi-cated the next destination the central controller is checked to see if there is an external request from an intermediate floor.</p><p>If so the liftservices the external request first. If not it services the internal request: the new direction is calculated and set; the lift is moved to the new floor and the door is opened; the internal queue and the central controller are notified; and then once the door is closed control is returned to the rest mode.</p><p>If, after waiting t p , an external request becomes available before any internal request: the new move direction is set; the lift is moved to the new floor and the door is opened; the floor service-request panel is notified; and then, once the door is closed, control is returned to the rest mode.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Controller</head><formula xml:id="formula_18">½ f ¾ AE ūps´f ½ f ¾ µ f AE f req Up f ½ f f ¾ dns´f ½ f ¾ µ f AE f req Down f ½ f f ¾ INIT reqQ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.5">The bank of lifts</head><p>Each lift consists of a door, a shaft, and a controller (Figure <ref type="figure">27</ref>).</p><p>The collection of all the lifts (Figure <ref type="figure">28</ref>) in the system is modeled as an aggregate of the individual lifts acting autonomously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">The central controller</head><p>The responsibility of the central controller is to dispatch floor requests to idle lifts (modeled in Figure <ref type="figure" target="#fig_3">26</ref>). It consists of a request queue with channels that connect the floors and the lifts. The network topology is described graphically in Figure <ref type="figure" target="#fig_7">14</ref>.</p><p>The controller receives requests from the floors and enters them into the reqQ queue (Join operation). In the ordinary case these requests are dispatched in first-in-first-out manner (Dispatch operation) as idle lifts become available, but if in the course of servicing internal requests a lift can visit a floor whilst moving in the floor required direction, the request is removed from the queue (CheckServ operation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">The lift system</head><p>The lift system consists of the floors of the building, the bank of lifts and the central controller. The number of floor-service </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 29. final lift system model</head><p>The lift system behaviour MAIN describes the communication channels between the independent concurrently executing system components: the lifts, the floors, and the controller. The floors communicate service requests to the controller through the enter channel, the controller dispatches these requests to the lifts through the select and check channels, and the lifts indicate successful servicing of requests to the floors through the service channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Discussion</head><p>The application of TCOZ to the multi-lift system has been convincingly successful, despite the relatively modest real-time aspects of the specification. The powerful combination of object-oriented structuring, data modeling, and process modeling features available in TCOZ has allowed the clean presentation of an ambitiously detailed (when compared to versions described in other languages) treatment of the multi-lift system. This strongly supports our claims that TCOZ represents a highly scalable and reusable method for describing real-time and concurrent systems. As an example, consider modifying the specification so as to allow `opportunistic' servicing of requests entered after a lift starts moving. The modular nature of the specification immediately draws attention to the Shaft class which controls the movement of the lift between floors. The interface of this class needs to be expanded to include events to indicate the lift is approaching the next floor and to stop the lift at the next floor. Armed with these additional controls the LiftControl class can easily be modified to react opportunistically to new service requests.</p><p>One surprise in the development of the TCOZ lift was the degree to which the process model idiom came to dominate. The starting point of the development had been a data oriented standard Object-Z specification <ref type="bibr" target="#b16">[16]</ref>. Rather than being a simple matter of adding real-time and concurrent features to the existing specification it soon became clear that much of its `data' was in fact being used to represent `process' behaviour which could be more elegantly represented using the CSP process modeling features of TCOZ. The final approach adopted was to model the system primarily as a network of communicating processes and to make use of Object-Z' s data modeling features to simplify and structure the specification by abstracting away from algorithmic specifics and reusing common data components such as buttons.</p><p>A perceived weakness of the TCOZ approach was identified in its handling of the interface between TCOZ processes and the real world. Although the abstraction of button presses as communications on external channels is reasonably acceptable, the inability to describe `continuously' changing aspects of the system such as `lift position' is particularly disturbing. Whilst modeling the moving process by start and finish events provides an adequate interface to the TCOZ specification it goes no way at all toward ensuring that lift shaft satisfies our informal intuitions as to its behaviour. The specification is thus strictly speaking not of a system for moving people between floors of a building, but rather simply a description of a method of controlling such a system in a satisfactory manner.</p><p>One advantage of choosing the lift system to exercise the TCOZ language is the availability of existing lift specifications in both CSP <ref type="bibr" target="#b49">[49]</ref> and Object-Z <ref type="bibr" target="#b16">[16]</ref>. Apart from the ability of TCOZ to describe timing aspects not addressed by either of these specifications, such as the correct behaviour of the door opening cycle, TCOZ represents an improvement in expressibility, modularity, and reusability over both existing specifications.</p><p>The CSP `lift' model <ref type="bibr" target="#b49">[49]</ref> is similar in spirit to the TCOZ lift presented here, except that it does not consider the door cycle nor the movement of the lift. However, in contrast to the highly modular approach of the TCOZ specification, the CSP version is forced to adopt a quite flat structure because the only structuring facility available is the process definition. The channel interface declarations and the network topology operator provide valuable information to the reader of the TCOZ specification regarding the source and destination of communications, which is not available to the reader of the CSP specification. Although some attempt is made to structure the CSP specification document through the use of section headings to distinguish system components, the essentially global nature of all process definitions and com-munication channels makes it difficult to comprehend individual process definitions without extensive reference to the rest of the specification. The standard CSP synchronisation operator ( k ) is a particular point of weakness as it offers no visual feedback as to the interface between network components. The use of the network topology operator (and associated diagrams) is a particular strength of the TCOZ specification.</p><p>The weaknesses in CSP' s treatment of data and algorithms not only adds syntactic clutter to the CSP lift, but also appears to influence the structure of the specification. In particular, the difficulty in abstracting various calculations away from the specific direction of travel results in a `split' specification, with many features being repeated for both the `up' and `down' directions of travel. For example, the specification of a single lift <ref type="bibr">[49, p 26]</ref> includes subprocesses Lift(f ; up) and Lift(f ; down) which differ primarily in the method of calculating the next floor on the itinerary. In contrast the TCOZ version abstracts this calculation into the Next operation of the Internal Q class allowing the description of the lift' s gross behaviour to be independent of the direction of travel, even despite using a more complex method of determining the itinerary. Although a specification of this form is possible in CSP, the lack of strong, modular data modeling facilities acts as a strong disincentive to this form of abstraction.</p><p>The Object-Z `lift' model <ref type="bibr" target="#b16">[16]</ref> provided a structured and reusable model and was able to describe the sequence of state changes of the overall lift system. However, Object-Z' s process semantics forces the specification to include extra data for describing process state and all system components to be viewed passively (except the lift system class) which leads to a complex, centralised control-model. The lift components, such as the shaft and the door, were abstractively modeled as internal state components (rather than component objects) of the lift. The system class LiftSystem <ref type="bibr">[16, pp 146,147]</ref> became very complex (and lengthy) because the global ordering of synchronisations between lifts, floor requests and request queue must be explicitly determined. In the TCOZ model only the local ordering of these events need be specified, the global ordering is implicit in the CSP event synchronisation model. In addition, the TCOZ model gives the freedom of viewing the lift system components as active entities allowing a more natural, modular, and reusable description of the lift system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related work</head><p>The basis for the successful blending of the Timed CSP and Object-Z notations is the duality between state transition semantics and event semantics. This has long been recognised <ref type="bibr" target="#b29">[29,</ref><ref type="bibr">35,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6]</ref> and has undoubtedly helped shape the development of Object-Z' s behavioural semantics. Perhaps the most mature formalism based on this duality is Butler' s <ref type="bibr" target="#b5">[6]</ref> blending of CSP with Back' s Action Systems <ref type="bibr" target="#b2">[3]</ref>. An important lesson from this work is the need to distinguish strongly between the notions of guard and precondition in the statetransition view. The failure to do so in Object-Z has made it impossible to reconcile the usual Z precondition refinement techniques with the default behavioural semantics. The adoption of a distinct notion of state guards in TCOZ makes possible a full blending of Z-style algorithm and CSP-style process refinement.</p><p>The notion of blending the untimed CSP and Object-Z has been proposed independently by Fischer <ref type="bibr" target="#b22">[22]</ref> and Smith <ref type="bibr" target="#b51">[51]</ref>. Both take the approach of identifying the notion of channel with that of operation and operation invocations with atomic communications of both inputs and outputs. The latter prevents the modeling of timing and concurrency at the operation level and complicates the CSP semantics through the mixing of elements of external (inputs) and internal (outputs) choice in a single event. The former is undesirable from a theoretical standpoint because it confuses communications interfaces which are essentially process related attributes with algorithmic structures which are essentially data related attributes. An object' s communications interface should be determined by highlevel considerations of the overall system structure, whilst the operational interface should be determined by consideration of the internal data structures. The purpose of the class envelope is to resolve such tensions locally, not to propagate them up and down the design hierarchy. The practical consequences of the identification of channel and operation is the promotion of both high degrees of coupling between classes and unnatural class structures. Neither formalism makes a thorough distinction between preconditions, guards, and operations and consequently refinement issues are complicated in both. Smith adopts a semantics which is unable to model process divergence and as a consequence must identify preconditions with guards, making process and precondition refinement incompatible. The semantics adopted by Fischer does allow a distinction between guards and preconditions, but guards are tightly coupled with operations so that the same operation may not be used in differing circumstances as is the Remove operation in the Controller class. Moreover, a convention is introduced whereby when an operation guard is not explicitly defined the precondition is used by default, thus complicating both the understanding of the process behaviour and the refinement of the operation. Issues, such as real-time and the distinction between active and passive objects, are not addressed by either formalism.</p><p>More generally, the need for specification notations capable of addressing both data/algorithmic issues and process control issues is widely recognised. Several notations now exist aimed at bridging this divide.</p><p>These fall essentially into two classes, those that adopt a process-algebra/event-based style (LO-TOS <ref type="bibr" target="#b33">[33]</ref>, ESTEREL <ref type="bibr" target="#b4">[5]</ref>, RAISE <ref type="bibr" target="#b26">[26]</ref>) and those that adopt a transition system style (UNITY <ref type="bibr" target="#b6">[7]</ref>, Action Systems <ref type="bibr" target="#b2">[3]</ref>, TLA <ref type="bibr" target="#b35">[36]</ref>). We consider two real-time specific languages, E-LOTOS <ref type="bibr" target="#b32">[32]</ref> and AS-TRAL <ref type="bibr" target="#b7">[8]</ref>, as being representative of their respective classes and having similar aims to TCOZ.</p><p>The LOTOS specification language <ref type="bibr" target="#b33">[33]</ref> is very similar in approach to TCOZ, blending CSP-like process primitives with a declarative-style data-specification language. E-LOTOS <ref type="bibr" target="#b32">[32]</ref> is a recently developed real-time extension to LOTOS. The process and real-time primitives of E-LOTOS are influenced by Timed-CSP, therefore these aspects of E-LOTOS are similar to TCOZ. The major differences lie in the data-modeling and structuring aspects of the two formalisms. The data modeling language of E-LOTOS is an algebraic/functional hybrid, whilst TCOZ is model based. The module construct of E-LOTOS is similar to the class construct of TCOZ in that it can encapsulate states and operations. Modules can be reused via the imports mechanism which is similar to the class inheritance. However E-LOTOS modules cannot be instantiated as a type, while TCOZ classes can. Therefore, the notions of object and composition of objects (aggregation) are missing from E-LOTOS. In TCOZ this adds another dimension of potential for reuse of specifications. E-LOTOS' s subtyping is a simple record-type extension mechanism which is less powerful than the TCOZ' s polymorphic typing (inheritance hierarchy and class union).</p><p>ASTRAL is developed based on the ideas of RT-ASLAN <ref type="bibr" target="#b1">[2]</ref> and TRIO <ref type="bibr" target="#b27">[27]</ref>. AS-TRAL also has a module construct that encapsulates the variables and transactions. The ASTRAL module has the two dimensions of reuse, importing and type instantiation. Therefore the ASTRAL module is very close to the TCOZ class construct except that the names of instances of a module are modeled explicitly, while the object identity is implicitly included in the TCOZ class semantics (a class is a collection of object identities). In ASTRAL, object composition is generally modeled by the (programming language flavoured) list type construct, array :::of :::. In TCOZ, object composition may have various (mathematics flavoured) abstract forms, i.e. collections `P:::' and list `seq :::' . The timing aspects are similar to the TLA approach <ref type="bibr" target="#b0">[1]</ref> and the Timed Object-Z approach <ref type="bibr" target="#b10">[11]</ref>.</p><p>That is, a global clock NOW is introduced and system environments are modeled explicitly. Therefore sequential realtime systems can be captured well by AS-TRAL, while truly concurrent active systems are difficult to describe in ASTRAL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions and further work</head><p>Timed CSP and Object-Z complement each other not only in their expressive capabilities, but also in their underlying semantics. In addition, the object oriented flavour of Object-Z provides an ideal foundation for promoting modularity and separation of concerns in system design. The combination of the two, TCOZ, treats data and algorithmic concerns in the Object-Z style and treats process control, timing, and communication concerns in the CSP style. The notion of active and passive objects are clearly distinguished in the TCOZ model.</p><p>This powerful modeling combination, TCOZ, has been successfully applied to a comprehensive case study on specifying a real-time multi-lift system. In comparison to the CSP model <ref type="bibr" target="#b49">[49]</ref> and the standard Object-Z model <ref type="bibr" target="#b16">[16]</ref> of the lift system, the TCOZ model not only describes the complex system state and behaviour within a cleaner and less coupled structure, but also captured the true concurrent realtime interactions between various system components of the lift system. The lift case study also provides feedback to the development of TCOZ. For example, the development of the modeling notation for complex network topologies is motivated by the lift case study. A particular weakness of the language has been identified in its ability interface with `real-world' aspects of a system. This clearly limits the applicability of the notation to the software aspects of a system. Future work will be directed toward improving its capabilities in this direction so as to integrate it into a more holistic approach to realtime and embedded systems design. One promising approach is to enhance TCOZ with features of the Timed Refinement Calculus <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b42">43]</ref> which allow convincing descriptions of continuously varying real-world observables. Some results on this work have been recently reported in <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>TCOZ preserves in large part both the syntax and semantics of the individual notations and hence can potentially benefit from the large body of experience developed in the use of and tool support for the individual notations and their parents. These benefits might include: the full application of the Z schema calculus, structured design, and refinement techniques; the application of Timed CSP process equivalence and refinement techniques, especially the Timed CSP model hierarchy for moving between timed and untimed models; the extension of existing Z, Object-Z, and CSP tools and model checkers. For example, we are currently planning a project to construct a parser/typechecker for TCOZ based on the Object-Z parser of Johnson <ref type="bibr" target="#b34">[34]</ref>.</p><p>A separate paper details the blended state/event process model which forms the basis for the TCOZ semantics <ref type="bibr" target="#b37">[38]</ref>. Additional planned work includes developing refinement rules for the TCOZ specification language based on existing Z and CSP refinement systems. Schneider has described a system for capturing and verifying abstract temporal requirements of Timed CSP processes <ref type="bibr" target="#b47">[47]</ref>, it is hoped that this might also form a valuable addition to the TCOZ notation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A TCOZ Concrete Syntax</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Notation</head><p>The syntax is described in an extended BNF with the following metasymbols: Nonterminal names are typically compound and abbreviated, each part commencing with an upper-case letter, e.g. OpExpDef . Abbreviations are listed below.</p><p>Terminal symbols are shown directly as they appear in TCOZ. Metasymbols are larger than terminal symbols of the same shape as seen by:</p><p>℄ [ ] and . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GenDef</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Object-Z model of the Timed Collection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>The initial state is represented by the empty set. TimedCollection b = TC ? :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>mems = ?] Add; TC 2 mems 6 = ?] ((Add 2 Delete) .ftg Purge); TC</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. delete operation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 9</head><label>9</label><figDesc>Figure 9. delete operation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .Figure 10 .</head><label>810</label><figDesc>Figure 8. Buffered consumer producer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Two dimensional communication topology</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Lift system communication diagram</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 17 .</head><label>17</label><figDesc>Figure 17. top floor model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 16 .Figure 18 .Figure 19 .</head><label>161819</label><figDesc>Figure 16. External service request panels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 20. building model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 22 .Figure 21 .</head><label>2221</label><figDesc>Figure 22. door model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 25 .</head><label>25</label><figDesc>Figure 25. individual lift controller model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Nonterminals ending in List have productions according to:xList x x</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Figure 3. behaviour when non- empty</head><label></label><figDesc></figDesc><table><row><cell cols="2">When the collection is non-empty the pro-</cell></row><row><cell cols="2">cess is ready to accept left or right events.</cell></row><row><cell cols="2">The staleness stamps are updated with</cell></row><row><cell cols="2">each communication and state update de-</cell></row><row><cell cols="2">lays are introduced. In the event of no</cell></row><row><cell cols="2">communication occurring before the old-</cell></row><row><cell cols="2">est element becomes stale, all stale ele-</cell></row><row><cell cols="2">ments are purged (see Figure 3).</cell></row><row><cell cols="2">TC f(t;a)g s b = (left?e : X@t i ! WAIT t a ; TC ps(ti+ta;f(t;a)g s) f(to;e)g 2 right!a@t i ! WAIT t d ;</cell></row><row><cell>TC ps(ti+td;s) ) .ftg</cell><cell></cell></row><row><cell cols="2">WAIT t p ; TC ps(t+tp;tl)</cell></row><row><cell cols="2">where (t; a) = find oldest(f(t; a)g s).</cell></row><row><cell cols="2">X] find oldest : P 1 (T X) !</cell></row><row><cell>(T</cell><cell>X)</cell></row><row><cell cols="2">8 s : P 1 (T X) 9(t; e) : s</cell></row><row><cell cols="2">t = min(dom s)</cell></row><row><cell cols="2">find oldest(s) = (t; e)</cell></row><row><cell>TC ? b = left?e : X ! WAIT t a ; TC f(to;e)g</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The ac-tual state-change allowed by the operation schema remains unchanged from the Timed Object-Z version, but the timing characteristics of the operation are expressed by the condition = t a , rather than now 0 ? now = t a .</figDesc><table><row><cell>Add 0 (mems) e? : X t i ? : T</cell></row><row><cell>= t a mems 0 =</cell></row><row><cell>ps(t</cell></row></table><note><p>i ? + t a ; mems) f(t o ; e?)g Add b = e : X; t i : T]</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>X mems 6 = ? ) (t;oldest) 2 mems ^t = min dom mems : X; t i : T] left?e@t i ! Add 0 Delete b = t i : Tj mems 6 = ?] right!oldest@t i ! Delete 0</figDesc><table><row><cell>TimedCollection X]</cell><cell></cell></row><row><cell>mems : P(T X) left; right : chan</cell><cell>INIT mems = ?</cell></row><row><cell>t : T</cell><cell></cell></row><row><cell>Add 0 (mems) e? : X t i ? : T = t a mems 0 = ps(t i ? + t a ; mems) f(t o ; e?)g</cell><cell>Delete 0 (mems) t i : T mems 6 = ? ^ = t d mems 0 = ps(t i + t d ; (mems n f(t; oldest)g)</cell></row><row><cell>Add b =</cell><cell></cell></row></table><note><p>oldest : e Purge (mems) = t p ^mems 0 = ps(t + t p ; mems) MAIN b = TC mems = ?] Add; TC 2 mems 6 = ?] ((Add 2 Delete) .ftg Purge); TC Figure 7. Timed Object-Z model of the Timed Collection mems : F(T X) left; right : chan t : T oldest : X mems 6 = ? ) (t; oldest) 2 mems t = min dom mems</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>timing property of the door is that once it is open, it must remain open for time period The door cycle is initiated by receipt of an open signal from the lift controller and completed by sending a close signal. As soon as the door is open, a conf signal must be sent to the lift controller so as to indicate fulfillment of a service request.</figDesc><table><row><cell>t o : T</cell><cell cols="2">[open time]</cell></row><row><cell cols="3">before closing. The safety property is that</cell></row><row><cell cols="3">if the closing of the door is blocked (as in-</cell></row><row><cell cols="3">dicated by receipt of an Interrupt message)</cell></row><row><cell cols="2">the door must be reopened.</cell></row><row><cell>Door</cell><cell></cell></row><row><cell cols="2">open conf close chan</cell></row><row><cell cols="2">servo sensor chan</cell></row><row><cell>OpenDoor</cell><cell></cell></row><row><cell cols="2">servo ´self ToOpenµ</cell></row><row><cell cols="2">sensor ´self Openedµ</cell><cell>SKIP</cell></row><row><cell>CloseDoor</cell><cell></cell></row><row><cell cols="2">servo ´self ToCloseµ</cell></row><row><cell cols="2">sensor ´self Closedµ</cell><cell>SKIP</cell></row><row><cell>CycleDoor</cell><cell></cell></row><row><cell cols="2">OpenDoor conf</cell></row><row><cell cols="3">´ CD ¯WAIT t o CloseDoor Ç ´sensor ´self Interruptµ</cell></row><row><cell></cell><cell cols="2">OpenDoor CDµµ</cell></row><row><cell>MAIN</cell><cell>D ¯open</cell></row><row><cell cols="2">CycleDoor close</cell><cell>D</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>int sched int serv chan AE dir MoveDirection℄ ¯select ´dest dirµ SetDir External MAIN LC ¯Get Internal ¾ ´WAIT t p Get Externalµ LC</figDesc><table><row><cell>LiftControl</cell><cell></cell></row><row><cell>fl AE</cell><cell></cell></row><row><cell cols="2">md MoveDirection</cell></row><row><cell cols="2">move arrive chan</cell><cell>[shaft]</cell></row><row><cell cols="2">open conf close chan</cell><cell>[door]</cell></row><row><cell cols="2">int sched int serv chan</cell><cell>[internal Q]</cell></row><row><cell cols="3">select check service chan ¡ irs AE ups dns AE AE height panel irs SetFloor ¡´flµ SetDir ¡´mdµ dest AE dir MoveDirection f dom panel panel´f µ state On [external channels] CalDir dest AE dir MoveDiection ups fl ¼ dest md ¼ dir dest fl dir md fl dom panel ¯ n irs n fl dns dest fl dir Up fl dom panel ¯ n irs n fl dest fl dir Down</cell></row><row><cell cols="3">NextUp fl dest dom panel ´ups´fl µ dest min ups´fl µµ ´ups´fl µ dns´fl µ dest max dns´fl µµ Move dest AE dest fl℄ ¯move ´dest flµ arrive open conf SetFloor ¾ NextDown fl dest dom panel dest AE dest fl℄ ¯open conf SKIP ´dns´fl µ dest Internal CalDir SetDir Move int serv fl close SKIP max dns´fl µµ ´dns´fl µ ups´fl µ dest min ups´fl µµ Get Internal int sched ´fl mdµ dest AE℄ ¯int sched dest check ´fl dest mdµ check Internal ¾ dest AE℄ ¯check dest External External Move service ´fl mdµ close SKIP Next md MoveDirection md Up℄ NextUp Get External dest</cell></row><row><cell cols="2">md MoveDirection md</cell><cell>Down℄ NextDown</cell></row><row><cell>MAIN</cell><cell>IQ ¯</cell></row><row><cell></cell><cell cols="2">Figure 24. internal queue model</cell></row><row><cell cols="2">internal floor-request panel and those dis-</cell><cell>vices are requested by passing the current</cell></row><row><cell cols="2">patched from the central control. For the</cell><cell>floor fl? and movement direction md? on</cell></row><row><cell cols="2">purposes of limiting design complexity a</cell><cell>the int sched channel.</cell></row><row><cell cols="2">separate class is defined to determine the lift' s internal service itinerary.</cell><cell>The operations of the controller are turning the panel buttons on and off, in response</cell></row><row><cell cols="2">This internal queue makes use of a panel</cell><cell>to service requests and confirmations, and</cell></row><row><cell cols="2">of buttons to communicate with passen-</cell><cell>determining the next destination for the lift</cell></row><row><cell cols="2">gers and to maintain a record of the floor-</cell><cell>itinerary. The next destination is the first</cell></row><row><cell cols="2">requests pending (Figure 24). A depen-</cell><cell>requested destination in the current direc-</cell></row><row><cell cols="2">dent (secondary) variable irs records the</cell><cell>tion of movement, reversing at either ex-</cell></row><row><cell cols="2">set of destinations that have been selected</cell><cell>tremity of movement. A scheduling re-</cell></row><row><cell cols="2">by the passengers at any given time. This</cell><cell>quest is only serviced if there are pending</cell></row><row><cell cols="2">set may in turn be split into those destina-</cell><cell>floor-service requests.</cell></row><row><cell cols="2">tions above a given floor, ups, and those</cell></row><row><cell cols="2">below, dns. Floor services are requested</cell></row><row><cell cols="2">on the int request channel and confirmed</cell></row><row><cell cols="2">on the int serv channel. Scheduling ser-</cell></row></table><note><p>fl dom panel℄ ¯int request ´self flµ panel´flµ TurnOn IQ ¾ fl dom panel℄ ¯int serv fl panel´flµ TurnOff IQ ¾ fl dom panel md MoveDirection irs ℄ īnt sched ´fl mdµ Next int sched dest IQ</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Figure 26. lift system controller model</head><label></label><figDesc>AE md MoveDirection℄ ¯check ´fl d mdµ Find suc℄ ¯check dest Remove ¾ suc℄ ¯check SKIP MAIN C ¯´Join ¾ Dispatch ¾ CheckServµ C</figDesc><table><row><cell>Join ¡´reqQµ req ´AE ¢ MoveDirectionµ on enter</cell><cell cols="2">Find fl d AE md MoveDirection dest AE</cell><cell></cell></row><row><cell>reqQ ¼ reqQ Remove ¡´reqQµ ´dest md µ AE ¢ MoveDirection req reqQ ¼ ×ÕÙ × ŕeqQ ´dest md µ µ</cell><cell cols="3">suc md suc µ dest min ups´fl d µ Up suc ´ups´fl d µ µ md Down suc ´dns´fl d µ µ suc µ dest min dns´fl d µ</cell></row><row><cell cols="2">Dispatch ´dest mdµ AE ¢ MoveDirection reqQ ´dest mdµ Remove</cell><cell>´dest mdµ</cell><cell>reqQ℄</cell><cell>select</cell></row><row><cell>CheckServ</cell><cell></cell><cell></cell><cell></cell></row><row><cell>fl d</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>increases down the page. The 'L/R' indication determines left or right associativity of binary operators.The nonterminal Deltalist cannot be written DeltaList as the construct represented does not conform to the List convention.</figDesc><table><row><cell cols="2">OpSchemaExp</cell><cell></cell><cell></cell><cell>NetworkTopology Pred µ Pred</cell><cell>R</cell></row><row><cell></cell><cell>GenFormals℄ Decs Pred℄ SchemaText ¯OpExp Ï SchemaText ¯OpExp</cell><cell></cell><cell></cell><cell>OpExp OpExp SchemaText℄ ¯OpExp Pred Pred</cell><cell>L</cell><cell>L</cell></row><row><cell cols="2">GenFormals OpExp OpExp NameList℄ StateSchema OpExp OpExp ChanDecs℄</cell><cell>L L</cell><cell></cell><cell>Pred Pred OpExp ¾ OpExp Pred OpExp Ù OpExp Name INIT</cell><cell>L L</cell><cell>L</cell></row><row><cell></cell><cell>PrimVarDecs℄ Deltalist℄ Decs℄ ¡ SecVarDecs℄ Exp ℄ OpName</cell><cell>Pred℄ ℄</cell><cell></cell><cell>OpExp OpExp true false OpExp Exp ℄ OpExp BoolExp</cell><cell>L L</cell></row><row><cell></cell><cell>ClassInv℄ ´OpExpµ</cell><cell></cell><cell></cell><cell>OpExp OpExp ´Predµ</cell><cell>L</cell></row><row><cell cols="3">NetworkTopology ChanDecs ChanDec ChanDec ´Connection Connection µ</cell><cell></cell><cell cols="2">OpExp º Exp OpExp OpExp º Event OpExp L L</cell></row><row><cell cols="3">ChanDec PrimVarDecs SecVarDecs Connection NameList NameList ¹ NameList NameList chan Decs Decs Event Name Exp℄</cell><cell cols="3">OpExp Ç OpExp Iff (¸), disjunction ( ) and conjunction L ( ) are associative. 'R' indicates right-to-OpExp ¯DEADLINE Exp left association. OpExp ¯WAITUNTIL Exp BoolExp Exp</cell></row><row><cell cols="3">ClassInv InitialSchema INIT Pred Operations OpDef Sep OpDef Pred Productions are in equal-precedence groups (separated by ) and the precedence of groups OpName Name MAIN Deltalist ¡´NameListµ</cell><cell>Exp</cell><cell cols="2">WAIT Exp Event @Exp℄ OpName ¯OpExp OpExp OpExp Renaming OpExp Ò ´NameListµ SchemaText ¯Exp℄ SchemaText ¯Exp Ð Ø LetDefs ¯Exp Pred Ø Ò Exp Ð× Exp</cell></row><row><cell cols="2">OpDef OpSchemaDef OpExpDef OpSchemaDef OpName SchemaText Decs Pred℄ Decs</cell><cell></cell><cell></cell><cell>OpSchemaExp Exp ¢ Exp ½ ´OpExpµ È Exp</cell></row><row><cell></cell><cell>Deltalist℄ Dec Dec</cell><cell></cell><cell></cell><cell>Exp ℄ OpName</cell></row><row><cell>Dec</cell><cell>Decs℄ NameList Exp</cell><cell></cell><cell></cell><cell>STOP SKIP Exp Infix Exp</cell><cell>L</cell></row><row><cell cols="2">Pred℄ SchemaText ¯Pred OpExpDef Pred OpName OpExp SchemaText ¯Pred</cell><cell></cell><cell></cell><cell>Exp Exp Prefix Exp</cell><cell>L</cell></row><row><cell>OpExp</cell><cell>½ SchemaText ¯Pred</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Ù SchemaText ¯OpExp Ð Ø LetDefs ¯Pred</cell><cell></cell><cell></cell><cell>Exp Postfix</cell></row><row><cell></cell><cell>¾ SchemaText ¯OpExp SchemaText ¯OpExp Pred ¸Pred</cell><cell>L</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For ease of presentation (especially in the Object-Z and Timed CSP versions) we adopt exact timing constraints in the timed-collection example.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Smith's semantics also includes ready sets which record the enabled events at each step.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Note the clear influence of CSP.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This may be non-zero because the process must wait until the event is requested by its environment.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Although if-then style commands appear in several dialects of CSP, for example CSP M<ref type="bibr" target="#b46">[46]</ref>, we believe that TCOZ is unique in adopting the state guard as a seperate primitive in the style of Morgan's version of the guarded command language<ref type="bibr" target="#b45">[45]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Many formal notations have been applied to the lift system. For example, the UNITY model<ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9]</ref>, Raddle<ref type="bibr" target="#b23">[23]</ref>, and Constraint Nets<ref type="bibr" target="#b55">[55]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Object containment ensures that no object directly or indirectly contains itself; and no object is directly contained in two distinct objects. For a detailed discussion see<ref type="bibr" target="#b11">[12]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank John Colton, Ian Hayes, Keith Gallagher, Neale Fulton, and the anonymous referees for many useful comments. This work has been supported in part by the DSTO/CSIRO Fellowship programme.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Abbreviations</head><p>The following abbreviations are used in the productions listed in Section A. <ref type="bibr" target="#b2">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Productions</head><p>The order of presentation of productions is top down with definitions for nonterminals appearing after their last application, except for recursive definitions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Specification</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An Old-Fashioned Recipe for Real Time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Huizing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-P</forename><surname>De Roever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">editors, Proc. REX Workshop on Real-Time: Theory in Practice</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">600</biblScope>
			<biblScope unit="page" from="1" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Rt-aslan: A specification language for real-time systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Auernheimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kemmerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="1986-09">September 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Refinement calculus, part II: Parallel and reactive programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">430</biblScope>
			<biblScope unit="page" from="42" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A message passing system: An example of combining CSP and Z</title>
		<author>
			<persName><forename type="first">M</forename><surname>Benjamin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Annual Z User Meet ing</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Nicholls</surname></persName>
		</editor>
		<editor>
			<persName><surname>Editor</surname></persName>
		</editor>
		<meeting>the Fourth Annual Z User Meet ing<address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989-12">December 1989. 1990</date>
			<biblScope unit="page" from="221" to="228" />
		</imprint>
	</monogr>
	<note>Workshops in Computing</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The ESTEREL synchronous programming language: design, semantics, implementation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="87" to="152" />
			<date type="published" when="1992-11">November 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A CSP Approach to Action Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Butler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Michaelmas Term</publisher>
		</imprint>
		<respStmt>
			<orgName>Wolfson College, Oxford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Parallel Program Design: A Foundation</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Specification of Realtime Systems Using ASTRAL</title>
		<author>
			<persName><forename type="first">A</forename><surname>Coen-Porisini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kemmerer</surname></persName>
		</author>
		<idno>96-30</idno>
		<imprint>
			<date type="published" when="1997-01">January 1997</date>
			<pubPlace>Santa Barbara, US</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Devising a formal specification for an elevator controller</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Cunningham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shen</surname></persName>
		</author>
		<idno>TR 94-10</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer and Information Science, University of Mississippi</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Living with free type and class union</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 1995 Asia-Pacific Software Engineering Conference (APSEC&apos; 95)</title>
		<meeting><address><addrLine>De</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="304" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A formal object approach to realtime specification</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Colton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zucconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 3rd Asia-Pacific Software Engineering Conference (APSEC&apos; 96)</title>
		<meeting><address><addrLine>Seoul, Korea</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996-12">December 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The geometry of object containment</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Object-Oriented Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="63" />
			<date type="published" when="1995-03">March 1995</date>
			<publisher>Chapman &amp; Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fulton. Capturing Periodic Concurrent Interactions of Mission Computer Tasks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 6th Asia-Pacific Software Engineering Conference (APSEC&apos; 99)</title>
		<meeting><address><addrLine>De</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="538" to="545" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Active objects in TCOZ</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Second International Conference on Formal Engineering Methods (ICFEM &apos; 98)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Staples</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Hinchey</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</editor>
		<meeting>Second International Conference on Formal Engineering Methods (ICFEM &apos; 98)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="16" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The role of secondary attributes in formal object modelling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The First IEEE International Conference on Engineering Complex Computer Systems (ICECCS&apos; 95)</title>
		<editor>
			<persName><forename type="first">Alex</forename><surname>Stoyenko</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
	<note>Ft</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Usa</forename><surname>Lauderdale</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
			<publisher>IEEE Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Specifying parallel and distributed systems in Object-Z</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zucconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 2nd International Workshop on Software Engineering for Parallel and Distributed Systems</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Russo</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="140" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The Object-Z specification language: Version 1. Technical Report 91-1, Software Verification Research Centre</title>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<pubPlace>Australia</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Modelling object identity</title>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Australian Comput. Sci. Conf. (ACSC-16)</title>
		<meeting>16th Australian Comput. Sci. Conf. (ACSC-16)</meeting>
		<imprint>
			<date type="published" when="1993-02">February 1993</date>
			<biblScope unit="page" from="93" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Formal Object Oriented Specification</title>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Macmillan</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Object-Z: a specification language advocated for the description of standards</title>
		<author>
			<persName><forename type="first">R</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Standards and Interfaces</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="511" to="533" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A formal method for building concurrent real-time software</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fidge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kearney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Utting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">CSP-OZ: A combination of Object-Z and CSP</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods for Open Object-Based Distributed Systems (FMOODS &apos; 97)</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Bowmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Derrick</surname></persName>
		</editor>
		<imprint>
			<publisher>Chapman &amp; Hall</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="423" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Design by decomposition of multiparty interactions in Raddle87</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">R</forename><surname>Forman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th IEEE International Workshop on Software Specification and Design (IWSSD&apos; 89)</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="2" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Integrated Formal Methods with Richer Methodological Profiles for the Development of Multi-Perspective Systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Galloway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">School of Computing and Mathematics</title>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Teesside</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An operational semantics for ZCCS</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Galloway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Stoddart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">editors, the IEEE International Conference on Formal Engineering Methods (ICFEM&apos; 97)</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Hinchey</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</editor>
		<meeting><address><addrLine>Hiroshima, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997-11">November 1997</date>
			<biblScope unit="page" from="272" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Haxthausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bendix Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Prehn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Wagner</surname></persName>
		</author>
		<title level="m">The Raise Specification Language</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Trio: A logic language for executable specifications of real-time system</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mandrioli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Morzenti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Systems and Software</title>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Using units of measurement in formal specifications</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Process simulation and refinement</title>
		<author>
			<persName><forename type="first">Jifeng</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="229" to="241" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Communicating Sequential Processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Prentice-Hall International</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Units of measurement: handbook on international standards for units of measurement</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>Geneva</pubPlace>
		</imprint>
	</monogr>
	<note>International Organization for Standardization</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">SC21/WG7 Working Draft on Enhancements to LOTOS, ISO Working Group 7</title>
		<author>
			<persName><surname>Iso</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-12">December 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">LOTOS -A formal description technique based on the temporal ordering of observational behaviour</title>
		<idno>ISO 8807</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A state-based approach to communicating processes</title>
		<author>
			<persName><forename type="first">W</forename><surname>Johnston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Josephs</surname></persName>
		</author>
		<idno>96-24</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="9" to="18" />
			<date type="published" when="1988">July 1996. 1988</date>
			<pubPlace>Brisbane 4072. Australia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Software Verification Research Centre, School of Information Technology, The University of Queensland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>A type checker for Object-Z</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The temporal logic of actions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="872" to="923" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Should your specification language be typed?</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<idno>147</idno>
	</analytic>
	<monogr>
		<title level="j">Systems research Center</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Overview of the semantics of TCOZ</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFM&apos; 99: Integrated Formal Methods</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Araki</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Galloway</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Taguchi</surname></persName>
		</editor>
		<meeting><address><addrLine>York, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999-06">June 1999</date>
			<biblScope unit="page" from="66" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Sensors and Actuators in TCOZ</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FM&apos; 99: World Congress on Formal Methods</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Wing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Woodcock</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Davies</surname></persName>
		</editor>
		<meeting><address><addrLine>Toulouse, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999-09">September 1999</date>
			<biblScope unit="volume">1709</biblScope>
			<biblScope unit="page" from="1166" to="1185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Networks of predicate transformers</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-02">February 1995</date>
			<biblScope unit="volume">4072</biblScope>
			<pubPlace>St. Lucia, QLD; Australia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Software Verification Research Centre, Department of Computer Science, The University of Queensland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report 95-05</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Blending Object-Z and Timed CSP: An introduction to TCOZ</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 20th International Conference on Software Engineering (ICSE&apos; 98)</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998-04">April 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Network topology and a case-study in TCOZ</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ZUM&apos; 98 The 11 th International Conference of Z Users</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998-09">September 1998</date>
			<biblScope unit="volume">1493</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A case-study in timed refinement: A mine pump</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="817" to="826" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
		<title level="m">Fixed Points Without Completeness</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Computer Science</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="273" to="314" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Programming from Specifications</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Morgan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Theory and Practice of Concurrency</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Series in Computer Science</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Correctness and Communication in Real-Time Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>Oxford University Computing Laboratory, Programming Research Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
	<note>Available as Technical Monograph PRG-84</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A brief history of Timed CSP</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Davies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Specifying a lift control system with CSP</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Delisle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th IEEE International Workshop on Software Specification and Design (IWSSD&apos; 87)</title>
		<meeting><address><addrLine>Monterey, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1987-04">April 1987</date>
			<biblScope unit="page" from="21" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A fully abstract semantics of classes for Object</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Z. Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="313" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A semantic integration of Object-Z and CSP for the specification of concurrent systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FME&apos; 97: Industrial Benefit of Formal Methods</title>
		<meeting>FME&apos; 97: Industrial Benefit of Formal Methods<address><addrLine>Graz, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997-09">September 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">The Object-Z Specification Language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">The State-Based CCS Semantics for Concurrent Z Specification</title>
		<author>
			<persName><forename type="first">K</forename><surname>Taguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Araki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the IEEE International Conference on Formal Engineering Methods (ICFEM&apos; 97)</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Hinchey</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</editor>
		<meeting><address><addrLine>Hiroshima, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="283" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Mathematics for specification and design: The problem with lifts</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C P</forename><surname>Woodcock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Sorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 4th IEEE International Workshop on Software Specification and Design (IWSSD&apos; 87)</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="265" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Design and analysis of embedded realtime systems: An elevator case study</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Mackworth</surname></persName>
		</author>
		<idno>93-04</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, University of British Columbia</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">The following TCOZ syntax is based on the Object-Z syntax</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
