<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">P4FPGA : A Rapid Prototyping Framework for P4</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Han</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="laboratory">SOSR 2017</orgName>
								<address>
									<settlement>Santa Clara</settlement>
									<country>California USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><surname>Soulé</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Università della Svizzera italiana</orgName>
								<address>
									<settlement>Barefoot Networks</settlement>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="laboratory">SOSR 2017</orgName>
								<address>
									<settlement>Santa Clara</settlement>
									<country>California USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tu</forename><surname>Huynh</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Università della Svizzera italiana</orgName>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="laboratory">SOSR 2017</orgName>
								<address>
									<settlement>Santa Clara</settlement>
									<country>California USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Dang</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Università della Svizzera italiana</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ki</forename><forename type="middle">Suh</forename><surname>Lee</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vishal</forename><surname>Shrivastav</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nate</forename><surname>Foster</surname></persName>
							<affiliation key="aff5">
								<orgName type="institution">Cornell University Barefoot Networks</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hakim</forename><surname>Weatherspoon</surname></persName>
							<affiliation key="aff6">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ki</forename><surname>Dang</surname></persName>
							<affiliation key="aff7">
								<orgName type="laboratory">SOSR 2017</orgName>
								<address>
									<settlement>Santa Clara</settlement>
									<country>California USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Suh</surname></persName>
							<affiliation key="aff7">
								<orgName type="laboratory">SOSR 2017</orgName>
								<address>
									<settlement>Santa Clara</settlement>
									<country>California USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">P4FPGA : A Rapid Prototyping Framework for P4</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9829373AACE607F09E5C38E2194BE618</idno>
					<idno type="DOI">10.1145/3050220.3050234</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>P4</term>
					<term>FPGA</term>
					<term>High-level synthesis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents P4FPGA, a new tool for developing and evaluating data plane applications. P4FPGA is an open-source compiler and runtime. The compiler extends the P4.org reference compiler with a custom backend that generates FPGA code. P4FPGA supports different architecture configurations, depending on the needs of the particular application.</p><p>We have benchmarked several representative P4 programs, and our experiments show that code generated by P4FPGA runs at line-rate at all packet sizes with latencies comparable to commercial ASICs. By combining high-level programming abstractions offered by P4 with a flexible and powerful hardware target, P4FPGA allows developers to rapidly prototype and deploy new data plane applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>the language's domain-specific abstractions to implement a variety of novel applications, including network diagnostics and telemetry tools <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b35">38]</ref>, advanced traffic engineering and load balancing systems <ref type="bibr" target="#b19">[19]</ref>, and even optimized consensus protocols <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b25">25]</ref>.</p><p>However, most current targets for P4 are implemented in software <ref type="bibr" target="#b29">[32,</ref><ref type="bibr" target="#b33">36]</ref>. To get the full performance benefits of a programmable data plane, developers need access to platforms that can execute their designs efficiently in hardware. In this respect, Field Programmable Gate Arrays (FPGAs) are an attractive target platform for P4 programs. As a form of re-programmable silicon, FPGAs offer the flexibility of software and the performance of hardware. Indeed, major cloud providers, such as Microsoft, Amazon and Baidu, already deploy FPGAs in their data centers to boost performance-e.g., to accelerate network encryption and decryption or implement custom transport layers <ref type="bibr" target="#b32">[35]</ref>.</p><p>There are several challenges in designing a compiler from P4 to FPGAs. First, FPGAs are typically programmed using low-level libraries that are not portable across devices. Moreover, communication between 3rd party processing elements is device-specific, adding an additional hurdle to portability. Second, generating an efficient implementation of a source P4 program is difficult since programs vary widely and architectures make different tradeoffs. Third, although the P4 language is target agnostic, it relies on a number of "extern" functions for critical functionality, such as checksums and encryption, complicating code generation. This paper presents P4FPGA, an open-source P4-to-FPGA compiler and runtime that is designed to be flexible, efficient, and portable. To ensure that P4FPGA is flexible enough to implement many different network functions, the compiler allows users to incorporate arbitrary hardware modules written in the language of their choice. This approach offers a degree of flexibility that would be difficult to achieve on other targets, such as a switch ASIC. To ensure that the code generated by the compiler is efficient, P4FPGA supports datapaths with one <ref type="bibr" target="#b24">[24]</ref> or more ports <ref type="bibr" target="#b17">[17]</ref>. This approach allows users to select the best design for their particular application. Finally, to ensure that programs are portable across different devices, P4FPGA provides a runtime with device-agnostic hardware abstractions. This runtime allows P4FPGA to support designs that can be synthesized to either Xilinx or Altera FPGAs.</p><p>We have evaluated our prototype implementation on a variety of representative P4 programs. Our experiments show that code generated by P4FPGA runs at line-rate throughput on all packet sizes up to MTU with latencies similar to offthe-shelf commodity switch ASICs. Moreover, P4FPGA is already being used by at least two research projects <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b18">18]</ref> to deploy P4 programs on actual hardware.</p><p>Overall, this paper makes the following contributions: • It presents the design of a P4-to-FPGA compiler and runtime system. • It evaluates the performance of the generated code and backend on a variety of non-trivial P4 programs and demonstrates that performance is competitive with commercial switches-e.g., latencies are comparable to commercial cut-through switches. • It develops a wide variety of standard and emerging network applications using P4FPGA, which demonstrates that the tool is broadly applicable. The rest of this paper is organized as follows. We first provide background on the P4 language ( §2). We then discuss the design of the code-generation ( §3) and runtime ( §4) components; and details of the implementation ( §6). Next, we evaluate ( §7) our prototype. Finally, we discuss related work ( §8), and conclude ( §9).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND AND OVERVIEW</head><p>Before describing the details of the P4FPGA design, we briefly present a high-level overview of the P4 language <ref type="bibr" target="#b6">[6]</ref>, and networking processing on FPGAs.</p><p>P4 Background. When describing a P4 compiler, it is important to clarify some terminology. A target is hardware that is capable of running a P4 program, such as FPGAs, ASICs, or CPUs. An architecture refers to the combination of the runtime as well as the processing pipeline specified in a P4 program. A P4 program is target independent, meaning the same program can be implemented on different hardware. A P4 compiler is responsible for mapping the abstract architecture specified by the P4 program to a particular target and architecture. FPGAs are uniquely able to map abstract architectures directly to hardware. In contrast, a single switch ASIC will only be able to faithfully implement a small subset of potential architectures and extern primitives.</p><p>As a language, P4 allows developers to specify how packets are processed in the data plane of network forwarding elements. P4 programs are written against an abstract architecture that hides the actual physical implementation. In the abstract architecture, packets are first parsed, and then processed by a sequence of match-action tables. Each table matches on specified packet header fields, and then performs a sequence of actions to modify, forward, or drop the packet. Additionally, the program collects packet metadata, such as ingress and egress port numbers, which flows through the pipeline. Implicitly, at the end of the pipeline, packets are reassembled for transmission in a deparser stage. Figure <ref type="figure" target="#fig_0">1</ref> illustrates a simple example with a single parser and match table pipeline. The P4 language provides syntax that mirrors this abstract model. For brevity, we do not describe the syntax in detail as the full language specification is available online <ref type="bibr">[31]</ref>. We simply mention that programmers can declare packet headers, compose tables, and specify actions. Tables can be populated at runtime with flow rules via a control plane API.</p><p>The P4FPGA compiler supports both P4 14 and P4 16 syntax. The example code in Figure <ref type="figure" target="#fig_1">2</ref> shows a subset of a P4 14 program for counting UDP packets by destination port. Line 4 defines the layout for the UDP packet headers. Line 11 declares an instance of that header, named udp. Line 12 defines how to parse UDP packet headers. The extract keyword assigns values to the fields in the header instance. The return keyword returns the next parser stage, which could be ingress, indicating the start of the pipeline. Line 26 is the start of the flow control for the P4 FPGA Background. FPGAs are widely used to implement network appliances <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b16">16]</ref> and accelerators <ref type="bibr" target="#b3">[3]</ref>, as applications implemented on FPGAs typically achieve higher throughput, lower latency, and reduced power consumption compared to implementations with general-purpose CPUs.</p><p>Development on an FPGA typically involves using a lowlevel hardware description languages (i.e., Verilog, VHDL)  to statically specify a hardware circuit for a single application <ref type="bibr" target="#b37">[40]</ref>. However, these languages are widely regarded as difficult to use, and consequently, there has been significant research in high-level synthesis <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b34">37]</ref>.</p><p>P4FPGA uses one of these languages, Bluespec System Verilog <ref type="bibr" target="#b26">[27]</ref>, both as the target for compiler generation and to implement the runtime. Bluespec is a strongly typed functional language, similar in many respect to Haskell. Users write hardware operations as guarded rules <ref type="bibr" target="#b26">[27]</ref>. The language includes a large set of libraries for common hardware constructs such as registers, FIFO queues and state machines. Moreover, P4FPGA uses Bluespec code from the Connectal project <ref type="bibr" target="#b21">[21]</ref> to implement the control plane channel. Using Bluespec simplifies FPGA development by providing highlevel language constructs, and is more expressive than Verilog.</p><p>P4FPGA Overview. A compiler for P4 is responsible for two main tasks: generating the configuration to implement a data plane on a target platform at compile time and generating an application programming interface (API) to populate tables and other programmable elements at run time.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> presents a high-level overview of the P4FPGA framework and compilation strategy. The components inside the dashed-line were developed specifically for P4FPGA. The components outside the dashed-line are existing open-source tools or commercial products for FPGA synthesis that are re-used by P4FPGA.</p><p>P4FPGA builds on the reference P4 compiler implementation provided by the P4 organization <ref type="bibr" target="#b31">[34]</ref>. The reference compiler parses P4 source, and produces a standard intermediate representation (IR) <ref type="bibr" target="#b31">[34]</ref>. We chose to build on the reference front end for practical reasons. It both reduces the required engineering effort, and ensures that FPGA conforms to the latest P4 syntax standards.</p><p>P4FPGA includes three main components: (i) a code generator, (ii) a runtime system, and (iii) optimizers implemented as IR-to-IR transformers. The code generator produces a packet-processing pipeline inspired by the model proposed by Bosshart et al. <ref type="bibr" target="#b7">[7]</ref>. The runtime provides hardwareindependent abstractions for basic functionality including memory management, transceiver management, host/control plane communication. Moreover, it specifies the layout of the packet processing pipeline (e.g. for full packet switching, or to support network function virtualization (NFV). The optimizers leveraging hardware parallelism to increase throughput and reduce latency.</p><p>The compiler produces Bluespec code as output, which is compiled to Verilog. The Verilog code is further synthesized by downstream FPGA tool chains. The output bitstream can then be used to configure an FPGA.</p><p>In the following sections, we present the code generator, runtime system, and optimizers in full detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CODE GENERATION</head><p>The core job of the P4FPGA compiler is to map logical packet-processing constructs expressed in P4 into physical packet-processing constructs expressed in a hardware description language. We organize the generated physical constructs into basic blocks. As in most standard compilers, a basic block is a sequence of instructions (e.g., table lookups, packetmanipulation primitives, etc.). We implement basic blocks in P4FPGA using parameterized templates. When instantiated, the templates are hardware modules that realize the logic for packet parsers, tables, actions, and deparsers.</p><p>There are two motivations behind our use of basic blocks. First, it reduces the complexity of the compiler, since code generation simply becomes the composition of modules that implement standard interfaces. Second, the modular design enables extensibility in two ways: (i) programmers can easily add externally-defined functionality via a foreign-function interface (e.g., to implement a custom hash function), and (ii) programmers can modify the compiler by replacing one basic block with another that implements the same functionality (e.g., to modify the memory storage to use DRAM, SRAM, or an SSD).</p><p>The control flow constructs from the P4 source program dictate the composition of the basic blocks. We refer to this composition of blocks as the programmable packet-processing pipeline. This is in contrast to the fixed-function pipeline that is realized by the P4FPGA runtime system. In other words, the programmable packet-processing pipeline is specified by the logic of a particular P4 source program, whereas the fixedfunction pipeline is determined by the target platform, and is fixed for all input source programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Programmable Pipeline</head><p>The programmable packet-processing pipeline realizes the programmable logic of a P4 source program on an FPGA hardware implementation. It consists of a composition of basic blocks to parse, deparse, match, or perform an action.</p><p>Parsing. Parsing is the process of identifying headers and extracting relevant fields for processing by subsequent stages of the device. Abstractly, the process of parsing can be expressed as a finite state machine (FSM) comprising a set of states and transitions. From a given state, the FSM transitions to the next state based on a given input from a header or metadata. A subset of the states identifies and extracts header fields. The FSM graphs may be acyclic, as is the case with Ethernet/IPv4 parsers, or cyclic-e.g., to parse TCP options. P4FPGA adopts a streaming approach in which the packet byte stream is fed into the FSM and processed as soon as there is enough data to extract a header or execute a FSM transition.</p><p>Deparsing. As shown in Figure <ref type="figure" target="#fig_2">3</ref>, there are two sources of input data to the deparser stage. One is the packet data stored in memory ( §4), and one is the modified packet header processed by the programmable pipeline. The deparser reassembles the packet for transmission from these two input sources.</p><p>Like the parser, the deparser is implemented as a FSM. However, the design of deparser is more complicated, since it may add or remove headers during packet assembly.</p><p>The deparser consists of three modules: packet extender, packet merger, and packet compressor. The packet extender supports the addition of headers by inserting empty bytes at a designated offset. The packet merger writes modified packet fields, including fields added by the extender module. The packet compressor marks bytes to be removed by writing to a bit mask.</p><p>Note that the deparsing stage is responsible for modifying packets. Packet modification could be performed inline oneby-one (i.e., after every table), or all together at the end of the pipeline. P4FPGA takes the latter approach, since it reduces latency. In other words, the pipeline modifies a copy of the header, and changes are merged with the actual header in the deparser stage.</p><p>Matching. In P4FPGA, basic blocks for tables are implemented as FPGA hardware modules that support get/put operations via a streaming interface. P4 allows users to specify the algorithm used to match packets. Our P4FPGA prototype supports two matching algorithms: ternary and exact-match. The ternary match uses a third-party library. We implemented two versions of exact match ourselves, one using a fullyassociative content addressable memory (CAM) <ref type="bibr" target="#b1">[1]</ref>, and the other using a hash-based lookup table. Users can choose the implementation strategy by using a command line option when invoking the compiler. Note that because of the "programming with tables" abstraction that P4 provides, some programs include tables without lookup keys, whose purpose is solely to trigger an action upon every packet processed by the pipeline stage. P4FPGA handles this corner case by not allocating any table resources to this stage.</p><p>Actions. P4 actions can modify a field value; remove/add a header; or modify packet metadata. Conceptually, each action operates on one packet at any given time, with all temporary variables stored in metadata on the target. P4FPGA performs   inline editing to packet metadata and post-pipeline editing to packet headers. Modify actions create a copy of the updated value stored in a memory that is merged with the original packet header field in the deparser block. For actions that change a packet header length, basic blocks are created before and after the deparser block, to perform re-alignment. For example, to remove a packet header, the deparser marks the header as invalid in a bit mask. The realignment block then shifts the remaining bytes forward to cover the gap created by the removed header.</p><p>Control Flow. P4 control flow constructs compose tables and actions into an acyclic graph. A naïve implementation would be to use a fixed pipeline. In such a design, the runtime would use extra metadata to implement the logic of the source program. However, because we target an FPGA, P4FPGA can map the control flow directly onto the generated hardware design. Each node corresponds to a basic block followed by a branch condition. We note that this is much more flexible than implementing control flow on an ASIC. During program execution, the parsed packet and metadata is passed along the tree structure. At each node, the runtime evaluates the conditional and passes the data to the next node along the appropriate branch, or performs a table lookup depending on the rules specified in the control plane API. P4FPGA relies on pipeline parallelism to achieve high throughput. In other words, at any given time, different nodes in the tree can process different packets in parallel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Control Plane API</head><p>In addition to generating code that implements the applicationspecific logic in the data plane, P4FPGA also generates a control plane API that exposes a set of C++ functions that allow users to insert/delete/modify match table entries and read/write stateful memory. Moreover, the generated interface includes functions to support debugging. Users can inject packets via a packet capture (PCAP) trace, or can enable/disable an on-chip packet generator and capturer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">External Functions</head><p>One of the advantages of FPGAs over ASICs are that they are more flexible and programmable. P4 offers a relatively restrictive programming interface that is targeted for network applications and is platform-agnostic by design. Therefore, it is sometimes necessary to execute additional functionality via externally defined functions. An externally defined function could be used to access a state in a register or to execute custom logic, such as a checksum computation or encryption/decryption. In P4, these are declared using extern blocks, and the implementations of these calls are target specific.</p><p>P4FPGA allows users to implement externally defined functions in the hardware description language of their choice. However, such functions pose a challenge for efficient code generation, since they may have high latency. For example, an external function that accesses persistent state or requires complex logic may take a long time to complete. If the processing pipeline were to block while waiting for the function to return, it could significantly impact throughput. P4FPGA provides an asynchronous implementation, so that the processing of other packets can continue in parallel. This is roughly analogous to multi-threading, but without the associated cost of context switching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FIXED-FUNCTION RUNTIME</head><p>The P4FPGA fixed-function runtime provides the execution environment for packet processing algorithms specified in P4. It defines an API that allows generated code to access common functionality through a set of target-agnostic abstractions. Consequently, the runtime system plays a crucial role in providing an efficient, flexible and portable environment for packet processing applications. It must provide an abstract architecture that is uniform across many different hardware platforms. It must also provide an efficient medium to transport data across processing elements. Finally, the runtime system must provide auxiliary functionalities to support control, monitoring, and debugging.</p><p>Note that P4 developers can create a variety of potential applications, ranging from packet switching to NFV style hardware offloading for packet processing. These applications have different requirements from the architecture that the fixed function runtime provides. To support these different use-cases, P4FPGA allows P4 developers to choose either of two architectures: multi-port switching or bump-in-thewire. The multi-port switching architecture is suitable for network forwarding elements, such as switches and routers, and for experimenting with new network routing protocols. It includes an output cross-bar, as shown in Figure <ref type="figure" target="#fig_4">4</ref>, to arbitrate packets to the appropriate egress port. The bump-in-the-wire architecture is suitable for network functions and network acceleration. It receives packets from a single input port, and forwards to a single output <ref type="bibr" target="#b24">[24]</ref>.</p><p>Below, we describe the design of the major components of the P4FPGA fixed function runtime. These components, indicated as grey boxes in Figure <ref type="figure" target="#fig_4">4</ref>, include memory management, transceiver management, and host communication.</p><p>Memory Management. As packets arrive at the FPGA, they must be stored in memory for processing. This memory can be designed in two ways. A straight-forward approach is to use FIFO queues, which forward packets through processing elements in the order in which they are received. However, simple FIFO queues are not sufficient for implementing more advanced packet-processing features, such as quality-of-service guarantees. In particular, such features require re-ordering packets as they are processed.</p><p>Therefore, P4FPGA includes an optional memory buffer managed by a hardware memory management unit (MMU). The MMU interface defines two functions: malloc and free. The malloc function takes one parameter, the size of packet buffer to be allocated rounded up to 256-byte boundary, and returns a unique packet identifier (PID). The PID is similar to a pointer in C, and is used throughout the lifetime of the packet in the pipeline. Upon the completion of packet transmission, the PID (and associated memory) is returned to the MMU to be reused for future packets, via a call to free. Users can configure the amount of memory used for storing packets. By default, P4FPGA allocates 65,536 bytes of on-chip block RAM (BRAM) per packet buffer.</p><p>Transceiver Management. P4FPGA is portable across many hardware platforms. As a result, it provides a transceiver management unit that enables it to use the media access control (MAC) and physical (PHY) layers specific to a target platform. For instance, the P4FPGA transceiver management unit uses vendor-specific protocols without requiring changes to the P4 program.</p><p>Host Communication. P4FPGA integrates a host communication channel between the FPGA and host CPU. This is useful for implementing the control channel and for debugging. The host communication channel is built on top of the PCI express protocol, which is the de-facto protocol for internal communication within network devices, such as switches and routers. We provide both blocking and non-blocking remote procedure calls (RPC) between software and hardware. For example, it is possible for a host program to issue an non-blocking call to read hardware registers by registering a callback function to receive the returned value. Similarly, a controller can program match tables by issuing a function call with an encoded table entry as a parameter.</p><p>Timing Closure. Our general approach to the timing closure problem is as follows: First, we use pipeline FIFOs to ensure the inputs and outputs of parser, table and action blocks are registered. Second, we optimized the design of action engine and control flow logic to perform simple combinatorial logic in each cycle. If the logic is too complex to perform within a clock cycle and causes timing closure failure, we decompose the logic across multiple clock cycles. Third, the generated pipeline is constructed by template instantiation. These templates were designed to minimize timing issues by construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">OPTIMIZATION</head><p>To ensure that the code generated by P4FPGA is efficient, we implemented a number of optimizations at both the compiler and micro-architectural level. Based on our experience, we have identified a few principles that we followed to improve the throughput and latency of the packet processing pipeline. Below, we describe the optimizations in the context of the NetFPGA SUME platform, but the same principles should apply to other platforms such as Altera DE5. For clarity, we present these principles in order of importance, not novelty.</p><p>Leverage hardware parallelism in space and time to increase throughput.</p><p>FPGAs provide ample opportunities to improve system throughput by leveraging parallelism in space, e.g., by increasing the width of the datapath. The throughput of a streaming pipeline, r , is determined the datapath width, w and the clock frequency, f (r = w × f ). The maximum clock frequency for an FPGA is typically 100s of MHz (a mid-end FPGA ranges from 200 to 400 Mhz). Therefore, in order to reach a throughput of 40 to 100 Gbps, it is necessary to use a datapath width in the range of 100s of bits to a few thousand bits.</p><p>On the NetFPGA SUME platform, we target an overall system throughput of 40Gbps on the four available 10Gbps Ethernet ports at 250 MHz. We used 128-bits for the parser datapath and 512-bits for the forwarding pipeline datapath. The theoretical throughput for the parser is 128 bits × 250 Mhz, or 32 Gbps. As a result, we replicate the parser at each port to support parsing packets at 10 Gbps.</p><p>Another important form of hardware parallelism is pipeline parallelism. We clock the P4 programmable pipeline at 250 MHz. If we process a single packet in every clock cycle, we would be able to process 250 Mpps (million packet per second). At 10 Gbps, the maximum packet arrival rate is 14.4 Mpps for 64 byte packets. At 250 Mpps, we should be able to handle more than sixteen 10 Gbps ports simultaneously with one P4 programmable pipeline. Of course, the theoretical maximum rate does not directly translate to actual system performance. Nonetheless, we conducted extensive pipelining optimizations to ensure that all generated constructs are fully pipelined. In other words, control flow, match tables and action engines are all fully pipelined.</p><p>Transform sequential semantics to parallel semantics to reduce latency.</p><p>The P4 language enforces sequential semantics among actions in the same action block, meaning that side effects of a prior action must be visible to the next. A conservative compilation strategy that respects the sequential semantics would allocate a pipeline stage for each action. Unfortunately, this strategy results in sub-optimal latency, since each stage would add one additional clock cycle to the end-to-end latency.</p><p>P4FPGA optimizes latency by leveraging the fact that hardware inherently supports parallel semantics. As a result, we opportunistically co-locate independent actions in the same pipeline stage to reduce the overall latency of an action block.</p><p>Select the right architecture for the job. Network functions can be broadly divided into two subcategories: those that need switching and those that do not. For example, network encryption, filtering, firewalling can be enforced on a per-port basis. This is especially true if interface speeds increase to 50 or 100Gbps, when CPUs barely have enough cycles to keep up with data coming in from one interface. On the other hand, prototyping network forwarding elements on FPGAs requires switching capability. As mentioned in Section 4, P4FPGA allows users to select the architecture most appropriate for their needs.</p><p>Use a resource-efficient components to implement match tables. In P4FPGA generated pipelines, match tables dominate FPGA resource consumption. This is because FPGAs lack hardened content-addressable memory (CAM), an unfortunate reality of using FPGAs for network processing. Although one can implement CAM using existing resources on FPGAs, such as Block RAMs or LUTs, it is not efficient. High-end FPGAs have more resources on-chip to implement CAMs, but they also come at a premium price. To alleviate the situation, P4FPGA uses hash-based methods for table lookup. The compiler uses these more efficient implementation techniques by default. But, users may choose to use more expensive CAM implementations by specifying a compiler flag.</p><p>Eliminate dead metadata A naïve P4 parser implementation would extract full header and metadata from packets by default. This can be wasteful if the extracted headers are not used in the subsequent pipeline. P4FPGA analyzes all match and action stages, and eliminates unused header fields and metadata from the extracted packet representation.</p><p>Use non-blocking access for external modules. Stateful processing is expensive on high-performance packet-processing pipelines. Complex operations may require multiple clock cycles to finish, which can negatively affect performance if pipelining is only performed at the function level. P4FPGA implements fine-grained pipelining on stateful elements to maintain high throughput. For example, a memory read operation requires issuing a read request to memory and waiting for the corresponding response. Due to the high latency of memory, the response may only come after multiple cycles of delay. In P4FPGA, we support split-phase reads such that a read request and response can happen at different clock cycles. Meanwhile, the pipeline can continue processing other packets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">IMPLEMENTATION</head><p>Our prototype P4FPGA implementation consists of a C++based compiler along with a Bluespec-based runtime system. For the frontend, we reused P4.org's C++ compiler frontend to parse P4 source code and generate an intermediate representation <ref type="bibr" target="#b28">[30]</ref>. We designed a custom backend for FPGAs, which consists of 5000 lines of C++ code. The runtime is developed in a high-level hardware description language, Bluespec <ref type="bibr" target="#b26">[27]</ref>. Bluespec provides many higher level hardware abstractions (e.g., FIFO with back-pressure) and the language includes a rich library of components, which makes development easier. The runtime is approximately 10,000 lines of Bluespec. We relied on Bluespec code from the Connectal project <ref type="bibr" target="#b21">[21]</ref> to implement the control plane channel. We also implemented mechanisms to replay pcap traces, access control registers, and program dataplane tables. All code is publicly available under an open-source license. <ref type="foot" target="#foot_0">1</ref>Complex FPGA-based systems often require integration with existing intellectual property (IP) components from other vendors and P4FPGA is no exception. We allow third-party IPs to be integrated with the existing P4FPGA runtime system as long as those components conform to the interfaces exposed by P4FPGA runtime. For example, we currently support IP cores such as MAC/PHY and Ternary CAM (TCAM) provided by FPGA vendors and commercial IP vendors <ref type="bibr" target="#b5">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EVALUATION</head><p>In this section, we explore the performance of the P4FPGA. Our evaluation is divided into two main sections. First, we evaluate the ability of P4FPGA to handle a diverse set of P4 applications. Then, we use a set of microbenchmarks to evaluate the individual components of P4FPGA in isolation.</p><p>Toolchain and hardware setup. We evaluate the performance of P4FPGA generated designs against a set of representative P4 programs. Each program in our benchmark suite is compiled with the P4FPGA compiler into Bluespec source code, which is then processed by a commercial compiler from Bluespec Inc. to generate Verilog source code. Next, the Verilog source code is processed by the standard Vivado 2015.4 tool from Xilinx, which performs synthesis, placement, routing and bitstream generation. The compilation framework supports both the Altera tool suite, Quartus, and Xilinx tool suite, Vivado. For this evaluation, we only used Vivado. We deployed the compiled bitstream on a NetFPGA SUME platform with a Xilinx Virtex-7 XC7V690T FPGA, with 32 high-speed serial transceivers to provide PCIe (Gen3 x8) communication and 4 SFP+ ports (10Gbps Ethernet).</p><p>For packet generation, we built a custom packet generator that is included as part of the P4FPGA runtime. It generates packets at a user-specified rate. We also provide a utility to program the packet generator with a packet trace supplied in the PCAP format or to configure/control the packet generator from userspace. Similarly, we provide a built-in packet capture tool to collect output packets and various statistics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Case Studies</head><p>To illustrate the broad applicability of P4FPGA, we implemented three representative P4 applications as case studies. We chose these examples because (i) they represent nontrivial, substantial applications, (ii) they illustrate functionality at different layers of the network stack, and (iii) they implement diverse functionality and highlight P4's potential.</p><p>Table <ref type="table" target="#tab_3">1</ref> shows the lines of code in P4 for each of these applications. As a point of comparison, we also report the lines of code for the generated Bluespec code. While lines of code is not an ideal metric, it does help illustrate the benefit of high-level languages like P4, which requires orders-ofmagnitude fewer lines of code. Below, we describe each of these applications in detail.</p><p>L2/L3 Forwarding. P4 was designed around the needs of networking applications that match on packet headers and either forward out a specific port, or drop a packet. Therefore, our first example application performs Layer 2 / Layer 3 forwarding. It uses a switching architecture and routes on the IP destination field. Paxos. Paxos <ref type="bibr" target="#b22">[22]</ref> is one of the most widely used protocols for solving the problem of consensus, i.e., getting a group of participants to reliably agree on some value used for computation. The protocol is the foundation for building many fault-tolerant distributed systems and services. While Paxos is traditionally implemented as an application-level service, recent work demonstrates that significant performance benefits can by achieved by leveraging programmable data planes to move consensus logic in to network devices <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b25">25]</ref>. The P4 implementation <ref type="bibr" target="#b11">[11]</ref> defines a custom header for Paxos messages that is encapsulated inside a UDP packet. The program keeps a bounded history of Paxos packets in registers, and makes stateful routing decisions based on comparing the contents of arriving packets to stored values. Paxos uses the switch architecture with one input and one output port, essentially a bump-in-the-wire.</p><p>Market Data Protocol. Many financial trading strategies critically depend on the ability to react quickly to changing market condition, and to place orders at high speeds and frequencies. Platforms that implement these trading algorithms would therefore benefit by offloading computations into hardware using custom packet headers and processors. As a proof-of-concept for how P4 could be used for financial applications, we implemented a commonly used protocol, the Market Data Protocol (MDP). MDP is used by the Chicago Mercantile Exchange. Essentially, MDP is a L7 load balancer. An MDP P4 implementation is complicated by the fact that the protocol header is variable length. Figure <ref type="figure" target="#fig_5">5</ref> shows the header definitions for a book refresh message. A "book" is an entity that keeps the most recent stock price. A book refresh message has a fixed header mdp t that is common to all MDP protocol messages, as well as a variable length header, refreshBook, with one or more entries refreshBookEntry. A field numEntries in refreshBook dictates how many entries must be extraced by the parser. Our P4 implementation of MDP can address the header variable length and also parse the input packet stream, filter duplicated messages, and extract important packet fields for additional processing.  Processing time and latency. Our evaluation focuses on two metrics: processing time and latency. Table <ref type="table" target="#tab_4">2</ref> shows the processing time for each application on a single FPGA. Note that memory is only access in a shared memory architecture configuration. All latency measurements are taken from a cycle-accurate simulation, which is as precise as measurement on actual FPGA hardware. The numbers are in term of cycles running at 250MHz, where each cycle is 4 nanoseconds. We measured the packet-processing time of each application on small and large packets. Since the L2/L3 application only parses Ethernet and IP headers, parsing only takes 2 cycles, or 8 ns. On the contrary, the MDP application spends more time parsing because it performs variable-length header processing and inspects packet payload for market data. Match and action stages are constant time for each application For example, L2/L3 spends 31 cycles or 124 ns in match and action stage. The time is spent on table look-up, packet field modification and packet propagation through multiple pipeline stages. The amount of time spent in a match and action stage depends on the number of pipeline stages and the complexity of actions performed on a packet. Memory access accounts for time taken to access a shared memory buffer, and therefore is always a constant overhead among all packets. The time required for the deparser, which must reassemble and transmit the packet, is proportional to the packet size. Even though the latency for a single packet may be 65 cycles or longer (e.g. L2L3 with 64 byte packets), a pipeline has a lot of parallelism and a piplined stage may take as much as 10 to 20 cycles for a table access with or without memory.</p><p>We define the pipeline latency as the time from when the first bit of packet enters the P4 pipeline (right after the RX channel in Figure <ref type="figure" target="#fig_4">4</ref>) until the first bit of packet exits the pipeline (right before the TX channel 4). In all three cases, P4FPGA processes packets with low latency. The additional latency in the program generated by P4FPGA in Table <ref type="table" target="#tab_5">3</ref> is caused by serializing and deserializing packets to and from the packet buffer (store-and-forward). To place the latency numbers in context, we report the performance results from Arista 7050QX cut-through switch in Table <ref type="table" target="#tab_5">3</ref>. As we can see, P4FPGA is able to offer latency comparable to commercial off-the-shelf switches.</p><p>Packet processing is heavily pipelined and we can sustain 10Gbit/s line rate at all packet sizes for all our test applications. We note that the shared memory buffer architecture imposes some overhead due to the memory management unit. Specifically, the malloc and free operations do not support pipelining. Currently, the shared memory buffer implementation supports up to 10Mpps, which is less than line rate for packets smaller than 125 bytes. We expect that this performance could be further optimized with additional engineering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Microbenchmarks</head><p>The next part of our evaluation focuses on a set of microbenchmarks that evaluate different aspects of P4FPGA in isolation. We investigate the following questions:</p><p>• How does the runtime perform?</p><p>• How does overall pipeline perform?</p><p>• How much of the FPGA resources are required for the pipeline and runtime?</p><p>We focus on three metrics for evaluation: throughput, latency and resource utilization on the FPGA. We present the details of these microbenchmarks below.</p><p>7.2.1 Fixed-Function Runtime. The target FPGA board consists of 4x 10Gbps ports. As a result, the runtime system must sustain line-rate forwarding at 40Gbps to avoid being a bottleneck to overall system performance. To verify that P4FPGA is able to satisfy this requirement, we measured the raw throughput of the fixed-function runtime with an empty packet processing pipeline (no table, no action in ingress or egress pipeline).</p><p>In this experiment, we used a runtime configured with six input and output ports. Each input port receives traffic from a built-in packet generator at full 10Gbps line rate. The two additional ports in the runtime runtime can be used to send packets to the host CPU through a DMA engine or to recirculate packets from the egress pipeline to the ingress pipeline. However, these operations are out-of-the-scope for this paper. We loaded a packet trace with packet sizes ranging from 64 to 1516 bytes and replayed the packet trace a million times. The fixed function runtime is able to sustain between 53.3Gbps for 64 bytes packets and 59.5Gbps for 1518 bytes packets, which is well above the required 40Gbps throughput requirement.</p><p>7.2.2 Programmable pipeline. We evaluated the performance of a generated P4 pipeline with a set of microbenchmarks that focused on each key language construct in isolation: parsers, tables, and actions. As a point of comparison, we also report results for running the same experiments with the PISCES <ref type="bibr" target="#b33">[36]</ref> software switch. PISCES extends Open vSwitch [29] with a protocol independent design. In all cases, PISCES uses DPDK <ref type="bibr" target="#b15">[15]</ref> to avoid the overhead of the kernel network stack. Note, to make the comparison equal, we used only two ports for PISCES.</p><p>Parser. We used the packet generator to send 256-byte packets with an increasing number of 16-bit custom packet headers. We measured both latency and throughput, and the results are shown in Figures <ref type="figure">6</ref> and<ref type="figure">7</ref>. As expected, we see that parsing latency increases as we increase the number of extracted headers. In terms of absolute latency, P4FPGA is able to leverage the performance of FPGAs to significantly reduce latency. P4FPGA took less than 450 ns to parse 16 headers, whereas PISCES took 6.5us. The results for throughput are similar. For both P4FPGA and PISCES, the parser throughput decreases as the number of headers increases. As expected, P4FPGA significantly outperforms PISCES in terms of absolute throughput as well as the number of headers that parse without performance degradation. In this experiment, we compiled a set of synthetic programs with an increasing number of pipeline stages (1 to 32). We measured the end-to-end latency from the entry of the ingress pipeline to the exit of the egress pipeline. The result is shown in figure <ref type="figure">8</ref>. Although the absolute latency is much better for P4FPGA, the trend shows that the processing latency increases with the number of tables. In contrast, the latency for PISCES remains constant. This is because PISCES implements an optimization that fuses multiple match-action pipeline stages into a single match-action rule. We have not yet implemented this optimization for P4FPGA.</p><p>Action. In this experiment, we evaluate how the action complexity can affect throughput. We vary the number of header field writes from 8 to 64. All field write operations are independent, meaning that they write to different fields in the packet header. Hence, P4FPGA is able to leverage hardware parallelism to perform all write operations within the same clock cycle, as there is no dependency between any operation. Note that this faithfully implements the sequential semantics of the original P4 source program, even though all actions are performed in parallel. As shown in Figure <ref type="figure">9</ref>, the end-to-end packet processing latency in P4FPGA remains the same at 364 ns. This is in contrast to PISCES, which consumes more CPU cycles to process write operations, as the operations are performed in sequence on a CPU target <ref type="bibr" target="#b33">[36]</ref>. In other words, the absolute latency is much higher on a software target, and it also increases with the number of write operations. In contrast, with P4FPGA, the latency remains low and constant independent of the number of writes in a stage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Resource Utilization.</head><p>We report the resource utilization of the FPGA in two parts: the resource consumed by the fixed function runtime which is common to all P4 programs; and the resource consumed by individual P4 constructs which is variable depending on parameters specified by P4 program. We quantify resource consumption with the number and percentage of look-up tables (LUTs) and memory consumed by each block.</p><p>The runtime subsystem implements PCIe host communication, and the MAC and PHY layers of the Ethernet protocol. As shown in Table <ref type="table" target="#tab_6">4</ref>, the total resource consumption of the runtime is about 7.5% of total available LUTs and 2.3% of available memory blocks, which leaves many of the resources available to implement the actual logic of a P4 program. to perform key lookup, and regular memory to corresponding action for a matched key entry. Unlike ASICs, FPGAs lack native support for CAM, and as a result, we had to emulate CAM by implementing it with regular memory blocks. We evaluated three different CAM implementations on the FPGA: binary CAM for implementing exact match, ternary CAM for implementing ternary and longest prefix match, and hash-based CAM for exact match.</p><p>As shown in Table <ref type="table">5</ref>, we can implement up to a 288-bit key binary CAM (BCAM), ternary CAM (TCAM), or a hashbased associative memory with minimum resource utilization. The commercial-grade TCAM implementation is more efficient than our BCAM. We suspect that the difference is due to both implementation efficiency and internal architecture of these two CAM technologies. But, the hash-based associative memory implementation is the most efficient among all three implementations <ref type="bibr" target="#b14">[14]</ref>. If we were to use the whole FPGA for only a CAM with a 288-bit key, then a BCAM, TCAM, and hash-based associative memory can fit up to 6K, 53K, 93K entries on a Virtex-7 FPGA, respectively. To put these numbers into context, a Mellanox Spectrum ASIC allows 9K entries of 288 bit rules in a common TCAM table shared between ingress and egress pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED WORK</head><p>We briefly survey related work on P4 compilers, use of FPGAs in networking, and FPGA synthesis.</p><p>P4 Compilers. Given the significant interest in P4 as a development platform, there are several efforts underway to implement P4 compilers and tools. Our microbenchmarks compare against PISCES <ref type="bibr" target="#b33">[36]</ref>, which is a software hypervisor switch that extends Open vSwitch [29] with a protocolindependent design. The Open-NFP <ref type="bibr" target="#b27">[28]</ref> organization provides a set of tools for developing network function processing logic, including a P4 compiler that targets 10, 40 and 100GbE Intelligent Server Adapters (ISAs) manufactured by Netronome. These devices are network processing units (NPUs), while P4FPGA targets FPGAs. The Open-NFP compiler currently does not support register related operations and cannot parse header fields larger than 32 bits. Users implement actions in MicroC code external to the P4 program. P4c [33] is a retargetable compiler for the P4 language which generates high performance network switch code in C, linking against DPDK <ref type="bibr" target="#b15">[15]</ref> libraries. DPDK provides a set of user-space libraries, which bypass the Linux kernel. P4c does not yet support P4 applications that require register uses to store state. P4.org provides a reference compiler <ref type="bibr" target="#b31">[34]</ref> that generates a software target, and can be executed in a simulated environment (i.e., Mininet [26] and P4 Behavioral Model switch <ref type="bibr" target="#b29">[32]</ref>). P4FPGA shares the same compiler front-end, but provides a different back-end.</p><p>A P4 compiler backend targeting a programmable ASIC <ref type="bibr" target="#b20">[20]</ref> must deal with resource constraints. The major challenge arises from mapping logical lookup tables to physical tables on an ASIC. In contrast, FPGAs can directly map logical tables into the physical substrate without the complexity of logical-to-physical table mapping, thanks to the flexible and programmable nature of FPGAs.</p><p>Perhaps the most closely related effort is Xilinx's SD-Net <ref type="bibr" target="#b36">[39]</ref>. SDNet compiles programs from the high-level PX <ref type="bibr" target="#b8">[8]</ref> language to a data plane implementation on a Xilinx FPGA target, at selectable line rates from 1G to 100G. A Xilinx Labs prototype P4 compiler works by translating from P4 to PX, and then using SDNet to map this PX to a target FPGA. As the compiler implementation is not yet publicly available, we cannot comment on how the design or architecture compares to P4FPGA.</p><p>FPGAs for networking. The NetFPGA project <ref type="bibr" target="#b37">[40]</ref> is another open-source framework that researchers frequently use to prototype networking ideas. P4FPGA shares the same vision with NetFPGA to provide an open framework for network researchers. Furthermore, P4FPGA can support not only NetFPGA-specific hardware platforms, but also many other existing FPGA platforms on the market.</p><p>A unified software-hardware co-design framework simplifies the FPGA development process <ref type="bibr" target="#b21">[21]</ref>. P4FPGA leveraged the idea of generating SW/HW interfaces from a interface definition file from Connectal <ref type="bibr" target="#b21">[21]</ref>, which has greatly simplified the generation of a control-plane interface for P4 prototyping on FPGAs.</p><p>High-level Synthesis. FPGAs are typically programmed using hardware description languages such as Verilog. Many developers find working with these languages challenging, as they expose low-level hardware details to the programmer. Consequently, there has been significant research in highlevel synthesis and programming language support for FP-GAs. Some well-known examples include CASH <ref type="bibr" target="#b9">[9]</ref>, which compiles C to FPGAs; Kiwi <ref type="bibr" target="#b34">[37]</ref>, which transforms .NET</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>FPGAs offer performance that far exceeds software running on general purpose CPUs, while offering a degree of flexibility that would be difficult to achieve on other targets, such as ASICs. At the same time, they are also notoriously difficult to program. P4FPGA lowers the barrier to entry, giving programmers a programmable substrate for creating innovative new protocols and applications.</p><p>P4FPGA provides a P4-to-FPGA compiler and runtime that is flexible, portable, and efficient. It supports multiple architectures, generates code that runs on Xilinx or Altera FPGAs and runs at line-rate with latencies comparable to commercial ASICs. P4FPGA is open source and publicly available for use. Indeed, it has already been used by two research projects to evaluate P4 programs on hardware. We hope that this research will help other users in real environments or to support systems and networking research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">AVAILABILITY</head><p>P4FPGA is publicly available under an open-source license. All source code, as well as example P4 source programs and their generated Bluespec counterparts are available at http://p4fpga.org. Furthermore, benchmarks are available via the P4 Whippersnapper Benchmark Suite <ref type="bibr" target="#b13">[13]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example P4 Abstract Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Subset of a P4 14 program to count UDP packets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: P4FPGA Framework Overview.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: P4FPGA Runtime and Pipeline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Header definitions for MDP.p4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Figure 6: Parser latency v.s. number of headers parsed</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: Processing latency v.s. number of tables</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>program. It checks if the arriving packet is an Ethernet packet, then if it is an IPv4 packet, and finally if it is a UDP packet. If so, it passes the packet to the table count table, defined on Line 23. The table count table reads the destination port, and performs one of two possible actions: count c1 or drop a packet. The action count c1 on Line 20 invokes a count function. The count function must be defined externally to the P4 program.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>1</head><label></label><figDesc>// We have elided eth and ipv4 headers, 2 // and the extern declarations for brevity</figDesc><table><row><cell>3</cell><cell></cell></row><row><cell cols="2">4 header_type udp_t {</cell></row><row><cell>5</cell><cell>fields {</cell></row><row><cell>6</cell><cell>srcPort : 16;</cell></row><row><cell>7</cell><cell>dstPort : 16;</cell></row><row><cell>8</cell><cell>length : 16;</cell></row><row><cell>9</cell><cell>checksum : 16;</cell></row><row><cell>10 }}</cell><cell></cell></row><row><cell cols="2">11 header udp_t udp;</cell></row><row><cell cols="2">12 parser parse_udp {</cell></row><row><cell>13</cell><cell>extract(udp);</cell></row><row><cell>14</cell><cell>return ingress;</cell></row><row><cell>15 }</cell><cell></cell></row><row><cell cols="2">16 counter c1 {</cell></row><row><cell>17</cell><cell>type: packet;</cell></row><row><cell>18</cell><cell>numPackets : 32;</cell></row><row><cell>19 }</cell><cell></cell></row><row><cell cols="2">20 action count_c1() {</cell></row><row><cell>21</cell><cell>count(c1, 1);</cell></row><row><cell>22 }</cell><cell></cell></row><row><cell cols="2">23 table table_count {</cell></row><row><cell>25</cell><cell>actions { count_c1; _drop; } }</cell></row><row><cell cols="2">26 control ingress {</cell></row><row><cell>27</cell><cell>if (valid(eth)) {</cell></row><row><cell>28</cell><cell>if (valid(ipv4)) {</cell></row><row><cell>29</cell><cell>if (valid(udp)) {</cell></row><row><cell>30</cell><cell>apply(table_count);</cell></row><row><cell cols="2">31 }}}}</cell></row></table><note><p><p>24</p>reads { udp.dstPort : exact; }</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Example applications compiled by P4FPGA and lines of code (LoC) in P4 and Bluespec. The framework includes P4FPGA runtime and control plane support.</figDesc><table><row><cell>Name</cell><cell>Description</cell><cell cols="3">LoC in P4 LoC in Bluespec Framework</cell></row><row><cell>l2l3.p4</cell><cell>L2/L3 router</cell><cell>170</cell><cell>1281</cell><cell>33295</cell></row><row><cell>mdp.p4</cell><cell cols="2">variable packet length, financial trading protocol 205</cell><cell>1812</cell><cell>33295</cell></row><row><cell cols="2">paxos.p4 stateful processing, consensus protocol</cell><cell>385</cell><cell>3306</cell><cell>33295</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Latency breakdown, cycles @ 250MHz. Note that memory is only accessed in the shared memory configuration.</figDesc><table><row><cell>App</cell><cell cols="5">Size Parser Table Memory Deparser</cell></row><row><cell></cell><cell>64</cell><cell>2</cell><cell>31</cell><cell>21</cell><cell>11</cell></row><row><cell>l2l3</cell><cell cols="2">256 2 512 2</cell><cell>31 31</cell><cell>23 24</cell><cell>32 66</cell></row><row><cell></cell><cell cols="2">1024 2</cell><cell>31</cell><cell>23</cell><cell>130</cell></row><row><cell></cell><cell cols="2">256 15</cell><cell>9</cell><cell>23</cell><cell>34</cell></row><row><cell>mdp</cell><cell cols="2">512 35</cell><cell>9</cell><cell>24</cell><cell>68</cell></row><row><cell></cell><cell cols="2">1024 88</cell><cell>9</cell><cell>23</cell><cell>130</cell></row><row><cell cols="3">paxos 144 6</cell><cell>42</cell><cell>21</cell><cell>12</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Latency comparing to vendors.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>The latency of</cell></row><row><cell cols="4">cut-through switch (Arista 7050QX) is from [4]</cell></row><row><cell>Mode</cell><cell></cell><cell cols="2">Packet Size</cell></row><row><cell></cell><cell>64</cell><cell>256</cell><cell>1024 1518</cell></row><row><cell>Arista 7050QX</cell><cell cols="3">550ns 550ns 550ns 550ns</cell></row><row><cell cols="4">P4FPGA (L2/L3) 340ns 420ns 810ns 1050ns</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Area and frequency of fixed function runtime</figDesc><table><row><cell></cell><cell>Slice LUTs</cell><cell cols="2">Block RAMs MHz</cell></row><row><cell>PCIe</cell><cell>6377</cell><cell>9</cell><cell>250</cell></row><row><cell cols="2">10G MAC x4 8174</cell><cell>0</cell><cell>156</cell></row><row><cell cols="2">10G PHY x4 10422</cell><cell>0</cell><cell>644.5</cell></row><row><cell>Connectal</cell><cell>7867</cell><cell>25</cell><cell>250</cell></row><row><cell>Area Used</cell><cell cols="2">32700 (7.5%) 34 (2.3%)</cell><cell>-</cell></row><row><cell cols="4">Next, we profile resource consumption of major P4 con-</cell></row><row><cell cols="4">structs: match table, parser, deparser and action. Match tables</cell></row><row><cell cols="4">are implemented with content-addressable memory (CAM)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.p4fpga.org</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This research is partially supported by Swiss NSF (166132 and 159537), European Union's Horizon 2020 research and innovation programme under the SSICLOPS project (agreement No. 644866), DARPA CSSG (D11AP00266), NSF (1053757, 1440744, and 1422544), and with gifts from Cisco, Xilinx, Altera and Bluespec. We thank Jamey Hicks and John Ankcorn for their help with Connectal, Nagase for providing the TCAM IP core, our shepherd Luigi Rizzo, and the SOSR reviewers for helpful comments.</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The implementation of the parser basic block includes code that is common to all parser instances and generated code that is customized for each specific parser. The common code includes state variables (e.g., header buffer, parse state, and offset), and a circuit that manages incoming bytes. The generated portion of a parser implements the applicationspecific FSM.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">which performs synthesis from MATLAB code. P4FPGA notably relies on Bluespec [27] as a target language, and re-uses the associated compiler and libraries to provide platform independence. As already mentioned, P4FPGA uses Connectal [21] libraries</title>
	</analytic>
	<monogr>
		<title level="m">progrrams into FPGA circuits; and Xilinx&apos;s AccelDSP</title>
		<imprint/>
	</monogr>
	<note>which are also written in Bluespec, for common hardware features. REFERENCES</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Modular SRAM-Based Binary Content-Addressable Memories</title>
		<author>
			<persName><forename type="first">A</forename><surname>Abdelhadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lemieux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 23rd Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM)</title>
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<ptr target="http://www.xilinx.com/tools/acceldsp.htm" />
	</analytic>
	<monogr>
		<title level="j">AccelDSP Synthesis Tool</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m">Algorithms in Logic. www.algo-logic.com</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="https://solutions.arista.com/hubfs/Arista/Datasheets/Arista7050XSwitchArchitectureV0.512.pdf" />
		<title level="m">Arista 7050X Switch Architecture</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Axonerve Low Latency Matching Engine Synthesizable IP Core</title>
		<author>
			<persName><surname>Axonerve</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Programming Protocol-Independent Packet Processors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Talayco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGCOMM Computer Communication Review (CCR)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="87" to="95" />
			<date type="published" when="2014-07">July 2014</date>
		</imprint>
	</monogr>
	<note>P</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mujica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-COMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication (SIGCOMM)</title>
		<imprint>
			<date type="published" when="2013-08">Aug. 2013</date>
			<biblScope unit="page" from="99" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">High-Speed Packet Processing using Reconfigurable Computing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brebner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="2014-01">Jan. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Spatial computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chelcea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Goldstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Corsa DP6420 OpenFlow data plane</title>
		<author>
			<persName><surname>Corsa</surname></persName>
		</author>
		<ptr target="http://www.corsa.com/products/dp6420" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Soulé</surname></persName>
		</author>
		<title level="m">Paxos Made Switch-y. SIGCOMM Computer Communication Review (CCR)</title>
		<imprint>
			<date type="published" when="2016-04">Apr. 2016</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="87" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">NetPaxos: Consensus at Network Speed</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sciascia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Soulé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM SOSR</title>
		<imprint>
			<date type="published" when="2015-06">June 2015</date>
			<biblScope unit="page" from="59" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Whippersnapper: A P4 Language Benchmark Suite</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jepsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brebner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Soul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Weatherspoon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM SOSR</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Area-Efficient Near-Associative Memories on FPGAs</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dhawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dehon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Reconfigurable Technology System</title>
		<imprint>
			<date type="published" when="2015-01">Jan. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><surname>Dpdk</surname></persName>
		</author>
		<ptr target="http://dpdk.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Exalink Fusion</title>
		<author>
			<persName><surname>Exablaze</surname></persName>
		</author>
		<ptr target="https://exablaze.com/exalink-fusion" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Blueswitch: Enabling Provably Consistent Configuration of Network Switches</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mundkur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rotsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antichi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh ACM/IEEE Symposium on Architectures for Networking and Communications Systems</title>
		<meeting>the Eleventh ACM/IEEE Symposium on Architectures for Networking and Communications Systems</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Jepsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>De Sousa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Soulé</surname></persName>
		</author>
		<idno>CoRR, abs/1610.07459</idno>
		<title level="m">Optimistic aborts for geo-distributed transactions</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Z J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><surname>Lbswitch</surname></persName>
		</author>
		<ptr target="http://p4.org/p4-workshop-2016/" />
		<title level="m">Switch is Your Server Load-Balancer</title>
		<imprint>
			<date type="published" when="2016-05">May 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Compiling Packet Programs to Reconfigurable Switches</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Networked Systems Design and Implementation. USENIX Association</title>
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Software-Driven Hardware Development</title>
		<author>
			<persName><forename type="first">M</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ankcorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays</title>
		<meeting>the 2015 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Part-Time Parliament</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998-05">May 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Data-plane probe for in-band telemetry collection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lapukhov</surname></persName>
		</author>
		<ptr target="https://tools.ietf.org/html/draft-lapukhov-dataplane-probe-00" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Clicknp: Highly flexible and high performance network processing with reconfigurable hardware</title>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication (SIGCOMM)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Just Say NO to Paxos Overhead: Replacing Consensus with Network Ordering</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R K</forename><surname>Ports</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016-11">Nov. 2016</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Nikhil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Czeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BSV by Example. CreateSpace</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Open-Nfp</forename></persName>
		</author>
		<ptr target="http://open-nfp.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><surname>P4</surname></persName>
		</author>
		<ptr target="https://github.com/p4lang/p4c-bm" />
		<title level="m">P4 Behavioral Model</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<ptr target="https://github.com/p4lang" />
		<title level="m">P4 Behavioral Model</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">@</forename><surname>Elte</surname></persName>
		</author>
		<ptr target="http://p4.elte.hu/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><surname>P4</surname></persName>
		</author>
		<author>
			<persName><surname>Org</surname></persName>
		</author>
		<ptr target="http://p4.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A Reconfigurable Fabric for Accelerating Large-Scale Datacenter Services</title>
		<author>
			<persName><forename type="first">A</forename><surname>Putnam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Caulfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chiou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 41st Annual International Symposium on Computer Architecuture (ISCA)</title>
		<meeting>eeding of the 41st Annual International Symposium on Computer Architecuture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2014-06">June 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">PISCES: A Programmable, Protocol-Independent Software Switch</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication (SIGCOMM)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Kiwi: Synthesis of fpga circuits from parallel programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Greaves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 16th International Symposium on Field-Programmable Custom Computing Machines (FCCM)</title>
		<meeting>the 2008 16th International Symposium on Field-Programmable Custom Computing Machines (FCCM)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Tofigh</surname></persName>
		</author>
		<ptr target="http://p4.org/p4-workshop-2016/" />
		<title level="m">Dynamic Analytics for Programmable NICs Utilizing P4</title>
		<imprint>
			<date type="published" when="2016-05">May 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><surname>Xilinx</surname></persName>
		</author>
		<author>
			<persName><surname>Sdnet</surname></persName>
		</author>
		<ptr target="http://www.xilinx.com/products/design-tools/software-zone/sdnet.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Zilberman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Audzevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Covington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<title level="m">NetFPGA SUME: Toward 100 Gbps as Research Commodity</title>
		<imprint>
			<publisher>IEEE Micro</publisher>
			<date type="published" when="2014-09">Sept. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
