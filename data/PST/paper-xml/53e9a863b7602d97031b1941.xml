<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Detection of Scanning Worm Infections</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stuart</forename><forename type="middle">E</forename><surname>Schechter</surname></persName>
							<email>stuart@eecs.harvard.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Harvard DEAS</orgName>
								<address>
									<addrLine>33 Oxford Street</addrLine>
									<postCode>02138</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jaeyeon</forename><surname>Jung</surname></persName>
							<email>jyjung@csail.mit.edu</email>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<address>
									<addrLine>32 Vassar Street</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arthur</forename><forename type="middle">W</forename><surname>Berger</surname></persName>
							<email>awberger@csail.mit.edu</email>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<address>
									<addrLine>32 Vassar Street</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fast Detection of Scanning Worm Infections</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">89DF92BC54983E8F40C5C9D7FC9450DA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Worm detection and response systems must act quickly to identify and quarantine scanning worms, as when left unchecked such worms have been able to infect the majority of vulnerable hosts on the Internet in a matter of minutes <ref type="bibr" target="#b8">[9]</ref>. We present a hybrid approach to detecting scanning worms that integrates significant improvements we have made to two existing techniques: sequential hypothesis testing and connection rate limiting. Our results show that this two-pronged approach successfully restricts the number of scans that a worm can complete, is highly effective, and has a low false alarm rate.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Human reaction times are inadequate for detecting and responding to fast scanning worms, such as Slammer, which can infect the majority of vulnerable systems in a matter of minutes <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b8">9]</ref>. Thus, today's worm response proposals focus on automated responses to worms, such as quarantining infected machines <ref type="bibr" target="#b9">[10]</ref>, automatic generation and installation of patches <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>, and reducing the rate at which worms can issue connection requests so that a more carefully constructed response can be crafted <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>Even an automated response will be of little use if it fails to be triggered quickly after a host is infected. Infected hosts with high-bandwidth network connections can initiate thousands of connection requests per second, each of which has the potential to spread the infection. On the other hand, an automated response that triggers too easily will erroneously identify hosts as infected, interfering with these hosts' reliable performance and causing significant damage.</p><p>Many scan detection mechanisms rely upon the observation that only a small fraction of addresses are likely to respond to a connection request at any given port. Many IPv4 addresses are dead ends as they are not assigned to active hosts. Others are assigned to hosts behind firewalls that block the port addressed by the scanner. When connection requests do reach active hosts, many will be rejected as not all hosts will be running the targeted service. Thus, scanners are likely to have a low rate of successful connections, whereas benign hosts, which only issue connection requests when there is reason to believe that addressees will respond, will have a much greater rate of success.</p><p>Existing methods for detecting scanning worms within a local network use fixed thresholds for the number of allowable failed connections over a time period <ref type="bibr" target="#b15">[16]</ref> or limit the rate at which a host can initiate contact with additional hosts <ref type="bibr" target="#b26">[27]</ref>. However, these threshold based approaches may fail to detect low-rate scanning. They may also require an excessive number of connection observations to detect an infection or lead to an unnecessary number of false alarms.</p><p>To detect inbound scans initiated by hosts outside the local network, previous work on which we collaborated <ref type="bibr" target="#b6">[7]</ref> used an approach based on sequential hypothesis testing. This approach automatically adjusts the number of observations required to detect a scan with the strength of the evidence supporting the hypothesis that the observed host is, in fact, scanning. The advantage of this approach is that it can reduce the number of connection requests that must be observed to detect that a remote host is scanning while maintaining an acceptable false alarm rate.</p><p>While this approach shows promise for quickly detecting scanning by hosts inside a local network soon after they have been infected by a worm, there are significant hurdles to overcome. For one, to determine whether a request to connect to a remote host will fail, one must often wait to see whether a successful connection response will be returned. Until enough connection requests can be established to be failures, a sequential hypothesis test will lack the observations required to conclude that the system is infected. By the time the decision to quarantine the host is made, a worm with a high scan rate may have already targeted thousands of other hosts.</p><p>This earlier work used a single sequential hypothesis test per host and did not re-evaluate benign hosts over time. Unlike an intrusion detection system observing remote hosts, a worm detection system is likely to observe benign traffic originating from an infected host before it is infected. It is therefore necessary to adapt this method to continuously monitor hosts for indications of scanning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>WDS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. A Worm Detection System (WDS) is located to monitor a local network</head><p>We introduce an innovative approach that enables a Worm Detection System (WDS) to continuously monitor a set of local hosts for infection, requiring a small number of observations to be collected after an infection to detect that the host is scanning (Figure <ref type="figure">1</ref>).</p><p>To detect infected hosts, the WDS need only process a small fraction of network events; a subset of connection request observations that we call firstcontact connection requests and the responses to these requests that complete the connections. A first-contact connection request is a packet (TCP or UDP) addressed to a host with which the sender has not previously communicated. These events are monitored because scans are mostly composed of first-contact connection requests.</p><p>In Section 2, we introduce a scan detection algorithm that we call a reverse sequential hypothesis test ( ← --HT ), and show how it can reduce the number of firstcontact connections that must be observed to detect scanning<ref type="foot" target="#foot_0">3</ref> . Unlike previous methods, the number of observations ← --HT requires to detect hosts' scanning behavior is not affected by the presence of benign network activity that may be observed before scanning begins.</p><p>In Section 3, we introduce a new credit-based algorithm for limiting the rate at which a host may issue the first-contact connections that are indicative of scanning activity. This credit-based connection rate limiting (CBCRL) algorithm results in significantly fewer false positives (unnecessary rate limiting) than existing approaches.</p><p>When combined, this two-pronged approach is effective because these two algorithms are complementary. Without credit-based connection rate limiting, a worm could rapidly issue thousands of connection requests before enough connection failures have been observed by Reverse Sequential Hypothesis Testing so that it can report the worm's presence. Because Reverse Sequential Hypothesis Testing processes connection success and failure events in the order that connection requests are issued, false alarms are less likely to occur than if we used an approach purely based on credit-based connection rate limiting, for which first-contact connections attempts are assumed to fail until the evidence proves otherwise.</p><p>We demonstrate the utility of these combined algorithms with trace-driven simulations, described in Section 4, with results presented in Section 5. The limitations of our approach, including strategies that worms could attempt to avoid detection, are presented in Section 6. We discuss related work, including previous approaches to the scanning worm detection problem, in Section 7. Our plans for future work are presented in Section 8, and we conclude in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Detecting Scanning Worms by Using Reverse Sequential Hypothesis Testing</head><p>A worm is a form of malware that spreads from host to host without human intervention. A scanning worm locates vulnerable hosts by generating a list of addresses to probe and then contacting them. This address list may be generated sequentially or pseudo-randomly. Local addresses are often preferentially selected <ref type="bibr" target="#b24">[25]</ref> as communication between neighboring hosts will likely encounter fewer defenses. Scans may take the form of TCP connection requests (SYN packets) or UDP packets. In the case of the connectionless UDP protocol, it is possible for the scanning packet to also contain the body of the worm as was the case with the Slammer worm <ref type="bibr" target="#b8">[9]</ref>.</p><p>In this section, we present an on-line algorithm for detecting the presence of scanners within a local network by observing network traffic. We use a sequential hypothesis test for its ability to adjust the number of observations required to make a decision to match the strength of the evidence it is presented with.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sequential Hypothesis Testing</head><p>As with existing approaches to scan detection <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b26">27]</ref>, we rely upon the observation that only a small fraction of addresses are likely to respond to a connection request at any given port. Benign hosts, which only contact systems when they have reason to believe that this connection request will be accepted, are more likely to receive a response to a connection request.</p><p>Recall that a first-contact connection request is a packet (TCP or UDP) addressed to a host with which the sender has not previously communicated. When a local host l initiates a first-contact connection request to a destination address, d, we classify the outcome as either a "success" or a "failure". If the request was a TCP SYN packet, the connection is said to succeed if a SYN-ACK is received from d before a timeout expires. If the request is a UDP packet, any UDP packet from d received before the timeout will do. We let Y i be a random (indicator) variable that represents the outcome of the i th first-contact connection request by l, where</p><formula xml:id="formula_0">Y i = 0 if the connection succeeds 1 if the connection fails</formula><p>Detecting scanning by local hosts is a problem that is well suited for the method of sequential hypothesis testing first developed by Wald <ref type="bibr" target="#b23">[24]</ref>, and used in our earlier work to detect remote scanners <ref type="bibr" target="#b6">[7]</ref>.</p><p>We call H 1 the hypothesis that host l is engaged in scanning (indicating infection by a worm) and H 0 the null hypothesis that the host is not scanning. We assume that, conditional on the hypothesis H j , the random variables Y i |H j i = 1, 2, . . . are independent and identically distributed (i.i.d.). That is, conditional on the hypothesis, any two connection attempts will have the same likelihood of succeeding, and their chances of success are unrelated to each other. We can express the distribution of the Bernoulli random variable Y i as:</p><formula xml:id="formula_1">Pr[Y i = 0|H 0 ] = θ 0 , Pr[Y i = 1|H 0 ] = 1 -θ 0 Pr[Y i = 0|H 1 ] = θ 1 , Pr[Y i = 1|H 1 ] = 1 -θ 1</formula><p>Given that connections originating at benign hosts are more likely to succeed than those initiated by a scanner, θ 0 &gt; θ 1 .</p><p>Sequential hypothesis testing chooses between two hypotheses by comparing the likelihoods that the model would generate the observed sequence of events, Y n ≡ (Y 1 , . . . , Y n ), under each hypothesis. It does this by maintaining the ratio Λ(Y n ), the numerator of which is the likelihood that the model would generate the sequence of events Y n under hypothesis H 1 , and the denominator under hypothesis H 0 .</p><formula xml:id="formula_2">Λ(Y n ) ≡ Pr[Y n |H 1 ] Pr[Y n |H 0 ]<label>(1)</label></formula><p>The i.i.d. assumption in the model enables us to state this ratio in terms of the likelihoods of the individual events.</p><formula xml:id="formula_3">Λ(Y n ) ≡ n i=1 Pr[Y i |H 1 ] Pr[Y i |H 0 ]<label>(2)</label></formula><p>We can write the change to Λ(Y n ) as a result of the i th observation as φ(Y i ):</p><formula xml:id="formula_4">φ(Y i ) ≡ Pr[Y i |H 1 ] Pr[Y i |H 0 ] =    θ1 θ0 if Y i = 0 (success) 1-θ1 1-θ 0 if Y i = 1 (failure) This enables us to rewrite Λ(Y n ) inductively, such that Λ(Y 0 ) = 1,</formula><p>and Λ(Y n ) may be calculated iteratively as each observation arrives.</p><formula xml:id="formula_5">Λ(Y n ) = n i=1 φ(Y i ) = Λ(Y n-1 )φ(Y n )</formula><p>One compares the likelihood ratio Λ(Y n ) to an upper threshold, η 1 , above which we accept hypothesis H 1 , and a lower threshold, η 0 , below which we accept hypothesis H 0 . If η 0 &lt; Λ(Y n ) &lt; η 1 then the result will remain inconclusive until more events in the sequence can be evaluated. This is illustrated in Figure <ref type="figure" target="#fig_0">2</ref>. Writing the probability of correctly reporting detection (declaring host is infected when indeed it is) as P D and the probability of a false positive (declaring host is infected when in fact it is not) as P F , we can define our performance requirements as bounds α and β on these probabilities. α ≥ P F and β ≤ P D Because every false positive can decrease productivity of both the users of a host and the security staff who need to inspect it, one would expect to use α values that are small fractions of a percentage point. Since scanners generate enough traffic to clearly differentiate their behavior from that of benign systems, a β of greater than 0.99 should be an achievable requirement.</p><formula xml:id="formula_6">Y 2 Y 4 Y 3 Y 5 Y 1 η 1 η 0 1 0 1 0 1 0</formula><p>Wald <ref type="bibr" target="#b23">[24]</ref> showed that η 1 and η 0 can be bounded in terms of P D and P F .</p><formula xml:id="formula_7">η 1 ≤ P D P F (3) 1 -P D 1 -P F ≤ η 0<label>(4)</label></formula><p>Given our requirement parameters α and β, we assign the following values to our thresholds, η 0 and η 1 :</p><formula xml:id="formula_8">η 1 ← β α (<label>5</label></formula><formula xml:id="formula_9">)</formula><formula xml:id="formula_10">η 0 ← 1 -β 1 -α (6)</formula><p>From Equations (3) and (5), we can bound P F in terms of α and β. Since 0 &lt; P D &lt; 1, we can replace P D with 1 in Equation (3) to yield:</p><formula xml:id="formula_11">η 1 ≤ P D P F &lt; 1 P F (7)</formula><p>It follows that:</p><formula xml:id="formula_12">P F &lt; 1 η 1 = α β (8)</formula><p>Likewise, using Equation ( <ref type="formula" target="#formula_7">4</ref>) and given that 1 -P D &lt; (1 -P D )/(1 -P F ), we can bound 1 -P D :</p><formula xml:id="formula_13">1 -P D &lt; η 0 = 1 -β 1 -α (9)</formula><p>While η 1 may result in a false positive rate above our desired bound by a factor of 1 β , this difference is negligible given our use of β values in the range of 0.99 and above. Similarly, while our miss rate, 1 -P D may be off by as much as a factor of 1  1-α , this too will have negligible effect given our requirements for very small values of α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Detecting Infection Events</head><p>In our earlier work, it was assumed that each remote host was either a scanner or benign for the duration of the observed period. When a host was determined to be benign it would no longer be observed. In contrast, in this paper we are concerned with detecting infection events, in which a local host transitions from a benign state to an infected state. Should a host become infected while a hypothesis test is already running, the set of outcomes observed by the sequential hypothesis test may include those from both the benign and infected states, as shown in Figure <ref type="figure">3</ref>. Even if we continue to observe the host and start a new hypothesis test each time a benign conclusion is reached, the test may take longer than necessary to conclude that an infection has occurred.</p><formula xml:id="formula_14">Y i Y i+1 Y i+4 Y i+5 Y i+6 Y i+7 Y i+3 Y i+2 Y i-1 i-2 Y 1 0 η η 1 0 0 infection 1 1 1 1 1 1 0 1</formula><p>Fig. <ref type="figure">3</ref>. A log scale graph tracing the value of Λ(Y) as it is updated for a series of observations that includes first-contact connection requests before (Y i-1 and Y i-2 ) and after (Y i and beyond) the host was infected</p><p>The solution to this problem is to run a new sequential hypothesis test as each connection outcome is observed, evaluating these outcomes in reverse chronological order, as illustrated in Figure <ref type="figure" target="#fig_1">4</ref>. To detect a host that was infected before it issued first-contact connection i (event Y i ), but after it had issued first-contact connection i -1, a reverse sequential hypothesis test ( ← --HT ) would require the same number of observations to detect the infection as would a forward sequential hypothesis that had started observing the sequence at observation i. Because the most recent observations are processed first, the reverse test will terminate before reaching the observations that were collected before infection. When we used sequential hypothesis testing in our prior work to detect scanning of a local network by remote hosts, the intrusion detection system could know a priori whether a connection would fail given its knowledge of the network topology and services <ref type="bibr" target="#b6">[7]</ref>. Thus, the outcome of a connection request from host i could immediately be classified as a success or failure observation (Y i ) and Λ(Y n ) could be evaluated without delay.</p><formula xml:id="formula_15">Y i-1 i-2 Y Y i+5 Y i+4 Y i+3 Y i+2 Y i+1 Y i η 1 1 0 η infection 1 0 0 1 1 1 0 1</formula><p>When a local host initiates first-contact connection requests to remote hosts, such as those shown in Figure <ref type="figure" target="#fig_2">5</ref>, the worm detection system cannot immediately determine if the connection will succeed or fail. While some connection failures will result in a TCP RST packet or an ICMP packet <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, empirical evidence has shown that most do not <ref type="bibr" target="#b1">[2]</ref>. The remaining connection attempts can be classified as failures only after a timeout expires. While a sequential hypothesis test waits for unsuccessful connections to time out, a worm may send thousands of additional connection requests with which to infect other systems. To limit the number of outgoing first-contact connections, a sequential hypothesis testing approach can be paired with a credit-based connection rate limiter as described in Section 3.</p><formula xml:id="formula_16">r 2 src: Y 1 = 1 Y 5 = 1 Y 4 = 1 Y 3 = 1 Y 2 = 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Algorithmic Implementation</head><p>A naïve implementation of repeated reverse sequential hypothesis testing requires that we store an arbitrarily large sequence of first-contact connection observations. A naïve implementation must also step through a portion of this sequence each time a new observation is received in order to run a new test starting at that observation.</p><p>Fortunately, there exists an iterative function:</p><formula xml:id="formula_17">Λ(Y n ) = max 1, Λ(Y n-1 )φ(Y n )</formula><p>with state variable Λ(Y n ), that can be calculated in the sequence in which events are observed, and that has the property that its value will exceed η 1 if and only if a reverse sequential hypothesis test would conclude from this sequence that the host was infected. This is proved in Appendix A.</p><p>Updating Λ for each observation requires only a single multiplication and two comparison operations <ref type="foot" target="#foot_1">4</ref> . Because Λ is updated in sequence, observations can be discarded immediately after they are used to update the value of Λ.</p><p>When running this algorithm in a worm detection system, we must maintain separate state information for each host being monitored. Thus, a state variable Λl is maintained for each local host l.</p><p>It is also necessary to track which hosts have been previously contacted by l. We track the set of Previously Contacted Hosts, or PCH set, for each local host.  Finally, each local host l has an associated queue of the first-contact connection attempts that l has issued but that have not yet been processed as observations. The structure of the records that are pushed on this FCC queue are shown in Figure <ref type="figure" target="#fig_3">6</ref>. The choice of a queue for this data structure ensures that first-contact connection attempts are processed in the order in which they are issued, not in the order in which their status is determined.</p><p>The algorithm itself is quite simple and is triggered upon one of three events. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">When an incoming packet arrives addressed to local host l and the source</head><p>address is also the destination address (DestAddr) of a record in l's FCC queue, the packet is interpreted as a response to the first-contact connection request and the status of the FCC record is updated. The status of the FCC record is set to SUCCESS unless the packet is a TCP RST packet, which indicates a rejected connection. 3. Whenever the entry on the front of the FCC queue has status PENDING and has been in the queue longer than the connection timeout period, a timeout occurs and the entry is assigned the status of FAILURE.</p><p>When any of the above events causes the entry at the front of the FCC queue to have status other than PENDING, it is dequeued and Λl is updated and compared to η 1 . If Λl ≥ η 1 , we halt testing for host l and immediately conclude that l is infected. Dequeuing continues so long as Λl &lt; η 1 , the front entry of the FCC queue has status other than PENDING, and the queue is not empty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Slowing Worm Propagation by Using Credit-Based</head><p>Connection Rate Limiting</p><p>It is necessary to limit the rate at which first-contact connections can be initiated in order to ensure that worms cannot propagate rapidly between the moment scanning begins and the time at which the scan's first-contact connections have timed out and been observed by our reverse sequential hypothesis test ( ← --HT ). Twycross and Williamson <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b21">22]</ref> use a technique they call a virus throttle to limit outgoing first-contact connections. When observing a given host, their algorithm maintains a working set of up to five hosts previously contacted by the host they are observing. For the purpose of their work, a first-contact connection is a connection to a host not in this working set. First-contact connections issued when the working set is full are not sent out, but instead added to a queue. Once per second the least recently used entry in the working set is removed and, if the pending queue of first-contact connection requests is not empty, a request is pulled off the queue, delivered, and its destination address is added to the working set. All requests in the queue with the same destination address are also removed from the queue and delivered.</p><p>Virus throttling is likely to interfere with HTTP connection requests for inlined images, as many Web pages contain ten or more inlined images each of which is located on a distinct peering server. While a slow but bursty stream of requests from a Web browser will eventually be released by the throttle, mail servers, Web crawlers, and other legitimate services that issue first-contact connections at a rate greater than once per second will overflow the queue. In this case, the virus throttling algorithm quarantines the host and allows no further first-contact connections.</p><p>To achieve rate limiting with a better false positive rate we once again present a solution inspired by sequential hypothesis testing and that relies on the observation that benign first-contact connections are likely to succeed whereas those issued by scanners are likely to fail. This credit-based approach, however, is unlike ← --HT in that it assumes that a connection will fail until evidence proves otherwise. Because it does not wait for a timeouts to act, it can react immediately to a burst of connections and halt the flow so that ← --HT can then make a more informed decision as to whether the host is infected. As it does not force connections to be evaluated in order, CBCRL can also immediately process evidence of connection successes. This will enable it to quickly increase the allowed first-contact connection rate when these requests are benign.</p><p>Credit-based connection rate limiting, as summarized in Figure <ref type="figure" target="#fig_4">7</ref>, works by allocating to each local host, l, a starting balance of ten credits (C l ← 10) which can be used for issuing first-contact connection requests. Whenever a firstcontact connection request is observed, a credit is subtracted from the sending host's balance (C l ← C l -1). If the successful acknowledgment of a first-contact connection is observed, the host that initiated the request is issued two additional credits (C l ← C l + 2). No action is taken when connections fail, as the cost of issuing a first-contact connection has already been deducted from the issuing host's balance. Finally, first-contact connection requests are blocked if the host does not have any credit available (C l = 0) <ref type="foot" target="#foot_2">5</ref> . If a first-contact connection succeeds with probability θ, its expected payoff from issuing that connection is its expected success credit minus its cost, or 2θ-1. This payoff is positive for θ &gt; 1  2 and negative otherwise. Hosts that scan with a low rate of successful connections will quickly consume their credits whereas benign hosts that issue first-contact connections with high rates of success will nearly double their credits each time they invest them.</p><formula xml:id="formula_18">Event Change to C l Starting balance C l ← 10 FCC issued by l C l ← C l -1 FCC succeeds C l ← C l + 2 Every second C l ← max(10, 2 3 C l ) if C l &gt; 10 Allowance C l ← 1 if C l = 0 for 4 seconds</formula><p>As described so far, the algorithm could result in two undesirable states. First, a host could acquire a large number of credits while performing a benign activity (e.g. Web crawling) which could be used later by a scanning worm. Second, a network outage could cause a benign host to use all of its credits after which it would starve for a lack of first-contact connection successes.</p><p>These problems are addressed by providing each host with a small allowance and by putting in place a high rate of inflation. If a host has been without credits for four seconds, we issue the host a single credit (C l ← 1 if C l ≤ 0). This not only ensures that the host does not starve, but enables us to collect another observation to feed into our hypothesis test ( ← --HT ). Because ← --HT , as configured in Section 4, observes all first-contact connection requests as successes or failures within three seconds, providing a starving process with a credit allowance only after more than three seconds have passed ensures that ← --HT will have been executed on all previously issued first-contact connection requests. If ← --HT has already concluded that the host is a worm, it is expected that the system will be quarantined and so no requests will reach their destination regardless of the credit balance.</p><p>For each second that passes, a host that has acquired more than 10 credits will be forced to surrender up to a third of them, but not so many as to take its balance below 10 (C l ← max(10, 2  3 C l ) if C l &gt; 10). A host that is subject to the maximum inflation rate, with a first-contact connection rate r, success rate θ &gt; 0, and credit balance C l,t at time t, will see this balance reach an equilibrium state Ĉ when Ĉ = C l,t = C l,t+1 .</p><formula xml:id="formula_19">C l,t+1 = 2 3 (C l,t + r • (2θ -1)) Ĉ = 2 3 ( Ĉ + r • (2θ -1)) Ĉ = 2 3 Ĉ + 2 3 • r • (2θ -1) 1 3 Ĉ = 2 3 • r • (2θ -1) Ĉ = 2 • r • (2θ -1)</formula><p>One can now see that we chose the inflation constant 2 3 to ensure that, in the upcoming second, a host that has a perfect first-contact connection success rate (θ = 1) will have twice as many credits as it could have needed in the previous second. Also note that the maximum inflation rate, which seems quite steep, is only fully applied when Ĉ ≥ 15, which in turn occurs only when the firstcontact connection rate r is greater than 7.5 requests per second. Twycross and Williamson's virus throttle, on the other hand, can only assume that any host with a first-contact connection rate consistently greater than one request per second is a worm.</p><p>The constant of 10 was chosen for the starting credit balance (and for the equilibrium minimum credit balance for benign hosts with first-contact connection rates below 5 requests/second) in order to match the requirements of our sequential hypothesis test ( ← --HT ) as currently configured (see parameters in Section 4), which itself requires a minimum of 10 observations in order to conclude that a host is engaged in scanning. Slowing the rate at which the first 10 observations can be obtained will only delay the time required by ← --HT to conclude that a host is engaged in scanning. Should the parameters of ← --HT be reconfigured and the minimum number of observations required to conclude a host is a scanner change, the starting credit balance for rate-limiting can be changed to match it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Setup</head><p>We evaluated our algorithms using two traces collected at the peering link of a medium sized ISP; one collected in April 2003 (isp-03) containing 404 active hosts and the other in January 2004 (isp-04) containing 451 active hosts. These traces, summarized in Table <ref type="table" target="#tab_2">1</ref>, were collected using tcpdump.</p><p>Obtaining usable traces was quite difficult. Due to privacy concerns, network administrators are particularly loathe to share traces, let alone those that contain payload data in addition to headers. Yet, we required the payload data in order to manually determine which, if any, worm was present on a host that was flagged as infected. To best simulate use of our algorithm in a worm detection system that is used to quarantine hosts, we only tested local hosts for infection. Remote hosts were not tested.</p><p>In configuring our reverse sequential hypothesis test ( ← --HT ), first-contact connection requests were interpreted as failures if they were not acknowledged within a three second grace period. First-contact connection requests for which TCP RST packets were received in response were immediately reported as failure observations. Connection success probability estimates were chosen to be:</p><formula xml:id="formula_20">θ 0 = 0.7 θ 1 = 0.1</formula><p>Confidence requirements were set to:</p><formula xml:id="formula_21">α = 0.00005 β = 0.99</formula><p>Note that these confidence requirements are for each reverse sequential hypothesis test, and that a test is performed for each first-contact connection that is observed. Therefore, the false positive rate is chosen to be particularly low as testing will occur many times for each host.</p><p>For each local host we maintained a Previously Contacted Host (PCH) set of only the last 64 destination addresses that each local host had communicated with (LRU replacement). For the sake of the experiment, a first-contact connection request was any TCP SYN packet or UDP packet addressed to a host that was not in the local host's PCH set. While using a fixed sized PCH set demonstrates the efficacy of our test under the memory constraints that are likely to occur when observing large (e.g. class B) networks, this fixed memory usage comes at a cost. As described in Section 6, it is possible for a worm to exploit limitations in the PCH set size in order to avoid having its scans detected.</p><p>For sake of comparison, we also implemented Twycross and Williamson's 'virus throttle' as described in <ref type="bibr" target="#b21">[22]</ref>. Since our traces contain only those packets seen at the peering point, our results may differ from a virus throttle implemented at each local host as Twycross and Williamson recommend. However, because observing connections farther from the host results in a reduction in the number of connections observed, it should only act to reduce the reported number of false positives in which benign behavior is throttled.</p><p>All algorithms were implemented in Perl, and used traces that had been pre-processed by the Bro Network Intrusion Detection System <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>We did not observe FTP-DATA, finger, and IDENT connections as these connections are the result of local hosts responding to remote hosts, and are not likely to be accepted by a host that has not issued a request for such a connection. These connections are thus unlikely to be useful for worm propagation. Our reverse sequential hypothesis test detected two hosts infected with CodeRed II <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b19">20]</ref> from the April, 2003 trace (isp-03). Our test detected one host infected with Blaster/Lovsan <ref type="bibr" target="#b4">[5]</ref>, three hosts infected with MyDoom/Novarg <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b20">21]</ref>, and one host infected with Minmail.j <ref type="bibr" target="#b5">[6]</ref> from the January, 2004 trace (isp-04). The worms were conclusively identified by painstakingly comparing the logged traffic with the cited worm descriptions at various online virus/worm information libraries. Our test also identified four additional hosts that we classify as HTTP scanners because each sent SYN packets to port 80 of at least 290 addresses within a single class B network. These results are summarized in Table <ref type="table" target="#tab_3">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>While peer-to-peer applications are not necessarily malicious, many network administrators would be loathe to classify them as benign. Peer-to-peer file sharing applications also exhibit ambiguous network behavior, as they attempt to contact a large number of transient peers that are often unwilling or unavailable to respond to connection requests. While peer-to-peer clients are deemed undesirable on most of the corporate networks that we envision our approach being used to protect, it would be unfair to classify these hosts as infected. For this reason we place hosts that we detect running peer-to-peer applications into their own category. Even if detections of these hosts are classified as false alarms, the number of alarms is manageable.</p><p>Three additional false alarms were reported for three of the 60 (isp-04) total hosts transmitting SMTP traffic. We suspect the false alarms are the result of bulk retransmission of those emails that have previously failed when the recipients' mail servers were unreachable. We suggest that organizations may want to white-list their SMTP servers, or significantly increase the detection thresholds for this protocol.</p><p>The remaining three false alarms are specific to the isp-04 trace, and resulted from HTTP traffic. It appears that these false alarms were raised because of a temporary outage at a destination network at which multiple remote hosts became unresponsive. These may have included servers used to serve inlined images. Upon discovering these failures, we came to realize that it would be possible for an adversary to create Web sites that served pages with large numbers of inlined image tags linked to non-responsive addresses. If embedded with scripts, these sites might even be designed to perform scanning of the client's network from the server. Regardless, any client visiting such a site would appear to be engaged in HTTP scanning. To prevent such denial of service attacks from rendering a worm detection system unusable, we require a mechanism for enabling users to deactivate quarantines triggered by HTTP requests. We propose that HTTP requests from such hosts be redirected to a site that uses a CAPTCHA (Completely Automated Public Turing Test to Tell Computers and Humans Apart <ref type="bibr" target="#b22">[23]</ref>), to confirm that a user is present and was using a Web browser at the time of quarantine.</p><p>Results for our implementation of Twycross and Williamson's virus throttle <ref type="bibr" target="#b21">[22]</ref> are summarized in Table <ref type="table" target="#tab_4">3</ref>. Their algorithm blocked both instances of CodeRed II, but failed to detect Blaster, three instances of MyDoom (which is admittedly an email worm and not an IP scanning worm), and two low rate HTTP scanners. It did, however, detect one host infected with MyDoom that ← --HT failed to detect. The virus throttle also detected fewer hosts running peer-to-peer applications, which for fairness we classify as a reduction in false alarms in virus throttling's favor in our composite results summarized in Table <ref type="table" target="#tab_5">4</ref>.</p><p>These composite results for both traces report the number of hosts that resulted in alarms and the number of those alarms that were detections of the 12 worms located in our traces. We also include the efficiency, which is the number of detections over the total number of alarms, and the effectiveness, which is the total number of detections over the total number of infected hosts we have found in these traces. While ← --HT is somewhat less efficient than virus throttling, the more than two-fold increase in effectiveness is well worth the trade-off. In addition, corporate networks that forbid peer-to-peer file sharing applications will see a two-fold increase in efficiency.</p><p>Table <ref type="table" target="#tab_6">5</ref> shows the number of hosts that had connection requests blocked by our credit-based algorithm and the number of hosts that were rate limited by Twycross and Williamson's algorithm. For credit-based connection rate limiting, we say that a machine has been rate limited if a single packet is dropped. For the virus throttle, we say that a machine has been rate limited if the outgoing delay queue length is greater than five, giving Twycross and Williamson the benefit of the doubt that users won't notice unless connections are severely throttled. Our credit-based algorithm only limited the rates of hosts that our reverse sequential hypothesis test reported as infected. In contrast, even given our generous definition, more than 10% of the hosts in both traces were rate limited by Twycross and Williamson's algorithm.</p><p>Table <ref type="table" target="#tab_7">6</ref> reports the number of first-contact connections permitted by the two approaches for those scanners that both detected. CodeRed II is a fast scanner, and so virus throttling excels in blocking it after 6 to 7 connection requests. This speed is expected to come at the price of detecting any service, malicious or benign, that issues high-rate first-contact connections.</p><p>Reverse Sequential Hypothesis Testing with credit-based connection rate limiting detects worms after a somewhat higher number of first-contact connections are permitted <ref type="bibr" target="#b9">(10)</ref>, but does so regardless of the scanning rate. Whereas our approach detects a slow HTTP scanner after 10 first-contact connection requests, the virus throttle requires as many as 526.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Limitations</head><p>Credit-based connection rate limiting is resilient to network uplink outages as hosts starved for credits will receive an allowance credit seconds after the network is repaired. Unfortunately, this will be of little consolation as Reverse Sequential Hypothesis Testing( ← --HT ) may have already concluded that all hosts are scanners. This may not be a problem if network administrators are given the power to invalidate observations made during the outage period, and to automatically reverse any quarantining decisions that would not have been taken without these invalid observations. Of greater concern is that both Reverse Sequential Hypothesis Testing and credit-based connection rate limiting rely exclusively on the observation that hosts engaged in scanning will have lower first-contact connection success rates than benign hosts. New hypotheses and tests are required to detect worms for which this statistical relationship does not hold.</p><p>In particular, our approach is not likely to detect a topological worm, which scans for new victim hosts by generating a list of addresses that the infected host has already contacted. Nor is our approach likely to detect flash worms, which contain hit-lists of susceptible host addresses identified by earlier scans.</p><p>Also problematic is that two instances of a worm on different networks could collaborate to ensure that none of their first-contact connections will appear to fail. For example, if worm A does not receive a response to a first-contact connection request after half the timeout period, it could send a message to worm B asking it to forge a connection response. This forged response attack prevents our system from detecting connection failures. To thwart this attack for TCP connections, a worm detection system implemented on a router can modify the TCP sequence numbers of traffic as it enters and leaves the network. For example, the result of a hash function h(IP local , IP remote , salt) may be added to all sequence numbers on outgoing traffic and subtracted from all incoming sequence numbers. The use of the secret salt prevents the infected hosts from calculating the sequence number used to respond to a connection request which they have sent, but not received. By storing the correct sequence number in the FCC queue, responses can then be validated by the worm detection system.</p><p>Another concern is the possibility that a worm could arrive at its target already in possession of a list of known repliers -hosts that are known to reply to connection requests at a given port. This known-replier attack could employ lists that are programmed into the worm at creation, or accumulated by the worm as it spreads through the network. First-contact connections to these known-repliers will be very likely to succeed and can be interleaved with scans to raise the first-contact connection success rate. A one to one interleaving is likely to ensure that more than half of all connections succeed. This success rate would enable the scanner to bypass credit-based connection rate limiting, and delay detection by Reverse Sequential Hypothesis Testing until the scanner had contacted all of its known-repliers. What's worse, a worm could avoid detection altogether if the detection system defines a first-contact connection with respect to a fixed sized previously contact host (PCH) set. If the PCH set tracks only the n previously visited hosts, the scanner can cycle through (n/2) + 1 known-repliers, interleaved with as many new addresses, and never be detected<ref type="foot" target="#foot_3">6</ref> . To prevent a worm from scanning your local network by interleaving connections to knownrepliers outside of your network, Weaver et al. <ref type="bibr" target="#b25">[26]</ref> propose that one hypothesis test be run for local connections (i.e. those within the same IP block) and another for connections to remote hosts. If hosts in your local network are widely and randomly dispersed through a large IP space<ref type="foot" target="#foot_4">7</ref> , then a worm will have a low probability of finding another host to infect before being quarantined.</p><p>A worm might also avoid detection by interleaving scanning with other apparently benign behavior, such as Web crawling. A subset of these benign interleaving attacks can be prevented by detecting scanners based on the destination port they target in addition to the source IP of the local host. While it is still fairly easy to create benign looking traffic for ports such as HTTP, for which one connection can lead to information about other active hosts receptive to new connections, this is not the case for ports such as those used by SSH. Running separate scan detection tests for each destination port that a local host addresses can ensure that connections to one service aren't used to mask scans to other services.</p><p>Finally, if an infected host can impersonate other hosts, the host could escape quarantine and cause other (benign) hosts to be quarantined. To address these address impersonation attacks, it is important that a complete system for network quarantining include strong methods for preventing IP masquerading by its local hosts, such as switch level egress filtering. Host quarantining should also be enforced as close to the host as is possible without relying on the host to quarantine itself. If these boundaries cannot be enforced between each host, one must assume that when one machine is infected, all of the machines within the same boundary will also be infected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>We were motivated by the work of Moore et al. <ref type="bibr" target="#b9">[10]</ref>, who model attempts at containing worms using quarantining. They perform theoretical simulations, many of which use parameters principally from the CodeRed II <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b19">20]</ref> outbreak. They argue that it is impossible to prevent systems from being vulnerable to worms and that treatment cannot be performed fast enough to prevent worms from spreading, leaving containment (quarantining) as the most viable way to prevent worm outbreaks from becoming epidemics.</p><p>Early work on containment includes Staniford et al.'s work on the GrIDS Intrusion Detection System <ref type="bibr" target="#b18">[19]</ref>, which advocates the detection of worms and viruses by tracing their paths through the departments of an organization. More recently, Staniford <ref type="bibr" target="#b15">[16]</ref> has worked to generalize these concepts by extending models for the spread of infinite-speed, random scanning worms through homogenous networks divided up into 'cells'. Simulating networks with 2 17 hosts (two class B networks), Staniford limits the number of first-contact connections that a local host initiates to a given destination port to a threshold, T . While he claims that for most ports, a threshold of T = 10 is achievable in practice, HTTP and KaZaA are exceptions. In comparison, reverse sequential hypothesis testing reliably identifies HTTP scanning in as few as 10 observations.</p><p>The TRAFEN <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> system also observed failed connections for the purpose of identifying worms. The system was able to observe larger networks, without access to end-points, by inferring connection failures from ICMP messages. One problem with acting on information at this level is that an attacker could spoof source IP addresses to cause other hosts to be quarantined.</p><p>Our use of rate limiting in order to buy time to observe worm behavior was inspired by the virus throttle presented by Twycross and Williamson <ref type="bibr" target="#b21">[22]</ref>, which we described in detail in Section 3. Worms can evade a throttle by scanning at rates below one connection per second, allowing epidemics to double in size as quickly as once every two seconds.</p><p>An approach quite similar to our own has been simultaneously developed by Weaver, Staniford, and Paxson <ref type="bibr" target="#b25">[26]</ref>. Their approach combines the rate limiting and hypothesis testing steps by using a reverse sequential hypothesis test that (like our CBCRL algorithm) assumes that connections fail until they are proven to succeed. As with CBCRL, out-of-order processing could cause a slight increase in detection delay, as the successes of connections sent before an infection event may be processed after connections are initiated after the infection event. In the context of their work, in which the high-performance required to monitor large networks is a key goal, the performance benefits are likely to outweigh the slight cost in detection speed.</p><p>For a history and recent trends in worm evolution, we recommend the work of Kienzle and Elder <ref type="bibr" target="#b7">[8]</ref>. For a taxonomy of worms and a review of worm terminology, see Weaver et al. <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Future Work</head><p>As worm authors become aware of the limitations discussed in Section 6, it will be necessary to revise our algorithms to detect scanning at the resolution of the local host (source address) and targeted service (destination port), rather than looking at the source host alone. Solutions for managing the added memory requirements imposed by this approach have been explored by Weaver, Staniford, and Paxson <ref type="bibr" target="#b25">[26]</ref>.</p><p>The intrusiveness of credit-based connection rate limiting, which currently drops outgoing connection requests when credit balances reach zero, can be further reduced. Instead of halting outgoing TCP first-contact connection requests from hosts that do not maintain a positive credit balance, the requests can be sent immediately and the responses held until a positive credit balance is achieved. This improvement has the combined benefits of reducing the delays caused by false rate limiting while simultaneously ensuring that fewer connections are allowed to complete when a high-speed scanning worm issues a burst of connection requests. As a result, the remaining gap in response speed between credit-based connection rate limiting and Twycross and Williamson's virus throttle can be closed while further decreasing the risk of acting on false positives.</p><p>Finally, we would like to employ additional indicators of infection to further reduce the number of first-contact connection observations required to detect a worm. For example, it is reasonable to conclude that, when a host is deemed to be infected, those hosts to which it has most recently initiated successful connections are themselves more likely to be infected (as was the premise behind GrIDS <ref type="bibr" target="#b18">[19]</ref>). We propose that this be accomplished by adding an event type, the report of an infection of a host that has recently contacted the current host, to our existing hypothesis test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>When combined, credit-based connection rate limiting and reverse sequential hypothesis testing ensure that worms are quickly identified with an attractively low false alarm rate. While no system can detect all possible worms, our new approach is a significant improvement over prior methods, which detect a smaller range of scanners and unnecessarily delay network traffic. What's more, the techniques introduced in this paper lend themselves to efficient implementation, as they need only be activated to observe a small subset of network events and require little calculation for the common case that traffic is benign.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Optimizing the Computation of Repeated Reverse Sequential Hypothesis Tests</head><p>It is unnecessarily expensive to repeatedly recompute Λ in reverse sequence each time a new first-contact connection is observed. A significant optimization requires that we maintain single state variable Λ, calculated iteratively in the order in which events are observed.</p><formula xml:id="formula_22">Λ(Y n ) = max 1, Λ(Y n-1 )φ(Y n ) Λ(Y 0 ) ≡ 1.<label>(1)</label></formula><p>We will prove that Λ(Y n ) &gt; η 1 if and only if a reverse sequential hypothesis test starting backward from observation n would lead to infection conclusion.</p><p>We first prove the following lemma stating that if a reverse sequential hypothesis test reports an infection, our optimized algorithm will also report an infection.</p><p>Lemma 1. For η 1 &gt; 1 and for mutually independent random variables Y i , ∀m ∈ <ref type="bibr">[1, n]</ref> :</p><formula xml:id="formula_23">Λ(Y n , Y n-1 , . . . , Y m ) ≥ η 1 ⇒ Λ(Y n ) ≥ η 1 (2)</formula><p>Proof. We begin by replacing the Λ term with its equivalent expression in terms of φ:</p><formula xml:id="formula_24">η 1 ≤ Λ(Y n , Y n-1 , . . . , Y m )<label>(3)</label></formula><formula xml:id="formula_25">≤ n i=m φ(Y i )<label>(4)</label></formula><p>We can place a lower bound on the value of Λ(Y n ) by exploiting the fact that, in any iteration, Λ cannot return a value less than 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Λ(Y</head><formula xml:id="formula_26">n ) = Λ(Y 1 , Y 2 , . . . , Y n ) ≥ 1 • Λ(Y m , Y m+1 , . . . , Y n ) ≥ n i=m φ(Y i ) ≥ η 1</formula><p>where the last inequality follows the steps taken in Equations ( <ref type="formula" target="#formula_24">3</ref>) and (4).</p><p>Thus,</p><formula xml:id="formula_27">Λ(Y n , Y n-1 , . . . , Y m ) ≥ η 1 ⇒ Λ(Y n ) ≥ η 1 .</formula><p>We must also prove that our optimized algorithm will only report an infection when a reverse sequential hypothesis test would also report an infection. Recall that a reverse sequential hypothesis test will only report an infection if Λ exceeds η 1 before falling below η 0 . Lemma 2. For thresholds η 0 &lt; 1 &lt; η 1 and for mutually independent random variables Y i , if Λ(Y i ) ≥ η 1 for some i = n, but Λ(Y i ) &lt; η 1 for all i ∈ [1, n -1], then there exists a subsequence of observations starting at observation n and moving backward to observation m ∈ <ref type="bibr">[1, n]</ref>  To prove that there exists no k in [m, n] such that Λ(Y n , Y n-1 , . . . , Y k ) ≤ η 0 , suppose that such a k exists. It follows that:</p><formula xml:id="formula_28">n j=k φ(Y j ) ≤ η 0 &lt; 1<label>(5)</label></formula><p>Recall that we chose m to ensure that:</p><formula xml:id="formula_29">η 1 ≤ n j=m φ(Y j )<label>(6)</label></formula><p>The product on the right hand side can be separated into factors from before and after observation k.</p><formula xml:id="formula_30">η 1 ≤ k-1 j=m φ(Y j ) • n j=k φ(Y j )•<label>(7)</label></formula><p>We then use Equation <ref type="bibr" target="#b4">(5)</ref> to substitute an upper bound of 1 on the latter product.</p><formula xml:id="formula_31">η 1 ≤ k-1 j=m φ(Y j ) η 1 ≤ Λ(Y k-1 )</formula><p>This contradicts the hypothesis that Λ(Y i ) &lt; η 1 for all i ∈ [1, n -1].</p><p>If we were concerned with being notified when the test came to the 'benign' conclusion we could create an analogous function Λ:</p><formula xml:id="formula_32">Λ(Y n ) = min (1, Λ(Y n-1 )φ(Y n ))</formula><p>The lemmas required to show equivalence and proof are also analogous.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. A log scale graph of Λ(Y) as each observation, Yi, is added to the sequence. Each success (0) observation decreases Λ(Y), moving it closer to the benign conclusion threshold η0, whereas each failure (1) observation increases Λ(Y), moving it closer to the infection conclusion threshold η 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A log scale graph tracing the value of Λ(Y i+5 , Y i+4 , . . .), in which the observations in Y are processed in reverse sequential order. The most recent, or rightmost, observation is the first one processed</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. The success of first-contact connection requests by a local host to remote hosts cannot be established by the Worm Detection System (WDS) until a response is observed or a timeout expires</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. The structure of entries in the First-Contact Connection (FCC) queue</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The underlying equations behind credit-based connection rate limiting. Changes to a host's balance are triggered by the first-contact connections (FCCs) it initiates and by the passing of time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>for which Λ(Y n , Y n-1 , . . . , Y m ) ≥ η 1 and such that there exists no k in[m,n]  such that Λ(Y n , Y n-1 , . . . , Y k ) ≤ η 0Proof. Choose m as the largest observation index for which it held that:Λ(Y m-2 )φ(Y m-1 ) &lt; 1We know that m &lt; n because Λ(Y n-1 )φ(Y n ) is greater than η 1 which is in turn greater than 1. Let m = 1 if the above relation does not hold for any observation with index greater than 1. It follows that Λ(Y m-1 ) = 1 and thus:Λ(Y m ) = φ(Y m )Because we chose m such that Λ(Y j-2 )φ(Y j-1 ) ≥ 1 for all j &gt; m:Λ(Y n ) = n j=m φ(Y j ) = Λ(Y n , Y n-1 , . . . , Y m ) Thus, Λ(Y n ) ≥ η 1 ⇒ Λ(Y n , Y n-1 , . . . , Y m ) ≥ η 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Summary of network traces</figDesc><table><row><cell></cell><cell>isp-03</cell><cell>isp-04</cell></row><row><cell>Date</cell><cell cols="2">2003/04/10 2004/01/28</cell></row><row><cell>Duration</cell><cell cols="2">627 minutes 66 minutes</cell></row><row><cell>Total outbound connection attempts</cell><cell>1,402,178</cell><cell>178,518</cell></row><row><cell>Total active local host</cell><cell>404</cell><cell>451</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>Alarms reported by reverse sequential hypothesis testing combined with credit-based rate limiting. The cause of each alarm was later identified manually by comparing observed traffic to signature behaviors described at online virus libraries</figDesc><table><row><cell></cell><cell cols="2">isp-03 isp-04</cell></row><row><cell>Worms/Scanners detected</cell><cell></cell><cell></cell></row><row><cell>CodeRed II</cell><cell>2</cell><cell>0</cell></row><row><cell>Blaster</cell><cell>0</cell><cell>1</cell></row><row><cell>MyDoom</cell><cell>0</cell><cell>3</cell></row><row><cell>Minmail.j</cell><cell>0</cell><cell>1</cell></row><row><cell>HTTP (other)</cell><cell>3</cell><cell>1</cell></row><row><cell>Total</cell><cell>5</cell><cell>6</cell></row><row><cell>False alarms</cell><cell></cell><cell></cell></row><row><cell>HTTP</cell><cell>0</cell><cell>3</cell></row><row><cell>SMTP</cell><cell>0</cell><cell>3</cell></row><row><cell>Total</cell><cell>0</cell><cell>6</cell></row><row><cell>P2P detected</cell><cell>6</cell><cell>11</cell></row><row><cell>Total identified</cell><cell>11</cell><cell>23</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>Alarms reported by virus throttling</figDesc><table><row><cell></cell><cell cols="2">isp-03 isp-04</cell></row><row><cell>Worms/Scanners detected</cell><cell></cell><cell></cell></row><row><cell>CodeRed II</cell><cell>2</cell><cell>0</cell></row><row><cell>MyDoom</cell><cell>0</cell><cell>1</cell></row><row><cell>HTTP (other)</cell><cell>1</cell><cell>1</cell></row><row><cell>Total</cell><cell>3</cell><cell>2</cell></row><row><cell>False alarms</cell><cell>0</cell><cell>0</cell></row><row><cell>P2P detected</cell><cell>2</cell><cell>3</cell></row><row><cell>Total identified</cell><cell>5</cell><cell>5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 .</head><label>4</label><figDesc>Composite results for both traces. A total of 7 HTTP scanning worms and 5 email worms were present</figDesc><table><row><cell>← --HT</cell><cell cols="4">Alarms Detection Efficiency Effectiveness 34 11 0.324 0.917</cell></row><row><cell>virus-throttling</cell><cell>10</cell><cell>5</cell><cell>0.500</cell><cell>0.417</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5 .</head><label>5</label><figDesc>Comparison of rate limiting by credit-based connection rate limiting (CBCRL) vs. a virus throttle. Unnecessary rate limiting means that CBCRL dropped at least one packet from a host. For virus throttling, we only classify a host as rate limited if the delay queue reaches a length greater than five</figDesc><table><row><cell></cell><cell>CBCRL</cell><cell></cell><cell cols="2">Virus Throttling</cell></row><row><cell></cell><cell cols="4">isp-03 isp-04 isp-03 isp-04</cell></row><row><cell>Worms/Scanners</cell><cell>5</cell><cell>1</cell><cell>3</cell><cell>4</cell></row><row><cell>P2P</cell><cell>4</cell><cell>8</cell><cell>3</cell><cell>7</cell></row><row><cell>Unnecessary rate limiting</cell><cell>0</cell><cell>0</cell><cell>84</cell><cell>59</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 6 .</head><label>6</label><figDesc>The number of first-contact connections permitted before hosts were reported as infected. The value pairs represent individual results for two different CodeRed II infections and two different HTTP scanners</figDesc><table><row><cell></cell><cell cols="2">← --HT with CBCRL Virus Throttling</cell></row><row><cell>CodeRed II</cell><cell>10,10</cell><cell>6,7</cell></row><row><cell>Other HTTP scanners</cell><cell>10,10</cell><cell>102,526</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>The letters in this abbreviation, ← --HT , stand for Hypothesis Testing and the arrow indicates the reverse sequential order in which observations are processed.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>In fact, addition and subtraction operations are adequate as the iterative function is equivalent to Θ(Yn) = max (0, Θ(Yn-1) + ln φ(Yn)) where Θ(Yn) ≡ ln Λ(Yn).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>In Section 8, we discuss the alternative of allowing all TCP requests to be transmitted and queueing responses until credits are available.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>For detecting such a worm, a random replacement policy will be superior to an LRU replacement policy, but will still not be effective enough for long known-replier lists.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>Randomly dispersing local hosts through a large IP space can be achieved by using a network address translation (NAT) switch.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Acknowledgments</head><p>This paper could not have been completed without the continued support of Vern Paxson and Hari Balakrishnan. We are indebted to Dave Andersen and Noah Case for the network logs used for our analysis. We would also like to thank the anonymous reviewers as well as Nick Feamster, David Molnar, Rodrigo Miragaia Rodrigues, David Savitt, Matt Williamson, and especially Glenn Holloway for taking the time to review and comment on earlier drafts of this paper. Stuart Schechter would like to thank the National Science Foundation for support under grant CCR-0310877.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Early detection of internet worm activity by metering ICMP destination unreachable messages</title>
		<author>
			<persName><forename type="first">George</forename><surname>Bakos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Berk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SPIE Aerosense</title>
		<meeting>the SPIE Aerosense</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Designing a framework for active worm detection on global networks</title>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Berk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Bakos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Workshop on Information Assurance</title>
		<meeting>the IEEE International Workshop on Information Assurance</meeting>
		<imprint>
			<date type="published" when="2003-03">March 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Using sensor networks and data fusion for early detection of active worms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">S</forename><surname>Berk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><surname>Bakos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SPIE Aerosense Conference</title>
		<meeting>the SPIE Aerosense Conference</meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Code Red II:&quot; another worm exploiting buffer overflow in IIS indexing service DLL</title>
		<author>
			<persName><surname>Cert</surname></persName>
		</author>
		<ptr target="http://tinyurl.com/2lzgb" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">F-Secure</forename></persName>
		</author>
		<ptr target="http://tinyurl.com/jozm" />
		<title level="m">Computer virus information pages: Lovsan</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Computer virus information pages: Mimail</title>
		<author>
			<persName><forename type="first">F-Secure</forename></persName>
		</author>
		<ptr target="http://tinyurl.com/3ybsp" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast portscan detection using sequential hypothesis testing</title>
		<author>
			<persName><forename type="first">Jaeyeon</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><forename type="middle">W</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2004">May 9-12, 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Recent worms: a survey and trends</title>
		<author>
			<persName><forename type="first">Darrell</forename><forename type="middle">M</forename><surname>Kienzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">C</forename><surname>Elder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM Workshop on Rapid Malcode</title>
		<meeting>the 2003 ACM Workshop on Rapid Malcode</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-10-27">October 27, 2003</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Inside the Slammer worm</title>
		<author>
			<persName><forename type="first">David</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colleen</forename><surname>Shannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Staniford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Weaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="33" to="39" />
			<date type="published" when="2003-07">July 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Internet quarantine: Requirements for containing self-propagating code</title>
		<author>
			<persName><forename type="first">David</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colleen</forename><surname>Shannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">M</forename><surname>Voelker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Savage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2003-03">April 1-3 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://tinyurl.com/2asgc" />
		<title level="m">Network Associates Inc. Security threat report for W32/MydoomMM</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><surname>Bro</surname></persName>
		</author>
		<ptr target="http://www.icir.org/vern/bro-info.html" />
		<title level="m">A system for detecting network intruders in real-time</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Bro: a system for detecting network intruders in real-time</title>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="2435" to="2463" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Countering network worms through automatic patch generation</title>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<idno>CUCS-029-03</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A network worm vaccine architecture</title>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE), Workshop on Enterprise Security</title>
		<meeting>the IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE), Workshop on Enterprise Security</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Containment of scanning worms in enterprise networks</title>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Staniford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Practical automated detection of stealthy portscans</title>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Staniford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Hoagland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Mcalerney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="105" to="136" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">How to 0wn the Internet in your spare time</title>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Staniford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Weaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Security Symposium</title>
		<meeting>the 11th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2002">August 7-9, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">GrIDS -A graph-based intrusion detection system for large networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Staniford-Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dilger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hoagland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Levitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zerkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th National Information Systems Security Conference</title>
		<meeting>the 19th National Information Systems Security Conference</meeting>
		<imprint>
			<date type="published" when="1996-10">October 1996</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Security response -CodeRed II</title>
		<author>
			<persName><surname>Symantec</surname></persName>
		</author>
		<ptr target="http://tinyurl.com/89t0" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Security response -W32</title>
		<author>
			<persName><surname>Symantec</surname></persName>
		</author>
		<ptr target="http://tinyurl.com/2qbaj" />
	</analytic>
	<monogr>
		<title level="m">A@mm</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Implementing and testing a virus throttle</title>
		<author>
			<persName><forename type="first">Jamie</forename><surname>Twycross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">M</forename><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Security Symposium</title>
		<meeting>the 12th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2003-08">August 4-8 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Telling humans and computers apart (automatically) or how lazy cryptographers do AI</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Luis Von Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><surname>Langford</surname></persName>
		</author>
		<idno>CMU- CS-02-117</idno>
		<imprint>
			<date type="published" when="2002-02">February 2002</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Wald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sequential Analysis. J. Wiley &amp; Sons</title>
		<imprint>
			<date type="published" when="1947">1947</date>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A taxonomy of computer worms</title>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Staniford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Cunningham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM Workshop on Rapid Malcode</title>
		<meeting>the 2003 ACM Workshop on Rapid Malcode</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003-10-27">October 27, 2003</date>
			<biblScope unit="page" from="11" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Very fast containment of scanning worms</title>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><surname>Staniford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX Security Symposium</title>
		<meeting>the 13th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="9" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Throttling viruses: Restricting propagation to defeat malicious mobile code</title>
		<author>
			<persName><forename type="first">M</forename><surname>Matthew</surname></persName>
		</author>
		<author>
			<persName><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 18th Annual Computer Security Applications Conference (ACSAC 2002)</title>
		<meeting>The 18th Annual Computer Security Applications Conference (ACSAC 2002)</meeting>
		<imprint>
			<date type="published" when="2002">December 9-13, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
