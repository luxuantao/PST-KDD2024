<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Networks: Models and Algorithms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
							<email>fabian.kuhn@usi.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Informatics Computer Science</orgName>
								<orgName type="laboratory">Artificial Intelligence Lab University of Lugano MIT</orgName>
								<address>
									<postCode>6904, 02139</postCode>
									<settlement>Lugano, Cambridge</settlement>
									<region>MA</region>
									<country>Switzerland, USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rotem</forename><surname>Oshman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Informatics Computer Science</orgName>
								<orgName type="laboratory">Artificial Intelligence Lab University of Lugano MIT</orgName>
								<address>
									<postCode>6904, 02139</postCode>
									<settlement>Lugano, Cambridge</settlement>
									<region>MA</region>
									<country>Switzerland, USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Networks: Models and Algorithms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">628B56E6460FAF09DE41B978E0F78A7E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The study of dynamic networks has come into popularity recently, and many models and algorithms for such networks have been suggested. In this column we survey some recent work on dynamic network algorithms, focusing on the effect that model parameters such as the type of adversary, the network diameter, and the graph expansion can have on the performance of algorithms. We focus here on high-level models that are not induced by some specific mobility pattern or geographic model (although much work has gone into geographic models of dynamic networks, and we touch upon them briefly in Section 2).</p><p>Dynamic network behavior has long been studied in distributed computing literature, but initially it was modeled as a fault in the network; as such, it was typically bounded, either in duration or in the number of nodes affected (or both). For example, in the general omission-fault model, if two nodes that could once communicate can no longer send messages to each other, this is treated as a failure of one of the nodes, and the number of faulty nodes is assumed to be bounded. Another example is self-stabilizing algorithms, which are guaranteed to function correctly only when changes to the network have stopped <ref type="bibr" target="#b15">[16]</ref>. These models are appropriate for modeling unreliable static networks, but they are not appropriate for mobile and ad hoc networks, where changes are unbounded in number and occur continually.</p><p>In the sequel we survey several models for dynamic networks, both random and adversarial, and algorithms for these models. The literature on dynamic networks is vast, and this column is not intended as a comprehensive survey. We have chosen to focus on models and algorithms that exhibit the following properties.</p><p>Unceasing changes. Changes to the network never stop, and are not restricted in frequency.</p><p>Dynamic topology not subject to the algorithm's control. We concentrate solely on algorithms that execute in a dynamic network, but have no control over how the topology changes.</p><p>Terminating computation. In this column we focus on algorithms whose execution eventually completes (in contrast to, e.g., eventually stabilizing computation, where the outputs eventually converge to the right answer, but the participants do not know when this occurs). For deterministic algorithms, we require all all nodes to eventually halt in every execution. When we discuss randomized algorithms, their correctness guarantee is of the form "the algorithm achieves its goal in f (n) rounds with high probability", where "high probability" here means 1o <ref type="bibr" target="#b0">(1)</ref>. We note that such algorithms can be used for either terminating or eventually stabilizing computation: if we have the nodes halt after f (n) rounds, then the goal is accomplished with high probability; if instead we repeat the algorithm forever, then with probability 1 the goal is eventually accomplished.</p><p>Non-geographical models. With the exception of one model discussed in Section 3.2, the network models we discuss here are not motivated by a geographical distribution of the nodes on the plane or by an underlying mobility pattern for the nodes. Rather, we focus on abstract models, where the dynamic communication topology can reflect any communication network -including both wireless mobile networks and unreliable traditional point-to-point networks.</p><p>The rest of the column is organized as follows. In the next section we introduce the basic dynamic graph model used in the work we survey, and point out several basic parameters of the model that can affect algorithmic performance. In Section 3 we define the dynamic diameter of a dynamic graph, a generalization of the notion of the diameter in a static graph; we illustrate the role it plays and give some examples of how it is affected by basic model parameters. In Section 4 we discuss a recent result on computation and information dissemination in adversarial dynamic networks, and in Section 5 we survey some of the work on broadcast in dynamic radio networks. Finally, in Section 6 we briefly discuss a few alternative models to the ones discussed in this column, and we conclude in Section 7 with some directions for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Evolving Graphs: A Basic Model for Dynamic Networks</head><p>For simplicity, and because this almost exclusively is the case considered in the literature, we restrict our attention to dynamic networks with a fixed set of participants. Such a dynamic network can typically be modeled as a dynamic graph G = (V, E), where V is a set of nodes that we identify with the participants in the computation, and E : N + → 2 V ×V is a dynamic edge function assigning to each round r ∈ N + a set of edges E(r) for that round. (The discussion here assumes a synchronous model, and this is true of much of the literature. In Section 3 we briefly touch upon asynchronous dynamic networks.) We think of a round as occurring between two times; round r ∈ N + occurs between time r -1 and time r. Depending on the model, E(r) may be a set of directed or undirected edges. Throughout this survey, we use n = |V | to denote the total number of nodes, and we use G(r) = (V, E(r)) to denote the instantaneous communication graph in round r. In the literature, such dynamic graphs have also been termed evolving graphs <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>An execution in a dynamic graph induces a causal order</p><formula xml:id="formula_0">⊆ (V × N) 2 , where (u, t 1 ) (v, t 2 )</formula><p>denotes the fact that u's state at time t 1 influences v at time t 2 . The causal order is defined in the usual way: it is the transitive and reflexive closure of the relation →, where (u, t) → (v, t ) iff t &gt; t and either u = v or u sends a message at time t that v receives at time t . In the case of a synchronous model where nodes broadcast on all their available links in each round, the direct causal order reduces to the following:</p><formula xml:id="formula_1">(u, t) → (v, t + 1) iff either u = v or (u, v) ∈ E(t + 1).</formula><p>Naturally, what can be achieved in a dynamic network and at what cost it can be done largely depends on how the dynamic set of edges is chosen. Consequently, dynamic network models can feature different assumptions about the way the dynamic graph is generated, the properties of each instantaneous graph E(r), and equally important the properties of the causal order, that is, in which way the graph G(r) in round r depends on earlier graphs. In this column we focus on the following properties.</p><p>Adversary model. The adversary model determines the method by which the dynamic edge function is generated. We focus on three types of adversaries: an adaptive worst-case adversary ("adaptive adversary" for short) generates the dynamic graph on-the-fly; in each round r, the edges E(r) are chosen based on the execution so far, including the states of all the participants at time r -1 and their randomness up to time r -1 (exclusive). An oblivious worst-case adversary ("oblivious adversary") commits to a dynamic graph in advance, choosing an edge function E that does not depend on the randomness of the participants or their states during the execution. (For deterministic algorithms, adaptive and oblivious adversaries are equivalent.)</p><p>Finally, a random-graph adversary is not an adversary at all, but simply a distribution according to which the instantaneous graph at each time is chosen. Random dynamic graph models are typically Markovian and often synchronous. In that case, the dynamic graph for round r + 1 is chosen according to some probability distribution that only depends on G(r) (see, e.g., <ref type="bibr" target="#b2">[3]</ref>). A special class of Markovian graphs has been considered in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11]</ref>, where it is assumed that for all r ≥ 1, each edge e ∈ E(r) appears in round r + 1 (that is, e ∈ E(r + 1)) with probability p independent of all other edges, and each edge e ∈ E(r) disappears in round r + 1 (that is, e ∈ E(r + 1)) with probability q independent of other edges. We refer to such graphs as Markovian dynamic graphs with birth rate p and death rate q. If we choose q = 1p, we obtain an interesting special case, where the graph of each round is an independent Erdős-Rényi random graph G n,p (see, e.g., <ref type="bibr" target="#b22">[23]</ref>).</p><p>Instantaneous connectivity and expansion. Real communication networks are often dense and wellconnected. To capture such properties it is often assumed that each instantaneous graph (V, E(r)) has some desirable connectivity properties; for example, it may be assumed that each instantaneous graph is a vertex expander, or that it is k-vertex connected for some k &gt; 1, and so on. In adversarial models, it is usually assumed that the graph is at least connected (or strongly connected for directed graphs) in each round. In random graph models the distribution is typically one that guarantees that each instantaneous graph or the union of a few consecutive graphs is with very high probability connected (and often has good expansion to boot).</p><p>To formally capture the connectivity of each instantaneous graph, we define a vertex growth function g : N → N, which generalizes the usual notion of vertex expansion. We say that a (static) graph G = (V, E) has vertex growth g if for every vertex set S ⊂ V of size s = |S| ≤ |V |/2, the set of neighbors N (S) := {v ∈ V \ S : ∃u ∈ S : (u, v) ∈ E} has size at least |N (S)| ≥ g(|S|).</p><p>For example, if G is connected, then the vertex growth of G is at least 1; if G is k-connected, the vertex growth of G is at least k (that is, the vertex growth is at least the constant function g(s) = k); and if G has vertex expansion α &gt; 0, then G has vertex growth g(s) = α • s.</p><p>We use g (f ) to denote the vertex growth of a set after f consecutive rounds, counting members of the original set as well as new neighbors: the base case is g (0) (s) = s, and for f &gt; 1, the growth is g (f ) (s) = g (f -1) (s) + g g (f -1) (s) .</p><p>Long-term stability. To model stability inherent in the dynamic network, one may assume for example that topology changes only occur once every certain number of rounds <ref type="bibr" target="#b2">[3]</ref>. Alternatively, in <ref type="bibr" target="#b27">[28]</ref> we introduce a property called T -interval connectivity, which asserts that over any window of T consecutive rounds there is some connected spanning subgraph that remains stable during those T rounds. (This graph is not known to the nodes in advance, and indeed can be chosen adaptively by the adversary.) Edges that are not in the stable graph may appear and disappear arbitrarily.</p><p>In the sequel we survey some of the work that considers various settings of the parameters above.</p><p>3 Dynamic Diameter and Cover Time</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Adversarial Dynamic Graphs</head><p>One of the crucial features affecting the efficiency of computation in a dynamic graph model is its dynamic diameter (also called flooding time, e.g., in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11]</ref>). The dynamic diameter is a bound on the time required for each participant to be causally influenced by each other participant; formally, the dynamic diameter is bounded by D if at all times t and for all u, v ∈ V it holds that (u, t) (v, t+D). In synchronous broadcast models this definition is straightforward and depends only on the dynamic graph. In non-synchronous models, where typically the nodes do not broadcast constantly, one also has to assume something about the protocol; for example, one may assume that nodes broadcast at least once every ∆H time units, and that there is some upper bound U on message delays. These assumptions induce a well-defined dynamic diameter that depends on the dynamic graph in question as well as on U and on ∆H; see below. The dynamic diameter is a natural lower bound on the time required for information to propagate through the network, just like the "standard" diameter in static networks: if some node broadcasts a message, and the message is immediately forwarded by all those who receive it, then all nodes receive the message in time that is bounded by the dynamic diameter. One might wonder if this new definition is necessary: can we not simply use a bound on the diameter of each instantaneous graph G(t)?</p><p>The answer turns out to be negative. A striking example that information dissemination in a dynamic graph can be much slower than in static networks is given in <ref type="bibr" target="#b2">[3]</ref>, where it is shown that even when the adversary is oblivious, there is a dynamic graph in which the instantaneous graph in each round has diameter 2, but the cover time of a random walk in the graph is Ω(2 n ). This stands in stark contrast to the cover time of a static graph, which is always O(D • |E| • log n), i.e., polynomial in n and linear in the diameter.</p><p>The dynamic graph given in <ref type="bibr" target="#b2">[3]</ref> is a "dynamic star" over nodes 0, . . . , n -1, where in round r the center of the star is node r mod (n-1), and the remaining nodes are leaves (see Fig. <ref type="figure" target="#fig_1">1</ref>). In addition, all nodes have self-loops, allowing the random walk to remain at one node for several rounds. Notice that node n -1 is never at the center of the star. If the random walk starts at node 0 (which is a leaf in rounds 1, 2, . . . , n -2), the only way the walk can reach node n-1 is by staying at some leaf for n-2 rounds until this leaf becomes the center of the star, and then moving to node n -1. (If the random walk moves to the center "too soon" then the process starts over, because the center will itself be a leaf again in the next round.) The probability that the random walk stays at a leaf for n -2 consecutive rounds is 1/2 n-2 , and hence the expected time until the walk covers all nodes is Ω(2 n ).</p><p>It is further shown in <ref type="bibr" target="#b2">[3]</ref> that the cover time is bounded from above by n O(n) , although in some special cases it is polynomial in n (for example, when the instantaneous graph is always d-regular). However, these upper bounds hold only for oblivious adversaries; an adaptive adversary can prevent a random walk or any other token-circulation mechanism from ever completing. In fact, the adversary can restrict the token to two nodes u 0 , u 1 , where u 0 is the node that has the token initially and u 1 is some arbitrarily chosen node: to do this, whenever node u i holds the token, the adversary connects u i only to u 1-i , and connects u 1-i to the remainder of the graph. Thus u i has no choice except to either keep the token or pass it to u 1-i .</p><p>The dynamic star described above also illustrates why the instantaneous diameter does not reflect the time required to flood a message through the network. If node 0 broadcasts a message on all its links in the to node n -1. (If the random walk moves to the center "too soon" then the process starts over, because the center will itself be a leaf again in the next round.) The probability that the random walk stays at a leaf for n -2 consecutive rounds is 1/2 n-2 , and hence the expected time until the walk covers all nodes is Ω(2 n ).  It is further shown in <ref type="bibr" target="#b2">[3]</ref> that the cover time is bounded from above by n O(n) , although in some special cases it is polynomial in n (for example, when the instantaneous graph is always d-regular). However, these upper bounds hold only for oblivious adversaries; an adaptive adversary can prevent a random walk or any other token-circulation mechanism from ever completing. In fact, the adversary can restrict the token to two nodes u 0 , u 1 , where u 0 is the node that has the token initially and u 1 is some arbitrarily chosen node: to do this, whenever node u i holds the token, the adversary connects u i only to u 1-i , and connects u 1-i to the remainder of the graph. Thus u i has no choice except to either keep the token or pass it to u 1-i .</p><p>The dynamic star described above also illustrates why the instantaneous diameter does not reflect the time required to flood a message through the network. If node 0 broadcasts a message on all its links in the first round, and in each round this message is re-broadcast by all nodes that know it (that is, all nodes that have heard it in the past), then n -1 rounds are required for the message to reach node n -1 (in Fig. <ref type="figure" target="#fig_1">1</ref>, node 3 does not receive the message until round 3). The dynamic diameter of the network is n -1, even though the instantaneous diameter is always bounded by 2.</p><p>Some instantaneous properties of the communication graph do translate into bounds on the dynamic diameter. For instance, if the instantaneous graph in each round is a vertex expander, then the dynamic diameter is O(log n); if each instantaneous graph is k-connected, the dynamic diameter is O(n/k) <ref type="bibr" target="#b27">[28]</ref>. The key is that unlike a small instantaneous diameter, these properties guarantee that a large number of new nodes are causally influenced by each node in each round. In general we can state the following. Lemma 3.1. Let G = (V, E) be dynamic graph such that for every round r, the static graph G(r) has vertex growth g. The dynamic diameter of G is at most 2d, where d is the smallest integer such that g (d) (1) &gt; n/2.</p><p>Proof sketch. We must show that for any two nodes u, v ∈ V and time t ≥ 0, we have (u, t) (v, t + 2d). The vertex growth of G tells us that at first, the set of nodes causally influenced by u grows quickly. Formally, let</p><formula xml:id="formula_2">U t := {w ∈ V | (u, t)</formula><p>(w, t )} denote the set of nodes causally influenced at time t by the state of u at time t (see Fig. <ref type="figure" target="#fig_4">2</ref>). If |U t | ≤ n/2, then the vertex growth of G guarantees that at least g(|U t |) edges cross the cut between U t and V \ U t ; therefore, the causal influence of u spreads to at least g(|U t |) new nodes, and (1) (|U t |). This process continues until we reach a time t where |U t | &gt; n/2; because we chose d so that g (d) (1) &gt; n/2, we have</p><formula xml:id="formula_3">|U t +1 | ≥ |U t | + g(|U t |) = g</formula><formula xml:id="formula_4">|U d | &gt; n/2.</formula><p>Once the causal influence of u has reached n/2 nodes, we can no longer apply vertex growth to show that it continues to spread quickly. Instead, we now turn our attention to node v, and consider the inverse question: how many nodes causally influence v at time t + 2d?</p><formula xml:id="formula_5">Let V t := {w ∈ V | (w, t ) (v, t + 2d</formula><p>)} denote the nodes whose state at time t influences v at time t + 2d. We trace the growth of this set going back in time starting from time t + 2d. Just as before, as long as   first round, and in each round this message is re-broadcast by all nodes that know it (that is, all nodes that have heard it in the past), then n -1 rounds are required for the message to reach node n -1 (in Fig. <ref type="figure" target="#fig_1">1</ref>, node 3 does not receive the message until round 3). The dynamic diameter of the network is n -1, even though the instantaneous diameter is always bounded by 2. Some instantaneous properties of the communication graph do translate into bounds on the dynamic diameter. For instance, if the instantaneous graph in each round is a vertex expander, then the dynamic diameter is O(log n); if each instantaneous graph is k-connected, the dynamic diameter is O(n/k) <ref type="bibr" target="#b27">[28]</ref>. The key is that unlike a small instantaneous diameter, these properties guarantee that a large number of new nodes are causally influenced by each node in each round. In general we can state the following. Lemma 3.1. Let G = (V, E) be dynamic graph such that for every round r, the static graph G(r) has vertex growth g. The dynamic diameter of G is at most 2d, where d is the smallest integer such that g (d) (1) &gt; n/2.</p><formula xml:id="formula_6">|V t | ≤ n/2 we have |V t -1 | ≥ g (1) (|V t |). Therefore, |V t+d | &gt; n/2.</formula><p>Proof sketch. We must show that for any two nodes u, v ∈ V and time t ≥ 0, we have (u, t)</p><formula xml:id="formula_7">(v, t + 2d).</formula><p>The vertex growth of G tells us that at first, the set of nodes causally influenced by u grows quickly. Formally, let Consequently, (u, t) (v, t + 2d).</p><formula xml:id="formula_8">U t := {w ∈ V | (u,</formula><p>Similar arguments to the one in Lemma 3.1 have also been applied in slightly different contexts, e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>The dynamic diameter in partially-synchronous networks. The majority of this column discusses synchronous dynamic networks, but we now make a brief foray into partially-synchronous networks. There are many different versions of partial synchrony in the literature; here we are interested in the model where nodes operate in real time (that is, time is modeled as a real number, rather than a natural number), and each node is equipped with a hardware clock, which is subject to some bounded inaccuracy (called clock drift).</p><p>Similar arguments to the one in Lemma 3.1 have also been applied in slightly different contexts, e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b24">25]</ref>. The dynamic diameter in partially-synchronous networks. The majority of this column discusses synchronous dynamic networks, but we now make a brief foray into partially-synchronous networks. There are many different versions of partial synchrony in the literature; here we are interested in the model where nodes operate in real time (that is, time is modeled as a real number, rather than a natural number), and each node is equipped with a hardware clock, which is subject to some bounded inaccuracy (called clock drift). It is also assumed in this setting that messages suffer from unpredictable delay bounded above by U , and that each node broadcasts at least once every ∆H real time units. The dynamic diameter for this partially-synchronous model is defined similarly to the synchronous case: it is an upper bound on the time required for a single message to be flooded throughout the entire network. The technical details of the definition are more complex than for synchronous networks, and we refer to <ref type="bibr" target="#b25">[26]</ref> for the precise definition.</p><p>In <ref type="bibr" target="#b25">[26]</ref> we considered the problem of clock synchronization in this model: the goal is for each node to output a logical clock, such that the logical clocks are always well-synchronized (unlike the hardware clocks, which can drift apart over time). It is well-known that the quality of clock synchronization that can be achieved in a static network is closely related to its diameter: no algorithm can avoid a clock difference of Θ(D) between two distant nodes in the graph, and a clock difference of Θ(log D) even between neighboring nodes <ref type="bibr" target="#b30">[31]</ref>.</p><p>For dynamic graphs, the situation is almost the same, replacing D now by the dynamic diameter. There is, however, an additional caveat: when a new communication link appears, it takes Θ(D) time before the clock difference between its endpoints can be reduced to its final value of Θ(log D). Informally, this adjustment time corresponds to the time it takes for information about the new edge to propagate through the network, so that all nodes can adjust their behavior accordingly. In <ref type="bibr" target="#b25">[26]</ref> we show that in networks with dynamic diameter D, there is a dynamic clock synchronization algorithm that achieves a clock difference of no more than O(D) between any two nodes at any time in the execution, and a clock difference of O(log D) between nodes that remain neighbors of each other for Θ(D) time. The algorithm is based on the optimal static algorithm from <ref type="bibr" target="#b30">[31]</ref>, but it requires very careful handling of new edges, in order to reduce the clock difference on such edges while at the same time not creating large clock differences on "older" edges that have existed for longer than Θ(D) time.</p><p>Figure <ref type="figure" target="#fig_4">2</ref>: Illustration for the proof of Lemma 3.1, with n = 9 and t = 0. Each instantaneous graph is 2-connected (vertex growth 2), the smallest d satisfying g (d) &gt; 9/2 is d = 2, and the dynamic diameter is 4. The shaded areas indicate U t for t = 0, 1, 2 in light gray, and V t for t = 2, 3, 4 in darker gray (with U 2 ∩ V 2 = ∅, as argued in the proof). Only edges from nodes in U t for t = 0, 1 and edges into nodes in V t for t = 3, 4 are shown.</p><p>It is also assumed in this setting that messages suffer from unpredictable delay bounded above by U , and that each node broadcasts at least once every ∆H real time units. The dynamic diameter for this partiallysynchronous model is defined similarly to the synchronous case: it is an upper bound on the time required for a single message to be flooded throughout the entire network. The technical details of the definition are more complex than for synchronous networks, and we refer to <ref type="bibr" target="#b25">[26]</ref> for the precise definition.</p><p>In <ref type="bibr" target="#b25">[26]</ref> we considered the problem of clock synchronization in this model: the goal is for each node to output a logical clock, such that the logical clocks are always well-synchronized (unlike the hardware clocks, which can drift apart over time). It is well-known that the quality of clock synchronization that can be achieved in a static network is closely related to its diameter: no algorithm can avoid a clock difference of Θ(D) between two distant nodes in the graph, and a clock difference of Θ(log D) even between neighboring nodes <ref type="bibr" target="#b30">[31]</ref>.</p><p>For dynamic graphs, the situation is almost the same, replacing D now by the dynamic diameter. There is, however, an additional caveat: when a new communication link appears, it takes Θ(D) time before the clock difference between its endpoints can be reduced to its final value of Θ(log D). Informally, this adjustment time corresponds to the time it takes for information about the new edge to propagate through the network, so that all nodes can adjust their behavior accordingly. In <ref type="bibr" target="#b25">[26]</ref> we show that in networks with dynamic diameter D, there is a dynamic clock synchronization algorithm that achieves a clock difference of no more than O(D) between any two nodes at any time in the execution, and a clock difference of O(log D) between nodes that remain neighbors of each other for Θ(D) time. The algorithm is based on the optimal static algorithm from <ref type="bibr" target="#b30">[31]</ref>, but it requires very careful handling of new edges, in order to reduce the clock difference on such edges while at the same time not creating large clock differences on "older" edges that have existed for longer than Θ(D) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Diameter of Markovian Dynamic Graphs</head><p>Using an argument along the lines of Lemma 3.1, we can derive a bound for the most simple Markovian dynamic graphs. Assume that in each round r, G(r) is a random graph G n,p for some given parameter p; that is, in every round r, every possible edge is present independently with probability p. What is the expected vertex growth of G n,p ? For any node set S ⊆ V of size |S| = s, the probability that a given node v ∈ S is not connected to S is (1p) s (this is the probability that all s potential edges connecting v to S do not exist). This holds for each of the ns nodes in V \ S. Thus we obtain</p><formula xml:id="formula_9">E |N (S)| = (n -s) 1 -(1 -p) s &gt; (n -s) 1 -e -ps ≥ (n -s) min {1, ps} 2 .</formula><p>We therefore have g(s) = Ω n • min {1, ps} "in expectation." Plugging into Lemma 3.1 would lead to a dynamic diameter of O log 1+np (n) . Using standard probability-theoretic arguments, it can be shown that indeed this is true with high probability (w.h.p.). Note that for p = Ω(1)/n, we get a logarithmic dynamic diameter; even though the graph is not connected in each round w.h.p. (as p is below the connectivity threshold), still over O(log n) rounds every node causally influences every other node w.h.p. For constant p, the dynamic diameter becomes a constant. (Closely related to the dynamic diameter of a sequence of independent random graphs is the basic problem of spreading a rumor by a push-pull gossip protocol, as introduced in <ref type="bibr" target="#b24">[25]</ref>. In such protocols each node chooses a random neighbor to connect to, which induces an independent random graph for that round.) In <ref type="bibr" target="#b10">[11]</ref>, Clementi et al. show that the above result generalizes to Markovian dynamic graphs with birth rate p. In addition, they give lower bound on the dynamic diameter for that case. Theorem 3.2. <ref type="bibr" target="#b10">[11]</ref> For all 0 ≤ p, q ≤ 1, the dynamic diameter of a Markovian dynamic graph with birth rate p and any death rate q is at most O log 1+pn n , independent of q and the initial graph G(0). If G(0) is empty and p ≥ ln(n)/n is above the connectivity threshold of the random graph G n,p , this result is asymptotically tight. For general p &gt; 0, the dynamic diameter is lower bounded by Ω(log(n)/(np)).</p><p>Proof Sketch. The upper bound can be shown as for the simpler case where the graph is an independent random graph G n,p in each round. To see this, consider two consecutive rounds r and r + 1. For an edge e ∈ E(r -1), the probability that e ∈ E(r) is p; for an edge e ∈ E(r -1), the probability that e ∈ E(r) ∪ E(r + 1) is (1q) + qp ≥ p. Hence, in the union of any two consecutive rounds, each edge independently occurs with probability at least p. It follows that the dynamic diameter of a Markovian random graph with birth rate p is at most twice as large as the dynamic diameter when the graph in each round is an independent random graph G n,p . We have already seen above that the dynamic diameter of such dynamic graphs is w.h.p. O log 1+pn n .</p><p>For the lower bound, we note that if E(0) = ∅, the union of the instantaneous graphs in the first d rounds is itself a (static) random graph G n,p , where p = 1 -(1p) d (the probability that an edge never appears in d rounds). If p ≥ ln(n)/n and d = Θ(log np (n)), then the diameter of this random graph is Θ(log np n) = Θ(log np n) <ref type="bibr" target="#b6">[7]</ref>. This implies that the diameter of the dynamic graph is Ω(log np (n)), because in the first d rounds a node can only causally influence nodes at distance at most d from it in the union of the graphs during those d rounds. A somewhat similar, but more involved argument can be made for the case np &lt; ln n. For details, we refer to <ref type="bibr" target="#b10">[11]</ref>.</p><p>Subsequent work in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15]</ref> analyzes the flooding time of Markovian random graphs with birth rate p and death rate q in the stationary distribution. In that case, the graphs in all rounds are random graphs G n,p with edge probability p = p/(p + q). If p &gt; ln(n)/n, i.e., if p is above the connectivity threshold, w.h.p., the dynamic diameter is Θ(np/ log(np)) and thus asymptotically equal to the diameter of G n,p . The same bound holds for 1 p &lt; ln(n)/n and np ≥ ln(np), whereas for all other values of p, the dynamic diameter becomes Θ(log(n)/(np)).</p><p>Clementi et al. have also studied the flooding time of random dynamic geographic graphs <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>. Specifically, in <ref type="bibr" target="#b13">[14]</ref>, they consider a simple variant of the random way-point model. Nodes are located in a square of side length L. Two nodes are connected by an edge whenever they are at distance at most R. Each node chooses a random destination in the square and moves there with a fixed constant speed s, either by first moving horizontally and then vertically, or by first going vertically and then horizontally. In such a scenario, the network is much denser in the center of the square than in the corners. In <ref type="bibr" target="#b13">[14]</ref>, it is shown that for sufficiently dense networks (average degree Ω(log n)) and moderate speeds (O(1) communication radii per time unit), the dynamic diameter of such networks is O(L/R + L 3 log(n)/(sR 2 n)). Note that the required average degree does not guarantee connectivity at each time. Furthermore, the given speed limitation gives an Ω(L/R) lower bound on the dynamic diameter. The authors point out that there are interesting settings for the parameter values for which the dynamic diameter is strictly larger than O(L/R).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Computing in Adversarial Dynamic Graphs</head><p>In <ref type="bibr" target="#b27">[28]</ref> we considered the problem of general computation in adversarial dynamic graphs, under fairly minimalistic assumptions (some basic results in that direction also appeared in <ref type="bibr" target="#b33">[34]</ref>). We assumed that the dynamic graph is always connected (that is, it is 1-interval connected), but nodes do not know in each round what their edges for that round will be; in every round each node generates a message to broadcast, and the adversary then chooses edges for that round and delivers the message to all the sender's neighbors. Further, we assumed that nodes do not initially know the size n of the network, but they do have unique identifiers (UIDs). We asked whether nodes can accomplish tasks such as leader election, determining the number n of nodes in the network, and information dissemination.</p><p>Let us say that at time t, node u has heard from node v if (v, 0) (u, t). A 1-interval connected graph has vertex growth at least 1; therefore, at time t &lt; n, each node has heard from at least t + 1 nodes (see Lemma 3.1). If nodes can send large messages, then there is a simple way to determine n. In each round, we have all nodes forward all the UIDs they have heard so far; let A u (t) denote the set of UIDs collected by node u by time t. At time t, if |A u (t)| = t, then node u halts and outputs t as the count, and if desired, A u (t) as the set of UIDs participating in the computation. How do we know, when |A u (t)| = t, that t = n and A u (t) = V ? Simple: if t &lt; n, then as mentioned above, at time t node u must have heard from at least t + 1 nodes; the UIDs of all these nodes are in A u (t), and hence |A u (t)| &gt; t. In particular, node u cannot stop if t &lt; n. On the other hand, at time n we have</p><formula xml:id="formula_10">|A u (t)| ≥ |A u (n -1)| = n; consequently A u (n) = V ,</formula><p>and at time n node u stops and outputs n. At that time nodes can also elect a leader using some global decision rule (e.g., the smallest UID), or compute functions of the initial states of the participants, if the initial states are forwarded along with the UIDs.</p><p>What if nodes cannot send everything they know in every message? In <ref type="bibr" target="#b27">[28]</ref> we show that full information dissemination can be achieved even if only a constant number of UIDs and initial inputs can be sent in each message.</p><p>Suppose that our goal is to have each node compute an upper bound on the count (we will return to exact counting and full information dissemination later). We solve this problem via an intermediary problem that we call k-committee. In the k-committee problem the nodes must partition themselves into committees (that is, each node outputs a committee ID), such that (a) Each committee contains no more than k nodes (but can contain fewer than k nodes), and (b) If k ≥ n, then there is only one committee containing all the nodes. The k-committee problem is equivalent to the problem of computing (an upper bound on) the count. One direction is trivial: if the nodes known n, then they can solve k-committee by each forming a singleton committee if k &lt; n, and all joining one default committee if k ≥ n. The other direction is more interesting: if we start from a valid solution for k-committee, we can check whether or not k ≥ n using a quick k-round verification protocol.</p><p>In the verification protocol a node can have two states: positive or negative. Initially all nodes are positive. In each round, positive nodes broadcast their own committee ID, and negative nodes send ⊥, a special value that differs from all committee IDs. If a positive node hears ⊥ or a committee ID that differs from its own, it becomes negative, and remains negative thereafter. After k rounds, all positive nodes output "k ≥ n", and negative nodes output "k &lt; n".</p><p>To see the correctness of this protocol, suppose first that k ≥ n. In this case there can only be one committee, so no node ever hears a different committee ID from its own. After k rounds, all nodes are still positive, and all output "k ≥ n". Next, suppose that k &lt; n, and consider some committee c. In each round, if we look at the cut between the members of committee c that are still positive (if any remain) and the rest of the graph, this cut must contain at least one edge, and the endpoint that is not a positive member of c sends on that edge a value that differs from c (either ⊥ or some other committee ID). Therefore some member of c "drops out" and becomes negative. Thus, in each round where not all members of c are negative, at least one new member becomes negative. Since committee c can initially contain at most k members, after k rounds all members are negative, and all output "k &lt; n". This holds for all committees and therefore for all nodes in the graph.</p><p>Using the verification protocol we can compute an upper bound on the count: for each k = 1, 2, 4, 8, . . ., we solve k-committee election, then run the verification protocol to check if k ≥ n. But how do we solve k-committee using only small messages? Our strategy is to use k as a guess for the count, and try to elect k nodes for each committee. We rely on the following observation:</p><p>• If k ≥ n, then the dynamic diameter of the graph is at most k -1 (Lemma 3.1), so k -1 rounds are sufficient for one node u to "invite" any other node v to join its committee, provided that all nodes forward u's invitation when they receive it.</p><p>• On the other hand, if k &lt; n, then we really do not have to guarantee much; invitations can fail to reach their destination, but all we have to ensure is that no more than k nodes join each committee.</p><p>(Recall that if k &lt; n then even having each node form its own committee is a valid solution.)</p><p>We proceed as follows.</p><p>(1) First, for k -1 rounds, each node forwards the smallest UID it has heard so far. At the end of the k -1 rounds, any node that has not heard a smaller UID than its own elects itself as a leader of a committee (using its own UID for the committee ID). Each leader immediately joins its own committee. Notice that if k ≥ n, then all nodes hear the smallest UID, and there is only one leader.</p><p>(2) Next, the nodes repeat the following k -1 times:</p><p>(a) For k -1 rounds, all nodes forward the smallest UID of a node that has not joined a committee yet.</p><p>(b) Each leader selects the smallest UID it has heard in (a), and issues an invitation to this node to join its committee. The invitation is a message carrying the leader's UID and the UID of the invited node.</p><p>(c) For k -1 rounds, all nodes forward the invitations they hear; if a node hears invitations from more than one leader, it chooses which one to forward arbitrarily (or just forwards none of them).</p><p>(d) Each node that receives an invitation addressed to itself in (c) joins the committee of the node that invited it. If a node is invited to join more than one committee, it chooses arbitrarily.</p><p>Since each node can only invite at most k -1 other nodes to join its committee, the size of each committee is at most k. If k ≥ n, then we have just one leader, whose invitations all reach their destinations; in k -1 ≥ n -1 cycles this leader successfully identifies and invites all the other nodes in the graph. Notice that when k ≥ n, each node has n -1 rounds where it is "singled out" and has its UID forwarded to all nodes in the graph. If nodes remember all the UIDs they hear, they can collect the UIDs of all the participants this way; if nodes have initial inputs, they can attach them to their UIDs, and in this manner we can achieve full information dissemination and exact counting.</p><p>The protocol above requires O(n 2 ) rounds for full information dissemination in 1-interval connected graphs. If the graph enjoys good expansion, then it can take fewer than n -1 rounds to invite each node, and the process can be sped up; if the graph is T -interval connected for T &gt; 1, then we can pipeline invitations and invite T nodes in O(n) rounds, gaining a factor of T in the round complexity. We refer to <ref type="bibr" target="#b27">[28]</ref> for the full details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Dynamic Radio Networks</head><p>An important application domain for dynamic network algorithms is wireless mobile ad hoc networks. When communication occurs via wireless radio, the communication model used in the previous sections does not directly apply any more; because all messages are sent over the same shared wireless medium, messages from different senders can collide and interfere. This characteristic is captured by the radio network model as for example defined in <ref type="bibr" target="#b3">[4]</ref>. A message sent by some node u reaches all of u's neighbors. A neighbor v can decode the message if and only if no other neighbor of v transmits a message at the model as defined (for example) in <ref type="bibr" target="#b3">[4]</ref>. Furthermore, it is typically assumed that a receiver cannot distinguish a message collision from silence.</p><p>Consider the basic problem of broadcasting a single message throughout the network. Assume that we have a synchronous dynamic graph G = (V, E) that is not necessarily connected in every round, and that some source node s ∈ V has a message to broadcast. We say that a node is informed if it already received the message.</p><p>In <ref type="bibr" target="#b11">[12]</ref>, it is assumed that in every round, there is some uninformed node v connected to some set of nodes that already know the message. (Note that this requirement on the dynamic graph adversary depends on the algorithm in question, and even on the specific execution of the algorithm. However, it is implied by 1-interval connectivity.) A simple randomized protocol for broadcast, given in <ref type="bibr" target="#b11">[12]</ref>, is to have each informed node transmit the message with probability p in each round. If an uninformed node v is connected to k informed nodes, the probability that it successfully receives the message is kp(1p) k-1 (the probability that one informed neighbor broadcasts and the rest do not). If we choose p = ln(n)/n, this success probability is Θ(log n/n) independent of k. Since at most n -1 hops are required to reach all nodes, the broadcast completes in O(n 2 / log n) rounds w.h.p. In <ref type="bibr" target="#b11">[12]</ref> it is also shown that there is an adaptive adversary for which this bound is tight.</p><p>An interesting speed-up can be achieved if we assume that the dynamic graph G = (V, E) is more stable. If G is ∞-interval connected, i.e., if there is a connected spanning sub-graph that is stable, we have shown in <ref type="bibr" target="#b26">[27]</ref> that broadcast is possible in almost-linear time. To do this we have nodes that have known the message for Θ(t log n) rounds transmit with probability roughly 1/t, and we show that broadcast is completed in O(n log 2 n) rounds w.h.p. The main idea is the following: there is always some node v at the boundary between informed and uninformed nodes in the stable sub-graph. Whenever node v transmits alone among all the nodes in the network, the algorithm makes progress. Intuitively, in order to delay this kind of progress for a long time, the adversary has to allow the message to reach many additional nodes, so that these nodes will interfere and cause collisions whenever v transmits. Because broadcast probabilities decay with time, we can argue that either node v broadcasts alone, or many other nodes recently received the message, and in both cases the algorithm makes amortized progress.</p><p>In <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b26">27]</ref> it is also shown that in ∞-connected dynamic radio networks, broadcast can be solved deterministically. If the nodes have unique identifiers from a space of size O(n), the respective bounds are Ω(n 3/2 ) <ref type="bibr" target="#b12">[13]</ref> and O(n 3/2 √ log n) <ref type="bibr" target="#b26">[27]</ref>. Note that if we drop the ∞-interval connectivity requirement, an adaptive adversary can prevent the broadcast message from ever reaching more than two nodes.</p><p>Finally, Clementi et al. study radio network broadcast in random dynamic graphs in <ref type="bibr" target="#b11">[12]</ref>. If for some fixed and generally known parameter 1/n ≤ p ≤ 1, the graph for each round is an independent random graph G n,p , they show that the time to do broadcast is Θ(log n). If p is not known to the algorithm, it has to guess different values for p, at the cost of a logarithmic factor in the overall performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Other Models for Dynamic Networks and Dynamic Network Algorithms</head><p>In this section we briefly survey several alternatives to the models we discussed in this column. This section is not intended as a comprehensive survey; for brevity, we only list a few of the prominent alternatives, and give only one or two examples of each approach.</p><p>Liveness and termination. The algorithms we focused on in this column always terminate, even when the network changes continually. There are (at least) two popular alternative modes of computation.</p><p>The first alternative is to use self-stabilizing algorithms. The basic assumption here is that changes are bounded in time and eventually cease, or that changes are infrequent enough that the algorithm can stabilize between them. While changes continue to occur, the algorithm can behave badly; however, if changes cease for sufficiently long, a self-stabilizing algorithm will eventually gravitate to a correct configuration and resume normal operation. We refer to <ref type="bibr" target="#b15">[16]</ref> for a comprehensive treatment of self-stabilizing algorithms. Some algorithms provide a two-part correctness guarantee: a safety guarantee, which holds even while the network is dynamic, and a liveness (or termination) guarantee, which only holds when the network stops changing. For example, algorithms based on Gafni and Bertsekas' link reversal algorithm from <ref type="bibr" target="#b18">[19]</ref> frequently have this flavor; the link reversal algorithm eventually orients a directed network so that all nodes have a path to some fixed sink node, but the time required is Θ(n 2 ) rounds <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b8">9]</ref>, and during this time nodes cannot necessarily route messages to the sink. One example that uses link-reversal is <ref type="bibr" target="#b36">[37]</ref>, which gives a mutual exclusion algorithm in which nodes pass a single token among themselves to determine who can enter the critical section; link reversal is used to route the token from node to node. Safety (mutual exclusion) is always guaranteed because only one node has the token, but liveness (in this case starvationfreedom) is only guaranteed when the network stops changing.</p><p>A second alternative to always-terminating computation is eventually stabilizing computation. Here it is not assumed that the network eventually stops changing. However, the algorithm never terminates; instead, the outputs of the nodes are continually updated, and they eventually stabilize to a correct answer. (Note that the nodes themselves do not know when a correct answer has been reached, so nodes cannot stop executing the algorithm.) A prominent example is population protocols <ref type="bibr" target="#b0">[1]</ref>, where participants are anonymous and have finite (uniformly-bounded) memory; in this model it is possible to have the nodes' outputs stabilize to any semi-linear predicate of the inputs (see <ref type="bibr" target="#b1">[2]</ref> for a survey on population protocols).</p><p>Dynamic overlay networks. The models we discussed here assume that the network topology is completely adversarially controlled. There is a vast literature on algorithms that choose the communication topology themselves, typically in the form of an overlay network that the algorithm superimposes on an underlying fully-connected network. One very popular application domain is peer-to-peer protocols, where participants must maintain a small number of connections to peers they select, e.g., <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36]</ref>. The algorithm must deal with nodes joining and leaving the network (churn) by adjusting the overlay network. Examples of protocols that deal with continual concurrent joins and leaves controlled by an adaptive worst-case adversary are given, for instance, in <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b31">32]</ref>. In the examples given above, the overlay changes only as a response to changes in the set of participating peers; other algorithms, such as those given in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b32">33]</ref>, induce a constantly-changing overlay even when the set of participants remains static.</p><p>Geographic models. Much of the work on dynamic networks is motivated by an underlying distribution of the nodes on the two-or three-dimensional plane, with some geometric constraint governing which nodes have a communication link to each other (perhaps the most popular assumption is that only nodes within some fixed distance of each other can directly communicate). From time to time the nodes change their positions according to some mobility pattern, either adversarially controlled or random (e.g., the random way-point model <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b29">30]</ref>; we discussed one variant of this model in Section 3.2). We refer to <ref type="bibr" target="#b9">[10]</ref> for a survey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this column we briefly surveyed several models for dynamic networks. The main characteristic shared by these models is that they do not assume that the network stops changing at some point, and they do not restrict the number or frequency of changes. Nevertheless, recent results show that always-terminating computation is possible in such networks, even when the network is adversarially controlled.</p><p>There are many open research questions in dynamic networks. One major concern is dealing with node failures, or with nodes joining and leaving the network; most of the algorithms we discussed here are not resilient to such changes. For example, in some of the network-wide broadcast algorithms described in Section 5, nodes stop forwarding the message after a certain number of rounds. At some points in the execution there might only be a few nodes still forwarding the message, and if these nodes were to crash, the broadcast would fail. Can broadcast algorithms be made resilient to node crashes, while still completing in a timely manner and allowing nodes to eventually stop sending? As another example, the information dissemination algorithm from Section 4 cannot withstand node failures, nor can it handle new nodes joining the network. Can information dissemination be solved in networks that enjoy good vertex growth (e.g., networks that are always k-connected), despite changes to the set of nodes participating in the computation?</p><p>Another interesting direction is testing and adapting to network conditions. Throughout this column we saw that if the network enjoys good expansion or long-term stability, algorithms can be made to run faster. But how do we know if the network is a good expander, or even if it is 1-interval connected? How do we know if it is fairly stable over time? Lightweight tests for such properties, which can run alongside an algorithm and inform it of the condition of the network in the recent past, could allow algorithms to take advantage of a well-behaved network.</p><p>In general, it seems that a promising direction for dynamic network algorithms is to cope with the worst, and hope for the best: an algorithm should be able to withstand a badly-behaved and highly dynamic network topology, and always guarantee correctness and termination, albeit not necessarily good performance; if the network is well-behaved for a period of time (e.g., it enjoys some stability, or has good expansion), the algorithm should take advantage of this to improve its performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure1: The dynamic star graph from<ref type="bibr" target="#b2">[3]</ref> with n = 4. Self-loops are generally not shown. Bold nodes and edges indicate the shortest walk from node 0 to node 3 in the dynamic graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>4</head><label>4</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 1 :</head><label>1</label><figDesc>Figure1: The dynamic star graph from<ref type="bibr" target="#b2">[3]</ref> with n = 4. Self-loops are generally not shown. Bold nodes and edges indicate the shortest walk from node 0 to node 3 in the dynamic graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure2: Illustration for the proof of Lemma 3.1, with n = 9 and t = 0. Each instantaneous graph is 2-connected (vertex growth 2), the smallest d satisfying g (d) &gt; 9/2 is d = 2, and the dynamic diameter is 4. The shaded areas indicate U t for t = 0, 1, 2 in light gray, and V t for t = 2, 3, 4 in darker gray (with U 2 ∩ V 2 = ∅, as argued in the proof). Only edges from nodes in U t for t = 0, 1 and edges into nodes in V t for t = 3, 4 are shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>But now we are done: since |U t+d | &gt; n/2 and |V t+d | &gt; n/2, there is some node in the intersection, w ∈ U t+d ∩ V t+d .</figDesc><table><row><cell>both (u, t)</cell><cell>(w, t + d) and (w, t + d)</cell><cell>(v, t + 2d). Consequently, (u, t)</cell><cell>(v, t + 2d).</cell><cell>This node satisfies</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Once the causal influence of u has reached n/2 nodes, we can no longer apply vertex growth to show that it continues to spread quickly. Instead, we now turn our attention to node v, and consider the inverse question: how many nodes causally influence v at time t + 2d? Let V</figDesc><table /><note><p><p><p><p><p><p><p><p><p><p>t) (w, t )} denote the set of nodes causally influenced at time t by the state of u at time t (see Fig.</p>2</p>). If |U t | ≤ n/2, then the vertex growth of G guarantees that at least g(|U t |) edges cross the cut between U t and V \ U t ; therefore, the causal influence of u spreads to at least g(|U t |) new nodes, and</p>|U t +1 | ≥ |U t | + g(|U t |) = g</p>(1) </p>(|U t |). This process continues until we reach a time t where |U t | &gt; n/2; because we chose d so that g</p>(d) </p>(1) &gt; n/2, we have</p>|U d | &gt; n/2. t := {w ∈ V | (w, t ) (v,</p>t + 2d)} denote the nodes whose state at time t influences v at time t + 2d. We trace the growth of this set going back in time starting from time t + 2d. Just as before, as long as |V t | ≤ n/2 we have |V t -1 | ≥ g (1) (|V t |). Therefore, |V t+d | &gt; n/2. But now we are done: since |U t+d | &gt; n/2 and |V t+d | &gt; n/2, there is some node in the intersection, w ∈ U t+d ∩V t+d . This node satisfies both (u, t) (w, t+d) and (w, t+d) (v, t+2d).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>March 2011, vol. 42, no. 1</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>ACM SIGACT News</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement. The authors would like to thank the Editor, Idit Keidar, for many insightful comments and suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Computation in networks of passively mobile finite-state sensors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Angluin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Diamadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Peralta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 23rd ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 23rd ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="290" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An introduction to population protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ruppert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Middleware for Network Eccentric and Mobile Applications</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Garbinato</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Miranda</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Rodrigues</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="97" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">How to explore a fast-changing world (cover time of a simple random walk on evolving graphs)</title>
		<author>
			<persName><forename type="first">C</forename><surname>Avin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koucký</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lotker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 35th Coll. on Automata, Languages and Programming (ICALP)</title>
		<meeting>of 35th Coll. on Automata, Languages and Programming (ICALP)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the time-complexity of broadcast in multi-hop radio networks: An exponential gap between determinism and randomization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bar-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Itai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="104" to="126" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Parsimonious flooding in dynamic graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Crescenzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fraigniaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 28th ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 28th ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="260" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The node distribution of the random waypoint mobility model for wireless ad hoc networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bettstetter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Resta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Santi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="257" to="269" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The diameter of random graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollobás</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">267</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="52" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Brahms: Byzantine resilient random membership sampling</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bortnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Keidar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kliot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shraer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="2340" to="2359" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Analysis of link reversal routing algorithms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Busch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tirthapura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. on Computing</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="305" to="326" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A survey of mobility models for ad hoc network research</title>
		<author>
			<persName><forename type="first">T</forename><surname>Camp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Boleng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Davies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wireless Communication and Mobile Computing</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="483" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Flooding time in edge-Markovian dynamic graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clementi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Macci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pasquale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Silvestri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 27th ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 27th ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="213" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Broadcasting in dynamic radio networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clementi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pasquale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Silvestri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="213" to="230" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Round robin is optimal for fault-tolerant broadcasting on wireless networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clementi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Silvestri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Parallel and Distribited Computing</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="96" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast flooding over Manhattan</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clementi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Silvestri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 29th ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 29th ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="375" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Information spreading in stationary Markovian evolving graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clementi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pasquale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Silvestri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symp. on Parallel &amp; Distributed Processing</title>
		<meeting>of IEEE Symp. on Parallel &amp; Distributed essing</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Self-stabilization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dolev</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Building a reference combinatorial model for MANETs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network Magazine</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="24" to="29" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Performance evaluation of routing protocols for MANETs with known connectivity patterns using evolving graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Monteiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wireless Networks</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="627" to="640" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Distributed algorithms for generating loop-free routes in networks with frequently changing topology</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Gafni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Bertsekas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="11" to="18" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">SCAMP: Peer-to-peer lightweight membership service for large-scale group communication</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-M</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Massoulié</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="44" to="55" />
		</imprint>
		<respStmt>
			<orgName>Networked Group Communication</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Evolving graphs: dynamical models, inverse problems and propagation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Grindrod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Higham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. of the Royal Society A: Mathematical, Physical and Engineering Sciences</title>
		<imprint>
			<biblScope unit="volume">466</biblScope>
			<biblScope unit="page" from="753" to="770" />
			<date type="published" when="2009">2115. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Correctness of gossip-based membership under message loss</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Keidar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. of Computing</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="3830" to="3859" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Random graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Janson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Łuczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rucinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wiley-Interscience Series in Discrete Mathematics and Optimization</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley-Interscience</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Dynamic source routing in ad hoc wireless networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mobile Computing, chapter 5</title>
		<imprint>
			<publisher>Kluwer Academic</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="153" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Randomized rumor spreading</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schindelhauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vöcking</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 41st Symp. on Foundations of Computer Science (FOCS)</title>
		<meeting>of 41st Symp. on Foundations of Computer Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="565" to="574" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Optimal gradient clock synchronization in dynamic networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lenzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Locher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oshman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 29th ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 29th ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="430" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Broadcasting in unreliable radio networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Newport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Richa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 29th ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 29th ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="336" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Distributed computation in dynamic networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oshman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 42nd Symp. on Theory of Computing (STOC)</title>
		<meeting>of 42nd Symp. on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="513" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A self-repairing peer-to-peer system resilient to dynamic adversarial churn</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 4th Int. Workshop on Peer-To-Peer Systems (IPTPS)</title>
		<meeting>of 4th Int. Workshop on Peer-To-Peer Systems (IPTPS)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The random trip model: Stability, stationarity regime, and perfect simulation</title>
		<author>
			<persName><forename type="first">J.-Y. Le</forename><surname>Boudec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vojnovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1153" to="1166" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Tight bounds for clock synchronization</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lenzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Locher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 28th ACM Symp. on Principles of Distributed Computing (PODC)</title>
		<meeting>of 28th ACM Symp. on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="46" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Maintaining the ranch topology</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Plaxton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1142" to="1158" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Peer-to-peer networks based on random transformations of connected regular undirected graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mahlmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schindelhauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 17th ACM Symp. on Parallelism in Algorithms and Architectures (SPAA)</title>
		<meeting>of 17th ACM Symp. on Parallelism in Algorithms and Architectures (SPAA)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="155" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Information dissemination in highly dynamic graphs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">O</forename><surname>Dell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Workshop on Foundations of Mobile Computing (DIALM-POMC)</title>
		<meeting>of Workshop on Foundations of Mobile Computing (DIALM-POMC)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="104" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Accessing nearby copies of replicated objects in a distributed environment</title>
		<author>
			<persName><forename type="first">C</forename><surname>Plaxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Richa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 9th ACM Symp. on Parallel Algorithms and Architectures (SPAA)</title>
		<meeting>of 9th ACM Symp. on Parallel Algorithms and Architectures (SPAA)</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="311" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Chord: A scalable peer-to-peer lookup service for internet applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Conference on Applications</title>
		<meeting>ACM SIGCOMM Conference on Applications</meeting>
		<imprint>
			<publisher>Architectures, and Protocols for Computer Communications</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Technologies</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A mutual exclusion algorithm for ad hoc mobile networks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Walter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Welch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Vaidya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wireless Networks</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="585" to="600" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
