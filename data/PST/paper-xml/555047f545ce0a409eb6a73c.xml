<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CoREBench: Studying Complexity of Regression Errors</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Marcel</forename><surname>Böhme</surname></persName>
							<email>marcel.boehme@acm.org</email>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Abhik</forename><surname>Roychoudhury</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">CoREBench: Studying Complexity of Regression Errors</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D3D430CC461B79E8E4AE56947DC1178A</idno>
					<idno type="DOI">10.1145/2610384.2628058</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.5 [Software Engineering] Testing and Debugging Theory</term>
					<term>Measurement</term>
					<term>Experimentation Error Complexity</term>
					<term>Coupling Effect</term>
					<term>Regression</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Intuitively we know, some software errors are more complex than others. If the error can be fixed by changing one faulty statement, it is a simple error. The more substantial the fix must be, the more complex we consider the error.</p><p>In this work, we formally define and quantify the complexity of an error w.r.t. the complexity of the error's least complex, correct fix. As a concrete measure of complexity for such fixes, we introduce Cyclomatic Change Complexity which is inspired by existing program complexity metrics.</p><p>Moreover, we introduce CoREBench, a collection of 70 regression errors systematically extracted from several opensource C-projects and compare their complexity with that of the seeded errors in the two most popular error benchmarks, SIR and the Siemens Suite. We find that seeded errors are significantly less complex, i.e., require significantly less substantial fixes, compared to actual regression errors. For example, among the seeded errors more than 42% are simple compared to 8% among the actual ones. This is a concern for the external validity of studies based on seeded errors and we propose CoREBench for the controlled study of regression testing, debugging, and repair techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Software errors can be arduous. Their fixes can account for half of the code changes even in well-tested software <ref type="bibr" target="#b4">[4]</ref>. Before they are fixed, they can remain in the program for many years, causing problems for the software users. When they are fixed, these fixes can introduce even further errors.</p><p>Related processes can be automated based on our understanding of the inherent nature of software errors. Testing techniques seek to expose errors; debugging techniques seek to determine the faulty source code for an error; and repair techniques seek to fix the faulty source code.</p><p>* The first author conducted this work while at NUS.</p><p>Two properties of errors are complexity and detectability. While the complexity of an error is determined by how substantial the error's fix is required to be, the detectability of an error is determined by the amount of input exposing the error. Intuitively, an error that is hard to detect may still require only a simple fix. Offutt <ref type="bibr" target="#b24">[24]</ref> relates both properties and conjectures: the detectability of simple faults is similar to the detectability of complex faults -the coupling effect hypothesis. He defines simple faults as ones that can be fixed by changing one statement while complex faults cannot.</p><p>In this paper, we are the first to quantify error complexity and formally define the term and a metric. The complexity of an error is determined by the complexity of the correct, least complex fix of the error. The fix must be correct because no other errors should be introduced and least complex because even Offutt's simple faults can be fixed in multiple ways, including a complete revision of the program.</p><p>To measure the complexity of a fix, we formally define software change complexity and introduce a concrete change complexity metric -Cyclomatic Change Complexity (CyCC), which is inspired by McCabe's cyclomatic program complexity metric <ref type="bibr" target="#b20">[20]</ref>. Program complexity is a measure of the interactions among the various elements of the software. Similarly, we define the change complexity as a measure of the interaction among the various changed elements in the changed software. We give an efficient algorithm to compute CyCC.</p><p>Equipped with our novel error complexity metric we set out to learn about the nature of complex regression errors. The two most popular benchmarks for experimentation with regression errors are the Siemens Suite <ref type="bibr" target="#b13">[13]</ref> and SIR <ref type="bibr">[9]</ref>. In both cases, most errors were introduced through a process called fault seeding. Developers were asked to change the given programs slightly such that they contain errors of varying detectability. However, we were not certain about a varying complexity of the seeded errors and constructed our own benchmark to compare to actual regression errors.</p><p>In this paper, we introduce CoREBench as a collection of 70 regression errors and compare the complexity of these to the complexity of the seeded ones in the Siemens Suite and SIR. We harvested the regression errors in CoREBench systematically from four widely deployed, well-tested opensource software projects. Indeed, we find that the seeded regression errors are significantly less complex, i.e., require significantly less substantial fixes, compared to the actual regression errors in CoREBench. For example, among the seeded errors more than 42% are simple compared to 8% among the actual ones. This is a concern for the external validity of studies based on such seeded regression errors.</p><p>We apply our error complexity metric to the regression errors in CoREBench in order to experimentally investigate the nature of complex regression errors. Three of our main findings are enumerated in the following:</p><p>• Between the complexity of the change introducing an error and of the change fixing it seems to be no correlation. That is, even simple changes can introduce complex errors. One could say that the cause of a regression error is already dormant in the code and the change merely triggers it. Or, the regression errors may be evolving when the program is and the complexity of errors may change during evolution.</p><p>• Between the complexity and life span 1 of an error seems to be no correlation. That is, even complex errors may be fixed on the same day when they are introduced or a few years later. This may be indirect evidence that simple and complex errors are of similar detectability, i.e., coupled <ref type="bibr" target="#b24">[24]</ref>.</p><p>• Change Interaction Errors (CIEs) 2 require consistently more substantial fixes than other types of regression errors (Non-CIEs). This suggests that CIEs are not only of less detectability <ref type="bibr" target="#b4">[4]</ref> but also of greater complexity than Non-CIEs.</p><p>We define change complexity as a measure of interaction among the changed elements and introduce the CyCC as a concrete metric. Yet, there are other metrics, such as number of Changed Lines of Code (CLoC), paths, or hunks. We study CLoC versus CyCC and find: While both rarely agree on the specific value or rank of a change's complexity, they strongly correlate in general. Basically, both indicate high complexity for substantial change. We believe, CyCC is a precise and practical measure of change complexity.</p><p>In summary, this paper makes the following contributions.</p><p>1. Error Complexity Metric. We formally define and quantify the complexity of an error w.r.t. the complexity of the error's least complex and correct fix. Investigations into error complexity are relevant for software testing, debugging, and repair: What is the root cause of an error that requires a substantial fix? Is a test suite adequate to expose complex errors? How do we correctly and efficiently repair complex errors? 2. Change Complexity Metric. We formally define software change complexity, introduce CyCC as a concrete complexity metric, discuss an algorithm to compute the CyCC efficiently based on a graph containing the control-flow among the changed statements, and make available a tool that computes the CyCC of any C source code commit in under one second on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Regression Error Benchmark. We make available</head><p>CoREBench, a collection of 70 realistically complex regression errors. For each error, we provide the bug report, the error-introducing source code commit, the error-fixing source code commit, and a validating test case that fails for all versions between these commits, but passes before and after. 4. Empirical Study. We study the complexity of actual regression errors and establish that seeded errors in existing benchmarks are significantly less complex. CoREBench and the implementation of CyCC are available at http://www.comp.nus.edu.sg/∼release/corebench. 1 The life span of an error is the time an error is observable from when it is introduced to when it is fixed. 2 A regression error is a CIE <ref type="bibr" target="#b4">[4]</ref> if a sequence of changed statements must be executed in order to expose the error while "skipping" one of them does not expose the error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">AN ERROR COMPLEXITY METRIC</head><p>We define the complexity of an error w.r.t. the complexity of the correct, least complex fix of the error. To measure the complexity of a fix, we formally define software change complexity as a measure of the interaction among the changed elements in a changed program and propose a concrete change complexity metric. Cyclomatic Change Complexity (CyCC) directly measures the number of linearly independent <ref type="foot" target="#foot_0">3</ref>   The simplified code fragment parses a valuestring into an integer value. However, every string containing a negative number is parsed as a positive number. This error is simple because only one statement (in line 359) needs to be changed in order to repair the error. The bug report states that "find does not report symlink loop when trying to follow symlinks". Hence, the developer adds the presented code fragment to describe conditions under which symlink loops need to be reported. The error is complex because it requires three additional conditional statements and several statements to fix it correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Measuring Change Complexity</head><p>Traditional program complexity measures the interaction among the elements in a software system. So, we can define:</p><formula xml:id="formula_0">Definition 1 (Change Complexity )</formula><p>Change complexity is a measure of the interaction among the changed elements in a changed program.</p><p>Note that deleted statements are changed elements nevertheless and can be represented by dummy statements in the changed program (see e.g., <ref type="bibr" target="#b25">[25]</ref>).</p><p>As a concrete measure of change complexity, we introduce CyCC which is computed based on a graph containing the control-flow among the changed basic blocks -the CSG.</p><p>Definition 2 (Change Sequence Graph (CSG) <ref type="bibr" target="#b4">[4]</ref>)</p><p>The change sequence graph of a changed program P ′ is a directed graph containing as vertices the program entry as source, the program exit as sink, and the changed basic blocks in P ′ , with an edge between any two vertices if control may pass from the first to the second without passing through a third.</p><p>The source vertex is connected through an edge to every changed basic block that may be executed first, that is, before some other changed basic block is executed. To the sink vertex is connected every changed basic block that may be executed last, that is, after any other changed basic block is executed. This simplified definition of CSG accounts for all sequences of changed statements that can be exercised but not for potential interaction locations (see <ref type="bibr" target="#b4">[4]</ref>) and can be computed from the changed program's Control Flow Graph. For example, Figure <ref type="figure" target="#fig_2">3</ref> depicts three different CSGs. The paths through a CSG from source to sink represent different sequences of changed statements that may be executed. The CSGs on the left and in the middle are computed for the changed code fragments in Figures <ref type="figure">1</ref> and<ref type="figure">2</ref>. It is interesting to note that the size of the CSG depends only on the size of the changed code and not on the size of the complete program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Cyclomatic Change Complexity )</head><p>The complexity of a set of program changes C is defined with reference to the Change Sequence Graph constructed for C as CyCC = E -N + 2P , where E is the number of edges of the CSG, N is the number of nodes of the CSG, and P is the number of connected components in the CSG.</p><p>Cyclomatic Change Complexity (CyCC) measures the number of linearly independent sequences of changed statements from entry to exit in a changed program. We argue that the changed statements in each sequence may "interact" differently. In fact, some sequences are critical in exposing so called Change Interaction Errors <ref type="bibr" target="#b4">[4]</ref> while others are not. In Figure <ref type="figure" target="#fig_2">3</ref>, based on the number of linearly independent paths in the CSG, we compute a CyCC=1 (left), CyCC=4 (middle), and CyCC=5 (right), respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Measuring Error Complexity</head><p>Before we define and measure the complexity of an error, we quote the IEEE glossary to define what we mean by error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Software Error [15])</head><p>A software error is the difference between a computed, observed, or measured value or condition and the true, specified, or theoretically correct value or condition. An error's detectability is determined by the proportion of program inputs that expose the error. Such input is said to fail w.r.t. the error. For example, the code fragment in Figure <ref type="figure">1</ref> parses negative numbers incorrectly. E.g, input setting valuestring to "-2" fails w.r.t. the error as it produces the output value of 2 instead of -2. If valuestring is directly a program input, then the error has a high detectability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Error Complexity )</head><p>The complexity of an error E is the complexity of the least complex change required to pass all input that fails w.r.t. E while the output for all other input remains unchanged.</p><p>Intuitively, we define the complexity of an error based on how substantial its fix must be -without introducing new errors. For example, the error in Figure <ref type="figure">1</ref> can be correctly repaired with the change of only one statement (line 359). With CyCC = 1, it is a simple error. The error in Figure <ref type="figure">2</ref> can be repaired with a change involving three additional conditional statements. Assuming short-circuit evaluation for these conditions (see <ref type="bibr" target="#b12">[12]</ref>), the CSG in Fig. <ref type="figure" target="#fig_2">3</ref> (middle) might be the least complex. The error is of complexity four.</p><p>However, we note that other measures, such as number of changed LoC, paths, or hunks, may assign different specific values to an error's complexity. While different measures may disagree on its specific value or rank, they should correlate in general (see RQ1 in Sec. 5). For instance, if an error requires a substantial fix involving a high number of changed LoC distributed over the code, the values for other measures of complexity should be high as well. We believe that CyCC is a precise and practical measure of change complexity as given in Def. 1 and thus of error complexity as in Def. 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">COMPUTING INTER-PROCEDURAL CHANGE SEQUENCE GRAPHS</head><p>We present an algorithm to synthesize the inter-procedural Change Sequence Graph (CSG) efficiently from the intraprocedural control-flow graphs of the changed methods and the call graph of the changed program. The intra-procedural Control-Flow Graphs (CFGs) of the changed methods are traversed to establish the control-flow among the changed basic blocks in the CSG. The Call Graph (CG) of the changed program is traversed to establish whether a basic block transitively calls a changed method.</p><p>The inter-procedural CSG is computed more efficiently than previously in Reference <ref type="bibr" target="#b4">[4]</ref> because it does not require the entire inter -procedural CFG for the complete program.</p><p>Algorithm 1 depicts the CSG construction process. Given two versions of a program, P and P ′ , the algorithm computes the inter-procedural CSG. After determining which methods and basic blocks have changed, the algorithm follows along the control-flow and method calls from every changed basic block onwards. If another changed basic block is found, an edge is added to the CSG between the original changed basic block and the found one. Then, we establish whether the original changed basic block can be executed as first or last changed basic block and a corresponding edge is added to program entry and exit, respectively. for each changed m ′ that curr may call in CG do 24:</p><p>let</p><formula xml:id="formula_1">CF G ′ ← constructCF G(m ′ ) 25: traverseChange(CF G ′ .f irst, CF G ′ , c) 26:</formula><p>end for 27: end function Output: Inter-procedural CSG In more detail, Algorithm 1 works as follows. First, a syntactic differencing-tool, such as the Unix diff-tool, determines the syntactic differences between both program versions (line 1). These differences are used subsequently to determine in the changed version those basic blocks and methods that have changed. Then, the call graph is constructed for the changed program and the CSG initialized with entry and exit vertices (lines 2-3). After this initialization, the algorithm computes the intra-procedural CF G for each changed method m, adds the changed basic blocks from the CF G into the CSG, and starts traversing the controlflow recursively from each changed basic block c onwards (lines 4-10). Since the method traverseChange is a recursive traversal algorithm, we mark the visited vertices as such (lines 14-15). If any basic block bb transitively following c is changed, then add an edge from c to bb (lines <ref type="bibr" target="#b16">[16]</ref><ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref><ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref><ref type="bibr" target="#b21">[21]</ref>. If c or any transitively following basic block, transitively calls a changed method m ′ , continue traversal from the f irst basic block in the CF G ′ of m ′ (lines <ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b24">[24]</ref><ref type="bibr" target="#b25">[25]</ref><ref type="bibr" target="#b26">[26]</ref>. Finally, the method connectEntryExit computes the edges from the entryvertex to any changed basic block that can be executed first, that is before some other basic block is executed, and the edges to the exit-vertex from any changed basic block that can be executed last, that is after any other changed basic block is executed (cf. Def. 2). A complete implementation is discussed in Sec. 4.3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EMPIRICAL STUDY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Objects of Empirical Analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">CoREBench: Complex Regression Errors</head><p>CoREBench is a collection of 70 regression errors that we systematically extracted from the code repositories and bug reports of four open-source software projects: Make, Grep, Findutils, and Coreutils (see Fig. <ref type="figure">4</ref>).</p><p>We chose these projects because they are well-specified, well-tested, well-maintained, and widely-used open source programs with standardized program interfaces. The version history and all bug reports can be publicly accessed on the GNU homepage. 4 The program interfaces and parameters were specified in POSIX as IEEE standard in 1988 <ref type="bibr" target="#b14">[14]</ref>.</p><p>We built the corpus by ( <ref type="formula">1</ref>) identifying a regression-fixing commit in the 1,000 most recent revisions and a test that passes after but fails before the fix, and (2) the regressionintroducing commit, such that the same test passes before and fails after the commit. Regression errors which could not be reproduced using a test case are not reported. This was the case for some system-or concurrency-related bugs.</p><p>To identify a regression-fixing commit ( F ix ➠ ), we parsed the commit messages of the 1,000 most recent commits and a file which highlights recent new features and fixes for keywords, such as "regression", "introduced", and "broken". Except for Make, the file and commit messages are sufficiently detailed and may even reference the error-introducing commit. For Make, we parsed the bug report referenced in the commit messages. Also for Make, we removed seven commits in which the regression fix was tangled 5 with other fixes. Computing the error complexity based on tangled fixes will give wrong results. For all regression errors we ensure that the commit is solely devoted to fixing exactly one error. The error-witnessing test case was always provided with the bugfixing commit or the bug report.</p><p>To identify the error-introducing commit ( Reg ➠ ), we used the error-witnessing test case and a binary search on the complete version history of the subject. The binary search is automated using git bisect, which conceptually searches all revisions before the error-fixing commit to determine the exact (error-introducing) commit before which the test case passes (P ✓ ) and after which the test case fails (P✗). For Coreutils, we add five regression errors that we already identified in Reference <ref type="bibr" target="#b4">[4]</ref>. Finally, we determined two commits describing the lifetime and a test case exposing the effects of each regression error: Using this approach, we have identified and validated 70 regression errors (incl. six segmentation faults) that were introduced by 57 different commits. From the time an error was introduced to the time the error was fixed, it took on average 1.7 years. Eleven errors were fixed incorrectly. In these cases the error was indeed removed in the fixed version. Yet, up to three new errors were introduced that required further fixes. About one third of the errors were introduced by changes not to the program's behavior but to non-functional properties such as performance, memory consumption, or APIs. In some cases one error would supercede another error such that the superceded was not observable for the duration that the superceding remained unfixed. 6   </p><formula xml:id="formula_2">. . . ➠P ✓ Reg ➠ P✗➠ . . . ➠P✗ F ix ➠ P ✓ ➠ . . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Base Line: SIR and Siemens Suite</head><p>The Subject Infrastructure Repository (SIR) <ref type="bibr">[9]</ref> and the Siemens Suite <ref type="bibr" target="#b13">[13]</ref> are arguably the most popular error benchmarks. For every correct program version P ✓ , there are several faulty versions P✗. One may evaluate regression testing and debugging techniques by considering:</p><formula xml:id="formula_3">P ✓ Reg ➠ P✗ F ix ➠ P ✓ .</formula><p>The popularity may be due to the provision of test oracles, standardized program interfaces, a large number of test cases, and a uniform format for the materials provided. Program input and output are clearly defined. Each subject consists of a "golden version" as test oracle and several erroneous versions with one fault each. Measuring popularity by the number of citations: In the five years preceding this paper, the publications associated with the SIR <ref type="bibr">[9]</ref> and Siemens Suite <ref type="bibr" target="#b13">[13]</ref> have been cited almost six hundred times.</p><p>Figure <ref type="figure">5</ref> shows the characteristics of the subjects in both benchmarks. The number of tests was derived from the file universe while the number of regression errors was derived from Fault_Seeds.h that accompanies each subject. Figure <ref type="figure">5</ref>: Subjects of Siemens Suite and SIR 6 For instance, find.66c536bb supercedes find.dbcb10e9.</p><p>Unfortunately, in both benchmarks almost all errors were created by manual fault seeding <ref type="foot" target="#foot_1">7</ref> . We claim that fault seeding introduces a bias towards less complex errors. Our novel measure of error complexity, for the first time, allows us to assess the substance and extent of this bias.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Variables and Measures</head><p>Our experiment manipulated two independent variables (IV):</p><p>• IV1 Genuineness: There are two categorical factors of genuineness. Seeded regression errors result from faults that were manually seeded. Actual regression errors appear in typical evolving software projects.</p><p>• IV2 Regression Cause: We consider two categorical factors of regression cause. Change Interaction Errors (CIEs) can be observed only if a certain sequence of changes is exercised (cf. <ref type="bibr" target="#b4">[4]</ref>). All other errors (Non-CIEs) are regression errors that are not CIEs.</p><p>In our experiment, we measured 3 dependent variables (DV):</p><p>• DV1 Error Complexity: We consider two measures of error complexity which is defined w.r.t. the errorfixing commit. The Cyclomatic Change Complexity (CyCC) is described in Section 2.2. The Changed Lines of Code (CLoC) corresponds to the number of executable source code lines that were changed. Both are measured for the version just before the error is fixed.</p><p>• DV2 Error Life Span: We measure the error life span as the number of days between the commit introducing and the commit fixing the error.</p><p>• DV3 Error-Introducing-Commit Complexity:</p><p>We measure the error-introducing-commit complexity as CyCC of the commit introducing the error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Experimental Design</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Measuring Error Complexity for CoREBench</head><p>To investigate the complexity of actual regression errors, we analyse their actual fixes. But why should the actual fix be that "least complex, correct" fix describing the error complexity (see Def. 5)? In fact, for each error there can be innumerable fixes and not every fix is correct such that not only the observed error is fixed but also no new errors are introduced and least complex such that no other correct fix is of less complexity.</p><p>In practice, we neither have all possible fixes nor do we have all possible test cases that observe that the error (and only the error) is really fixed. Instead, for the analysis of CoREBench we put forward the following hypothesis:</p><p>Competent Repair Hypothesis.</p><p>Software developers write fixes with a complexity as low as possible and that are close to being correct.</p><p>First, the Competent Repair Hypothesis (CRH) states that developers write fixes that are as simple as possible. For several errors in CoREBench we found two fixes -the second fixed the error "more efficiently" or repaired "the root cause" of the error even though the first fix was already a correct one. 8 Complex fixes are often accompanied by very elaborate explanations why such complex changes were necessary to fix the error. Then, the CRH states that developers write fixes that are close to being correct. Indeed, the fixes for eleven of seventy errors in CoREBench were incorrect such that the repair of one introduced a new error. However, in general we believe that the programmer is likely to fix the error correctly. If this was not the case, we would register an exponential increase of bug reports. This hypothesis is an instance of the Competent Programmer Hypothesis <ref type="bibr" target="#b8">[8]</ref> which states that developers "create programs that are close to being correct".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Infrastructure and Implementation</head><p>We implemented Algorithm 1 based on the C Intermediate Language (CIL) program analysis framework <ref type="bibr" target="#b22">[22]</ref> and the Unix diff tool to compute the Cyclomatic Change Complexity (CyCC) and the executable Changed Lines of Code (CLoC) of a code commit as the two measures of DV1. Both, tool implementation and CoREBench can be downloaded at http://www.comp.nus.edu.sg/∼release/corebench.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6: CyCC Tool Implementation</head><p>As depicted in Figure <ref type="figure">6</ref>, the implementation works as follows. First, the changed version (v2.c) is compiled into an intermediate file (v2.i) using cilly. Then, our script uses the diff tool to determine the lines of code that have syntactically changed in v2.c. Note that CLoC is the number of executable changed lines of code while the syntactic changes can also comprise comments. If the program version history is maintained remotely and the changed version is available on the local machine, our script uses the previous verison (v1.c) from the repository. Otherwise, its location must be provided to compute the difference.</p><p>Next, CIL can compute the call graph and intra-procedural control-flow graphs (CFG) for the changed program. Using the output of the diff-tool, we find the changed methods in the call graph and the changed basic blocks in the CFGs of the changed methods. Note that diff detects any line of a multi-line statement that is changed while CIL only maintains the first of the potentially multiple lines of a statement. We address this issue for the most common multi-line statement (if-conditions) but not for others. Furthermore, toplevel variable and method declarations (e.g., int x;) are not available in the CIL CFGs and macros are readily expanded. Thus, modifications of these program elements, as well as deleted basic blocks, are not reflected in the CIL-CFGs and the inter-procedural CSG, respectively. 8 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>See commit message of find.b445af98</head><p>Once the change sequence graph is synthesized for a source code commit, our implementation computes the CLoC and CyCC according to Definition 3. Note that during our experiments, we ignore errors and code commits that yield "empty" CSGs. For CoREBench, we report the results for all 70 regression errors. However, for SIR and the Siemens Suite, several changes were only to variable or method declarations (e.g., change of type) or C macros. While these were ignored, we report the results for the remaining 259 regression errors in SIR and 108 regression errors in Siemens.</p><p>The experiments were run on a Linux machine with Intel Core2 Quad CPU at 2.83GHz and 4GB of main memory. On average, it took less than 1 second to compute the complexity of an error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Threats to Validity</head><p>Construct validity refers to the degree to which a test measures what it claims, or purports, to be measuring. Three threats to construct validity are the empirical reliability of the competent repair hypothesis, the reliability of CyCC as good measure of error complexity, and the correctness of the implementation of the measure into the CyCC tool. (i) The Competent Repair Hypothesis (CRH) links that theoretical least complex, correct fix specified in Definition 5 to the actual fix of the errors in CoREBench (see Sec. 4.3.1). Assuming the CRH, we measure the complexity of actual regression errors based on the actual fixes of these errors. If the CRH does generally not hold, the actual error complexity may be different from the measured error complexity.</p><p>(ii) The CyCC metric may not be a good measure of the complexity of a fix and thus of error complexity. However, we note that Definition 3 of CyCC is inspired by an existing measure of software complexity <ref type="bibr" target="#b20">[20]</ref> which itself inspired Definition 1 of change complexity. We study the relationship to another measure of change complexity (see Sec. 5). (iii) The CyCC tool may be incorrectly implemented. For instance, some changed elements, like deleted basic blocks, are not represented in the computed CSG from which the CyCC is computed. However, all results are computed using the same tool, subjecting each (compared) measurement to the same potential bias. Furthermore, we make available the source code of the implementation for inspection.</p><p>External validity refers to the extent to which the results of a study can be generalized to other objects which are not included in the study. One threat to the external validity is the representativeness of the the chosen objects of empirical analysis. Indeed, our objects are well-maintained, open-source C software projects containing regression errors typical for such projects. However, for instance regression errors in projects written in other languages, like Java, or in commercially developed software may be of different kind and complexity. Hence, the results and conclusion are to be interpreted in this context.</p><p>Internal validity refers to the degree to which the independent variable causes the changes seen in the dependent variable being examined within the study. While it is clear that (IV1) the actual regression errors are not seeded and vice versa, it may be that (IV2) regression errors classified as change interaction errors are not actually change interaction errors. However, for each regression error, we attempted to determine the specific sequence of changed statements that need to be exercised to expose the error. In the results we note which errors could thus not be classified. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DATA AND ANALYSIS</head><p>We investigate the nature of complex regression errors. In our main research hypothesis, we claim that the process of creating errors using manual fault seeding introduces a bias towards less complex errors. Formally, we submit a null hypothesis which needs to be rejected in order to empirically prove this claim. We also find out whether actual, more complex regression errors have a longer life span and whether complex errors are introduced by complex commits.</p><p>Furthermore, we investigate another measure of change complexity -the number of Changed Lines of Code (CLoC). While we cannot directly compare both measures, we find out whether our Cyclomatic Change Complexity (CyCC) and CLoC agree on the ranking of two-hundred commits in terms of their complexity. If so, CLoC and CyCC may be used interchangeably to assess the complexity of a commit.</p><p>Lastly, we use the actual regression errors to study the prevalence, complexity, and life span of an interesting class of regression errors -Change Interaction Errors (CIEs; cf. <ref type="bibr" target="#b4">[4]</ref>). We classify a regression error E as CIE if a sequence of at least two changed statements must be executed in order to expose E while "skipping" one of the changed statements does not expose E. Conservatively, we also require that each change in the sequence can potentially be skipped.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Research Questions and Null Hypothesis</head><p>In statistical inference, the null hypothesis, H0, states there is no relationship between two measured phenomena. The null hypothesis can be rejected based on observed data of a scientific experiment with the conclusion that there is very likely a relationship. The null hypothesis can never be accepted as more data may still reveal a relationship.</p><p>To test H0, we measure either a difference or the strength of the relationship. In the first case, we subtract the mean of one from the mean of the other dataset. In the latter case, we measure Spearman's rank correlation coefficient <ref type="bibr" target="#b28">[28]</ref> which is more robust for non-normal distributions than the common Pearson's product moment correlation. If we fail to reject H0 with a very low correlation coefficient, we can still conclude that if a relationship exists, it is very weak.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• H a</head><p>0 : There is no difference between the complexity of seeded and actual regression errors.</p><p>• H b 0 : There is no relationship between the complexity and life span of a regression error.</p><p>• H c 0 : There is no relationship between the complexity of the error and the commit introducing the error.</p><p>Furthermore, we want to answer these research questions:</p><p>• RQ1 Can the number of Changed Lines of Code (CLoC) and the Cyclomatic Change Complexity (CyCC) be used interchangeably?</p><p>• RQ2 What is the complexity, prevalence, and life span of Change Interaction Errors?</p><p>H a 0 : Seeded vs. Actual Errors (IV1, DV1)</p><p>We compare the error complexity (as CyCC) of the seeded regression errors in the Siemens Suite and SIR with that of the actual regression errors in CoREBench to study the effects of IV1 on DV1 and test H a 0 . For SIR and the Siemens Suite, we measure the complexity of the errors by considering the non-faulty versions as the fix for the error in the faulty versions. For CoREBench, we measure the complexity of the errors by analyzing the complexity of the regression-fixing commits and assume the Competent Repair Hypothesis. Also, for CoREBench we choose the regression errors such that every regression-fixing commit is designated to fixing exactly one error only.  We reject H a 0 and conclude: seeded regression errors are significantly less complex than actual regression errors. The mean error complexity differs by 21.9 for SIR and 21.7 for the Siemens Suite. Fitting the data to a power-law distribution, we compute the cumulative distribution functions shown in Figure <ref type="figure" target="#fig_5">8</ref>. The complexity distributions for each subject and benchmark are shown in Figure <ref type="figure" target="#fig_3">7</ref>.</p><p>Among the seeded errors, simple errors (complexity one) occur five times more often than among the actual errors. Specifically, 42% of the seeded errors are simple while only 8% of the actual errors are. Simple errors are characterized by a localized fault and can often be fixed by changing just one statement. In contrast to actual errors, the complexity of the seeded errors barely exceeds 10. Less than 1% of the seeded errors have a complexity of more than 10 compared to 30% of the actual errors. This means, that actual errors are generally more complex than the errors created through manual fault injection. The most complex error in CoREBench is twenty times more complex than the most complex error in the SIR and the Siemens Suite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H b</head><p>0 : Life Span vs. Complexity (DV1, DV2)</p><p>We compare the life span and complexity of actual regression errors to study the correlation between DV1 and DV2 and test H b 0 . Every commit has a timestamp, so we can compute the life span of an error by subtracting the timestamp of the error-introducing from that of the corresponding error-fixing commit. We measure the complexity using CyCC and depict the results in Figure <ref type="figure" target="#fig_7">9</ref>.  We cannot reject H b 0 and conclude that if a relationship between the life span and complexity of an error exists, then it is very weak. We compute a Spearman's rank correlation coefficient of ρ = 0.0675 with a two-sided p-value=0.5790. In other words, even simple errors that are "easy" to fix can take a very long time to fix. Vice versa, even complex errors that are difficult to fix can be fixed on the same day as the error is introduced.</p><p>Independent of error complexity, error life span follows a power-law distribution. Once introduced, 12% of the regression errors are fixed within a week while half of them stay undetected and uncorrected for more than 9 months up to 8.5 years. While there is a large number of errors with a small life span, there is a small number of errors with very large life span.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H c</head><p>0 : Introducing vs. Fixing Errors (DV1, DV3)</p><p>For each actual regression error, we compare the CyCC of the commit introducing and the commit fixing the error to study the correlation between DV1 and DV3 and test H c 0 . The results are presented in Figure <ref type="figure" target="#fig_9">10</ref>. On the left, we show for each regression error the complexity of the commit introducing the error versus the complexity of the commit fixing the error. On the right, we show the cumulative distribution of error-introducing and error-fixing commits independently.  We cannot reject H c 0 and conclude that if there exists a relationship between the complexity of an error and the complexity of the commit which introduces the error, then it is very weak. We compute a Spearman's rank correlation coefficient of ρ = 0.1656 with a two-sided p-value=0.1705. In other words, even complex errors can be introduced by simple changes and vice versa. One interpretation is that sometimes the root cause of some complex regression errors is already dormant in the program and only "unmasked" in the changed code. Then, we should consider these changes as the trigger instead of the root cause of an observed error. Another interpretation is that the error itself evolves during its life span due to many other changes to the program. Then, the complexity of errors may change during evolution.</p><p>On average, error-introducing commits are more complex when compared to error-fixing commits (see Fig. <ref type="figure" target="#fig_9">10</ref> -right).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ.1 Changed Lines of Code as Proxy Measure</head><p>For 200 random code commits <ref type="foot" target="#foot_2">9</ref> , we measure the CyCC and Changed Lines of Code (CLoC), to study the concordance and correlation of two measures of DV1 (Error Complexity). Concordance describes the degree to which both measures agree on the complexity of a set of changes and is measured using Cohen's kappa <ref type="bibr" target="#b6">[6]</ref>. Full agreement (κ = 1) means that CyCC rates a set of changes C1 more complex than another set of changes C2 if and only if CLoC rates C1 more complex than C2. In contrast, correlation describes the strength of the relationship and is measured using Spearman's ρ. Strong correlation (ρ = 1) means that if CyCC is large than CLoC is also likely to be large and vice versa.</p><p>The results are presented in Figure <ref type="figure" target="#fig_0">11</ref>. The Bland-Altman plot <ref type="bibr" target="#b3">[3]</ref> on the left allows us to compare the differences between the measurements with both measures of complexity for each commit. The mean (x) of these differences is called bias and the reference interval (x ± 1.96×standard deviation) is called limits of agreement. If the measures tend to agree, the differences will be plotted near zero. As CLoC and CyCC are not directly comparable and the power-law distribution generates strong outliers, we compare the ranks instead of the measurement values. The rank of measurement lies between one and the number of measurements and is greater than the rank of another measurement if and only if the measurement value is greater than that of the other measurement. The plot on the right depicts the (value) correlation of both measures on a logarithmic scale.  Two measures that are designed to measure the same property (here, change complexity) may not agree but should have a good correlation. Indeed, we compute Spearman's correlation ρ = 0.86 with a two-sided p-value &lt; 0.0001. So, as the CLoC increases, the CyCC increases and vice versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ.2 Complexity, Life Span, and Prevalence of Change Interaction Errors (IV2, DV1, DV2)</head><p>We compare the error complexity (as CyCC) and life span of Change Interaction Errors (CIEs) with the error complexity and life span of actual regression errors that are not Change Interaction errors (Non-CIE) to study the effects of IV2 on DV1 and DV2. We also measure the prevalence of CIEs among actual regression errors.</p><p>The results are presented in Figure <ref type="figure" target="#fig_12">12</ref>. In the table, we show the classification of actual regression errors into CIE, Non-CIE, and Unclassified. For the latter, the regression cause could not be identified. On the left, we show the cumulative distribution of the complexity of CIEs versus Non-CIEs cropped at an error complexity of 50. On the right side, we show the cumulative distribution of the life span of CIE versus Non-CIEs on a logarithmic scale.  Error Complexity. CIEs are consistently more complex than Non-CIEs. The mean complexity of CIEs (20.1) differs from that of Non-CIEs (9.9) by 10.2. On average 10% more CIEs exceed any given complexity than Non-CIEs. For example, while about 32% of the CIEs exceed a complexity of 10, only 22% of the Non-CIEs exceed the same complexity. This means CIEs are "more difficult to fix" than other types of regression errors.</p><p>Error Life Span. CIEs and Non-CIEs have a similar life span. Indeed, the mean life span of CIEs (623 days) differs from that of Non-CIEs (463 days) by 160 days. However, on average only 1% more CIEs exceed any given life span than Non-CIEs. From the chart (Fig. <ref type="figure" target="#fig_12">12</ref>-right) it seems evident that there is no significant difference between the life span of CIEs and that of Non-CIEs. This means CIEs are manually "as difficult to find" as other types of regression errors.</p><p>Prevalence. Change interaction errors are prevalent. In fact, 22 of 59 classified actual regression errors can be classified as CIEs. This means that the existence of change interaction errors as a particular type of regression errors must be considered during the testing and debugging of evolving open source C programs. The prevalence and peculiarity of change interaction errors suggests that CIEs should not be disregarded during the empirical evaluation of techniques and methodologies in the scientific research of regression testing, debugging, and program repair.</p><p>In summary, compared to any other type of regression errors, CIEs are more difficult to expose automatically <ref type="bibr" target="#b4">[4]</ref> while it takes the same time to encounter them manually (cf. error life span). Once discovered, CIEs are "more difficult to fix" (cf. error complexity). Since CIEs are prevalent in open-source C programs, they form an important class of regression errors that can be studied in CoREBench.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>We first discuss investigations into the relationship of error complexity and detectability, continue with work related to quantifying error complexity, and conclude with an overview of related work on the construction and public provisioning of a benchmark suite with actual regression errors.</p><p>Offutt <ref type="bibr" target="#b24">[24]</ref> asserts a relationship between the detectability and complexity of software errors. He defines a simple fault as one "that can be fixed by making a single change to a source statement" while a complex fault is one that can thus not be fixed. In his coupling effect hypothesis he conjectures that a "test dataset that detects all simple faults in a program will detect a high percentage of the complex faults" which holds if and only if the detectability<ref type="foot" target="#foot_3">10</ref> of simple errors is somewhat similar to the detectability of complex errors. In the present work, we have extended Offutt's definition of error complexity to be ordinal rather than nominal.</p><p>Andrews et al. <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b2">2]</ref> confirm that the detectability of simple errors resulting from auto-generated faults (i.e., mutants) is similar to the detectability of actual (complex) errors and conclude that the mutation-adequacy of a test suite is a good indicator of its fault-detection capability. Namin et al. <ref type="bibr" target="#b21">[21]</ref> caution that this insight is highly sensitive to external threats mentioning several influential factors that must be accounted for. In the present paper we have investigated not the detectability but the complexity of regression errors and found that the complexity of regression errors resulting from seeded faults is different from that of actual regression errors. This raises concerns for the validity of studies based on SIR and Siemens specifically and on seeded errors in general.</p><p>While it is intuitively clear that some errors are simple and others certainly more complex, we are not aware of any previous attempt to quantify error complexity. However, there has been a great effort to understand how to quantify software complexity <ref type="bibr" target="#b29">[29]</ref>. Some established measures of software complexity are McCabe's cyclomatic complexity <ref type="bibr" target="#b20">[20]</ref>, Henry and Kafura's information flow complexity <ref type="bibr" target="#b10">[10]</ref>, and Chidamber and Kemerer's object-oriented complexity <ref type="bibr" target="#b5">[5]</ref>. To quantify error complexity, we introduce and compare two measures -the cyclomatic change complexity (CyCC) and the number of changed lines of code (CLoC).</p><p>A popular technique to extract actual regression errors from software repositories is the SZZ-algorithm <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b16">16]</ref>. First, SZZ identifies the error-fixing commit by parsing the commit messages for relevant keywords. Then, SZZ identifies the error-introducing commit by blaming the changed lines in the error-fixing commit. Blaming or annotating is a function of the repository to determine the commits that modified or added any given line of code. Fundamentally, the SZZ-algorithm assumes that the lines changed in the fix contain the fault location and determines which commit changed these lines previously to introduce the error. However, we find that the changed lines in the error-fixing and error-introducing commits in CoREBench do not even overlap for one in every three regression errors.</p><p>Three benchmarks that contain actual program errors are iBugs <ref type="bibr" target="#b7">[7]</ref>, BugBench <ref type="bibr" target="#b18">[18]</ref>, and Marmoset <ref type="bibr" target="#b27">[27]</ref>. iBugs consists of a large number of real bug fixes in the version history of two Java projects, AspectJ and Rhino. For some bug fixes, the benchmark also maintains those test cases that were submitted with the fix. BugBench consists of mostly memory-related errors while Marmoset contains errors extracted from student projects and may not contain a representative sample of actual program errors. In contrast to these, our CoREBench allows us to study regression testing and regression debugging techniques as well as the evolution of software errors over several program versions for up to eight years from error-introduction to fix.</p><p>Two benchmarks that contain seeded regression errors introduced by manual fault seeding are the Siemens Suite <ref type="bibr" target="#b13">[13]</ref> and SIR <ref type="bibr">[9]</ref>. Both are discussed in detail in the empirical section of the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>The research on and development of automated techniques to expose, locate root-causes of, and repair regression errors requires an understanding of the inherent nature of such errors. In order to develop automated regression testing, debugging, and repair techniques, we need to be aware of the underlying, general properties of regression errors.</p><p>In this paper, we advertise the study of regression errors with a varying degree of complexity and propose the subjects in CoREBench, as a collection of actual regression errors, for such controlled studies. We have analyzed the two most popular benchmarks, the Siemens Suite and SIR, which contain regression errors with a varying degree of detectability and found that these errors are often simple and generally significantly less complex than actual regression errors. In other words, their fixes were required to be less substantial.</p><p>Our novel measure of error complexity enables research and development of regression testing, debugging, and repair techniques that account for a varying degree of complexity. We may ask more refined research questions, such as:</p><p>• What is the root-cause of a complex error? If an error requires a substantial fix, can we assume that there is just one faulty statement causing the error? Are faults of complex errors localizable <ref type="bibr" target="#b19">[19]</ref>? The answers may have implications for the performance of (statistical) debugging techniques.</p><p>• Test suite adequacy to expose complex errors? Some widely used metrics of test suite adequacy, such as statement or branch coverage, are based on the implicit assumption that errors are often simple, i.e., that the fault is localizable within some branch or statement which is covered. Now we may be able to investigate the effectiveness of coverage-adequate test suites w.r.t. a varying degree of error complexity and may develop more sophisticated adequacy-criteria that account for complex errors. Moreover, for the study of the relationship between simple and complex errors (e.g., see coupling effect <ref type="bibr" target="#b24">[24]</ref>), we can take error complexity as an ordinal rather than a dichotomous measure.</p><p>• How do we repair complex errors? By definition, the fix of complex errors is more substantial than for simple errors. The research community has made significant progress understanding the automated repair of (simple) localizable errors <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b17">17]</ref>. Now we may be able to evaluate the efficiency of such repair techniques w.r.t. a varying complexity of the repaired errors.</p><p>The artifact evaluation committee of ISSTA 2014 has found CoREBench and the CyCC tool to exceed expectations. We hope that our novel error complexity metric and the many actual regression errors in CoREBench spur a multitude of studies of regression testing, debugging, and repair techniques and of those assumptions underlying these techniques so as to better understand the nature of complex regression errors.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 1</head><label>11</label><figDesc>Figure 1: Fix of simple error core.6fc0ccf7 Figure 1 shows an example of a simple error in coreutils.The simplified code fragment parses a valuestring into an integer value. However, every string containing a negative number is parsed as a positive number. This error is simple because only one statement (in line 359) needs to be changed in order to repair the error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>447++:Figure 2 :Figure 2</head><label>22</label><figDesc>Figure 2: Fix of complex error find.24bf33c0 Figure 2 shows an example of a complex error in findutils.The bug report states that "find does not report symlink loop when trying to follow symlinks". Hence, the developer adds the presented code fragment to describe conditions under which symlink loops need to be reported. The error is complex because it requires three additional conditional statements and several statements to fix it correctly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Change sequence graphs with linear independent paths (359) (left); (447), (447-448-449), (447-448-451), (447-448-451-452) (middle); and (100), (200), (100-200), (200-100), (200-200) (right).</figDesc><graphic coords="3,118.15,287.27,96.50,190.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Cumulative distribution of error complexity for all subjects in each benchmark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Cumulative distribution of error complexity for seeded errors (SIR and Siemens) vs. actual errors (CoREBench)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Correlation of error life span vs. complexity (left), cumulative distribution of life span (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Correlation (left) and cumulative distribution (right) of the complexity of the two commits introducing and fixing an error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Bland-Altman plot of measurement ranks (left) and correlation (right) of CLoC vs. CyCC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Prevalence (top), complexity (left), and life span (right) of Change Interaction Errors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>change sequences in a changed program and is thus inspired by McCabe's cyclomatic program complexity. Intuitively, CyCC quantifies the amount of changed decision logic in the program.</figDesc><table><row><cell cols="2">351 : intmax_t value = 0;</cell></row><row><cell cols="2">352 : int sign = (*valuestring == '-' ? -1 : 1);</cell></row><row><cell cols="2">353 : if (sign &lt; 0)</cell></row><row><cell>354 :</cell><cell>valuestring++;</cell></row><row><cell cols="2">355 : do {</cell></row><row><cell>356 :</cell><cell>if (ISDIGIT(*valuestring))</cell></row><row><cell>357 :</cell><cell>value = 10*value + sign * (*valuestring-'0');</cell></row><row><cell cols="2">358 : } while (*++valuestring)</cell></row><row><cell cols="2">359--: return value * sign;</cell></row></table><note><p>359++: return value;</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Algorithm 1 Inter-procedural Change Sequence Graph Input: Programs P and P ′ 1: determine changed methods and basic blocks using diff 2: let CG ← constructCallGraph(P</figDesc><table><row><cell>19:</cell><cell>else</cell></row><row><cell>20:</cell><cell>traverseChange(bb, CF G, c)</cell></row><row><cell>21:</cell><cell>end if</cell></row><row><cell>22:</cell><cell>end for</cell></row><row><cell>23:</cell><cell></cell></row></table><note><p><p><p><p><p><p>′ ) 3: let CSG ← {entry, exit} 4: for each changed method m ∈ CG do 5: let CF G ← constructCF G(m) 6: add all changed basic blocks from CF G to CSG 7: for each changed basic block c ∈ CF G do 8: traverseChange(c, CF G, c) 9: end for 10: end for 11: connectEntryExit() 12: 13: function traverseChange(curr, CF G, c) 14:</p>if curr marked as traversed then return 15:</p>else mark curr as traversed 16:</p>for each bb that directly follows curr in CF G do 17:</p>if bb is a changed basic block then 18:</p>add an edge from c to bb</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>A linearly independent path is a complete path through the program that introduces at least one new edge that is not included in any other linearly independent paths.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_1"><p>Except for space, all errors are manually generated.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_2"><p>We chose the 50 most recent code commits in each of the projects Coreutils, Findutils, Grep, and Make.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_3"><p>The detectability of an error is determined by the proportion of input exposing the error (see Sec. 2.2).</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We thank Dr. Konstantin Rubinov and Dr. Jooyong Yi for their insightful comments on earlier drafts of this paper. This work was partially supported by Singapore's Ministry of Education research grant MOE2010-T2-2-073. The first author is funded by an ERC advanced grant 'SPECMATE'.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Is mutation an appropriate tool for testing experiments?</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Labiche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Conference on Software Engineering, ICSE &apos;05</title>
		<meeting>the 27th International Conference on Software Engineering, ICSE &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="402" to="411" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Using mutation analysis for assessing and comparing testing coverage criteria</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Labiche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Namin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="608" to="624" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Measuring agreement in method comparison studies</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Altman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistical Methods in Medical Research</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="135" to="160" />
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Regression tests to expose change interaction errors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C D S</forename><surname>Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, ESEC/FSE 2013</title>
		<meeting>the 2013 9th Joint Meeting on Foundations of Software Engineering, ESEC/FSE 2013</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="334" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A metrics suite for object oriented design</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Chidamber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Kemerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="476" to="493" />
			<date type="published" when="1994-06">June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A coefficient of agreement for nominal scales</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Educational and Psychological Measurement</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="46" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Extraction of bug localization benchmarks from history</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dallmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-second IEEE/ACM International Conference on Automated Software Engineering, ASE &apos;07</title>
		<meeting>the Twenty-second IEEE/ACM International Conference on Automated Software Engineering, ASE &apos;07</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="433" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hints on test data selection: Help for the practicing programmer</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Demillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">G</forename><surname>Sayward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="34" to="41" />
			<date type="published" when="1978-04">Apr. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Supporting controlled experimentation with testing techniques: An infrastructure and its potential impact</title>
		<author>
			<persName><forename type="first">H</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Elbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rothermel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="405" to="435" />
			<date type="published" when="2005-10">Oct. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Software structure metrics based on information flow</title>
		<author>
			<persName><forename type="first">S</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kafura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="510" to="518" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The impact of tangled code changes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Herzig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Working Conference on Mining Software Repositories, MSR &apos;13</title>
		<meeting>the 10th Working Conference on Mining Software Repositories, MSR &apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="121" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Finding bugs is easy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hovemeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="92" to="106" />
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Experiments of the effectiveness of dataflow-and controlflow-based test adequacy criteria</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hutchins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Goradia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ostrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Software Engineering, ICSE &apos;94</title>
		<meeting>the 16th International Conference on Software Engineering, ICSE &apos;94</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="191" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Edition, IEEE Standard Interpretations of IEEE Standard Portable Operating System Interface for Computer Environments (IEEE Std 1003.1-1988)</title>
		<idno>IEEE. 1003.1-1988 INT/1992</idno>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>IEEE</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Standard Glossary of Software Engineering Terminology</title>
		<author>
			<persName><surname>Ieee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Std</title>
		<imprint>
			<biblScope unit="volume">610</biblScope>
			<biblScope unit="page" from="1" to="84" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automatic identification of bug-introducing changes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J J</forename><surname>Whitehead</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st IEEE/ACM International Conference on Automated Software Engineering, ASE &apos;06</title>
		<meeting>the 21st IEEE/ACM International Conference on Automated Software Engineering, ASE &apos;06</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A systematic study of automated program repair: Fixing 55 out of 105 bugs for $8 each</title>
		<author>
			<persName><forename type="first">C</forename><surname>Le Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dewey-Vogt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering, ICSE &apos;12</title>
		<meeting>the 34th International Conference on Software Engineering, ICSE &apos;12</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="3" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Bugbench: Benchmarks for evaluating bug detection tools</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on the Evaluation of Software Defect Detection Tools</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Are faults localizable?</title>
		<author>
			<persName><forename type="first">F</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 9th IEEE Working Conference on Mining Software Repositories (MSR)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="74" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A complexity measure</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mccabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering, SE</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="308" to="320" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The use of mutation in testing experiments and its sensitivity to external threats</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Namin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kakarla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 International Symposium on Software Testing and Analysis, ISSTA &apos;11</title>
		<meeting>the 2011 International Symposium on Software Testing and Analysis, ISSTA &apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="342" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Cil: Intermediate language and tools for analysis and transformation of c programs</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Compiler Construction, CC &apos;02</title>
		<meeting>the 11th International Conference on Compiler Construction, CC &apos;02</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="213" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Semfix: Program repair via semantic analysis</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 International Conference on Software Engineering, ICSE &apos;13</title>
		<meeting>the 2013 International Conference on Software Engineering, ICSE &apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="772" to="781" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Investigations of the software testing coupling effect</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Offutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="20" />
			<date type="published" when="1992-01">Jan. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Test-suite augmentation for evolving software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Santelices</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Chittimalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Apiwattanapong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Harrold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering, ASE &apos;08</title>
		<meeting>the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering, ASE &apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="218" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">When do changes induce fixes?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Śliwerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 International Workshop on Mining Software Repositories, MSR &apos;05</title>
		<meeting>the 2005 International Workshop on Mining Software Repositories, MSR &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Software repository mining with marmoset: An automated programming project snapshot and testing system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Spacco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Strecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hovemeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 International Workshop on Mining Software Repositories, MSR &apos;05</title>
		<meeting>the 2005 International Workshop on Mining Software Repositories, MSR &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The proof and measurement of association between two things</title>
		<author>
			<persName><forename type="first">C</forename><surname>Spearman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Psychology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="72" to="101" />
			<date type="published" when="1904">1904</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Evaluating software complexity measures</title>
		<author>
			<persName><forename type="first">E</forename><surname>Weyuker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1357" to="1365" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
