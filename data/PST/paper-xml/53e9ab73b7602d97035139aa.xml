<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Requirements-Driven Development Methodology *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jaelson</forename><surname>Castro</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Centro de Informática</orgName>
								<orgName type="department" key="dep2">Av. Prof. Luiz Freire S/N</orgName>
								<orgName type="institution">Universidade Federal de Pernambuco</orgName>
								<address>
									<postCode>50732-970</postCode>
									<settlement>Recife PE</settlement>
									<country key="BR">Brazil</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Manuel</forename><surname>Kolp</surname></persName>
							<email>mkolp@cs.toronto.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<addrLine>10 King&apos;s College Road</addrLine>
									<postCode>M5S3G4</postCode>
									<settlement>Toronto</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Mylopoulos</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<addrLine>10 King&apos;s College Road</addrLine>
									<postCode>M5S3G4</postCode>
									<settlement>Toronto</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Requirements-Driven Development Methodology *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">65F4EE8D21827B2BF239354D52877839</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Information systems of the future will have to better match their operational organizational environment. Unfortunately, development methodologies have traditionally been inspired by programming concepts, not organizational ones, leading to a semantic gap between the system and its environment. To reduce as much as possible this gap, this paper proposes a development methodology named Tropos which is founded on concepts used to model early requirements. Our proposal adopts the i* organizational modeling framework <ref type="bibr" target="#b17">[18]</ref>, which offers the notions of actor, goal and (actor) dependency, and uses these as a foundation to model early and late requirements, architectural and detailed design. The paper outlines Tropos phases through an e-business example. The methodology seems to complement well proposals for agent-oriented programming platforms. * The Tropos project has been partially funded by the Natural Sciences and Engineering Research Council (NSERC) of Canada, and Communications and Information Technology Ontario (CITO), a centre of excellence, funded by the province of Ontario.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Information systems have traditionally suffered from an impedance mismatch. Their operational environment is understood in terms of actors, responsibilities, objectives, tasks and resources, while the information system itself is conceived as a collection of (software) modules, entities (e.g., objects, agents), data structures and interfaces. This mismatch is one of the main factors for the poor quality of information systems, also the frequent failure of system development projects.</p><p>One cause of this mismatch is that development methodologies have traditionally been inspired and driven by the programming paradigm of the day. This means that the concepts, methods and tools used during all phases of development were based on those offered by the pre-eminent programming paradigm. So, during the era of structured programming, structured analysis and design techniques were proposed <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b16">17]</ref>, while object-oriented programming has given rise more recently to objectoriented design and analysis <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>. For structured development techniques this meant that throughout software development, the developer can conceptualize the system in terms of functions and processes, inputs and outputs. For object-oriented development, on the other hand, the developer thinks throughout in terms of objects, classes, methods, inheritance and the like.</p><p>Using the same concepts to align requirements analysis with system design and implementation makes perfect sense. For one thing, such an alignment reduces impedance mismatches between different development phases. Moreover, such an alignment can lead to coherent toolsets and techniques for developing system (and it has!) as well, it can streamline the development process itself.</p><p>But, why base such an alignment on implementation concepts? Requirements analysis is arguably the most important stage of information system development. This is the phase where technical considerations have to be balanced against social and organizational ones and where the operational environment of the system is modeled. Not surprisingly, this is also the phase where the most and costliest errors are introduced to a system. Even if (or rather, when) the importance of design and implementation phases wanes sometime in the future, requirements analysis will remain a critical phase for the development of any information system, answering the most fundamental of all design questions: "what is the system intended for?" Information systems of the future like ERP, Knowledge Management or e-business systems should be designed to match their operational environment. For instance, ERP systems have to implement a process view of the enterprise to meet business goals, tightly integrating all functions from the operational environment. To reduce as much as possible this impedance mismatch between the system and its environment, we outline in this paper a development framework, named Tropos, which is requirements-driven in the sense that it is based on concepts used during early requirements analysis. To this end, we adopt the concepts offered by i* <ref type="bibr" target="#b17">[18]</ref>, a modeling framework offering concepts such as actor (actors can be agents, positions or roles), as well as social dependencies among actors, including goal, softgoal, task and resource dependencies. These concepts are used for an e-commerce example ‡ to model not just early requirements, but also late requirements, as well as architectural and detailed design. The proposed methodology spans four phases:</p><p>• Early requirements, concerned with the understanding of a problem by studying an organizational setting; the output of this phase is an organizational model which includes relevant actors, their respective goals and their inter-dependencies. • Late requirements, where the system-to-be is described within its operational environment, along with relevant functions and qualities. • Architectural design, where the system's global architecture is defined in terms of subsystems, interconnected through data, control and other dependencies. • Detailed design, where behaviour of each architectural component is defined in further detail.</p><p>The proposed methodology includes techniques for generating an implementation from a Tropos detailed design. Using an agent-oriented programming platform for the implementation seems natural, given that the detailed design is defined in terms of (system) actors, goals and inter-dependencies among them. For this paper, we have adopted JACK as programming platform to study the generation of an implementation from a detailed design. JACK is a commercial product based on the BDI (Beliefs-Desires-Intentions) agent architecture. Early previews of the Tropos methodology appeared in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>Section 2 of the paper describes a case study for a B2C (business to consumer) ecommerce application. Section 3 introduces the primitive concepts offered by i* and illustrates their use with an example. Sections 4, 5, and 6 illustrate how the technique works for late requirements, architectural design and detailed design respectively. Section 7 sketches the implementation of the case study using the JACK agent development environment. Finally, Section 8 summarizes the contributions of the paper, and relates it to the literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A Case Study</head><p>Media Shop is a store selling and shipping different kinds of media items such as books, newspapers, magazines, audio CDs, videotapes, and the like. Media Shop customers (on-site or remote) can use a periodically updated catalogue describing available media items to specify their order. Media Shop is supplied with the latest releases and in-catalogue items by Media Supplier. To increase market share, Media Shop has decided to open up a B2C retail sales front on the internet. With the new setup, a customer can order Media Shop items in person, by phone, or through the internet. The system has been named Medi@ and is available on the world-wide-web using communication facilities provided by Telecom Cpy. It also uses financial services supplied by Bank Cpy, which specializes on on-line transactions.</p><p>The basic objective for the new system is to allow an on-line customer to examine the items in the Medi@ internet catalogue, and place orders.</p><p>There are no registration restrictions, or identification procedures for Medi@ users. Potential customers can search the on-line store by either browsing the catalogue or querying the item database. The catalogue groups media items of the same type into (sub)hierarchies and genres (e.g., audio CDs are classified into pop, rock, jazz, opera, world, classical music, soundtrack, …) so that customers can browse only (sub)categories of interest.</p><p>An on-line search engine allows customers with particular items in mind to search title, author/artist and description fields through keywords or full-text search. If the item is not available in the catalogue, the customer has the option of asking Media Shop to order it, provided the customer has editor/publisher references (e.g., ISBN, ISSN), and identifies herself (in terms of name and credit card number).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Early Requirements with i*</head><p>During early requirements analysis, the requirements engineer captures and analyzes the intentions of stakeholders. These are modeled as goals which, through some form of a goal-oriented analysis, eventually lead to the functional and non-functional requirements of the system-to-be <ref type="bibr" target="#b6">[7]</ref>. In i* (which stands for "distributed intentionality''), early requirements are assumed to involve social actors who depend on each other for goals to be achieved, tasks to be performed, and resources to be furnished. The i* framework includes the strategic dependency model for describing the network of relationships among actors, as well as the strategic rationale model for describing and supporting the reasoning that each actor goes through concerning its relationships with other actors. These models have been formalized using intentional concepts from AI, such as goal, belief, ability, and commitment (e.g., <ref type="bibr" target="#b4">[5]</ref>). The framework has been presented in detail in <ref type="bibr" target="#b17">[18]</ref> and has been related to different application areas, including requirements engineering, software processes and business process reengineering.</p><p>A strategic dependency model is a graph, where each node represents an actor, and each link between two actors indicates that one actor depends on another for something in order that the former may attain some goal. We call the depending actor the depender and the actor who is depended upon the dependee. The object around which the dependency centers is called the dependum. Figure <ref type="figure">1</ref> shows the beginning of an i* model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Orders Customer Handle</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Items Buy Media</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Increase Market Share</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Customers Happy</head><p>Media Shop Customer Fig. <ref type="figure">1</ref>. "Customers want to buy media items, while the Media Shop wants to increase market share, handle orders and keep customers happy"</p><p>The two main stakeholders for a B2C application are the consumer and the business actors named respectively in our case Customer and Media Shop. The customer has one relevant goal Buy Media Items (represented as an oval-shaped icon), while the media store has goals Handle Customer Orders, Happy Customers, and Increase Market Share. Since the last two goals are not well-defined, they are represented as softgoals (shown as cloudy shapes).</p><p>Once the relevant stakeholders and their goals have been identified, a strategic rationale model determines through a means-ends analysis how these goals (including softgoals) can actually be fulfilled through the contributions of other actors. A strategic rationale model is a graph with four types of nodes --goal, task, resource, and softgoal --and two types of links --means-ends links and process decomposition links. A strategic rationale graph captures the relationship between the goals of each actor and the dependencies through which the actor expects these dependencies to be fulfilled.</p><p>Figure <ref type="figure" target="#fig_0">2</ref> focuses on one of the (soft)goal identified for Media Shop, namely Increase Market Share. The analysis postulates a task Run Shop (represented in terms of a hexagonal icon) through which Increase Market Share can be fulfilled. Tasks are partially ordered sequences of steps intended to accomplish some (soft)goal. Tasks can be decomposed into goals and/or subtasks, whose collective fulfillment completes the task. In the figure, Run Shop is decomposed into goals Handle Billing and Handle Customer Orders, tasks Manage Staff and Manage Inventory, and softgoal Improve Service which together accomplish the top-level task. Sub-goals and subtasks can be specified more precisely through refinement. For instance, the goal Handle Customer Orders is fulfilled either through tasks OrderByPhone, OrderInPerson or OrderByInternet while the task Manage Inventory would be collectively accomplished by tasks Sell Stock and Enhance Catalogue. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Means-ends link</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Legend</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Late Requirements Analysis</head><p>Late requirements analysis results in a requirements specification which describes all functional and non-functional requirements for the system-to-be. In Tropos, the information system is represented as one or more actors which participate in a strategic dependency model, along with other actors from the system's operational environment. In other words, the system comes into the picture as one or more actors who contribute to the fulfillment of stakeholder goals. For our example, the Medi@ system is introduced as an actor in the strategic dependency model depicted in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>With respect to the actors identified in Figure <ref type="figure" target="#fig_0">2</ref>, Customer depends on Media Shop to buy media items while Media Shop depends on Customer to increase market share and remain happy (with Media Shop service). Media Supplier is expected to provide Media Shop with media items while depending on the latter for continuing long-term business. He can also use Medi@ to determine new needs from customers, such as media items not available in the catalogue. As indicated earlier, Media Shop depends on Medi@ for processing internet orders and on Bank Cpy to process business transactions. Customer, in turn, depends on Medi@ to place orders through the internet, to search the database for keywords, or simply to browse the on-line catalogue. With respect to relevant qualities, Customer requires that transaction services be secure and usable, while Media Shop expects Medi@ to be easily maintainable (e.g., catalogue enhancing, item database evolution, user interface update, …). The other dependencies have already been described in Figure <ref type="figure" target="#fig_0">2</ref>. As late requirements analysis proceeds, Medi@ is given additional responsibilities, and ends up as the depender of several dependencies. Moreover, the system is decomposed into several sub-actors which take on some of these responsibilities. This decomposition and responsibility assignment is realized using the same kind of means-ends analysis along with the strategic rationale analysis illustrated in Figure <ref type="figure" target="#fig_0">2</ref>. Hence, the analysis in Figure <ref type="figure" target="#fig_2">4</ref> focuses on the system itself, instead of a external stakeholder.</p><p>The figure postulates a root task Internet Shop Managed providing sufficient support (++) <ref type="bibr" target="#b2">[3]</ref> to the softgoal Increase Market Share. That task is firstly refined into goals Internet Order Handled and Item Searching Handled, softgoals Attract New Customer, Secure and Usable and tasks Produce Statistics and Maintenance. To manage internet orders, Internet Order Handled is achieved through the task Shopping Cart which is decomposed into subtasks Select Item, Add Item, Check Out, and Get Identification Detail. These are the main process activities required to design an operational on-line shopping cart <ref type="bibr" target="#b5">[6]</ref>. The latter (goal) is achieved either through sub-goal Classic Communication Handled dealing with phone and fax orders or Internet Handled managing secure or standard form orderings. To allow for the ordering of new items not listed in the catalogue, Select Item is also further refined into two alternative subtasks, one dedicated to select catalogued items, the other to preorder unavailable products.</p><p>To provide sufficient support (++) to the Maintainable softgoal, Maintenance is refined into four subtasks dealing with catalogue updates, system evolution, interface updates and system monitoring. The goal Item Searching Handled might alternatively be fulfilled through tasks Database Querying or Catalogue Consulting with respect to customers' navigating desiderata, i.e., searching with particular items in mind by using search functions or simply browsing the catalogued products.</p><p>In addition, as already pointed, Figure <ref type="figure" target="#fig_2">4</ref> introduces softgoal contributions to model sufficient/partial positive (respectively ++ and +) or negative (respectively --and -) support to softgoals Secure, Usable, Maintainable, Attract New Customers and Increase Market Share. The result of this means-ends analysis is a set of (system and human) actors who are dependees for some of the dependencies that have been postulated.</p><p>Figure <ref type="figure" target="#fig_3">5</ref> suggests one possible assignment of responsibilities identified for Medi@. The Medi@ system is decomposed into four sub-actors: Store Front, Billing Processor, Service Quality Manager and Back Store.</p><p>Store Front interacts primarily with Customer and provides her with a usable frontend web application. Back Store keeps track of all web information about customers, products, sales, bills and other data of strategic importance to Media Shop. Billing Processor is in charge of the secure management of orders and bills, and other financial data; also of interactions to Bank Cpy. Service Quality Manager is introduced in order to look for security gaps, usability bottlenecks and maintainability issues. All four sub-actors need to communicate and collaborate. For instance, Store Front communicates to Billing Processor relevant customer information required to process bills. For the rest of the section, we focus on Store Front. This actor is in charge of catalogue browsing and item database searching, also provides on-line customers with detailed information about media items. We assume that different media shops working with Medi@ may want to provide their customers with various forms of information retrieval (Boolean, keyword, thesaurus, lexicon, full text, indexed list, simple browsing, hypertext browsing, SQL queries, etc.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Telecom Cpy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Accounting</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Buy Media Items</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bills</head><p>Store Front is also responsible for supplying a customer with a web shopping cart to keep track of selected items. We assume that different media shops using the Medi@ system may want to provide customers with different kinds of shopping carts with respect to their internet browser, plug-ins configuration or platform or simply personal wishes (e.g., Java mode, simple browser, frame-based, CGI shopping cart,…) Finally, Store Front initializes the kind of processing that will be done (by Billing Processor) for a given order (phone/fax, internet standard form or secure encrypted form). We assume that different media shop managers using Medi@ may be processing various types of orders differently, and that customers may be selecting the kind of delivery system they would like to use (UPS, FedEx, …).</p><p>Resource, task and softgoal dependencies correspond naturally to functional and non-functional requirements. Leaving (some) goal dependencies between system actors and other actors is a novelty. Traditionally, functional goals are "operationalized" during late requirements <ref type="bibr" target="#b6">[7]</ref>, while quality softgoals are either operationalized or "metricized" <ref type="bibr" target="#b7">[8]</ref>. For example, Billing Processor may be operationalized during late requirements analysis into particular business processes for processing bills and orders. Likewise, a security softgoal might be operationalized by defining interfaces which minimize input/output between the system and its environment, or by limiting access to sensitive information. Alternatively, the security requirement may be metricized into something like "No more than X unauthorized operations in the system-to-be per year".</p><p>Leaving goal dependencies with system actors as dependees makes sense whenever there is a foreseeable need for flexibility in the performance of a task on the part of the system. For example, consider a communication goal "communicate X to Y". According to conventional development techniques, such a goal needs to be operationalized before the end of late requirements analysis, perhaps into some sort of a user interface through which user Y will receive message X from the system. The problem with this approach is that the steps through which this goal is to be fulfilled (along with a host of background assumptions) are frozen into the requirements of the system-to-be. This early translation of goals into concrete plans for their fulfillment makes systems fragile and less reusable.</p><p>In our example, we have left three goals in the late requirements model. The first goal is Usability because we propose to implement Store Front and Service Quality Manager as agents able to automatically decide at run-time which catalogue browser, shopping cart and order processor architecture fit best customer needs or navigator/platform specifications. Moreover, we would like to include different search engines, reflecting different search techniques, and let the system dynamically choose the most appropriate. The second key softgoal in the late requirements specification is Security. To fulfil it, we propose to support in the system's architecture a number of security strategies and let the system decide at run-time which one is the most appropriate, taking into account environment configurations, web browser specifications and network protocols used. The third goal is Maintainability, meaning that catalogue content, database schema, and architectural model can be dynamically extended to integrate new and future web-related technologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Architectural Design</head><p>A system architecture constitutes a relatively small, intellectually manageable model of system structure, which describes how system components work together. For our case study, the task is to define (or choose) a web-based application architecture. The canonical web architecture consists of a web server, a network connection, HTML/XML documents on one or more clients communicating with a Web server via HTTP, and an application server which enables the system to manage business logic and state. This architecture is not intended to preclude the use of distributed objects or Java applets; nor does it imply that the web server and application server cannot be located on the same machine.</p><p>By now, software architects have developed catalogues of web architectural styles (e.g., <ref type="bibr" target="#b5">[6]</ref>). The three most common styles are the Thin Web Client, Thick Web Client and Web Delivery. Thin Web Client is most appropriate for applications where the client has minimal computing power, or no control over its configuration. The client requires only a standard forms-capable web browser. Thick Web Client extends the Thin Web Client style with the use of client-side scripting and custom objects, such as ActiveX controls and Java applets. Finally, Web Delivery offers a traditional client/server system with a web-based delivery mechanism. Here the client communicates directly with object servers, bypassing HTTP. This style is appropriate when there is significant control over client and network configuration.</p><p>The first task during architectural design is to select among alternative architectural styles using as criteria the desired qualities identified earlier. The analysis involves refining these qualities, represented as softgoals, to sub-goals that are more specific and more precise and then evaluating alternative architectural styles against them, as shown in Figure <ref type="figure" target="#fig_4">6</ref>. The styles are represented as operationalized softgoals (saying, roughly, "make the architecture of the new system Web Delivery-/Thin Web-/Thick Web-based") and are evaluated with respect to the alternative non-functional softgoals as shown in Figure <ref type="figure" target="#fig_4">6</ref>. Design rationale is represented by claim softgoals drawn as dashed clouds. These can represent contextual information (such as priorities) to be considered and properly reflected into the decision making process. Exclamation marks (! and !!) are used to mark priority softgoals while a check-mark "✔" indicates a fulfilled softgoal, while a cross "✕ " labels a unfulfillable one. The Usability softgoal has been AND-decomposed into sub-goals Comprehensibility, Portability and Sophisticated Interface. From a customer perspective, it is important for Medi@ to be intuitive and ergonomic. The look-and-feel of the interface must naturally guides customer actions with minimal computer knowledge. Equally strategic is the portability of the application across browser implementations and the quality of the interface. Note that not all HTML browsers support scripting, applets, controls and plug-ins. These technologies make the client itself more dynamic, and capable of animation, fly-over help, and sophisticated input controls. When only minimal business logic needs to be run on the client, scripting is often an easy and powerful mechanism to use. When truly sophisticated logic needs to run on the client, building Java applets, Java beans, or ActiveX controls is probably a better approach. A comparable analysis is carried out for Security and Maintainability.</p><p>As shown in Figure <ref type="figure" target="#fig_4">6</ref>, each of the three web architectural styles contributes positively or negatively to the qualities of interest. For instance, Thin Web Client is useful for applications where only the most basic client configuration can be guaranteed. Hence, this architecture does well with respect to Portability. However, it has a limited capacity to support Sophisticated User Interfaces. Moreover, this architecture relies on a connectionless protocol such as HTTP, which contributes positively to system availability.</p><p>On the other hand, Thick Web Client is generally not portable across browser implementations, but can more readily support sophisticated interfaces. As with Thin Web Client, all communication between client and server is done with HTTP, hence its positive contribution to Availability. On the negative side, client-side scripting and custom objects, such as ActiveX controls and Java applets, may pose risks to client confidentiality. Last but not least, Web Delivery is highly portable, since the browser has some built-in capabilities to automatically download the needed components from the server. However, this architecture requires a reliable network.</p><p>This phase also involves the introduction of new system actors and dependencies, as well as the decomposition of existing actors and dependencies into sub-actors and sub-dependencies which are delegated some of the responsibilities of the key system actors introduced earlier.</p><p>Figure <ref type="figure" target="#fig_5">7</ref> focuses on the latter kind of refinement. To accommodate the responsibilities of Store Front, we introduce Item Browser to manage catalogue navigation, Shopping Cart to select and custom items, Customer Profiler to track customer data and produce client profiles, and On-line Catalogue to deal with digital library obligations. To cope with the non-functional requirement decomposition proposed in Figure <ref type="figure" target="#fig_4">6</ref>, Service Quality Manager is further refined into four new system sub-actors Usability Manager, Security Checker, Maintainability Manager and Performance Monitor, each of them assuming one of the top main softgoals explained previously. Further refinements are shown on Figure <ref type="figure" target="#fig_5">7</ref>.</p><p>An interesting decision that comes up during architectural design is whether fulfillment of an actor's obligations will be accomplished through assistance from other actors, through delegation ("outsourcing"), or through decomposition of the actor into component actors. Going back to our running example, the introduction of other actors described in the previous paragraph amounts to a form of delegation in the sense that Store Front retains its obligations, but delegates subtasks, sub-goals etc. to other actors. An alternative architectural design would have Store Front outsourcing some of its responsibilities to some other actors, so that Store Front removes itself from the critical path of obligation fulfilment. Lastly, StoreFront may be refined into an aggregate of actors which, by design work together to fulfil Store Front's obligations. This is analogous to a committee being refined into a collection of members who collectively fulfil the committee's mandate. It is not clear, at this point, how the three alternatives compare, nor what are their respective strengths and weaknesses. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Manager</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Detailed Design</head><p>The detailed design phase is intended to introduce additional detail for each architectural component of a system. In our case, this includes actor communication and actor behavior. To support this phase, we propose to adopt existing agent communication languages, message transportation mechanisms and other concepts and tools. One possibility, for example, is to adopt one of the extensions to UML proposed by the FIPA (Foundation for Intelligent Agents) and the OMG Agent Work group <ref type="bibr" target="#b13">[14]</ref>. The rest of the section concentrates on the Shopping cart actor and the check out dependency.</p><p>To specify the checkout task, for instance, we use AUML -the Agent Unified Modeling Language <ref type="bibr" target="#b13">[14]</ref>, which supports templates and packages to represent checkout as an object, but also in terms of sequence and collaborations diagrams.</p><p>Figure <ref type="figure" target="#fig_7">8</ref> focuses on the protocol between Customer and Shopping Cart which consists of a customization of the FIPA Contract Net protocol <ref type="bibr" target="#b13">[14]</ref>. Such a protocol describes a communication pattern among actors, as well as constraints on the contents of the messages they exchange.</p><p>When a Customer wants to check out, a request-for-proposal message is sent to Shopping Cart, which must respond before a given timeout (for network security and integrity reasons). The response may refuse to provide a proposal, submit a proposal, or express miscomprehension. The diamond symbol with an "✕ " indicates an "exclusive or" decision. If a proposal is offered, Customer has a choice of either accepting or canceling the proposal. The internal processing of Shopping Cart's checkout plan is described in Figure <ref type="figure" target="#fig_8">9</ref>.  At the lowest level, we use plan diagrams <ref type="bibr" target="#b11">[12]</ref> (See Figure <ref type="figure" target="#fig_8">9</ref>), to specify the internal processing of atomic actors. The initial transition of the plan diagram is labeled with an activation event (Press checkout button) and activation condition ([checkout button activated]) which determine when and in what context the plan should be activated. Transitions from a state automatically occur when exiting the state and no event is associated (e.g., when exiting Fields Checking) or when the associated event occurs (e.g., Press cancel button), provided in all cases that the associated condition is true (e.g., [Mandatory fields filled]). When the transition occurs any associated action is performed (e.g., verifyCC()).</p><p>An important feature of plan diagrams is their notion of failure. Failure can occur when an action upon a transition fails, when an explicit transition to a fail state (denoted by a small no entry sign) occurs, or when the activity of an active state terminates in failure and no outgoing transition is enabled.</p><p>Figure <ref type="figure" target="#fig_8">9</ref> depicts the plan diagram for checkout, triggered by pushing the checkout button. Mandatory fields are first checked. If any mandatory fields are not filled, an iteration allows the customer to update them. For security reasons, the loop exits after 5 tries ([i&lt;5]) and causes the plan to fail. Credit Card validity is then checked. Again for security reasons, when not valid, the CC# can only be corrected 3 times. Otherwise, the plan terminates in failure. The customer is then asked to confirm the CC# to allow item registration. If the CC# is not confirmed, the plan fails. Otherwise, the plan continues: each item is iteratively registered, final amounts are calculated, stock records and customer profiles are updated and a report is displayed. When finally the whole plan succeeds, the ShoppingCart automatically logs out and asks the Order Processor to initialize the order. When, for any reason, the plan fails, the ShoppingCart automatically logs out. At anytime, if the cancel button is pressed, or the timeout is more than 90 seconds (e.g., due to a network bottleneck), the plan fails and the Shopping Cart is reinitialized. JACK Intelligent Agents <ref type="bibr" target="#b3">[4]</ref> is an agent-oriented development environment designed to provide agent-oriented extensions to Java. JACK agents can be considered autonomous software components that have explicit goals to achieve, or events to cope with (desires). To describe how they should go about achieving these desires, agents are programmed with a set of plans (intentions).</p><p>Each plan describes how to achieve a goal under different circumstances. Set to work, the agent pursues its given goals (desires), adopting the appropriate plans (intentions) according to its current set of data (beliefs) about the state of the world. To support the programming of BDI agents, JACK offers five principal language constructs. These are agents, capabilities, database relations, events, and plans. I* actors, (informational/data) resources, softgoals, goals and tasks will be respectively mapped into BDI agents, beliefs, desires and intentions. In turn, a BDI agent will be mapped as a JACK agent, a belief will be asserted (or retracted) as a database relation, a desire will be posted (sent internally) as a BDIGoalEvent (representing an objective that an agent wishes to achieve) and handled as a plan, and an intention will be implemented as a plan. Finally, an i* dependency will be directly realized as a BDIMessageEvent (received by agents from other agents).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion and Discussion</head><p>We have proposed a development methodology founded on intentional concepts, and inspired by early requirements modeling. We believe that the methodology is particularly appropriate for generic, componentized systems like e-business applications that can be downloaded and used in a variety of operating environments and computing platforms around the world. Preliminary results suggest that the methodology complements well proposals for agent-oriented programming environments.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Means-ends analysis for the softgoal Increase Market Share</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Strategic dependency model for a media shop</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Strategic rationale model for Medi@</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. The web system consists of four inside actors, each with external dependencies</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Refining softgoals in architectural design</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Strategic Dependency Model for Medi@ actors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Agent interaction protocol focusing on a checkout dialogue</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. A plan diagram for checkout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10</head><label>10</label><figDesc>depicts the JACK layout presenting each of the five JACK constructs as well as the implementation of the first part of the dialogue shown in Figure 8. The request for proposal checkout-rfp is a MessageEvent (extends MessageEvent) sent by Customer and handled by the Shopping Cart's checkout plan (extends Plan) as detailed in Figure 9. Finally, Timeout (which we consider a belief) is implemented as a closed world (i.e., true or false) database relation asserting for each Shopping Cart one or several timeout delays.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Partial implementation of Figure 8 in JACK</figDesc><graphic coords="15,181.16,213.62,261.64,265.90" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>There already exist some proposals for agent-oriented software development, most notably <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16]</ref>. Such proposals are mostly extensions to known objectoriented and/or knowledge engineering methodologies. Moreover, all these proposals focus on design --as opposed to requirements analysis --for agent-oriented software and are therefore considerably narrower in scope than Tropos.</p><p>Of course, much remains to be done to further refine the proposed methodology and validate its usefulness with real case studies. We are currently working on the development of formal analysis techniques for Tropos, also the development of tools which support different phases of the methodology.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>† This work was carried out during a visit to the Department of Computer Science, University of Toronto. Partially supported by the CNPq -Brazil under grant 203262/86-7.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Unified Modeling Language User Guide</title>
		<author>
			<persName><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">The Addison-Wesley Object Technology Series</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Developing Agent-Oriented Information Systems for the Enterprise</title>
		<author>
			<persName><forename type="first">J</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kolp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference On Enterprise Information Systems (ICEIS00)</title>
		<meeting>the Second International Conference On Enterprise Information Systems (ICEIS00)<address><addrLine>Stafford, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-07">July 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Nixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</author>
		<title level="m">Non-Functional Requirements in Software Engineering</title>
		<imprint>
			<publisher>Kluwer Publishing</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Coburn</surname></persName>
		</author>
		<title level="m">Jack Intelligent Agents: User Guide version 2.0, AOS Pty Ltd</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Intention is Choice with Commitment</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="213" to="261" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Building Web Applications with UML</title>
		<author>
			<persName><forename type="first">J</forename><surname>Conallen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">The Addison-Wesley Object Technology Series</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Goal-directed Requirements Acquisition</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dardenne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Van Lamsweerde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fickas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="3" to="50" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Software Requirements: Objects, Functions and States</title>
		<author>
			<persName><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Demarco</surname></persName>
		</author>
		<title level="m">Structured Analysis and System Specification</title>
		<imprint>
			<publisher>Yourdon Press</publisher>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Survey of Agent-Oriented Methodologies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Iglesias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Garrijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Workshop on Intelligent Agents: Agent Theories, Architectures, and Languages (ATAL-98)</title>
		<meeting>the 5th International Workshop on Intelligent Agents: Agent Theories, Architectures, and Languages (ATAL-98)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-07">July 1998</date>
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">On agent-based software engineering</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="277" to="296" />
		</imprint>
	</monogr>
	<note>Artificial lntelligence, 117, 2000</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Modelling and Design of Multi-Agent System</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on Agent Theories, Architectures, and Languages (ATAL-96)</title>
		<meeting>the Third International Workshop on Agent Theories, Architectures, and Languages (ATAL-96)<address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Tropos: A Framework for Requirements-Driven Software Development</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Castro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Systems Engineering: State of the Art and Research Themes</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Brinkkemper</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Solvberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000-06">June 2000</date>
			<biblScope unit="page" from="261" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Extending UML for Agents</title>
		<author>
			<persName><forename type="first">J</forename><surname>Odell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van Dyke Parunak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Agent-Oriented Information System Workshop at the 17 National Conference on Artificial Intelligence</title>
		<meeting>the Agent-Oriented Information System Workshop at the 17 National Conference on Artificial Intelligence<address><addrLine>Austin, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-07">July 2000</date>
			<biblScope unit="page" from="3" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Designing Object-Oriented Software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wirfs-Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wiener</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The Gaia Methodology for Agent-Oriented Analysis and Design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Autonomous Agents and Multi-Agent Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design</title>
		<author>
			<persName><forename type="first">E</forename><surname>Yourdon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Constantine</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Modelling Strategic Relationships for Process Reengineering</title>
		<author>
			<persName><forename type="first">E</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Canada</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
