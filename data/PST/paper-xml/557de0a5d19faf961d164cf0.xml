<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Main Memory Oriented Optimization of 00 Queries Using Typed Datalog with Foreign Predicates</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Witold</forename><surname>Litwin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Dauphine University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tore</forename><surname>Risch</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Dauphine University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Linkoping Univer-sity</orgName>
								<address>
									<postCode>581 83</postCode>
									<settlement>Linkoping</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Main Memory Oriented Optimization of 00 Queries Using Typed Datalog with Foreign Predicates</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">98D96A7AD2AE753D47A62663D756DB0E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Main memory database</term>
					<term>object-oriented database system (OODB)</term>
					<term>object-oriented (00) query language</term>
					<term>query optimization</term>
					<term>foreign predicates</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Object-oriented DBMS's (OODB's) have created a demand for relationally complete, extensible, and declarative object-oriented (00) query languages. Until now, runtime performance of such languages was far behind that of procedural 00 interfaces. One reason is the internal use of a relational engine with magnetic disk resident databases. We address the processing of the declarative 00 language WS-OSQL, provided by the fully operational prototype OODB called WS-IRIS. A WS-IRIS database is main memory (MM) resident. The system architecture, data structures, and optimization techniques are designed accordingly. WS-OSQL queries are compiled into an 00 extension of Datalog called ObjectLog, providing for objects, typing, overloading, and foreign predicates for extensibility. We present cost-based optimizations in WS-IRIS using ObjectLog. Performance tests show that WS-IRIS is about as fast as current OODB's with procedural interfaces only and is much faster than known relationally complete systems. These results would not be possible for a traditional disk-based implementation. However, MM residency of a database appears only a necessary condition for better performance. An efficient optimization proves of crucial importance as well.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>0 database systems (OODB's) have grown in popularity 0 <ref type="bibr">[13]</ref>, <ref type="bibr">[14]</ref>, <ref type="bibr" target="#b29">[27]</ref>. Most existing OODB's have navigational languages for object manipulation. A new trend has been to provide them with declarative query languages [3], <ref type="bibr">[4]</ref>, <ref type="bibr">[lo]</ref>, <ref type="bibr">[12]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b33">[31]</ref>, possibly extensible through foreign methods or functions <ref type="bibr">[7]</ref>, <ref type="bibr" target="#b32">[30]</ref>. Implementation of query languages has led to the problem of query optimization. Little is yet published about this subject for OODB's, but two approaches can be identified.</p><p>1) The object model is internally processed by a relational engine. Queries are optimized accordingly [ 103, <ref type="bibr" target="#b32">[30]</ref>, <ref type="bibr" target="#b25">[37]</ref> by using relational algebra. 2) A dedicated 00 algebra is defined <ref type="bibr">[9]</ref>, <ref type="bibr" target="#b31">[29]</ref>, <ref type="bibr" target="#b33">[31]</ref>.</p><p>Queries are optimized using corresponding transformation rules. We do not know any implemented system using the second approach. The current proposals are limited to optimization using algebraic operators, and cite the development of fully operational optimizers as a future goal <ref type="bibr" target="#b33">[31]</ref>. The first approach seems at present the leading one for fully implemented systems <ref type="bibr">[lo]</ref>, <ref type="bibr" target="#b32">[30]</ref>, <ref type="bibr" target="#b25">[37]</ref>, since relational optimization techniques are well understood. However, it is easy to see that this approach is limited. While one rationale for OODB's is much higher efficiency than RDB's, the first approach is basically limited by relational storage performance, although 00 dedicated index structures and statistics can help overcome this limitation [ 121. Another problem is that the semantics of the relational model are more limited than that required for an 00 query language Furthermore, relational optimization techniques were developed for classical (magnetic) disk-based very large shared databases, where only a small part of the database could fit the fast main memory (MM). They are partly obsoleted by the progress in hardware and by new working environments, especially the powerful interoperable workstations with individual (personal) databases, and MM's comparable to those of mainframes a few years ago.' A PC can now handle MM storage of 32-64 Mbyte at a cost of $36 per Mbyte, while servers can have gigabytes <ref type="bibr">[18]</ref>. As 00 databases on workstations are usually not larger than that, it is now possible to fit all or most of an entire database in MM.' Also, MM has become reliable enough to support data for extended periods of time (e.g., weeks or months) without any crashes. Hence, the interaction with the disk for reliability purposes can be much more infrequent, i.e., individual updates need not be committed to the disk. All this progress requires a revision of traditional database designs, but opens the way to performance that no classical implementation could achieve <ref type="bibr">[18]</ref>.</p><p>One can also observe that logical languages such as Datalog (341 are attractive candidates for the efficient processing of declarative 00 queries. Their expressive power often exceeds that of the relational languages, primarily through their recursion capabilities <ref type="bibr">[6]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b36">[34]</ref>, and their optimization principles are fairly well understood <ref type="bibr">[6]</ref>, <ref type="bibr" target="#b36">[34]</ref>. In particular, the relational algebra of the first approach can be generated from a logical language for nonrecursive queries <ref type="bibr" target="#b36">[34]</ref> and subsequently optimized <ref type="bibr">[15]</ref>, <ref type="bibr">[28]</ref>. However, Datalog lacks update semantics, and 00 features such as typing and OID management which makes it impractical to use pure Datalog to process 00 queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~311.</head><p>'Large RAM disks have become available as compatible suhstitutes for 2Future databases perhaps will be larger, but MM will be larger as well, at magnetic disk, but we consider such devices as MM. a much lower price per megabyte. 1041-4347/92$03.00 0 1992 IEEE We have built a prototype OODB termed WS-IRIS (Workstation IRIS) that is based on these considerations. WS-IRIS' query language, called WS-OSQL, is an extension of the 00 declarative query language of IRIS, termed OSQL.</p><p>After optimization of type checking, the WS-OSQL queries are translated to an 00 generalization of Datalog, termed ObjectLog. The ObjectLog queries are optimized through costbased rule rewriting and through reordering for safety, which are well-known techniques from logic query languages [ 6 ] , <ref type="bibr" target="#b36">[34]</ref>. For processing, the database is entirely in MM, and largely uses MM oriented data structures such as arrays, hash tables, and linked lists. These prove to be more efficient than relational storage for 00 operations, e.g., for type checking and method selection. WS-IRIS also provides concurrency control, logging, commit, rollback, and recovery facilities. The granularity of the concurrency control is at present the entire database, which is often sufficient for a personal DBMS. For recovery, there is a backup copy on the disk, and a background process saves the database on the disk using the well known copy-on-write Unix facility.' Unlike other 00 systems we know of, WS-IRIS optimizes multiway foreign function calls, i.e., where only the result of the function is known and the system finds the corresponding argument(s). This is done using foreign predicates, generalizing the concept of external predicates in CDC <ref type="bibr">[6]</ref>.</p><p>A multiway foreign function can be transparently mapped to a set of foreign predicates sharing the function name but differently implemented in C.4 For example, a function accessing an array can be mapped into two foreign predicates, one for directly accessing an array element when its index is known, and another resolving a call with unknown index value through scanning the array. The resolvent choice is in general based on the cost estimate from the cost functions attached to foreign predicates. The overall benefit for the user is enhanced polymorphism of foreign function calls.</p><p>Foreign predicates further allow for inferencing through constraints <ref type="bibr">[17]</ref>. For instance, the WS-OSQL user can define a function converting Fahrenheit to Celsius and the system will infer the reverse conversion from Celsius to Fahrenheit.</p><p>In what follows, we present the WS-OSQL query processing and optimization. Section I1 overviews the languages of WS-IRIS. Section 111 shows the steps for query transformation. Section IV describes the optimizations within each step. Section V discusses foreign predicates. Section VI presents performance measurements.</p><p>The measures show that query evaluation according to the proposed principles can be several orders of magnitude faster than naive evaluation despite the MM processing speed. For instance, for a database of 10 000 objects, the improvement can be from 13 min to 1.1 ms. Such a fast evaluation would not be possible for a traditional disk-based implementation, being faster than even a single disk access. On the other hand, the results prove that without effective optimization, the system would be too slow for many applications, despite its MM implementation.</p><p>'In case of a system crash the database can be reloaded from the disk with 4Alternatives LISP or IPL <ref type="bibr">(21.</ref> the log rolled forward. We show further that altogether the speed of WS-IRIS is comparable to that of OODB's currently providing only navigational access [ 131, <ref type="bibr" target="#b20">[21]</ref>, even for large workstation data base^.^ WS-IRIS allows us therefore, to use a relationally complete declarative language for typical 00 applications where high efficiency is the primary concern. This is a major advantage of WS-IRIS, since to write a declarative query is usually much faster than to write a navigational program.6 <ref type="bibr">[32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">THE WS-OSQL LANGUAGE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The OSQL Language</head><p>WS-OSQL is a dialect of OSQL that is the query language for IRIS systems <ref type="bibr">[lo]</ref>. OSQL uses the concepts of types, objects, and functions. Objects are represented through typed atomic object identifiers (OID's), and functions associate properties to objects or define relationships between objects. Functions model object attributes and relationships between objects through three basic function types:</p><p>1) Stored functions that are tables.</p><p>2) Derived functions that are defined through OSQL se-</p><p>3) Foreign functions that are defined using an external Fig. <ref type="figure" target="#fig_0">1</ref> shows some of the OSQL functions and types used in this paper. Objects of type Person have the properties Income Bonus, Parent GrossIncome, and GrandSParentGrossIncome. These are OSQL functions of a single argument bound to objects of type Person. Local variables are declared using the "for each" clause.</p><p>The GrandSParentGrossIncome function will be our running example. It illustrates important 00 needs, such as efficient traversal of object hierarchies, static and dynamic type checking, inheritance, and overloading (the Income function).' lect statements. programming language.</p><p>The function Plus in the derived function GrossIncome is a foreign function, implemented in C outside WS-OSQL. GrossIncome itself, as any derived function, is defined through the select statement that follow the "as" keyword. The stored functions Parent, and GrandSparentGross-Income return sets of values.</p><p>In general, the arguments and results of a function together with their types are called the signature of the function. We denote signatures by OSQL has a SQL-like select statement both for ad hoc queries to the database and for defining derived functions.</p><p>Overloaded functions are OSQL functions sharing a name for different definitions. In Fig. <ref type="figure" target="#fig_0">1</ref> there are two variants, or resolvents, of the overloaded Income function. Both resolvents provide a person's income, the first one is given an OID of an object of type Person, while the other is given a name as a string. Resolvents can be any of the three basic function types. WS-IRIS then chooses the resolvent according to the argument type, at compile or at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. New Features in WS-OSQL Language</head><p>The main new features of WS-OSQL (261, are multiway foreign functions, a limited form of recursion, late binding of overloaded functions, and second-order functions. WS-OSQL furthermore has aggregation operators, nested subqueries, disjunctive queries, and quantifiers, and is relationally complete. The user can also provide cost hints to the optimizer as OSQL functions. We discuss these possibilities more in depth in the sections that follow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. ObjectLog</head><p>WS-OSQL compiles into its intermediate language a language we termed ObjectLog. ObjectLog is inspired by Datalog and CDDC but provides new facilities for effective processing of 00 queries. ObjectLog generalizes the polymorphic type extensions proposed for Prolog <ref type="bibr" target="#b21">[22]</ref> by providing a type hierarchy, late binding, update semantics, and foreign predicates. The following are its most important features.</p><p>Predicate arguments are objects, where each object belongs to one or more types organized in a type hierarchy that corresponds to the type hierarchy of Iris [lo]. Object creation and deletion semantics maintain the referential integrity of the type hierarchy. Update semantics of predicates preserve type integrity of arguments. The optimizer relies on this to avoid dynamic type checking in queries (Section IV-A).</p><p>Predicates can be overloaded on the types of their arguments. We call the corresponding resolvent a type resolved (TR) predicate (Section 111-C).</p><p>8The brackets around the result are optional for functions returning a single result.</p><p>. Predicates can be further overloaded 519 on the binding patterns of their arguments, i.e., on which arguments are bound or free when the predicate is called. We call each corresponding resolvent a fype and binding pattern resolved (TBR) predicate (Section 111-D). Predicates can be not only facts and rules, but also multiway foreign predicates implemented in a procedural language.' Foreign predicates implement foreign functions, especially multiway foreign functions (Section V). Predicates themselves as well as types are objects, and there are second-order predicates that produce or apply other predicates. Second-order predicates are crucial, e.g., for late binding (Section IV-A.1)) and recursion (Section V-D).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">QUERY PROCESSING STEPS</head><p>A WS-OSQL query is defined through a select statement. WS-IRIS compiles ad hoc queries as if they were unnamed derived functions, and vice versa, functions can be seen as views defined through queries, like in SQL. A query or a function definition is compiled to ObjectLog representation. The compiler transforms a function or a query in several steps, shown top-down in Fig. <ref type="figure">2</ref>. We now summarize these steps; the next section describes the query processing algorithms more in detail. Examples refer to the compilation of functions only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Flattener</head><p>As Datalog, ObjectLog does not allow function symbols to appear in arguments. Therefore, the compiler first transforms WS-OSQL select statements into flattened select statements, without functions in the result list and without function nesting in the predicate. We flatten select statements by recursively introducing intermediate variables for each nested function call.  </p><p>-&gt; I n t e g e r g i a s </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Type Checker</head><p>Type checking has three phases.</p><p>During the type adornment phase, the translator identifies type-adorned (TA) resolvents of a flattened function by annotating the name of the function with the names of its signature types. An overloaded function has a TA resolvent for each definition. For example, Income in Fig. <ref type="figure" target="#fig_0">1</ref> has the TA resolvents: and Then an overloud resolution algorithm (Section IV-A) substitutes function calls in the flattened select statement with their TA resolvents. Fig. <ref type="figure" target="#fig_5">4</ref> shows the result for the function GrandSParentGrossIncome. This algorithm cannot be applied to late-bound function calls, in which case the overload resolution has to be done at runtime (Section IV-A.l)).</p><p>Finally, the optimizer adds dynamic type checks to the function definition whenever the type of a variable cannot be guaranteed to be of the desired type assuming the referential integrity of updates. This is the case of the function SParent (Fig. <ref type="figure">l</ref>), where the system must dynamically check that the variable s is of type Student, since the function Parent returns Person objects not always being Student objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. ObjectLog Generator</head><p>The ObjectLog generator transforms TA resolvents into TR ObjectLog programs Stored functions become TR facts. For example the TA resolvent I n c o m e ~c r s o r r -~n t r r I r r would generate the TR fact incOmep,7,,,,.InteyL.i</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>( p , I ) .</head><p>Derived functions become TR rules. The signature becomes the head of the rule and the select statement becomes the rule body. Fig. <ref type="figure" target="#fig_6">5</ref> shows the TR rule of the derived function GrandSParentGrossIncome.</p><p>Finally, the foreign functions become TR foreign predicates. We'll discuss this transformation in Section V. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. ObjectLog Optimizer</head><p>Each WS-OSQL function is compiled into a TBR predicate where bound predicate arguments correspond to the arguments of the function, and the unbound arguments correspond to the results. The function is optimized for execution in the forward direction where arguments are known and results computed. The rationale is that functions are normally used as methods that compute properties of the arguments. Functions can nevertheless also be used inversely, in which case the optimizer will generate different TBR predicates.</p><p>The TR rules constitute the entry to the ObjectLog optimizer. The outcome is optimized TBR rules. The optimization algorithm use results in <ref type="bibr">[15]</ref>, <ref type="bibr" target="#b36">[34]</ref> for rule reordering, and <ref type="bibr">[6]</ref> for foreign predicate optimization. However, these results had to be revisited for ObjectLog, because of the overloading on binding patterns. The consequence is a larger space of safe reorderings to choose the optimal one from. The increase is obtained in two ways.</p><p>The explicit definition of the set of resolvents, S ( P ) , overloading a TR predicate, P , provided by the user as part of a foreign function definition (Section V-A).</p><p>The completion algorithm (Section V-C) that can infer from S ( P ) yet other resolvents. The search space is then explored using greedy heuristics to find the cheapest reordering according to the cost model in [ 1.51. Two benefits result from the ObjectLog approach with respect to the algorithm in <ref type="bibr">[6]</ref>.</p><p>A more efficient optimized program can be chosen.</p><p>There can be TBR programs that would have no solution in a smaller search space. This is, e.g., the case of the constraint inferencing (Section V-A), and of examples in [I61 (Section VIII-C), and <ref type="bibr" target="#b35">[33,</ref><ref type="bibr">Fig. 7</ref> shows the optimal TBR program for the function GrandSParentGrossIncome that will be justified later. Each literal refers to TBR predicate names, where superscripts "b" and " f " stand for bound argument and free argument, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. ObjectLog Interpreter</head><p>The ObjectLog interpreter executes the TBR program with b marked arguments bound to produce the corresponding result tuples. For instance would be invoked if a query about GrandSParentGross-Income for a given Person was submitted. The interpreter uses a top-down interpretation method that corresponds to the nested-loop method in relational databases [ 151."'</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. OPTIMIZATION ALGORITHMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Type Checking</head><p>It is advantageous for efficiency to perform overload resolution at compile time whenever possible. In particular, it is advantageous for choosing the best TBR program, because late binding makes rule substitution and thus global optimization impossible. Thus late binding should be used only when semantically necessary.</p><p>For dynamic type checking there is a built-in foreign function, TypesOf, that returns the set of types to which a given object belongs:</p><formula xml:id="formula_1">TypesOf (Object 0 ) + Type t .</formula><p>The simplest processing strategy is to add TypesOf to each variable declared in a function body (Fig. <ref type="figure">S</ref>)." This strategy, however, sometimes introduces unnecessary checks. The type checker avoids such checks through the following rule:</p><p>[Type Check Removal:] Consider a TA function f , invoked in a select statement: Variables, 4, are declared of type D,. If T, is D, or a subtype of D,, then one may remove the type check for A,.</p><p>'"By contrast, NAIL1 <ref type="bibr" target="#b36">[34]</ref> uses a bottom-up method for efficient hmdliny of a class of recursive queries l1 The variables typeInteger, typestudent, and typeperson refer to objects representing the types named "Integer" "Student", and "Person", respectively</p><p>The type check removal rule is valid since types of the arguments and results of f are constrained by the referential integrity system for stored functions and by type checking for derived functions.</p><p>It turns out that all TypesOf calls in Fig. <ref type="figure" target="#fig_7">8</ref> prove unnecessary. The type check </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I)</head><p>Lute Binding: It is advantageous for efficiency to perform overload resolution at compile time whenever possible. In particular, it is advantageous for choosing the best TBR program, as late binding makes some optimizations impossible. Thus late binding should be used only when semantically necessary. In WS-OSQL a special keyword, late, indicates to the type checker when late binding is to be used in an OSQL function call.</p><p>The query processor generates a "generic" TBR predicate on the universal type Object for every overloaded OSQL function. The generic predicate does dynamic overload resolution to handle late binding. For example, the OSQL function Income in Fig. <ref type="figure" target="#fig_0">1</ref> will generate a generic predicate</p><p>The generic TBR predicate is implemented as a call to a second-order foreign system predicate, apply. This predicate first does the type resolution at runtime based on the types of the actual argument values, and calls the selected TBR predicate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. ObjectLog Optimizer</head><p>For example, the TR rule 1) Rule Substitution: A TR rule can refer to other TR rules.</p><p>(Fig. <ref type="figure" target="#fig_6">5</ref>) refers to the TR rules SParentPErson,student, and GrossIncomep,,sor,,~ntrytr. The rule substitution phase combines such rules into one larger rule, whenever possible, e.g., there is no recursion (see [34, vol. 11, sec. 13.41). The reason is that the global optimization of a set of substituted rules often proves more efficient than local optimization of individual rules. Fig. <ref type="figure">6</ref> shows the rule substituted TR program of GrandSParentGrossIncomep, , ion ~~, t ~~~~.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Cost Model for Rule Reordering:</head><p>a. The basis: Choice of bindings through rule reordering (e.g., join ordering, selection pushing) and of access methods (e.g., join method, index creation/use) are among the most important techniques for optimizing Datalog queries [34], as well as for relational queries in general <ref type="bibr">[28]</ref>.</p><p>Traditional optimizers have exponential optimization time over the number of literals in a rule Cjoins) <ref type="bibr">[28]</ref>. This proves inconvenient for WS-OSQL, and the WS-IRIS default is a heuristic optimization [ 151 which produces query plans in quadratic time. The rest of this section presents the principles of the heuristics. They are MM oriented, as all ObjectLog data structures are in MM.</p><p>Our optimization method is a variant of the nested-loop join method, generalized for foreign predicates. No disk access costs are considered, since the entire database is in MM and eventual disk backups are done asynchronously in the background. By the same token, cluster orderings are not considered which simplifies rule reordering. Also, the MM residency costs of common primitive operations are comparable to data access costs, unlike disk resident databases. These operations are arithmetic operators, foreign function calls, etc.</p><p>b. Optimization heuristics: Let P be a TBR rule or fact.</p><p>We call the input tuple the tuple corresponding to variable(s) that are bound in P . For a given input tuple there are zero, one, or several output tuples, corresponding to unbound variable(s) in P . For each TBR predicate P two cost estimates are calculated.</p><p>1) The execution cost of P , Cp, defined as the number of visited tuples, given that all variables of the input tuple are bound.</p><p>2) The fan out, F p , which is the estimated number of output tuples produced by P for a given input tuple. The optimizer minimizes the total cost, C , to join a conjunction of literals, been populated the user can instruct the system to optimize all OSQL functions using the statistics of the populated database.</p><p>The optimizer distinguishes between joining on unique indexes, nonunique indexes, and unindexed input tuples. On an experimental basis, the defaults are currently as follows:</p><p>Fp=l if the input tuple has a unique index;</p><p>Fp=2 if it has a nonunique index; Fp=4 otherwise.</p><p>The rationale for these defaults is that input tuples with unique indexes will have a maximal possible Fp value of 1. A nonunique index is usually efficient only for a fan out slightly larger than one. Unindexed input tuples usually have fan out larger than indexed ones; that is why they remain unindexed.</p><p>The default size of a stored predicate is assumed to be 100 tuples. The corresponding defaults for Cp are:</p><p>Cp=Fp if the input tuple has an index; C'p=lOO if it is unindexed, since the system has to scan the entire table. Foreign predicates have default Fp=l and Cp=l, assuming that they are cheap to execute and return a single result tuple.</p><p>d. Cost hints: The DBA can provide cost hints for each TBR predicate, which override default assumptions about Cp and F p . Hints are particularly useful for evaluating foreign predicates. These hints are provided by the DBA as a WS-OSQL function, that for a given TBR predicate returns the two estimates Cp and Fp.</p><p>For example, the system TBR predicate</p><p>As in [15] the optimizer computes a rank, Rp,, for each P, typesof~b,c~t</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T , in { P t } ;</head><p>Then next literal to evaluate is the literal minimizing R p z , provided that it is executable (safe) at the position to be taken in the rule. The calculus is iterated until there are no literals left. The motivation for this heuristic is that to repeatedly minimize Rp, also minimizes C.</p><p>base the system estimates Cp and Fp from the cardinality of stored predicates, join selectivity, and index kind and a~ai1ability.l~ To obtain reasonable optimization even before the database is populated, the system uses the default cost parameters discussed in the following. After the database has c. Default values for cost parameters: In a populated data-computes the type of a given object X , while f h typesofobject T~lpc,(~'? computes the objects belonging to type T . Computing the type of a WS-IRIS object is very cheap, since a pointer to the types of each object is stored directly in the OID. However, finding all the objects of a given type is expensive and proportional to the number objects of the type. The cost hint functions specify these hints.</p><p>3) Example: The ObjectLog interpreter would interpret the unoptimized program of Fig. <ref type="figure">6</ref> using the nested loop algorithm of Fig. <ref type="figure" target="#fig_9">9</ref>.</p><p>Our test database has a database populated with 10 000  we can assume a constant cost of, e.g., 2 to access an index, while a basic operation (e.g. arithmetic) has cost 1.</p><p>The execution plan of Fig. <ref type="figure" target="#fig_9">9</ref> is very inefficient, because it first iterates on line 2 over the entire extension of the stored predicate income (10 000 iterations). Furthermore, on line 6 it also iterates over the extension of parent, since parent has no index on its second argument. Assuming that all other extensional predicates have indexes and that type checking is very fast, the cost of the above execution plan will be O(card(income) . card(parent)), i.e. O(108). Fig. <ref type="figure">7</ref> shows the final definition of GrandSParent-Gross Income after applying our cost heuristics. Appendix A shows the details of the calculus. The plan has a constant execution cost of 10, since indexes are used on income, bonus, and parent;, and plus and typesof are basic operations.</p><p>In Section VI we show empirical results on grandsparentgros s income that verifies the importance of this optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. FOREIGNPREDICATES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . The Rationale</head><p>Many system functions in WS-IRIS are implemented as foreign functions, e.g., for late binding (Section IV-A.l)), quantification, and aggregate functions <ref type="bibr" target="#b28">[26]</ref>. Some of them have to be multiway, e.g., TypeSOf (Section IV-A), and foreign predicates reveal a very efficient way for their implementation. Foreign predicates also open new possibilities for user defined foreign functions. For instance, they allow for constraint inferencing (compilation) [ 171 as Fig. <ref type="figure" target="#fig_0">12</ref> illustrates.</p><p>Foreign functions can have several TBR foreign predicate resolvents for different binding patterns.'3 Each TBR predicate has associated cost functions (either default or user defined). The whole concept of TBR foreign predicates generalizes that of external predicates in CDC <ref type="bibr">[6]</ref>, that were neither polymorphic over binding patterns nor over types.</p><p>As an example of the importance of foreign predicate optimization, regard the function SParent of Fig. <ref type="figure" target="#fig_0">1</ref> whose unoptimized TBR representation is shown in Fig. <ref type="figure" target="#fig_11">10</ref>. The type checker has added a call to the built-in foreign function typesof to test if the parent is a student. The above TA definition is, however, inefficient, because S is not known when iterates through and emits all objects of type Student.14 The execution time will be proportional to the number of students in the database. I4Foreign predicates, such as typesoffobh,, r.f Tyi,c are defined as generators that call a system provided C function, e m i t , for each result of a set valued foreign predicate. The generator method avoids materializing the result set, which saves MM usage significantly. By contrast, the optimal TBR program is shown in Fig. <ref type="figure" target="#fig_0">11</ref>. Its execution time is constant, since parent has a hash-based index on C and the foreign predicate typesof&amp;irct,Type is implemented as a simple check of the type tag of the object S.</p><p>The foreign predicates allow elegant implementation of the constraint compilation of [17], as Fig. <ref type="figure" target="#fig_0">12</ref> illustrates. The function ftoc in Fig. <ref type="figure" target="#fig_0">12</ref> converts Fahrenheit degrees into Celsius. Assuming the Celsius temperature is stored using ctemp, the constraint compilation allows use of ftoc as a constraint to inversely infer f temp given ctemp. Otherwise a different function, let it be ctof, would be needed, and the user would manually choose between both, depending on the query. Similarly, the functions Minus, and Div are defined as derived functions in terms of two inverted foreign functions, Plus and Times. Without the constraint compilation, Minus and Div would have to be implemented as separate foreign functions, where the user would have to choose the correct implementation depending on the query, and the system would not have been able to infer the inverse of ftoc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Reordering for Safety</head><p>While facts allow any binding patterns, foreign predicates do not. A TBR rule that refers to undefined TBR predicates is not executable at all, i.e., it is unsafe [6]. For example, Fig. <ref type="figure" target="#fig_4">13</ref> shows the rule substituted TBR program of f temp. It cannot be executed without rule reordering, since the foreign TBR predicate plusbRSefol,RPa,,Reo, is undefined. The body of ftemp has to be reordered for safety, where every TBR predicate is defined or can be inferred by the completion algorithm to be discussed in Section V-C.</p><p>For every TR predicate, P , there will be a corresponding set of defined TBR predicates, S ( P ) , realizing the overloading on P . For the TR predicates plus and times we have the Assume that in the process of reordering, a rule for the position in the reordered rule, the chosen literal PI, gets a binding pattern X such that P;" $2 S ( P ) , (i.e., the TBR predicate P;" is undefined) and P;' cannot be inferred from S using the completion algorithm to be defined in next section.</p><p>PJ is then disregarded for this position and another literal is examined by the optimization algorithm.</p><p>In our example, the optimal TBR program for f tempprrsolr is shown in Fig. <ref type="figure" target="#fig_5">14</ref>. It results from the following steps.</p><p>1) Initially only P is bound, cternpbpfrrsor, Rcul(P. _V1) is chosen as the implemented TBR predicate in the rule body.</p><p>2) Once ctemp is called both P and -V1 are bound, and t i m e s ~~a l , R e u l . R E u i ( 9 .</p><p>-V1. -V2) is the only implemented TBR predicate.</p><p>3) Then P , -V1, and -V2 are known, which makes t i m e s ~E ~l , R c a l , R e u l ( -V3.5. -V2) the (only) implemented TBR redicate. 4) Finally plus~,Snl,Rcal.Rcr,l(i12. R -V3. F ) is chosen.</p><p>Note that this example would have been unsafe with the optimization principles of [ 161, because of smaller search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Completion Algorithm</head><p>Not every possible TBR foreign predicate needs to be implemented for a given TR foreign predicate P. Some TBR predicates can be automatically inferred from S( P ) through the completion algorithm. The idea is to avoid implementation of TBR foreign predicates, that are covered by elements of S ( P ) . Some programming effort can then be saved. Informally speaking, a covering element has fewer bindings, e.g., p1us"bf covers plusbbb.</p><p>P 7 ] , covers another TBR predicate, PUl U t i , when Va . p , = q, or qr =b. The following example illustrates the problem.</p><p>Consider the OSQL query testing whether two numbers add up to a given sum:select where P l u s ( l . 2 ) = 3:</p><p>This query leads to the TBR query'' plusb""(. 2 . 3 ) " . It is, however, not necessary to implement plusbbb, i.e., plus"' $2 S(p1us). The system can instead use plus6bf (1.2. -V1) to compute -V1 and then test whether -1' 1 = 3. The ObjectLog query would be:</p><p>plus""f1.2._Vl)&amp;Eq(-V1.3)"</p><p>Formally, a TBR predicate, PPI l5 We omit the type adornments for simplicity l 6 We omit type adornments with the expression:</p><formula xml:id="formula_2">P' ( b l . . . . blL) &amp; PY(V,, a,,) &amp; . . . eq(K,,, . o,_<label>( 2 )</label></formula><p>where: i) b, = a, if both are bound.</p><p>ii) b,, = V,, if at, . k = 1. . . . . r n is bound in PA' and b,, is free in P' . The case when a, is free but 6, is bound is impossible, since P' covers P'</p><p>An interesting problem is that of a minimal S ( P ) . While the substituted covering form (2) is semantically equivalent to the implementation of Py, it is less efficient. The difference is often negligible, e.g., for plusbbf and plusbbb, and we need not implement the covered predicate. However, the inverse may be true as well, and the covered predicate can be significantly faster than its cover. It is then advantageous to implement it anyhow.</p><p>For example, consider the TR predicate typesof ObJect,Type. It would be sufficient to implement the TBR predicate typesoffShJecl Type,17 which would return for every object in the system all its types. However, for large databases the execution cost of typesof [i,,,, is prohibitive, while the cost to execute typesof{Jblrc, T y p e is proportional to the number of objects of the given type, and often used typesof4fb,ert Type is implemented in a way that is very fast. Therefore, only the two latter foreign TBR resolvents were implemented, with appropriate cost functions attached. On the other hand, typesofgbJpll Type is covered by typesof r t T y p e , but no implementation significantly faster than its cover could be found. Therefore, this foreign predicate was not implemented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Safety of Recursive Functions</head><p>Our safety checking algorithm also supports recursive functions, e.g., in Fig. <ref type="figure" target="#fig_6">15</ref>. We recall that the flattener detects recursive functions and then adds a call to a system function, Apply (fn. al. . . . . a r L ) = ( r l . . . . . r I I L ) , that applies an arbitrary OSQL function f n on its arguments a l . . . . , an, producing the results ( r l . . . . . rnL). The function Apply is compiled into a system TR predicate, apply (p, a l . . . . , aTL. 7'1, . . . , rIIL), where p is the recursive TBR predicate." apply is executable only if the TBR rule it is used in can be reordered so that all a, are bound.</p><p>Since ObjectLog program-are evaluated top-down, the left recursive calls would be unsafe. The consequence of using the apply predicate is that such calls are transformed into rightrecursive calls. That is why the recursive function in Fig. <ref type="figure" target="#fig_6">15</ref> is executable in ObjectLog. It is known that right recursive "Since f f covers every other binary binding pattern "ancestor:!&lt; , <ref type="figure">,</ref><ref type="figure">( ,</ref><ref type="figure">I ) ,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure" target="#fig_0">1 ,</ref><ref type="figure">,</ref><ref type="figure"></ref>  calls are safe unless there are circularities in the data or the definition. These cases are not detected by WS-IRIS optimizer at present. For this, the semantics of ObjectLog should be extended with memoing <ref type="bibr">[35]</ref> or a bottom-up approach <ref type="bibr" target="#b36">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. PERFORMANCE MEASUREMENTS</head><p>Performance measures concern the efficiency of WS-IRIS and its comparison to other OODB's and relational systems. We evaluated some query execution times with and without optimization. We also benchmarked WS-IRIS according to the 001 benchmark [ 5 ] .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Query Evaluation</head><p>To evaluate the efficiency of the optimization algorithm, we have measured the execution time of GrandSParent-GrossIncome for a given person. This query combines some important 00 features: navigation through a hierarchy, type checking, and foreign functions. The database contained 100, 1000, and 10 000 Person objects. The measurements were run on a SUN4/470 (SPARC). We measured the speedup due to the full optimization, or to partial optimizations. Fig. <ref type="figure" target="#fig_0">16</ref> summarizes our experiences.</p><p>The figure shows that rule reordering is by far the most important optimization. As columns F and NRR show, the gain is over 100 times already for 100 objects, and over seven hundred thousand times for 10 000 objects. Note that the time for the optimal case is, in practice, constant, one reason being the direct use of MM hash tables as internal implementation. The contribution of type check removal is comparatively modest and constant by factor of about 2, as columns F and NTC show. cal page size of 4K, it would span over 250 pages. The testbed query accessed seven persons (the person, hidher parents, and grandparents). Without clustering, the performance of the first query would need at least seven accesses to the corresponding data pages plus some accesses to index pages, typically about seven as well. In the best case of perfect matching of the clustering scheme, the query would need two accesses. l9 The usual average disk access time is 15-40 ms. The processing of the query by WS-IRIS is, hence, about  times faster than for a disk-based system in the best case, and about 200-500 times faster for the usual case of a query not matching the clustering criteria. Similar results hold for recursive queries.</p><p>These figures show the critical importance of MM residency for access performance, known to be a critical requirement for 00 applications. On the other hand, MM alone is not sufficient for good performance. Without the optimization, our MM implementation could be even slower than a disk-based one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The 001 Benchmark</head><p>The 001 benchmark focuses on important characteristics of 00 applications. It simulates a CAD database with 20 000 parts and 60 000 connections. Fig. <ref type="figure" target="#fig_7">18</ref> shows an 001 benchmark for WS-IRIS and the systems originally benchmarked. <ref type="bibr" target="#b19">20</ref> The test of WS-IRIS was run on a SUN3/280 with 16 MBytes of main memory, which was also used by the original benchmark as a server, and has the same speed as the SUN3/260 used in 001 as client machine. To measure the best performance, the benchmarked systems are called through fast-path interfaces assuming a "warm" database state. Hence, the systems are allowed to cash data in MM as much as they can for best execution time performance. For WS-IRIS the entire database is always warm. Columns 2-5 indicate the "warm" values of the original OODB's. These are the latest best verified performance figures of OODB's we could find. The 6th column shows the "warm" figure for a commercial relational DBMS (SYBASE)21 also using a fast-path interface.</p><p>The WS-IRIS figure for building the database does not include saving a backup image on disk, unnecessary for an MM database. The time to save the backup image in the background is 20 s.</p><p>The results show that the time to build the database, as well as the ''lookup'' and "traversal" time, for WS-IRIS, are about those of other OODB's. Small differences are not meaningful as the original numbers are already not strictly comparable [5]. In contrast, the overall performance ( L + T + I ) is about four times in favor of WS-IRIS. The improvement comes from the MM residency, as updates do not need to be committed to the disk. The figures also show that an RDBMS has significantly lower performance for 00 applications than any of the OODB's. For WS-IRIS the overall performance is more than 150 times faster. This figure confirms our evaluations of the importance of MM residency in Section VI-A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS AND FUTURE WORK</head><p>We have described the query processing in WS-IRIS. The WS-IRIS database is MM resident, and the disk is used only for backup through background operations. The optimizations and the physical data structures are large MM oriented. The locality of data is not a primary concern, allowing for data structures more efficient for 00 needs. All of the algorithms we have addressed have been implemented. WS-IRIS is in experimental use at HP and is distributed to universities.</p><p>The overall results prove that WS-IRIS offers a very efficient interface for both navigational and relationally complete declarative use. The declarative interface also includes foreign functions, constraint inferencing, and one popular kind of recursion. None of the benchmarked OODB's offer such a relationally complete interface, while the existing relational systems prove too slow for 00 needs.22 Furthermore, we are not aware of any other OODB that would provide a declarative interface as powerful as that of WS-IRIS, including <ref type="bibr">[SI and [ 241 .23</ref> Efficient processing is a primary concern for 00 applications. Declarative query languages are important for ad hoc queries and for mission critical application programs. Experiences reported in <ref type="bibr">[32]</ref> show that the difference in programming time between declarative and procedural languages can be a couple of minutes versus several hours. Hence, the new capabilities WS-IRIS provides are very important.</p><p>MM residency proved necessary for the performance of our system. Extensive optimization proved nevertheless necessary as well. Only the conjunction of both capabilities allowed for performance unattainable for a disk database.</p><p>For the future, the system can be extended to incorporate more query optimization techniques, e.g., to enhance the processing of recursive queries <ref type="bibr" target="#b36">[34]</ref>, <ref type="bibr">[35]</ref> or perhaps optimization of the choice operator <ref type="bibr" target="#b22">[23]</ref>. These techniques have to be re-examined in the light of their feasibility with respect to 00 characteristics of ObjectLog. One should also carefully 22Note that SQL is only relationally complete, i.e., it currently does not 23Neither could we find any performance evaluations of these interfaces. offer recursion, constraint inferencing, or foreign functions.</p><p>evaluate the costs of their functioning versus the expected gains for an MM resident database.</p><p>One can also add to WS-IRIS new general features, e.g., versioning, or data monitoring <ref type="bibr">[25]</ref>. Again, we believe that MM residency is necessary for these extensions.</p><p>At present the access performance of a WS-IRIS database as well as its size is limited by the capabilities of a single workstation. One way to larger databases is to enhance the compactness of WS-IRIS' internal data structures. Another possibility is to use distributed data structures, especially the dynamic ones <ref type="bibr">[19]</ref>. Such data structures allow storage of objects over several machines linked through a fast LAN and allow for parallel low-level operations. A WS-IRIS database could then attain many gigabytes.</p><p>WS-IRIS could also be extended to a front end to an IRIS server or even a relational server <ref type="bibr" target="#b24">[36]</ref>. The benefit would be more efficient use of these databases. Primitives would be required to check inlout objects between the server database and a private database. Techniques could be developed to post WS-OSQL queries spanning both the private and the shared database [ l l ] , <ref type="bibr">[14]</ref>.</p><p>Another direction should be an extension of WS-IRIS with multidatabase capabilities for federated management of collections of WS-IRIS databases. This is another way to manage in an enterprise much larger data sets than a single WS-IRIS database could handle.</p><p>Finally, WS-IRIS could (and should) be extended with heterogeneous multidatabase capabilities, e.g., along the lines started by Pegasus <ref type="bibr">[l]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX EXAMPLE OFCOST-BASED OPTIMIZATION</head><p>As an illustration of how our cost heuristics work, we describe how grandsparentgrossincome of Fig. <ref type="figure">6</ref> is reordered into the optimal program of Fig. <ref type="figure">7</ref>. We assume a database of 10 000 person with 2500 students, and that every child is expected to have 2 parents.</p><p>To reorder the program of Fig. <ref type="figure">6</ref> with these assumptions the optimizer will do the following calculations. Initially the only bound variable is C. The first rankings are calculated as: </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Examples of OSQL functions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>P I . . . . . P,, are the arguments of f whose values are of types T I . . . . . T , . A function can have as the result a set of tuples of values, &amp; I . . . . . Q I I L , with types U1. . . . . U,,, .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Fig. 2. Translation step5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Fig. 3 shows how the function GrossIncome of Fig. 1 is flattened by introducing intermediate variables gi, -v l , and -1~2.The flattener also detects and marks recursive functions, as discussed in Section V-D. 'c. ~i s p , or IPL 121.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Query fattening</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A TA resolvent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. TR rule</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Function definition with type checks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Unoptimized interpretation of grandsparentgrossincome.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>T ) and tYPesofObJect,Type(X. T ) persons of which 2500 are students, and the stored predicates their first argument. Since we use hash-based MM indexing "OSQL allows the DBA to put indexes on any argument or result of a function, and the system by default puts an index on the first argument of parent and bonus have hash-based indexes On OSQL functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Unoptimized TBR ObjectLog program for S P a r e n t .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>"</head><label></label><figDesc>The resolvents are normally implemented in C, Lisp, or IPL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .Fig. 12 .</head><label>1112</label><figDesc>Fig. 11. Optimal TBR ObjectLog program for S P a r e n t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Fig. 14. Optimized constraints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. Performance measurement of a recursive function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Fig. 18. 001 benchmark.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>PI = incomeff(GP, -v2) Fp, = 10 000 Cp, = 20 000 (assumes cost 2 per tuple visited) Rp, = 0.49 995 P2 = bonusff(GP, -V1) Fp2 = 10 000 Cp, = 20 000 Rp2 = 0.49 995 P3 = plusfff(_V2, -vl, GI) Rp3 = undefined (cannot execute here) P4 = typesofbf(GP, typestudent) Fp4 = 2500 Cp, = 5000 (assuming 2500 students)Witold Litwin is currently with HP Labordtories, on leave from the University of Pdris-Dauphine, where he is d Full Professor He has been a lecturer at Stanford University, the Research Director at INRIA, and an expert for the IS0 subcommittee on open systems His research interests include distributed databases, multidatabase systems, interoperability, and dynamic data structures. He is the author of over 100 hundred papers and has edited or contributed to 11 hooks Tore Risch is currently a Full Professor of Engineering Databdscs with Linkoping University, Sweden He was previously a Researcher with the Ddtdbase Technology Department, Hewlett-Packard Laboratories and developed WS-IRIS at HP's Stanford Science Center Prior to joining HP, he developed the Syntel system for large scdle knowledge bases combining AI and database technologies He also worked on the Prospector expert system with SRI on integrating Prolog with relational databdses and dt IBM's Almaden Center on functional knowledge representation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>, in the example</figDesc><table><row><cell cols="3">create function ancestor(Person p) -&gt; Person a</cell></row><row><cell>a s select a</cell><cell></cell><cell></cell></row><row><cell>f o r each Person par</cell><cell></cell><cell></cell></row><row><cell cols="2">where ( (a = ancestor(par) or</cell><cell></cell></row><row><cell>a = par) and</cell><cell></cell><cell></cell></row><row><cell>par = parent(p1) ;</cell><cell></cell><cell></cell></row><row><cell cols="3">Fig. 15. A left recursive function.</cell></row><row><cell>GrandSParentGrossIncome</cell><cell></cell><cell>Optimization leuels</cell></row><row><cell>Database size</cell><cell>F</cell><cell>NTC NRR</cell></row><row><cell>100 objects</cell><cell cols="2">l.lms 2.5ms 120ms</cell></row><row><cell>1,000 objects</cell><cell cols="2">l.lms 2.5ms 7.3s</cell></row><row><cell>10,000 objects</cell><cell cols="2">l.lms 2.6ms 13.3min</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>After P s is chosen, C.P. and GP are bound. The new rankings are:</p><p>The system now chooses PI and then P, making After the final two choices, we obtain the optimal program of Fig. <ref type="figure">7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The support by Steven Rosenberg was crucial for the success of this project, as well as the support of Dan Fishman, Marie-Anne Neimat, and Ming Shan Discussions with Ravi Krishnamurthy and Gio Wiederhold were helpful. Peter Lyngbaek, Jiirgen Annevelink, and the Database Technology Department group provided insights into IRIS. Sang Cha contributed to the benchmarks and the ObjectLog interpreter.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Pegasus heterogeneous multidatabase system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Desmedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Ketabchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Litwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rafii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M-C</forename><surname>Shan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<date type="published" when="1991-12">Dec. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Database programming languages: A functional approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Annevclink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Cant</title>
		<meeting>ACM SIGMOD Cant</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="318" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Objects and views</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bonner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">infroc. ACM SIC-MOD Cont</title>
		<imprint>
			<biblScope unit="page" from="238" to="247" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A data model and query language for EXODUS</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Vandenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">inProc. ACM SIGMOD Conf</title>
		<imprint>
			<biblScope unit="page" from="4" to="13" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Object operations benchmark</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G G</forename><surname>Cattell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Skeen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AC&apos;M Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="31" />
			<date type="published" when="1992-03">Mar. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Toward an open architecture for LDL</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chimenti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gamboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th VLDB Con$</title>
		<meeting>15th VLDB Con$</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="195" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Providing uniform access to heterogeneous information bases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Connors</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lyngbaek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Object-Oriented Database Sy.stems, K. R. Dittrich</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The 0 2 system</title>
		<author>
			<persName><surname>Deux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An association algebra for processing object-oriented databases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Y W</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Data Engineering Cant</title>
		<meeting>7th Data Engineering Cant</meeting>
		<imprint>
			<biblScope unit="volume">991</biblScope>
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Object-Oriented Concepts, Databases, and Applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Fishman</surname></persName>
		</author>
		<editor>W. Kim, F. H. Lochovsky</editor>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>Overview of the IRIS DBMS</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Technical</forename><surname>Itasca</surname></persName>
		</author>
		<author>
			<persName><surname>Summary</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>ITASCA Systems, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Advanced query processing in object bases using access support relations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Moerkotte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th VLDB Conj</title>
		<meeting>16th VLDB Conj</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="290" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Object-Oriented Concepts, Databases</title>
		<author>
			<persName><forename type="first">W</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Lochovsky</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>and Applications</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Iritroduction to Objecl-Oriented Databases</title>
		<author>
			<persName><forename type="first">W</forename><surname>Kim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>MIT</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimization of nonrecursive queries</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Boral</surname></persName>
		</author>
		<author>
			<persName><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th VLDB CO$</title>
		<meeting>12th VLDB CO$</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="128" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimization in a logic based language for knowledge and data intensive applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Advances in Database Technology -EDBT &apos;88</title>
		<meeting>Advances in Database Technology -EDBT &apos;88</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="16" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Constraint Programming Languages: Their Specification artd Generation Reading</title>
		<author>
			<persName><forename type="first">W</forename><surname>Leler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multiprocessor main memory transaction processing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISPDS. Austin TX</title>
		<imprint>
			<date type="published" when="1988-12">Dec. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Distributed linear hashing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Litwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M-A</forename><surname>Neimat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1992. Sept. 1988. 1989</date>
			<publisher>ACM</publisher>
			<pubPlace>Palo Alto; New York; New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>HP-Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. HPL-DTD-92-7. Database Technology Dept</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">LLO: An object-oriented deductive Ianguage with methods and method inheritance</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Ozsoyoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Conf. 1991</title>
		<meeting>ACM SIGMOD Conf. 1991</meeting>
		<imprint>
			<biblScope unit="page" from="198" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Development of an object-oriented DBMS</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pmc. OOPSLA Conf</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="472" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A polymorphic type system for Prolog</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>O'keefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif Intell</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="295" to="307" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A Logical Language for Data and Knowledge Bases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Naqvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tsur</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Memoing for logic programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Orenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Haradhvala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Margulies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sakahara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1992-03">Mar. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Views, objects, and databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wiederhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="37" to="44" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The IRIS architecture and implementation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wilkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lyngbaek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Tram. Kwwl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="1990-03">Mar. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">~~ processing in the Objectstore database-system</title>
		<author>
			<persName><surname>Baltimore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SItiM0D Conf</title>
		<meeting>ACM SItiM0D Conf</meeting>
		<imprint>
			<date type="published" when="1989">1989. 1992</date>
			<biblScope unit="page">393402</biblScope>
		</imprint>
	</monogr>
	<note>MD: Computer Science</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Monitoring database objects</title>
		<author>
			<persName><forename type="first">T</forename><surname>Risch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th VI-DB CoriJ</title>
		<meeting>15th VI-DB CoriJ</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page">445153</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">WS-IRIS, A main memory object-oriented DBMS</title>
		<imprint/>
	</monogr>
	<note type="report_type">Tech. Rep</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Readings in Object-Oriented Database Systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Morgan-Kaufman</publisher>
			<pubPlace>San Francisco,CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Access path selection in a relational database management system</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Object-oriented queries: Equivalence and optimization</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Conf Deductive arid 00 L)atahu.scs</title>
		<meeting>1st Conf Deductive arid 00 L)atahu.scs</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="264" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The design of POSTGRES</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">inPr.oc. ACM SIGMOD Cot$</title>
		<imprint>
			<biblScope unit="page" from="340" to="355" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Qucries and query processing in objectoriented database systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Straube</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Ozsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">387430</biblScope>
			<date type="published" when="1990-10">Oct. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Distributed database system JDDBS</title>
		<author>
			<persName><forename type="first">M</forename><surname>Takizawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JARECT Computer Science &amp;: Technologicq</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="262" to="283" />
			<date type="published" when="1983">1983</date>
			<publisher>North Holland</publisher>
			<pubPlace>Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Tsur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Garrison</surname></persName>
		</author>
		<title level="m">LDL User&apos;s Guide, MCC Tech. Rep. STP-LD-295-91</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Principles of Database and Knowledge-Base Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Baltimore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
