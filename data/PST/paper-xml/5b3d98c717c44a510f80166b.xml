<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
							<email>jkatz@cs.umd.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vladimir</forename><surname>Kolesnikov</surname></persName>
							<email>kolesnikov@gatech.edu</email>
							<affiliation key="aff1">
								<address>
									<country>Georgia Tech</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiao</forename><surname>Wang</surname></persName>
							<email>wangxiao@cs.umd.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7068AC0C088BE1D363C31149B3B10E55</idno>
					<idno type="DOI">10.1145/3243734.3243805</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Zero-knowledge proof; Post-quantum signature</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recent work, including ZKBoo, ZKB++, and Ligero, has developed efficient non-interactive zero-knowledge proofs of knowledge (NIZKPoKs) for Boolean circuits based on symmetric-key primitives alone, using the "MPC-in-the-head" paradigm of Ishai et al. We show how to instantiate this paradigm with MPC protocols in the preprocessing model; once optimized, this results in an NIZKPoK with shorter proofs (and comparable computation) as in prior work for circuits containing roughly 300-100,000 AND gates. In contrast to prior work, our NIZKPoK also supports witness-independent preprocessing, which allows the prover to shift most of its work to an offline phase before the witness is known.</p><p>We use our NIZKPoK to construct a signature scheme based only on symmetric-key primitives (and hence with "post-quantum" security). The resulting scheme has shorter signatures than the scheme built using ZKB++ (and comparable signing/verification time), and is even competitive with hash-based signature schemes.</p><p>To further highlight the flexibility and power of our NIZKPoK, we also use it to build efficient ring and group signatures based on symmetric-key primitives alone. To our knowledge, the resulting schemes are the most efficient constructions of these primitives that offer post-quantum security.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Zero-knowledge (ZK) proofs<ref type="foot" target="#foot_0">1</ref>  <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref> and non-interactive zeroknowledge (NIZK) proofs <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b21">22]</ref> are among the most fundamental and versatile cryptographic primitives. In the present context, (NI)ZK proofs of knowledge (PoKs) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b28">29]</ref> allow a prover to convince a verifier, who holds a circuit C, that the prover knows an input (or "witness") w for which C(w) = 1. Historically, research on (NI)ZK proofs has followed two largely independent paths: some work gave asymptotic improvements for generic proofs that can be used for arbitrary circuits (by reducing a circuit to an NP-complete problem) but had poor concrete efficiency; other work explored efficient proofs tailored to certain classes of circuits related to specific, "algebraic" computations (e.g., group exponentiation).</p><p>More recently, researchers have merged these two directions and have developed (NI)ZKPoKs for general circuits with good concrete efficiency. We highlight in particular recent constructions of succinct non-interactive arguments of knowledge (SNARKs) <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b39">40]</ref>, which can be used to generate proofs for arbitrary circuits that are shorter than the input w itself. (Prior work showing ZK proofs with size sublinear in the input <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b37">38]</ref> demonstrated feasibility, but was concretely inefficient.) Unfortunately, existing SNARKs suffer from several disadvantages. First, although they have excellent proof size and verification time, the computational efficiency of the prover is poor. Second, most constructions require public parameters generated and published by some semi-trusted party. Security of existing SNARKs is based on non-standard and poorly understood knowledge assumptions, and to some extent this is inherent <ref type="bibr" target="#b25">[26]</ref>. Finally, most existing constructions of SNARKs rely on bilinear maps and are thus insecure against quantum attackers. (One exception is the recent work of Boneh et al. <ref type="bibr" target="#b12">[13]</ref>. This scheme still has the other drawbacks, and its concrete efficiency is unclear.)</p><p>In another recent line of work, researchers have shown how to use protocols for secure multi-party computation (MPC) to obtain (NI)ZKPoKs with excellent concrete performance (even if the communication is no longer sublinear in the circuit size |C |). Jawurek et al. <ref type="bibr" target="#b32">[33]</ref> (see also <ref type="bibr" target="#b23">[24]</ref>) showed that two-party protocols based on garbled circuits could be used to construct efficient ZKPoKs; their approach requires interaction as well as the use of public-key primitives. Hazay and Venkitasubramaniam <ref type="bibr" target="#b30">[31]</ref> show a public-coin protocol based on garbled circuits that avoids public-key primitives; its practical performance is likely worse than the approaches we discuss next. Ishai et al. (IKOS) <ref type="bibr" target="#b31">[32]</ref>, using the so-called "MPC-inthe-head" approach, showed how to use MPC protocols to obtain ZKPoKs whose security can be based entirely on symmetric-key primitives; their approach yields public-coin protocols, and so can be made non-interactive via the Fiat-Shamir transform <ref type="bibr" target="#b22">[23]</ref>. Based on the IKOS approach, Giacomelli et al. <ref type="bibr" target="#b26">[27]</ref> developed and implemented a protocol called ZKBoo that supports efficient NIZKPoKs for arbitrary circuits. (Concurrently, Ranellucci et al. <ref type="bibr" target="#b42">[43]</ref> proposed an NIZKPoK with similar asymptotic performance.) Chase et al. <ref type="bibr" target="#b15">[16]</ref> introduced ZKB++, which improves the performance of ZKBoo; they also showed that ZKB++ could be used to construct efficient signature schemes based on symmetric-key primitives alone. (A version of their scheme called Picnic <ref type="bibr" target="#b14">[15]</ref> was submitted to the NIST post-quantum standardization effort.) Ames et al. <ref type="bibr" target="#b3">[4]</ref> subsequently proposed Ligero, which offers proofs that are sublinear in |C | and so asymptotically outperforms ZKBoo and ZKB++; see further discussion in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contributions</head><p>We show here a novel way to instantiate the "MPC-in-the-head" approach that leads to NIZKPoKs with shorter proofs than (and comparable computation to) the best prior work <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b42">43]</ref> for "medium-size" circuits with roughly 300-100,000 gates. (Although we focus on Boolean circuits, our ideas can be extended to arithmetic circuits as well.) As we show, this range covers many "cryptographically interesting" circuits that incorporate hashing, block-cipher evaluations, etc.</p><p>Our main insight leading to improved performance is that the "MPC-in-the-head" paradigm can be instantiated using MPC protocols designed in the preprocessing model. (A detailed overview of our approach is given in Section 1.2.) This greatly increases the space of MPC protocols that can be used, and in particular makes it competitive to use protocols designed for a large number of parties (in contrast to prior work) and hence achieve better efficiency for the same level of security.</p><p>As in the work of Chase et al. <ref type="bibr" target="#b15">[16]</ref>, we may apply our NIZKPoK to construct an efficient signature scheme based on symmetric-key primitives alone, and thus offering "post-quantum" security. Our resulting scheme has signatures roughly 3.2× shorter than those of Chase et al.; in fact, we can achieve signatures that are even shorter than some leading constructions of (stateless) hash-based signature schemes <ref type="bibr" target="#b8">[9]</ref>. We can also trade off signature length and computation, giving some flexibility in the design. We are currently working with the Picnic team to incorporate our work in their submission to NIST.</p><p>As an additional application highlighting the power of our new NIZKPoK, we also show how to use it to build efficient ring and group signatures based on symmetric-key primitives alone. (Similar ideas, but using ZKB++, have been pursued in concurrent work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b20">21]</ref>.) The main challenge here is to build schemes in which signing corresponds to generating an NIZKPoK for a circuit that is not too large; we defer additional details to Section 4. Our resulting schemes are, to the best of our knowledge, the most efficient constructions of ring/group signatures that offer post-quantum security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview of Our Techniques</head><p>We provide the high-level intuition for our improved NIZKPoK. Here (and in Section 2.2) we describe a 5-round, public-coin proof of knowledge that is honest-verifier zero knowledge (HVZK). In Section 2.4 we then show how it can be "compressed" to three rounds (while remaining public-coin and HVZK). Either of these proofs can, in turn, be compiled to achieve zero knowledge against a malicious verifier using standard techniques. Alternatively-and of most interest to us-the 3-round version can be made non-interactive in the random-oracle model using the Fiat-Shamir transform <ref type="bibr" target="#b22">[23]</ref>.</p><p>Our starting point is the "MPC-in-the-head" paradigm of Ishai et al. <ref type="bibr" target="#b31">[32]</ref> for constructing public-coin HVZK proofs of knowledge based on protocols for secure computation. Roughly speaking, the main idea is for the prover to simulate an execution of an n-party secure-computation protocol Π that evaluates a given circuit C on the prover's input w, and then for the prover to commit to the views of the parties in the protocol. The verifier chooses a random subset of those parties (we call those parties "opened"), and the prover opens their corresponding views. The verifier then checks that the views of the opened parties are consistent with each other and with an honest execution of Π that yields output 1.</p><p>As observed in prior work <ref type="bibr" target="#b26">[27]</ref>, efficiency considerations for the protocol Π used in the "MPC-in-the-head" paradigm differ from efficiency considerations for standard applications of MPC. For example, in this context Π can freely rely on "oblivious-transfer channels" in addition to standard point-to-point channels; in fact, Π can freely use any (deterministic) two-party functionality as a building block, since such functionalities incur no additional cost for the prover to simulate them, and consistency between any pair of opened parties can still be checked by the verifier. We stress that this does not immediately extend to using t-party functionalities for t &gt; 2, since it may no longer be possible to verify consistent execution unless all t parties using the functionality are opened.</p><p>Giacomelli et al. <ref type="bibr" target="#b26">[27]</ref> and Chase et al. <ref type="bibr" target="#b15">[16]</ref> gave concrete instantiations of the "MPC-in-the-head" approach, and determined that using a 3-party protocol Π resulted in optimal performance for the space of protocols they considered. Since the number of parties is small, the soundness of the resulting HVZK proof is poor; a large number of parallel repetitions is thus needed to obtain negligible soundness. (We discuss the work of Ames et al. <ref type="bibr" target="#b3">[4]</ref> in Section 3.1.)</p><p>Our main conceptual insight is that the "MPC-in-the-head" approach can be modified so the underlying n-party protocol Π can rely on any n-party functionality, as long as that functionality is called during preprocessing. At first glance, using an n-party functionality does not seem compatible with the IKOS paradigm: the only way to verify that the functionality was run honestly is to open all parties, but then privacy (which translates to zero-knowledge) cannot possibly hold. We overcome this difficulty by having the verifier issue its challenges in two phases, thus giving a 5-round HVZK proof. Roughly, the HVZK proof thus works as follows:</p><p>(1) The prover commits to multiple (independent) executions of the preprocessing phase, where each commitment also commits to the state of each party at the end of that phase. (2) The verifier challenges the prover to open some of the executions of the preprocessing phase. For each challenged execution, the prover opens the state of all parties, thus allowing the verifier to check those executions. (3) Using each of the remaining (unchallenged) executions of the preprocessing phase, the prover simulates an execution of Π that evaluates C on input w. It then commits to each party's view in the protocol, including its state from the preprocessing phase.</p><p>Session 3C: Crypto: Lattice/ZKP CCS'18, October 15-19, 2018, Toronto, ON, Canada (4) As in the original IKOS approach, for each execution of Π the verifier chooses a random subset of the parties to open. Now, however, opening a party involves opening the commitment to that party's state following the preprocessing phase (from step 1) as well as its view in the online execution of the protocol (from step 3). The verifier then checks that all the opened parties are consistent with each other and with an honest execution of Π (using the state from the preprocessing phase) that yields output 1.</p><p>The fact that the n-party functionality is executed during a preprocessing phase is essential here; the execution of that functionality is independent of the parties' inputs, and so opening the views of all parties from the preprocessing phase does not reveal any information about w.</p><p>As a consequence of being able to rely on preprocessing, the space of possible protocols Π we can use is greatly expanded. In particular, we find that we obtain much shorter proofs by using an n-party protocol (secure against semi-honest corruption of allbut-one of the parties) with n as high as 64. The ability to rely on preprocessing is critical here: the communication complexity of traditional MPC protocols (that do not rely on preprocessing) with security against all-but-one corruption is quadratic in the number of parties, but by relying on preprocessing we can obtain communication complexity independent of n.</p><p>Further optimizations and specific parameter choices for the above proof are discussed in the remainder of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Outline of the Paper</head><p>In Section 2, we present the details of the MPC protocol Π we use, and describe more fully how to convert it into a 3-round, public-coin HVZK proof whose security relies on symmetric-key primitives alone. By applying the Fiat-Shamir transform to our 3-round proof, we obtain an NIZKPoK; the resulting construction is analyzed and compared to prior work in Section 3.1, where we show that it yields shorter proofs than prior work for a large range of circuit sizes. As in prior work, we can use our NIZKPoK to build a signature scheme based only on symmetric-key primitives (and hence offering "postquantum" security); performance of this scheme is discussed in Section 3.2. We explore the applicability of our work to constructing "post-quantum" ring and group signatures in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">HVZK PROOFS OF KNOWLEDGE</head><p>We construct our HVZK proofs by instantiating the "MPC-in-thehead" paradigm using an MPC protocol Π designed in the preprocessing model. We first describe the MPC protocol we rely on, and then discuss how to build HVZK proofs based on it.</p><p>Notation. We denote the n-out-of-n (XOR-based) secret sharing of a bit x by [x]. Throughout, κ and ρ denote computational and statistical security parameters, respectively. We let |C | denote the number of AND gates in a circuit C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Suitable MPC protocol</head><p>In this section we describe an n-party protocol Π run by parties S 1 , . . . , S n in the preprocessing model, secure against semi-honest corruption of all-but-one of the parties. The protocol is inspired by recent work of Wang et al. <ref type="bibr" target="#b47">[48]</ref>.</p><p>Recall that our goal is to use this protocol to instantiate the "MPC-in-the-head" approach efficiently, and so in particular we are interested in minimizing the communication needed to verify consistency and correct computation for any n -1 parties chosen by the verifier. As explained in more detail in the next section, our protocol Π ends up having communication comparable to the 3-party MPC protocols used by ZKBoo and ZKB++, but because we set n &gt; 3 we are able to achieve much lower soundness error per protocol execution and thus better communication complexity overall for our resulting interactive proof system.</p><p>Our protocol Π maintains the invariant that, for each wire in the circuit, the parties hold an n-out-of-n secret sharing of a random mask along with the (public) masked value of the wire. Specifically, if we let z α denote the value of wire α in the circuit C when evaluated on input w, then the parties will hold [λ α ] (for uniform λ α ∈ {0, 1}) along with the value ẑα def = z α ⊕ λ α .</p><p>Preprocessing phase. In the preprocessing phase, shares are set up among the parties as follows. For each wire α that is either an input wire of the circuit or the output wire of an AND gate, the parties are given [λ α ], where λ α ∈ {0, 1} is uniform. For an XOR gate with input wires α, β and output wire γ , define λ γ def = λ α ⊕ λ β ; note the parties can compute [λ γ ] locally. Finally, for each AND gate with input wires α, β, the parties are given [λ α, β ], where</p><formula xml:id="formula_0">λ α, β def = λ α • λ β .</formula><p>A key observation is that the shares of the {λ α } are uniform, and so can be generated by having each party S i apply a pseudorandom generator to a short, random seed seed i given to that party, and then (implicitly) defining the {λ α } based on the resulting shares. All-but-one of the shares of the {λ α, β } can also be generated in this way, but the final share is constrained by the values of λ α , λ β . To ensure that the shares of the {λ α, β } are correct, S n can be given an additional |C | "correction bits" that determine its share of λ α, β for each AND gate with input wires α, β.</p><p>To summarize: each S i is given a κ-bit seed seed i ∈ {0, 1} κ , and S n is additionally given |C | bits denoted by aux n . We refer to this information as the state of the parties, and denote the state of S i by state i . In the online phase of the protocol, each party S i uses seed i to generate its shares of the {λ α }; for 1 ≤ i ≤ n -1, party S i also uses seed i to generate its shares of the {λ α, β }. Party S n uses aux n as its shares of the {λ α, β }.</p><p>Protocol execution. Note that in our setting, where all parties are semi-honest, we can perform public reconstruction of a shared value [x] by simply having each party broadcast its share.</p><p>We assume the parties begin the protocol holding a masked value ẑα for each input wire α. (In our context these masked values will be provided to the parties by the prover who is simulating execution of the protocol.) Note that these masked values, along with the corresponding {λ α }, define an effective input to the protocol. During the online phase of the protocol, the parties inductively compute ẑα for all wires in the circuit. Specifically, for each gate of the circuit with input wires α, β and output wire γ , where the parties already hold ẑα , ẑβ , the parties do:</p><p>• If the gate is an XOR gate, then the parties locally compute ẑγ := ẑα ⊕ ẑβ . • If the gate is an AND gate, the parties locally compute</p><formula xml:id="formula_1">[s] := ẑα [λ β ] ⊕ ẑβ [λ α ] ⊕ [λ α, β ] ⊕ [λ γ ],</formula><p>and then publicly reconstruct s. Finally, they compute ẑγ := s ⊕ ẑα ẑβ . One can verify that ẑγ = z γ ⊕ λ γ .</p><p>Once the parties have computed ẑα for the output wire α, the output value z α is computed by publicly reconstructing λ α and then setting z α := ẑα ⊕ λ α .</p><p>We remark that the online phase of this protocol is deterministic. Also observe that all communication is due to share reconstruction: for a circuit with |C | AND gates, at most |C | + 1 share reconstructions are needed. We will see in the following sections that these properties are advantageous for our application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Our Basic HVZK Proof</head><p>In this section we describe a basic, 5-round HVZK proof based on the MPC protocol from the previous section. We defer discussion of further optimizations to the following section, and a description of a 3-round variant to Section 2.4.</p><p>Notation. In this section, H is a collision-resistant hash function. (Later in the paper, we will model H as a random oracle.) We let Com denote a non-interactive<ref type="foot" target="#foot_2">2</ref> commitment scheme, where a commitment to a value x is generated by choosing a uniform r ∈ {0, 1} κ and computing com := Com(x; r ); decommitment is done by simply revealing x and r . Computational binding and hiding suffices.</p><p>Overview. Recall from Section 1.2 that, because we rely on an MPC protocol Π designed in the preprocessing model, we modify the "MPC-in-the-head" approach and construct a 5-round proof of the following format: First, the prover commits to m executions of the preprocessing phase, where each such commitment includes a commitment to the state of each party. The verifier then challenges the prover to open all-but-one of those executions, and verifies that all the state information given to the parties in the opened executions is correct. The remaining (unopened) execution of the preprocessing phase is then used by the prover to simulate the online phase of the n-party protocol Π on a shared input w, and the prover commits to the view of each party in this execution. The verifier then chooses all-but-one of the parties to be opened; for each opened party, the prover opens that party's state from the preprocessing phase as well as its view from the online phase. The verifier then checks consistency of the parties' views as well as correct behavior. We provide details about each of these steps next.</p><p>Checking the preprocessing phase. Recall from the previous section that, following the preprocessing phase, the state of party S i for 1 ≤ i ≤ n -1 is a seed seed i , while the state of party S n is a seed seed n along with a |C |-bit string aux n . Thus, in a naive implementation of the idea outlined above, for each execution of the preprocessing phase the prover would send (com 1 , . . . , com n ), where com i is a commitment to the state of S i . Then, for each challenged execution of the preprocessing phase, the prover would send seed 1 , . . . , seed n , aux n , r 1 , . . . , r n , where r i denotes the randomness used for the ith commitment. For the unchallenged execution (used for the subsequent execution of Π), the prover will be able to decommit to the states of any subset of the parties. The communication complexity of this approach is O(m |C | + mnκ).</p><p>We improve the communication complexity in several ways (cf. Round 1 and steps (1) and (2) of verification in Figure <ref type="figure" target="#fig_0">1</ref>):</p><p>(1) The prover will send H (com 1 , . . . , com n ) instead of sending all the commitments individually. It can then hash the results from all m executions and so send just a single hash value to the verifier. (2) When opening a challenged execution, it is unnecessary for the prover to send aux n since the correct value of aux n can be computed from seed 1 , . . . , seed n . This gives an asymptotic improvement in the communication in this step. (3) By generating the {seed i } and the {r i } from a "master" seed seed * ∈ {0, 1} κ , the prover can open a challenged execution of the preprocessing phase by simply sending seed * .</p><p>The overall communication complexity of the initial checking phase can thus be reduced to O(mκ), which is independent of |C | and n.</p><p>Checking the online execution. An execution of our protocol proceeds gate-by-gate, with the processing of each AND gate requiring reconstruction of one shared value. Although the communication complexity of share reconstruction in our protocol is n bits (one bit per party), for our purposes we do not need the prover to send n bits per gate in order to prove consistent execution. This is because the verifier only needs to obtain the protocol messages sent by the (single) unopened party in order to check the execution of the n -1 opened parties. Thus, it suffices for the prover to send just a single bit per AND gate.</p><p>In addition to the protocol messages sent by the unopened party, the prover also needs to reveal the state (from the preprocessing phase) of every opened party. For each opened party S i , i n, this involves just O(κ) bits; if S n is opened then this requires |C | + O(κ) bits due to aux n . In either case the marginal communication complexity per AND gate is independent of the number of parties n.</p><p>The above ideas (with a few optimizations) are encapsulated in Figure <ref type="figure" target="#fig_0">1</ref>. Security of the scheme is given by the following theorem. Theorem 2.1. Let H be collision-resistant, and let Com be a secure commitment scheme. Then the protocol in Figure <ref type="figure" target="#fig_0">1</ref> is an honest-verifier zero-knowledge proof of knowledge with soundness/knowledge error max{ 1  m , 1 n }.</p><p>Proof. Completeness of the protocol is immediate, and we thus focus on proving honest-verifier zero knowledge and soundness.</p><p>Honest-verifier zero knowledge follows easily from semi-honest security of Π (for corruption of any n -1 parties) and hiding of the commitment scheme. Specifically, if we let Sim Π denote a simulator for Π, then we can construct an honest-verifier zero-knowledge simulator for our protocol as follows:</p><p>• Round 1 For each j ∈ [m], the prover emulates the preprocessing phase as follows:</p><p>(1) Choose uniform seed * j ∈ {0, 1} κ and use it to generate values seed j,1 , r j,1 , . . ., seed j,n , r j,n . Also compute aux j,n ∈ {0, 1} |C | as described in the text. For i = 1, . . . , n -1, let state j,i := seed j,i ; let state j,n := seed j,n ∥aux j,n .</p><p>(2) For i ∈ [n], compute com j,i := Com(state j,i ; r j,i ).</p><p>(3) Compute h j := H (com j,1 , . . . , com j,n ). Compute h := H (h 1 , . . . , h m ) and send h to the verifier. Round 2 The verifier chooses uniform c ∈ [m] and sends it to the prover. Round 3 The prover sends {seed * j } j c to the verifier. The prover simulates the online phase of the n-party protocol Π (as described in the text) using the state generated by the cth preprocessing phase, beginning by computing the masked values { ẑα } for the input wires (based on w and the {λ α } defined by the cth preprocessing phase). Let msgs i denote the messages broadcast by S i in the protocol execution. The prover sends the initial masked values { ẑα } as well as h ′ := H (msgs 1 , . . . , msgs n ) to the verifier. Round 4 The verifier chooses uniform p ∈ [n] and sends it to the prover. Round 5 The prover sends {state c,i , r c,i } i p , com c,p , and msgs p . Verification The verifier accepts iff all the following checks succeed:</p><p>(1) For i p, the verifier uses state c,i and r c,i to compute com c,i . It then computes h c := H (com c,1 , . . . , com c,n ).</p><p>(2) For j c, the verifier uses seed * j to compute h j as an honest prover would. It then checks that h</p><formula xml:id="formula_2">? = H (h 1 , . . . , h m ).</formula><p>(3) The verifier simulates the online phase of Π among the {S i } i p using {state c,i } i p , masked input-wire values { ẑα }, and msgs p . This yields {msgs i } i p and an output bit b. The verifier checks that b ? =</p><p>(4) The verifier checks that h ′ ? = H (msgs 1 , . . . , msgs n ). computed. The simulator computes h ′ as the honest prover would. • For j c, the simulator computes h j exactly as the honest prover would. For i p, the simulator sets state c,i := state i , chooses uniform r c,i , and computes com c,i as the honest prover would. It computes com c,p as a commitment to a 0-string of the appropriate length. It then computes h c and h as the honest prover would. • The simulator outputs the transcript with h, c, {seed * j } j c , { ẑα }, h ′ , p, {state c,i , r c,i } i p , com c,p , and msgs p .</p><p>A straightforward hybrid argument shows that transcripts output by the simulator are computationally indistinguishable from transcripts of real executions of the protocol with an honest verifier.</p><p>We next show that given accepting transcripts for challenges (c, p), (c ′ , ⋆), and (c, p ′ ), with c c ′ and p p ′ , it is possible to extract a witness w for which C(w) = 1 unless there is a hash collision or binding of the commitment scheme fails. It follows using standard techniques that the protocol has soundness/knowledge error max{ 1 m , 1 n }. In the discussion that follows we assume for simplicity that no hash collisions occur and that binding of the commitment scheme never fails. From the accepting transcript with challenges (c ′ , ⋆), we can compute for any c c ′ values state c,1 , . . . , state c,n that are mutually consistent (i.e., are a correct outcome of the preprocessing phase); moreover, those values are equal to the corresponding values sent in round 5 of the other two accepting transcripts (with initial challenge c). These values of the state define a value λ α for each input wire α; from these and the masked inputs { ẑα } used in either of the other accepting transcripts we may compute an effective input w.</p><p>We now show that C(w) = 1:</p><p>• From the transcript with challenges (c, p), we obtain the state of all parties besides S p ; these will be exactly equal to the values {state c,i } i p computed above. We also derive</p><formula xml:id="formula_4">{msgs i } i ∈[n] .</formula><p>Moreover, these values are all consistent with an honest execution of Π by parties {S i } i p resulting in output 1. • From the transcript with challenges (c, p ′ ), we can obtain {state c,i } i p ′ along with protocol messages</p><formula xml:id="formula_5">{msgs i } i ∈[n]</formula><p>that must be equal to those obtained above. These values are consistent with an honest execution of Π by parties {S i } i p ′ resulting in output 1.</p><p>Since the masked input-wire values { ẑα } are fixed in the above, the {state c,i } i ∈[n] and the {msgs i } i ∈[n] must all be mutually consistent with an honest execution of Π, beginning with correct state and effective input w, resulting in output 1. This implies C(w) = 1. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Additional Optimizations</head><p>Here we describe some additional optimizations that can be used to further improve the concrete performance of our protocol.</p><p>Improved commitments. In the basic protocol we use a commitment scheme to hide the states of the parties following the Reducing the number of random seeds. In the cth emulation of the preprocessing phase, the prover generates n seeds seed c,1 , . . ., seed c,n from a master seed seed * c , commits to the n generated seeds, and then sends n -1 of those seeds to the verifier. The second step requires (n -1) • κ bits of communication.</p><p>Motivated by the NNL scheme for stateless revocation <ref type="bibr" target="#b38">[39]</ref>, we observe that we can reduce the communication by generating the seeds in a more structured way. Namely, imagine labeling the root of a binary tree of depth log n with seed * c , and then inductively labeling the children of each node with the output of a pseudorandom generator applied to the node's label. The {seed c,i } i ∈[n] will be the labels of the n leaves of the tree. To reveal {seed c,i } i p , it suffices to reveal the labels on the siblings of the path from the root of the tree to leaf p. Those labels allow the verifier to reconstruct {seed c,i } i p while still hiding seed c,p . Applying this optimization reduces the communication complexity to κ • log n for revealing the seeds used by the n -1 opened parties.</p><p>We can, in fact, apply the same idea to the master seeds {seed * j } m j=1 used for the different emulations of the preprocessing phase; this reduces the communication required to reveal all-but-one of those seeds in Round 3 from (m -1) • κ bits to κ • log m bits. Looking ahead to the next optimization, we remark that we are not limited to revealing all-but-one of the leaf labels; more generally, the scheme just described supports revealing all-but-τ of the leaf labels using communication at most κ • τ log m τ bits (cf. <ref type="bibr" target="#b38">[39]</ref>).</p><p>Beating parallel repetition. The basic protocol analyzed in the previous section has soundness error max{ 1 m , 1 n }; we can achieve soundness error 2 -ρ by running τ = ρ log min{m,n } independent, parallel repetitions of the basic protocol. This would require τm emulations of the preprocessing phase, followed by τ executions of an n-party protocol.</p><p>We can do better by performing a more general cut-and-choose over the emulations of the preprocessing phase. That is, the prover now runs M emulations of the preprocessing phase and the verifier selects Mτ of those to check; the remaining τ executions of the preprocessing phase are then used to run τ (independent) instances of Π. Each of those instances of Π is then verified by revealing the view of all-but-one party as before. If a cheating prover generates k ≥ M -τ correct emulations of the preprocessing phase and Mk incorrect emulations, then its probability of successfully passing the first phase of the proof is at most</p><formula xml:id="formula_6">k M -τ • M M -τ -1</formula><p>; conditioned on passing the first phase, its probability of passing the second phase is at most 1/n k-M +τ . The soundness error is therefore</p><formula xml:id="formula_7">ϵ(M, n, τ ) def = max M -τ ≤k ≤M k M -τ M M -τ • n k -M +τ .<label>(1)</label></formula><p>In Table <ref type="table" target="#tab_1">1</ref> we show some values of M, n, and τ that give soundness 2 -128 or 2 -256 . (In each case, for fixed choice of n we find M, τ with minimum τ for which ϵ(M, n, τ ) is below the desired soundness error.) For an interactive protocol, soundness 2 -40 may be sufficient; however, for our later applications to non-interactive protocols better soundness is needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">A 3-Round Protocol</head><p>For applications where an interactive proof suffices, the 5-round protocol described previously can be used. If a non-interactive proof is needed, however, then it is easier to start with a 3-round protocol.</p><p>(Although it is possible to apply the Fiat-Shamir transform to any constant-round, public-coin, HVZK protocol <ref type="bibr" target="#b0">[1]</ref>, we obtain better efficiency for a given security level by starting with a 3-round protocol.) We present a 3-round version of our proof here. The high-level idea of our 3-round variant is to have the prover now simulate the online phase of Π for every emulation of the preprocessing phase, and then commit to all the resulting executions. The verifier then challenges the prover to open some of the preprocessing phases, as well as all-but-one party from each of the unopened preprocessing phases, as before. The modified protocol is shown in Figure <ref type="figure" target="#fig_1">2</ref>. In that figure, we also incorporate the cutand-choose optimization discussed in the previous section. A proof of the following theorem relies on the same ideas as in the proof of Theorem 2.1, and so is omitted. Theorem 2.2. Let H be collision-resistant, and let Com be a secure commitment scheme. Then the protocol in Figure <ref type="figure" target="#fig_1">2</ref> is an honestverifier zero-knowledge proof of knowledge with soundness/knowledge error ϵ(M, n, τ ).</p><p>As mentioned in the previous section, instead of computing h ′ := H (h ′ 1 , . . . , h ′ M ) the prover can compute h ′ as the root of a Merkle tree with the {h ′ j } as leaves. Then, in the third round it suffices for the prover to send at most τ log M τ values instead of sending the Mτ values {h ′ j } j C . Applying this optimization, and assuming the output of H is 2κ bits long, the communication complexity of our protocol is at most</p><formula xml:id="formula_8">2κ + τ • log M τ • 3κ + τ • (κ log n + 2|C | + |w | + 2κ) A 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>-round HVZK proof</head><p>Inputs: Both parties have a circuit C; the prover also holds w with C(w) = 1. Values M, n, τ are parameters of the protocol.</p><p>Round 1 For each j ∈ [M], the prover does:</p><p>(1) Choose uniform seed * j ∈ {0, 1} κ and use it to generate values seed j,1 , r j,1 , . . ., seed j,n , r j,n . Also compute aux j ∈ {0, 1} |C | as described in the text. For i = 1, . . . , n -1, let state j,i := seed j,i ; let state j,n := seed j,n ∥aux j .</p><p>(2) For i ∈ [n], compute com j,i := Com(state j,i ; r j,i ).</p><p>(3) The prover simulates the online phase of the n-party protocol Π (as described in the text) using {state j,i } i , beginning by computing the masked inputs { ẑj,α } (based on w and the {λ j,α } defined by the preprocessing). Let msgs j,i denote the messages broadcast by S i in this protocol execution. (4) Let h j := H (com j,1 , . . . , com j,n ) and h ′ j := H ({ ẑj,α }, msgs j,1 , . . . , msgs j,n ). Compute h := H (h 1 , . . . , h M ) and h ′ := H (h ′ 1 , . . . , h ′ M ) and send h * := H (h, h ′ ) to the verifier. Round 2 The verifier chooses a uniform τ -sized set C ⊂ [M] and P = {p j } j ∈[τ ] where each p j ∈ [n] is uniform. Send (C, P) to the prover. Round 3 For each j ∈ [M] \ C, the prover sends seed * j , h ′ j to the verifier. For each j ∈ C, the prover sends {state j,i , r j,i } i p j , com j,p j , { ẑj,α }, and msgs j,p j to the verifier. Verification The verifier accepts iff all the following checks succeed:</p><p>(1) For every j ∈ C, i p j , the verifier uses state j,i and r j,i to compute com j,i . It then computes h j := H (com j,1 , . . . , com ).</p><p>(2) For j ∈ [M] \ C, the verifier uses seed * j to compute h j as an honest prover would. It then computes h := H (h 1 , . . . , h M ).</p><p>(3) For each j ∈ C, the verifier simulates an execution of Π among the {S i } i p j using {state j,i } i p j , masked input-wire values { ẑα }, and msgs j,p j . This yields {msgs i } i p j and an output bit b. The verifier checks that b ? = 1 and computes h ′ j := H ({ ẑj,α }, msgs j,1 , . . . , msgs j,n ) as well as</p><formula xml:id="formula_9">h ′ := H (h ′ 1 , . . . , h ′ m ).</formula><p>(4) The verifier checks that H (h, h ′ ) bits.</p><formula xml:id="formula_10">? = h * .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">REMOVING INTERACTION</head><p>In this section we describe how our 3-round protocol can be converted into a general NIZKPoK as well as a signature scheme. We also report on implementations of the resulting schemes. We implemented our protocol in C++ and will make the code available as open-source. All experiments (here and in Section 4) were carried out using a single core of an Intel Xeon E5-2666v3 CPU running at 2.9 GHz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">An NIZKPoK</head><p>We can apply the Fiat-Shamir transform <ref type="bibr" target="#b22">[23]</ref> to our 3-round protocol to obtain a non-interactive ZKPoK. In more detail, in this modified proof system the prover will compute the first-round message as before, and then derive a challenge by hashing the first message using a hash function G modeled as a random oracle. The proof then consists of the first-round message plus the response to that challenge; it can be verified in the standard way. Zero-knowledge of the resulting non-interactive proof system (in the random-oracle model) follows immediately from the fact that the 3-round interactive protocol is honest-verifier zero knowledge. Soundness-or, equivalently, the fact that the proof system is a proof of knowledge-can be proved using standard results about the Fiat-Shamir transform <ref type="bibr" target="#b41">[42]</ref>. Directly applying those results unfortunately results in a relatively loose concrete-security bound due to use of the "forking lemma." However, we observe that if H is also modeled as a random oracle, and is additionally used to instantiate the commitment scheme as discussed in Section 2.3, then it is possible to extract (with high probability) a valid witness w from a successful forgery without any rewinding at all, and thus obtain a tight security reduction. In a bit more detail: consider some attacker A making q G queries to the hash function G. Each time A makes a query of the form G(h * ), where h * represents a firstround message from the 3-round protocol, the previous H -queries made by A define<ref type="foot" target="#foot_3">3</ref> values corresponding to M executions of the entire protocol Π (i.e., both the preprocessing phase and the online phase). If any of those M executions is "correct, " then that execution defines a value w such that C(w) = 1, i.e., a witness is extracted. Otherwise, the probability that the response to that G-query allows A to generate a valid proof is bounded by ϵ(M, n, τ ). The overall probability that A can generate a valid proof, yet a witness cannot be extracted, is thus dominated by q G • ϵ(M, n, τ ). (A full analysis would also take into account the negligible-probability events from footnote 3. Details will be given in the full version.)</p><p>Chase et al. do not claim tight security for the non-interactive version of ZKB++, and the observation above is, to the best of our knowledge, new to our work.</p><p>Security against quantum algorithms. The preceding analysis assumes a classical attacker. We are not aware of any quantum attacks on our NIZKPoK that perform better than classical attacks, other than for quantum attacks on the underlying primitives (e.g., preimage attacks using Grover's algorithm, or better collision-finding attacks) that can be handled by simply increasing parameters. It is in this sense that we claim "post-quantum" security for our NIZKPoK. Nevertheless, we note that there are no known proofs of security for the Fiat-Shamir transform against quantum adversaries, except in some special cases <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b45">46]</ref>.</p><p>It is possible to apply Unruh's transformation <ref type="bibr" target="#b44">[45]</ref> to our 3-round proof to obtain a non-interactive scheme with provable security against quantum attacks (in the quantum random-oracle model); this was done in the Picnic submission <ref type="bibr" target="#b14">[15]</ref>. We are currently exploring the impact of this on the efficiency of our scheme.</p><p>Implementation optimizations. One potential source of overhead in our scheme is the large number of parties in the underlying MPC protocol. To reduce the impact of this, we utilize bit-level parallelization by packing all parties' shares into one word. This is efficient because most of the computations on parties' shares are identical, and therefore SIMD-friendly. This optimization works regardless of the topology of the circuit C.</p><p>Note, however, that each party's share is generated from a different seed, and so that step is not compatible with bit-packing. To address this, our implementation uses efficient bit-matrix transposition based on SSE instructions <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b46">47]</ref>: namely, we first generate a matrix of random bits contiguously aligned in memory, where each row is generated from one random seed, and then apply bit-level matrix transposition such that each column is a word containing one share of each party. Now, operating on shares of all parties takes only one instruction.</p><p>Our MPC protocol is designed in the preprocessing model. We can leverage this feature in our resulting proof system so as to allow the prover to perform most of its computation in an offline phase before the witness is known: specifically, the prover can compute h (cf. Figure <ref type="figure" target="#fig_1">2</ref>) without knowledge of w. Note that for other MPC-inthe-head proof systems where the underlying MPC protocol does not use preprocessing, most of the prover's computation cannot be done before the witness is known because the prover cannot begin emulating the MPC protocol without knowing the witness.</p><p>Computation/communication trade off. In Table <ref type="table" target="#tab_2">2</ref> we show the proof size and running time of the prover for circuits of various sizes. (A comparison to prior work is given below.) For computation time, we show both the total time (t total ) to compute a proof, as well as the online time (t online ), assuming all witness-independent work is done by the prover during an offline phase. The running time of the verifier is always roughly the same as the (total) running time of the prover, and so we do not report it. In all cases we set the parameters of the protocols so as to achieve 128-bit security against known quantum attacks; in particular, we use SHA-256 as the hash function and AES-256 for pseudorandom number generation, and set M, n, τ so that ϵ(M, n, τ ) ≤ 2 -256 .</p><p>Interestingly, our protocol offers the ability to trade off communication and computation by varying n. We show the effect of this in Table <ref type="table" target="#tab_2">2</ref>. By increasing n from 8 to 64, we can reduce the proof size almost by half; however, this results in a 4× slowdown in the computation. Nevertheless, there may be applications that prefer to optimize proof length vs. computation time, or vice versa. Observe that our protocol yields the smallest proof size for circuits containing ≈300-100,000 AND gates.</p><p>Comparison to prior work. We compare the performance of our scheme to the most relevant prior work, namely, ZKB++ and Ligero.</p><p>As in those works, we view the size of the resulting proofs as the primary metric of interest and so focus on that. At the time of this writing, neither ZKB++ nor Ligero is available as an open-source implementation: ZKB++ (and Picnic) is only available as a signature scheme rather than as a full-fledged NIZKPoK, and code for Ligero is not available. We calculate communication complexity based on equations provided in the original papers <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16]</ref>, but are unable to report on the computational time required by the other protocols.</p><p>For a circuit having |C | AND gates, the proofs in our NIZKPoK have length O(κ • |C |/log n) whereas those in ZKB++ have length O(κ • |C |). Since in our scheme n can vary (in contrast to ZKB++ which fixes n = 3), we can obtain asymptotically shorter proofs. More importantly, as discussed below, we obtain concretely shorter proofs than in ZKB++ for medium-size circuits even when we fix n ∈ {16, 64} as we do in our experiments.</p><p>The communication complexity of our scheme is asymptotically worse than that of Ligero, which has proofs of size O(κ</p><formula xml:id="formula_11">• |C | log |C |).</formula><p>However, the computational complexity of the prover in Ligero is O(|C | log 2 |C |), which is significant for large circuits. In contrast, the computational complexity of the prover in our protocol (after applying all the optimizations described in the text) is O(|C |). Concretely, we note that in our protocol all operations can use hardware acceleration, whereas Ligero requires field operations that are expected to be much slower.</p><p>Notwithstanding the fact that the communication complexity in Ligero is asymptotically better than in ours, there is a range of circuit sizes for which the concrete communication of our protocol is best. This is demonstrated in Figure <ref type="figure" target="#fig_2">3</ref>, where we plot the communication complexity of ZKB++, Ligero (for two different values of n) as the circuit size varies, for a fixed input length |w | = 256. (In all cases, parameters were set so as to achieve 128-bit quantum security.) Figure <ref type="figure" target="#fig_2">3</ref> shows that for very small circuits (below ≈ 300 AND gates), ZKB++ offers the lowest communication complexity; for very large circuits (above ≈ 100, 000 AND gates), Ligero is best. But in the range of 300-100,000 AND gates, our protocol outperforms both of those. This range captures many circuits of cryptographic interest, including those used in our signature scheme and the more advanced schemes introduced in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Post-Quantum Signature Scheme</head><p>As in the work of Chase et al. <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>, we can use our NIZKPoK to obtain a signature scheme whose security is based on symmetrickey primitives only. Specifically, the private key is a uniform value k ∈ {0, 1} κ ; the public key is y := PRF k (0 κ ), where PRF is a block cipher; and a signature is an NIZKPoK of k, where the message being signed is included as input to the hash function G used to compute the challenge. For 128-bit quantum security, we use a block cipher with 256-bit key and block length. We implemented the resulting signature scheme, instantiating PRF with the LowMC block cipher <ref type="bibr" target="#b2">[3]</ref> that was designed to be efficient for MPC applications. Our implementation was meant to enable an "apples-to-apples" comparison to the signature scheme of Chase et al. <ref type="bibr" target="#b15">[16]</ref> at a 128-bit quantum security level. In particular, we use the same hash function, pseudorandom generator, and instantiation of PRF as they do.</p><p>In Table <ref type="table" target="#tab_3">3</ref> we display the performance of our scheme and compare it to other post-quantum signatures based on symmetric-key primitives. Performance numbers for the ZKB++ signature scheme were obtained from a most recent technical report <ref type="bibr" target="#b40">[41]</ref> that is slightly better than what is reported in <ref type="bibr" target="#b15">[16]</ref>. <ref type="foot" target="#foot_5">5</ref> For our scheme, we report performance for n = 16 and n = 64. We find that both versions of our scheme achieve better signature length compared to the scheme of Chase et al., with an improvement of 2.6-3×. The running time of our scheme is comparable to their scheme when n = 16. When n = 64, our running time is noticeably worse, but nevertheless still practical. Interestingly, the signature length of our scheme is even competitive with hash-based signature schemes (not constructed using NIZKPoKs); in particular, when n = 64 our signatures are 6% shorter than those of SPHINCS-256 <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONSTRUCTING RING AND GROUP SIGNATURES</head><p>To highlight the flexibility and power of our NIZKPoK, we also use it to build efficient ring/group signatures based on symmetrickey primitives alone. <ref type="foot" target="#foot_6">6</ref> To the best of our knowledge, the resulting schemes are the most efficient constructions of these primitives that can claim to offer post-quantum security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Ring Signatures</head><p>Ring signatures were introduced by Rivest, Shamir, and Tauman <ref type="bibr" target="#b43">[44]</ref>. Roughly, they allow a user to adaptively define a ring R of users (of which it is a member), and then generate a signature that can be verified as having been generated by some user in that ring (without revealing precisely which one). Importantly, this can be done without the involvement of the other users in the ring. Formally, a ring signature scheme consists of three probabilistic polynomial-time algorithms (Gen, Sign, Vrfy) defined as follows:</p><p>• The key-generation algorithm Gen takes as input the security parameter κ and generates public key pk and associated private key sk. (with pk i ∈ R) outputs Sign(R, sk i , M). (Note that we do not require R ⊆ S.) (3) A may also query a corruption oracle Corrupt that on input i returns sk i . If A queries Corrupt(i) then we say that pk i is corrupted. We let C be the set of corrupted public keys at the end of the experiment. (4) A outputs M * , R * , σ * . It succeeds if (1) Vrfy(R * , M * , σ * ) = 1;</p><p>(2) R * ⊆ S \ C; and (3) A never queried Sign ′ (R * , ⋆, M * ).</p><p>Anonymity. Intuitively, anonymity ensures that a valid signature with respect to a ring R does not reveal which secret key (corresponding to some public key in R) was used to generate the signature. Our definition is based on [8, Definition 5], slightly simplified for our context. Definition 4.2. Ring signature scheme (Gen, Sign, Vrfy) is anonymous if, for any ppt adversary A and any polynomial ℓ, the probability that A succeeds in the following experiment is at most 1/2 + negl(κ):</p><p>(1) Keys {(pk i , sk i )} ℓ i=1 are generated by Gen(1 κ ) and all keys (both public and private) are given to A.</p><p>(2) A outputs a message M, a ring R, and i 0 , i Constructing a ring signature scheme. The main idea is to generate a ring signature with respect to a ring R by generating an NIZKPoK of the secret key corresponding to one of the public keys in R. The main question is how to do so while reducing the size of the proof as much as possible.</p><formula xml:id="formula_12">1 ∈ [ℓ]. A uniform b ∈ {0, 1} is chosen, and A is given Sign(R ′ , sk i b , M), where R ′ = R ∪ {pk i 0 , pk i 1 }. (<label>3</label></formula><p>A naive solution to building a ring signature scheme, based on the signature scheme from the previous section, is as follows. As before, key generation chooses a uniform key k ∈ {0, 1} κ ; the corresponding public key is y := PRF k (0 κ ). Given a ring R = {y i } ℓ i=1 of public keys, let C be the circuit that takes as input a key k and outputs 1 iff PRF k (0 κ ) = y i for some i. (Alternately, it can take as input k, i and output 1 iff PRF k (0 κ ) = y i . This does not materially affect the parameters.) A signature will then be an NIZKPoK of an input k i such that C(k i ) = 1. The size of C (and hence the size of a signature) grows linearly in ℓ = |R|.</p><p>Efficiency can be improved using a Merkle tree. Given a ring R as before, we define a (public) mechanism for computing a Merkle root h * starting from values y 1 , . . . , y ℓ at the leaves; assume for simplicity that ℓ = 2 q for some integer q. Let C be a circuit that takes as input k, i, and an auxiliary value path; computes y := PRF k (0 κ ); and then outputs 1 if path is a valid Merkle proof (with respect to root h * ) for value y at leaf i. As before, a signature is an NIZKPoK of an input for which C evaluates to 1. Importantly, the size of C (and hence the signature length) is now only logarithmic in ℓ.</p><p>Anonymity of the scheme is ensured by the zero-knowledge property of the NIZKPoK. Given an adversary who forges a signature for some ring R * of uncorrupted keys (and assuming the hash function used for the Merkle tree is collision-resistant), we can use the knowledge extractor of the NIZKPoK to extract k, i such that PRF k (0 κ ) = y i for some uncorrupted party i. That is, the adversary is able to find a private key for some uncorrupted party, which happens with negligible probability. As in the previous section, since the scheme relies on symmetric-key primitives alone it can be said to offer post-quantum security. We refer to Section 4.3 for a performance evaluation of the scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Group Signatures</head><p>A group signature scheme <ref type="bibr" target="#b16">[17]</ref> also allows users in a group to sign messages without revealing their identity (beyond the fact that they belong to the group). The main differences between group signatures and ring signatures are that (1) in the context of group signatures, a group manager determines membership in the group; and (2) the group manager has the ability to violate anonymity by tracing the user who generated a given signature.</p><p>We focus on the case of static groups for simplicity. Formally, a group signature scheme consists of four probabilistic polynomialtime algorithms (Gen, Sign, Vrfy, Open) with the following functionality:</p><p>• The key-generation algorithm Gen takes as input the security parameter κ and the number of group members ℓ, and generates a master public key gpk, master private key gmsk, and signing keys gsk 1 , . . . , gsk ℓ . • The signing algorithm Sign takes as input a signing key gsk i and a message M, and outputs a signature σ . ours has the advantage of not having to rely on trusted public parameters.</p><p>Recent work by Ling et al. <ref type="bibr" target="#b36">[37]</ref> gives a group signature scheme based on lattices for which the signature size is independent of the number of users in the group. However, they do not investigate the concrete efficiency of their scheme, and it appears that our scheme will out-perform theirs for practical settings of the parameters. Some concurrent works <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b20">21]</ref> have proposed constructions of ring and group signature schemes based on ideas similar to ours, but using ZKB++ as the underlying NIZKPoK. As shown in Table <ref type="table" target="#tab_5">4</ref>, by using our NIZKPoK in place of ZKB++ we are able to generate signatures roughly 3.5-4.4× shorter than in their work. (They do not provide implementations, so we are unable to determine the running times for their schemes.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>We show here a new construction of a "post-quantum" NIZKPoK with shorter proof size than in prior work. We also explored applications of our work in the context of various signature schemes. It remains interesting to explore other applications of our work, e.g., to smart contracts and/or verification of arithmetic circuits.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Our basic HVZK proof.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Our 3-round HVZK proof.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure3: Proof size of ZKB++, Ligero, and our protocols. Observe that our protocol yields the smallest proof size for circuits containing ≈300-100,000 AND gates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>) A outputs a bit b ′ , and succeeds if b ′ = b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Sample values of M, n, and τ to achieve statistical security ρ ∈ {128, 256}. M is the number of executions simulated by the prover; n is number of parties in the MPC protocol; τ is the number of executions of the online phase of the MPC protocol.preprocessing phase. If we are willing to model H as a random oracle, then we can streamline things by observing that all committed values have min-entropy at least κ and can thus be committed by direct evaluation of H (i.e., we may set com j,i := H (state j,i )). This reduces communication since no additional randomness is needed for decommitment.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">ρ = 128</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">ρ = 256</cell><cell></cell></row><row><cell>n</cell><cell>4</cell><cell>8</cell><cell>16</cell><cell>32</cell><cell cols="2">64 128</cell><cell>4</cell><cell>8</cell><cell>16</cell><cell>32</cell><cell>64</cell><cell>128</cell></row><row><cell cols="7">M 218 252 352 462 631 916</cell><cell cols="6">456 533 781 1024 1662 2540</cell></row><row><cell>τ</cell><cell>65</cell><cell>44</cell><cell>33</cell><cell>27</cell><cell>23</cell><cell>20</cell><cell cols="2">129 87</cell><cell>65</cell><cell>53</cell><cell>44</cell><cell>38</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>4 , and our protocol Performance of our NIZKPoK. Parameters of all schemes were set to achieve 128-bit quantum security, as discussed in the text. |σ | is the proof size; t total is the total computation time; t online is the online time.</figDesc><table><row><cell>Circuit size:</cell><cell></cell><cell>1,000</cell><cell></cell><cell></cell><cell>10,000</cell><cell></cell><cell></cell><cell>100,000</cell></row><row><cell></cell><cell>|σ |</cell><cell cols="2">t total t online</cell><cell>|σ |</cell><cell>t total</cell><cell>t online</cell><cell></cell><cell>|σ |</cell><cell>t total</cell><cell>t online</cell></row><row><cell>n = 64</cell><cell cols="3">37 KB 128 ms 10 ms</cell><cell cols="3">136 KB 851 ms 220 ms</cell><cell cols="2">1126 KB 7865 ms 2207 ms</cell></row><row><cell>n = 32</cell><cell cols="3">39 KB 51 ms 7 ms</cell><cell cols="3">159 KB 420 ms 149 ms</cell><cell cols="2">1351 KB 4015 ms 1498 ms</cell></row><row><cell>n = 16</cell><cell cols="3">44 KB 28 ms 7 ms</cell><cell cols="3">190 KB 250 ms 105 ms</cell><cell cols="2">1652 KB 2408 ms 1039 ms</cell></row><row><cell>n = 8</cell><cell cols="3">50 KB 16 ms 4 ms</cell><cell cols="3">246KB 190 ms 87 ms</cell><cell cols="2">2203 KB 1886 ms 883 ms</cell></row><row><cell>Scheme</cell><cell></cell><cell>|σ |</cell><cell>Gen</cell><cell>Sign</cell><cell>Vrfy</cell><cell>|sk|</cell><cell>|pk|</cell><cell>Assumption</cell></row><row><cell cols="7">This paper (n = 64) 38.5 KB 0.01 ms 129 ms 129 ms 32 B</cell><cell>64 B</cell><cell>random-oracle model</cell></row><row><cell cols="7">This paper (n = 16) 45.9 KB 0.01 ms 28 ms 28 ms 32 B</cell><cell>64 B</cell><cell>random-oracle model</cell></row><row><cell cols="2">ZKB++ [16]</cell><cell cols="5">118.5 KB 0.01 ms 25 ms 17 ms 32 B</cell><cell>64 B</cell><cell>random-oracle model</cell></row><row><cell cols="2">SPHINCS-256 [9]</cell><cell cols="7">41 KB 0.82 ms 13 ms 0.58 ms 1088 B 1056 B collision-resistant hashing</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Performance of signature schemes with 128-bit quantum security. We report times for key generation, signing, and verification, as well as the lengths of the signature σ , private key sk, and public key pk.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>•</head><label></label><figDesc>The signing algorithm Sign takes as input a set (or "ring") R = {pk i } of distinct public keys, a secret key sk corresponding to one of the public keys in R, and a message M. It outputs a signature σ .• The verification algorithm Vrfy takes as input a ring R of distinct public keys, a message M, and a signature σ . It outputs a single bit indicating acceptance or rejection. Correctness requires that for any collection of keys {(pk i , sk i )} i ∈[ℓ] output by Gen, any message M, and any j ∈ [ℓ], we have Vrfy({pk i }, M, Sign({pk i }, sk j , M)) = 1.Unforgeability. Intuitively, unforgeability means that an adversary not in R should not be able to generate a valid signature σ on a message M relative to a ring R unless some honest user in R had previously signed M (relative to the same ring) [8,Definition 8].Definition 4.1. Ring signature scheme (Gen, Sign, Vrfy) is unforgeable if, for any ppt adversary A and any polynomial ℓ, the probability that A succeeds in the following experiment is negligible in κ:</figDesc><table><row><cell>Ring signatures have two security requirements: unforgeability and</cell></row><row><cell>anonymity. We present formal definitions below, following Bender</cell></row><row><cell>et al. [8].</cell></row></table><note><p>(1) Keys {(pk i , sk i )} ℓ i=1 are generated by Gen(1 κ ). The public keys S def = {pk i } ℓ i=1 are given to A. (2) A may query an oracle Sign ′ (•, •, •), where Sign ′ (R, i, M)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>• The verification algorithm Vrfy takes as input the master public key gpk, a message M, and a signature σ . It outputs a bit indicating acceptance or rejection. • The tracing algorithm Open takes as input the master private key gmsk, a message M, and a signature σ . It outputs an index i ∈ [ℓ] or a failure symbol ⊥. Performance of our ring/group signature schemes, and comparison to prior work. |σ | is the signature size, and t is the signing/verification time. The top two schemes are ring signatures; the bottom two are group signatures.</figDesc><table><row><cell>Ring/group size:</cell><cell>2 7</cell><cell></cell><cell>2 10</cell><cell></cell><cell>2 13</cell></row><row><cell></cell><cell>|σ |</cell><cell>t</cell><cell>|σ |</cell><cell>t</cell><cell>|σ |</cell><cell>t</cell></row><row><cell cols="2">Derler et al. [21] 982 KB</cell><cell>-</cell><cell cols="2">1.35 MB -</cell><cell cols="2">1.72 MB -</cell></row><row><cell>Here</cell><cell cols="2">285 KB 2.0 s</cell><cell cols="2">388 KB 2.8 s</cell><cell cols="2">492 KB 3.6 s</cell></row><row><cell cols="3">Boneh et al. [12] 1.37 MB -</cell><cell cols="2">1.85 MB -</cell><cell>-</cell><cell>-</cell></row><row><cell>Here</cell><cell cols="2">315 KB 2.3 s</cell><cell cols="2">418 KB 3.0 s</cell><cell cols="2">532 KB 3.8 s</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In this paper we do not distinguish between computational and information-theoretic soundness, and thus refer to both arguments and proofs simply as "proofs. "</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>CCS'18, October 15-19, 2018, Toronto, ON, Canada  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>We could also use a two-round commitment scheme by adding one additional round to the proof system.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>It is possible that A has not made H -queries defining those values, but in that case it is easy to see that the probability A is able to use the response from the G-query to generate a valid proof is negligible. Alternately, a hash collision would mean that the values are ill-defined; such collisions occur with negligible probability.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Numbers for Ligero are conservative estimates, since their paper only considers 40-bit security in an interactive setting. Session 3C: Crypto: Lattice/ZKP CCS'18, October 15-19, 2018, Toronto, ON, Canada</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>We take the numbers for the version of their scheme using the same LowMC circuit we use.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Note that group signatures with full anonymity imply public-key encryption<ref type="bibr" target="#b1">[2]</ref>, and thus the group signatures we construct will meet a slightly weaker definition.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This material is based on work supported by NSF awards #1111599 and #1563722. Work of the second and third authors was done in part while at Bell Labs, and was supported in part by the Office of Naval Research (ONR) under contract number N00014-14-C0113. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes not withstanding any copyright notation thereon. The views, opinions, and/or findings expressed are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Correctness requires that for any gpk, gmsk, gsk 1 , . . . , gsk ℓ output by Gen, any message M, and any i ∈ [ℓ], we have Vrfy(gpk, M, Sign(gsk i , M)) = 1 and Open(gmsk, M, Sign(gsk i , M)) = i.</p><p>Bellare et al. <ref type="bibr" target="#b5">[6]</ref> define two security requirements for group signatures: traceability and anonymity. We follow their definitions here with some differences described below.</p><p>Traceability. The traceability property requires that an attacker who colludes with some set C of group members cannot output a valid signature that fails to be traced by the group manager to some member of C. Definition 4.3. Group signature scheme (Gen, Sign, Vrfy, Open) is traceable if, for any ppt adversary A and any polynomial ℓ, the probability that A succeeds in the following experiment is negligible in κ:</p><p>(1) Keys gpk, gmsk, gsk 1 , . . . , gsk ℓ are output by Gen(1 κ , 1 ℓ ), and gpk, gmsk are given to A. (2) A may query an oracle Sign ′ (•, •), where Sign ′ (i, M, ) outputs Sign(gsk i , M). (3) A may also query a corruption oracle Corrupt that on input i returns gsk i ; in this case we say that user i is corrupted. We let C denote the set of corrupted users at the end of the experiment. (4) A outputs M, σ , and succeeds if: (1) Vrfy(gpk, M, σ ) = 1;</p><p>(2) Open(gmsk, M, σ ) C; and (3) the adversary never made a query Sign ′ (⋆, M).</p><p>As shown by Bellare et al. <ref type="bibr" target="#b5">[6]</ref>, traceability implies unforgeability (simply consider C = ∅ in the above definition). One could also consider a weaker definition of traceability (that still implies unforgeability) in which gmsk is not given to the adversary. Our scheme can be made more efficient if that weaker definition suffices.</p><p>Anonymity. As in the case of ring signatures, anonymity implies that a valid signature does not reveal the user who generated that signature (except the group manager who holds gmsk); this should hold even if the adversary is given access to a tracing oracle to which it can submit any other signature. The notion of full anonymity considered by Bellare et al. <ref type="bibr" target="#b5">[6]</ref> requires signatures produced by a user i to remain anonymous even if the secret key gsk i of that user is known to the adversary. A weaker notion <ref type="bibr" target="#b13">[14]</ref> requires anonymity only for uncorrupted users. Previous work <ref type="bibr" target="#b1">[2]</ref> shows that fully anonymous group signatures imply public-key encryption. Since our goal is to construct a scheme based on symmetric-key primitives alone, we consider the weaker notion of anonymity here. Definition 4.4. Group signature scheme (Gen, Sign, Vrfy, Open) satisfies weak anonymity if, for any ppt adversary A and any polynomial ℓ, the probability that A succeeds in the following experiment is at most 1/2 + negl(κ):</p><p>(1) Keys gpk, gmsk, gsk 1 , . . . , gsk ℓ are output by Gen(1 κ , 1 ℓ ), and gpk is given to A. (2) A is given access to the following oracles:</p><p>• A signing oracle that on input M, i outputs Sign(gsk i , M).</p><p>• A corruption oracle that on input i outputs gsk i . We let C denote the set of queries made by A to this oracle at the end of the experiment. • A tracing oracle that outputs Open(gmsk, M, σ ).</p><p>(3) At some point, A outputs a message M * and i 0 ,</p><p>Then a uniform b ∈ {0, 1} is chosen, σ * ← Sign(gsk i b , M) is computed, and A is given σ * . (4) A may continue to query all the oracles above, except that it may not query its tracing oracle on M * , σ * . (5) A outputs a bit b ′ , and succeeds if i 0 , i 1 C and b ′ = b.</p><p>Constructing a group signature scheme. Analogous to our construction of a ring signature scheme, the basic idea here is for a user to generate a signature by generating an NIZKPoK of a secret key corresponding to the group public key. Here, however, we must also ensure traceability, which adds additional complications.</p><p>Assume for simplicity that ℓ = 2 q for some integer q. In our scheme, the private key gsk i of a user now includes two uniform and independent keys k 0 i , k 1 i ; we set</p><p>private key gmsk consists of the {k 0 i } but, importantly, does not include the {k 1 i }. A Merkle root h * is then computed for the Merkle tree with values (y 0 1 , y 1 1 ), . . . , (y 0 ℓ , y 1 ℓ ) at the ℓ leaves of the tree. The master public key is h * , and the private key gsk i of a user includes the Merkle proof (with respect to h * ) for (y 0 i , y 1 i ). Let C x,y be a circuit that has values x, y hardcoded; takes as input k 0 , k 1 , i, and an auxiliary value path; computes y 0 := PRF k 0 (0 κ ) and y 1 := PRF k 1 (0 κ ); and then outputs 1 iff y = PRF k 0 (x) and path is a valid Merkle proof (with respect to h * ) for the value (y 0 , y 1 ) at leaf i. To sign a message M, a user i holding k 0 i , k 1 i computes y = PRF k 0 i (H (M)) and then generates an NIZKPoK of an input for which the circuit C H (M ),y outputs 1; the signature includes both y and the resulting proof. Tracing is done by finding the key k 0 i for which PRF k 0 i (H (M)) = y. We refer to Section 4.3 for a performance evaluation of the scheme.</p><p>Traceability and weak anonymity of the above construction follows using standard techniques; we omit the details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Implementation and Performance</head><p>We implemented the ring and group signature schemes described in the previous sections, using our NIZKPoK from Section 3.1 with n = 64 so as to optimize the signature length. As previously, we target 128-bit quantum security. Both of our schemes involving constructing a circuit that can verify a Merkle path, which requires several hash-function computations. To minimize the circuit size, we derived a fixed-length hash function mapping 512-bit inputs to 256-bit outputs by applying the Davies-Meyer construction to the LowMC cipher with 256-bit key/block size. (This matches what was done in concurrent work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b20">21]</ref> mentioned below.) We summarize the performance of our schemes in Table <ref type="table">4</ref>.</p><p>The signature length in our ring signature scheme asymptotically matches what is achieved by the state-of-the-art, lattice-based ring signature scheme by Libert et al. <ref type="bibr" target="#b35">[36]</ref>, but the concrete efficiency of our scheme (both in terms of communication and computation) appears to be significantly better. <ref type="bibr">(Libert et al.</ref> do not provide an implementation of their scheme.) As compared to their scheme, Session 3C: Crypto: Lattice/ZKP CCS'18, October 15-19, 2018, Toronto, ON, Canada</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">From Identification to Signatures via the Fiat-Shamir Transform: Minimizing Assumptions for Security and Forward-Security</title>
		<author>
			<persName><forename type="first">Michel</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jee</forename><surname>Hea An</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chanathip</forename><surname>Namprempre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2002</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Lars</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2332</biblScope>
			<biblScope unit="page" from="418" to="433" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the Minimal Assumptions of Group Signature Schemes</title>
		<author>
			<persName><forename type="first">Michel</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>Warinschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICICS 04: 6th International Conference on Information and Communication Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Javier</forename><surname>López</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sihan</forename><surname>Qing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Eiji</forename><surname>Okamoto</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3269</biblScope>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ciphers for MPC and FHE</title>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">R</forename><surname>Albrecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tyge</forename><surname>Tiessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zohner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2015, Part I</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Elisabeth</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="430" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Ligero: Lightweight Sublinear Arguments Without a Trusted Setup</title>
		<author>
			<persName><forename type="first">Scott</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmit</forename><surname>Hazay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 17: 24th Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2087" to="2104" />
		</imprint>
	</monogr>
	<note>Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On Defining Proofs of Knowledge</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO&apos;92</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ernest</forename><forename type="middle">F</forename><surname>Brickell</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">740</biblScope>
			<biblScope unit="page" from="390" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Foundations of Group Signatures: Formal Definitions, Simplified Requirements, and a Construction Based on General Assumptions</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniele</forename><surname>Micciancio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>Warinschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EURO-CRYPT 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Eli</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="614" to="629" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SNARKs for C: Verifying Program Executions Succinctly and in Zero Knowledge</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madars</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2013, Part II</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8043</biblScope>
			<biblScope unit="page" from="90" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ring Signatures: Stronger Definitions, and Constructions without Random Oracles</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruggero</forename><surname>Morselli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="114" to="138" />
			<date type="published" when="2009-01">2009. Jan. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SPHINCS: Practical Stateless Hash-Based Signatures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daira</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Hopwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tanja</forename><surname>Hülsing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruben</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louiza</forename><surname>Niederhagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Papachristodoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zooko</forename><surname>Schwabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-O'</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName><surname>Hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2015, Part I</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Elisabeth</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="368" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Noninteractive Zero-Knowledge</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfredo</forename><forename type="middle">De</forename><surname>Santis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1084" to="1118" />
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Non-Interactive Zero-Knowledge and Its Applications</title>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">20th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="103" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Post-Quantum EPID Group Signatures from Symmetric Primitives</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saba</forename><surname>Eskandarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Fisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2018">2018. 2018/261</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Lattice-Based SNARGs and Their Application to More Efficient Obfuscation</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="page" from="247" to="277" />
			<date type="published" when="2017">2017</date>
			<publisher>Springer</publisher>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Group Signatures: Better Efficiency and New Theoretical Aspects</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN 04: 4th International Conference on Security in Communication Networks</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Carlo</forename><surname>Blundo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stelvio</forename><surname>Cimato</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3352</biblScope>
			<biblScope unit="page" from="120" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">Melissa</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Derler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Goldfeder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Orlandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Ramacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Slamanig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Zaverucha</surname></persName>
		</author>
		<ptr target="https://microsoft.github.io/Picnic" />
		<title level="m">The Picnic Signature Scheme Design Document</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Post-Quantum Zero-Knowledge and Signatures from Symmetric-Key Primitives</title>
		<author>
			<persName><forename type="first">Melissa</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Derler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Goldfeder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Orlandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Ramacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Slamanig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Greg</forename><surname>Zaverucha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 17: 24th Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1825" to="1842" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Group Signatures</title>
		<author>
			<persName><forename type="first">David</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugène</forename><surname>Van Heyst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT&apos;91</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Donald</forename><forename type="middle">W</forename><surname>Davies</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">547</biblScope>
			<biblScope unit="page" from="257" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">SOFIA: M Q-Based Signatures in the QROM</title>
		<author>
			<persName><forename type="first">Ming-Shing</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Hülsing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joost</forename><surname>Rijneveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simona</forename><surname>Samardjiska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Schwabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="page" from="3" to="33" />
			<date type="published" when="2018">2018</date>
			<publisher>Springer</publisher>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Geppetto: Versatile Verifiable Computation</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Costello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cédric</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markulf</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Kreuter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samee</forename><surname>Zahur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="253" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Zero-Knowledge Proofs of Knowledge Without Interaction</title>
		<author>
			<persName><forename type="first">Alfredo</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santis</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd Annual Symposium on Foundations of Computer Science</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="427" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Post-Quantum Zero-Knowledge Proofs for Accumulators with Applications to Ring Signatures from Symmetric-Key Primitives</title>
		<author>
			<persName><forename type="first">David</forename><surname>Derler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Ramacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Slamanig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="1154">2017. 2017/1154</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multiple Non-Interactive Zero Knowledge Proofs Based on a Single Random String</title>
		<author>
			<persName><forename type="first">Uriel</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dror</forename><surname>Lapidot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st Annual Symposium on Foundations of Computer Science</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="308" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How to Prove Yourself: Practical Solutions to Identification and Signature Problems</title>
		<author>
			<persName><forename type="first">Amos</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO&apos;86</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Andrew</forename><forename type="middle">M</forename><surname>Odlyzko</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="186" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Privacy-Free Garbled Circuits with Applications to Efficient Zero-Knowledge</title>
		<author>
			<persName><forename type="first">Tore</forename><surname>Kasper Frederiksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesper</forename><surname>Buus Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Orlandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2015, Part II</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Elisabeth</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9057</biblScope>
			<biblScope unit="page" from="191" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Quadratic Span Programs and Succinct NIZKs without PCPs</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariana</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2013</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Johansson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Phong</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7881</biblScope>
			<biblScope unit="page" from="626" to="645" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Separating Succinct Non-Interactive Arguments from All Falsifiable Assumptions</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">43rd Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">Lance</forename><surname>Fortnow</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Salil</surname></persName>
		</editor>
		<editor>
			<persName><surname>Vadhan</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">ZKBoo: Faster Zero-Knowledge for Boolean Circuits</title>
		<author>
			<persName><forename type="first">Irene</forename><surname>Giacomelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesper</forename><surname>Madsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Orlandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Proofs That Yield Nothing But Their Validity Or All Languages in NP Have Zero-Knowledge Proof Systems</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="691" to="729" />
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The Knowledge Complexity of Interactive Proof Systems</title>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="291" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the Size of Pairing-Based Non-interactive Arguments</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2016, Part II</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jean-Sébastien</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9666</biblScope>
			<biblScope unit="page" from="305" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the Power of Secure Two-Party Computation</title>
		<author>
			<persName><forename type="first">Carmit</forename><surname>Hazay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muthuramakrishnan</forename><surname>Venkitasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2016, Part II</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Matthew</forename><surname>Robshaw</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9815</biblScope>
			<biblScope unit="page" from="397" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Zero-Knowledge from Secure Multiparty Computation</title>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eyal</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">39th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Uriel</forename><surname>Feige</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Zero-Knowledge using Garbled Circuits: How to Prove Non-Algebraic Statements Efficiently</title>
		<author>
			<persName><forename type="first">Marek</forename><surname>Jawurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Kerschbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Orlandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 13: 20th Conference on Computer and Communications Security</title>
		<editor>
			<persName><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Virgil</forename><forename type="middle">D</forename><surname>Gligor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Moti</forename><surname>Yung</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="955" to="966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer</title>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emmanuela</forename><surname>Orsini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Scholl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 16: 23rd Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="830" to="842" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A Note on Efficient Zero-Knowledge Proofs and Arguments</title>
		<author>
			<persName><forename type="first">Joe</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="723" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Zero-Knowledge Arguments for Lattice-Based Accumulators: Logarithmic-Size Ring Signatures and Group Signatures Without Trapdoors</title>
		<author>
			<persName><forename type="first">Benoît</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">San</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Khoa</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huaxiong</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2016, Part II</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jean-Sébastien</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9666</biblScope>
			<biblScope unit="page" from="1" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<author>
			<persName><forename type="first">San</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Khoa</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huaxiong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanhong</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constant-Size Group Signatures from Lattices</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="58" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Computationally Sound Proofs</title>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1253" to="1298" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Revocation and Tracing Schemes for Stateless Receivers</title>
		<author>
			<persName><forename type="first">Dalit</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffery</forename><surname>Lotspiech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2001 (Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Joe</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="41" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Pinocchio: Nearly Practical Verifiable Computation</title>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariana</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Improvements to the Linear Layer of LowMC: A Faster Picnic</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Perrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Promitzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Ramacher</surname></persName>
		</author>
		<author>
			<persName><surname>Rechberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="1148">2017. 2017/1148</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Security Arguments for Digital Signatures and Blind Signatures</title>
		<author>
			<persName><forename type="first">David</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="361" to="396" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Efficient Generic Zero-Knowledge Proofs from Commitments</title>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Ranellucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alain</forename><surname>Tapp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rasmus</forename><surname>Winther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zakarias</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICITS 16: 9th International Conference on Information Theoretic Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="190" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">How to Leak a Secret</title>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yael</forename><surname>Tauman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Colin</forename><surname>Boyd</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2248</biblScope>
			<biblScope unit="page" from="552" to="565" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Non-Interactive Zero-Knowledge Proofs in the Quantum Random Oracle Model</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Elisabeth</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9057</biblScope>
			<biblScope unit="page" from="755" to="784" />
		</imprint>
	</monogr>
	<note>Advances in Cryptology -EUROCRYPT 2015, Part II</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Post-Quantum Security of Fiat-Shamir</title>
		<author>
			<persName><forename type="first">Dominique</forename><surname>Unruh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2017, Part I</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="65" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><forename type="middle">J</forename><surname>Malozemoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Faster Secure Two-Party Computation in the Single-Execution Setting</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="399" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Authenticated Garbling and Efficient Maliciously Secure Two-Party Computation</title>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Ranellucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS 17: 24th Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="21" to="37" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
