<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Types, Bytes, and Separation Logic</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Harvey</forename><surname>Tuch</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Gerwin</forename><surname>Klein</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Michael</forename><surname>Norrish</surname></persName>
							<email>michael.norrish@nicta.com.au</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Sydney Research Lab</orgName>
								<orgName type="department" key="dep2">School of Computer Science and Engineering</orgName>
								<orgName type="institution">National ICT Australia *</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">UNSW</orgName>
								<address>
									<settlement>Sydney</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Canberra Research Lab</orgName>
								<orgName type="institution">National ICT Australia</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Types, Bytes, and Separation Logic</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3D044D4C0B6681EE7544187252EE7DE2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs-Mechanical verification General Terms Languages</term>
					<term>Theory</term>
					<term>Verification Separation Logic</term>
					<term>C</term>
					<term>Interactive Theorem Proving</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a formal model of memory that both captures the lowlevel features of C's pointers and memory, and that forms the basis for an expressive implementation of separation logic. At the low level, we do not commit common oversimplifications, but correctly deal with C's model of programming language values and the heap. At the level of separation logic, we are still able to reason abstractly and efficiently. We implement this framework in the theorem prover Isabelle/HOL and demonstrate it on two case studies. We show that the divide between detailed and abstract does not impose undue verification overhead, and that simple programs remain easy to verify. We also show that the framework is applicable to real, security-and safety-critical code by formally verifying the memory allocator of the L4 microkernel.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Nearly All Binary Searches and Mergesorts are Broken. This was the title of a short, widely read article by Joshua Bloch on Google's research blog <ref type="bibr" target="#b5">[6]</ref>. Bloch had discovered a problem in his implementation of binary search in an array in the standard Java library. The problem had remained unnoticed for nine years of widespread deployment in the Java platform, and Bloch argues that it is in fact about 50 years old as it can be found in most standard text-books. What is remarkable about this error is that many of the text-book and lecture implementations have been formally proven correct.</p><p>The problem is that the usual text-book view of state and values in programming language semantics is an oversimplification. The bug described by Bloch is a simple value overflow that occurs in Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. POPL'07 January 17 <ref type="bibr">-19, 2007</ref>, Nice, France. Copyright c 2007 ACM 1-59593-575-4/07/0001. . . $5.00. the computation of the average of two values: int mid = (low + high) / 2. For sufficiently large values of low and high this statement is wrong. One version that works for all values is mid = low + ((high -low) / 2).</p><p>Even in the light of industrially deployed programs failing because of this error, one is tempted to say that they are not really wrong; that they work as long as int behaves like the integers of mathematics, and that people should not be using values that are too large. If the specification of binary search did have this precondition explicitly stated, then this view would be defensible. Of course it does not, because we would rather not think about the messy world of finite values, finite memory, unsafe pointer operations, pointer alignment, and other low level constraints of real programming languages when we are focusing on the interesting parts of verifying a program. This view is not just wishful thinking: it was, and in part still is, also widely believed that dealing with all this detail in program verification is intractable, and that it obscures the algorithmic part where errors are most likely. Nonetheless, it is our thesis and contribution that we can indeed verify real programs in real programming languages with their real semantics, and provide the hard correctness guarantees of formal software verification, without sacrificing soundness and without drowning in detail.</p><p>Our verification methodology for programs in languages like C is to use Hoare logic together with an automated verification condition generator. Additionally, for pointer programs, we would like to use separation logic <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b24">25]</ref>, which promises to be an efficient and scalable method. However, existing implementations of separation logic <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b17">18]</ref> use simplifications that while convenient are not directly suitable for C. For instance, they model the heap as a function from integers to integers, or treat values on the heap as atomic.</p><p>In contrast, we model the values and heap of the C programming language in the theorem prover precisely. For overflow problems we use the correct mathematical structure (e.g. finite integers). For pointers, correct models are more complex. C's view of memory is that of an array of bytes coupled with various access restrictions. Further, pointers have to be aligned, dereferencing the null pointer is undefined, etc.</p><p>Using such a model directly is intractable for verifying real programs. Our contribution is to reconcile this model with convenient, abstract notation and reasoning. Our framework supports both, normal Hoare logic and a sound separation logic, by instantiating Schirmer's Hoare logic environment <ref type="bibr" target="#b26">[27]</ref>. Schirmer provides a generic imperative language with operational semantics, Hoare logic, and generic state in Isabelle/HOL. We instantiate this to C on the one side, and provide optional separation logic notation for assertions on the other side. At the heart of our work stands the observation that although languages like C are not type-safe, and although many programs do not always use pointers in a type-safe way, the majority of pointer operations in any given program are well-behaved and can be treated in the abstract text-book way.</p><p>In previous work <ref type="bibr" target="#b27">[28]</ref>, we showed that the low-level view of the heap as an array of bytes can be soundly unified with a view of multiple abstract heaps of abstract values. We provided an implementation of this unified memory model in Isabelle/HOL and applied it to the verification of page tables in the L4 microkernel. In this paper, we extend this work by making it more concrete and more firmly grounded in reality on the one side, and more abstract and better suited for high-level verification on the other side:</p><p>• We harden our implementation so that it accurately reflects the real semantics of a significant, strict subset of the C programming language. C programs as accepted by standard C compilers can be read directly into the theorem prover. We also show how to add a number of low-level semantic restrictions like pointer alignment and automatic NULL-dereference guards without incurring undue verification overhead. • We extend and generalise the memory model to support separation logic constructs, and we implement a shallow embedding of separation logic with the frame rule on top of this model in Isabelle/HOL. This constitutes the first sound implementation of separation logic for a mainstream programming language. • We show two case studies in this setting: a simple list reversal, and a full formal verification of the L4 kernel memory allocator. We use the list reversal example to demonstrate the model and to show that easy programs remain easy to verify. The memory allocator study shows the applicability of the model and verification of real, security critical programs. It also gives an example of a program that cannot be verified formally in the traditional setting without losing soundness. • Finally, we use the two case studies to evaluate separation logic against traditional Hoare logic. To our knowledge this is the first such evaluation of separation logic in one unified setting.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> shows the process of verifying a C program in our setting. The user (the program verifier) provides a normal C program that contains invariant and pre/post annotations in comments. Optionally, the user may also provide an Isabelle/HOL specification with definitions used in these annotations. Building on our model of memory, separation logic, and the semantics of C, the pro-gram is then translated into an imperative program in Isabelle/HOL. Schirmer's VCG generates the proof obligations. Proving these is where most of the user-work happens and the process will usually result in changes to the annotations and/or program until a proof is found. The soundness of this setup depends on translating C programs correctly to their Isabelle counterparts, on the correctness of the memory model (both of which we present here), and on the VCG (which Schirmer has proved sound in Isabelle <ref type="bibr" target="#b26">[27]</ref>).</p><p>Our work is motivated by a project to formally verify the functional correctness of the L4 microkernel <ref type="bibr" target="#b16">[17]</ref>. While we concentrate on operating-system-level code and Isabelle/HOL in our case studies and implementation, we believe that this work is widely applicable. The basic technique generalises to other low-level languages and is orthogonal to developing an operational semantics for the statements of the language. We concentrate on a precise model of state, values, and memory. The implementation in the theorem prover uses features specific to Isabelle (e.g. type classes) to optimise proof productivity, but the model should be implementable in different provers like PVS using slightly different mechanisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Notation</head><p>Our meta-language Isabelle/HOL conforms largely to everyday mathematical notation. This section introduces further non-standard notation and in particular a few basic data types along with their primitive operations.</p><p>The space of total functions is denoted by ⇒. Type variables are written a, b, etc. The notation t :: τ means that HOL term t has HOL type τ . The option type datatype a option = None | Some a adjoins a new element None to a type a. We use a option to model partial functions, writing a instead of Some a and a b instead of a ⇒ b option. The Some constructor has an underspecified inverse called the, satisfying the x = x. Function update is written f (x := y) where f :: a ⇒ b, x :: a and y :: b and f (x → y) stands for f (x := Some y). We use { →} for updating whole sets. Domain restriction is f A where f :: a b and</p><formula xml:id="formula_0">(f A ) x = (if x ∈ A then f x else None).</formula><p>Finite integers are represented by the type a word where a determines the word length. For succinctness, we use abbreviations like word8 and word32. The functions unat and of-nat convert to and from natural numbers (with u for unsigned). The notation {w..+n} stands for the interval starting at the word w with n::nat elements, possibly wrapping around to zero.</p><p>Hoare triples are written {|P| } c {|Q| } where P and Q are assertions and c a program. In assertions, we use the syntax ´x to refer to the program variable x in the current state, while σ x means x in state σ. Program states can be bound in assertions by {|σ. P| }.</p><p>Isabelle supports axiomatic type classes <ref type="bibr" target="#b31">[32]</ref> similar to, but more restrictive than Haskell's. The notation a::ring restricts the type variable a to those types that support the axioms of class ring. Type classes can be reasoned about abstractly, with recourse just to the defining axioms. Further, a type τ can be shown to belong to a type class given a proof that the class's axioms hold in τ . All abstract consequences of the class's axioms then follow for τ .</p><p>Isabelle theories can be augmented with L A T E X text which may contain references to Isabelle theorems (by name-see chapter 4 of <ref type="bibr" target="#b22">[23]</ref>). We use this presentation mechanism to generate the text for most of the definitions and all of the theorems in this paper, taking them directly from the Isabelle proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Translation of C</head><p>In our domain, C programs are happy to exploit C's low-level features. We cannot pretend that we are verifying a pseudo-Pascal</p><formula xml:id="formula_1">int i = 0, a[2] = {0,0}; int f(void) { i++; return i; } /* will return either 0 or 1 */ int main(void) { a[i] = f(); return a[0]; } Figure 2. A non-deterministic C program</formula><p>with integer values of infinite range. In this section, we briefly describe the C dialect that we require, and how our translation of this dialect handles many of C's low-level complications. A number of memory specific details are further discussed in Sect. <ref type="bibr" target="#b3">4</ref>.</p><p>Syntactically, our C dialect is a C subset. We must be able to pass implemented C source code to standard compilers (on whose correctness we implicitly rely), but we do also impose some syntactic restrictions on developers. For example, we make some simplifications that have no deep semantic impact, such as requiring all struct declarations to occur at the top-level of a translation unit. Rather more significantly, we prohibit side effects in almost all expressions. Assignments become statement-forms, and functions that return values may be called only as the right-hand side of an assignment.</p><p>Semantically, we make a number of assumptions about the nature of the environment in which our C code will be executing. These move the C we are verifying away from the standard's ideal of strict conformance. When writing applications, such assumptions are often a sign of programmer laziness, and a harbinger of pain when code is ported. At the systems level, these assumptions are unavoidable. We categorise them using the standard's terms for describing varying (and illegal) program behaviours: implementation-defined, unspecified, and undefined.</p><p>Implementation-defined behaviours are the easiest to treat. These behaviours are those on which the standard places broad restrictions, but where it also requires that the implementation make a particular (and documented) choice of behaviour.</p><p>For example, an implementation must choose the size of its character type (typically 8 bits), the size of other integral types in terms of bytes (int values are now typically four bytes), the endianness of integral types, how negative numbers are represented (typically two's-complement), and how integer division behaves with negative arguments. Most of the time, compilers choose to reflect the decisions made by the underlying hardware architecture. As we know the nature of the architecture for which we are developing our code, we add these decisions as extra assumptions to the verification process. This does mean that the same sourcecode does need to be verified anew for each underlying architecture where it is to be deployed. Depending on the program this could amount to merely re-running the proof.</p><p>Unspecified behaviours occur when the standard permits an implementation to vary its behaviour, but does not require any documentation of this variation. Indeed, an implementation is not required to make a particular choice consistently. This allows optimisation to drive the choice of behaviour. The most significant place where behaviour is unspecified is in order of evaluation, of arguments to assignments, of arguments of binary operators such as + and /, and of arguments to function calls.</p><p>Most C expressions that appear to induce different behaviours because of this under-specification are actually examples of undefined or illegal behaviour. This is because of the strong restrictions on the way in which programs are allowed to read and write memory. Nonetheless, it is possible to write legal, non-deterministic C programs. One such appears in Fig. <ref type="figure">2</ref>.</p><p>By making all expressions side-effect free, and making assignments and function calls statement forms, we eliminate a whole class of undefined behaviours. By further requiring that functions may only be called in contexts where their return value is ignored, or where it is assigned to a single variable (which restriction the program in Fig. <ref type="figure">2</ref> violates), we ensure that all code must have only one possible behaviour, unless we choose to work from deliberate underspecifications, as might happen with an implementation of malloc. <ref type="foot" target="#foot_0">1</ref>For other unspecified behaviours, such as the values of possible padding bits in integer representations, our knowledge of the underlying architecture means we know how the machine will behave, and our verification can exploit this.</p><p>Undefined behaviours occur when a program attempts to do something illegal, such as dereferencing a null pointer, or doing an integer division by zero. It is part of the devil's pact that programmers make when they program in C that implementations are not required to trap such events. Instead, implementations are free to do anything at all, and again, there is no requirement that their undefined behaviours be documented. This feature of C makes testing difficult, but when verification is performed we can explicitly make sure that undefined behaviours can not occur.</p><p>One approach to this verification task is to use explicit guards. Guards are extra program annotations, similar to assertions users can provide with the standard assert function. In order to be verified with respect to any specification, a program must have all of its guards shown to hold when they are encountered. For every possible undefined behaviour, we generate guards that are sufficient to ensure that the undefined behaviour cannot occur. If done manually, this process of annotating programs with guards might lead to guards being omitted, but by generating guards mechanically we can ensure that all those we wish to treat are indeed generated.</p><p>Guards that we include prevent division by zero, dereferencing the null pointer, and dereferencing an improperly aligned pointer. One further guard is the test that all memory-writes are to allocated memory. We use this guard to show a form of memory safety in Sect. 5.3 as a proof convenience but it may be omitted from the semantics when considering systems code at the verifier's discretion. A stricter semantics for application verification would require such a guard always. This flexibility in choosing our code's environment is another reason in favour of the guards-based approach: it is straightforward to enable different sorts of guards depending on circumstances. For example, in some kernel verifications, dereferencing the null pointer might be a valid way of accessing the first element of the machine's exception vector. If this was the case, the null pointer guard would need to be disabled. In this way, we can give definition to a variety of behaviours that the standard leaves undefined. Our systems code will not be strictly conforming, but indeed this line was crossed when our code relied on implementationdefined aspects of the programming environment.</p><p>Finally, generating guards is straightforward: as expressions are translated into the verification environment, forms that may cause difficulties are recorded. When the translation of the enclosing statement has finished, it can be preceded by the appropriate checks on the given expressions. Because of our syntactic restrictions preventing side effects, the repeated evaluation (as guard, and in the original expression) of these sub-expressions is sure to be safe.</p><p>Our aim is to make verification part of the engineering process. Crucially, the engineering process does not produce source code in one phase and then stop, with verification taking over from implementation. Rather, implementation continues at the same time. In order to tie verification effort to the source code that is verified, we annotate source code with Isabelle invariants and specifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A Unified Memory Model for Pointers</head><p>When verifying C programs that may break many of the commonly employed abstractions described in the introduction we face a dilemma. Since convenient simplifications must be discarded we require detailed and cumbersome low-level models. This may increase the difficulty of the verification task, in particular when using an interactive theorem prover, where this detail is exposed to the program verifier. We take soundness to be non-negotiable, yet some abstraction is also required for tractability.</p><p>In this and the next section we focus on resolving this difficulty for the C memory model. We describe both a low-level semantic model based on finite byte-addressable memory and connections to two high-level proof abstractions-multiple typed heaps and separation logic. The latter can safely be used when programs remain inside a type-safe fragment. Since most code remains in this fragment in practice, even in the systems domain, we gain soundness while alleviating the additional burden on the program verifier in the common case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Semantic model</head><p>It is common in language semantics to treat the heap or memory as a partial function int lang-val, where int is the type of addresses and lang-val the type of all language values. While greatly simplifying the formalisation, this makes several assumptions that are not valid in our setting:</p><p>• Addresses range over an infinite integer type. In C addresses are constrained by a finite addressable memory, which affects the semantics of pointer arithmetic and memory allocation, e.g. *(x+1) = y may in fact be a null pointer dereference. • Values representations are atomic. C language types have representations spanning multiple locations, and it is possible to have value updates at one location affect values in other cells. This calls for a semantic model that both captures values' storage sizes, and reflects these update semantics accurately. E.g. *x = 0xdeadbeef affects not only the byte at location x, but also the bytes at locations x + 1, x + 2, and x + 3. An additional complication is alignment: per-type restrictions on address validity. For example, 16-bit short values may be forced to be stored at even addresses. Expressing alignment conditions in dereferencing and update semantics requires having a constant byte granularity for addressing. • Heap partiality. Heap partiality is often used in the heap dereferencing semantics in memory or type-safety checks. Much weaker variants of these properties hold for C programs and it is not always necessary to introduce them in the dereference semantics. This is particularly important in making it possible to verify low-level code that manages details such as the layout of its own address space or implements the functionality of malloc.</p><p>Earlier work <ref type="bibr" target="#b27">[28]</ref> solved a similar problem, where the aim was to reconcile the low-level C memory model and the abstraction of multiple typed heaps. We present that semantic model here, together with a significant extension of the heap abstraction. In particular, we remove the well-formedness invariant previously required, add general support for guards that protect against undefined behaviours, and in Sect. 5 employ it as the basis of a separation logic embedding.</p><p>In our model, heap memory state is described as a total function from addresses, represented by a wordn type corresponding to the machine address type, to bytes, also a wordn type. Arithmetic operations on wordn values are modulo 2 n . For example, on a machine with 32-bit addresses and 8-bit bytes the heap memory state will be:</p><formula xml:id="formula_2">addr = word32 byte = word8 heap-mem = addr ⇒ byte</formula><p>Each language type is assigned a unique type in the theorem prover's logic. This allows for both an intuitive definition of language operators as functions in HOL, and the harnessing of the theorem prover's type inferencing mechanism to avoid unnecessary type annotations in assertions and proofs. All such types belong to an axiomatic type class a::c-type in Isabelle, which introduces constants that connect the low-level byte representation and the HOL values:</p><p>to-bytes :: a::c-type ⇒ byte list from-bytes :: byte list a::c-type typ-tag :: a::c-type itself ⇒ typ-tag typ-info :: a::c-type itself ⇒ typ-info</p><p>The functions to-bytes and from-bytes convert between Isabelle values and lists of bytes suitable for writing to or reading from the raw heap state. The function typ-tag associates a unique type tag with each a::c-type, providing a means of treating language types as first-class values in HOL. Finally, typ-info provides enough structure to allow size and alignment information for the type to be calculated. We can then use this to define functions size-of :: a::c-type itself ⇒ nat and align-of :: a::c-type itself ⇒ nat respectively.</p><p>The following conditions, captured in the axiomatic type class a::mem-type, must hold for any a::c-type we want to use in our heap abstraction below: These conditions follow mostly from requirements in the C standard, e.g. fixed size representations, with the exception of the final alignment constraint which we add to make pointer arithmetic better behaved, and which holds on all the C implementations we are aware of. The constant addr-card represents the size of the address space, e.g. 2 32 .</p><p>Finally, we introduce a distinct Isabelle pointer type for each Isabelle type, used to model C pointer types:</p><formula xml:id="formula_3">datatype a ptr = Ptr addr</formula><p>The additional a on the left-hand side can now be used to associate the pointer type information with pointer values in Isabelle's type system. Since the type variable does not appear on the right-hand side it is a phantom type. Nonetheless, the type information is used to constrain the action of various pointer operators by making use of the type information associated with a. The destructor ptr-val retrieves the address from a pointer value. The pointer types a::c-type ptr can be shown to be to be instances of a::mem-type. An example of the use of the phantom type variable comes in the definition of pointer addition, adding a word n to a pointer p:: a ptr:</p><formula xml:id="formula_4">p +p n = Ptr (ptr-val p + n * of-nat (size-of TYPE( a)))</formula><p>Another example of the utility of such polymorphic definitions is the pointer alignment guard from Sect. 3: In this work we deal primarily with C's base and pointer types but it is possible to extend this to compound types. Array indexing, access, and update semantics can be expressed in terms of the corresponding pointer semantics. C's struct types can be translated to Isabelle record types, however the models in this paper require extending when fields have their address taken 2 or padding is involved. Similarly, union types can be treated as datatypes when a tag field can be identified, and otherwise translated to type-casts.</p><p>Low-level heap access and update Heap dereferences in expressions, e.g. * p + 1 are given a semantics by first lifting the raw heap state with the polymorphic lift function, e.g. lift s p + 1 where s is the current state. The definition of lift is presented below, together with that of heap-update, providing semantics for heap updates. For example, * p = * q + 5 is translated to the state transformer λs. heap-update p (lift s q + 5) s. Fig. <ref type="figure" target="#fig_2">3</ref> illustrates the value transformations involved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>heap-list</head><formula xml:id="formula_5">:: heap-mem ⇒ nat ⇒ addr ⇒ byte list heap-list h 0 p = [] heap-list h (Suc n) p = h p•heap-list h n (p + 1) h-val :: heap-mem ⇒ a::c-type ptr a h-val h p ≡ from-bytes (heap-list h (size-of TYPE( a)) (ptr-val p)) lift :: heap-mem ⇒ a::c-type ptr ⇒ a lift h ≡ λp. the (h-val h p) heap-update-list p [] h = h heap-update-list p (x•xs) h = heap-update-list (p + 1) xs (h(p := x)) heap-update p v h ≡ heap-update-list (ptr-val p) (to-bytes v) h</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Typed heaps</head><p>While it is possible to do proofs about programs directly with this semantics, it is rather complicated to do so. Problems quickly arise when the potential for overlapping value representations on the heap and aliasing between lifted typed heaps complicate heap update post-conditions. This is an example of the aliasing <ref type="bibr" target="#b7">[8]</ref> problem inherent in pointer program proofs being further compounded by the low-level semantic model utilised. We call this representation overlap problem inter-type aliasing for the purpose of this paper; see Fig. <ref type="figure" target="#fig_3">4</ref> for an example of this. In this section we present an abstraction from our semantic model, together with appropriate 2 We also have not required supporting the &amp; operator for local variables yet. These could be modelled explicitly in the heap-mem. In this type-safe fragment, a convenient model for a type-safe language would be based on explicit multiple typed heaps, one for each language type, e.g. addr char, addr short. While this avoids the problem of inter-type aliasing and greatly simplifies proofs, it does not allow us to escape the type-safe world. The lift function provides a view of multiple typed heaps, but values in a lifted a heap change when the heap is updated through a b ptr.</p><p>However, inside the type-safe fragment, there is an implicit mapping between memory locations and types, and heap dereferences respect this mapping. We introduce this mapping as an additional state component, and refer to it as the heap type description.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>heap-typ-desc = addr typ-tag option</head><p>The heap type description is a history variable, and as such does not affect the semantics of our programs. Since in C this mapping cannot be extracted from the source code, the program verifier adds proof annotations that update the heap type description. The overhead of these annotations is very low relative to the proof effort because the intended type for a region of memory changes infrequently-mainly for alloc and free.</p><p>The heap type description is partial, since it only maps memory actually used by the program. Each value representation has the typ-tag corresponding to its type stored at the base address. The rest of the heap footprint of the value is also mapped, but with a None value padding instead of a tag, making heap validity, as defined below, monotonic, a useful property in the development of the separation logic embedding. Without padding we would also have the additional requirement of a well-formedness invariant <ref type="bibr" target="#b27">[28]</ref> on the heap type description.</p><p>We write d,g |=t p to mean that the pointer p is valid in heap type description d with guard g. The definition is straightforward:</p><formula xml:id="formula_6">valid-footprint d x t n ≡ d x = t ∧ (∀ y. y ∈ {x + 1..+n -1} -→ d y = None ) d,g |=t p ≡ valid-footprint d (ptr-val p) (typ-tag TYPE( a)) (size-of TYPE( a)) ∧ g p</formula><p>The guard g strengthens the assertion to restrict validity based on the language's pointer dereferencing rules. For example, alignment Heap type description update annotations are written in C comments. The syntax AUXUPD takes a guard and a heap type description state transformer as a parameter. E.g. to indicate that the location at p now is the value of a valid pointer of type addr ptr, we write / * * AUXUPD: (g, ptr-tag (´p::addr ptr)) * /.</p><p>The following two-stage lifting process provides an abstract heap view for proofs:</p><p>1  Note that it is not sufficient to just restrict the domain to addresses possessing the alignment of the lifted heap's type in order to avoid overlapping value representations, since the alignment of a type can be smaller than its footprint size: in our semantics the relationship between alignment and size is given by align-of t dvd size-of t. The two stages, shown in Fig. <ref type="figure" target="#fig_6">6</ref>, are combined with liftτ :</p><formula xml:id="formula_7">liftτ g ≡ lift-typ-heap g • lift-state</formula><p>Like lift, liftτ is polymorphic and returns a heap abstraction of type a typ-heap = a ptr a. The program text itself can continue to use the functions lift and heap-update, while pre/post conditions and invariants use the stronger liftτ to make more precise statements. The following conditional rewrite connects the two levels:</p><formula xml:id="formula_8">liftτ g (h, d) p = v =⇒ lift h p = v</formula><p>We have proved two further significant rewrite rules that support reasoning about the effects of heap updates on liftτ . The first rule states how an a ptr update affects an a typ-heap, the second rule shows that an a ptr update does not affect a b typ-heap if a is different from b:</p><formula xml:id="formula_9">d,g |=t p =⇒ liftτ g (heap-update p v h, d) = liftτ g (h, d)(p → v) [[d,g |=t p; typ-tag TYPE( a) = typ-tag TYPE( b)]] =⇒ liftτ g (heap-update p v h, d) = liftτ g (h, d)</formula><p>These, added to the default simplification set with other heaprelated lemmas, do not require manual application. The typ-tag TYPE( a) = typ-tag TYPE( b) condition can be resolved automatically, as long as the type tag definitions for language types are also in the simplification set.</p><p>For any program that respects the heap type description, we can thus automatically simplify away the fact that the heap is shared and pretend to work on multiple typed heaps. At the same time, we can still capture the semantics of type-unsafe operations. In the unsafe case, things are no longer automatic, and we require new rules to be proven in terms of the underlying lift and heap-update, as was previously required anyway.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Separation Logic</head><p>The previous section presents a proof technique that tames intertype aliasing. However, the problem of intra-type aliasing remains, where two valid same-typed pointers may have identical values. Dealing with this often requires explicit anti-aliasing invariants on typed heaps, a problem that has been recognised in the literature <ref type="bibr" target="#b7">[8]</ref>. Separation logic <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b24">25]</ref> provides an approach in which anti-aliasing information may be expressed implicitly in assertions, potentially simplifying specifications and proofs. In this section we present a development of separation logic based on the preceding memory model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Shallow embedding</head><p>Below we describe a shallow embedding for separation assertions, where the semantic constructs of assertions are translated to HOL, as opposed to a deep embedding where the syntax of assertions would be considered a distinct type in the logic. There is a tradeoff involved in the choice of embedding approach-shallow embeddings are often more pragmatic and expressive, while deep embeddings allow for language metatheory reasoning and proof optimisations <ref type="bibr" target="#b32">[33]</ref>. We opt for the former since our focus here is on the verification task.</p><p>We model separation assertions as predicates on heap-states, applied in assertions of the verification environment to the result of the first lifting stage of Sect. 4.2. For example, a loop invariant with the separation assertion P and heap memory and type description state in the variables h and d respectively is written {| P (lift-state (´h,´d)) | }, which we abbreviate as {|P sep | }.</p><p>As in the development of Reynolds we have an empty heap predicate:</p><formula xml:id="formula_10">= (λs. s = empty)</formula><p>The definition of the singleton heap assertion is more involved in our embedding, and is provided below. p →g v asserts that the heap contains exactly one mapping matching the guard g, at the location given by pointer p to value v.</p><formula xml:id="formula_11">p →g v = λs. lift-typ-heap g s p = v ∧ dom s = {ptr-val p..+size-of TYPE( a)}</formula><p>The guard is an addition to the usual p → v and serves the same purpose as in Sect. 4.2, i.e. strengthening the assertion to aid in discharging guard proof obligations. There are two significant separation connectives, conjunction and implication:</p><formula xml:id="formula_12">s 0 ⊥ s 1 = dom s 0 ∩ dom s 1 = ∅ s 0 ++ s 1 = λx. case s 1 x of None ⇒ s 0 x | y ⇒ y P ∧ * Q = λs. ∃ s 0 s 1 . s 0 ⊥ s 1 ∧ s = s 1 ++ s 0 ∧ P s 0 ∧ Q s 1 P -→ * Q = λs. ∀ s . s ⊥ s ∧ P s -→ Q (s ++ s )</formula><p>The definitions are standard, with the intuition behind separation conjunction that (P ∧ * Q) s asserts that s can be partitioned into two subheaps such that P holds on one subheap and Q on the other. This allows for predicates on the heap to be written that conveniently include anti-aliasing information.</p><p>Some additional mapping assertions are useful:</p><formula xml:id="formula_13">sep-true = λs. True p →g -= λs. ∃ v. (p →g v) s p →g v = p →g v ∧ * sep-true p →g -= λs. ∃ x. (p →g x) s</formula><p>The standard commutative, associative, and distributive properties apply to the connectives, and we have formalised pure, intuitionistic, domain, and strictly exact assertions and their properties <ref type="bibr" target="#b24">[25]</ref>. We require a stronger definition of the singleton heap assertion for it to be strictly exact. Some of these properties are routinely used in proofs and have been grouped in simplification sets and/or added to the default simplification set. Since this is a shallow embedding, standard HOL connectives and quantifiers can be freely mixed with the separation connectives, e.g. λs. P s ∧ (Q ∧ * R) s.</p><p>A key feature of this embedding is that it avoids the problem of skewed sharing <ref type="bibr" target="#b24">[25]</ref>. This is essentially the problem of intertype aliasing in separation logic. An approach like ours, where a history variable is introduced, was suggested as a future direction for separation logic by Reynolds. We have developed this, have a machine-checked formalisation and have deployed it in real-world verification examples (see Sect. 6).</p><p>Another notable gain from our development is the harnessing of Isabelle's type inference to avoid explicit type annotations in assertions. Since language types are assigned Isabelle types and pointer types are derived from these, asserting that p → v, where p is a program variable automatically constrains the type of v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Lifting proof obligations</head><p>Our verification condition generator applies weakest precondition rules to transform Hoare triples to HOL goals that can then be solved by applying theorem prover tactics. In Sect. 4.2, rewrites were given that could automatically lift the raw heap component of these proof obligations, and in this section we provide rules that allow the low-level applications of lift and heap-update to be expressed in terms of separation assertions. This is desirable as reasoning can then use the derived rules for these assertions at the separation logic level, whereas the alternative of unfolding the definitions produces a massively more complex goal and proof.</p><p>The approach taken here is quite different to the usual separation Hoare logic proof technique employed in the literature, where a new Hoare logic is developed based on separation logic and individual rules are applied at the Hoare logic level. The advantage of our approach is two-fold: we avoid having to manually apply Hoare rules, a task easily automated, and can take advantage of an existing verification framework and condition generator. On the other hand, applying the rules in this section requires the program verifier to understand the relationship between components of the HOL goals and the original program since this structure is lost during verification condition generation.</p><p>The following rule connects lift and separation mapping assertions:</p><formula xml:id="formula_14">(p →g v) (lift-state (h, d)) lift h p = v</formula><p>An example of how this may be used is the Hoare triple</p><formula xml:id="formula_15">{|(p → x ∧ * Q) sep | } a = * p + * p {|a = 2 * x| }.</formula><p>The resulting proof obligation</p><formula xml:id="formula_16">(p → x ∧ * Q) (lift-state (h, d)) =⇒ 2 * lift h p = 2 * x</formula><p>requires the value of x in terms of lift h p or vice versa. By deriving from the assumption of the goal that (p → x) (lift-state (h, d)) using normal rules of separation logic, the above rule can be applied to solve the goal. Heap update dereferences produce proof goals of the form</p><formula xml:id="formula_17">P (lift-state (h, d)) =⇒ Q (lift-state (heap-update p 0 v 0 (heap-update p 1 v 1 (heap-update p••• v••• (heap-update pn vn h))),d))</formula><p>To reduce heap-updates to a separation assertion on the original state we first require a new separation predicate g s p:</p><formula xml:id="formula_18">g s p ≡ λs. s,g |=s p ∧ dom s = {ptr-val p..+size-of TYPE( a)}</formula><p>This is related to the idea of the singleton heap predicate p →g -, but the implication only works in one direction, (p →g v) s =⇒ (g s p) s, since it is possible to have both liftτ g s p = None and a valid footprint at p.</p><p>The following rules allow for the reduction of heap-updates:</p><formula xml:id="formula_19">(g s p ∧ * (p →g v -→ * P)) (lift-state (h, d)) P (lift-state (heap-update p v h, d)) (g s p ∧ * P) (lift-state (h, d)) (p →g v ∧ * P) (lift-state (heap-update p v h, d))</formula><p>These rules are analogous to the backwards and global reasoning Hoare logic mutation rules <ref type="bibr" target="#b24">[25]</ref>. The first rule provides a weakest precondition style rule that will match any separation assertion, while the second rule may be used on goal assertions that can be manipulated into the matching form.</p><p>When the heap type description is modified with ptr-tag the resulting goal needs to be reduced in a similar manner. We provide a rule for this that establishes separation validity from sep-cut, another additional separation predicate. sep-cut simply asserts that the locations in the heap-state domain are the supplied interval. The shallow embedding gives us the flexibility to add separation predicates that express information about a region of memory at different levels of abstraction, from p →g v to sep-cut. Once the above reduction rules are applied the reasoning can continue using the standard rules of separation logic without requiring additional proof goals or side-conditions.</p><p>In deriving these rules we have primarily been concerned with soundness, which we are forced to show prior to Isabelle admitting the rules. Our focus on real-world verification examples has caused us to pay rather less attention to the completeness of our system, particularly as we know that we can always drop down to the lower more concrete levels if required. However, completeness results have been explored elsewhere in the literature <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Frame rule</head><p>The separation frame rule <ref type="bibr" target="#b33">[34]</ref> is often seen as important to scalability. It allows for deriving a global specification from a local specification of a program's behaviour, with an arbitrary conjoined separation assertion on a part of the heap preserved by the program. In our this rule would have the form:</p><formula xml:id="formula_20">{|P sep | } c {|Q sep | } {|(P ∧ * R) sep | } c {|(Q ∧ * R) sep | }</formula><p>Unfortunately, such a general rule cannot be expressed in a shallow embedding since (i) the state-space type is program dependent and (ii) c is an arbitrary program in the underlying verification framework for which this rule may not be true. It is however possible to prove this rule for specific programs and state-spaces, and in our development of the frame rule we automate and make generic this process for our C subset.</p><p>We make further use of type classes to define a::heap-state-typ, which provides access and update functions for the heap state and heap type description. A concrete program's state-space is instantiated as a member of this type class using automatic Isabelle/HOL tactics. The frame rule can then be expressed on programs c with a state-space in a::heap-state-typ as:</p><formula xml:id="formula_21">{|P sep | } c {|Q sep | } mem-safe c {|(P ∧ * R) sep | } c {|(Q ∧ * R) sep | }</formula><p>The mem-safe c assumption is required as the second problem arises from the dependence of this rule on a form of memory safety. In order to prove soundness it is helpful that a program generates a guard failure if it either (i) modifies the heap state or heap type description outside of the initial domain of the heap type description or (ii) depends on the heap type description outside this domain in any expression. This is not the case for the normal output of the C translation stage, since guards are only generated to prevent undefined behaviour as our C semantics understands it.</p><p>To show mem-safe c we insert additional guards for memory safety, e.g. for a heap update dereference asserting that the lvalue's heap footprint is contained entirely in the heap type description's word_t reverse(word_t *i) { word_t j = 0; while (i) { word_t *k = (word_t*)*i; *i = j; j = (word_t)i; i = k; } return j; } Figure <ref type="figure">7</ref>. In-place list reversal domain. It should be noted that we do not require type safety, nor do we require this form of memory safety for most expressions as only heap type description updates may depend on the heap type description, i.e. the output of the C translation stage does not feature heap type description accesses except in such updates.</p><p>With the generated guards in place, Isabelle discharges the mem-safe c proof obligation automatically. The additional memory safety proof obligations obtained from the verification condition generator can be discharged with the aid of of a strengthened precondition asserting that the required locations are a subset of the heap type description's domain.</p><p>The above presentation of the frame rule is somewhat simplified in that P, Q and R are not functions of the local variable state. We have also derived the more general rule where they are and R does not depend on variables modified by c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Case Studies</head><p>This section presents two case studies that demonstrate the support of abstract and low-level reasoning in our setting. Since we have formalised both classical Burstall/Bornat-style pointer reasoning and separation logic in the same framework, we can give a meaningful comparison of their applicability. While our results support the folklore view that separation logic is well suited for specification, but less convenient for verification, we find that the difference becomes smaller for the larger, more realistic case study. Since proofs can be checked, but specifications need to be understood, this advocates the use of separation logic for more complex verification tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">List reversal</head><p>This subsection shows a small example program-in-place reversal of a list-with simple, abstract reasoning. The list is somewhat unusual in that it has no content but the pointer values themselves. Lists like these are used in OS code for instance, where they are loosely part of larger data structures. Mehta and Nipkow <ref type="bibr" target="#b18">[19]</ref> use the same example in their more abstract setting. We achieve the same style of reasoning and specification with almost the same degree of automation. Fig. <ref type="figure">7</ref> shows the code (where word t is unsigned int). Even though the program is very simple, it already makes use of unsafe pointer operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Classical setting</head><p>The pre/post specification of this program in a classical setting (without separation logic) is:</p><formula xml:id="formula_22">∀ zs. {|list (liftτ H) zs ´i| } ´reverse-ret :== PROC reverse(´i) {|list (liftτ H) (rev zs) (Ptr ´reverse-ret)| }</formula><p>The idiom ´reverse-ret :== PROC reverse(´i) is the standard form for procedure specification in Schirmer's environment. The variable reverse-ret is automatically generated and makes the return value of function reverse available to the postcondition. We write H = (´h, ´d) for the heap and type description in the current state.</p><p>The predicate list relates the heap pointer structure to abstract lists. It takes a heap of word32 values, a list of word32 values, and the start pointer of the list as arguments. Our definition is analogous to the one in Mehta and Nipkow <ref type="bibr" target="#b18">[19]</ref> (we additionally deal with heap partiality):</p><formula xml:id="formula_23">list h [] i = i = NULL list h (x•xs) i = ∃ j. ptr-val i = x ∧ x = 0 ∧ h i = j ∧ list h xs (Ptr j)</formula><p>The loop invariant again is almost the same as in Mehta and Nipkow. We use distinct to say that the list zs does not contain duplicate addresses and rev to reverse the abstract HOL list:</p><formula xml:id="formula_24">{|∃ xs ys. list (liftτ H) xs ´i ∧ list (liftτ H) ys (Ptr ´j) ∧ rev zs = rev xs @ ys ∧ distinct (rev zs)| }</formula><p>As mentioned above, the proof of the 3 verification conditions generated for this program is almost completely automatic (5 lines of proof script). However, this has to be viewed in the context of a careful setup of automated simplification rules for the abstraction predicate list that again we share with Mehta and Nipkow. It consists of 13 lemmas, 12 of which are proven automatically. All low-level guards were discharged automatically as well; they did not play any role in the verification of this example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Separation logic</head><p>The specification of the same program in separation logic is similar on the pre/post level, but the abstraction predicate is defined differently.</p><formula xml:id="formula_25">∀ zs. {|(list zs ´i) sep | } ´reverse-ret :== PROC reverse(´i) {|(list (rev zs) (Ptr ´reverse-ret)) sep | } list [] i = λs. i = NULL ∧ s list (x•xs) i = λs. i = Ptr x ∧ x = 0 ∧ (∃ j. (i → j ∧ * list xs (Ptr j)) s)</formula><p>The invariant is a bit shorter, because the separating conjunction takes care of distinctness:</p><formula xml:id="formula_26">{|∃ xs ys. (list xs ´i ∧ * list ys (Ptr ´j)) sep ∧ rev zs = rev xs @ ys| }</formula><p>The proof remains easy, but is not automatic any more and requires some manual application of rules for separating conjunction. This is not surprising, since separating conjunction is an existential statement which usually leads to manual intervention. The proof of the 3 verification conditions comes to a total of 32 lines, which we might be able to improve with specialised tactics for separation logic connectives. For example, one of the low-level guards was not solved automatically, because the required precondition was under a separating conjunction and had to be extracted manually. After this, the proof was automatic.</p><p>In the separation logic case, there was no specific automation setup for the list data structure apart from the lemma list xs NULL = (λs. xs = [] ∧ s) which brings the total proof effort for this example to 62 lines, as opposed to 89 lines in the classical setting. Most of these 89 lines could be reused for programs on the same data structure, though, which is not the case for the separation logic proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">The L4 kernel memory allocator</head><p>The case study presented in this section concerns the verification of the kernel memory allocator of the L4 microkernel with and without separation logic in Isabelle/HOL. At the OS kernel level, C library functions like malloc and free are not available yet, but have to be provided internally. Since this code is run in the  void free(void *address, word t size), and void *alloc(word t size). We have verified alloc and free, but only have space to show alloc; init consists of a call to free. The full proof document for this case, including code and invariants is available online <ref type="bibr" target="#b28">[29]</ref>. The functions are not very large, but the fact that the originals contain more than 50% tracing and debugging code indicates that they were not easy to get right. We did not find any clear bugs in the code during verification which is encouraging for a system with several years of deployment. We did find two preconditions to free that are not immediately obvious: the address must be word-aligned (because it is used as a word pointer), and the sum of the address and the size must not overflow. If free is only used with values produced by alloc, and init is used with values as in L4, these conditions will hold.</p><p>Currently, L4 is distributed in C++, although no essential use of C++ features is made apart from using classes to structure the code. For a number of reasons (not only verification), we are porting L4 to C. The source code that is verified is taken from the L4Ka::Pistachio distribution, ported, configured for the x86 architecture, and preprocessed. The manual porting is not soundness critical as it is the result of the translation that will eventually run together with the rest of the C port, neither is the configure nor preprocessing part. If they are merely deterministic, we verify exactly what the compiler sees as input.</p><p>Fig. <ref type="figure" target="#fig_9">8</ref> shows the internal data structure that is used to manage memory. It is a NULL terminated, singly linked list of chunks of memory of a fixed size KMC (1024 bytes in this case) starting with the global variable word t *kfree list. The first 4 bytes of each free memory block are used to point to the next one. The blocks are often, but not always, adjacent in memory.</p><p>The implementation of alloc first searches for a contiguous block of memory of the right size that is correctly aligned. It then removes this block from the free list, zeroes out the memory region, and returns a pointer to it. If no such block is found, the kernel has run out of memory and alloc returns NULL. Fig. <ref type="figure">9</ref> shows the input to the theorem prover with the invariant annotations removed and formatting adjusted for the presentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Classical setting</head><p>The data abstraction predicate is very similar to the simple list of Sect. For the specification of alloc we first need to define what this operation does in the abstract. For this, we are not interested in the list structure itself, but just in the set of free memory chunks:</p><p>The precondition requires that kfree-list-addr describe some set of free memory chunks F and that all addresses in F as well as the requested size be aligned with KMC. The postfix -addr refers to the fact that the code takes the address of the global variable kfree-list; kfree-list itself can be accessed by a heap lookup at kfree-list-addr. That means, kfree-list-addr is of type word32 ptr ptr. Since k-list expects a word32 ptr, we use the function ptr-coerce to cast it (as does the C code). Alignment is expressed using the nonoverflowing version of divisibility on finite integers with x |u y = (unat x dvd unat y) and aligned F = (∀ p∈F. KMC |u p). The postcondition refers to the pre-state σ for size and the heap.</p><p>The aligned predicate could be made part of k-list. We have not done so here, because free does not require this condition (although free preserves it if the base address is aligned with KMC). It is interesting to note that the code, while it tests the size alignment with an assertion (removed by the preprocessor here), does not check base address alignment.</p><p>The postcondition has two cases: either some memory was returned (´alloc-ret = NULL) or the kernel ran out of memory (´alloc-ret = NULL). In the latter case, we claim that nothing changes in the heap, including the global variable kfree-list. In the former case, we say that the new set of free memory chunks is the same that you would get by evaluating the abstract alloc.</p><p>This specification is not completely satisfying. In the success case, we would ideally like to know that nothing else in the heap changes. This "nothing else" is hard to nail down formally. The set F as used in the specification above is too loose, it would miss the heap changes caused by zeroing out the freshly allocated memory. Separation logic will handle this more naturally below.</p><p>The proof of the verification conditions for alloc takes about 350 lines of proof script with 130 lines of specific supporting lemmas and a further 1400 lines of lemmas shared between and alloc and free in classical and separation logic settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Separation logic</head><p>The separation logic version of the abstraction predicate is the following. The precondition here is simpler than in the classical setting. Since alignment is built into fsets using block, we only need data abstraction and that the requested size is aligned to KMC.</p><p>The postcondition has the same two cases that occur in the classical setting. If we have run out of memory (´alloc-ret = NULL), we now only say that F does not change (and, by frame rule, nothing else in the heap changes either).</p><p>In the success case (´alloc-ret = NULL), we still state that the new set of free memory chunks is the same that you would get by evaluating the abstract function alloc. Additionally, we now explicitly say that the memory returned is a separate, contiguous block of the right size, filled with zero.</p><formula xml:id="formula_27">zero p n = zero-block (ptr-coerce p) (unat (n div 4)) zero-block p 0 = zero-block p (Suc n) = (p +p of-nat n) → 0 ∧ * zero-block p n</formula><p>This zero-block is the sub-formula that can directly be used by client code-it describes the freshly allocated memory. The postcondition is stronger than the one in the classical case.</p><p>The proof of the verification conditions induced by this specification takes about 650 lines of proof script with 750 lines of supporting lemmas (plus the 1400 lines shared with the other parts of the verification). This corresponds to 136 lines of code in the original and 30 lines of code after configure and preprocessing. The effort for the separation logic case was higher than in the classical setting, but not significantly so, and we have acquired a much stronger postcondition that was difficult to state before. In the separation logic case, we see potential for improvement in automation. Much of the additional proof text was verbose, but not hard.</p><p>It should be noted that we chose alloc because it constitutes the worst possible case for this framework: almost every pointer access is unsafe and needs to be reasoned about. In other frameworks this is impossible or leads to unsoundness if applied naïvely, here it is merely more work than usual. Once done, client code does not need to go to the same level of detail to use the pre/post conditions provided. The complexity is hidden by the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>The directly relevant work in the literature arises from efforts to verify properties of pointer programs. There are two directions that are taken-Hoare logic oriented verification in which partial/total correctness and completeness is the primary goal, with decidability or the existence of an efficient algorithmic procedure considered less important, and the opposite approach that strives for automation, at the expense of only being able to cope with limited language fragments or properties, the domain of software model checking, shape analysis, and separation logic decision procedures.</p><p>The idea to use separate heaps for separate pointer types and structure fields in Hoare logic goes back to Burstall <ref type="bibr" target="#b8">[9]</ref>. On the abstract level, our multiple typed heaps formalisation is most closely related to Bornat <ref type="bibr" target="#b7">[8]</ref> and Mehta and Nipkow's <ref type="bibr" target="#b18">[19]</ref> work in Isabelle, although we exploit Isabelle's type inference in a different way. We ground this abstract and efficient reasoning in a detailed C semantics that is directly applicable to concrete programs. Our use of HOL types is similar to that of Blume's <ref type="bibr" target="#b6">[7]</ref> encoding of the C type system in ML that utilises phantom typing to express pointer types and operators for the purpose of a foreign-function interface. The Caduceus tool <ref type="bibr" target="#b11">[12]</ref> supports Hoare logic verification of C programs, including the type-safe part of pointer arithmetic at this level. We increase the applicability of program verification drastically by supporting the unsafe part as well. Separation logic <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b24">25]</ref> has been mechanised in theorem proving systems previously <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b17">18]</ref>. Again, we provide soundness for program verification by grounding these abstract, idealised models in a concrete semantics. We are able to support abstract separation logic notation and unsafe, low-level pointer manipulations at the same time.</p><p>On the concrete level, Norrish <ref type="bibr" target="#b23">[24]</ref> presents a very thorough and detailed memory model of C. Our formalisation has similarities to exploratory work on C++ in the VFiasco project <ref type="bibr" target="#b14">[15]</ref>. The latter two provide a more precise machine model, while the abstractions of the previous paragraph allow for more convenient and efficient reasoning. Our model provides a unified view of both.</p><p>The SLAM <ref type="bibr" target="#b1">[2]</ref> and BLAST <ref type="bibr" target="#b13">[14]</ref> software model checkers apply predicate abstraction and counter-example driven refinement to check some safety properties of C programs automatically, such as correct API usage in device drivers. This is not as useful when verifying fundamental system abstractions, such as memory allocation, that do not rely on other interfaces that can be factored out or that feature inductively defined data structures with complex invariants. It may be possible to tackle some of the guard proof obligations we encounter such as the absence of null pointer dereferences <ref type="bibr" target="#b4">[5]</ref> with this technique, and efforts exist that seek to integrate software model checking with proof-based verification <ref type="bibr" target="#b10">[11]</ref>. Cook et al <ref type="bibr" target="#b9">[10]</ref> extend the automatic theorem prover in software model checkers to support the pointer operations and bit-level arithmetic described in this paper by translating C to propositional logic. Our translation is substantially different, taking advantage of HOL's expressiveness and type system, intended to better support interactive proof.</p><p>Shape analysis <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b25">26]</ref> and separation logic decision procedures <ref type="bibr" target="#b2">[3]</ref> can show some structural invariants, such as the absence of loops in linked lists. At this point in time they tend to be specialised for limited language fragments or data structures that either do not meet our needs or do not provide sufficient benefit to offset the implementation effort, but there are promising developments that may improve this situation <ref type="bibr" target="#b0">[1]</ref>. The Hob <ref type="bibr" target="#b34">[35]</ref> framework takes the refinement view of verification and allows some of these analyses to be used on independent modules or at higher-levels of abstraction, where when applied directly they may fail.</p><p>Type-safe C variants like CCured <ref type="bibr" target="#b20">[21]</ref> take a dual approach to memory type-safety, by statically detecting safe pointer usage and adding runtime checks for those cases where this cannot be verified. These variants have not gained popularity in real-world systems implementations, due to a combination of runtime overheads and the restrictions imposed.</p><p>Our longer-term goal is a verified kernel and earlier work on theorem proving based OS verification includes PSOS <ref type="bibr" target="#b21">[22]</ref> and UCLA Secure Unix <ref type="bibr" target="#b29">[30]</ref>. A lack of mature mechanised theorem proving technology meant that while designs could be formalised, full implementation proofs were not achieved. Later, KIT <ref type="bibr" target="#b3">[4]</ref>, part of the CLI stack, describes verification of process isolation properties down to object code level, but for an idealised kernel with far simpler and less general abstractions than modern microkernels. The VeriSoft project <ref type="bibr" target="#b12">[13]</ref> is attempting to verify a whole system stack, including hardware, compiler, applications, and a simplified microkernel called VAMOS that is inspired by, but not very close to, L4. Most closely related to our case study is the successful verification of the kernel memory allocator from the teaching-based Topsy operating system by Marti et al <ref type="bibr" target="#b17">[18]</ref> in Coq. The major difference is the heavy use of pointer arithmetic and casting in L4's memory allocator that we are able to handle confidently and conveniently due to our more detailed semantic model and type encoding. Marti et al model C memory as nat ⇒ int and translate the code manually into their tool. Although our model is more detailed, our proofs are significantly shorter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Future Work and Conclusion</head><p>Apart from supporting more language features which is underway, we see the main directions for future work as automation and integration. Combining automatic techniques such as decision procedures for separation logic and bit vector arithmetic with interactive proof, as exemplified by Hob <ref type="bibr" target="#b34">[35]</ref>, should lead to improved productivity and reusability without sacrificing the range of programs or properties we consider.</p><p>We have presented a unified, formal framework for the verification of real C programs in an interactive proof assistant without oversimplifications or strong restrictions on the language. Our work is a novel combination of concepts that so far have only been well understood in isolation: Hoare logic verification, separation logic, interactive theorem proving, detailed dynamic and memory models for the C programming language, and low-level pointer operations.</p><p>We have demonstrated with two case studies that reasoning on both the abstract and the detailed level is well supported. Our results indicate that while separation logic might not provide the amount of direct automation that we are used to, this difference becomes smaller for larger verification examples.</p><p>By grounding separation logic in our memory model, we make verification of systems level code practical: proof obligations relating to issues such as inter-type aliasing disappear when the code to be verified is working within type-safe bounds. When the source code is not so well-behaved, the framework allows verifiers to drop to the lower level of multi-byte values and their encodings. This contrasts with methodologies that would reject such low-level behaviour as ill-formed, making verification impossible.</p><p>By importing C code directly into our verification environment, and by tying our logical annotations to the C source, we keep a close connection between the verification and development activities. In particular, we aim to avoid the scenario where the developing code loses its connection with the verification. There is no point in verifying code that is not going to be deployed. We hope our still-nascent methodology, which has verifiers and developers touching the same source files, will make the timely production of verified software possible.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The C verification process. User-supplied components indicated with shading.</figDesc><graphic coords="2,145.17,188.00,56.78,62.27" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>from-bytes (to-bytes v) = v |to-bytes (x:: a)| = size-of TYPE( a) 0 &lt; size-of TYPE( a) size-of TYPE( a) &lt; addr-card align-of TYPE( a) dvd addr-card</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. int heap representation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Inter-type aliasing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Example heap state</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>lift-typ-heap g s ≡ (from-bytes • heap-list-s s (size-of TYPE( a)) • ptr-val) {p | s,g |=s p}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Two-stage lifting</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>sep-cut x y ≡ λs. dom s = {x..+y}(sep-cut (ptr-val p) (size-of TYPE( a)) ∧ * P) (lift-state (h, d))g p (g s p ∧ * P) (lift-state (h, ptr-tag p d))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>..... ........ ................ ........ ........</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Management data structure of the L4 chunk allocator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>6 . 1 :</head><label>61</label><figDesc>k-list h s e [] = s = e k-list h s e (p•ps) = s = Ptr p ∧ s = e ∧ (∃ s . h s = s ∧ k-list h (Ptr s ) e ps)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>k-lists s e [] = λh. s = e ∧ h k-lists s e (p•ps) = λh. (s = Ptr p ∧ s = e) ∧ (∃ s . (block s s ∧ * k-lists s e ps) h) block s s = λh. KMC |u ptr-val s ∧ (s → ptr-val s ) h ∧ sep-cut (ptr-val s) KMC h fsets s e F = λh. ∃ ps. k-lists s e ps h ∧ F = set ps free-sets s e F = λh. ∃ x. (ptr-coerce s → ptr-val x ∧ * fsets x e F) hThe separation logic specification of alloc is then:∀ F σ.{|σ. (free-sets kfree-list-addr NULL F) sep ∧ KMC |u ´size| } ´sep-alloc-ret :== PROC sep-alloc(´size) {|(´sep-alloc-ret = NULL -→ (free-sets kfree-list-addr NULL (alloc ´sep-alloc-ret (max σ size KMC) F) ∧ * zero ´sep-alloc-ret (max σ size KMC)) sep ) ∧ (´sep-alloc-ret = NULL -→ (free-sets kfree-list-addr NULL F) sep )| }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>None in the heap type description, removing values that should not affect the final lifted typed heaps. Equality between lifted heaps is then modulo the heap type description domain.Lifted validity and heap-list are expressed on heap-states with d,g |=s p and heap-list-s respectively in the obvious way.2. The second lifting stage results in typed lifted heaps again. The lift-typ-heap function restricts the heap domain so that the only values affecting the resultant heap are inside the heap footprint of valid pointer values. Equality is now modulo pointer validity.</figDesc><table /><note><p>. The first stage results in an intermediate heap-state: heap-state = addr typ-tag option × byte The function lift-state filters out locations that are lift-state ≡ λ(h, d) x. case d x of None ⇒ None | t ⇒ (t, h x)</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Our restriction on the use of function calls may appear draconian. It forbids not only f(x) + g(y), but also x + f(y). Two unexplored options are possible. We might annotate some function calls as side-effect free, and then allow these functions to be called within expressions. Alternatively, rather than have the programmer do so by hand, we might compile such expressions into a linearised form that forced a particular order of evaluation.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements We thank Kai Engelhardt, Carroll Morgan, Manuel Chakravarty, and Rob van Glabbeek for discussions and for reading drafts of this paper. We are also grateful to David Tsai who started our work on the memory allocator.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* National ICT Australia is funded through the Australian Government's Backing Australia's Ability initiative, in part through the Australian Research Council.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The function chunks p q in the definition above refers to a set of locations starting with pointer p, ending with address q, that consists of adjacent memory chunks only. With this, the pre/post specification of alloc is: </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Beyond reachability: Shape abstraction in the presence of pointer arithmetic</title>
	</analytic>
	<monogr>
		<title level="m">13th International Symposium on Static Analysis (SAS 2006)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4134</biblScope>
			<biblScope unit="page" from="182" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatically validating temporal safety properties of interfaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN&apos;01, Workshop on Model Checking of Software</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2057</biblScope>
			<biblScope unit="page" from="103" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A decidable fragment of separation logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Berdine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Calcagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSTTCS 2004: Foundations of Software Technology and Theoretical Computer Science, 24th International Conference</title>
		<meeting><address><addrLine>Chennai, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">December 16-18, 2004, 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Kit: A study in operating system verification</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Bevier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1382" to="1396" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Checking memory safety with Blast</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Fundamental Approaches to Software Engineering (FASE)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the International Conference on Fundamental Approaches to Software Engineering (FASE)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3442</biblScope>
			<biblScope unit="page" from="2" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Nearly all binary searches and mergesorts are broken</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bloch</surname></persName>
		</author>
		<ptr target="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html" />
		<imprint>
			<date type="published" when="2006-06">June 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">No-longer-foreign: Teaching an ML compiler to speak C &quot;natively</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blume</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Proving pointer programs in Hoare Logic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bornat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematics of Program Construction (MPC 2000)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Backhouse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Oliveira</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1837</biblScope>
			<biblScope unit="page" from="102" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Some techniques for proving correctness of programs which alter data structures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Burstall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence 7</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meltzer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<imprint>
			<publisher>Edinburgh University Press</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="23" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cogent: Accurate theorem proving for program verification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CAV 2005</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Etessami</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</editor>
		<meeting>CAV 2005</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3576</biblScope>
			<biblScope unit="page" from="296" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Integration of a software model checker into Isabelle</title>
		<author>
			<persName><forename type="first">M</forename><surname>Daum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schirmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Seghir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic for Programming, Artificial Intelligence, and Reasoning: 12th International Conference</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Sutcliffe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting><address><addrLine>Montego Bay, Jamaica</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-10">October 2005</date>
			<biblScope unit="volume">3835</biblScope>
			<biblScope unit="page" from="381" to="395" />
		</imprint>
	</monogr>
	<note>LPAR 2005</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multi-prover verification of C programs</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Filliâtre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Marché</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Software Engineering, 6th International Conference on Formal Engineering Methods, ICFEM 2004</title>
		<meeting><address><addrLine>Seattle, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3308</biblScope>
			<biblScope unit="page" from="15" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the correctness of operating system kernels</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gargano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hillebrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leinenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Paul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th International Conference on Theorem Proving in Higher Order Logics (TPHOLs&apos;05)</title>
		<meeting>18th International Conference on Theorem Proving in Higher Order Logics (TPHOLs&apos;05)<address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Software verification with Blast</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN&apos;03, Workshop on Model Checking Software</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Applying source-code verification to a microkernel -the VFiasco project</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hohmuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Stephens</surname></persName>
		</author>
		<idno>TUD-FI02-03-März</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>TU Dresden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">BI as an assertion language for mutable data structures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Ishtiaq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;01: Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="14" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<ptr target="http://l4ka.org/projects/version4/l4-x2.pdf" />
		<title level="m">L4Ka Team. L4 eXperimental Kernel Reference Manual Version X.2. University of Karlsruhe</title>
		<imprint>
			<date type="published" when="2001-10">Oct. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Verification of the heap manager of an operating system using separation logic</title>
		<author>
			<persName><forename type="first">N</forename><surname>Marti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Affeldt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third workshop on Semantics, Program Analysis, and Computing Environments For Memory Management (SPACE 2006)</title>
		<imprint>
			<date type="published" when="2006-01">Jan. 2006</date>
			<biblScope unit="page" from="61" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Proving pointer programs in higher-order logic</title>
		<author>
			<persName><forename type="first">F</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The pointer assertion logic engine</title>
		<author>
			<persName><forename type="first">A</forename><surname>Møller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;01</title>
		<meeting>ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;01</meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">CCured: type-safe retrofitting of legacy software</title>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="477" to="526" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Feiertag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Levitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Robinson</surname></persName>
		</author>
		<idno>CSL-116</idno>
		<title level="m">A provably secure operating system: The system, its applications, and proofs</title>
		<imprint>
			<publisher>SRI International</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Isabelle/HOL -A Proof Assistant for Higher-Order Logic</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">2283</biblScope>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">C formalised in HOL</title>
		<author>
			<persName><forename type="first">M</forename><surname>Norrish</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Computer Laboratory, University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Separation logic: A logic for shared mutable data structures</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th IEEE Symposium on Logic in Computer Science</title>
		<meeting>17th IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="55" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Parametric shape analysis via 3-valued logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;99: Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="105" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Verification of Sequential Imperative Programs in Isabelle/HOL</title>
		<author>
			<persName><forename type="first">N</forename><surname>Schirmer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A unified memory model for pointers</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th International Conference on Logic for Programming Artificial Intelligence and Reasoning (LPAR-12)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Sutcliffe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3835</biblScope>
			<biblScope unit="page" from="474" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Norrish</surname></persName>
		</author>
		<ptr target="http://www.ertos.nicta.com.au/research/l4.verified/kmalloc.pml" />
		<title level="m">Verification of the L4 kernel memory allocator. Formal proof document</title>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Specification and verification of the UCLA Unix security kernel</title>
		<author>
			<persName><forename type="first">B</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kemmerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Popek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="118" to="131" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Towards mechanized program verification with separation logic</title>
		<author>
			<persName><forename type="first">T</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Science Logic -18th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Marcinkowski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Tarlecki</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">3210</biblScope>
			<biblScope unit="page" from="250" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Type classes and overloading in higher-order logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics&apos;97</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Gunter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Felty</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1275</biblScope>
			<biblScope unit="page" from="307" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Certifying machine code safety: Shallow versus deep embedding</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wildmoser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Slind</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Bunker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">3223</biblScope>
			<biblScope unit="page" from="305" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A semantic basis for local reasoning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computation Structure</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="402" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Combining theorem proving with static analysis for data structure consistency</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Workshop on Software Verification and Validation</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
