<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Subtyping Recursive Types</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Roberto</forename><forename type="middle">M</forename><surname>Amadio</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">CNRS-CRIN</orgName>
								<address>
									<settlement>Nancy</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">DEC, Systems Research Center</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Subtyping Recursive Types</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">08893349D6912EB6DFC78824D1C50E98</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We investigate the interactions of subtyping and recursive types, in a simply typed λ-calculus. The two fundamental questions here are whether two (recursive) types are in the subtype relation, and whether a term has a type.</p><p>To address the first question, we relate various definitions of type equivalence and subtyping that are induced by a model, an ordering on infinite trees, an algorithm, and a set of type rules. We show soundness and completeness between the rules, the algorithm, and the tree semantics. We also prove soundness and a restricted form of completeness for the model.</p><p>To address the second question, we show that to every pair of types in the subtype relation we can associate a term whose denotation is the uniquely determined coercion map between the two types. Moreover, we derive an algorithm that, when given a term with implicit coercions, can infer its least type whenever possible. 1 This author's work has been supported in part by Digital Equipment Corporation and in part by the Stanford-CNR Collaboration Project.</p><p>provable. This requirement suggests the most important rule for the µt.α construction, which amounts to a one-step unfolding of the recursion:</p><p>µt.α = [µt.α/t]α meaning that µt.α is equal to α where we replace t by µt.α itself. In our example we have:</p><p>which is the equation we expected to hold.</p><p>Having discussed recursive types, we now need to determine when a value belongs to a recursive type. The rule above for µt.α allows us to expand recursive types arbitrarily far, for a finite number of expansions. Hence, we can postulate that a finite value belongs to a recursive type if it belongs to one of its finite expansions according to the ordinary typing rules. That is, we push the troublesome µ's far enough until we no longer need to consider them.</p><p>However, if the values are not finite, for example if they are defined recursively, we may not be able to push the µ's out of the way. In that case, we need to provide adequate notions of finite approximations of values and types, and postulate that a value belongs to a type when every approximation of the value belongs to some approximation of the type. An approximation α n of a type expression α is an appropriate truncation of α at depth n, hence it is different from an unfolding. This will be made precise in later sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>®</head><p>yes yes yes yes yes © no yes no no no t no yes if t7s no no ®→© no yes no yes no α→β (β≠©) no yes no yes α'≤α,β≤β'</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Subtyping is an inclusion relation between types that is present to some degree in many programming languages. Subtyping is especially important in object-oriented languages, where it is crucial for understanding the much more complex notions of inheritance and subclassing.</p><p>Recursive types are also present in most languages. These types are supposed to unfold recursively to match other types. Moreover, unfolding must preserve typing soundness and not cause the compiler to diverge.</p><p>In this paper we investigate the interaction of unrestricted recursive types with subtyping. This interaction is present in some modern languages based on structural type matching (where type equality or subtyping is determined by some abstract type structure, and not by how types are syntactically presented). In the past, recursive types have often been restricted by other language features; for example by explicit unfolding in ML, and by name matching in Modula-2. Algol68 was the first language to rely on a structural type equality algorithm for recursive types. Thereafter name matching became popular, largely because it is easier to implement but also because it prevents accidental matches based on type structure.</p><p>Name-matching determines type equality by relying, at least partially, on the names assigned to types in a given program, instead of on their structure. With name matching, recursive analysis can stop at occurrences of type names. Unfortunately there is no general definition of name matching; each language, and sometimes each compiler, implements it slightly differently. Types with the same meaning (in the eye of the programmer) may or may not be equated in different runs of the compiler, depending on irrelevant textual perturbations that affect the name matching rules.</p><p>The inconsistency of name-matching rules becomes a problem in distributed environments, where type definitions and data may migrate outside the compiler or program run in which they are created. Types and data should have a meaning independent of particular runs, hence languages such as Modula-3 <ref type="bibr" target="#b21">[22]</ref> and other experimental languages such as Amber <ref type="bibr" target="#b9">[10]</ref> and Quest <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b11">12]</ref> concerned with data persistence and data migration, have again adopted structural matching. Since these languages also rely on subtyping, structural subtyping becomes an issue. Because of various language design issues, Modula-3 restricts itself to structural equivalence plus a limited form of structural subtyping; in this paper we deal with the unrestricted combination of recursion and subtyping, which forms the basis of Amber and Quest.</p><p>With this motivation, we investigate type systems with recursive types and subtyping, and the related problems of structural matching and structural subtyping. Structural matching techniques are well known, and have strong connections with well-understood theoretical concepts. Structural subtyping is a much newer subject. We provide the first complete theory of recursive subtypes that leads naturally to an effective type theory and to typechecking algorithms. In practice it is easy to adapt algorithms for structural typing to structural subtyping (although to our knowledge, this was first done in Amber), but formalizing the type rules and the proofs of correctness of the algorithms is more challenging. We show that both our algorithm and our type rules are complete with respect to a natural notion of subtyping.</p><p>In the rest of the introduction we provide the basic intuitions about recursive subtypes, and we illustrate the main problems along with several non-solutions. Section 2 formalizes the syntax of a basic calculus with recursive types and section 3 introduces a subtyping relation based on a tree ordering. Section 4 describes a subtyping algorithm, and section 5 describes the corresponding type rules. A partial equivalence relation model is given in section 6. Finally, section 7 relates subtyping to type coercions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Types</head><p>A type, as normally intended in programming languages, is a collection of values sharing a common structure or shape. Examples of basic types are: Unit, the trivial type containing a single element, and Int, the collection of integer numbers. Examples of structured types are: Int→Int, the functions from integers to integers; Int×Int, the pairs of two integers; and Unit+Int, the disjoint union of Unit and Int consisting of either a unit value marked "left" or an integer marked "right" (given two arbitrary but distinct marks).</p><p>A recursive type is a type that satisfies a recursive type equation. Common examples are:</p><formula xml:id="formula_0">Tree = Int + (Tree×Tree)</formula><p>the collection of binary trees with integer leaves, and:</p><formula xml:id="formula_1">List = Unit + (Int×List)</formula><p>the collection of lists of integers. Note that these are not definitions of Tree and List; they are equational properties that any definition of Tree and List must satisfy. There are also useful examples of recursion involving function spaces, typical of the objectoriented style of programming: Cell = (Unit→Int) × (Int→Cell) × (Cell→Cell) A Cell is interpreted as the collection of integer-containing memory cells, implemented as triples of functions read: Unit→Int, write: Int→Cell, and add: Cell→Cell. In each of these functions the current cell is implicit, so for example add needs only to receive another cell in order to perform a binary addition.</p><p>Recursive types can hence be described by equations, and we shall see that in fact they can be unambiguously defined by equations. To see this, we need some formal way of reasoning about the solutions of type equations. These formal tools become particularly useful if we start examining problematic equations such as t = t, s = s×s, r = r→r, etc., for which it is not clear whether there are solutions or whether the solutions are unique.</p><p>It is appealing to set up sufficient conditions so that type equations have canonical solutions. Then, if we have an equation such as t = Unit+(Int×t), we can talk about the solution of the equation. Such a canonical solution can then be indicated by a term such as µt.Unit+(Int×t); the type t that is equal to Unit+(Int×t). Here µt.α is a new type construction just introduced for denoting canonical solutions.</p><p>To say that L @ µt.Unit+(Int×t) (where @ means equal by definition) is the solution of the List equation, implies that L must satisfy the equation; that is, L = Unit+(Int×L) must be</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Subtypes</head><p>If types are collections of values, subtypes should be subcollections. For example, we can introduce two new basic types ® (bottom), the collection containing only the divergent computation, and © (top), the collection of all values. Then ® should be a subtype of every type, and every type should be a subtype of ©. We write these relations as ®≤α and α≤©.</p><p>Function spaces α→β have a subtyping rule that is antimonotonic in the first argument. That is, α→β ≤ α'→β' if α' ≤ α and β ≤ β'</p><p>For example, if Nat ≤ Int, and f: Int→Cell stores an integer into a cell, then f is also willing to store a natural number into a cell, that is f: Nat→Cell. Hence, it is sound to have Int→Cell ≤ Nat→Cell, but not the opposite. This antimonotonic rule is familiar in object-oriented programming, where it is one of the main considerations for the correct typechecking of methods.</p><p>Adequate subtyping rules can be found for all the other type constructions we may have. For example, for products we have α×β ≤ α'×β' if α≤α' and β≤β'. Similarly, for disjoint unions we have α+β ≤ α'+β' if α≤α' and β≤β'.</p><p>What is, then, subtyping for recursive types? The intuition we adopt is that two recursive types α and β are in the subtype relation if their infinite unfoldings also are in this relation, in some appropriate sense. We might at first just consider finite unfoldings α + of a type α, and require that "α ≤ β if for every α + of α there is a β + of β with α + ≤ β + ". However, we shall see shortly that this condition is not strong enough. Hence, we insist on inclusion of infinite unfoldings. This is made precise by the notion, mentioned above, of finite approximations α n of a type α, and by defining "α ≤ β if, for every n, α n ≤ β n ".</p><p>Unfortunately, the formal subtyping rules for recursive types and the related algorithms cannot rely on approximations, since "α n ≤β n for every n" involves testing an infinite number of conditions. The subtyping rules should rely instead on "finitary" rules, and it is therefore not so obvious how to invent a collection of rules that achieve the desired effect. For example, a first idea might be simply to say that:</p><formula xml:id="formula_2">if α ≤ β then µt.α ≤ µt.β<label>(1)</label></formula><p>where t may occur free in α and β. By this we can show that, for example, µt. ©→t ≤ µt. ®→t, just from the assumption that t≤t. Unfortunately we also have:</p><p>(1) implies α @ µt. t→® ≤ µt. t→© @ β and this is quite wrong. By unfolding both α and β twice we get:</p><p>(1) implies (α→®)→® ≤ (β→©)→© and these are not subtypes: the first ® on the left and the first © on the right are in the wrong inclusion relation (©≤®), being in antimonotonic position.</p><p>The problem with rule (1) comes from the negative occurrences (on the left of an odd number of →'s) of the recursion variable. In fact rule (1) is sound for types that are monotonic in the recursion variable.</p><p>A correct (and finitary) rule for inclusion of recursive types is instead the following:</p><formula xml:id="formula_3">(s≤t ⇒ α ≤ β) ⇒ µs.α ≤ µt.β<label>(2)</label></formula><p>where s occurs only in α, and t occurs only in β. That is, if by assuming the inclusion of the recursive variables we can verify the inclusion of the bodies, then we can deduce the inclusion of the recursive types. (It is interesting to check how subtyping now fails on the example above.) Going back to the List example, if we have Nat≤Int and:</p><p>NatList @ µs. Unit+(Nat×s) IntList @ µt. Unit+(Int×t) then we can safely deduce NatList≤IntList from rule (2) since s≤t implies Unit+(Nat×s) ≤ Unit+-(Int×t).</p><p>On the other hand, the Cell example does not work as smoothly.</p><formula xml:id="formula_4">NatCell @ µs. (Unit→Nat) × (Nat→s) × (s→s) IntCell @ µt. (Unit→Int) × (Int→t) × (t→t)</formula><p>Here we cannot conclude NatCell≤IntCell from rule (2), because of antimonotonicity: both the inclusion of the second component (write) and the inclusion of the third (add) fail. This is however not a deficiency of rule (2); such a conclusion would be unsound. For example, a NatCell might have a write function of type Nat→NatCell that fails on negative numbers. If such a cell were considered as an IntCell, it would be possible to pass a negative integer to this write and cause it to fail. These issues are related to the typechecking of object types in object-oriented languages, and are discussed at length in <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Equality of Recursive Types</head><p>We need now to consider strong notions of equality of recursive types. This is necessary because the rule (2) above is weak in some areas; for example, we cannot deduce directly from it that:</p><p>µt.t→t ≤ µs.s→s because this would require assuming both s≤t and t≤s. The combination of rule (2) and equality rules will finally give us all the power we need.</p><p>To check whether two recursive types µs.α' and µt.β' are equivalent, we could assume s=t, and attempt to prove α'=β' under this assumption. This would work for µt. t→t and µs. s→s. But now consider the types: α @ µs.Int→s β @ µt.Int→Int→t</p><p>They both expand infinitely into Int→Int→Int→Int→..., and they also have the same set of values (for example, recursive terms like µf. λx:Int. f). However, the assumption s=t does not show Int→s = Int→Int→t; we get stuck on the question whether s = Int→t. Another attempt might involve expanding the µ's, but unfortunately we cannot expand them out of existence. By unfolding alone we can get only: This is what we meant earlier by the insufficiency of "α ≤ β if for every expansion α + of α there is a β + of β with α + ≤ β + ".</p><p>In fact, we seem to have made some progress here; we have come back to the original question α=β only after analyzing the entire structure of α and β. It seems that we should then be able to conclude that α=β, because a complete analysis of α and β has found no contradiction. This kind of reasoning is possible but it has to be carefully justified, and in general we need to determine the conditions under which this stronger notion of equality does not lead to a circular argument.</p><p>Note that in the process above we have found a single context C[X] @ Int→Int→X such that α = C[α] and β = C[β]; that is, both α and β are fixpoints of C. We shall be able to show that all the non-trivial (formally, contractive) type contexts C[X] have unique fixpoints over infinite trees, and therefore if they have two fixpoints these must be equal. Hence, the necessary rule for determining type equality can be formulated as follows:</p><formula xml:id="formula_5">α = C[α] ∧ β = C[β] ∧ C contractive ⇒ α = β<label>(3)</label></formula><p>It remains to be shown how to generate contractive contexts that allow us to equate any two types that have equal infinite expansions. This can be done via an algorithm, and in fact a natural one. We will show that this algorithm is sound (it will not equate types with different infinite expansions) and complete (it will equate all types that have equal infinite expansions). Such proofs of correctness of algorithms are among our major goals here, but first we need to carefully develop a formal framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Subtyping of Recursive Types</head><p>The problem of equating recursive types such as α and β above can be related to well-known solvable problems, such as the equivalence of finite-state automata. However, the similar problem for subtyping has no well-known parallel. Take, for example: γ @ µs.Int→s δ @ µt.Nat→Nat→t</p><p>Again, looking at the infinite expansions we obtain γ = Int→Int→..., and δ = Nat→Nat→..., from which we would like to deduce γ≤δ by antimonotonicity. But what are the exact rules? Attempts to unfold γ and δ fall into the same difficulties as before. The strategy here is to reduce the subtyping problem to an equality problem, which we solve by rule (3), plus rule <ref type="bibr" target="#b1">(2)</ref>. That is, we first show that δ' @ µt.Nat→t = µt.Nat→Nat→t 7 δ. After that, we can use rule (2) to show γ≤δ', and hence γ≤δ.</p><p>Initially, this strategy suggests a two-step algorithm that first synchronizes the recursions in some appropriate way, and then uses rule (2) without additional folding/unfolding. Instead, we present an algorithm that tests subtyping of recursive types directly; the correspondence between the algorithm and the rules is then less obvious.</p><p>The example above involves two distinct recursive types for which the rule (2) alone is not sufficient to determine subtyping. This example may seem artificial, however this situation can easily happen in practice. As a slightly more plausible example, suppose we define the type of lists of alternating integers and naturals:</p><formula xml:id="formula_6">IntNatList @ µt.Unit+Int×(Unit+Nat×t)</formula><p>This definition could arise more naturally from a mutual recursion construct in some programming language, for example:</p><p>Let Rec IntNatList = Unit+Int×NatIntList and NatIntList = Unit+Nat×IntNatList One would certainly expect NatList ≤ IntNatList to hold. But, NatList @ µs.Unit+Nat×s hence we have first to show that NatList = µs.Unit+Nat×(Unit+Nat×s), and only then can we apply rule (2) successfully.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Algorithm outline</head><p>We describe the algorithm informally and we show some sample runs. This is only an approximation of the algorithm analyzed in the formal part, but it should explain the main ideas. A more detailed description is given in section 4.4.</p><p>A recursive type of the form µt. ...t... can be represented in memory as a cyclic linked structure such that every occurrence of t in the recursive body is represented by the address of the corresponding µt structure, i.e., by a back-pointer. Otherwise, all subexpressions of a type expression, including µ subexpressions, are uniquely determined by their address in memory. Every time the algorithm reaches a µ structure, possibly through a back-pointer, it has the option of analyzing the interior of the structure ("unfolding" the recursive type) or to compare its address with other addresses as a termination condition. The algorithm for α≤β operates on a pair of linked structures and a trail. A trail is a set of address pairs that records the pairs of addresses that have been jointly encountered when following a pair of paths in the two linked structures. To avoid diverging on cyclic structures, the algorithms registers a local successful termination when it reaches a pair of addresses that have already been seen, that is, a pair of addresses that are contained in the trail.</p><p>The algorithm to determine whether α≤β starts with an empty trail and proceeds through the following steps in sequence. We only consider basic types, function types, and recursive types.</p><p>[1] Succeed if the pair of addresses of α and β (in this order) is contained in the trail.</p><p>(In this situation, we have completely explored a pair of cyclic paths and found no subtyping failures; hence we declare success for these paths.) <ref type="bibr" target="#b1">[2]</ref> Succeed if α and β are type constants that are equal or in the subtype relation.</p><p>(This is the base case for the given collection of basic types and basic inclusions.) <ref type="bibr" target="#b2">[3]</ref> When α is α'→α" and β is β'→β", recur on β'≤α' and on α"≤β". Succeed if both recursions succeed. (This is the case for function types; note the swapping of inclusion on the domains because of antimonotonicity of →; no such swapping would occur for data type constructors such as × and +). [4.1] When α is µt.α' and β is µs.β', add the pair of addresses of α and β (in this order) to the trail, and recur on α'≤β'. Succeed if the recursion succeeds.</p><p>(The presence of µ's signals potential cyclic paths, hence we store the current pair of addresses in the trail so that case <ref type="bibr" target="#b0">[1]</ref> can prevent looping. We use an ordered pair of addresses because inclusion is, obviously, not symmetric; this detail differs from the standard trail algorithms for type equivalence. The next two cases are similar.) [4.2] When α is µt.α', add the pair of addresses of α and β to the trail, and recur on α'≤β.</p><p>Succeed if the recursion succeeds. <ref type="bibr">[4.3]</ref> When β is µs.β', add the pair of addresses of α and β to the trail, and recur on α≤β'.</p><p>Succeed if the recursion succeeds. <ref type="bibr" target="#b4">[5]</ref> Otherwise, fail. (This means we have found a pair of incomparable type expressions, such as a function type and a base type.)</p><p>A faithful description of a run of this algorithm would involve assigning arbitrary addresses to subexpressions of type expressions; this would only obscure the exposition. Instead, we display the type expressions and we leave their addresses implicit: the reader is urged to keep this in mind.</p><p>The diagrams below represent execution trees. The starting goal is at the bottom, the branching represents recursive calls, and the leaves represent termination conditions. The trail is shown in curly brackets; its elements are written as t≤s, and represent pairs of addresses of type expressions. We indicate in square bracket the step of the algorithm used in each line to obtain the line above it.</p><p>The first sample run involves two types with matching µ structures; their inclusion is nontrivial because of antimonotonicity. {t≤s} t ≤ s <ref type="bibr" target="#b0">[1]</ref> {t≤s} ® ≤ t [2] {t≤s} s→® ≤ t→t <ref type="bibr" target="#b2">[3]</ref> {t≤s} ® ≤ © [2] {t≤s} (t→t)→® ≤ (s→®)→© <ref type="bibr" target="#b2">[3]</ref> {} µt.((t→t)→®) ≤ µs.((s→®)→©) <ref type="bibr">[4.1]</ref> The second sample run involves two types with mismatching µ structures. This mismatch introduces the need to examine a cyclic path more that once. For this, we use a loopback step, which corresponds to following a cyclic structure back to its original entry point (an artificial loopback step is needed only because, as we said, we keep the address information implicit). In the algorithm above, a loopback situation corresponds to a failure of step <ref type="bibr" target="#b0">[1]</ref> followed by some dereferencing of back-pointers that leads to step <ref type="bibr" target="#b3">[4]</ref>. {t≤s, t≤®→s} ® ≤ © <ref type="bibr" target="#b1">[2]</ref> {t≤s, t≤®→s} t ≤ s [1] {t≤s, t≤®→s} ©→t ≤ ®→s <ref type="bibr" target="#b2">[3]</ref> {t≤s} µt.(©→t</p><formula xml:id="formula_7">) ≤ ®→s [4.2] {t≤s} ® ≤ © [2] {t≤s} t ≤ ®→s [loopback] {t≤s} ©→t ≤ ®→(®→s) [3] {} µt.(©→t) ≤ µs.(®→(®→s)) [4.1]</formula><p>Hence, in this run we go around the µt loop twice in order to go around the µs loop once.</p><p>For other interesting examples, check how µt.(t→t) ≤ µs.(s→s) succeeds, and how µt.(t→®) ≤ µs.(s→©) fails.</p><p>One of the main aims of this paper is to show that the algorithm above is consistent with, and in fact equivalent to, the rules (2) and (3) of sections 1.2 and 1.3. For this we need to place both the rules and the algorithm in a more formal framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Formal development</head><p>Having explained most of the problems and the unsatisfactory solutions arising from subtyping recursive types, we can now proceed to the formal treatment.</p><p>So far we have discussed rules for the subtyping of recursive types which are motivated by some operational intuition. In the following we will broaden our perspective and consider various notions of type equivalence, α=β, and subtyping, α≤β. These are induced by: a) An ordering on infinite trees:</p><formula xml:id="formula_8">α= T β, α≤ T β (Section 3) b) An algorithm: α= A β, α≤ A β (Section 4) c) A collection of typing rules: α= R β, α≤ R β (Section 5) d) A collection of per models: α= M β, α≤ M β (Section 6)</formula><p>The mathematical content of the paper consists mainly in analyzing the relationships between these notions. For a simply typed lambda calculus with recursive types (described in Section 2) we show, among other properties:</p><formula xml:id="formula_9">α= T β ⇔ α= A β ⇔ α= R β ⇒ α= M β α≤ T β ⇔ α≤ A β ⇔ α≤ R β ⇒ α≤ M β</formula><p>Moreover, we prove a restricted form of completeness with respect to the model (6.3), we show the definability in the calculus of certain maps that interpret coercions (7.1), and we give an algorithm for computing the minimal type of a term with respect to ≤ T (7.2). All these results support the relevance of the theory for the subtyping of recursive types sketched in this introduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A Simply Typed λ-calculus with Recursive Types</head><p>We consider a simply typed λ-calculus with recursive types and two ground types ® (bottom) and © (top); the latter play the roles of least and greatest elements in the subtype relation. Although this calculus is very simple, it already embodies the most interesting problems for which we can provide solutions sufficiently general to extend to other domains. In the conclusions we comment on which techniques can be applied to more complex calculi.<ref type="foot" target="#foot_0">2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Types</head><p>In an informal BNF notation, types are defined as follows:</p><p>t,s, ... type variables and type constants, indifferently α :</p><formula xml:id="formula_10">:= t | ® | © | α→β | µt.α</formula><p>Types are identified up to renaming of bound variables. We use parentheses to determine precedence; in their absence, → associates to the right, and the scoping of µ extends to the right as far as possible. For simplicity we omit the other type constructors considered in the introduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Terms</head><p>Terms are denoted with M, N, ... ; the following rules establish when a term M has type α (written M:α).</p><p>(assmp)</p><p>x </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Equations</head><p>Here are some fundamental equations for the calculus. In particular, notice that the constants "fold" and "unfold" establish an isomorphism between a recursive type and its unfolding.</p><formula xml:id="formula_11">(β) ( λ x α .M)N = [N/x α ]M (µ) fold(unfold x) = x unfold(fold x) = x</formula><p>In section 6 we will consider a model in which many more types and terms are equated, for example the following will be valid equations:</p><formula xml:id="formula_12">(fold-unfold) [µt.α/t]α = µt.α (η) λx α .Mx α = M if x α ÌFV(M) (® ) x ® = y ® (© )</formula><p>x © = y ©</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Tree Ordering</head><p>There is a well-established theory of subtyping for the non-recursive types. Basic motivations can be found, for example, in <ref type="bibr" target="#b10">[11]</ref>. The notion of non-recursive type is merely syntactic; it means that the type does not contain µ's. The purpose of this section is to extend this theory to the recursive types, by defining a notion of approximation on infinite trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Subtyping Non-recursive Types</head><p>We have the following simple rules. There is a least type ® and a greatest type ©; the operator → is antimonotonic in the first argument and monotonic in the second. The relation ≤ is reflexive by virtue of (var) and (→) below.</p><formula xml:id="formula_13">(®) ® ≤ α (©) α ≤ © (var) t ≤ t (→) α' ≤ α, β ≤ β' ⇒ α→β ≤ α'→β'</formula><p>It is fairly easy to prove that the relation ), defined as α)β iff α≤β is derivable in the system above, is a partial order on the collection of non-recursive types. In particular, one has to show that the transitivity rule:</p><formula xml:id="formula_14">(trans) α ) β, β ) γ ⇒ α ) γ</formula><p>is derived. This can be proven by defining a collection of rewriting rules on proofs that have the property that, when applied to a proof using transitivity, produce a (trans)-free proof of the same judgment. More abstractly one can look at the rules as the clauses of an inductive definition of a binary relation ) and show that such a relation is transitive (see 3.4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Folding and Unfolding</head><p>Should the types [µt.α/t]α and µt.α be considered as equivalent? In general they are provably isomorphic in the calculus via fold and unfold. However, in most languages fold and unfold are implicit, and most implementations do not generate run-time code for them. So it seems reasonable to require that [µt.α/t]α ≤ µt.α and µt.α ≤ [µt.α/t]α, thereby making unfolding transparent.</p><p>In fact, we will exhibit a model of the calculus in which µt.α and [µt.α/t]α are equated because recursive domain equations are solved up to equality. However, a theory of type equivalence based only on the congruence closure of:</p><formula xml:id="formula_15">(fold-unfold) [µt.α/t]α ≤ µt.α µt.α ≤ [µt.α/t]α</formula><p>turns out to be too weak; for example, the types µt.s→s→t and µt.s→t are not equivalent.</p><p>Once we assume the transparency of unfolding, it seems natural to consider types with the same infinite expansions as equivalent. Infinite expansion can be rephrased as an approximation property such that the semantics of a type is completely determined by the semantics of its finite syntactic approximations. In fact, this is a very desirable property in the semantics of programming languages (see, for example, the approximation theorem in <ref type="bibr" target="#b28">[29]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Tree Expansions</head><p>As we have seen, simple unfolding does not induce a sufficiently strong notion of type equivalence. A stronger condition of approximation seems required to deal with infinite expansions. Let us first explain how to associate a finitely branching, labeled, regular tree with any recursive type.</p><p>Paths in a tree are represented by finite sequences of natural numbers π,σ∈ω*, with πσ for concatenation and nil as the empty sequence.</p><p>Nodes in a tree are labeled by a ranked alphabet L = {® 0 , © 0 , → 2 } ∪ {t 0 | t is a type variable}, where the superscripts indicate arity.</p><p>A tree A∈ω*îïÕL is a partial function from (paths) ω* into (node labels) L, whose domain is non-empty and prefix-closed, and such that each node has a number of children equal to the rank of the associated label.</p><p>Formally, let A(π)ß indicate that π is in the domain of A (and A(π) ¶ indicate the opposite). Then the collection Tree(L) of finitely-branching labeled trees over L, is given by the partial maps:</p><formula xml:id="formula_16">A: ω*îïÕ L such that: A(nil)ß A(πσ)ß ⇒ A(π)ß A(π) = p i ⇒ Ó0≤j&lt;i. A(πj)ß</formula><p>We can now define a function T: Type → Tree(L) from recursive types (as defined in 2.1) to Tree(L). Let hµ be the function that counts the number of µ's in the head position of a type. We define T(α)(π) by induction on (|π|, hµ(α)):</p><formula xml:id="formula_17">T(®)(nil) @ ® T(©)(nil) @ © T(t)(nil) @ t T(α→β)(nil) @ → T(α→β)(0π) @ T(α)(π) T(α→β)(1π) @ T(β)(π) T(µt.α)(nil) @ ® if α has the shape µt 1 ....µt n .t (t i ≠t, iÏ1..n, n≥0) T(µt.α)(π) @ T([µt.α/t]α)(π) if α does not have the shape above T(α)(π) @ ¶ in all other cases</formula><p>Note that the α→β case reduces |π|, and second µt.α case preserves |π| while reducing hµ(α); this entails that the definition is well-founded.</p><p>Here are some simple examples; the tree on the right repeats itself after the "..." : </p><formula xml:id="formula_18">T(s→µt.t) = → T(µt.®→(©→t)) = → / \ / \ s ® ® → / \ © . . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3.2</head><p>Tree(L) is a complete metric space with respect to the usual metric on trees <ref type="bibr" target="#b3">[4]</ref>. In fact it is the completion of the space of finite trees Tree fin (L). We recall:</p><p>-A metric space is complete iff every Cauchy sequence converges.</p><p>-A map f:M→M over a metric space M with distance d is contractive iff there is a real number q&lt;1 such that Óa,bÏM:</p><formula xml:id="formula_19">d(f(a),f(b)) ≤ q †d(a,b).</formula><p>-Banach's fixpoint theorem asserts that a contractive map over a complete metric space has a unique fixpoint.</p><p>-The distance d(A,B) on Tree(L) is defined as either 0 if A=B; or else 2 -c(A,B) , where c(A,B) is either ∞ if A=B, or else it is the length of a shortest path that distinguishes A from B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3.3</head><p>For every α, Tα is a regular tree, that is, a tree with a finite number of different subtrees. Every tree is completely specified by the language of its occurrences, where if pÏL and A∈Tree(L) then the occurrences are Occ(p,A) @ {π∈ω* | A(π) = p}. In particular, every regular tree A has an associated set {πp | π∈Occ(p,A), pÏL} which is a regular language <ref type="bibr" target="#b15">[16]</ref>.</p><p>From this it follows that given types α, β, the problem of deciding if Tα = Tβ is reducible to the problem of the equivalence of deterministic finite-state automata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.3.4</head><p>Going back to the example in 3.2, observe that T(µt.s→s→t) = T(µt.s→t).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Finite Approximations</head><p>Finite trees are in one-one correspondence with the non-recursive types, therefore they have a partial order as defined in 3.1. The problem we are going to consider now is how to extend this partial order on finite trees to Tree(L).</p><p>Hence, we introduce the notion of finite approximation of a tree. It is crucial to keep in mind the antimonotonic behavior of the → in its first argument.</p><p>We define a family of functions:</p><formula xml:id="formula_20">{ | k : Tree(L)→Tree fin (L)} k∈ω</formula><p>Given AÏTree(L) its cut at the k-th level is defined as follows:</p><formula xml:id="formula_21"> ↑ if |π| &gt; k A | k (π) @  A(π) if |π| &lt; k, or |π| = k and A(π) ¶  ® if |π| = k, A(π)ß, and π is positive in A  © if |π| = k, A(π)ß,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and π is negative in A</head><p>where we say that π is positive (negative) in A if along the path π from the root we select the left sibling of a node labeled → an even (odd) number of times. We can extend this definition to types:</p><formula xml:id="formula_22">α | k @ T -1 ((Tα) | k ) (a non-recursive type)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Convention</head><p>The bijection T,T -1 between Tree fin (L) and non-recursive types is from now on often omitted. That is, given any finite tree AÏTree fin (L), we ambiguously identify it with the corresponding non-recursive type. Similarly, for AÏTree(L), we denote with A | k both its cut and the corresponding non-recursive type.</p><p>We are now ready to introduce a notion of tree ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Definition (tree ordering)</head><p>For A,B Ï Tree fin (L):</p><formula xml:id="formula_23">A ≤ fin B ⇔ T -1 A≤T -1 B (as finite types; see 3.1) For A,B Ï Tree(L): A ≤ ∞ B ⇔ Ók. (A | k ≤ fin B | k ) For α,β Ï Type: α≤ T β ⇔ Tα ≤ ∞ Tβ Remarks 3.4.2 ≤ ∞</formula><p>is a partial order on Tree(L).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">α≤</head><p>T β is a preorder on recursive types, and is such that for all k α | k ≤ T α. We can now show, for example, α @ µt.©→t ≤ T µt.®→(®→t) @ β; consider the tree expansions:</p><formula xml:id="formula_24">Tα = → Tβ = → / \ / \ © → ® → / \ / \ © . . . ® . . .</formula><p>Observe that © and ® always occur in negative position so from ®≤© we can conclude Ók. α | k ≤β | k and this gives us the statement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.4.4</head><p>One can think of other tree orderings; for example, consider the following inductive definition that gives an ordering ≤ Ind on Tree(L).</p><p>≤ Ind is the least reflexive relation such that, ÓA,B,A',B' Ï Tree(F):</p><formula xml:id="formula_25">→ → ®≤ Ind A; A≤ Ind ©; A'≤ Ind A, B≤ Ind B' ⇒ / \ ≤ Ind / \ A B A' B'</formula><p>Equivalently, ≤ Ind = ê n&lt;ω ≤ n where:</p><formula xml:id="formula_26">≤ 0 = {(®,A), (A,©) | AÏTree(L)} ∪ Id Tree(L) → → ≤ n+1 = ≤ n ∪ {( / \ , / \ ) | A'≤ n A, B≤ n B'} A B A' B'</formula><p>It is not difficult to prove by induction on n that ≤ Ind is a partial order on Tree(L), it conservatively extends the ordering on Tree fin (L) and it is contained in ≤ ∞ . Moreover, such containment is strict as shown by the example in 3.4.3. In fact, ≤ Ind lacks the crucial approximation property possessed by ≤ ∞ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">An Algorithm</head><p>In this section we show that the tree ordering we have defined on types (3.4.1) can be decided by a rather natural modification of the algorithm that tests directly (that is, without reduction to a minimal form) the tree equivalence of two types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Canonical Forms</head><p>The first step towards formalizing the algorithm is to introduce canonical forms for types and systems of equations.</p><p>Canonical forms of types allow us to ignore the trivial type equivalences due to redundant uses of µ binders. For example, the recursive type (µt.µs.t→s)→ ((µt.t)→(µt.©)) can be simplified to the canonical form (µv.v→v)→(®→©) without changing the denoted tree. In a canonical form, the body of each µ is an → type, and each µ variable is used in its µ body. Note, however, that different canonical forms may generate the same tree, for example µt.s→t, s→µt.s→t, and µt.s→s→t.</p><p>Implementations of the subtyping algorithm manipulate cyclic linked data structures in computer memory. We represent these data structures abstractly as special sets of equations. Informally, each equation relates a memory address, represented by a variable, to a node of the data structure, represented by a type constant or a type constructor applied to variables. For example, here is a simple type with a corresponding equational representation and a possible memory representation:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type</head><p>Equations A memory representation</p><formula xml:id="formula_27">(v 0 is the root) Addr. Node Child1 Child2 µt.®→t v 0 =v 1 →v 0 0: → 1 0 v 1 =® 1: ® - -</formula><p>Sets of equations in this stylized form are called canonical. In this section we show that a canonical set of equations, along with a root variable, determines a unique tree which is called the solution of the equations. Moreover, we give effective ways of going from a type to a canonical set of equations, and vice versa, while preserving the represented tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proviso</head><p>In order to have a simple correspondence between recursive types and systems of regular equations, we assume that all variables, both bound and free, in the types α 1 , ..., α n under consideration are distinct. When a type is unfolded, the necessary renaming of bound variables must be performed. For example, (µt.t→s)→(µs.t→s) should be rewritten as (µv.v→s)→(µr.t→r).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Recursive Types in Canonical Form</head><p>Henceforth, Tp denotes the collection of non-recursive types, and µTp denotes the collection of recursive types in canonical form, defined as follows:</p><p>α</p><formula xml:id="formula_28">::= ® | © | t | α→β | µt.α→β</formula><p>where in the case µt.α→β, t must occur free in α→β. Hence the body of a µ in canonical form must immediately start with an →; in particular, it cannot be another µ. The introduction of µTp simplifies the case analysis in the following proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Proposition (existence of canonical forms)</head><p>For every type α there is a type β in canonical form such that Tα=Tβ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>The crucial observation is that Tµt.µs.γ[t,s] = Tµv.γ <ref type="bibr">[v,v]</ref>. See also 5.1.3 for a proof of this fact that uses the rules for type equivalence. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Regular System of Equations in Canonical Form</head><p>Systems of regular equations are a well-known tool for representing regular trees (see for example <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>).</p><p>For our purposes a regular system of equations in canonical form is an element of Tenv, that is, a finite association of distinct type variables (members of Tvar) with types in a specific form: Tenv @ { ε Ï Tvar îïÕ Tp | Dom(ε) is finite and ÓtÏDom(ε) we have that ε(t) is one of ®, ©, t 1 , t 2 →t 3 , where t 1 ÌDom(ε) and t 2 , t 3 ÏDom(ε) } A pair (α , ε) Ï Tp × Tenv represents the following system of regular equations (not necessarily in canonical form because α may be complex):</p><formula xml:id="formula_29">t α = α (t α a fresh variable) t = ε(t)</formula><p>for each tÏDom(ε)</p><p>It is important to observe that, by the definition of Tenv, this system defines a contractive functional (G 0 ,..., G n ) over Tree(L) n+1 (see remark 3.3.2) where n = |Dom(ε)|, Dom(ε) = {t 1 , ..., t n } and:</p><formula xml:id="formula_30">G 0 (A 0 , ..., A n ) @ [A 0 /t α , A 1 /t 1 , ..., A n /t n ]Tα G i (A 0 , ..., A n ) @ [A 0 /t α , A 1 /t 1 , ..., A n /s n ]Tε(t i ) (1≤i≤n)</formula><p>The predicate Reach(α,ε) denotes the variables reachable from the free variables in α by applying the equations in ε. Formally:</p><formula xml:id="formula_31">Reach(t,ε) 0 @ {t} Reach(t,ε) n+1 @ if tÌDom(ε) then {t} if tÏDom(ε) then if ε(t)=® or ε(t)=© then  if ε(t)=s then {s} if ε(t)=t 1 →t 2 then Reach(t 1 ,ε) n ∪Reach(t 2 ,ε) n Reach(t,ε) @ ê n∈ω Reach(t,ε) n Reach(α,ε) @ ê t∈FV(α) Reach(t,ε)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.4">Definition (solution of a system)</head><p>We denote with Sol(α, ε) the first component B 0 of the solution (B 0 ,..., B n ) in Tree(L) n+1 of the system associated with (α, ε). The solution is given by Banach's unique fixpoint theorem (see remark 3.3.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark</head><p>Given a system of regular equations in canonical form, it is possible to minimize the number of variables by a procedure that is analogous to the one for minimizing the number of states in a deterministic finite-state automaton. This immediately provides an algorithm for deciding the equality of the trees represented by two regular systems of equations in canonical form.</p><p>In the rest of this section we describe maps between types and regular systems of equations in canonical form, as summarized by the following diagram, where all the paths leading from a node to Tree(L) commute.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type</head><p>Tvar × Tenv</p><formula xml:id="formula_32">Ü , á ( *, E) Tree(L) T Sol</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.5">Proposition (From recursive types to regular systems)</head><p>There is a pair of maps *ÏType→Tvar, E∈Type→Tenv such that:</p><formula xml:id="formula_33">Óα∈Type. Tα = Sol(α*, Eα) Proof</formula><p>It is enough to prove the result for every term in µTp. Then the lemma follows by 4.1.2. We now define (*, E) by induction on the structure of γ∈µTp.</p><p>Cases γ7t, γ7®, and γ7© . Take γ*@s and Eγ@{s=γ}, for any s not appearing in the original type α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case γ7α→β.</head><p>We if q j 7t, and q j [t n+2 ...t n+m+1 ] otherwise. Next proceed by induction on (|π|, γ) to prove Tγ(π)=Sol(γ*, Eγ)(π). The only difficulty arises for γ7µt.α→β. In order to apply the induction hypothesis one needs a lemma. Following the notation above we show, for instance, Sol(t 2 , Eγ) = Sol([γ/t]α*, E[γ/t]α). See 4.1.7 for a proof of a related fact that gives the main insights while being slightly simpler. M</p><p>Here is an example of the procedure described in the proof above. Consider: γ @ µt.t→®.</p><p>For the base cases t and ® we have (cunningly choosing the names t 2 and t 3 ): t* = t 2 ; Et = {t 2 =t} ®* = t 3 ; E® = {t 3 =®} From the µ case of the proof we obtain:</p><p>γ* = t 1 ; Eγ = {t 1 = t 2 →t 3 , t 2 = t 2 →t 3 , t 3 = ®} Note the first two equations of the system Eγ; the redundancy facilitates the uniform treatment of the µ case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.6">Definition (From regular systems to recursive types)</head><p>We define a function Ü -,á : Tp×Tenv → Type by induction on (|Dom(ε)|, α):</p><p>Ü®,εá @ ® Ü©,εá @ © Üα→β,εá @ Üα,εá → Üβ,εá Üt,εá @ t if tÌDom(ε) Üt,εá @ µt.Üε(t),ε\tá if tÏDom(ε) where ε\t is like ε except that it is undefined on t.</p><p>Continuing the example above, we have:</p><formula xml:id="formula_34">Üγ*,Eγá = Üt 1 ,{t 1 = t 2 →t 3 , t 2 = t 2 →t 3 , t 3 = ®}á = µt 1 .Üt 2 →t 3 ,{t 2 = t 2 →t 3 , t 3 = ®}á = µt 1 .Üt 2 ,{t 2 = t 2 →t 3 , t 3 = ®}á → Üt 3 ,{t 2 = t 2 →t 3 , t 3 = ®}á = µt 1 .(µt 2 .Üt 2 →t 3 ,{t 3 = ®}á) → (µt 3 .Ü®,{t 2 = t 2 →t 3 }á) = µt 1 .(µt 2 .Üt 2 ,{t 3 = ®}á → Üt 3 ,{t 3 = ®}á) → (µt 3 .®) = µt 1 .(µt 2 .t 2 →(µt 3 .Ü®,{}á)) → (µt 3 .®) = µt 1 .(µt 2 .t 2 →(µt 3 .®)) → (µt 3 .®)</formula><p>The last line is equivalent to the original type γ = µt.t→®, as established in general by the following proposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.7">Proposition (More on commuting translations)</head><p>(1) For any system of equations, the first component of the solution coincides with the tree expansion of the associated recursive type:</p><p>Ó(α, ε) Ï Tp × Tenv. Sol(α, ε) = TÜα,εá (we abbreviate T(Üα,εá) as TÜα,εá) (2) The map Ü , á satisfies the conditions:</p><p>1. Ü®,εá = ® 2. Ü©,εá = © 3. Üt,εá = t if tÌDom(ε) 4. TÜt,εá = TÜε(t),εá if tÏDom(ε) 5. TÜα→β,εá = T(Üα,εá → Üβ,εá) 6. TÜα*,Eαá = Tα Proof (1) Show by induction on (|π|, α) that TÜα,εá(π) = Sol(α, ε)(π). The interesting case arises when α7t, tÏDom(ε), ε(t) = t 1 →t 2 . Then, Sol(t, ε) = Sol(ε(t), ε) = Sol(t 1 →t 2 ,ε); and, TÜt,εá = Tµt.Üε(t), ε\tá = T[Üt,εá/t]Üt 1 →t 2 , ε\tá. In order to apply the induction hypothesis and complete this case one needs to prove TÜt i , εá = T([Üt,εá/t]Üt i , ε\tá) (i=1,2). To obtain the latter, we show the following lemma: For any canonical system ε, and type variables, t, t', we have TÜt', εá = T([Üt,εá/t]Üt', ε\tá) . We proceed by induction on the depth of the path π, and by case analysis, to show: TÜt', εá(π) = T([Üt,εá/t]Üt', ε\tá)(π) . Case t7t': [Üt,εá/t]Üt', ε\tá = [Üt,εá/t] t' = Üt,εá = Üt',εá.</p><p>Case t=t': Subcase tÏDom(ε), t'ÏDom(ε):</p><p>Say:</p><formula xml:id="formula_35">ε(t) = t 1 →t 2 , ε(t') = t' 1 →t' 2 .</formula><p>Then: α 7 Üt',εá = µt'. Üt'  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Computational Rules</head><p>The subtyping algorithm described in this section is based on the canonical sets of equations described in the previous section (again, these equations can be interpreted as linked data structures in memory). The algorithm involves a single set of equations ε, with two distinct roots α and β representing the types to be compared. It also involves a trail Σ of the form {t 1 ≤s 1 ,..., t n ≤s n }, which records inclusions of variables discovered as the algorithm progresses. An invocation of the algorithm with parameters Σ, ε, α and β, is written as the judgment Σ,ε ⊃ α≤β.</p><p>The algorithm is not expressed as an ordinary procedure, but as a collection of rules that resembles a Prolog program. The typical rule is written as a logical implication of judgments:</p><formula xml:id="formula_37">Σ 1 ,ε 1 ⊃α 1 ≤β 1 , Σ 2 ,ε 2 ⊃α 2 ≤β 2 ⇒ Σ,ε⊃α≤β</formula><p>Operationally, this means that in order to determine whether Σ,ε⊃α≤β holds, we must invoke the "subroutines" Σ 1 ,ε 1 ⊃α 1 ≤β 1 and Σ 2 ,ε 2 ⊃α 2 ≤β 2 and check whether they hold. In general, given a logical deduction in this system of rules, the algorithm execution can be recovered by reading the rules backwards from the conclusion to the assumptions.</p><p>In the following, t,s,r,u denote arbitrary variables; a,b denote variables not in the domain of ε; Σ is a finite set of subtyping assumptions on pairs of type variables; and α,β∈Tp.</p><p>The algorithm can then be written as follows:</p><formula xml:id="formula_38">(assmp A ) Σ,ε ⊃ t≤s if t≤s∈Σ (® A ) Σ,ε ⊃ ®≤β (© A ) Σ,ε ⊃ α≤© (var A ) Σ,ε ⊃ a≤a (→ A ) Σ,ε ⊃ α'≤α, Σ,ε ⊃ β≤β' ⇒ Σ,ε ⊃ α→β ≤ α'→β' (µ A ) Σ∪{t≤s},ε ⊃ ε(t) ≤ ε(s) ⇒ Σ,ε ⊃ t ≤ s if t,sÏDom<label>(ε)</label></formula><p>The initial judgment Σ,ε⊃α≤β that starts an execution of the algorithm must obey a special condition expressing some reasonable assumptions. This condition says that the initial type structures α,β are simple root variables denoting disjoint structures, and that Σ has not yet come into play. For Σ={t 1 ≤s 1 ,..., t n ≤s n }, define:</p><formula xml:id="formula_39">Vars(Σ) @ {t 1 ,s 1 ,...,t n ,s n } Σπε ⇔ Vars(Σ)∩Dom(ε)= </formula><p>Then, a judgment Σ,ε⊃α≤β satisfies the initiality condition (or equivalently, is an initial goal) iff α7t, β7s, ε can be decomposed in ε 1 ∪ε 2 so that tÏDom(ε 1 ) and sÏDom(ε 2 ), Dom(ε 1 )∩Dom(ε 2 ) = , and Σπε.</p><p>By the way canonical systems are constructed, and by the fact of starting with an initial goal, the expansions of variables according to ε, as in (µ A ), is always synchronized. That is, in a call to Σ,ε⊃α≤β during the execution of the algorithm we never have a situation where α is a variable in Dom(ε) and β is not, or vice versa; hence (µ A ) covers all the cases that may arise. If one desires to treat more general systems of equations, then it may be necessary to introduce other µ-rules that take into account situations in which just an ε-expansion on the left (or the right) is needed. In these cases we would have rules like:</p><formula xml:id="formula_40">(assmp' A ) Σ,ε ⊃ α≤β if α≤β∈Σ (µ lA ) Σ∪{t≤α'→β'},ε ⊃ ε(t)≤α'→β' ⇒ Σ,ε ⊃ t≤α'→β' if tÏDom(ε) (µ rA ) Σ∪{α'→β'≤s},ε ⊃ α'→β'≤ε(s) ⇒ Σ,ε ⊃ α'→β'≤s if sÏDom(ε).</formula><p>Note also that there are two conceptually distinct uses of the rule (assmp A ) in the algorithm: one for the initial assumptions contained in Σ, which represent known inclusions on type constants, and one for the assumptions inserted during the computation, which come from the unfolding of µ's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Generating the Execution Tree</head><p>Given a goal Σ,ε ⊃ t≤s, the algorithm consists in applying the inference rules backwards, generating subgoals in the cases (→ A ) and (µ A ). This process is completely determined once we establish that (assmp A ) has priority over the other rules and (® A ) has priority over (© A ).</p><p>A tree of goals built this way is called an execution tree. If no rules are applicable to a certain subgoal, that branch of the execution tree is abandoned, and execution is resumed at the next subgoal, until all subgoals are exhausted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Termination</head><p>The execution tree is always finite. Observe that if t ≤ s is the assumption that we add to Σ, then t and s are type variables in Dom(ε). Also observe that the (→) rule shrinks the size of the current goal by replacing it with subexpressions of the goal, and that each application of a µ-rule enlarges Σ.</p><p>The bound on the depth of the execution tree for α≤ A β is of the order of the product of the sizes of the two systems Eα, Eβ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Algorithm Ordering</head><p>An execution tree succeeds if all the leaves correspond to an application of one of the rules (assmp A ), (® A ), (© A ), and (var A ). Dually, it fails if at least one leaf is an unfulfilled goal (no rule can be applied).</p><p>We write ∫ A Σ,ε⊃ t≤s iff Σ,ε⊃ t≤s is an initial goal (4.2) and the corresponding execution tree succeeds.</p><p>Given recursive types α,β we write:</p><formula xml:id="formula_41">α≤ A β ⇔ ∫ A , Eα∪Eβ ⊃ α*≤β*</formula><p>For testing type equality, we can define:</p><formula xml:id="formula_42">α= A β ⇔ α≤ A β ∧ β≤ A α</formula><p>Alternatively, we could directly define a (more efficient) type equality algorithm, along the same lines as the subtyping algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Soundness and Completeness of the Algorithm</head><p>We now show that the subtyping algorithm described in the previous section is sound and complete with respect to the infinite-tree interpretation of types. That is, the algorithm precisely embodies our intuition of recursive types as infinite trees.</p><p>First we prove soundness and completeness for non-recursive types. Soundness is then derived by observing that a successful execution of the algorithm on some input must also be successful on all the finite approximations of the input. Completeness is proven by examining a failing execution tree, and concluding that the trees corresponding to the input must have been different to start with.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Lemma (Derived structural computational rules)</head><p>Given the definition of Tenv in 4.1.3, the algorithm in 4.2, and the ordering in 4.2.3, we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Σ-weaken</head><p>If ∫ A Σ,ε ⊃ t≤s and Σ∪Σ' π ε then ∫ A Σ∪Σ',ε ⊃ t≤s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Σ-strengthen</head><p>If ∫ A Σ∪Σ',ε ⊃ t≤s and Reach(t→s,ε)∩Vars(Σ') =  then ∫ A Σ,ε ⊃ t≤s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ε-weaken</head><p>If ∫ A Σ,ε ⊃ t≤s, Reach(t→s,ε)∩Dom(ε') = , Σ π ε∪ε', and Dom(ε)∩Dom(ε') =  then ∫ A Σ,ε∪ε' ⊃ t≤s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ε-strengthen</head><p>If ∫ A Σ,ε∪ε'⊃ t≤s and Reach(t→s,ε)∩Dom(ε') =  then ∫ A Σ,ε ⊃ t≤s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Proposition (Completeness of ≤ A for non-recursive types)</head><p>Given α,β∈Tp non-recursive types then α≤ T β ⇒ α≤ A β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let ε @ Eα∪Eβ. We show α≤ T β ⇒ ÓΣ. Case α7α'→α". Since α≤ T β, we have either:</p><p>Case β7©, similar to the case α7®.</p><p>Case β7β'→β", with β'≤ T α' and α"≤ T β".</p><p>Then ε = {α*=α'*→α"*}∪{β*=β'*→β"*}∪ε'∪ ε" where ε' @ Eα'∪Eβ' and ε" @ Eα"∪Eβ".</p><p>By induction hypothesis ÓΣ'.Σ'πε' ⇒ ∫ A Σ',ε' ⊃ β'*≤α'* and ÓΣ". Σ"πε" ⇒ ∫ A Σ",ε" ⊃ α"*≤β"*. Take any Σ such that Σπε then: ∫ A Σ,ε' ⊃ β'*≤α'* and ∫ A Σ,ε" ⊃ α"*≤β"*. By ε-weaken (note Σπε ⇒ Σπε'∪ε"):</p><p>∫ A Σ,ε'∪ε" ⊃ β'*≤α'* and ∫ A Σ,ε'∪ ε" ⊃ α"*≤β"*. By Σ-weaken:</p><p>∫ A Σ∪{α*≤β*},ε'∪ ε" ⊃ β'*≤α'* and ∫ A Σ∪{α*≤β*},ε'∪ ε" ⊃ α"*≤β"*. Hence, by applying (→ A ) and (µ A ) we can conclude ∫ A Σ,ε⊃α*≤β*. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Proposition (Soundness of ≤ A for non-recursive types)</head><p>Given α,β∈Tp non-recursive types then α≤ A β ⇒ α≤ T β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>We show ∫ A ,ε ⊃ α*≤β* ⇒ α≤ T β, where ε @ Eα∪Eβ, by induction on the structure of α and β.</p><p>Case α7®. Then ®≤ A β by (® A ) ((assmp A ) does not apply), and also ®≤ T β.</p><p>Cases α7©, α7a. Similar.</p><p>Case α7α'→α". Assume ∫ A ,ε ⊃ α*≤β*; then the first step is either: </p><formula xml:id="formula_43">Case (© A ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Lemma (Uniformity of ≤</head><formula xml:id="formula_44">A ) Let α,β∈Type. If α≤ A β then Ók.α | k ≤ A β | k . Proof (sketch)</formula><p>Given any k, from the execution tree of α≤ A β it is possible to extract a successful execution tree for α | k ≤ A β | k . The point is that the use of the (assmp A ) rule can be arbitrarily delayed by repeating a certain pattern of computation.</p><p>For example, consider µt.©→t ≤ A µs.®→s, which gives raise to: ε @ ε 1 ∪ε 2 , ε 1 @ {t 1 =t 2 →t 1 , t 2 =©}, ε 2 @ {s 1 =s 2 →s 1 , s 2 =®}.</p><p>The execution tree of the initial goal ,ε⊃t 1 ≤s 1 is:</p><formula xml:id="formula_45">(® A ) ⇒ {t 1 ≤s 1 ,s 2 ≤t 2 },ε⊃®≤© (assmp A ) ⇒ {t 1 ≤s 1 },ε⊃s 2 ≤t 2 ⇒ {t 1 ≤s 1 },ε⊃t 1 ≤s 1 ⇒ {t 1 ≤s 1 },ε⊃t 2 →t 1 ≤s 2 →s 1 ⇒ ,ε⊃t 1 ≤s 1</formula><p>The goal under (assmp A ) can be replaced by a copy of the entire tree, appropriately renamed. At the same time, ε must be appropriately expanded:</p><formula xml:id="formula_46">ε @ ε 1 ∪ε 2 , ε 1 @ {t 1 =t 2 →u 1 , t 2 =©, u 1 =u 2 →u 1 , u 2 =©}, ε 2 @ {s 1 =s 2 →v 1 , s 2 =®, v 1 =v 2 →v 1 , v 2 =®}. (® A ) ⇒ {t 1 ≤s 1 ,u 1 ≤v 1 ,v 2 ≤u 2 },ε⊃®≤© (assmp A ) (® A ) ⇒ {t 1 ≤s 1 ,u 1 ≤v 1 }, ε⊃v 2 ≤u 2 ⇒ {t 1 ≤s 1 ,u 1 ≤v 1 },ε⊃u 1 ≤v 1 ⇒ {t 1 ≤s 1 ,s 2 ≤t 2 },ε⊃®≤© ⇒ {t 1 ≤s 1 ,u 1 ≤v 1 },ε⊃u 2 →u 1 ≤v 2 →v 1 ⇒ {t 1 ≤s 1 }, ε⊃s 2 ≤t 2 ⇒ {t 1 ≤s 1 },ε⊃u 1 ≤v 1 ⇒ {t 1 ≤s 1 },ε⊃t 2 →u 1 ≤s 2 →v 1 ⇒ ,ε⊃t 1 ≤s 1</formula><p>This is now the execution tree of a different initial goal, which might have originated from the problem ©→(µt.©→t) ≤ A ®→µs.(®→s), which is equivalent to the original problem. In a similar way, this execution tree can be further transformed into one for ©→(©→®) ≤ A ®→(®→®) by replacing the (assmp A ) leaf with a (® A ) leaf. By repeating this process we can obtain an execution tree for α | k ≤ A β | k , for an arbitrarily large k. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.5">Proposition (Soundness of ≤ A )</head><p>Let α,β∈Type; if α≤ A β then α≤ T β. Let lead(α,ε) @ Sol(α,ε)(nil) be the first label of α in ε (that is, skipping initial variables in α,ε).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let Σ,ε ⊃ α≤β be the root of an execution tree, terminating with success or failure leaves, obtained from the rules in 4.2. Every node Σ',ε ⊃ α'≤β' in the execution tree determines a path π from the root to itself, given by considering the occurrences of (→ A ) and ignoring the other rules. Then:</p><p>1) Either α' and β' are both (bound) type variables, or neither is.</p><p>2) Tα(π) = lead(α',ε) and Tβ(π) = lead(β',ε).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on the depth of the execution tree. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.7">Proposition (Completeness of ≤</head><formula xml:id="formula_47">A ) Let α,β∈Type; if α≤ T β then α≤ A β. Proof We show ¬ α≤ A β ⇒ ¬ Tα≤ ∞ Tβ.</formula><p>By assumption, we have an execution tree for α≤ A β which contains a failure node Σ,ε ⊃ α'≤β', determining a path π as in Lemma 4.3.6. By 4.3.6.(2), Tα(π) = lead(α',ε) and Tβ(π) = lead(β',ε). Hence we have a common path in Tα and Tβ corresponding to the failure node. The following table summarizes the possible cases for α',β' where the entry indicates either failure or the rule being applied by the algorithm; the n.a. (not applicable) cases come from 4.3.6.(1). Every "fail" in the algorithm corresponds to a situation where the two trees cannot be in the inclusion relation. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">An Implementation</head><p>In order to facilitate the proofs, the representation of data structures and algorithms given in 4.1 and 4.2 was rather abstract. In this section we show the beginning of a similar treatment for more concrete and traditional representations.</p><p>The computational rules in 4.2 can be converted into a straightforward and practical algorithm, based on the method of trails <ref type="bibr" target="#b27">[28]</ref>. To reflect more closely actual implementations, we adopt the additional rules (assmp' A ), (µ lA ), and (µ rA ) described in 4.2. This results in the algorithm discussed informally in 1.5, but differs slightly from the one treated formally in 4.2 and 4.3 where the additional rules are not needed because the systems of equations are taken in canonical form.</p><p>A member α of µTp is represented as a directed cyclic graph l,S where the nodes in S are uniquely labeled (for example by memory addresses), and where l is the starting label. Each µ in α corresponds to a cycle in S.</p><p>More concretely, using an informal programming notation, S is a Store, where Store @ LabelîïÕNode are the partial functions from labels to nodes (from memory addresses to memory locations). Then Graph @ Label×Store, where Label @ Nat, and Node @ Bot+Top+Var(Tvar)+ Arrow(Label×Label)+Rec(Label).</p><p>An allocator transforms a type into a graph structure:</p><formula xml:id="formula_48">Alloc: µTp×Store×(Tvar→Label) → Graph</formula><p>Let new(S) be a label l (for example the least one) such that l Ì dom(S). We denote by S[l=Bot] a store that is just like S except that S(l)=Bot.</p><p>Alloc(®, S, e) @ let l = new(S) in l,S[l=Bot] Alloc(©, S, e) @ let l = new(S) in l,S[l=Top] Alloc(t, S, e) @ if tÏdom(e) then e(t),S else let l=new(S) in l,S[l=Var(t)] Alloc(α→β, S, e) @ let l',S' = Alloc(α, S, e) and l",S" = Alloc(β, S', e) let l=new(S") in l,S"[l=Arrow(l',l")] Alloc(µt.α, S, e) @ let l = new(S) let l',S' = Alloc(α, S[l=Bot], e[t=l]) in l,S'[l=Rec(l')]</p><p>The allocation of µt.α is done by reserving a new memory location l, then allocating the body α by binding every occurrence of t to l, and finally storing a Rec node containing the allocation of α back into l. The store S[l=Bot] is used in the recursion to prevent l from being returned again by new.</p><p>In the implementation of the algorithm, the assumption set Σ is represented as a trail, that is, a set of label pairs. This has the task of remembering the pairs of labels in the cyclic graphs that have been jointly visited.</p><p>From two types α and β we produce two graphs l α ,S α , l β ,S αβ such that S αβ extends S α . Then Alg(,S αβ ,l α ,l β ) proceeds as follows, mimicking the rules in 4.2:</p><p>Alg(Tr, S, l, l') @ if Ül,l'á Ï Tr then ok else if S(l) = Bot ok else if S(l') = Top then ok else if S(l) = Var(t) and S(l') = Var(t) then ok else if both S(l) =Arrow(l 1 ,l 2 ) and S(l') = Arrow(l 1 ',l 2 ') then Alg(Tr, S, l 1 ', l 1 ); Alg(Tr, S, l 2 , l 2 ') else if S(l) = Rec(l 1 ) and S(l') ≠ Rec(l 1 ') then Alg(Tr∪Ül,l'á, S, l 1 , l') else if S(l) ≠ Rec(l 1 ) and S(l') = Rec(l 1 ') then Alg(Tr∪Ül,l'á, S, l, l 1 ') else if S(l) = Rec(l 1 ) and S(l') = Rec(l 1 ') then Alg(Tr∪Ül,l'á, S, l 1 , l 1 ') else fail An alternative approach is to avoid Rec nodes completely, and have the allocator construct direct loops in the graph. This leads to an algorithm where trails must be kept of every pair of nodes, instead of every pair of nodes of which one is a Rec node. This algorithm is closer to the formulation of the rules in 4.2, while the present algorithm, which in practice produces much shorter trails, uses the equivalent of the (µ lA ) and (µ rA ) rules described there.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Definition</head><p>α≤ C β ⇔ ÓS,l',S',l",S".</p><p>Alloc(α,S,[])=l',S' ∧ Alloc(β,S',[])=l",S" ⇒ Alg(,S",l',l") = ok</p><p>From this point on it seems possible to mimic sections 4.3.4-4.3.7, modulo the use of the (µ lA ) and (µ rA ) rules, and show α≤ C β iff α≤ T β, but we have not checked the cumbersome details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Typing Rules</head><p>In this section we introduce a certain number of axioms and rules for type equality and subtyping. These are intended as natural rules for a language based on subtyping, and as a specification of a subtyping algorithm for such a language. In section 4 we have studied such a subtyping algorithm; here we see that the algorithm and the rules match each other perfectly, by relating them both to trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Type Equivalence Rules</head><p>We say that a type α is contractive in the type variable t if either t does not occur free in α, or α can be rewritten via unfolding as a type of the shape α 1 →α 2 . We write this fact as αßt.</p><p>It is now easy to observe that the contractiveness of α in t is a sufficient (and necessary) condition to enforce the contractiveness of the following functional on the space Tree(L) (3.3): G α,t (A) @ [A/t]Tα AÏTree(L) ([A/t]Tα denotes the substitution of the tree A for the occurrences of t in Tα.) This remark suggests the following rule that is generalized to a larger calculus in <ref type="bibr" target="#b12">[13]</ref>:</p><formula xml:id="formula_49">(contract) [β/t]α = β, [β'/t]α = β', αßt ⇒ β = β'</formula><p>In words, if two types β and β' are fixpoints of the same functional α[t], then they are equal since contractive functionals have unique fixpoints. This rule was also inspired by a standard proof technique for bisimulation <ref type="bibr" target="#b22">[23]</ref>. Moreover, it is convenient to identify µt.t = ®.</p><p>In this section we consider the equivalence:</p><formula xml:id="formula_50">∫ α=β (or α= R β)</formula><p>meaning that α = β can be derived in the congruence induced by the (contract) rule and the (foldunfold) and (µ-®) axioms below. Here is the complete axiomatization:</p><formula xml:id="formula_51">(refl) α = α (symm) α = β ⇒ β = α (trans) α = β, β = γ ⇒ α = γ (→-congr) α = α', β = β' ⇒ α→β = α'→β' (µ-congr) α = β ⇒ µt.α = µt.β (µ-®) µt.t = ® (fold-unfold) [µt.α/t]α = µt.α (contract) [β/t]α = β, [β'/t]α = β', αßt ⇒ β = β'</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Proposition (Soundness of the equivalence rules w.r.t. the trees) α = R β ⇒ Tα=Tβ</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Immediate by the previous considerations. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Derived Rules</head><p>By means of (contract) and (fold-unfold) it is possible to prove new interesting equivalences, for example: <ref type="bibr" target="#b0">(1)</ref> µt.s→t = µt.s→(s→t)</p><formula xml:id="formula_52">(2) µt.µs.α = µv.[v/t,v/s]α (µ-contraction)</formula><p>We make explicit a free variable by writing, for example, α[t].</p><p>Then we have:</p><formula xml:id="formula_53">t h = r h [t 1 ..t k ] where r σ(i) [t 1 ..t k ] 7 p i [t σ(1) ...t σ(n) ] r π(j) [t 1 ..t k ] 7 q j [t π(1) ...t π(m) ]</formula><p>We need to argue that this is a proper definition, since we can have, for example, σ(i)=π(j) for some i,j. We show that when this happens, we also have by construction that r σ(i) [t 1 ..t k ]7r π(j) [t 1 ..t k ]. Similarly for the other possible conflicts: σ(i1)=σ(i2) for some i1,i2, and π(i1)=π(i2) for some j1,j2. To show these facts, we further investigate the properties of σ and π.</p><p>σ(1) = π(1) since α,β start in the same pair (A 1 ,B 1 ).</p><p>-if σ (i) = π (j) then p i 7q j . Moreover, let α i = p i [α 1 ...α n ]7p i (α (i,1) ...α (i,#p i ) ) and β j = q j [β 1 ...β m ]7q j (β (j,1) ...β (j,#qj) ) be the i-th and j-th equations in the respective systems.</p><p>Then α i ÏA h , β j ÏB h for some h (property above); the pair α i ,β j was considered in the process above; that is, the pairs α (i,1) ,β (j,1) ... α (i,#p i ) ,β (j,#p i ) were also added to the list. Therefore σ(i,1)=π(j,1) ... σ(i,#p i )=π(j,#q j ), and p i (t σ(i,1) ...t σ(i,#p i ) )7q j (t π(j,1) ...t π(j,#q j ) ). This is the same as saying p i [t σ(1) ...</p><formula xml:id="formula_54">t σ(n) ]7q j [t π(1) ...t π(m) ].</formula><p>-if σ (i1) = σ (i2) then p i1 7p i2 . Moreover, let α i1 = p i1 (α (i1,1) ...α (i1,#p i1 ) ) and α i2 = p i2 (α (i2,1) ...α (i2,#p i2 ) ) be the i1-th and i2-th equations in the α system. Then α i1 ,α i2 ÏA h for some h (property above). Consider any β j ÏB h ; the pairs α i1 ,β j , α i2 ,β j were considered in the process above, that is the pairs α (i1, <ref type="bibr">)</ref> were also added to the list. Therefore σ(i1,1)=π(j,1)=σ(i2,1), and similarly up to σ(i1,#p i1 )=σ(i2,#p i2 ). Hence: p i1 (t σ(i1,1) ...</p><formula xml:id="formula_56">t σ(i1,#p i1 ) )7p i2 (t σ(i2,1) ...t σ(i2,#p i 2 )</formula><p>). This is the same as saying p i1 [t σ(1) ...</p><formula xml:id="formula_57">t σ(n) ]7p i2 [t σ(1) ...t σ(n) ].</formula><p>-similarly for π(i1) = π(i2).</p><p>Hence we conclude:</p><formula xml:id="formula_58">-if σ(i) = π(j) then r σ(i) [t 1 ..t k ]7p i [t σ(1) ...t σ(n) ]7q j [t π(1) ...t π(m) ]7r π(j) [t 1 ..t k ] -if σ(i1)=σ(i2) then r σ(i1) [t 1 ..t k ]7p i1 [t σ(1) ...t σ(n) ]7p i2 [t σ(1) ...t σ(n) ]7r σ(i2) [t 1 ..t k ] -similarly for π(j1)=π(j2)</formula><p>Now by Lemma 5.2.1 we can construct a solution of the system t h = r h [t 1 ..t k ]; that is, we can obtain</p><formula xml:id="formula_59">γ 1 ..γ k such that ∫ γ h = r h [γ 1 ..γ k ]. Then ∫ γ σ(i) =r σ(i) [γ 1 ..γ k ]7p i [γ σ(1) ...γ σ(n)</formula><p>] for all i. Therefore, the γ 's (when appropriately replicated) satisfy the same system as the α's, and by Lemma 5.2.2 we have ∫ α i =γ σ(i) . Similarly, the γ 's satisfy the β 's system, and ∫ β j =γ π(j) . Moreover, σ (1) = π (1), hence ∫ α7α 1 =γ σ(1) =γ π(1) =β 1 7β by transitivity. M This constructive proof is based on the one in <ref type="bibr" target="#b24">[25]</ref> (see also <ref type="bibr" target="#b20">[21]</ref>), but differs in an important point as, in addition, we must deal with equivalence classes of types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.8">Example</head><p>In this example, arising from a discussion with Mario Coppo, we consider the types: α @ µt.t→(t→t) β @ µt.(t→t)→t</p><p>We have Tα=Tβ, but note that there is no single context that can prove them equivalent by the (contract) rule. We must find a third type γ which is independently provably equal to α and β by (contract), and then we can obtain ∫ α=β by transitivity. To find this γ, we instantiate the proof of 5.2.7.</p><p>We start with two equational characterizations for α and β:</p><formula xml:id="formula_60">α 1 @ α β 1 @ β α 2 @ α→α β 2 @ β→β p 1 [t 1 ,t 2 ] @ t 1 →t 2 q 1 [t 1 ,t 2 ] @ t 2 →t 1 p 2 [t 1 ,t 2 ] @ t 1 →t 1 q 2 [t 1 ,t 2 ] @ t 1 →t 1</formula><p>That is, the following are provable, by (fold-unfold):</p><formula xml:id="formula_61">α 1 = α 1 →α 2 β 1 = β 2 →β 1 α 2 = α 1 →α 1 β 2 = β 1 →β 1</formula><p>Starting with the list ({α 1 },{β 1 }), we must match the equations for α 1 and β 1 . This involves equating the pairs α 1 ,β 2 (obtaining ({α 1 },{β 1 ,β 2 }), and α 2 ,β 1 (obtaining ({α 1 ,α 2 },{β 1 ,β 2 }).</p><p>Matching the newly inserted pairs does not further modify the situation, hence we have reached termination with the partitions:</p><p>({α 1 ,α 2 },{β 1 ,β 2 }) with k=1 and σ=π={1÷ïñ1, 2÷ïñ1}</p><p>The associated system of one equation is t 1 = r 1 [t 1 ], where:</p><formula xml:id="formula_62"> r σ(1) [t 1 ] 7 p 1 [t σ(1) ,t σ(2) ]  r 1 [t 1 ] =  r σ(2) [t 1 ] 7 p 2 [t σ(1) ,t σ(2) ]  = t 1 →t 1  r π(1) [t 1 ] 7 q 1 [t π(1) ,t π(2) ]   r π(2) [t 1 ] 7 q 2 [t π(1) ,t π(2) ] </formula><p>We now generate a solution for this system:</p><formula xml:id="formula_63">γ 1 @ µt.t→t such that ∫ γ 1 = γ 1 →γ 1 = r 1 [γ 1 ]</formula><p>We can verify that (γ 1 ,γ 1 ) solves the α and β systems:</p><formula xml:id="formula_64">∫ γ 1 =p 1 [γ 1 ,γ 1 ] ∫ γ 1 =q 1 [γ 1 ,γ 1 ] ∫ γ 1 =p 2 [γ 1 ,γ 1 ] ∫ γ 1 =q 2 [γ 1 ,γ 1 ]</formula><p>Hence a proof of ∫ α 1 =γ 1 can be constructed by Lemma 5.2.2 (more simply, by unfolding</p><formula xml:id="formula_65">∫ α 1 = α 1 →(α 1 →α 1 ) and ∫ γ 1 = γ 1 →γ 1 = γ 1 →(γ 1 →γ 1 ), hence ∫ α 1 = γ 1 by (contract)). Similarly, ∫ γ 1 = β 1 .</formula><p>Hence by transitivity, ∫ α 1 = β 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Subtyping Rules</head><p>At first it is not clear how to define a rule for the subtyping of recursive types that is sufficiently powerful. In particular, observe that the computational rule (µ A ) in section 4.2 does not have any apparent logical meaning as the premise is always valid under a classical reading of the entailment relation.</p><p>We now introduce a rule, (µ R ), whose soundness is clear. Later, in section 5.4, we will show that in conjunction with the type equivalence rules, (µ R ) leads to a subtyping system complete with respect to the tree ordering.</p><formula xml:id="formula_66">Case (eq R ) α= R β ⇒ {t i ≤s i } ⊃ α≤β Since = R is a congruence, we have [α i /t i , β i /s i ]α = R [α i /t i , β i /s i ]β. By soundness of = R we have [α i /t i , β i /s i ]α = T [α i /t i , β i /s i ]β. Finally, [α i /t i , β i /s i ]α ≤ T [α i /t i , β i /s i ]β since ≤ T is a preorder. M Remarks 5.3.2</formula><p>It is easy to observe that if we prove something in the system without using (eq R ) and (trans R ) then all the assumptions, t≤s, inserted in Γ when applying the rule (µ R ) can be used only with respect to a pair of positive occurrences of t in α and s in β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.3.3</head><p>Then one may wonder whether the following rule suffices for our purposes <ref type="bibr" target="#b4">[5]</ref>:</p><p>α≤β, Monotonic(t,α), Monotonic(t,β) ⇒ µt.α ≤ µt.β</p><p>where Monotonic(t,α) iff t does not occur negatively in α.</p><p>Unfortunately it does not, as we cannot prove inclusions involving negative occurrences, as in µt.t→t ≤µt.®→t. Moreover, one must be careful in defining "t does not occur negatively in α" for recursive types, in order to ensure that α is really monotonic in t (for example, µs.s→t is not monotonic in t): PosAlso(t,t) @ True, PosAlso(t,s) @ False (s≠t) PosAlso(t,®) @ False, PosAlso(t,©) @ False PosAlso(t,α→β) @ NegAlso(t,α) ∨ PosAlso(t,β) PosAlso(t,µs.α) @ (NegAlso(s,α) ∧ tÏFV(α)) ∨ PosAlso(t,α) (s≠t) NegAlso(t,s) @ False (even when s=t) NegAlso(t,®) @ False, NegAlso(t,©) @ False NegAlso(t,α→β) @ PosAlso(t,α) ∨ NegAlso(t,β) NegAlso(t,µs.α) @ (NegAlso(s,α) ∧ tÏFV(α)) ∨ NegAlso(t,α) (s≠t) Monotonic(t, α) @ ¬ NegAlso(t, α) Under these conditions, it is possible to show that the rule above is provable from the system in 5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Completeness of Subtyping Rules.</head><p>In proving the completeness of the subtyping rules w.r.t. the tree ordering, it seems helpful to go through the algorithm. The rather obvious approach of extracting a proof from a successful execution tree is complicated by the lack of correspondence between the computational rule (µ A ) and the rule (µ R ), as the former can be applied repeatedly on the same variable, whereas the latter can be applied at most once.</p><p>One may wonder if it is possible to rearrange the regular systems, while preserving type equivalence, so that during the execution we never have to expand twice the same variable by means of (µ A ).</p><p>Naively this corresponds to a controlled unfolding of the recursive types so that the corresponding µ's appear at the same time in the visit of the trees. For example, to prove µt.t→t ≤ R µ s.(µs'.©→s')→s, we unfold the first type to µt.(µt'.t'→t')→t; note that this is not the unfolding given by the (fold-unfold) rule.</p><p>If ∫ A Σ,ε⊃t≤s (see 4.2.3), we say that (the successful execution tree of) the initial goal Σ,ε⊃t≤s has the one-expansion property iff the following is true: for every tÏDom(ε) and for each path p of the execution tree, t is expanded in a (µ A ) node of p at most once.</p><p>It follows that with one-expansion, each variable can be inserted in Σ in a unique way, so that for each pair of assumptions t 1 ≤s 1 , t 2 ≤s 2 Ï Σ we have that t 1 ,s 1 ,t 2 ,s 2 are pairwise distinct. Moreover, if we consider two (µ A ) nodes Σ,ε⊃t 1 ≤s 1 , Σ,ε⊃t 2 ≤s 2 on the same path then t 1 ,s 1 ,t 2 ,s 2 are pairwise distinct, and if we consider a (µ A ) node Σ,ε⊃t 1 ≤s 1 and an (assmp A ) node Σ,ε⊃t 2 ≤s 2 on the same path then either t 1 7t 2 , s 1 7s 2 or t 1 ,s 1 ,t 2 ,s 2 are pairwise distinct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Lemma (Putting recursions in lockstep)</head><p>If ∫ A Σ,ε⊃t≤s then there are θ, r, u such that ∫ A Σ,θ⊃r≤u, Sol(r,θ) = Sol(t,ε), Sol(u,θ) = Sol(s,ε) and Σ,θ⊃r≤u satisfies the one-expansion property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Given the initial goal Σ,ε⊃t≤s and the related successful execution tree we build a new judgment Σ,θ⊃r≤u such that the following properties hold: (a) Σ,θ⊃r≤u is an initial goal. (b) Sol(r,θ) = Sol(t,ε) and Sol(u,θ) = Sol(s,ε). (c) ∫ A Σ,θ⊃r≤u, and the execution tree is equal to the one for Σ,ε⊃t≤s modulo variable renaming. (d) Σ,θ⊃ r≤u satisfies the one-expansion property.</p><p>First we build the execution tree of Σ,ε⊃t≤s. Then we associate with every node of the tree a couple (r, u) (or (u, r) on negative branches) of fresh variables with the following constraint; with every assumption leaf for t≤s we associate the same pair of variables as with the µ node where the assumption t≤s has been introduced into Σ (if any).</p><p>Next generate θ according to the following cases:</p><p>Case (µ-®). Say we are in the situation: Σ',ε⊃®≤β ⇒ Σ',ε⊃t≤s 0 where ε(t)=® . If (r,u 0 ) is the pair of variables associated with the µ-node add the equations: r=® [u 0 /s 0 ,u 1 /s 1 , ..., u n /s n ](s i =ε(s i )) for iÏ0..n where u 1 ...u n are fresh variables and s 1 ...s n are the variables reachable from s 0 in the system ε, that is {s 1 ...s n } = Reach(s 0 , ε)∩Dom(ε).</p><p>Case (µ-©). Analogous.</p><p>Case (µ-var). Say we are in the situation Σ',ε⊃a≤a ⇒ Σ ',ε⊃t≤s . If (r,u) is the pair of variables associated with the µ-node, we add a pair of equations: r=a, u=a.</p><p>Case (µ-→). Say we are in the situation:</p><p>Σ'∪{t≤s},ε⊃s 1 ≤t 1 , Σ'∪{t≤s},ε⊃t 2 ≤s 2 ⇒ Σ'∪{t≤s},ε⊃t 1 →t 2 ≤s 1 →s 2 ⇒ Σ',ε⊃t ≤ s where we have the fresh variables r,r 1 ,r 2 for t,t 1 ,t 2 and u,u 1 ,u 2 for s,s 1 ,s 2 (the variables associated to an →-node are inessential) then we generate the equations r=r 1 →r 2 and u=u 1 →u 2 .</p><p>Case (µ-assmp1). Say we are in the situation: Σ',ε⊃a≤b ⇒ Σ',ε⊃t≤s where a≤b∈Σ. If (r,u) is the pair of variables associated with the µ-node, we add a pair of equations: r=a, u=b.</p><p>Case (µ-assmp2). Finally, if we visit a node in which we apply the rule (assmp A ) w.r.t. an assumption added during the computation then we do not generate any equation. In fact, the equations corresponding to those variables are defined in the corresponding µ-node in which the assumption was made.</p><p>Let us now consider the properties (a-d): (a) Follows from the use of fresh variables. (b) In the first place one establishes a relation R, say, between the variables reachable from t and those reachable from r. In general we will have a situation in which a variable t may correspond to many variables r 1 ...r n . Next, prove by induction on the lowest level of the appearance of r in the execution tree and |π| that (t, r)ÏR implies Sol(r,θ)(π) = Sol(t,ε)(π). (c) By construction at each step we can apply the same computational rule. (d) This is a consequence of the constraint on the assignment of fresh variables to nodes. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2">Example</head><p>Consider the types: µt.©→t ≤ T ®→(µs.s→s). These types are in minimal form, i.e. they are the smallest types that can describe the corresponding regular trees, but still the recursions are not in lockstep; we need to transform them into more redundant forms, in order to synchronize them. In the following we pedantically apply the procedure described in the proof of the previous lemma.</p><p>Let us assume that the types are described by the canonical system ε: ε @ ε 1 ∪ε 2 , ε 1 @ {t 1 =t 2 →t 1 , t 2 =©}, ε 2 @ {s 1 =s 2 →s 3 , s 2 =®, s 3 =s 3 →s 3 }.</p><p>The following describes the successful execution tree associated to the initial goal ,ε⊃t 1 ≤s 1 : Observe that this execution tree does not have the one-expansion property as the variable t 1 is expanded twice. Hence we start associating fresh variables to each node according to the rules described in the proof. The following describes which rule is being applied at each node of the execution tree, and which pair of fresh variables we associate to each node.</p><formula xml:id="formula_67">(© A ) (assmp A ) ⇒ {t 1 ≤s 1 ,</formula><p>If t7t, s7s then Tree(A ) is Σ∪{t≤s},ε⊃t≤s, and T is taken to be Σ∪{t≤s,t'≤s'},ε'⊃t≤s ⇒ Σ∪{t≤s},ε'⊃t'≤s', which is successful by (assmp A ) and (µ A ), and has one-expansion. This T is longer but it still has depth 0.</p><p>If t,t,s,s are pairwise distinct then Tree(A ) is Σ ∪{t≤s,t≤s},ε⊃t≤s, and T is taken to be Σ∪{t≤s,t≤s},ε'⊃t≤s which is successful by (assmp A ), has one-expansion, and has depth 0.</p><p>For the case (µ A ) we must have, by one-expansion, t,t,s,s pairwise distinct. Then Tree(A) has the shape:</p><p>Σ∪{t≤s,t≤s}, ε ⊃ ε(t)≤ε(s) ⇒ Σ∪{t≤s},ε⊃t≤s with t,sÏDom(ε). Now σ(t)7t, σ(s)7s, and since t,sÏDom(ε') we have ε'(t)=σ(ε(t)), ε'(s)=σ(ε(s)). The tree T is then chosen with the shape: Σ∪{t≤s,t≤s}, ε' ⊃ σ(ε(t))≤σ(ε(s)) ⇒ Σ∪{t≤s}, ε'⊃ t≤s hence preserving success and depth by (µ A ) and the induction hypothesis. One-expansion is preserved because, by induction hypothesis, T expands the same variables in (µ A ) node as Tree(A), which has one-expansion; except that t',s' are expanded in the (assmp A ) case, but in the present situation t,s,t',s' are distinct. The other cases do not pose difficulties. One-expansion for the (→ A ) case follows from oneexpansion of the two branches, since one-expansion is defined path-wise.</p><p>Hence we can apply the induction hypothesis to (B), obtaining:</p><p>∫ R Σ∪{t≤s} ⊃ Üσt 2 ,ε'á ≤ Üσs 2 ,ε'á Then, by the equivalences Üσt 2 ,ε'á= R Üt 2 ,ε\tá, Üσs 2 ,ε'á= R Üs 2 ,ε\sá, and (eq R ), (trans R ):</p><p>∫ R Σ∪{t≤s} ⊃ Üt 2 ,ε\tá ≤ Üs 2 ,ε\sá By a similar argument on Σ∪{t≤s},ε⊃s 1 ≤t 1 we obtain:</p><p>∫ R Σ∪{t≤s} ⊃ Üs 1 ,ε\sá ≤ Üt 1 ,ε\tá Finally:</p><p>⇒ Σ∪{t≤s} ⊃ Üt 1 ,ε\tá→Üt 2 ,ε\tá ≤ Üs 1 ,ε\sá→Üs 2 ,ε\sá (→ R ) ⇔ Σ∪{t≤s} ⊃ Üε(t),ε\tá ≤ Üε(s),ε\sá ⇒ Σ ⊃ µt.Üε(t),ε\tá ≤ µs.Üε(s),ε\sá (µ R ) ⇔ Σ ⊃ Üt,εá ≤ Üs,εá M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.4">Example</head><p>We describe how to associate a proof tree to the execution tree with one expansion property built in 5.4.2, by repeatedly applying the inductive proof just presented. For convenience we rewrite here the execution tree: where: θ" = θ" 1 ∪θ" 2 , σ = [r"/r 3 , u"/u 3 ],</p><formula xml:id="formula_68">(© A ) (assmp A ) ⇒ {r 1 ≤u 1 ,</formula><p>θ" 1 = σ(θ' 1 \r 3 ) ∪ {r"=r 3 } = {r 4 =©, r 6 =©, r'=r 1 , r"=r 3 }, θ" 2 = σ(θ' 2 \u 3 ) ∪ {u"=u 3 } = {u 4 =®, u 6 =u 6 →u 6 , u'=u 1 , u"=u 3 } .</p><p>The first modified subgoal, {r 1 ≤u 1 ,r 3 ≤u 3 },θ"⊃u 6 ≤r 6 , leads to a subcase (© A ). Hence we have:</p><p>∫ R {r 1 ≤u 1 ,r 3 ≤u 3 } ⊃ &lt;u 6 ,θ"&gt; ≤ &lt;r 6 ,θ"&gt;, (b) &lt;u 6 ,θ"&gt; = µu 6 .u 6 →u 6 , &lt;r 6 ,θ"&gt; = ©</p><p>The second modified subgoal, {r 1 ≤u 1 ,r 3 ≤u 3 },θ"⊃r 3 ≤u 3 , leads to a subcase (assmp A ). Hence we have:</p><p>∫ R {r 1 ≤u 1 ,r 3 ≤u 3 } ⊃ &lt;r 3 ,θ"&gt; ≤ &lt;u 3 ,θ"&gt;, (c) &lt;r 3 ,θ"&gt; = r 3 , &lt;u 3 ,θ"&gt; = u 3</p><p>We can now build the proof tree, bottom up, using the proofs (a), (b), (c) as leaves: We will consider the full subcategory of complete and uniform pers, therefore the morphisms are defined as usual as:</p><formula xml:id="formula_69">{r 1 ≤u 1 ,r 3 ≤u 3 } ⊃ µu 6 .u 6 →u 6 ≤ © {r 1 ≤u 1 ,r 3 ≤u 3 } ⊃ r 3 ≤ u 3 {r 1 ≤u 1 ,r 3 ≤u 3 } ⊃ ©→r 3 ≤ (µu 6 .u 6 →u 6 )→u 3 {r 1 ≤u 1 } ⊃ ®≤© {r 1 ≤u 1 } ⊃ µr 3 .(<label>©→r</label></formula><formula xml:id="formula_70">cuper[A, B] @ {f: D ∞ /A→D ∞ /B | Ôφ∈D ∞ .ÓdÏD ∞ . (d,d)ÏA ⇒ φdÏf([d] A ) } where [d] A @ {eÏD ∞ | (d, e)ÏA}, and D ∞ /A @ {[d] A | (d, d)ÏA} Let A |n @ A ∩ i n (D n )×i n (D n ).</formula><p>Given A, B cupers we can define as for ideals (see <ref type="bibr" target="#b19">[20]</ref>): B) , o.w.</p><formula xml:id="formula_71">closeness: c(A,B) @ ∞, if A=B; max{n| A |n =B |n }, o.w. distance: d(A,B) @ 0, if c(A,B) = ∞; 2 -c(A,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Subtype Interpretation</head><p>Following <ref type="bibr" target="#b10">[11]</ref> and <ref type="bibr" target="#b6">[7]</ref> we say that the cuper A is a subtype of the cuper B iff A⊆B. This is easily shown to correspond to the existence of a unique map in the category that is realized by the identity. Such maps play the role of coercions from A to B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Type Interpretation</head><p>A type environment η is a map from type variables to cupers: η: Tvar→ cuper. A type interpretation of a type α in an environment η is written as [α]η.</p><p>In view of the interpretation of subtyping, the interpretation of type variables and type constants is naturally given as follows:</p><formula xml:id="formula_72">[®]η @ {(® D ∞ , ® D ∞ )} [©]η @ D ∞ ×D ∞ 7 Top [t]η @ η(t)</formula><p>As we already mentioned, cuper is a cartesian closed category. In particular, given A, B cupers the exponent B A is defined as follows:</p><p>(f, g) Ï B A ⇔ Ó d,e. (d, e) ÏA ⇒ (fd, ge) Ï B This interpretation of the arrow is sometime referred to as simple.</p><p>In general, every object exp(A, B) isomorphic to the simple interpretation will enjoy the same categorical properties. Therefore, we assume exp is a binary operator on cupers satisfying: exp(A, B) 5 B A However, not any choice will be satisfying from our point of view. In order to complete the interpretation we need two more properties of the operator exp, namely, contractiveness and (anti-)monotonicity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Contractiveness</head><p>The set of cupers endowed with the metric d is a complete metric space. We require that the behavior of exp at level n+1 is determined by the value of the arguments up to level n:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>exp(A, B) |n+1 = exp(A |n , B |n ) |n+1</head><p>Under this condition the exponentiation operator is contractive on the space (cuper, d) as it satisfies the following property:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">F-theory of subtyping</head><p>Rather than giving some abstract definition of model that naively reflects the conditions for the soundness theorem and look for some ad hoc completeness result, we prefer to concentrate on a specific interpretation.</p><p>As a typical example, we characterize the subtypings valid in every F-interpretation. We write ª F α≤β iff for any type structure M constructed as just described, we have [α]η ⊆ [β]η (or equivalently ηª F α≤β) with respect to the induced F-interpretation and for any type environment η.</p><p>In order to prove the completeness of the theory it will be enough to use the elementary substructure of ideals. Ideals are cupers with just one equivalence class; they are closed w.r.t. the standard operations over cupers.</p><p>Consider the type α→©. Both in the simple interpretation and in the F-interpretation its meaning is essentially independent from α (this is not clearly the case for the tree equivalence).</p><p>In particular in the F-interpretation one has:</p><formula xml:id="formula_73">(Φ) α→β ≤ γ→©</formula><p>where γ→© plays the role of supertype of all the functional types as:</p><formula xml:id="formula_74">[γ→©]η = [®→©]η = F 2 ∪ {(®, f), (f, ®), (f, f)}</formula><p>Add to the subtyping system in 3.1 the axiom (Φ). Denote with ∫ Φ formal derivability in this new system. Write α≤ Φ β iff ∫ Φ α≤β.</p><p>By examining the twenty five possible combinations of rules and axioms it turns out that the relation ≤ Φ on the collection of non-recursive types is a preorder (as in 3.1, one shows the transitive rule is derived by case analysis).</p><p>Next, extend the preorder ≤ Φ to recursive types by defining an ordering ≤ Φ∞ on trees as: A ≤ Φ∞ B iff Ók. (A | k ≤ Φ B | k ). Also define: α≤ Φ T β iff Tα≤ Φ∞ Tβ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Lemma</head><p>Let α be a recursive type and η be a type environment. If Tα≠© and for each type variable t free in α we have η(t)≠ Top then [α]η ≠ Top.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on the structure of α. In particular, if α 7 µt.β then either Tα=® and the interpretation is the least cuper, or Tα=t and we can use the hypothesis on η, or the interpretation is a cuper A that solves the equation: A = (G 1 (A) G 2 (A) ) F for some definable operators G 1 and G 2 . This forces A⊂Top. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">Lemma (Separation)</head><p>Suppose D ∞ is an algebraic cpo. There is a type environment η such that whenever α (β) matches an element of the column (row) then [α]η ⊆ [ β]η iff the situation described at the corresponding intersection occurs:</p><formula xml:id="formula_75">≤ ® © s ®→© α'→β' (β'≠©)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>As we already mentioned, it will be enough to consider ideals, that is, subsets of D ∞ with particular closure properties. Let us choose an environment η s.t. η(t) = {®, λ t } where λ t is an element of the flat cpo At. Of course t≠s ⇒ λ t ≠λ s and λ t ≠ f.</p><p>The only interesting problem is to show that in the case (α→β,α'→β') the condition α'≤α, β≤β' is in fact necessary. Note that we use the downward closure property of ideals to prove that the elements greater than or equal to d o do not belong to [α]η. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.4">Proposition (Completeness for ≤ Φ T )</head><p>Given recursive types α and β, ª F α≤β iff α≤ Φ T β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>The soundness follows from the discussion in 6.3.1 and the more general soundness result presented in 6.2.5.</p><p>For showing completeness, consider the type structure and the type environment η in lemma 6.3.3. Given α,β, we want to show Ók. α | k ≤ Φ β | k whenever η ª α≤β.</p><p>Observe that the relation ≤ Φ T is invariant under unfolding and under transformations of types of the shape α→© to ®→©.</p><p>Fix k and unfold the types so that no µ appears before the k-th level. Transform all the subtypes of the shape α→© in ®→©. Proceed by induction on k to show that the conditions in the table <ref type="table">6</ref></p><formula xml:id="formula_76">.3.3 force α | k ≤ Φ β | k . M</formula><p>In the remaining part of the paper we will be concerned with the tree ordering as it is very simple to analyze and it is valid in every interpretation satisfying the conditions of theorem 6.2.5. However, the previous study suggests that the tree ordering is very close to the model ordering so that, for example, the decision algorithm that we discuss in section 4 for the former can be easily adapted to the latter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Coercions</head><p>Coercions and subtyping are closely related topics; see for example <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b5">[6]</ref>. We now show that the standard coercions c α,β between two types α≤β are definable in an extension of the basic calculus. This can be interpreted as saying that subtyping does not add any expressive power to such calculus (only convenience).</p><p>Then we show that the coercions implicit in a calculus with subsumption can be automatically synthesized. This fact is related to an algorithm for inferring the minimum type of a term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Definability.</head><p>In this section we show how to associate with each successful execution tree a λ-term whose denotation in the model is a coercion, that is, the unique map between the corresponding types that is realized by the identity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Building the λ-term.</head><p>We can show that if we consider types up to tree equivalence, = T , then for every initial goal Σ,ε ⊃t≤s such that ∫ A Σ,ε⊃t≤s there is a term M(x 1 , ..., x n ) : Üt→s,εá where Σ = {t 1 ≤s 1 , ..., t n ≤s n } and x i (i=1,..,n) are the free variables of M of type Üt i →s i ,εá.</p><p>For the sake of readability the type labels on bound variables and on the fold and unfold constants are often omitted.</p><p>We recall that it is possible to define a fixpoint combinator as follows: í7λf α→α .(λx µt.t→α . f((unfold x)x)) (fold(λx µt.t→α . f ((unfold x)x))): (α→α)→α.</p><p>Proceed by induction on the structure of the execution tree (see 4.2.1). We refer to 4.1.7 for the properties 1..6, of the translation Ü -,á: Case (assmp) x Üt→s,εá .</p><p>Case (®) λx ® . í(λx Üβ,εá . x) : Ü®→β,εá = T ®→Üβ,εá by 1,5.</p><p>Case (©) λx Üα,εá . í(λx © . x) : Üα→©,εá = T Üα,εá→© by 2,5.</p><p>Case (var) λx a . x : Üa→a,εá = T a→a by 3,5.</p><p>Case (→) λf Üα→β,εá . λx Üα',εá . M 2 (f(M 1 (x))) : Ü(α→β)→(α'→β'),εá by 5.</p><p>where by induction hypothesis M 2 : Üβ→β',εá and M 1 : Üα'→α,εá.</p><p>Case (µ) by induction hypothesis we have M(x Üt→s,εá ) : Üε(t)→ε(s), εá; by 4, 5 Üt→s,εá = T Üε(t)→ε(s), εá therefore we can type a term: í(λy Üε(t)→ε(s), εá . M(y)) : Üε(t)→ε(s), εá = T Üt→s,εá, by 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark</head><p>In a similar fashion one can associate a λ-term with a proof of the judgment Γ⊃α≤β in the system in 5.3 . The only difficulty arises for the rule (µ R</p><p>). Suppose we have inductively built a term M(x t→s ) : α(t)→β(s) then it is possible to transform it into a term M'(x µt.α→µs.β ) : [µt.α/t]α→[µs.β/s]β. The term associated with the conclusion of the (µ R ) rule can be defined as: í(λx µt.α→µs.β . λy µt.α . (fold (M''(x)(unfold y))))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Proposition (Coercions are definable)</head><p>Let α, β Ï Type and suppose α≤ A β. Let M be the term associated in 7.1.1 with the execution tree of ,Eα∪Eβ ⊃ α*≤β*. Then the denotation of the term in the model is the unique coercion map from the interpretation of α to the interpretation of β. Proof.</p><p>Since we have not given the term interpretation explicitly (see <ref type="bibr" target="#b0">[1]</ref>), we can only sketch an idea of the proof.</p><p>In the first place we need some facts about the interpretation of terms: (a) By erasing the type information and the constants fold, unfold from a typed term M, we obtain an untyped λ-term er(M). We denote these untyped λ-terms with P, Q, ... . It is a basic property of these interpretations that the interpretation of er(M) gives a representative for the equivalence class that corresponds to the interpretation of M. We shortly refer to this fact by saying that er(M) is a realizer for M. (b) Showing that the interpretation of M is a coercion from α to β means proving that the identity map, id, is a realizer for M. Equivalently id and er(M) are equivalent in α→β. Note that here and in the following for the sake of readability we simply refer to syntactic objects but we really intend to speak of their denotations in the model. (c) The realizer for í is an element Fix with functionality: λg. $ g n (® D ∞ ).</p><p>In order to prove the theorem by induction on the structure of the execution tree one needs to generalize somewhat.</p><p>In the first place one observes that if in the execution tree of ,ε⊃t≤s we never use (assmp) then the interpretation of the associated term M : Üt→s,εá is a coercion in Üt→s,εá.</p><p>However, this is not enough to make the induction go through in the case where the term M(x Σ ) really depends on the assumption variable. One has to observe that M(x Σ ) also enjoys a property of contractiveness.</p><p>Let us suppose that (µ) is the last rule applied. By construction assume we have a term M(x) that is a functional from coercions to coercions. We would like to show that í(λx.M(x)) is still a coercion.</p><p>Observe that after a (µ) rule we always have a (→) rule. Therefore the term M(x) has the structure λf.λy.M 2 (x)(f(M 1 (x)y)). Now observe that a realizer for í (λx.M(x)) will be something like $g n (® D ∞ ) for g=λx.λf.λy.P 2 (x)(f(P 1 (x)y)) where P i is a realizer for M i (i=1,2). We have to show that this realizer is equivalent to id in a type with the structure C7(A⇒B)⇒(A'⇒B'), where A⇒B 7 exp(A, B). Since the type is a complete per, it will be enough to show that for each n g n (® D ∞ ) is equivalent to id in the appropriate type.</p><p>To do this we need a last remark, Denote with A |n the approximation at the n-th level of the cuper A as in 6.2. One observes that if (P, id)Ï C |n then (g(P), id) Ï C |n+1 . This follows easily from the structure of g and the assumption (6.2.3). Hence we have Ón. (g n (® D ∞ ), id)ÏC |n that implies ($g n (® D ∞ ), id)ÏC. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>We have used a subtyping relation based on infinite trees as the central concept of our work. In our experience this relation has arisen naturally, giving insights about both the subtypings valid in certain per-models and the behavior of the Amber implementation. In fact we have shown that this relation can be used to characterize sound and complete theories for a certain class of per models and that it can be simply and efficiently implemented. We have also shown the soundness and completeness of certain rules and the definability of coercions within the calculus (modulo a strengthening of the notion of type equality). Finally, we have observed that the whole process of inferring coercions and minimal types can be automated.</p><p>In conclusion, let us consider the problem of the extension of our results. The notions of tree expansion and finite approximation (section 3) can be easily adapted to larger languages, both with first-order type constructors like products, sums, records and variants, and with higher-order type constructors like second-order universal quantification. The important point is that the tree resulting from the expansion is regular. Under this assumption it seems possible to adapt algorithms and rules to obtain results of soundness and completeness (sections 4, 5). Caution is necessary in extensions to bounded quantification since some of those systems are undecidable <ref type="bibr" target="#b23">[24]</ref>.</p><p>About the relationship between the tree ordering and the model, we expect the extension of the soundness theorem (6.2) to be straightforward. On the other hand we expect technical problems from the completeness theorem (6.3) when introducing higher-order type constructors like second-order universal quantification. In particular, in this case, it is not clear how to extend the separation lemma <ref type="bibr">(6.3.3)</ref>.</p><p>The result on the definability of the coercions has already been obtained for several calculi with records, variants, and bounded quantification (but without recursion). It is a reassuring result that shows that the subtyping theory is in good harmony with the calculus.</p><p>The fact that terms have a least type has a clear impact on the implementation of the typechecker. This appears to be a very desirable property towards an automatic treatment of coercions. The result, at the present state of the art, clearly relies on the structural properties of the subtyping relation.</p><p>Finally, we observe that challenging extensions arise when dealing with non-ground collections of subtyping assumptions (see <ref type="bibr" target="#b2">[3]</ref>). In this case much work remains to be done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Acknowledgments</head><p>We would like to thank Martín Abadi for comments on an early draft, and the referees for their efforts in improving the presentation of the paper.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>α = µs.Int→s = Int→(µs.Int→s) = Int→Int→(µs.Int→s) = Int→Int→α β = µt.Int→Int→t = Int→Int→(µt.Int→Int→t) = Int→Int→β which after a few unfoldings leaves us with the original problem of determining whether α=β.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Finally, define the 3 . 3 . 1 T</head><label>331</label><figDesc>collection of finite trees, Tree fin (L), as follows:Tree fin (L) @ {A Ï Tree(L) | Ôk. ∀π∈ω*. |π|&gt;k ⇒ A(π) ¶}Remarks induces a bijection between Tree fin (L) and non-recursive types. We denote its inverse with T -1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Conditions 1, 2, 3, 5 follow by definition. Condition 4 follows from Sol(t,ε) = Sol(ε(t),ε) and part (1). Condition 6 follows from prop. 4.1.5 and part (1): Tα = Sol(α*, Eα) = TÜα*, Eαá. M</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Σπε ⇒ ∫ A Σ,ε ⊃ α *≤β* by induction on the structure of α and β. Case α7®. Then ε = {α*=®}∪Eβ. Take any Σ s.t. Σπε: ⇒ Σ∪{α*≤β*},ε ⊃ ε(α*)≤ε(β*) by (® A ) since ε(α*)=® ⇒ Σ,ε ⊃ α*≤β* by (µ A ) since α*,β*ÌVars(Σ)Cases α7©, α7a. Similar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>3 )( 3 )</head><label>33</label><figDesc>≤ µu 3 .((µu 6 .u 6 →u 6 )→u 3 ) {r 1 ≤u 1 } ⊃ (©→µr 3 .(©→r 3 )) ≤ (®→µu 3 .((µu 6 .u 6 →u 6 )→u 3 ))  ⊃ µr 1 .(©→µr 3 .(©→r 3 )) ≤ µu 1 .(®→µu 3 .((µu 6 .u 6 →u 6 )→u 3 )) It just remains to observe the following equivalences to get back to the types we started with in 5.4.2: µr 1 .(©→µr 3 .(©→r 3 )) = R ©→µr 3 .(©→r 3 ) = R µr 3 .(©→r 3 ), and µu 1 .(®→µu 3 .((µu 6 .u 6 →u 6 )→u 3 )) = R ®→µu 3 .((µu 6 .u 6 →u 6 )→u 3 ) = R ®→(µu 6 .u 6 →u 6 ) . M If (e,e') Ï A then Ón. (e n , e' n ) Ï A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>First</head><label></label><figDesc>observe that [β]η ⊆ [β']η . Otherwise pick up d∈[β]η\[β']η and consider the constant map λx.d that belongs to [α→β]η\[α'→β']η. On the other hand, since β'≠© by lemma 6.3.2 ÔeÏTop\[β']η. If the set [α']η\[α]η is not empty then it contains a compact element d o . Consider the continuous function step d o ,e that evaluates to e for elements greater than or equal to d o , and to ® otherwise. Then such a function belongs to [α→β]η\[α'→β']η.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>denote with p[t 1 ...t k ] for pÏL\{t 1 ...t k } a type in Tp of the form p(u 1 ..u #p ), where #p is the arity of p, and {u 1 ..u #p } ⊆ {t 1 ...t k }. Assume, by induction hypothesis, that Eα={t i+1 =p i [t 2 ...t n+1 ] | iÏ1..n}, α * = t 2 , Eβ={t n+1+j =q j [t n+2 ...t n+m+1 ] | jÏ1..m}, and β*=t n+2 . (We require here that t 1 , t 2 ...t n+1 , and t n+2 ...t n+m+1 are disjoint variables not appearing in the original α; otherwise a consistent renaming must be performed.) Then Eγ is the following system and γ*@t 1 : t 1 = r 1 [t 1 ...t n+m+1 ] 7 t 2 →t n+2 , t 2 = r 2 [t 1 ...t n+m+1 ] 7 p 1 [t 2 ...t n+1 ] ... t n+1 = r n+1 [t 1 ...t n+m+1 ] 7 p n [t 2 ...t n+1 ] t n+2 = r n+2 [t 1 ...t n+m+1 ] 7 q 1 [t n+2 ...t n+m+1 ] ... t n+m+1 = r n+m+1 [t 1 ...t n+m+1 ] 7 q m [t n+2 ...t n+m+1 ] The property Sol(γ*, Eγ)=Sol(t 1 , Eγ)=Sol(t 2 →t n+2 , Eγ)=Sol(t 2 , Eα)→Sol(t n+2 , Eβ)=Tγ follows easily from the induction hypothesis. Case γ7µt.α→β. Let γ '=[γ/t]α→[γ/t]β (of course Tγ '=Tγ). As in the previous case, assume Eα={t i+1 =p i [t 2 ...t n+1 ] | iÏ1..n}, α*=t 2 , Eβ={t n+1+j =q j [t n+2 ...t n+m+1 ] | jÏ1..m} and β*=t n+2 . Then Eγ is the following system and γ*@t 1 : t 1 = r 1 [t 1 ...t n+m+1 ] 7 t 2 →t n+2 t 2 = r 2 [t 1 ...t n+m+1 ] 7 t 2 →t n+2 |p 1 [t 2 ...t n+1 ] ... t n+1 = r n+1 [t 1 ...t n+m+1 ] 7 t 2 →t n+2 |p n [t 2 ...t n+1 ] t n+2 = r n+2 [t 1 ...t n+m+1 ] 7 t 2 →t n+2 |q 1 [t n+2 ...t n+m+1 ] ... t n+m+1 = r n+m+1 [t 1 ...t n+m+1 ] 7 t 2 →t n+2 |q m [t n+2 ...t n+m+1 ] By t 2 →t n+2 |p i [t 2 ...t n+1 ] we denote t 2 → t n+2 if p i 7t, and p i [t 2 ...t n+1 ] otherwise. Analogously, t 2 →t n+2 |q j [t n+2 ...t n+m+1 ] denotes t 2 →t n+2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1 ,ε\t'á→Üt' 2 ,ε\t'á.If nπ is the current path, we can apply the inductive hypothesis on the shorter path π w.r.t.: (i) the variables t', t' i , (i=1,2) and the system ε to show:TÜt' i ,εá(π) = T([Üt',εá/t']Üt' i ,ε\t'á(π) . (ii) the variables t', t' i , (i=1,2) and the system ε\t to show:TÜt' i ,ε\tá(π) = T[Üt',ε\tá/t'](Üt' i ,ε\t\t'á )(π) . (iii) the variables t, t' i , (i=1,2) and the system ε to show:T[Üt,εá/t]Üt' i ,ε\tá(π) = TÜt' i ,εá(π). Finally we use the substitutivity of the T operation, T[γ/t]δ = [Tγ/t]Tδ, to conclude Tα=Tβ.</figDesc><table><row><cell>and</cell><cell>Tα =</cell><cell>→</cell></row><row><cell></cell><cell>/</cell><cell>\</cell></row><row><cell></cell><cell cols="3">T([Üt',εá/t']Üt' 1 ,ε\t' á T([Üt',εá/t']Üt' 2 ,ε\t' á</cell></row><row><cell>Also:</cell><cell cols="3">β 7 [Üt,εá/t]Üt', ε\tá = [Üt,εá/t]µt'. Üt' 1 ,ε\t\t'á→Üt' 2 ,ε\t\t'á =</cell></row><row><cell>So:</cell><cell cols="3">= [Üt,εá/t] ([Üt',ε\tá/t'](Üt' 1 ,ε\t\t'á→Üt' 2 ,ε\t\t'á ) ). Tβ = →</cell></row><row><cell></cell><cell></cell><cell>/</cell><cell>\</cell></row><row><cell></cell><cell cols="2">T[Üt,εá/t] ([Üt',ε\tá/t'](Üt' 1 ,ε\t\t'á ))</cell><cell>T[Üt,εá/t] ([Üt',ε\tá/t'](Üt' 2 ,ε\t\t'á ))</cell></row><row><cell cols="2">Subcase tÏDom(ε), t'ÌDom(ε):</cell><cell></cell></row><row><cell>Say: Then:</cell><cell cols="3">ε(t) = t 1 →t 2 . TÜt', εá = t' T([Üt,εá/t]Üt', ε\tá) = T([Üt,εá/t] t' = t'.</cell></row><row><cell cols="2">Subcase tÌDom(ε), t'ÏDom(ε):</cell><cell></cell></row><row><cell>Say:</cell><cell>ε(t') = t' 1 →t' 2 .</cell><cell></cell></row></table><note><p><p><p>Then:</p>T([Üt,εá/t]Üt', ε\tá) = T([t/t]Üt', ε\tá) = TÜt', ε\tá = TÜt', εá. Subcase tÌDom(ε), t'ÌDom(ε):</p>Then: T([Üt,εá/t]Üt', ε\tá) = T [t/t] t' = Tt' = TÜt', εá</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Similar to the case α7®.</figDesc><table><row><cell>Case (µ A ). Then the second step is (→ A ), that is also β7β'→β" with {α*≤β*},ε ⊃ β'*≤α'* and {α*≤β*},ε ⊃ α"*≤β"*, where ε = {α*=α'*→α"*}∪{β*=β'*→β"*}∪ε'∪ ε" and ε' @ Eα'∪Eβ' and ε" @ Eα"∪Eβ". Since α,β contain no µ, Reach(β'*→α'*,ε)∩(Dom(ε")∪{α*,β*})=. By a simple analysis we have: ∫ A {α*≤β*},ε'∪ ε"⊃β'*≤α'*. By ε-strengthen ∫ A {α*≤β*},ε'⊃β'*≤α'*. Similarly, ∫ A {α*≤β*},ε"⊃α"*≤β"*. Now, by Σ-strengthen ∫</cell></row></table><note><p>A ,ε' ⊃ β'*≤α'* and ∫ A ,ε" ⊃ α"*≤β"*. By induction hypothesis β'≤ T α' and α"≤ T β"; hence α'→α"≤ T β'→β". M</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>From 4.3.4 we have: α≤ A β ⇒ Ók.α | k ≤ A β | k . From 4.3.3 and the definition of ≤ T we have: Ók.α | k ≤ fin β | k and α≤ T</figDesc><table><row><cell>β. M</cell></row><row><cell>4.3.6 Lemma (Faithfulness of ≤ A w.r.t. paths)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>t 1 ≤s 3 },ε⊃s 3 ≤t 2 ⇒ {t 1 ≤s 1 ,t 1 ≤s 3 },ε⊃t 1 ≤s 3 (® A ) ⇒ {t 1 ≤s 1 ,t 1 ≤s 3 },ε⊃t 2 →t 1 ≤s 3 →s 3 ⇒ {t 1 ≤s 1 },ε⊃s 2 ≤t 2 ⇒ {t 1 ≤s 1 },ε⊃t 1 ≤s 3 ⇒ {t 1 ≤s 1 },ε⊃t 2 →t 1 ≤s 2 →s 3 ⇒ ,ε⊃t 1 ≤s 1</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>r 3 ≤u 3 },θ⊃u 6 ≤r 6 ⇒ {r 1 ≤u 1 ,r 3 ≤u 3 },θ⊃r 3 ≤u 3 (® A ) ⇒ {r 1 ≤u 1 ,r 3 ≤u 3 },θ⊃r 6 →r 3 ≤u 6 →u 3 ⇒ {r 1 ≤u 1 },θ⊃u 4 ≤r 4 ⇒ {r 1 ≤u 1 },θ⊃r 3 ≤u 3 ⇒ {r 1 ≤u 1 },θ⊃r 4 →r 3 ≤u 4 →u 3 ⇒ ,θ⊃r 1 ≤u 1 where θ = θ 1 ∪θ 2 , with: θ 1 = {r 1 =r 4 →r 3 , r 4 =©, r 3 =r 6 →r 3 , r 6 =©}, θ 2 = {u 1 =u 4 →u 3 , u 4 =®, u 3 =u 6 →u 3 , u 6 =u 6 →u 6 } Proceeding from the root we first fall on an inductive case. Hence we reapply the procedure to the modified subgoals: {r 1 ≤u 1 },θ'⊃u 4 ≤r 4 {r 1 ≤u 1 },θ'⊃r 3 ≤u 3 where: θ' = θ' 1 ∪θ' 2 , σ = [r'/r 1 , u'/u 1 ], θ' 1 = σ(θ 1 \r 1 ) ∪ {r'=r 1 } = {r 4 =©, r 3 =r 6 →r 3 , r 6 =©, r'=r 1 }, θ' 2 = σ(θ 2 \u 1 ) ∪ {u'=u 1 } = {u 4 =®, u 3 =u 6 →u 3 , u 6 =u 6 →u 6 , u'=u 1 }.The first modified subgoal, {r 1 ≤u 1 },θ'⊃u 4 ≤r 4 , leads to a subcase (® A ). Hence we have:∫ R {r 1 ≤u 1 } ⊃ &lt;u 4 ,θ'&gt; ≤ &lt;r 4 ,θ'&gt;, &lt;u 4 ,θ'&gt; = ®, &lt;r 4 ,θ'&gt; = © (a)The second modified subgoal, {r 1 ≤u 1 },θ'⊃r 3 ≤u 3 , leads again to an inductive case. Hence we generate two new modified subgoals: {r 1 ≤u 1 ,r 3 ≤u 3 },θ"⊃u 6 ≤r 6 {r 1 ≤u 1 ,r 3 ≤u 3 },θ"⊃r 3 ≤u 3</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Conventions: @ stands for equality by definition; 7for abbreviation or syntactic identification; ∫ precedes a judgment provable in a certain formal system; ⊃ is the linguistic implication; ⇒ is the metalinguistic implication; [U/x]V denotes the substitution of U for x in V.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Given a path in ω *, we can define a (partial) access function that returns the node corresponding to that path in a graph, but skipping over Rec nodes: GT : Graph→Tree(L) (Where Tree(L) = ω*îïÕL, section 3.3) GT(l,S)(nil) @ if S(l) = Rec(l') then GT(l', S)(nil) if S(l) = Bot then ® if S(l) = Top then © if S(l) = Var(t) then t if S(l) = Arrow(l',l") then → GT(l, S)(0.s) @ if S(l) = Rec(l') then GT(l', S)(0.s) if S(l) = Arrow(l',l") then GT(l',S)(s) else ¶ GT(l,S)(1.s) @ if S(l) = Rec(l') then GT(l',S)(1.s) if S(l) = Arrow(l',l") then GT(l",S)(s) else ¶ GT(l,S)(n+2.s) @ ¶ We now show that Alloc is correct, and that the initial state S is irrelevant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Proposition</head><p>Óα∈µTp. ÓS,l',S'. Alloc(α,S,[]) = l',S' ⇒ GT(l',S')=Tα Proof <ref type="bibr">(sketch)</ref> If lÌdom(S) then S[l=v] is a single extension of S. S' is an extension of S if it is S, or if it is the single extension of an extension of S.</p><p>We indicate by S + an arbitrary (finite) extension of S. Note that:</p><p>If lÏdom(S) then S(l) = S + (l). If Alloc(α, S, e) = l',S' then l'Ïdom(S') and S' is an extension of S. ÓS + . lÏdom(S) ⇒ GT(l,S) = GT(l,S + ).</p><p>To obtain the proposition, we need to prove a stronger statement:</p><p>Óα∈µTp. Ón≥0. ÓS,m 1 ..m n ,α 1 ..α n ,l',S',π. Alloc(α,S,[t i =m i ]) = l',S' ∧ (Óπ' s.t. |π'|≤|π|. ÓS + . GT(m i ,S + )(π')=Tα i (π') for all iÏ1..n) ⇒ ÓS' + . GT(l',S' + )(π)=T([α i /t i ]α)(π)</p><p>The proof is then by induction on |π|; the hard case is π=i.s, iÏ{0,1}, and α 7 µt.α'→α". M </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Reduction to Canonical Form</head><p>It easy to show that any recursive type is provably equivalent (= R ) to a type in canonical form. The strategy can be described as follows:</p><p>(a) Use unfold to get rid of all µ's that do not bind any variable. (b) Use µ-contraction to reduce sequences of µ's to one µ. (c) Use µ-® to reduce to ® all subtypes of the shape µt.t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Completeness of Equivalence Rules</head><p>By the strong connection between regular trees and recursive types we show that any time two recursive types α, β have the same tree expansion Tα=Tβ, then we can conclude ∫ α=β.</p><p>First we show how to solve systems of type equations. Then we introduce the notion of equational characterization of a type; that is, how to characterize a type by a system of type equations. Finally we use equational characterizations to prove the completeness theorem.</p><p>In this section we use the following notation. If γ has free variables {u 1 ..u p } ⊆ {t 1 ..t n }, then we write γ[α 1 ...α n ] for the substitution [α 1 /t 1 ... α n /t n ]γ. In particular, γ[t 1 ...t n ] emphasizes a superset of the free variables of γ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Lemma (A system of equations has a solution, by iterated elimination)</head><p>Every system of n equations in n variables:</p><p>.n) has a solution in the congruence induced by the axiom (fold-unfold). That is, there are α 1 ...α n such that ∫ α i =γ i [α 1 ...α n ] (iÏ1..n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on n. Case n=1. Given the equation t=γ</p><p>(iÏ1..n-1) which by inductive hypothesis has solution α 1 ...α n-1 , that is :</p><p>Now take α n 7 µt n .γ n [α 1 ...α n-1 t n ] and check that α 1 ...α n is a solution for the original system. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Lemma (A system of contractive equations has a unique solution)</head><p>Assume that, for iÏ1..n, we have two sets of types α i , β i , related by two systems of equations:</p><p>ßtj for i,jÏ1..n. Then, for all i: ∫ α i =β i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on n. Node contexts provide a convenient meta-notation for nodes whose children are all type variables. For example, the type →(r,r) can be denoted by the node context →[r] or (redundantly) by →[r,s,t], and the type →(r,s) by →[s,r] among others.</p><p>Note that a node context p[t 1 ...t n ] is contractive in each t i , because either t i is prefixed by p or does not occur in the type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">Definition</head><p>A type α∈Type is equationally characterized (eq. char.) if there are types α 1 ..α n with α7α </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5">Lemma (Building an equational characterization)</head><p>Every term α∈Type has an equational characterization such that all equations are reachable from the first one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>The construction is basically the same as the one in 4.1.5. It is enough to prove by induction on the structure of γ that every term in µTp is equationally characterized. Then the lemma follows by 5.1.3, and by the invariance of equational characterization modulo provable equivalence. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.6">Lemma</head><p>Assume Tα=Tβ and ∫ α=p(α 1 ..α #p ), ∫ β=q(β 1 ..β #q ), where p,q Ï L. Then p=q and Tα i =Tβ i for all i Ï 1..#p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By soundness, Tα=Tp(α 1 ..α #p ) and Tβ=Tq(β 1 ..β #q ). Hence, p=q and Tα i =Tβ i by definition of T. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.7">Theorem (Completeness of type equivalence rules)</head><p>If Tα=Tβ then α= R β Proof</p><p>The idea of the proof is as follows: given α and β such that Tα=Tβ we produce their corresponding equational characterizations, say ec(α) and ec(β). By a collapse of "equivalent" equations we derive a new equational characterization ec(γ). The solutions of the (smaller) system associated with ec(γ) can be replicated to produce solutions for the systems associated with ec(α) and ec(β). Hence we can apply twice Lemma 5.2.2 (uniqueness of solutions) and then transitivity to conclude α= R β.</p><p>Let Tα=Tβ; by Lemma 5.2.5, α,β are equationally characterized by α i , t i =p i [t 1 ...t n ] and β j , t j =q j [t 1 ...t m ] so that all equations are reachable from the first ones.</p><p>From these α i ,β j we generate a sequence of pairs (A h ,B h ) where A h ,B h are equivalence classes of α i and β j respectively. Moreover, for each h, α i1 ,α i2 ÏA h , and β j1 ,β j2 ÏB h , we shall have the invariant Tα i1 =Tα i2 =Tβ j1 =Tβ j2 . We start with the pair (A 1 ,B 1 ) 7 ({α},{β}). At each step we consider all the pairs α i ,β j such that α i ÏA h and β j ÏB h for some h. We indicate by α (i',i") some α i depending on both i' and i"; similarly for β (j',j") . If α i = p i (α (i,1) ...α (i,#p i ) ) and β j = q j (β (j,1) ...β (j,#q j ) ), we have, by Lemma 5.2.6, p i =q j and Tα (i,1) =Tβ (j,1) ... Tα (i,#p i ) =Tβ (j,#p i ) . We add all the pairs (α',β')Ï{(α (i,1) ,β (j,1) ),..., (α (i,#p i ) ,β (j,#p i ) )} in the following way, respecting the invariant above:</p><p>-if α'ÏA h and β'ÏB h for some h, then nothing is done; -else, if α'ÏA h1 , and β'ÏB h2 , with h1≠h2, then we replace the pairs (A h1 ,B h1 ) and (A h2 ,B h2 ) by (A h1 ∪A h2 ,B h1 ∪B h2 ); -else, if α'ÏA h we replace the pair (A h ,B h ) by (A h ,B h ∪{β'}); -else, if β'ÏB h we replace the pair (A h ,B h ) by (A h ∪{α'},B h ); -else we add a new pair ({α'},{β'}).</p><p>We stop when the list of pairs no longer changes. This process terminates because there are at most n †m pairs to consider.</p><p>The process above produces two partitions of α i and β j of size k≤n, k≤m, for some k. These are total partitions since all equations are reachable from the first ones. These partitions determine two functions σ:1..n→1..k and π:1..m→1..k such that:</p><p>Given these partitions, we now define a system of k equations t h = r h [t 1 ..t k ], which will turn out to be equivalent both to the p i and the q j systems. For hÏ1..k we have:</p><p>We denote with Γ a set {t 1 ≤s 1 , ..., t n ≤s n } of subtyping assumptions on type variables. We write a subtype judgment as: Γ ⊃ α≤β. Define a formal system for deriving this kind of judgments as follows; this is based on the α = β congruence in 5.1:</p><p>with t only in α; s only in β; t,s not in Γ</p><p>We say α≤ R β if we can derive  ⊃ α ≤ β. The last rule was proposed in <ref type="bibr" target="#b9">[10]</ref> in the specification of the Amber programming language as a first attempt to define a theory for the subtyping of recursive types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Proposition (Soundness of the rule ordering w.r.t. the tree ordering)</head><p>If α≤ R β then α≤ T β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>We prove the more general statement: The proof goes by induction on the length of the derivation ∫ R . The only interesting cases arise for (µ R ) and (eq R ).</p><p>For brevity we write lists such as t 1 ≤s 1 , ..., t n ≤s n in the form t i ≤s i for a free i.</p><p>Case (µ R ) {t i ≤s i , t≤s} ⊃ α≤β ⇒ {t i ≤s i } ⊃ µt.α ≤ µs.β with tÌFV(β); sÌFV(α); t,s ≠ t i ,s i for any i. By induction hypothesis:</p><p>Applying the induction hypothesis with α=α n , β=β n we obtain α n+1 ≤ T β n+1 for every n.</p><p>For every k we can then choose an n sufficiently large so that:</p><p>n is found by examining how t and s occur in α and β). Hence, by definition of ≤ T for recursive types, we have shown:</p><p>We now compute the new type environment θ = θ 1 ∪θ 2 , where: </p><p>We finally compute the successful execution tree, with one expansion property, associated to the initial goal ,θ⊃r 1 ≤u 1 : </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.3">Lemma (From the execution tree to the proof tree)</head><p>If ∫ A Σ,ε⊃t≤s (see 4.2.3) and its execution tree has the one-expansion property, then ∫ R Σ ⊃ Üt,εá ≤ Üs,εá.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>We proceed by induction on the depth k of the successful execution tree of an initial goal Σ,ε⊃t≤s (see 4.2). Depth is measured by the number of adjacent pairs of nodes (µ A )-(→ A ) in the longest branch from the root. In the inductive case, each subgoal is converted into an initial goal of the same depth, in order to apply the induction hypothesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case k=0.</head><p>The tree consists of a (µ A ) root (since the goal is initial) and a single leaf which is either (assmp A ), (® A ), (© A ), or (var A ). Then after the application of the (µ A ) rule, with s,tÏDom(ε), we are in a terminal case Σ∪{t≤s},ε ⊃ ε(t)≤ε(s).</p><p>Subcase (assmp A ). Σ∪{t≤s},ε ⊃ a≤b, where ε(t)=a, ε(s)=b, and a≤b∈Σ.</p><p>Then a,bÌDom(ε) (by definition of Tenv), and Üt,εá=µt.a=a, Üs,εá=µs.b=b.</p><p>Conclude by (eq R ): ∫ R Σ ⊃ µt.a≤a, ∫ R Σ ⊃ b≤µs.b, and (trans R ).</p><p>Subcase (® A ). Σ∪{t≤s},ε ⊃ ®≤ε(s), where ε(t)=®.</p><p>Then Üt,εá=µt.®=® and we have ∫ R Σ ⊃ ® ≤ Üs,εá.</p><p>Conclude by (eq R ) and (trans R ).</p><p>Subcase (© A ). Similar.</p><p>Subcase (var A ). Σ∪{t≤s},ε ⊃ a≤a, where ε(t)=ε(s)=a and aÌDom(ε). Then Üt,εá=µt.a=a=µs.a=Üs,εá. We can apply (eq R ): Σ ⊃ a≤a, then conclude with (eq R ) and (trans R ).</p><p>Case k&gt;0.</p><p>The tree has a (µ A ) root with a (→ A ) child, hence ε(t)=t 1 →t 2 , ε(s)=s 1 →s 2 , where by definition of Tenv t 1 ,t 2 ,s 1 ,s 2 ÏDom(ε):</p><p>We initially focus on one of the subgoals of depth k-1: (A) Σ∪{t≤s},ε⊃t 2 ≤s 2 Let us consider the following goal (B), which we intend to subject, instead of (A), to the induction hypothesis:</p><p>(B) Σ∪{t≤s}, ε'⊃ σ(t 2 )≤σ(s 2 ) where σ@[t'/t, s'/s] is a substitution with fresh variables t' and s', and ε' @ σ(ε\t\s)∪{t'=t, s'=s}.</p><p>First we show that the goal (B) is initial. Since ∫ A Σ,ε⊃t≤s is initial we have:</p><p>Vars(Σ)∩Dom(ε)= ε=ε 1 ∪ε 2 with Dom(ε 1 )∩Dom(ε 2 )=, such that tÏDom(ε 1 ), sÏDom(ε 2 )</p><p>Hence we also have: t 1 ,t 2 ÏDom(ε 1 ) (only); s 1 ,s 2 ÏDom(ε 2 ) (only) ε'=ε' 1 ∪ε' 2 where ε' 1 @σ(ε 1 \t)∪{t'=t}, ε' 2 @σ(ε 2 \s)∪{s'=s}</p><p>From which we conclude: Vars(Σ∪{t≤s})∩Dom(ε')= Dom(ε' 1 )∩Dom(ε' 2 )= σ(t 2 )ÏDom(ε' 1 ), because: if t 2 7t then σ(t 2 )7t' and t'ÏDom(ε' 1 ); (t 2 7s is not possible) if t 2 ?t then σ(t 2 )7t 2 ; since t 2 ÏDom(ε 1 ), we have σ(t 2 )ÏDom(ε' 1 ) σ(s 2 )ÏDom(ε' 2 ), similarly.</p><p>Second, let Tree(A) be the execution subtree of root (A), and Tree(B) be the execution tree of root (B). We show, by induction on the length of the longest path in Tree(A), that we can build a tree T such that: (1) T has the same depth as Tree(A); (2) T succeeds; (3) T expands the same variables as Tree(A) in (µ A ) nodes, with the exception of t',s'; (4) T has the one-expansion property; and (5) T = Tree(B). (Hence, we also have ∫ A (B).)</p><p>We proceed by induction on each subgoal A = Σ∪{t≤s},ε⊃α≤β of Tree(A), for which we build a subtree T of the shape Σ∪{t≤s},ε'⊃σ(α)≤σ(β).</p><p>For the case (assmp A ) we have Σ∪{t≤s},ε⊃t≤s with t≤sÏΣ∪{t≤s}. By the properties of oneexpansion noted in 5.4, we only need to consider the cases when either t7t and s7s, or t,s,t,s are pairwise distinct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.5">Theorem (Completeness of the subtyping rules)</head><p>If α≤ T β then α≤ R β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>If α≤ T β then α≤ A β by completeness of the algorithm (4.3.7). Consider the corresponding successful execution tree and apply the lockstep recursion lemma 5.4.1, obtaining a tree for α'≤ A β' with α= T α' and β= T β'. By lemma 5.4.3 we can now extract from the new execution tree a proof of α'≤ R β'. Applying the completeness of the rules for type equivalence we conclude α= R α' and β= R β'. Finally we derive α≤ R β by (eq R ) and (trans R ). M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">A Per Model</head><p>We sketch the main features of a model described in <ref type="bibr" target="#b0">[1]</ref> (see also <ref type="bibr" target="#b13">[14]</ref> for a related work) based on complete uniform pers over a D ∞ λ-model <ref type="bibr" target="#b25">[26]</ref>.</p><p>Per (partial equivalence relation) models provide an interpretation of subtyping as settheoretic containment of the relations <ref type="bibr" target="#b6">[7]</ref>. In addition, these structures have very interesting categorical properties (in particular cartesian closure and interpretation of second-order quantification as intersection, see <ref type="bibr" target="#b18">[19]</ref>) that entail a satisfying interpretation of higher-order typed λ-calculi. The particular class of pers considered here preserves the previous properties while providing a solution of recursive domain equations up to equality. This result is obtained by an application of Banach's theorem on the uniqueness of the fixpoint of a contractive operator over a complete metric space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Realizability Structure</head><p>Consider the functor G(D) @ D D + D×D + At defined in the category of complete partial orders (cpo's) and projection pairs. The cpo At is a collection of atomic values, and + is the coalesced sum. The morphism part of G is standard.</p><p>The cpo D ∞ is the initial fixpoint of the functor G, that is the colimit of the following ωdiagram:</p><p>with uniquely determined projection pairs (i n,n+1 ,j n+1,n ) : D n →D n+1 . Let (i n ,j n ) be the projection pair between D n and D ∞ . Let e n @ i n (j n (e)) for eÏD ∞ . We have $ n&lt;ω {e n } = e, where "$" denotes, as usual, the join. The cpo's D ∞ D ∞ and D ∞ ×D ∞ are projected into D ∞ by means of the projection pairs: (i, j) and ([ , ], p). The operation of application on D ∞ is defined as usual as: fd@j(f)(d).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Complete Uniform Pers</head><p>A per A over D ∞ is complete and uniform 3 (henceforth cuper) iff It turns out that every definable type operator is either contractive or the identity, and therefore admits a least fixpoint. The type-interpretation w.r.t. a contractive exponent exp(A, B) is completed as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.4">Soundness of the (→) subtyping rule</head><p>In order to have a sound interpretation of the (→) rule in 3.1 it is convenient that the operator exp satisfies the following additional condition:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proviso</head><p>We can summarize our discussion as follows. We assume to have a binary operator, exp: cuper×cuper→cuper, satisfying the following three properties, for any A, A', B, B':</p><p>The simple interpretation defined above provides an example of such operator. The Finterpretation discussed in 6.3 provides yet another example.</p><p>We can interpret the types parametrically in the operator exp as follows:</p><p>The three conditions above are also sufficient to obtain the following soundness theorem. We write ª α≤β iff, given any operator exp, with relative type-interpretation [ ], we have [α]η ⊆ [β]η for any η: Tvar→cuper. We also write ª Γ ⊃ α≤β. As usual this means: Óη. (ηª Γ ⇒ ηª α≤β).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.5">Theorem (Soundness of the tree ordering w.r.t. the model)</head><p>Given a per A we define its completion cmpl(A) as the least cuper that contains A:</p><p>Given a tree A in Tree(L) we define its interpretation as the completion of the set-theoretic union of the interpretations of its syntactic approximants:</p><p>Now we need the following fact (see <ref type="bibr" target="#b0">[1]</ref>):</p><p>where by definition</p><p>In other words, if we are interested in the interpretation of the type α up to the n-th level of the construction of D ∞ , it is enough to unfold α up to a certain level N and just consider the interpretation of this finite part of the associated tree expansion.</p><p>Next we use the fact that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.6">Proposition (Soundness of the rule ordering w.r.t. the model)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>For the soundness of the type equivalence rules (5.1) one observes that the contractiveness of α in t is a sufficient (and necessary) condition to enforce the contractiveness of the following functional on the space cuper D ∞ (6.2):</p><p>As for the subtyping rules (5.3) the problem is to check the soundness of (µ R ). Suppose ηª Γ. By hypothesis we have:</p><p>It can be proved (see <ref type="bibr" target="#b0">[1]</ref>) that for any type γ :</p><p>And from [µt.γ]η = cmpl(ê n&lt;ω [(µt.γ) n ]η) we have the thesis. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Completeness of an F-interpretation</head><p>We now consider an F-interpretation of → (see <ref type="bibr" target="#b26">[27]</ref>) that is isomorphic to the simple interpretation and still satisfies the properties in 6.2.3 and 6.2.4. We will also use this interpretation for the completeness theorem 6.3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Define:</head><p>(</p><p>where F is the embedding of the functional space D ∞ D ∞ into D ∞ and f is the embedding of a distinct symbol of At into D ∞ . Roughly speaking (B A ) F is built from B A by selecting among those elements that are "functions" in the underlying λ-model D ∞ and by attaching to ® a label f. We introduce the label f in order to distinguish the functional type ©→® from ® (see lemma <ref type="bibr">6.3.3)</ref>. As an exercise one can try to give the complete rules for the "pure" version of the F-interpretation: (B A ) F' @ B A ∩ F 2 . A more difficult exercise is to define a complete system for the simple semantics. In this case further identifications like µt.t→t = © take place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Inference</head><p>Let λ →µ be the calculus in section 2. Given a term in λ →µ , possibly not typeable, we are interested in the problem of determining if it can be well-typed modulo the insertion of appropriate coercions.</p><p>We refer to this problem as coercion inference. We will define a simple algorithm that, given a term M, succeeds exactly when M is typeable modulo the insertion of coercions. In this case the algorithm returns the least type among the types that can be assigned to M.</p><p>A similar problem was solved in <ref type="bibr" target="#b1">[2]</ref> for a second-order lambda calculus with records, and in <ref type="bibr" target="#b17">[18]</ref> for a second-order lambda calculus including a form of bounded quantification.</p><p>All these results rely on the structural properties of the subtype relation that are stated, in this case, as Proposition 7.2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notation.</head><p>In this section α 8 β and α 3 β are shorthands for Tα≤ ∞ Tβ and Tα=Tβ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Typing modulo coercions</head><p>We can formalize the idea of typing modulo coercions in two ways:</p><p>(a) Subsumption. Add to the typing system in 2.2 and 3.1 the following rule based on the tree order ≤ ∞ . The version based on ≤ fin is often referred to as Subsumption:</p><p>(Sub ∞ ) M: α, α8β ⇒ Μ: β We denote formal derivability in this new system with ∫ Sub .</p><p>(b) Explicit Coercions. Extend the term language with a collection of constants {c α,β | α, β types} and add to the typing system in 3.1 the following rule:</p><p>(ExpCoer ∞ ) M: α, α8β ⇒ (c α,β Μ): β Denote formal derivability in this new system with ∫ c , and denote the corresponding term language with λ →µc . Moreover, denote with er c (mnemonic for erase coercions) the obvious function that takes a term in λ →µc , erases all the constants c α,β , and returns a term in λ →µ . The use of these rules is justified by the finitary axiomatization of 8 given in section 5. Note that in both these systems the (fold µt.α M) and (unfold µt.α M) terms become redundant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Definition (coercion inference)</head><p>We define inductively on the structure of the term M in λ →µ a function 4 CI: (λ →µ ) → (λ →µc ∪ {FAIL}) (CI for coercion inference) that either fails or returns a well-typed term N in λ →µc such that er c (N) 7 M. The clauses (fold), (unfold) have priority on the clause (apl).  Clearly CI can also be used to define an inference algorithm for ∫ Sub ; just consider the type of the term synthesized by CI. We prove in 7.2.5 that this algorithm computes the minimal type of a term (if any). To achieve this result we need the following simple properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Proposition</head><p>Let M be a term in λ →µ then: (1) ∫ Sub M : α iff for some N: ∫ c N : α and er c (N) 7 M.</p><p>(2) If CI(M): β then er c (CI(M)) 7 M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>(1) Every introduction of an explicit coercion corresponds to an application of subsumption and vice versa.</p><p>( </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>(1) α can be rewritten, by unfolding, to an equivalent type of the shape ®, ©, t or α 1 →α 2 . The definition of the tree ordering and the hypothesis α 8 β 1 →β 2 lead to the conclusion by a simple case analysis.</p><p>(2) Analogous. M</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.5">Theorem (Terms have a least type)</head><p>Let M be a term in λ →µ then ∫ Sub M : α implies CI(M):β and β 8 α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on the structure of M. C(N) is a meta-notation for cα n-1, α n (...(cα 1, α 2 N)..), where: N: α 1 , n≥1, α i 8 α i+1 . By virtue of 7.2.3.(1) we may equivalently assume the existence of a well-typed term N in λ →µc such that er c (N) 7 M.</p><p>Observe the crucial role of property 7.2.4 in proving the rather surprising fact that the algorithm is complete in the sense just stated above. Case M7(unfold µt.α M'). Analogous. M Remarks 7.2.6 One can think of substituting the explicit coercions with the definable coercions constructed in section 7.1. The resulting term is now typeable in an extension of the calculus in section 2 including the rule: M:α, α=β ⇒ M:β. We recall that this rule is soundly interpreted by the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.2.7</head><p>Observe that in general there are many possible well-typed terms of the same type to which the erase-coercions map assigns the same term, that is: ∫ c N 1 : α , ∫ c N 2 : α and er c (N 1 ) 7 er c (N 2 ) However, N 1 and N 2 receive the same interpretation in the model.</p><p>It is an appealing aspect of our semantic approach to the interpretation of subtyping that many hard coherence problems (see <ref type="bibr" target="#b17">[18]</ref>) simply disappear by recalling the uniqueness of the coercion in the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.2.8</head><p>The following is a trivial example of a term that can be typed in the type system with subsumption but not in the system described in 2.2: ∫ Sub λ f t→s . λx t . (λy © . x)(f x): (t→s)→t .</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Recursion over realizability structures, Information and Computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
		<idno>as TR1/89</idno>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Dipartimento di Informatica</publisher>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="1" to="55" />
		</imprint>
		<respStmt>
			<orgName>Università di Pisa</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Formal theories of inheritance for typed functional languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
		<idno>TR 28/89</idno>
	</analytic>
	<monogr>
		<title level="j">Dipartimento di Informatica</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>Università di Pisa</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Typed equivalence, type assignment and type containment</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conditional and Typed Rewriting Systems 90</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Conditional and Typed Rewriting Systems 90</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">516</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The metric space of infinite trees. Algebraic and topological properties</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Fundamenta Informaticae III</publisher>
			<biblScope unit="page" from="445" to="476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Inheritance as implicit coercion</title>
		<author>
			<persName><forename type="first">V</forename><surname>Breazu-Tannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="172" to="221" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Denotational semantics for subtyping between recursive types</title>
		<author>
			<persName><forename type="first">V</forename><surname>Breazu-Tannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
		<idno>MS-CIS 89 63</idno>
	</analytic>
	<monogr>
		<title level="j">Logic of Computation</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>Dept of Computer &amp; Information Science, University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A modest model of records, inheritance and bounded quantification</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Longo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="196" to="240" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">F-bounded polymorphism for object-oriented programming</title>
		<author>
			<persName><forename type="first">P</forename><surname>Canning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Olthoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Functional Programming and Computer Architecture</title>
		<meeting>Functional Programming and Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">89</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">On understanding types, data abstraction and polymorphism, Computing Surveys</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wegner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985-12">December 1985</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="471" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Combinators and Functional Programming Languages</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><surname>Amber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th Summer School of the LITP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of the 13th Summer School of the LITP<address><addrLine>Vosges (France)</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985-05">May 1985</date>
			<biblScope unit="volume">242</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A semantics of multiple inheritance, Info.&amp;Comp</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in LNCS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="138" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Typeful programming, in Formal Description of Programming Concepts</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<editor>E.J.Neuhold and M.Paul Eds., pp</editor>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="431" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A semantic basis for Quest</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Longo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="417" to="458" />
			<date type="published" when="1991-10">Oct 1991</date>
		</imprint>
		<respStmt>
			<orgName>Cambridge University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Type inference with recursive types: syntax and semantics</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cardone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Info.&amp;Comp</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="48" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A denotational semantics of inheritance</title>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>Brown University</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fundamental properties of infinite trees</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="95" to="169" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Equivalence and transformation of regular systems -applications to recursive program schemes and grammars</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1" to="122" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Coherence of Subsumption, minimum typing and typechecking in F ≤</title>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Curien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="55" to="91" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A small complete category</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hyland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="135" to="165" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An ideal model for recursive polymorphic types</title>
		<author>
			<persName><forename type="first">D</forename><surname>Macqueen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Info.&amp;Comp</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="1" to="2" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A complete inference system for a class of regular behaviours</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Science</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="439" to="466" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m">Systems Programming with Modula-3</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</editor>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Concurrency and automata on infinite sequences</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M R</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th GI conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th GI conference</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page" from="167" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Bounded Quantification is Undecidable</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc ACM Symposium on Principles of Programming Languages</title>
		<meeting>ACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="305" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Two complete systems for the algebra of regular events</title>
		<author>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Continuous lattices, Toposes, Algebraic Geometry and Logic, Lawvere</title>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Mathematics</title>
		<imprint>
			<biblScope unit="volume">274</biblScope>
			<biblScope unit="page" from="97" to="136" />
			<date type="published" when="1972">1972</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Data types as lattices</title>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. of Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="522" to="587" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><surname>Van Wijngaarden</surname></persName>
		</author>
		<title level="m">Revised report on the algorithmic language Algol68</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="103" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The relation between computational and denotational properties for Scott&apos;s D ∞ models of the lambda-calculus</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wadsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. of Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="488" to="521" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
