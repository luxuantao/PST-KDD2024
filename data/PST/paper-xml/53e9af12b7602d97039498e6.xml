<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Process algebra for hybrid systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Research Group</orgName>
								<orgName type="institution">University of Amsterdam</orgName>
								<address>
									<postBox>P.O. Box 41882</postBox>
									<postCode>1009 DB</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">Netherlands</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Philosophy</orgName>
								<orgName type="institution">Utrecht University</orgName>
								<address>
									<postBox>P.O. Box 80126</postBox>
									<postCode>3508 TC</postCode>
									<settlement>Utrecht</settlement>
									<country key="NL">Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Computing Science Department</orgName>
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<postBox>P.O. Box 513</postBox>
									<postCode>5600 MB</postCode>
									<settlement>Eindhoven</settlement>
									<country key="NL">Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Process algebra for hybrid systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BCF6002AB88223C1F1D38BB758943AC7</idno>
					<idno type="DOI">10.1016/j.tcs.2004.04.019</idno>
					<note type="submission">Received 25 November 2003; received in revised form 3 February 2004; accepted 8 April 2004</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Process algebra</term>
					<term>Hybrid systems</term>
					<term>Continuous relative timing</term>
					<term>Propositional signals</term>
					<term>State evolutions</term>
					<term>State transitions</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a process algebra obtained by extending a combination of the process algebra with continuous relative timing from Baeten and Middelburg (Process Algebra with Timing, Springer, Berlin, 2002, Chapter 4), and the process algebra with propositional signals from Baeten and Bergstra  (Theoret. Comput. Sci. 177 (1977)  381-405). The proposed process algebra makes it possible to deal with the behaviour of hybrid systems, i.e. systems in which the instantaneous state transitions caused by performing actions are alternated with continuous state evolutions. This process algebra has, in addition to equational axioms, rules to derive equations with the help of real analysis.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>There is a rapid growth of interest in systems that exhibit both discrete and continuous behaviour. Such systems, called hybrid systems, are found in many areas, from avionics to consumer electronics. Simple hybrid systems typically consist of a controlling subsystem made up of digital components and a controlled subsystem made up of analogue components. The controlling subsystem exhibits discrete behaviour and the controlled subsystem exhibits continuous behaviour. In general, the controlling subsystem is embedded in the controlled subsystem without being accessible from the outside. Moreover, the behaviour of the controlling subsystem generally depends on the behaviour of the controlled subsystem and cannot be considered in isolation. More complicated hybrid systems arise, for example, if the controlled subsystem is a distributed system and, for that reason, the controlling subsystem is composed of several distributed controllers and possibly a coordinating supervisor.</p><p>It was proposed almost at the outset of the interest for hybrid systems in computer science to model them as hybrid automata <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b34">35]</ref>. Hybrid automata are automata equipped with variables that evolve continuously with time. They can be viewed as a generalization of timed automata <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>. The study of hybrid systems in computer science is up to now largely focussed on hybrid automata, in particular on model checking for hybrid automata, i.e. automatic ways for verifying whether a hybrid automaton satisfies a property expected from the hybrid system modelled by it (see e.g. Refs. <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref>). To the best of our knowledge, little attention is paid to equivalence checking for hybrid automata, i.e. automatic ways for verifying whether two hybrid automata are equivalent in some well-defined sense. Satisfaction of properties expressed in an expressive temporal logic can be automatically verified for a restricted subclass of hybrid automata, known as linear hybrid automata. Conservative approximations are needed for other hybrid automata to make automatic verification possible.</p><p>We complement the framework of hybrid automata with a process algebra for hybrid systems. This process algebra, being essentially a calculus of hybrid systems, allows for description and syntax-based analysis of hybrid systems in a compositional way. It comprises • mathematical expressions for hybrid systems;</p><p>• equational axioms for equational reasoning about hybrid systems;</p><p>• rules for lifting results from real analysis to equations about hybrid systems; • a structural operational semantics of the expressions. The expressions are constructed by means of operators, each of which corresponds to a distinct and natural way in which hybrid systems can be combined or adapted. The axioms and lifting rules make fully precise how to establish whether two expressions constructed in different ways represent the same hybrid system. The axioms can amongst other things be used to transform an expression into one that is suggestive of a symbolic counterpart of a hybrid automaton. The structural operational semantics induces a transition system for each expression. The transition systems concerned are similar to the ones used for model checking in the setting of hybrid automata. Consequently, those model checking techniques can easily be adapted to the process algebraic setting for hybrid systems.</p><p>The process algebra for hybrid systems is also meant to be an algebraic theory which formalizes an important part of our general understanding of hybrid systems. Although the axioms and lifting rules of the process algebra are supported by a model, based on the structural operational semantics, our general understanding of hybrid systems provided the primary justification of the axioms and lifting rules of the process algebra. The process algebra for hybrid systems turns out to be far from a compact theory. The complexity inherent in hybrid systems is also found in the rather large number of axioms. Only a few axioms can be removed because of their derivability from the other axioms. The remaining axioms formalize distinct and basic general properties. In order to condense the theory, the collection of operators has to be restricted. However, this would compromise its relevance to hybrid systems.</p><p>Like the framework of hybrid automata, the process algebra for hybrid systems proposed in this paper adopts the view that a hybrid system is a system in which an instantaneous state transition takes place on the system performing an action and a continuous state evolution takes place on the system idling between performing successive actions.</p><p>The process algebra for hybrid systems is obtained by extending a combination of two existing extensions of ACP <ref type="bibr" target="#b15">[16]</ref>, namely the process algebra with continuous relative timing from Ref. <ref type="bibr" target="#b13">[14]</ref> and the process algebra with propositional signals from Ref. <ref type="bibr" target="#b10">[11]</ref>. A process may idle for some period of time before it performs its next action (instantaneously), in which case the next action is performed after a delay. The process algebra with continuous relative timing covers this aspect of process behaviour. The state of the process may further change continuously during the delay. This is not covered, because the state of processes is kept invisible. In the process algebra with propositional signals, a process can have its state to some extent visible. The basic idea is that the visible part of the state of a process, called the signal emitted by the process, is a proposition. Only discrete state changes, caused by performing actions, are covered.</p><p>We introduce a new operator which makes it possible to deal with continuous state changes during delays as well. With the new operator, we can have signals at all points of time during a delay instead of only at its begin and end. For this operator, we have to add some structure to the atomic propositions from which the propositional signals concerned are generated: algebraic and differential equations and inequalities concerning named state components are taken as atomic propositions. We also introduce a new operator which makes it possible to deal better with instantaneous state changes where the state immediately after the change depends upon the state immediately before the change. The resulting process algebra has, in addition to equational axioms, some rules to derive further equations with the help of real analysis. These lifting rules constitute a smooth interface to disciplines such as control engineering where real analysis is the standard tool. They permit to cast the effects of continuous state changes into equations about processes.</p><p>As mentioned before, up to now the study of hybrid systems is largely focussed on hybrid automata. The process algebra proposed in this paper can be regarded as originating from the formalism of hybrid automata in the sense that it has been strongly influenced by the formalism of hybrid automata. This is among other things apparent from the fact that hybrid automata can be faithfully represented using the proposed process algebra in a uniform and direct way. The representation of hybrid automata will be briefly outlined in Section 6. The operational semantics of the proposed process algebra has further been influenced by the concept of abstract phase transition systems from Ref. <ref type="bibr" target="#b39">[40]</ref>.</p><p>Other related work includes the following. A variant of timed CSP <ref type="bibr" target="#b29">[30]</ref> in which one can deal with continuous behaviour in a limited way is introduced in Ref. <ref type="bibr" target="#b40">[41]</ref>. A variant of the -calculus <ref type="bibr" target="#b47">[48]</ref> in which one can deal with continuous behaviour in another limited way is introduced in Ref. <ref type="bibr" target="#b51">[52]</ref>. Those variants of timed CSP and the -calculus are called hybrid CSP and the -calculus, respectively. Very shortly after the report version of this paper <ref type="bibr" target="#b19">[20]</ref> appeared, another report about an extension of ACP for hybrid systems <ref type="bibr" target="#b28">[29]</ref> appeared. That version, called HyPA, does not extend a version of ACP with timing. Thereby, in comparison with the process algebra proposed in this paper, it has some limitations with regard to the description and analysis of hybrid systems. Hybrid CSP, the -calculus and HyPA will be further discussed in Section 6. Here, we only mention that to the best of our knowledge the first process algebra for hybrid systems is hybrid CSP. There is also work on the description and analysis of hybrid systems in which operations corresponding to ways in which hybrid systems can be combined or adapted are introduced, but which has not yet resulted in an algebraic framework. Notable examples are the work on Charon <ref type="bibr" target="#b5">[6]</ref>, Masaccio <ref type="bibr" target="#b35">[36]</ref>, and the HIOA framework <ref type="bibr" target="#b41">[42]</ref>.</p><p>In Ref. <ref type="bibr" target="#b13">[14]</ref>, a coherent collection of four process algebras with timing, each dealing with timing in a different way, is presented. The time scale on which the time is measured is either discrete or continuous, and the timing of actions is either relative or absolute. There is no other reason to choose for relative timing in this paper but the fact that it is generally considered to be simpler than absolute timing. Various constants and operators of the process algebra with continuous relative timing have counterparts in the other versions from the above-mentioned collection. A notational distinction is made between a constant or operator of one version and its counterparts in another version, by means of different decorations of a common symbol, if they should not be identified in case versions are integrated. So long as one uses a single version, one can safely omit those decorations. However, we refrain from omitting them in this paper because we think that change of notation in a series of technical publications is undesirable.</p><p>We distinguish between a basic process algebra for hybrid systems, which does not cover parallelism and communication, an algebra of communicating processes for hybrid systems, which covers parallelism and communication, and several extensions which are useful or needed in many applications. Two extensions are presented as extensions of the basic process algebra and another one as extension of the algebra of communicating processes. This is only for pedagogical reasons. Integration, which provides for alternative composition over a continuum of differently timed alternatives, and guarded recursion, which allows for the description of (potentially) non-terminating processes, are needed in many applications of the proposed process algebra for hybrid systems. Both integration and guarded recursion are treated as extensions. Localization, which makes it possible to keep discontinuities of named state components local, is useful in various applications. Localization is treated as extension as well.</p><p>The structure of this paper is as follows. First of all, we introduce the basic process algebra for hybrid systems (Section 2). Next, we consider the addition of integration and recursion (Section 3). After that, we consider the addition of parallel composition and encapsulation (Section 4). Then, we consider the addition of localization (Section 5). Finally, some concluding remarks are made (Section 6). The application of the process algebra for hybrid systems is regularly illustrated by means of examples.</p><p>In the remainder of this paper, we will mostly refer to process algebras by name. The process algebra with continuous relative timing from Ref. <ref type="bibr" target="#b13">[14]</ref> and the process algebra with propositional signals from Ref. <ref type="bibr" target="#b10">[11]</ref> are known as ACP srt and ACP ps , respectively. The new process algebra proposed in this paper is called ACP srt hs . All of these process algebras are extensions of ACP <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b17">18]</ref>. We will also refer to BPA and BPA , which are names of subtheories of ACP that do not cover parallelism and communication. The difference between them is that BPA does not cover deadlock and BPA does.</p><p>The new process algebra proposed in this paper extends ACP srt . This process algebra was first introduced in Ref. <ref type="bibr" target="#b12">[13]</ref>. The motivation of choices made in the design of ACP srt , as well as a brief comparison with other process algebras with timing, can be found in Ref. <ref type="bibr" target="#b12">[13]</ref>. In this paper, we mostly refer to Ref. <ref type="bibr" target="#b13">[14]</ref> because, in many respects, it contains a more extensive treatment of ACP srt . Additional insight in the choices made in the design of ACP srt can be gained from Refs. <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref>. Some familiarity with real analysis is required. The desirable background can, for example, be found in Ref. <ref type="bibr" target="#b23">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Basic process algebra</head><p>In this section, we introduce BPA srt hs , which is, roughly speaking, the subtheory of ACP srt hs that does not cover parallelism and communication. Beforehand, we give already an idea of its application by means of an example concerning a water-level monitor. First of all, we introduce BPA srt ⊥ , an extension of (a restricted version of) BPA srt from Ref. <ref type="bibr" target="#b13">[14]</ref> with non-existence like in BPA ⊥ from Ref. <ref type="bibr" target="#b10">[11]</ref>. Next, we introduce BPA srt ps , an extension of BPA srt ⊥ with propositional signals and conditions like in BPA ps from Ref. <ref type="bibr" target="#b10">[11]</ref>. Finally, we introduce BPA srt hs , an extension of BPA srt ps with a signal evolution operator and a signal transition operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Example: water-level monitor</head><p>This section is a sample of the application of BPA srt hs . It is meant to give a first impression of how one describes the behaviour of hybrid systems in BPA srt hs . We describe the behaviour of a water-level monitor. This example is adapted from Ref. <ref type="bibr" target="#b1">[2]</ref>. We take the following informal description of the behaviour of the water-level monitor as the starting point of our formal description.</p><p>The water-level monitor continuously senses the water level l in a tank and turns a pump on and off, in order to keep it between 0.075 and 0.300 m. Initially, the water level is 0.075 m and the pump is on. While the pump is on, the water level rises by 0.025 m/s. When the water level becomes 0.250 m, the monitor turns the pump off. While the pump is off, the water level falls by 0.050 m/s. When the water level becomes 0.175 m, the monitor turns the pump on. Naturally, the water level does not change instantaneously when the monitor turns the pump on or off. The change of the status of the pump becomes effective only 2 s later. That is, the pump starts working 2 s after it has been turned on and the pump stops working 2 s after it has been turned off.</p><p>The water-level monitor can be formally described using BPA srt hs by the following equations:</p><formula xml:id="formula_0">W = (l = 0.075) ∧ W on , W on = (l 0.250 ∧ l = 0.025) ∩ * rel (l = 0.250) :→ (l • = • l) turn-off • W on , W on = (l 0.300 ∧ l = 0.025) ∩ 2 rel (l • = • l) stop • W off , W off = (l 0.175 ∧ l = -0.050) ∩ * rel (l = 0.175) :→ (l • = • l) turn-on • W off , W off = (l 0.075 ∧ l = -0.050) ∩ 2 rel (l • = • l) start • W on .</formula><p>At this stage, we cannot further explain this description. However, note that it appears to be a fairly direct representation of the informal description given above ( l stands for the derivative of l). In addition to constants and operators of BPA srt <ref type="bibr" target="#b13">[14]</ref> and BPA ps <ref type="bibr" target="#b10">[11]</ref>, the signal transition operator and the signal evolution operator ∩ are used. These new operators are needed to make precise that the water level does not change instantaneously at the points of time at which the monitor turns the pump on or off or the pump starts or stops working and that the water level changes continuously as described above during the periods in between.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">BPA srt with non-existence</head><p>The atomic processes are undelayable actions. Let a be an action. Then undelayable action a, written ã, is the process that immediately performs action a at the current point of time and then terminates successfully. Actions are idealized in the sense that they are treated as if they are performed instantaneously.</p><p>The basic way of timing processes is relative delay. Let P be a process and r ∈ R . Then the relative delay of P for a period of time r, written r rel (P ), is the process that idles for a period of time r and then behaves like P. In other words, it is P after a delay of r time units.</p><p>The basic ways of combining processes are alternative composition and sequential composition. Let P 1 and P 2 be processes. Then the alternative composition of P 1 and P 2 , written P 1 +P 2 , is the process that behaves either like P 1 or like P 2 , but not both. In other words, there is an arbitrary choice between P 1 and P 2 . The choice is resolved on one of them performing its first action, and not otherwise. Consequently, the choice between two idling processes will always be postponed until at least one of the processes can perform its first action. Only when both processes cannot idle any longer, further postponement is not an option. If the choice has not yet been resolved when one of the processes cannot idle any longer, the choice will simply not be resolved in its favour. The sequential composition of P 1 and P 2 , written P 1 • P 2 , is the process that first behaves like P 1 , but when P 1 terminates successfully it continues by behaving like P 2 . That is, P 1 is followed by P 2 . If P 1 never terminates successfully, the sequential composition of P 1 and P 2 will behave like P 1 .</p><p>In order to deal with unsuccessful termination, we need an additional process that is neither capable of performing any action nor capable of idling beyond the current point of time. This process, written ˜ , is called undelayable deadlock.</p><p>We further introduce a process that is considered to be in an inconsistent state from its start. We need this process further on when we introduce propositional signals (it corresponds to a process that emits a signal that cannot hold). It is common to consider a process with such an inconsistency to be non-existent. Therefore, this process, written ⊥, is (rather contradictory) called the non-existent process. Like undelayable deadlock, ⊥ is neither capable of performing any action nor capable of idling beyond the current point of time.</p><p>Moreover, a choice involving the non-existent process and the non-existent process followed by another process are non-existent as well.</p><p>For convenience later on, we also add an auxiliary operator: rel . The operator rel is interpreted as relative undelayable time-out. Let P be a process. The relative undelayable time-out of P, written rel (P ), behaves like the part of P that starts to perform actions at the current point of time if P is capable of performing actions at the current point of time. Otherwise, it behaves like undelayable deadlock. That is, the relative undelayable time-out keeps P entirely from idling.</p><p>The process algebra introduced here features urgent actions. This means that it is possible for two or more actions to be performed consecutively at the same point of time. In Ref. <ref type="bibr" target="#b44">[45]</ref>, it is shown, using the finite elements of the non-standard extension of R as time domain, that actions that are performed consecutively at the same point of time in R , say p, can be considered to be performed at different points in time that are infinitely close to p. Other process algebras featuring urgent actions include the ACP-style process algebras with timing presented in Ref. <ref type="bibr" target="#b13">[14]</ref>, ATP <ref type="bibr" target="#b49">[50]</ref>, the different versions of CCS with timing <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b54">55]</ref>, Timed CSP <ref type="bibr" target="#b29">[30]</ref>, TIC <ref type="bibr" target="#b50">[51]</ref>, and TPL <ref type="bibr" target="#b33">[34]</ref>.</p><p>We shall henceforth use x, y, x , y , . . . as variables ranging over processes. Furthermore, we shall henceforth use p, q, r, . . . to stand for arbitrary closed terms denoting non-negative real numbers, and a, b, c, . . . to stand for arbitrary actions.</p><p>It is assumed that a fixed but arbitrary set A of actions has been given. We write A for A ∪ { }. An important convention is that we use a, b, c, . . . to stand for elements of A in the context of equations and for elements of A in the context of transition rules (used for describing structural operational semantics), unless explicitly indicated otherwise.</p><p>The axioms of BPA srt ⊥ are the equations given in Table <ref type="table" target="#tab_0">1</ref>. Many axioms in this table and coming ones are actually axiom schemas. In this table, for example, a stands for an arbitrary action, and p and q stand for arbitrary closed terms denoting non-negative real numbers. Axioms A1-A5 are the axioms of BPA. Axioms A6SR and A7SR are simple reformulations of axioms A6 and A7 of BPA . The constant has been replaced by the constant ˜ . For a detailed introduction to BPA and BPA , see Ref. <ref type="bibr" target="#b15">[16]</ref>. Axioms SRT1 and SRT2 point out that a delay of 0 time units has no effect and that consecutive delays count up. Axiom SRT3, called the time-factorization axiom, shows that a delay by itself cannot determine a choice. Axiom SRT4 reflects that timing is relative. Axioms SRU1-SRU4 make clear that relative undelayable time-out prevents a process from idling at the start. Axioms NE1 and NE2 express that a choice involving the non-existent process and the non-existent process followed by another process are non-existent as well. Axiom NE3SR expresses that going on as ⊥ after performing an action is impossible. Axiom NESRU expresses that keeping ⊥ from idling has no effect.</p><p>Note that the following interesting equations are derivable (p 0, r &gt; 0):</p><formula xml:id="formula_1">p+r rel (x)+ r rel ( ˜ ) = p+r rel (x), p+r rel (x)+ r rel (⊥) = r rel (⊥).</formula><p>The axioms of BPA srt ⊥ are essentially the axioms of BPA srt and BPA ⊥ with on top of that axiom NESRU concerning the effect of relative undelayable time-out on the non-existent process. Axiom NESRU is the only additional axiom. In particular, we do not have any </p><formula xml:id="formula_2">(a ∈ A , p, q 0, r &gt; 0) x+y = y+x A1 (x+y)+z = x+(y+z) A2 x+x = x A3 (x+y) • z = (x • z)+(y • z) A4 (x • y) • z = x • (y • z) A5 x+ ˜ = x A6SR ˜ • x = ˜ A7SR x+⊥ = ⊥ NE1 ⊥ • x = ⊥ NE2 ã • ⊥ = ˜ NE3SR 0 rel (x) = x SRT1 p rel ( q rel (x)) = p+q rel (x) SRT2 p rel (x)+ p rel (y) = p rel (x+y) SRT3 p rel (x) • y = p rel (x • y) SRT4 rel ( ã) = ã SRU1 rel ( r rel (x)) = ˜ SRU2 rel (x+y) = rel (x)+ rel (y) SRU3 rel (x • y) = rel (x) • y SRU4 rel (⊥) = ⊥ NESRU</formula><p>additional axiom concerning the effect of relative delay on the non-existent process. The process r rel (⊥) (r &gt; 0) is considered to be capable of idling, but only till arbitrarily close to the point of time that is reached after a period of time r. Thus, just like after performing an action, it is impossible to go on as ⊥ after idling for a period of time. However, there are no additional identifications of processes possible as a result of the interaction between relative delay and the non-existent process.</p><p>Throughout this paper, the need to use parentheses is reduced by using the associativity of the operators + and •, and by ranking the precedence of the binary operators. We adhere to the following precedence rules: (i) the operator + has lower precedence than all others, (ii) the operator • has higher precedence than all others, and (iii) all other operators have the same precedence. Moreover, we shall use the notation i∈I t i , where I = {i 1 , . . . , i n } and t i 1 , . . . , t i n are terms denoting processes, for t i 1 + . . . +t i n . The convention is that i∈I t i stands for ˜ if I = ∅.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">BPA srt with propositional signals</head><p>Propositions are used both as signals that are emitted by processes and as conditions that are imposed on processes to proceed. Condition testing is looked upon as signal inspection. The intuition is that the signal emitted by a process, as well as each of its logical consequences, holds at the start of the process. The signal emitted by a process is also called the signal of the process.</p><p>The basic ways of dealing with propositions are signal emission and conditional proceeding. Let P be a process and be a proposition. Then P emitting signal , written ∧ P , is the process that behaves like P and moreover emits signal ; and P proceeding conditionally on , written :→ P , is the process that behaves like P if proposition holds at its start, and otherwise behaves like undelayable deadlock.</p><p>It is assumed that a fixed but arbitrary set P at of atomic propositions has been given. Propositions over P at are constructed in the usual way with constants T, F and the various logical connectives (¬, ∨, ∧, →, ↔). </p><formula xml:id="formula_3">T :→ x = x GC1 F :→ x = ˜ GC2SR :→ ˜ = ˜ GC3SR :→ (x+y) = :→ x+ :→ y GC4 :→ x • y = ( :→ x) • y GC5 :→ ( :→ x) = ( ∧ ) :→ x GC6 ( ∨ ) :→ x = :→ x+ :→ x GC7 T ∧ x = x SE1 F ∧ x = ⊥ SE2 ∧ x+y = ∧ (x+y) SE3 ( ∧ x) • y = ∧ x • y SE4 ∧ ( ∧ x) = ( ∧ ) ∧ x SE5 ∧ ( :→ x) = ∧ x SE6 :→ ( ∧ x) = ( → ) ∧ ( :→ x) SE7 rel ( :→ x) = :→ rel (x) PSSRU1 rel ( ∧ x) = ∧ rel (x) PSSRU2</formula><p>We shall henceforth use , , . . . to stand for arbitrary (state) propositions over P at .</p><p>In derivations we may always use logical equivalences of propositional logic. So we are actually using equivalence classes of propositions, with respect to logical equivalence, instead of the propositions themselves.</p><p>The axioms of BPA srt ps are the equations given in Tables <ref type="table" target="#tab_0">1</ref> and<ref type="table" target="#tab_1">2</ref>. Axioms GC1-GC7 and SE1-SE7 are simple reformulations of corresponding axioms of BPA ps (see Ref. <ref type="bibr" target="#b10">[11]</ref>). The constant has again been replaced by the constant ˜ . Axiom SE2 expresses that a process emitting the signal F is non-existent. Axioms SE6 and SE7 represent the interaction between signal emission and conditional proceeding. Axiom SE6 reflects that condition testing is looked upon as signal inspection. Axiom SE7 points out that if a proposition holds at the start of a process and that process is proceeding conditional on another proposition then at the start of the whole the former proposition holds or the latter proposition does not hold. Axioms PSSRU1 and PSSRU2 are new axioms concerning the interaction of relative undelayable time-out with conditional proceeding and signal emission.</p><p>Note that axioms NE1, NE2 and NESRU are derivable from axioms A1, SE2, SE3, SE4 and PSSRU2. Note further that the following generalizations of axioms SE3 and SE6 are derivable:</p><formula xml:id="formula_4">∧ x+ ∧ y = ( ∧ ) ∧ (x+y), ( ∧ ) ∧ ( :→ x) = ( ∧ ) ∧ x, ∧ (( ∧ ) :→ x) = ∧ ( :→ x).</formula><p>Note also that the following interesting specialization of axiom SE3 is derivable:</p><formula xml:id="formula_5">∧ ˜ +x = ∧ x.</formula><p>Useful derivable equations concerning the non-existing process are:</p><formula xml:id="formula_6">∧ ⊥ = ⊥, :→ ⊥ = ¬ ∧ ˜ .</formula><p>The axioms of BPA srt ps are essentially the axioms of BPA srt and BPA ps with on top of that axiom NESRU concerning the effect of relative undelayable time-out on the nonexistent process and axioms PSSRU1 and PSSRU2 concerning the interaction of relative undelayable time-out with conditional proceeding and signal emission. Axioms NESRU, PSSRU1 and PSSRU2 are the only additional axioms. In particular, we do not have any additional axiom concerning the interaction of relative delay with conditional proceeding and signal emission. Conditional proceeding is non-waiting. Therefore, we do not have</p><formula xml:id="formula_7">:→ r rel (x) = r rel ( :→ x).</formula><p>Signal emission is non-persistent, both over performing an action and idling for a period of time. Therefore, we do not have ∧ r rel (x) = r rel ( ∧ x). In Ref. <ref type="bibr" target="#b22">[23]</ref>, a counterpart of BPA srt ps with discrete relative timing is presented, which includes a non-waiting version of the conditional proceeding operator as well as a waiting version. In that paper, the symbol :→ is used for the waiting version. The reason for this was that in a natural embedding of BPA ps , the conditional proceeding operator of BPA ps , for which the symbol :→ is used as well, corresponds to the waiting version. In the current paper, in which no waiting version is introduced, the symbol :→ is used for the non-waiting version. This is done because the axioms concerning the non-waiting version are essentially the same as the axioms concerning the conditional proceeding operator of BPA ps .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">BPA srt for hybrid systems</head><p>In Sections 2.2 and 2.3, existing (basic) process algebras were simply joined. No new constants or operators were added. With BPA srt for hybrid systems, it becomes more interesting because new operators, which make it possible to deal with the behaviour of hybrid systems, are introduced.</p><p>In the case of BPA srt hs , we add some structure to the atomic propositions of BPA srt ps . That is, algebraic and differential equations and inequalities concerning named state components, called state variables, are taken as atomic propositions. From now on, we will call them atomic state propositions. In conformity with that, the propositions that can be constructed from atomic state propositions will be called state propositions. They will be defined precisely later on. State variables are real-valued functions of time. Their values may change both instantaneously at the points of time at which an action is performed and continuously during the periods in between.</p><p>In order to deal with continuous state evolutions, the signal evolution operator is introduced. Let P be a process, V be a set of state variables, and be a state proposition. Then P in evolution according to with V smooth, written ∩ V P , is the process P of which the emitted signal changes continuously till it performs its first action in such a way that is satisfied and without discontinuities for the state variables in V. If the first action is performed immediately, signal evolution does not take its signal changing effect. What remains in such cases is that P emits signal at the start.</p><p>In order to deal with instantaneous state transitions, the signal transition operator is introduced. This operator requires transition propositions, i.e. propositions concerning the values of the state variables immediately before and after a transition, instead of state propositions. Transition propositions, just as state propositions, will be defined precisely later on. Let P be a process and be a transition proposition. Then P in transition according to , written P , is the process P of which the emitted signal changes instantaneously over performing its first action in such a way that is satisfied, if it performs its first action immediately. Otherwise, signal transition does not take its signal changing effect. In either case, the process P behaves like undelayable deadlock if there is no transition satisfying possible at the start of P. The signal transition operator supersedes the terminal signal emission operator from Ref. <ref type="bibr" target="#b10">[11]</ref>. The terminal signal emission operator is in general inadequate if the state immediately after a transition depends upon the state immediately before the transition.</p><p>It is assumed that a fixed but arbitrary set V of state variables has been given. For each state variable v ∈ V, we introduce an additional state variable v, standing for the derivative of v. We write V for { v | v ∈ V}. It is further assumed that a set of constants, arithmetic operators and relational operators of real arithmetic, including the basic ones (0, 1, +, -, •, -1 , &lt;), has been given. The set of state expressions is inductively defined by the following formation rules: ) is an atomic state proposition. In the case of BPA srt hs , we take the set of atomic state propositions as the set P at . State propositions are not propositions over P at in the customary meaning. There are two additional ways to construct state propositions, which will be described after the introduction of transition propositions.</p><formula xml:id="formula_8">• each state variable v ∈ V ∪ V</formula><p>For each state variable v ∈ V ∪ V, we further introduce two additional state variables • v and v • , standing for the state variable v immediately before and immediately after a transition. We write</p><formula xml:id="formula_9">• V for { • v | v ∈ V ∪ V} and V • for {v • | v ∈ V ∪ V}.</formula><p>The set of transition expressions is inductively defined by the following formation rules: We are now able to come back to the construction of state propositions. State propositions are constructed from atomic state propositions in the usual way with constants T, F and the various logical connectives, and in addition according to the following formation rule:</p><formula xml:id="formula_10">• each state variable v ∈ • V ∪ V • is a transition expression; • each constant c is a transition expression; • if o is</formula><p>• if is a transition proposition, then • and • are state propositions. The proposition • holds exactly in the states from which a transition satisfying is possible, and the proposition • holds exactly in the states to which a transition satisfying is possible.</p><p>We write P st for the set of all state propositions, and we write P tr for the set of all transition propositions.</p><p>We adhere to the customary notational conventions for real arithmetic. For example, we shall generally use infix notation for binary operators, and prefix notation for unary operators.</p><p>Let be a state proposition. Then we write [ • V/V] and [V • /V] for with, for each v ∈ V ∪ V, each occurrence of v in replaced by • v and v • , respectively. As to be expected, satisfaction of transition propositions is defined in Section 2.6 such that the transition proposition • is satisfied by the same transitions as [ • V/V], and the transition proposition • is satisfied by the same transitions as [V • /V]. Moreover, satisfaction of state propositions is defined such that the state propositions • ( • ) and ( • ) • hold in a state if there exists a state in which holds. In other words, those state propositions express satisfiability of .</p><p>Let and be a state proposition and a transition proposition, respectively. Then we write V () for the set of all v ∈ V with v or v occurring in , and V ( ) for the set of all</p><formula xml:id="formula_11">v ∈ V with • v, • v, v • or v• occurring in .</formula><p>We shall use the notation ∩ t for ∩ V () t. We shall also use the notation C V , where</p><formula xml:id="formula_12">V ⊆ V, for v∈V (v • = • v ∧ v• = • v).</formula><p>We shall henceforth use , , . . . as well as , , . . . to stand for arbitrary state propositions, and , , . . . to stand for arbitrary transition propositions. In general, we use , , . . . only in the cases where the state propositions occur solely as an operand of the signal emission operator and/or the conditional proceeding operator. Furthermore, we shall henceforth use v, v , . . . to stand for arbitrary elements of V, unless explicitly mentioned otherwise, and V , V , . . . to stand for arbitrary subsets of V.</p><p>In derivations, we may always use equivalences of state propositions and equivalences of transition propositions that are results of real arithmetic. So, like in the case of BPA srt ps , we are actually using equivalence classes of propositions instead of the propositions themselves.</p><p>The axioms of BPA srt hs are the equations given in Tables <ref type="table" target="#tab_0">1</ref><ref type="table" target="#tab_1">2</ref><ref type="table" target="#tab_4">3</ref>. In Table <ref type="table" target="#tab_4">3</ref>, we use a to stand for elements of A. Axioms HSE1-HSE12 and HST1-HST12 show that signal evolution and signal transition take effect over what takes place first, which is either performing an action or idling for a period of time, and that signal evolution keeps taking effect in the case of idling till the first action is performed. However, equations expressing how signal evolution actually changes the signal of a process during idling cannot be derived using the axioms of BPA srt hs . The reason for this is that the equations concerned can only be derived with the help </p><formula xml:id="formula_13">T ∩ ∅ x = x HSE1 F ∩ V x = ⊥ HSE2 ∩ V ˜ = ∧ ˜ HSE3 ∩ V ã = ∧ ã HSE4 ∩ V ã • x = ∧ ã • x HSE5 ∩ V r rel (x) = ∩ V ( ∧ r rel ( ∩ V x)) HSE6 ∩ V (x+y) = ∩ V x+ ∩ V y HSE7 ∩ V x • y = ( ∩ V x) • y HSE8 ∩ V ( :→ x) = ∧ ( :→ ( ∩ V x)) HSE9 ∩ V ( ∧ x) = ∧ ( ∩ V x) HSE10 ∩ V ( ∩ V x) = ( ∧ ) ∩ V ∪V x HSE11 ∩ V ( ã) = ∧ ( ã) HSE12 ∩ V r rel (x)+ ∩ V r rel ( rel (y)) = ∩ V ( r rel (x)+ ∩ V r rel ( rel (y))) HSE13 T x = x HST1 F x = ˜ HST2 ˜ = ˜ HST3 ã = ( • :→ ã) HST4 ã • x = ( • :→ ã • ( • ∧ x)) HST5 r rel (x) = • :→ r rel (x) HST6 (x+y) = x+ y HST7 x • y = ( x) • y HST8 ( :→ x) = :→ ( x) HST9 ( ∧ x) = ( • → ) ∧ ( x) HST10 ( ã) = ( ∧ ) ã HST11 ( ∩ V r rel (x)) = • :→ ( ∩ V r rel (x)) HST12 :→ ã = • ã HST13 ã • ( ∧ x) = • ã • x HST14 rel ( ∩ V x) = ∩ V rel (x) HSSRU1 rel ( x) = rel (x) HSSRU2</formula><p>of real analysis. We will introduce some rules for this kind of derivations in Section 2.5. Axioms HSE3-HSE6 show that signal evolution only takes its signal changing effect in the case where idling takes place first. Together with axiom HSE9, they also indicate that the state proposition concerned always hold at the start of the process concerned, even in the case where nothing can take place. Axioms HST3-HST6 show that signal transition only takes its signal changing effect in the case where performing an action takes place first. Together with axiom HST9, they also indicate that the process concerned will always behave like undelayable deadlock if there is no transition satisfying the transition proposition concerned possible at its start, even in the case where idling takes place first. Axioms HSE1 and HST1 are reminiscent of axioms SE1 and GC1, respectively; and axioms HSE2 and HST2 are reminiscent of axioms SE2 and GC2, respectively (all closed substitution instances of HSE2 and HST2 are derivable from the other axioms). Axiom HSE13 expresses that in the case of a choice between two idling processes the signals of the idling processes change jointly until one of them performs its first action. It would have been very inconvenient to express this without the relative undelayable time-out operator. Axioms HST13 and HST14 show that there are cases in which signal emission and conditional proceeding can be eliminated in favour of signal transition. Axioms HSSRU1 and HSSRU2 show that signal evolution and signal transition take effect over what takes place first, also in the presence of relative undelayable time-out. Note that axioms HSE4 and HST6 are derivable specializations of axioms HSE12 and HST12; and that axiom HSE5 is derivable from axioms HSE4 and HSE8. Note further that the following specializations of axioms HSE6 and HST5 are derivable (a ∈ A, r &gt; 0)</p><formula xml:id="formula_14">∩ V r rel (x) = ∩ V ( ∧ r rel (x)), ∩ V r rel (x) = ∩ V r rel ( ∩ V x), ã • x = ( • :→ ã • x), ã • x = ã • ( • ∧ x).</formula><p>Note also that the following specializations of axiom HSE13 are derivable (r &gt; 0):</p><formula xml:id="formula_15">∩ V r rel ( ˜ )+ r rel ( rel (x)) = ∩ V r rel ( rel (x)), ∩ V r rel ( rel (x))+ ∩ V r rel ( rel (y)) = ( ∧ ) ∩ V ∪V ( r rel ( rel (x))+ r rel ( rel (y))).</formula><p>The following interesting equations are derivable for all closed terms t (r &gt; 0):</p><formula xml:id="formula_16">∩ V r rel (t) = ∩ V ( ∧ r rel ( ∧ t)), ∩ V t = ∧ ( ∩ V t), t = • :→ ( t).</formula><p>The following derivable equation shows how signal transition changes the signal of a process over performing an action:</p><formula xml:id="formula_17">∧ ( ã • x) = ∧ ( ã • (( • ∧ ) • ∧ x)).</formula><p>Axiom HST5 is indispensable in deriving this equation. We can use it, for example, to derive</p><formula xml:id="formula_18">(v = 0) ∧ (( • v + v • = 1) ã • b) = (v = 0) ∧ (( • v + v • = 1) ã • ((v = 1) ∧ b)).</formula><p>Using equivalences that are results of real arithmetic, we can, for example, derive the following equation:</p><formula xml:id="formula_19">(v = 0) ∧ (( v = 0) ∩ 2 rel (( v = 1) ∩ 3 rel ( ã))) = (v = 0) ∧ (( v = 0) ∩ 2 rel (⊥)).</formula><p>All processes that can be described by means of the constants and operators of BPA srt hs , can be described by a basic term. The set B of basic terms is inductively defined by the following rules:</p><formula xml:id="formula_20">• ⊥ ∈ B; • if ∈ P st + , then ∧ ˜ ∈ B;</formula><p>• if ∈ P st + , ∈ P tr + and a ∈ A, then :→ ( ã) ∈ B;</p><formula xml:id="formula_21">• if ∈ P st + , ∈ P tr + , a ∈ A and t ∈ B, then :→ ( ã • t) ∈ B; • if , ∈ P st + , V ⊆ V, r ∈ R &gt; and t ∈ B, then :→ ( ∩ V r rel (t)) ∈ B; • if t, t ∈ B, then t+t ∈ B.</formula><p>Here we write P st + and P tr + for the restrictions of P st and P tr , respectively, to satisfiable propositions. We can prove that all closed terms of BPA srt hs can be reduced to a basic term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Elimination). For all closed terms t of BPA srt</head><p>hs there exists a basic term t such that t = t is derivable from the axioms of BPA srt hs .</p><p>Proof. See Appendix A.1.</p><p>If we replace in the third and fourth rule of the definition of B given above</p><formula xml:id="formula_22">:→ ( ã) ∈ B by ã ∈ B and :→ ( ã • t) ∈ B by ã • t ∈ B,</formula><p>we still have this result. Even if we add in the fourth rule the condition on that • implies the signal of t, we still have this result.</p><p>We can distinguish two interesting kinds of basic terms. The set B of undelayable basic terms is inductively defined by the following rules:</p><formula xml:id="formula_23">• ⊥ ∈ B ; • if ∈ P st + , then ∧ ˜ ∈ B ; • if ∈ P st + , ∈ P tr + and a ∈ A, then :→ ( ã) ∈ B ; • if ∈ P st + , ∈ P tr + , a ∈ A and t ∈ B, then :→ ( ã • t) ∈ B ; • if t, t ∈ B , then t+t ∈ B .</formula><p>The set B of delayable basic terms is inductively defined by the following rules:</p><formula xml:id="formula_24">• if , ∈ P st + , V ⊆ V, r ∈ R &gt; and t ∈ B, then :→ ( ∩ V r rel (t)) ∈ B ; • if t, t ∈ B , then t+t ∈ B .</formula><p>We can prove the following lemmas.</p><p>Lemma 2 (Urgency). For all t ∈ B , rel (t) = t is derivable from the axioms of BPA srt hs .</p><p>Proof. Easy, by induction on the structure of undelayable basic term t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Representation)</head><p>. For all basic terms t, either t ∈ B or there exists a term t ∈ B and a term t ∈ B such that t = t +t is derivable from the axioms of BPA srt hs .</p><p>Proof. Easy, by induction on the structure of basic term t.</p><p>As a corollary of Lemmas 2 and 3, we have the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 4 (Representation)</head><p>. For all closed terms t of BPA srt hs , either t = rel (t) is derivable from the axioms of BPA srt hs or there exists a basic term t of the form i∈I i :→ ( i ∩ V i r i rel (t i )) such that t = rel (t)+t is derivable from the axioms of BPA srt hs .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Lifting rules of BPA srt hs</head><p>Below, we introduce some rules which allow results from real analysis to be lifted to equations about processes.</p><p>We assume a mathematical theory MT that includes real arithmetic and real analysis to derive properties of signal evolutions. It is assumed that the state variables and the constants and arithmetic operators of real arithmetic can be used in MT to construct expressions designating real-valued functions of R . Likewise, it is assumed that the relational operators of real arithmetic and the logical constants and connectives can be used in MT to construct expressions designating truth-valued functions of R . It is also assumed that MT is based on the following interpretation of the state variables:</p><formula xml:id="formula_25">• each state variable v is interpreted as a real-valued function of R that is piecewise of class C ∞ in R ; 1</formula><p>• the interpretation of a state variable v is the right-hand derivative of the interpretation of the state variable v. 2 It is further assumed that MT is based on the following interpretation of the constants and arithmetic operators of real arithmetic:</p><p>• in expressions designating real numbers, constants and arithmetic operators of real arithmetic are interpreted as usual; • in expressions designating real-valued functions of R , constants and arithmetic operators of real arithmetic are interpreted as the pointwise extensions of their usual interpretations. Likewise, it is assumed that MT is based on the following interpretation of the relational operators of real arithmetic and the logical constants and connectives:</p><p>• in expressions designating truth-values, relational operators of real arithmetic, logical constants and logical connectives are interpreted as usual; • in expressions designating truth-valued functions of R , relational operators of real arithmetic, logical constants and logical connectives are interpreted as the pointwise extensions of their usual interpretations. Moreover, it is assumed that the following equivalences concerning the operators • _ , _ • , • _ and _ • are derivable in MT: (n) , the nth-order derivative of f, exists at every point of I, and is continuous on I, for every n; and f is piecewise of class C ∞ in I if I can be partitioned into a finite set I of left-closed and right-open intervals such that, for each interval I ∈ I, the restriction of f to I is of class C ∞ in I . 2 For each function that is piecewise of class C ∞ in some interval I, the right-hand derivative equals the derivative at all points of I where the latter exists. </p><formula xml:id="formula_26">• ⇔ [ • V/V], • ⇔ [V • /V], • ⇔ ∃r 1 , . . . , r 2n ∈ R• [V/ • V][r 1 , . . . , r 2n /v 1 • , . . . , v n • , v1 • , . . . , vn • ], • ⇔ ∃r 1 , . . . , r 2n ∈ R• [V/V • ][r 1 , . . . , r 2n / • v 1 , . . . , • v n , • v1 , . . . , • vn ]. 1 A function f : I → R, where I is an interval in R , is of class C ∞ in I if f</formula><formula xml:id="formula_27">(a ∈ A , r, s &gt; 0) V ⊆ C ∞ [0, r] ٛ MT (0)→∀t ∈ [0, r]•(t)↔ (t) ∧ ( ∩ V r rel (x)) = ∧ ( ∩ V r rel (x)) HSELR1 V ⊆ C ∞ [0, r] ٛ MT (0) ∧ (∀t ∈ [0, r]•(t))→ (r) ∧ ( ∩ V r rel (x)) = ∧ ( ∩ V r rel ( ∧ x)) HSELR2 V ⊆ C ∞ [0, r] ٛ MT (0) ∧ (∀t ∈ [0, s]•(t)) ∧ (∃t ∈ (s, r]•∀t ∈ (s, t]•¬(t )) ∧ ( ∩ V r rel (x)) = ∧ ( ∩ V s rel ( ˜ ))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HSELR3</head><p>Recall that we use the notations</p><formula xml:id="formula_28">[ • V/V] and [V • /V] for the replacement of the occurrences of v ∈ V ∪ V by • v and v • , respectively. We use the notations [V/ • V] and [V/V • ]</formula><p>for the reverse replacements.</p><p>The rules for lifting results from real analysis to equations about processes are given in Table <ref type="table" target="#tab_5">4</ref>. We use the notation ٛ MT for derivability in MT; and we write</p><formula xml:id="formula_29">V ⊆ C ∞ [0, r] to indicate that for each v ∈ V the restriction of v to [0, r] is of class C ∞ in [0, r].</formula><p>Lifting rule HSELR1 can, for example, be used to derive</p><formula xml:id="formula_30">((v = 0) ∧ ( v = 1)) ∩ 1 rel ( ã) = F ∩ 1 rel ( ã) = ⊥.</formula><p>Note that we cannot derive</p><formula xml:id="formula_31">((v = 0) ∧ ( v = 1)) ∧ ã = F ∧ ã.</formula><p>This is to be expected: although it is impossible that the emitted signal of a process evolves according to</p><formula xml:id="formula_32">(v = 0) ∧ ( v = 1)</formula><p>, it is possible that a process emits the signal</p><formula xml:id="formula_33">(v = 0) ∧ ( v = 1).</formula><p>Lifting rules HSELR2 and HSELR3 are indispensable in deriving the following equations:</p><formula xml:id="formula_34">(v = 0) ∧ ((v 5 ∧ v = 1) ∩ 4 rel ( ã)) = (v = 0) ∧ ((v 5 ∧ v = 1) ∩ 4 rel ((v = 4) ∧ ã)), (v = 0) ∧ ((v 5 ∧ v = 1) ∩ 6 rel ( ã)) = (v = 0) ∧ ((v 5 ∧ v = 1) ∩ 5 rel ( ˜ )</formula><p>). The use of signal evolution, as well as the use of signal transition, will be further illustrated in Section 3.3, after we have considered the addition of integration and recursion in Sections 3.1 and 3.2, and in Sections 4.6 and 4.7, after we have considered the addition of parallel composition and encapsulation in Section 4.2.</p><p>We will henceforth write PA ٛ e to indicate that equation e is derivable from the axioms and lifting rules of process algebra PA using standard equational reasoning.</p><p>Because there exist equations that are only derivable with the help of real analysis, by way of the lifting rules, there is no effective procedure for determining of an arbitrary equation whether it is derivable. Therefore, efficient proof techniques are important. Restrictions that make an effective procedure possible could be useful as well.</p><p>If we replace C ∞ by C 1 in the current section and the next one, the results of Section 2.7 go through. In other words, we could have chosen for state variables that are functions from R to R that are piecewise of class C 1 in R . <ref type="foot" target="#foot_0">3</ref> However, that choice would complicate the theory and might inhibit useful extensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.">Operational semantics of BPA srt hs</head><p>The structural operational semantics of BPA srt hs will be described below using assignments of state variables. An assignment of state variables is a function</p><formula xml:id="formula_35">: V∪ V → R or a function : • V ∪ V • → R. An assignment : V ∪ V → R is also called a state. An assignment : • V ∪ V • → R is also called a state update.</formula><p>An assignment : V∪ V → R can be extended to state expressions and atomic state propositions in the usual homomorphic way, and an assignment : • V ∪ V • → R can be extended to transition expressions and atomic transition propositions in the usual homomorphic way. An assignment : V ∪ V → R can also be extended further to state propositions as usual, except for state propositions of the forms • and • , and an assignment : • V∪V • → R can also be extended further to transition propositions as usual, except for transition propositions of the forms • and • . We will use the same name for an assignment and its extensions. For state propositions of the forms • and • , we have:</p><formula xml:id="formula_36">• ( • ) = T iff there exists a state update such that ( • v) = (v) for all v ∈ V ∪ V and ( ) = T; • ( • ) = T iff there exists a state update such that (v • ) = (v) for all v ∈ V ∪ V and</formula><p>( ) = T. For transition propositions of the forms • and • , we have:</p><formula xml:id="formula_37">• ( • ) = T iff there exists a state such that (v) = ( • v) for all v ∈ V ∪ V and ( ) = T; • ( • ) = T iff there exists a state such that (v) = (v • ) for all v ∈ V ∪ V and</formula><p>( ) = T. In Ref. <ref type="bibr" target="#b10">[11]</ref>, the structural operational semantics of BPA ps is described using valuations of atomic propositions. A valuation of atomic propositions is a function v : P at → B. In the case of BPA srt hs , where the set of atomic state propositions is taken as the set P at of atomic propositions, an assignment : V ∪ V → R of state variables induces a valuation : P at → B of atomic propositions, viz. the extension of the assignment to atomic state propositions.</p><p>Below, satisfaction of state propositions by state evolutions and satisfaction of transition propositions by pairs of states will be defined. Let : [0, r] → (V → R), where r ∈ R &gt; , and V ⊆ V. Then, for every v ∈ V, we write v for the function v : [0, r] → R defined by</p><formula xml:id="formula_38">v (t) = (t)(v). We say that is a state evolution if v is piecewise of class C ∞ in [0, r) for all v ∈ V. If is a state evolution, we say that is smooth for V if v is of class C ∞ in [0, r] for all v ∈ V .</formula><p>If is a state evolution, we say that a state agrees with at time t, t ∈ [0, r], if for all v ∈ V:</p><formula xml:id="formula_39">(v) = v (t), ( v) = ˙ v (t).</formula><p>Let ( , ) be a pair of states. Then, we say that a state update agrees with ( , ) if for all v ∈ V:</p><formula xml:id="formula_40">( • v) = (v), ( • v) = ( v), (v • ) = (v), ( v• ) = ( v).</formula><p>We write E r for the set of all state evolutions : [0, r] → (V → R). For a given state evolution : [0, r] → (V → R) and a given time t ∈ [0, r], there is a unique state that agrees with at t. We write t for this unique state. For a given pair of states ( , ), there is a unique state update that agrees with ( , ). We write for this unique state update.</p><p>Satisfaction of state propositions (by states and state evolutions) and satisfaction of transition propositions (by state transitions) are used below in describing the structural operational semantics of BPA srt hs . Satisfaction of state propositions and transition propositions is defined as follows:</p><p>• a state proposition is satisfied by state , written , if</p><formula xml:id="formula_41">( ) = T;</formula><p>• a state proposition is satisfied by state evolution ∈ E r , written , if t () = T for all t ∈ [0, r]; • a transition proposition is satisfied by the transition from state to state , written → , if</p><formula xml:id="formula_42">( ) = T.</formula><p>We write r,</p><p>--→ V for ∈ E r , 0 = , r = , is smooth for V and .</p><p>Note that we have for all states and :</p><formula xml:id="formula_43">• ( • ) iff ( • ) • iff , • ( • ) iff ( • ) • iff there exists a state such that , → • iff , → • iff , → implies • and • , r, --→ V implies</formula><p>and .</p><p>The structural operational semantics of BPA srt hs is described by the rules given in Tables <ref type="table" target="#tab_6">5</ref> and<ref type="table">6</ref>. In Table <ref type="table">6</ref>, we use a to stand for elements of A . The following transition relations </p><formula xml:id="formula_44">(a ∈ A, r, s &gt; 0) ã, a -→ √ , x, a -→ x , 0 rel (x), a -→ x , x, a -→ √ , 0 rel (x), a -→ √ , x, r, --→ x , 0 rel (x), r, --→ x , r+s rel (x), r, --→ s rel (x), ∈ [s(x)] r rel (x), r, --→ x, x, s, r ----→ x , r rel (x), r+s, ----→ x , x, a -→ x , , ∈ [s(y)] x+y, a -→ x , ∈ [s(x)], y, a -→ y , x+y, a -→ y , x, a -→ √ , , ∈ [s(y)] x+y, a -→ √ , ∈ [s(x)], y, a -→ √ , x+y, a -→ √ , x, r, --→ x , , y, r -→, ∈ [s(y)] x+y, r, --→ x , x, r -→, ∈ [s(x)], y, r, --→ y , x+y, r, --→ y , x, r, --→ x , , y, r, --→ y , x+y, r, --→ x +y , x, a -→ x , x • y, a -→ x • y, x, a -→ √ , , ∈ [s(y)] x • y, a -→ y, x, r, --→ x , x • y, r, --→ x • y, x, a -→ x , :→ x, a -→ x , x, a -→ √ , :→ x, a -→ √ , x, r, --→ x , :→ x, r, --→ x , x, a -→ x , ∧ x, a -→ x , x, a -→ √ , ∧ x, a -→ √ , x, r, --→ x , ∧ x, r, --→ x , x, a -→ x , ∩ V x, a -→ x , x, a -→ √ , ∩ V x, a -→ √ , x, r, --→ x , ∩ V x, r, --→ ∩ V x , r, --→ V x, a -→ x , x, a -→ x , → x, a -→ √ , x, a -→ √ , → Table 5 Continued x, r, --→ x , x, r, --→ x , • x, a -→ x , rel (x), a -→ x , x, a -→ √ , rel (x), a -→ √ , Table<label>6</label></formula><p>Rules for</p><formula xml:id="formula_45">∈ [s(_ )] (a ∈ A , r &gt; 0) ∈ [s( ã)] ∈ [s(x)] ∈ [s( 0 rel (x))] ∈ [s( r rel (x))] ∈ [s(x)], ∈ [s(y)] ∈ [s(x+y)] ∈ [s(x)] ∈ [s(x • y)] ∈ [s(x)] ∈ [s( :→ x)] ∈ [s( :→ x)] ∈ [s(x)] ∈ [s( ∧ x)] ∈ [s(x)] ∈ [s( ∩ V x)] ∈ [s(x)] ∈ [s( x)] ∈ [s( x)] • ∈ [s(x)] ∈ [s( rel (x))]</formula><p>are used:</p><formula xml:id="formula_46">• a binary relation _ , a -→ _ , for each a ∈ A, , : V ∪ V → R; • a unary relation _ , a -→ √ , for each a ∈ A, , : V ∪ V → R; • a binary relation _ , r, --→ _ , for each r ∈ R &gt; , ∈ E r , , : V ∪ V → R such that = 0 and = r ; • a unary relation ∈ [s(_ )] for each : V ∪ V → R.</formula><p>We write t, r -→ for the set of all transition formulas ¬( t, r, --→ t , ) where t is a closed term of BPA srt hs , : V ∪ V → R and ∈ E r . We write r, where ∈ E r+s (r, s &gt; 0), for the ∈ E s such that (s ) = (r + s ) for all s ∈ [0, s].</p><p>The four kinds of transition relations are called the action step, action termination, time step and signal relations, respectively. They can be explained as follows: --→ t , : in state , process t is capable of first idling for a period of time r, while the state evolves according to , and then proceeding as process t in state ; • ∈ [s(t)]: in state , the signal emitted by process t holds. The following are important properties of the transition relations defined by the rules given in Tables <ref type="table" target="#tab_6">5</ref> and<ref type="table">6</ref>. We have for all closed terms t and t , for all , :</p><formula xml:id="formula_47">• t, a -→</formula><formula xml:id="formula_48">V ∪ V → R, a ∈ A, r ∈ R &gt; and ∈ E r : t, a -→ t , or t, a -→ √ , or t, r, --→ t , implies ∈ [s(t)], t, a -→ t , or t, r, --→ t , implies ∈ [s(t )].</formula><p>In work on hybrid automata, the transition systems associated with hybrid automata usually include time step relations _ ,</p><formula xml:id="formula_49">r -→ _ , instead of _ , r,</formula><p>--→ _ , . State evolutions only play a part as "witnesses" for time steps, see e.g. Ref. <ref type="bibr" target="#b34">[35]</ref>. Time step relations _ , r -→ _ , would yield a semantics which is too abstract for our purpose. For instance, the meaning of ∩ V ( ∩ V t) would be far from its intended meaning, and axiom HSE11 would not be sound. Consider, for example, the following terms:</p><formula xml:id="formula_50">(x = 0 ∧ y = 0) ∧ (x + y 4 ∧ x y ∧ ¬(x = 1 ∧ y = 1) ∧ ẋ &gt; 0 ∧ ẏ &gt; 0) ∩ * rel (x = 2 ∧ y = 2) :→ stop , (x = 0 ∧ y = 0) ∧ (x + y 4 ∧ x y ∧ ẋ &gt; 0 ∧ ẏ &gt; 0) ∩ (x + y 4 ∧ x y ∧ ¬(x = 1 ∧ y = 1) ∧ ẋ &gt; 0 ∧ ẏ &gt; 0) ∩ * rel (x = 2 ∧ y = 2) :→ stop . 4</formula><p>The first term can be regarded as describing an object that first moves smoothly from point (0, 0) to point (2, 2), staying away from the left of the straight line through points (0, 0) and (2, 2), and not going through point (1, 1), and then stops. According to our intuition, the second term expresses that the object is on top of that staying away from the right of the straight line through points (0, 0) and (2, 2). This is impossible and therefore the object will never stop. As to be expected, it is derivable from the axioms and lifting rules of BPA srt hs that the second term equals:</p><formula xml:id="formula_51">(x = 0 ∧ y = 0) ∧ (x + y 4 ∧ x = y ∧ ¬(x = 1 ∧ y = 1) ∧ ẋ &gt; 0 ∧ ẏ &gt; 0) ∩ * rel ˜ .</formula><p>There are movements satisfying the first restriction and movements satisfying the second restriction. However, in the case where the state evolutions representing those movements are only playing a part as witnesses in the operational semantics, it is kept unnoticed that the two restrictions cannot be satisfied both. As a result, the second term would not denote a process that will never stop. With regard to the first term, note that the velocity of the object must change as time goes by in order to meet the constraints on its position. However, no discontinuities are allowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.">Bisimulation and soundness</head><p>Bisimulation based on the transition rules for BPA srt hs is defined as usual in cases where processes with different states are not considered to be equivalent.</p><p>A bisimulation is a symmetric binary relation B on pairs of closed terms and states, called configurations, such that for all configurations t 1 , , t 2 , with B( t 1 , , t 2 , ) the following conditions hold: We also consider a variant of bisimulation equivalence, called interference-compatible bisimulation equivalence, which is finer than bisimulation equivalence. The idea behind interference-compatible bisimulation is the following. A process proceeding in parallel with a process P can change the state of P at any time. Interference-compatible bisimulation offers resistance to such changes. For example, if a configuration t 1 , is related to a configuration t 2 , and t 1 , a -→ t 1 , , then there is a t 2 such that t 2 , a -→ t 2 , and t 1 , is related to t 2 , for all states . Parallel composition is introduced in Section 4. In that section, the need for interference-compatible bisimulation equivalence will be explained.</p><formula xml:id="formula_52">• whenever t 1 , a -→ t 1 , ,</formula><p>An interference-compatible bisimulation is a symmetric binary relation B on closed terms such that for all closed terms t 1 , t 2 with B(t 1 , t 2 ) the following conditions hold: ). We will use ic-bisimulation as an abbreviation for interference-compatible bisimulation.</p><formula xml:id="formula_53">• whenever t 1 , a -→ t 1 , ,</formula><p>We regard ic-bisimulation equivalence less natural than bisimulation equivalence: it appears to waver between two opinions. Besides, both axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3 are not sound under ic-bisimulation equivalence.</p><p>Bisimulation equivalence is coarser than ic-bisimulation equivalence. Bisimulation equivalence appears to be preferable. After all, axiom HST5 is indispensable to analyse how signal transition changes the signal of a process over performing an action and lifting rules HSELR2 and HSELR3 are indispensable to analyse how signal evolution changes the signal of a process during idling. Axiom HST14 is a simple alternative to axiom HST5, which has its limitation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5 (Inclusion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Integration and recursion</head><p>In this section, we extend BPA srt hs with integration and guarded recursion. These extensions will be needed in many applications. We illustrate this by means of an example concerning a thermostat. We also pay some attention to Zeno behaviour, which can be described in BPA srt  hs extended with integration and guarded recursion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">BPA srt hs with integration</head><p>In order to cover processes that are capable of performing an action at all points in a certain time interval, we add integration to BPA srt hs . Integration is represented by the variable-binding operator . Let P be an expression, possibly containing variable u, such that P [p/u] (P with p substituted for u) represents a process for all p ∈ R ; and let U ⊆ R . Then the integration u∈U P behaves like one of the processes P [p/u] for p ∈ U . Hence, integration is a form of alternative composition over a set of alternatives that may even be a continuum.</p><p>We shall henceforth use F and G as variables ranging over functions that map each non-negative real number to a process and can be represented by terms containing a designated free variable ranging over R . For more information on such second-order variables, see e.g. Refs. <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b46">47]</ref>. Furthermore, we shall henceforth use u, u , . . . as variables ranging over R . It is assumed that each first-order definable set of non-negative Table <ref type="table">7</ref> Axioms for integration (p 0)</p><formula xml:id="formula_54">u∈U F (u) = u ∈U F (u ) INT1 u∈∅ F (u) = ˜ INT2 u∈{p} F (u) = F (p) INT3 u∈U ∪U F (u) = u∈U F (u)+ u∈U F (u) INT4 U = ∅ ⇒ u∈U x = x INT5 (∀u ∈ U •F (u) = G(u)) ⇒ u∈U F (u) = u∈U G(u) INT6 U, U unbounded ⇒ u∈U u rel ( ˜ ) = u∈U u rel ( ˜ ) INT8SR sup U = p, p ∈ U ⇒ u∈U u rel ( ˜ ) = p rel ( ˜ ) INT9SR u∈U p rel (F (u)) = p rel ( u∈U F (u)) INT10SR u∈U (F (u)+G(u)) = u∈U F (u)+ u∈U G(u) INT11 u∈U (F (u) • x) = ( u∈U F (u)) • x INT12 u∈U rel (F (u)) = rel ( u∈U F (u)) INT13 u∈U ( :→ F (u)) = :→ u∈U F (u) PSINT1 u∈U ( ∧ F (u)) = ∧ u∈U F (u) PSINT2 u∈U ( ∩ V F (u)) = ∩ V u∈U F (u) HSINT1 u∈U ( F (u)) = u∈U F (u) HSINT2</formula><p>real numbers can be denoted by a closed term, and we shall henceforth use U, U , . . . to stand for arbitrary closed terms denoting first-order definable sets of non-negative real numbers. The additional axioms for integration are the equations given in Table <ref type="table">7</ref>. Axiom INT1 is similar to the -conversion rule of -calculus. Axioms INT2-INT4 show that integration is a form of alternative composition over a set of alternatives. Axiom INT5 can be regarded as the counterpart of axiom A3 for integration. Axiom INT6 is an extensionality axiom. The remaining axioms are easily understood by realizing that integration is a form of alternative composition over a set of alternatives. Axioms INT10SR, INT11, INT12, INT13, PSINT1, PSINT2, HSINT1 and HSINT2 can simply be regarded as variants of axioms SRT3, A2, A4, SRU3, GC4, SE3, HSE7 and HST7, respectively. Axioms INT8SR and INT9SR are both reminiscent of the equation</p><formula xml:id="formula_55">p+q rel ( ˜ )+ p rel ( ˜ ) = p+q rel ( ˜ ), which is derivable from axioms A6SR, SRT2 and SRT3.</formula><p>The following important equation concerning the interchange of integration order is derivable:</p><formula xml:id="formula_56">u∈U ( u ∈U K(u, u )) = u ∈U ( u∈U K(u, u )).</formula><p>Like F and G, we use K here as a variable ranging over functions that map each pair of non-negative real numbers to a process and can be represented by terms containing a pair of designated free variables ranging over R .</p><p>The additional axioms for integration in the case of BPA srt hs are essentially the additional axioms for integration in the case of BPA srt and on top of that axioms concerning the Table <ref type="table">8</ref> Additional rules for integration (a ∈ A, p, q 0, r &gt; 0)</p><formula xml:id="formula_57">F (p), a -→ x , , { ∈ [s(F (q))] | q ∈ U } u∈U F (u), a -→ x , p ∈ U F (p), a -→ √ , , { ∈ [s(F (q))] | q ∈ U } u∈U F (u), a -→ √ , p ∈ U { F (q), r, --→ F 1 (q), | q ∈ U 1 }, . . . , { F (q), r, --→ F n (q), | q ∈ U n }, { F (q), r -→, ∈ [s(F (q))] | q ∈ U n+1 } u∈U F (u), r, --→ u∈U 1 F 1 (u)+ . . . + u∈U n F n (u), {U 1 , . . . , U n } partition of U \ U n+1 , U n+1 ⊂ U { ∈ [s(F (q))] | q ∈ U } ∈ [s( u∈U F (u))]</formula><p>interaction of integration with conditional proceeding, signal emission, signal evolution and signal transition. We shall henceforth use the name BPA srt hs +INT to refer to the extension of BPA srt hs with integration.</p><p>We shall henceforth use the notation * rel (t) for u∈[0,∞) u rel (t), with u a variable not occurring free in t.</p><p>The structural operational semantics for integration is described by the rules given in Table <ref type="table">8</ref>. The complexity of the rule concerning the time-related capabilities of a process u∈U F (u) is caused by the fact that the processes F (p) with p ∈ U that are capable of idling need not change uniformly while idling. For more information on this phenomenon, see e.g. Refs. <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b45">46]</ref>. Bisimulation equivalence and ic-bisimulation equivalence are preserved by integration. All additional axioms for integration are sound with respect to bisimulation equivalence and ic-bisimulation equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">BPA srt hs with guarded recursion</head><p>In order to allow for the description of (potentially) non-terminating processes, we add guarded recursion to BPA srt hs . A recursive specification over BPA srt hs is a set of recursive equations E = {X = t X | X ∈ V } where V is a set of variables and each t X is a term of BPA srt hs that only contains variables from V. We write V (E) for the set of all variables that occur on the left-hand side of an equation in E. A solution of a recursive specification E is a set of processes (in some model of BPA srt hs ) {P X | X ∈ V (E)} such that the equations of E hold if, for all X ∈ V (E), X stands for P X .</p><p>Let t be a term of BPA srt hs containing a variable X. We call an occurrence of X in t guarded if t has a subterm of the form ã • t or r rel (t ), where a ∈ A, r &gt; 0 and t a term of BPA srt hs , with t containing this occurrence of X. A recursive specification over BPA srt hs is called a guarded recursive specification if all occurrences of variables in the right-hand sides of </p><formula xml:id="formula_58">X|E = t X |E if X = t X ∈ E RDP E ⇒ X = X|E if X ∈ V (E) RSP</formula><p>its equations are guarded or it can be rewritten to such a recursive specification using the axioms of BPA srt hs and the equations of the recursive specification. A guarded recursive specification has a unique solution.</p><p>For each guarded recursive specification E and each variable X ∈ V (E), we introduce a constant X|E which is interpreted as the unique solution of E for X. We often write X for X|E if E is clear from the context. In such cases, it should also be clear from the context that we use X as a constant.</p><p>We will also use the following notation. Let t be a term of BPA srt hs with guarded recursion and E be a guarded recursive specification. Then we write t|E for t with, for all X ∈ V (E), all occurrences of X in t replaced by X|E .</p><p>We shall henceforth use X, Y, . . . as variables ranging over processes in the case where they occur in a recursive specification. Furthermore, we shall henceforth use t X , t Y , . . . to stand for arbitrary terms of which the closed substitution instances denote processes, and E, E , . . . to stand for arbitrary guarded recursive specifications.</p><p>The additional axioms for guarded recursion are the equations given in Table <ref type="table" target="#tab_11">9</ref>. A side condition is added to restrict the variables, terms and guarded recursive specifications for which X, t X and E stand. The additional axioms for guarded recursion are known as the recursive definition principle (RDP) and the recursive specification principle (RSP). The equations X|E = t X |E for a fixed E express that the constants X|E make up a solution of E. The conditional equations E ⇒ X = X|E express that this solution is the only one.</p><p>It is sometimes helpful to rewrite guarded recursive specifications. The following useful fact about the rewriting of guarded recursive specifications can be proven. Let E and E be two guarded recursive specifications over BPA srt hs , where E is E rewritten using the axioms of BPA srt hs and the equations of E. Then the equation X|E = X|E is derivable for all X ∈ V (E).</p><p>The additional axioms for guarded recursion in the case of BPA srt hs are the same as in the cases of BPA, BPA ps and BPA srt . Guarded recursion is added in the same way to BPA srt hs +INT and the other extensions of BPA srt hs presented in this paper. We shall henceforth use the name BPA srt hs +INT+REC to refer to the extension of BPA srt hs +INT with guarded recursion. The structural operational semantics for guarded recursion is described by the rules given in Table <ref type="table" target="#tab_0">10</ref>. Bisimulation equivalence and ic-bisimulation equivalence are preserved by guarded recursion. All additional axioms for guarded recursion are sound with respect to bisimulation equivalence and ic-bisimulation equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Example: thermostat</head><p>In this section, we consider a thermostat. We give a guarded recursive specification of the behaviour of the thermostat. This example is adapted from Ref. <ref type="bibr" target="#b36">[37]</ref>. We take the following Table <ref type="table" target="#tab_0">10</ref> Additional rules for guarded recursion (a ∈ A, r &gt; 0)</p><formula xml:id="formula_59">t X |E , a -→ x , X|E , a -→ x , X = t X ∈ E t X |E , a -→ √ , X|E , a -→ √ , X = t X ∈ E t X |E , r, --→ x , X|E , r, --→ x , X = t X ∈ E ∈ [s( t X |E )] ∈ [s( X|E )] X = t X ∈ E</formula><p>(adapted) informal description of the behaviour of the thermostat from Ref. <ref type="bibr" target="#b32">[33]</ref> as the starting point of our specification.</p><p>Initially, the temperature is 18 • C and the heating is on. While the heating is on, the temperature T in the room goes up according to the differential equation Ṫ = -T + 22. When the temperature becomes 20 • C, the heating will be turned off. While the heating is off, the temperature T in the room goes down according to the differential equation Ṫ = -T + 17. When the temperature becomes 18 • C, the heating will be turned on again.</p><p>The recursive specification of the thermostat consists of the following equations:</p><formula xml:id="formula_60">Th = (T = 18) ∧ Th on , Th on = (18 T 20 ∧ Ṫ = -T + 22) ∩ * rel (T = 20) :→ (T • = • T ) turn-off • Th off , Th off = (18 T 20 ∧ Ṫ = -T + 17) ∩ * rel (T = 18) :→ (T • = • T ) turn-on • Th on .</formula><p>The signal transition operator and the signal evolution operator ∩ are needed here to make precise that the temperature in the room does not change instantaneously at the points of time at which the heating is turned off or on and that the temperature in the room changes continuously as described above during the periods in between.</p><p>Using the axioms and lifting rules of BPA srt hs +INT+REC, we can prove that the solution of this recursive specification is the same as the solution of the recursive specification that consists of the following equations:</p><formula xml:id="formula_61">Th = (T = 18) ∧ Th on , Th on = (18 T 20 ∧ Ṫ = -T + 22) ∩ ln 2 rel (T • = • T ) turn-off • Th off , Th off = (18 T 20 ∧ Ṫ = -T + 17) ∩ ln 3 rel (T • = • T ) turn-on • Th on .</formula><p>It is clear from this specification that the heater is on for a fraction ln 2/ln 3 of the time. If we could hide the atomic propositions concerning the state variable T, we would even get the process recursively specified by the following equation:</p><formula xml:id="formula_62">Th = ln 2 rel turn-off • ln 3 rel turn-on • Th .</formula><p>For properties that do not concern the course of the values of T and Ṫ , the processes Th and Th do not show a single difference. Therefore, we would like to add a hiding operator v for each v ∈ V such that v P is the process that behaves like P, but with the dependence of its behaviour on the value of v and v made invisible. With the envisaged operator, we would have T Th = Th . However, this extension would require a semantics that carries more detail than the structural operational semantics given in this paper. For that reason, we consider it a topic for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Zeno behaviour</head><p>Consider an object that moves on a flat plane as follows. It starts moving from the point (1, 0), i.e. the point with x-coordinate 1 and y-coordinate 0, such that ẋ = -1 and ẏ = 0.5. When the x-coordinate becomes 0, it proceeds moving such that ẋ = 0.5 and ẏ = -1. When the y-coordinate becomes 0 once more, it proceeds moving again such that ẋ = -1 and ẏ = 0.5. And so on, and so forth. Thus the object approaches in a zig-zag way the point (0, 0), but never reaches it. Moreover, the direction of the object changes infinitely many times before 2 time units have elapsed. This phenomenon, infinitely many instantaneous state changes happening in a non-zero finite amount of time, is called Zeno behaviour. Obviously, such behaviour is unrealizable.</p><p>Nevertheless, BPA srt hs +INT+REC is expressive enough to describe Zeno behaviour. For example, the behaviour considered above can be described by the following equations:</p><formula xml:id="formula_63">O = (x = 1 ∧ y = 0) ∧ O r , O r = (x 0 ∧ ẋ = -1 ∧ ẏ = 0.5) ∩ * rel (x = 0) :→ (x • = • x ∧ y • = • y) turn-left • O l , O l = (y 0 ∧ ẋ = 0.5 ∧ ẏ = -1) ∩ * rel (y = 0) :→ (x • = • x ∧ y • = • y) turn-right • O r .</formula><p>Under bisimulation equivalence and ic-bisimulation equivalence, no distinction is made between behaviours that occur after a point of time at which infinitely many instantaneous state changes accumulate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Algebra of communicating processes</head><p>In this section, we extend BPA srt hs with operators to capture parallelism and communication. Beforehand, we give already an idea of the application of the resulting process algebra, called ACP srt hs , by means of an example concerning the temperature control of a nuclear reactor. We also illustrate its application by means of examples concerning a bottle-filling system and a railroad crossing system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Example: nuclear reactor</head><p>This section is a sample of the application of ACP srt hs . It is meant to give a first impression of how one describes the behaviour of hybrid systems composed of several components that proceed concurrently and interact with each other using ACP srt hs . We describe the behaviour of a simple nuclear reactor in which the temperature of the reactor core is controlled by two control rods. This example is adapted from Ref. <ref type="bibr" target="#b6">[7]</ref>. We take the following informal description of the behaviour of the reactor as the starting point of our formal description.</p><p>Initially, the temperature of the reactor core is 510 • C and the control rods are outside the reactor core. With the control rods outside the reactor core, the temperature T increases according to the differential equation Ṫ = 0.1T -50. The reactor must be shut down if the temperature becomes higher than 550 • C. To prevent a shutdown, one of the control rods should be put into the reactor core once the temperature becomes 550 • C. With control rod 1 inside the reactor core, the temperature T decreases according to the differential equation Ṫ = 0.1T -56. With control rod 2 inside the reactor core, the temperature T decreases according to the differential equation Ṫ = 0.1T -60. The control rod inside the reactor is removed from the reactor core once the temperature becomes 510 • C. When it is removed, it cannot be put back in the reactor core for the next c seconds. To prevent that the reactor ever needs to be shut down, the time c must be short enough to guarantee that, whenever the temperature of the reactor core becomes 550 • C, one of the control rods can be put back in the reactor core.</p><p>The recursive specification of the reactor core consists of the following equations:</p><formula xml:id="formula_64">C = (T = 510) ∧ C out , C out = (T 550 ∧ Ṫ = 0.1T -50) ∩ * rel (T = 550) :→ (T • = • T ) s 1 (add) • C in1 + * rel (T = 550) :→ (T • = • T ) s 2 (add) • C in2 , C in1 = (T 510 ∧ Ṫ = 0.1T -56) ∩ * rel (T = 510) :→ (T • = • T ) s 1 (rmv) • C out , C in2 = (T 510 ∧ Ṫ = 0.1T -60) ∩ * rel (T = 510) :→ (T • = • T ) s 2 (rmv) • C out .</formula><p>Each of the control rods is recursively defined by a single equation:</p><formula xml:id="formula_65">R 1 = * rel r 1 (add) • * rel r 1 (rmv) • c rel (R 1 ) , R 2 = * rel r 2 (add) • * rel r 2 (rmv) • c rel (R 2 ) .</formula><p>Assuming that the whole system starts with both control rods out of the core for at least c seconds, the reactor is described by the following term:</p><formula xml:id="formula_66">* H (C R 1 R 2 ),</formula><p>where</p><formula xml:id="formula_67">H = {s i (d) | i ∈ {1, 2}, d ∈ {add, rmv}} ∪ {r i (d) | i ∈ {1, 2}, d ∈ {add, rmv}}.</formula><p>We write s i (d), r i (d) and c i (d) for the action of sending d at port i, the action of receiving d at port i and the action of communicating d at port i, respectively. The action c i (d) is the action that is left when s i (d) and r i (d) are performed synchronously. This notation is the standardized notation for handshaking communication introduced for ACP in Ref. <ref type="bibr" target="#b18">[19]</ref>.</p><p>At this stage, we cannot explain this description fully. However, note that it appears to be a fairly direct representation of the informal description given above. In addition to constants and operators of ACP srt <ref type="bibr" target="#b13">[14]</ref> and ACP ps <ref type="bibr" target="#b10">[11]</ref>, the signal transition operator and the signal evolution operator ∩ introduced in Section 2.4 are used. These operators are needed to make precise that the temperature of the reactor core does not change instantaneously at the points of time at which a control rod is put into it or removed from it and that the temperature of the reactor core changes continuously as described above during the periods in between.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">ACP srt for hybrid systems</head><p>The basic ways of combining atomic processes into composite processes are sequential and alternative composition. A more advanced way of combining processes is parallel composition. Let P 1 and P 2 be processes. Then the parallel composition of P 1 and P 2 , written P 1 P 2 , is the process that proceeds with P 1 and P 2 in parallel. By this is roughly meant that it can behave in the following ways:</p><p>• first either P 1 or P 2 performs its first action and next it proceeds in parallel with the process following that action and the process that did not perform an action; • if their first actions can be performed synchronously, first P 1 and P 2 perform their first actions synchronously and next it proceeds in parallel with the processes following those actions. However, P 1 and P 2 may have to idle before they can perform their first action. Therefore, their parallel composition can only start with • performing an action of P 1 or P 2 if it can do so before or at the ultimate point of time for the other process to start performing actions or to deadlock; • performing an action of P 1 and an action of P 2 synchronously if both processes can do so at the same point of time. Moreover, the state transition caused by performing the first action of P 1 or P 2 must be one that is not precluded by the other process. By this is meant that • the signal of the other process must hold in the state immediately before the transition and the state immediately after the transition; • if the other process is idling when the action is performed, a state evolution with discontinuities for all state variables of which the value changes by the transition must be possible for the other process. We say that the discontinuities resulting from the transition are possible for the other process to indicate that the latter condition is fulfilled.</p><p>The point of view is that there is only one action left when actions are performed synchronously. Thus, we can amongst other things easily model handshaking communication: when the action s i (d) of sending datum d at port i and the action r i (d) of receiving datum d at port i are performed synchronously, only the action c i (d) of communicating datum d at port i is left.</p><p>Parallel composition does not prevent actions that can be performed synchronously from being performed on their own. In order to capture parallelism and communication fully, we have, in addition to parallel composition, encapsulation with respect to a certain set of actions. Let P be a process and H be a set of actions. Then the encapsulation of P with respect to H, written * H (P ), keeps P from performing actions in H. The process P becomes deadlocked at the point that one of these actions would otherwise be performed. The name encapsulation is used here because the actions in H are encapsulated from communication with actions coming from the environment of P.</p><p>We will use two auxiliary operators in the axiomatization of ACP srt hs : and |. The operator is interpreted as left merge, which is the same as parallel composition except that the left merge of P 1 and P 2 can only start with performing an action of P 1 . The operator | is interpreted as communication merge, which is the same as parallel composition except that the communication merge of P 1 and P 2 can only start with performing an action of P 1 and an action of P 2 synchronously.</p><p>We shall henceforth use H, H , . . . to stand for arbitrary subsets of A.</p><p>It is assumed that a fixed but arbitrary partial commutative and associative communication function : A × A → A has been given. The function is regarded to give the result of synchronously performing any two actions for which this is possible, and to be undefined otherwise.</p><p>The additional axioms for parallel composition and encapsulation are the equations given in Tables <ref type="table" target="#tab_0">11</ref><ref type="table" target="#tab_1">12</ref><ref type="table" target="#tab_4">13</ref><ref type="table" target="#tab_5">14</ref><ref type="table" target="#tab_12">15</ref>. Adding the equations given in Table <ref type="table" target="#tab_0">11</ref> to the axioms of BPA srt ⊥ gives us the subtheory ACP srt ⊥ , ACP srt with non-existence. Adding the equations given in Tables <ref type="table" target="#tab_0">11</ref> and<ref type="table" target="#tab_1">12</ref> to the axioms of BPA srt ps gives us the subtheory ACP srt ps , ACP srt with propositional signals. Adding the equations given in Tables <ref type="table" target="#tab_0">11</ref><ref type="table" target="#tab_1">12</ref><ref type="table" target="#tab_4">13</ref><ref type="table" target="#tab_5">14</ref>, with the exception of axioms CM2SRPS and CM3SRPS from Table <ref type="table" target="#tab_0">11</ref>, to the axioms and lifting rule of icBPA srt hs gives us the theory ACP srt hs , ACP srt for hybrid systems (note that axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3 are not present in ACP srt hs ). Adding the same equations, together with the equations given in Table <ref type="table" target="#tab_12">15</ref>, to the axioms and lifting rule of icBPA srt hs with integration gives us the theory ACP srt hs with integration. First of all, we look at the additional axioms for ACP srt ⊥ (Table <ref type="table" target="#tab_0">11</ref>). Axioms CM1, CM4, CM8, CM9, D3 and D4 are in common with ACP. Axioms CM2SRPS, CM3SRPS, CM5SR-CM7SR, CF1SR, CF2SR, D1SR and D2SR are simple reformulations of axioms CM2, CM3, CM5-CM7, CF1, CF2, D1 and D2 of ACP. For a detailed introduction to ACP, see Ref. <ref type="bibr" target="#b15">[16]</ref>. Axioms SRCM1aPS, SRCM1bPS, SRCM2, SRCM3PS, SRCM4PS, SRCM5 and SRD are new axioms concerning the interaction of relative delay with left merge, communication merge and encapsulation. The axioms given in Table <ref type="table" target="#tab_0">11</ref>, other than axioms NE4-NE7, are the axioms concerning parallel composition and encapsulation of ACP srt without the deadlocked process (see Ref. <ref type="bibr" target="#b13">[14]</ref>), but with ˜ replaced by * A ( rel (x)) or * A ( rel (y)) in the axioms of which the name ends with PS. This is to accommodate the addition of propositional signals: the signal of the left merge and communication merge of two processes is always the conjunction of the signals of both processes. Axioms NE4-NE7 concern the effect of left merge, communication merge and encapsulation on the non-existent process. The equation t ⊥ = ⊥ is derivable for all closed terms t. The Table <ref type="table" target="#tab_0">11</ref> Additional axioms for ACP srt ⊥ (a, b, c ∈ A , p 0, r &gt; 0)</p><formula xml:id="formula_68">x y = x y+y x+x | y CM1 ã x = ã • x+* A ( rel (x)) CM2SRPS ã • x y = ã • (x y)+* A ( rel (y)) CM3SRPS r rel (x) rel (y) = * A ( rel (y)) SRCM1aPS r rel (x) ( rel (y)+z) = r rel (x) z+* A ( rel (y)) SRCM1bPS r rel (x) r rel (y) = r rel (x y) SRCM2 (x+y) z = x z+y z CM4 ã • x | b = ( ã | b) • x CM5SR ã | b • x = ( ã | b) • x CM6SR ã • x | b • y = ( ã | b) • (x y) CM7SR rel (x) | r rel (y) = * A ( rel (x)) SRCM3PS r rel (x) | rel (y) = * A ( rel (y)) SRCM4PS r rel (x) | r rel (y) = r rel (x | y) SRCM5 (x+y) | z = x | z+y | z CM8 x | (y+z) = x | y+x | z CM9 ã | b = c if (a, b) = c CF1SR ã | b = ˜ if (a, b) undefined CF2SR * H ( ã) = ã if a ∈ H D1SR * H ( ã) = ˜ if a ∈ H D2SR * H ( p rel (x)) = p rel (* H (x)) SRD * H (x+y) = * H (x)+* H (y) D3 * H (x • y) = * H (x) • * H (y) D4 ⊥ x = ⊥ NE4 ⊥ | x = ⊥ NE5 x | ⊥ = ⊥ NE6 * H (⊥) = ⊥ NE7</formula><p>axioms of ACP srt ⊥ are essentially the axioms of ACP srt and ACP ⊥ with on top of that axiom NESRU (Table <ref type="table" target="#tab_0">1</ref>) concerning the effect of relative undelayable time-out on the non-existent process.</p><p>Secondly, we look at the additional axioms for ACP srt ps (Table <ref type="table" target="#tab_1">12</ref>). Axioms PSCM1-PSCM6, PSD1 and PSD2 are similar to the additional axioms for ACP ps (see Ref. <ref type="bibr" target="#b10">[11]</ref>). Terms of the form s (x) ∧ have been replaced by terms of the form * A ( rel (x)) instead of s (x) ∧ ˜ . However, the addition of the operator s would yield the derivability of * A ( rel (t)) = s (t) ∧ ˜ for all closed terms t. The other differences are due to the absence of the terminal signal emission operator and the choice of having as the signal of the left merge of two processes, as in the case of the communication merge, always the conjunction of the signals of both processes. This choice, originating from the variant with discrete Table <ref type="table" target="#tab_1">12</ref> Additional axioms for ACP srt ps (r &gt; 0)</p><formula xml:id="formula_69">( :→ x) y = :→ (x y)+* A ( rel (y)) PSCM1 ( :→ x) | y = :→ (x | y)+* A ( rel (y)) PSCM2 x | ( :→ y) = :→ (x | y)+* A ( rel (x)) PSCM3 ( ∧ x) y = ∧ (x y) PSCM4 ( ∧ x) | y = ∧ (x | y) PSCM5 x | ( ∧ y) = ∧ (x | y) PSCM6 r rel (x) ( :→ y+z) = :→ ( r rel (x) (y+z))+¬ :→ ( r rel (x) z) PSSRCM * H ( :→ x) = :→ * H (x) PSD1 * H ( ∧ x) = ∧ * H (x)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PSD2</head><p>Table <ref type="table" target="#tab_4">13</ref> Additional axioms for ACP srt hs (a ∈ A , r, s &gt; 0)</p><formula xml:id="formula_70">ã x = d (x) ã • x+* A ( rel (x)) CM2SRHS ã • x y = d (y) ã • (x y)+* A ( rel (y)) CM3SRHS ( ∩ V x) y = ∩ V (x y) HSCM1 ( ∩ V x) | y = ∩ V (x | y) HSCM2 x | ( ∩ V y) = ∩ V (x | y) HSCM3 ( rel (x)) y = ( rel (x) y)+* A ( rel (y)) HSCM4 ( x) | y = (x | y)+* A ( rel (y)) HSCM5 x | ( y) = (x | y)+* A ( rel (x)) HSCM6 r rel (x) ( ∩ V r rel (y)+z) = r rel (x) ( r rel ( ∩ V y)+z)+ ∩ V r rel ( ˜ ) HSSRCM * H ( ∩ V x) = ∩ V * H (x) HSD1 * H ( x) = * H (x)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HSD2</head><p>Table <ref type="table" target="#tab_5">14</ref> Axioms for root discontinuity operator (a ∈ A , r &gt; 0)</p><formula xml:id="formula_71">d (⊥) = F RDO1 d ( ã) = T RDO2 d ( r rel (x)) = T RDO3 d (x+y) = d (x) ∧ d (y) RDO4 d (x • y) = d (x) RDO5 d ( :→ x) = • →d (x) RDO6 d ( ∧ x) = • ∧ d (x) RDO7 d ( ∩ V rel (x)) = • ∧ d ( rel (x)) RDO8 d ( ∩ V r rel (x)) = • ∧ C V RDO9 d ( x) = • ( • )→d (x) RDO10</formula><p>relative timing introduced in Ref. <ref type="bibr" target="#b22">[23]</ref>, is required for axiom PSSRCM to be sound. Axiom PSSRCM is useful dealing with the parallel composition of processes that are conditionally capable of idling. Note that axioms NE4-NE7 are derivable from axioms PSCM4, PSCM5, PSCM6, PSD2 and SE2. Note further that the following generalization of axiom </p><formula xml:id="formula_72">(F (u) x) = ( u∈U F (u)) x INT14 u∈U (F (u) | x) = ( u∈U F (u)) | x INT15 u∈U (x | F (u)) = x | ( u∈U F (u)) INT16 u∈U * H (F (u)) = * H ( u∈U F (u)) INT17 d ( u∈U F (u)) = p∈U d (F (p))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RDO11</head><p>PSSRCM is derivable:</p><formula xml:id="formula_73">r rel (x) ( :→ y+ :→ z) = ( ∧ ) :→ ( r rel (x) (y+z)) +( ∧ ¬ ) :→ ( r rel (x) y)+(¬ ∧ ) :→ ( r rel (x) z).</formula><p>The following equation is derivable for all closed terms t and t :</p><formula xml:id="formula_74">t ( ∧ t ) = ∧ (t ∧ t ).</formula><p>The axioms of ACP srt ps are essentially the axioms of ACP srt and ACP ps with on top of that axiom PSSRCM, axiom NESRU (Table <ref type="table" target="#tab_0">1</ref>) concerning the effect of relative undelayable time-out on the non-existent process and axioms PSSRU1 and PSSRU2 (Table <ref type="table" target="#tab_1">2</ref>) concerning the interaction of relative undelayable time-out with conditional proceeding and signal emission.</p><p>Finally, we look at the additional axioms for ACP srt hs (Tables <ref type="table" target="#tab_4">13</ref> and<ref type="table" target="#tab_5">14</ref>). Axioms CM2SRHS and CM3SRHS from Table <ref type="table" target="#tab_4">13</ref> replace axioms CM2SRPS and CM3SRPS from Table <ref type="table" target="#tab_0">11</ref>. These new axioms are needed to reflect that in the parallel composition of two processes the discontinuities resulting from the transition caused by performing the first action of one of them must be possible for the other. The auxiliary root discontinuity operator d , of which axioms RDO1-RDO10 are the defining equations, yields the transition proposition that characterizes the transitions from which only discontinuities result that are possible for a process. Recall that</p><formula xml:id="formula_75">C V abbreviates v∈V (v • = • v ∧ v• = • v).</formula><p>The following substitution instances of axioms CM2SRPS and CM3SRPS are derivable for all closed terms t in which the signal evolution operator only occurs in subterms of the form ∩ ∅ t :</p><formula xml:id="formula_76">ã t = ã • t+* A ( rel (t)), ã • x t = ã • (x t)+* A ( rel (t)).</formula><p>Hence, the auxiliary operator d , and the replacement of axioms CM2SRPS and CM3SRPS by axioms CM2SRHS and CM3SRHS, would not be needed if the preclusion of discontinuities for certain state variables in state evolutions was not supported. Axioms HSCM1-HSCM6, HSSRCM, HSD1 and HSD2 show that signal evolution and signal transition take effect over what takes place first, also in the presence of parallel composition and encapsulation. Obviously, we do not have x ( ∩ V y) = ∩ V (x y): y may not be done with idling when x performs its first action. Axiom HSSRCM shows that notwithstanding that, if two processes idle in parallel, signal evolution takes place in a way possible for both processes. Note that the following variation of axiom HSSRCM is derivable:</p><formula xml:id="formula_77">r rel (x) ( ∩ V r rel (y)+ ∩ V r rel (z)) = r rel (x) ( r rel ( ∩ V y)+ r rel ( ∩ V z))+( ∧ ) ∩ V ∪V r rel ( ˜ ).</formula><p>Using the axioms of ACP srt hs , we can, for example, derive the following equations:</p><formula xml:id="formula_78">2 rel ((v • = • v + 1) ã • 1 rel ( b)) (( v = 0) ∩ {v} 3 rel ( c)) = ( v = 0) ∩ {v} 2 rel ( ˜ ), 2 rel ((v • = • v + 1) ã • 1 rel ( b)) (( v = 0) ∩ ∅ 3 rel ( c)) = ( v = 0) ∩ ∅ 2 rel ((v • = • v + 1) ã • (( v = 0) ∩ ∅ 1 rel ( b • ( v = 0) ∧ c+ c • b))).</formula><p>Note the difference on the left-hand side of these equations:</p><formula xml:id="formula_79">( v = 0) ∩ {v} 3 rel ( c) precludes discontinuities for v, but ( v = 0) ∩ ∅ 3 rel ( c) does not preclude discontinuities for v.</formula><p>We can prove that all closed terms of ACP srt hs can be reduced to a closed term of BPA srt hs .</p><p>Theorem 9 (Elimination). For all closed terms t of ACP srt hs , there exists a closed term t of BPA srt hs such that t = t is derivable from the axioms of ACP srt hs .</p><p>Proof. See Appendix A.4.</p><p>As a corollary of Theorem 9, we have that all closed terms of ACP srt hs can be reduced to a basic term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 10 (Elimination). For all closed terms t of ACP srt</head><p>hs , there exists a basic term t such that t = t is derivable from the axioms of ACP srt hs .</p><p>Integration can be added to ACP srt ⊥ , ACP srt ps as well as ACP srt hs . The additional axioms for integration (Table <ref type="table" target="#tab_12">15</ref>) can be regarded as variants of axioms CM4, CM8, CM9, D3 and RDO4.</p><p>We shall henceforth use the name ACP srt hs +INT to refer to the extension of ACP srt hs with integration and the name ACP srt hs +INT+REC to refer to the extension of ACP srt hs +INT with guarded recursion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Two-phase derivation</head><p>The equations added to the axioms of icBPA srt hs to obtain ACP srt hs , cannot be added to BPA srt hs : if axiom HST5, axiom HST14, lifting rule HSELR2 or lifting rule HSELR3 is added to ACP srt hs , the result is not sound. For example, we can derive the following equation from the axioms of ACP srt hs :</p><formula xml:id="formula_80">((v = 0) ∧ ((v • = • v + 1) ã • ((v = 0) :→ b))) ((v • = • v -1) c) = (v = 0) ∧ ((v • = • v + 1) ã • ((v • = • v -1) c • b)).</formula><p>However, if we add axiom HST5 to ACP srt hs , we can also derive the following equation:</p><formula xml:id="formula_81">(v = 0) ∧ ((v • = • v + 1) ã • ((v = 0) :→ b)) = (v = 0) ∧ ((v • = • v + 1) ã • ˜ ).</formula><p>Then by substitution of the right-hand side for the left-hand side in the previous equation, and next further derivation from the axioms of ACP srt hs , we get:</p><formula xml:id="formula_82">((v = 0) ∧ ((v • = • v + 1) ã • ((v = 0) :→ b))) ((v • = • v -1) c) = ((v = 0) ∧ ((v • = • v + 1) ã • ˜ )) ((v • = • v -1) c) = (v = 0) ∧ ((v • = • v + 1) ã • ((v • = • v -1) c • ˜ )).</formula><p>Yet, we have that</p><formula xml:id="formula_83">(v = 0) ∧ ((v • = • v + 1) ã • ((v • = • v -1) c • b)) ↔ (v = 0) ∧ ((v • = • v + 1) ã • ((v • = • v -1) c • ˜ )), (v = 0) ∧ ((v • = • v + 1) ã • ((v • = • v -1) c • b)) ↔ (v = 0) ∧ ((v • = • v + 1) ã • ((v • = • v -1) c • ˜ )).</formula><p>The problem is that bisimulation equivalence is not preserved by parallel composition, left merge and communication merge whereas axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3 are not sound under ic-bisimulation equivalence. Because we still want to use these axioms and lifting rules, we introduce two-phase derivation which only permits the use of axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3 in the absence of parallel composition, left merge and communication merge. With the introduction of two-phase derivation we follow an idea from Ref. <ref type="bibr" target="#b31">[32]</ref>, where this kind of derivation was introduced to deal with a comparable problem.</p><p>Let </p><formula xml:id="formula_84">+ Ext ٛ t 1 = t 1 , ACP srt hs + Ext ٛ t 2 = t 2 , BPA srt hs + Ext ٛ t 1 = t 2 .</formula><p>Here, HSL refers to the extension with localization, which is treated in Section 5.</p><p>It is worth mentioning that the proofs of Theorems 1 and 9 show that axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3 are not needed to obtain the elimination results. If they would be needed, the idea of two-phase derivation would be useless.</p><p>Two-phase derivation does not permit the undesirable derivation given above. However, it does permit the derivations leading to the simplications of descriptions of hybrid systems shown in Sections 4.6 and 4.7. Those simplications, which facilitate analysis of the systems concerned, would not be possible otherwise.</p><p>The need for two-phase derivation originates from the potentiality of interference between parallel processes through shared state variables. Two-phase derivation may hinder a modular approach to hybrid system description and analysis. To remedy this largely, we could adapt two-phase derivation in such a way that it takes into account the absence of shared state variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Operational semantics of ACP srt hs</head><p>The structural operational semantics for parallel composition, left merge, communication merge and encapsulation is described by the rules given in Tables <ref type="table" target="#tab_0">16</ref> and<ref type="table" target="#tab_0">17</ref>. In Table <ref type="table" target="#tab_0">17</ref>, we use a to stand for elements of A . The following additional transition relations are used:</p><formula xml:id="formula_85">• a unary relation → ∈ [d(_ )] for each , : V ∪ V → R.</formula><p>We write t, → for the set of all transition formulas ¬( t, r, --→ t , ) where t is a closed term of ACP srt hs , : V ∪ V → R, r ∈ R &gt; and ∈ E r . The auxiliary discontinuity relations → ∈ [d(_ )] can be explained as follows:</p><p>• → ∈ [d(t)]: in state , the discontinuities resulting from a transition to state are possible for process t. The following is an important property of the transition relations defined by the transition rules given for ACP srt hs . We have for all closed terms t, for all , : V ∪ V → R:</p><formula xml:id="formula_86">→ ∈ [d(t)] implies ∈ [s(t)].</formula><p>Note that we have for all closed terms t in which the signal evolution operator only occurs in subterms of the form ∩ ∅ t , for all , : V ∪ V → R:</p><formula xml:id="formula_87">→ ∈ [d(t)] iff ∈ [s(t)].</formula><p>Hence, the auxiliary transition relations → ∈ [d(_ )] would be superfluous if the preclusion of discontinuities for certain state variables in state evolutions was not supported. We also have for all closed terms t and states and :</p><formula xml:id="formula_88">→ ∈ [d(t)] iff → d (t).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.">Bisimulation and soundness</head><p>The definitions of bisimulation equivalence and ic-bisimulation equivalence have to be adapted to the addition of discontinuity relations. The following condition must be added to both definitions:</p><formula xml:id="formula_89">• whenever → ∈ [d(t 1 )], then → ∈ [d(t 2 )].</formula><p>The following example shows that bisimulation equivalence is not preserved by all operators of ACP srt hs . We have </p><formula xml:id="formula_90">(v • = 1) ã • ((v = 0) :→ b) ↔ (v • = 1) ã • ˜ .</formula><formula xml:id="formula_91">(a, b, c ∈ A, r &gt; 0) x, a -→ x , , → ∈ [d(y)], ∈ [s(y)] x y, a -→ x y, → ∈ [d(x)], ∈ [s(x)], y, a -→ y , x y, a -→ x y , x, a -→ √ , , → ∈ [d(y)], ∈ [s(y)] x y, a -→ y, → ∈ [d(x)], ∈ [s(x)], y, a -→ √ , x y, a -→ x, x, a -→ x , , y, b -→ y , x y, c -→ x y , (a, b) = c x, a -→ x , , y, b -→ √ , x y, c -→ x , (a, b) = c x, a -→ √ , , y, b -→ y , x y, c -→ y , (a, b) = c x, a -→ √ , , y, b -→ √ , x y, c -→ √ , (a, b) = c x, r, --→ x , , y, r, --→ y , x y, r, --→ x y , x, a -→ x , , → ∈ [d(y)], ∈ [s(y)] x y, a -→ x y, x, a -→ √ , , → ∈ [d(y)], ∈ [s(y)] x y, a -→ y, x, r, --→ x , , y, r, --→ y , x y, r, --→ x y , x, a -→ x , , y, b -→ y , x | y, c -→ x y , (a, b) = c x, a -→ x , , y, b -→ √ , x | y, c -→ x , (a, b) = c x, a -→ √ , , y, b -→ y , x | y, c -→ y , (a, b) = c x, a -→ √ , , y, b -→ √ , x | y, c -→ √ , (a, b) = c x, r, --→ x , , y, r, --→ y , x | y, r, --→ x | y , x, a -→ x , * H (x), a -→ * H (x ), a ∈ H x, a -→ √ , * H (x), a -→ √ , a ∈ H x, r, --→ x , * H (x), r, --→ * H (x ), ∈ [s(x)], ∈ [s(y)] ∈ [s(x y)] ∈ [s(x)], ∈ [s(y)] ∈ [s(x y)] ∈ [s(x)], ∈ [s(y)] ∈ [s(x | y)] ∈ [s(x)] ∈ [s(* H (x))]</formula><p>Firstly, we take the left-hand side as the first argument of a left merge with (v • = 0) c. A possible sequence of transitions is</p><formula xml:id="formula_92">((v • = 1) ã • ((v = 0) :→ b)) ((v • = 0) c), v → * a -→ ((v = 0) :→ b) ((v • = 0) c), v → 1 c -→ (v = 0) :→ b, v → 0 b -→ √ , v → 0 . Table 17 Rules for → ∈ [d(_ )] (a ∈ A , r &gt; 0) → ∈ [d( ã)] → ∈ [d(x)] → ∈ [d( 0 rel (x))] → ∈ [d( r rel (x))] → ∈ [d(x)], → ∈ [d(y)] → ∈ [d(x+y)] → ∈ [d(x)] → ∈ [d(x • y)] → ∈ [d(x)] → ∈ [d( :→ x)] → ∈ [d( :→ x)] → ∈ [d(x)] → ∈ [d( ∧ x)] → ∈ [d(x)], x, r, --→ x , → ∈ [d( ∩ V x)] → C V , → ∈ [d(x)], x, → → ∈ [d( ∩ V x)] → ∈ [d(x)] → ∈ [d( x)] → ∈ [d( x)] • ∈ [s(x)] → ∈ [d( rel (x))] → ∈ [d(x)], → ∈ [d(y)], x y, r, --→ x , → ∈ [d(x y)] ∈ [s(x)], ∈ [s(y)], x y, → → ∈ [d(x y)] → ∈ [d(x)], → ∈ [d(y)], x y, r, --→ x , → ∈ [d(x y)] ∈ [s(x)], ∈ [s(y)], x y, → → ∈ [d(x y)] → ∈ [d(x)], → ∈ [d(y)], x | y, r, --→ x , → ∈ [d(x | y)] ∈ [s(x)], ∈ [s(y)], x | y, → → ∈ [d(x | y)] → ∈ [d(x)] → ∈ [d(* H (x))] { → ∈ [d(F (q))] | q ∈ U } → ∈ [d( u∈U F (u))] → ∈ [d( t X |E )] → ∈ [d( X|E )] X = t X ∈ E</formula><p>Here, v → r denotes the state in which the value of v is r; and * is any real number. Secondly, we take the right-hand side as the first argument of a left merge with (v • = 0) c. The only possible sequence of transitions starting from the same state is</p><formula xml:id="formula_93">((v • = 1) ã • ˜ ) ((v • = 0) c), v → * a -→ ˜ ((v • = 0) c), v → 1 c -→ ˜ , v → 0 .</formula><p>This discrepancy does not occur with ic-bisimulation equivalence because</p><formula xml:id="formula_94">(v • = 1) ã • ((v = 0) :→ b) ↔ (v • = 1) ã • ˜ .</formula><p>Ic-bisimulation equivalence is preserved by all operators of ACP srt hs .</p><p>Theorem 11 (Congruence). Ic-bisimulation equivalence is a congruence with respect to the operators of ACP srt hs . Proof. For ic-bisimulation equivalence, congruence follows immediately from the following. The transition rules for ACP srt hs constitute a complete transition system specification in panth format, and ic-bisimulation equivalence is the equivalence which is guaranteed to be a congruence in that case (see e.g. Refs. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b46">47]</ref>). <ref type="foot" target="#foot_2">5</ref>The axioms and lifting rule of ACP srt hs are sound with respect to ic-bisimulation equivalence.</p><p>Theorem 12 (Soundness). For all closed terms t 1 and t 2 of ACP srt hs , we have</p><formula xml:id="formula_95">ACP srt hs ٛ t 1 = t 2 implies t 1 ↔ t 2 .</formula><p>Proof. See Appendix A.5.</p><p>As a corollary of Theorems 7 and 12, we have the soundness of two-phase derivation.</p><p>Corollary 13 (Soundness). For all closed terms t 1 and t 2 of ACP srt hs , we have ACP srt hs /BPA srt hs ٛ 2 t 1 = t 2 implies t 1 ↔ t 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.">Example: bottle-filling system</head><p>In this section, we consider a bottle-filling system. This example is adapted from Ref. <ref type="bibr" target="#b32">[33]</ref>. The bottle-filling system consists of two subsystems, a conveyer belt CB and a container C, which proceed concurrently. They communicate with each other at ports 1 and 2. The configuration of the bottle-filling system is shown in Fig. <ref type="figure">1</ref>. We take the following informal description of the bottle-filling system as the starting point of our specifications of the conveyer belt and the container.</p><p>Bottles on a conveyer belt are filled with 10 L of liquid poured from a container. When a bottle is put under the container, a tap is opened and the bottle is filled at a rate of 3 L/s until the container becomes empty or the bottle becomes full, whatever happens first. In the case where the container becomes empty first, the bottle is filled further at the same rate as the container. When the bottle is full, the tap is closed and the conveyer belt starts moving to put the next bottle under the container, which takes 1 s. The container is filled at a constant rate of r litre per second. Its capacity is m litre. Naturally, it is highly preferable that overflow never occurs. It is also preferable that the container does not get empty during the filling of each bottle. It is assumed that initially the conveyer belt starts moving to put the first bottle under the container and the container is half full.</p><p>The recursive specifications of the conveyer belt and the container given below need no further explanation because they are fairly direct representations of the corresponding informal descriptions. The recursive specification of the conveyer belt consists of the following equations:</p><formula xml:id="formula_96">CB = (b = 0 ∧ ḃ = 0) ∩ 1 rel (b • = • b) s 1 (start) • CB nf , CB nf = (b 10 ∧ ḃ = 3) ∩ * rel (b • = • b) r 2 (empty) • CB sf + * rel (b = 10) :→ (b • = 0) s 1 (stop) • CB , CB sf = (b 10 ∧ ḃ = r) ∩ * rel (b = 10) :→ (b • = 0) s 1 (stop) • CB .</formula><p>The recursive specification of the container consists of the following equations:</p><formula xml:id="formula_97">C = (c = m/2) ∧ C inc , C inc = (c m ∧ ċ = r) ∩ * rel (c &lt; m) :→ (c • = • c) r 1 (start) • C dec + * rel (c = m) :→ (c • = • c) overflow • ˜ , C dec = (c 0 ∧ ċ = r -3) ∩ * rel (c &gt; 0) :→ (c • = • c) r 1 (stop) • C inc + * rel (c = 0) :→ (c • = • c) s 2 (empty) • C dry , C dry = (c = 0) ∩ * rel (c • = • c) r 1 (stop) • C inc .</formula><p>The whole system is described by the following term:</p><formula xml:id="formula_98">* H (CB C),</formula><p>where</p><formula xml:id="formula_99">H = {s 1 (d) | d ∈ {start, stop}} ∪ {r 1 (d) | d ∈ {start, stop}} ∪ {s 2 (empty)} ∪ {r 2 (empty)}</formula><p>and the communication function is defined such that</p><formula xml:id="formula_100">(s i (d), r i (d)) = (r i (d), s i (d)) = c i (d)</formula><p>for all d ∈ {start, stop, empty} and i ∈ {1, 2}, and it is undefined otherwise.</p><p>Using the axioms and lifting rule of ACP srt hs +INT+REC and the axioms and lifting rules of BPA srt hs +INT+REC, we obtain by means of two-phase derivation the following guarded recursive specification of the whole system:</p><formula xml:id="formula_101">X ini = (c = m/2) ∧ X mv m/2 , X mv c = (b = 0 ∧ ḃ = 0 ∧ c m ∧ ċ = r) ∩ 1 rel (b • = • b ∧ c • = • c) c 1 (start) • X nf c +r (for every c &lt; m -r), X mv c = (b = 0 ∧ ḃ = 0 ∧ c m ∧ ċ = r) ∩ (m-c )/r rel (b • = • b ∧ ḃ• = • ḃ ∧ c • = • c) overflow • ˜ (for every m -r c &lt; m), X nf c = (b 10 ∧ ḃ = 3 ∧ c 0 ∧ ċ = r -3) ∩ 10/3 rel (b • = 0 ∧ c • = • c) c 1 (stop) • X mv c -(3-r)(10/3) (for every (3 -r)(10/3) &lt; c &lt; m), X nf c = (b 10 ∧ ḃ = 3 ∧ c 0 ∧ ċ = r -3) ∩ c /(3-r) rel (b • = • b ∧ c • = • c) c 2 (empty) • X sf 3c /(3-r) (for every c (3 -r)(10/3)), X sf b = (b 10 ∧ ḃ = r ∧ c = 0) ∩ (10-b )/r rel (b • = 0 ∧ c • = • c) c 1 (stop) • X mv 0</formula><p>(for every b 10).</p><p>From this recursive specification, it is easy to see that the contents c of the container fluctuates around m/2 liters and overflow never occurs if r = 30 13 and m/2 &gt; r. If r &gt; 30  13 , eventually overflow occurs. If r &lt; 30  13 , overflow never occurs but during the filling of each bottle the container gets empty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7.">Example: railroad crossing system</head><p>In this section, we consider a railroad crossing system. This example is adapted from Ref. <ref type="bibr" target="#b6">[7]</ref>. The configuration of the railroad crossing system is shown in Fig. <ref type="figure" target="#fig_1">2</ref>. Analysis meant to provide answers to various basic questions about the railroad crossing system requires that the behaviour of its controller as well as the behaviour of the trains and the gate is described. We take the following informal description of the railroad crossing system from Ref. <ref type="bibr" target="#b32">[33]</ref> as the starting point of our specifications. When a train approaches the gate from a great distance its speed is between 48 and 52 m/s. As soon as it passes the detector placed at 1000 m backward from the gate, an appr signal is sent to the controller. The train may now slow down, but its speed stays between 40 and 52 m/s, and pass the gate. As soon as it passes the detector placed at 100 m forward from the gate, an exit signal is sent to the controller. A new train may come after the current one has passed the second detector, but only at a distance greater than or equal to 1500 m. The gate is able to receive lower and raise signals from the controller at any time. As soon as the gate receives a lower signal, it lowers from 90 • to 0 • at a constant rate of 20 • per second. As soon as it receives a raise signal, it raises from 0 • to 90 • at the same rate. The controller is able to receive appr and exit signals from the train detectors at any time. When the controller receives an appr signal, it takes less than 5 s before a lower signal is sent to the gate. When the controller receives an exit signal, it takes less than 5 s before a raise signal is sent to the gate. Because of fault tolerance considerations, appr signals should always cause the gate to go down, and exit signals should be ignored while the gate is going down. It is assumed that initially there is no train at a distance smaller than 1400 m backward from the gate, the gate is open, and the controller is idling. Moreover, it is assumed that each single train changes its speed only smoothly.</p><p>It is worth mentioning that the identity of the trains passing the gate is not relevant to the analysis of the functioning of the railroad crossing system. Whatever the trains, the railroad crossing system treats them all the same.</p><p>The recursive specifications of the train movement, the gate and the controller given below need no further explanation because they are fairly direct representations of the corresponding informal descriptions. The recursive specification of the train movement consists of the following equations:</p><formula xml:id="formula_102">Trains = (x -1400) ∧ T far , T far = (x -1000 ∧ 48 ẋ 52) ∩ * rel (x = -1000) :→ (x • = • x ∧ ẋ• = • ẋ) s 1 (appr) • T near , T near = (-1000 x 0 ∧ 40 ẋ 52) ∩ * rel (x = 0) :→ (x • = • x ∧ ẋ• = • ẋ) pass • T past , T past = (0 x 100 ∧ 40 ẋ 52) ∩ * rel (x = 100) :→ (x • -1400) s 1 (exit) • T far .</formula><p>The recursive specification of the gate consists of the following equations:</p><formula xml:id="formula_103">Gate = (r = 90) ∧ G op , G op = (r = 90 ∧ ṙ = 0) ∩ * rel (r • = • r) r 2 (lower) • G dn + * rel (r • = • r) r 2 (raise) • G op , G dn = (0 r 90 ∧ ṙ = -20) ∩ * rel (r • = • r) r 2 (lower) • G dn + * rel (r • = • r) r 2 (raise) • G up + * rel (r = 0) :→ (r • = • r) ready dn • G cl , G cl = (r = 0 ∧ ṙ = 0) ∩ * rel (r • = • r) r 2 (lower) • G cl + * rel (r • = • r) r 2 (raise) • G up , G up = (0 r 90 ∧ ṙ = 20) ∩ * rel (r • = • r) r 2 (lower) • G dn + * rel (r • = • r) r 2 (raise) • G up + * rel (r = 90) :→ (r • = • r) ready up • G op .</formula><p>The recursive specification of the controller consists of the following equations:</p><formula xml:id="formula_104">Cntr = (d = 0) ∧ C idle , C idle = ( ḋ = 0) ∩ * rel (d • = 0) r 1 (appr) • C dn + * rel (d • = 0) r 1 (exit) • C up , C dn = (0 d 5 ∧ ḋ = 1) ∩ * rel (d • = 0) s 2 (lower) • C idle + * rel (d • = • d) r 1 (appr) • C dn + * rel (d • = • d) r 1 (exit) • C dn , C up = (0 d 5 ∧ ḋ = 1) ∩ * rel (d • = 0) s 2 (raise) • C idle + * rel (d • = 0) r 1 (appr) • C dn + * rel (d • = • d) r 1 (exit) • C up .</formula><p>The whole system is described by the following term:</p><formula xml:id="formula_105">* H (Trains Cntr Gate),</formula><p>where</p><formula xml:id="formula_106">H = {s 1 (d) | d ∈ {appr, exit}} ∪ {r 1 (d) | d ∈ {appr, exit}} ∪ {s 2 (d) | d ∈ {lower, raise}} ∪ {r 2 (d) | d ∈ {lower, raise}}</formula><p>and the communication function is defined such that</p><formula xml:id="formula_107">(s i (d), r i (d)) = (r i (d), s i (d)) = c i (d)</formula><p>for all d ∈ {appr, exit, lower, raise} and i ∈ {1, 2}, and it is undefined otherwise.</p><p>Using the axioms and lifting rule of ACP srt hs +INT+REC and the axioms and lifting rules of BPA srt hs +INT+REC, we obtain by means of two-phase derivation the following guarded recursive specification of the whole system:</p><formula xml:id="formula_108">X 0 = (x -1400 ∧ d = 0 ∧ r = 90) ∧ X 1 0 , X 1 t = (x -1000 ∧ 48 ẋ 52 ∧ ḋ = 0 ∧ r = 90 ∧ ṙ = 0) ∩ t∈[400/52-t ,∞) t rel (d • = 0 ∧ C {x,r} ) c 1 (appr) • X 2 0</formula><p>(for every t &lt; 90/20 + 5),</p><formula xml:id="formula_109">X 2 t = (-1000 x 0 ∧ 40 ẋ 52 ∧ 0 d 5 ∧ ḋ = 1 ∧ r = 90 ∧ ṙ = 0) ∩ t∈[0,5-t ) t rel (d • = 0 ∧ r • = • r ∧ C {x} ) c 2 (lower) • X 3 t +t,90</formula><p>(for every t &lt; 90/20 -(400/52 -5)),</p><formula xml:id="formula_110">X 3 t ,r = (-1000 x 0 ∧ 40 ẋ 52 ∧ ḋ = 0 ∧ 0 r 90 ∧ ṙ = -20) ∩ r/20 rel (r • = • r ∧ C {x,d} ) ready dn • X 4 t +r/20</formula><p>(for every t &lt; 5 and r 90),</p><formula xml:id="formula_111">X 4 t = (-1000 x 0 ∧ 40 ẋ 52 ∧ ḋ = 0 ∧ r = 0 ∧ ṙ = 0) ∩ t∈[1000/52-t ,1000/40-t ] t rel C {x,d,r} pass • X 5</formula><p>(for every t &lt; 90/20 + 5),</p><formula xml:id="formula_112">X 5 = (0 x 100 ∧ 40 ẋ 52 ∧ ḋ = 0 ∧ r = 0 ∧ ṙ = 0) ∩ t∈[100/52,100/40] t rel (x • -1400 ∧ d • = 0 ∧ C {r} ) c 1 (exit) • X 6 , X 6 = (x -1000 ∧ 48 ẋ 52 ∧ 0 d 5 ∧ ḋ = 1 ∧ r = 0 ∧ ṙ = 0) ∩ t∈[0,5) t rel (d • = 0 ∧ r • = • r ∧ C {x} ) c 2 (raise) • X 7 t , X 7 t = (x -1000 ∧ 48 ẋ 52 ∧ ḋ = 0 ∧ 0 r 90 ∧ ṙ = 20) ∩ t∈[400/52-t ,90/20) t rel (d • = 0 ∧ C {x,r} ) c 1 (appr) • X 8 t + 90/20 rel (r • = • r ∧ C {x,d} ) ready up • X 1 t +90/20</formula><p>(for every t &lt; 5),</p><formula xml:id="formula_113">X 8 t = (-1000 x 0 ∧ 40 ẋ 52 ∧ 0 d 5 ∧ ḋ = 1 ∧ 0 r 90 ∧ ṙ = 20) ∩ t∈[0,90/20-t ) t rel (d • = 0 ∧ r • = • r ∧ C {x} ) c 2 (lower) • X 3 t,20(t +t) + 90/20-t rel (r • = • r ∧ C {x,d} ) ready up • X 2 90/20-t</formula><p>(for every 400/52 -5 &lt; t &lt; 90/20).</p><p>Recall that</p><formula xml:id="formula_114">C V abbreviates v∈V (v • = • v ∧ v• = • v).</formula><p>From this recursive specification, it is not difficult to see that (1) a train can only pass the gate when the gate is closed, (2) the gate opens after a train has left the track unless a new train has entered the track and (3) the system reacts adequately when a new train enters the track while the gate is going up. Analysis of this recursive specification is sufficient for virtually all relevant safety and liveness properties of the system in this case where it is not the continuously changing state that has to be controlled. For example, although it is important to know when a train passes the gate, it is in this case not important to know where the train is during its approach. However, it is most likely different in those cases where it is the continuously changing state that has to be controlled. In all cases, an important advantage of using the proposed process algebra for the description and analysis of hybrid systems is that one does not have to be finished with real analysis before one can use process algebra. For example, a process algebra with timing can only be used for the description and analysis of a hybrid system after all timing that arises from the continuous behaviour of the system has been determined with the help of real analysis-with the danger of abstracting too far-whereas real analysis is irrelevant in the stage where the process algebra with timing is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Localization</head><p>In this section, we extend ACP srt hs with localization. The localization operator makes it possible to keep discontinuities of a state variable local, in other words to inhibit discontinuities of the state variable caused by the environment. This extension can be useful in various applications. We illustrate this by means of an example concerning a vehicle with velocity control.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">ACP srt hs with localization</head><p>In order to support the preclusion of discontinuities for certain state variables due to actions performed by the environment of a process, we add localization to ACP srt hs . Let P be a process and v be a state variable. Then the localization of P with respect to v, written v∇P , behaves like P, but with its state evolving without discontinuities for v whenever it is idling.</p><p>In the railroad crossing system described in Section 4.7, the signal evolution operator is consistently used in such a way that the states of Trains, Gate and Cntr, as well as consequently the state of the whole system, must always evolve during idling without discontinuities for all state variables. This is possible because, for each state variable, there Table <ref type="table" target="#tab_0">18</ref> Axioms for localization (a ∈ A , r &gt; 0)</p><formula xml:id="formula_115">v∇⊥ = ⊥ HSL1 v∇ ã = ã HSL2 v∇ r rel (x) = T ∩ {v} r rel (v∇x) HSL3 v∇(x+y) = v∇x+v∇y HSL4 v∇x • y = (v∇x) • (v∇y) HSL5 v∇( :→ x) = :→ (v∇x) HSL6 v∇( ∧ x) = ∧ (v∇x) HSL7 v∇( ∩ V x) = ∩ V (v∇x) HSL8 v∇( ã) = ã HSL9 v∇(v ∇x) = v ∇(v∇x) HSL10 v∇( u∈U F (u)) = u∈U (v∇F (u)) HSL11</formula><p>is only one process that may cause discontinuities of the state variable, there is only one process that behaves dependent on the value of the state variable, and those processes are the same. That is, the state variables x, r and d are local to the processes Trains, Gate and Cntr, respectively. With or without localization, these processes, as well as the whole system, behave exactly the same. In other systems, we sometimes find that some state variable is not local, but shared by two or more processes. This means that the signal evolution operator has to be used in such a way that the states of those processes may sometimes evolve during idling with discontinuities for that state variable. In such cases, localization of the whole system inhibits further discontinuities caused by its environment. It is worth noticing that real analysis would not be a great help to the analysis of the system, if its state could evolve with discontinuities when it is idling. The use of localization will be illustrated in Section 5.2. The additional axioms for localization are the equations given in Table <ref type="table" target="#tab_0">18</ref>. Axioms HSL1-HSL11 show that localization is a global version of an instance of signal evolution.</p><p>We shall henceforth use the name ACP srt hs +INT+REC+HSL to refer to the extension of ACP srt hs +INT+REC with localization, and likewise the name BPA srt hs + INT+REC+HSL.</p><p>The structural operational semantics for localization is described by the rules given in Table <ref type="table" target="#tab_11">19</ref>. Bisimulation equivalence and ic-bisimulation equivalence are preserved by localization. All additional axioms for localization are sound with respect to bisimulation equivalence and ic-bisimulation equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Example: vehicle with velocity control</head><p>In this section, we consider a vehicle with velocity control. This example is adapted from Ref. <ref type="bibr" target="#b41">[42]</ref>. The vehicle with velocity control consists of the vehicle and a controller. The vehicle follows a suggested acceleration a approximately, to within an error of . The velocity controller monitors the velocity v of the vehicle and produces a new suggested acceleration every d time units. The suggested acceleration is chosen in such a way that Table <ref type="table" target="#tab_11">19</ref> Additional rules for localization (a ∈ A, r &gt; 0)</p><formula xml:id="formula_116">x, a -→ x , v∇x, a -→ v∇x , a, a -→ √ , v∇x, a -→ √ , x, r, --→ x , v∇x, r, --→ v∇x , r, --→ {v} T ∈ [s(x)] ∈ [s(v∇x)] → ∈ [d(x)], x, r, --→ x , → ∈ [d(v∇x)] → C {v} → ∈ [d(x)], x, → → ∈ [d(v∇x)]</formula><p>the velocity of the vehicle will remain below v max . We assume that the vehicle starts with velocity 0 and the velocity controller with suggested acceleration 0. We also assume that v max d. The recursive specification of the vehicle consists of the following equations:</p><formula xml:id="formula_117">V = (v = 0) ∧ V , V = (a - v a + ) ∩ {v} * rel ( ˜ ).</formula><p>The recursive specification of the velocity controller consists of the following equations:</p><formula xml:id="formula_118">C = (a = 0) ∧ C , C = ( ȧ = 0) ∩ d rel ( • v + (a • + ) d v max ) suggest • C .</formula><p>The vehicle with velocity control is described by the following term:</p><formula xml:id="formula_119">a∇(V C).</formula><p>The point is that the vehicle process V does not preclude discontinuities for a, which is updated every d time units by the controller process C. The localization operator is used to inhibit further discontinuities of a caused by the environment of the vehicle and its controller. In other words, only the controller can update the suggested acceleration of the vehicle, and in this way affect the velocity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Concluding remarks</head><p>A process algebra has been presented which makes it possible to deal with the behaviour of systems in which the instantaneous state transitions caused by performing actions are alternated with continuous state evolutions. It is intended as an algebraic framework for the description and analysis of hybrid systems. The inescapable interface of this framework with real analysis is isolated in special lifting rules to derive equations with the help of a mathematical theory that includes real analysis. The application of the framework has been illustrated by means of various examples. In the analysis of a thermostat, a bottle-filling system and a railroad crossing system, the lifting rules turned out to be essential.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Discussion of main choices</head><p>The process algebra for hybrid systems proposed in this paper extends the process algebra with continuous relative timing from Ref. <ref type="bibr" target="#b13">[14]</ref>. One of the reasons to extend a process algebra with timing is the following notable experience with the use of process algebra with timing for the description and analysis of hybrid systems (see e.g. Ref. <ref type="bibr" target="#b13">[14]</ref>). In many cases, when all timing that arises from continuous behaviour is known, the details of continuous behaviour are not relevant to analysis of the system concerned with respect to all or virtually all properties expected from it, but the details of timing are still relevant.</p><p>The process algebra for hybrid systems proposed in this paper also extends the process algebra with propositional signals from Ref. <ref type="bibr" target="#b10">[11]</ref>. The initial ideas about the use of a timed variant of the process algebra with propositional signals for hybrid systems were born while the second author was working on timed frames <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b42">43]</ref>. Similar ideas, born independently, were outlined in Ref. <ref type="bibr" target="#b52">[53]</ref>, but those ideas have never been worked out. To the best of our knowledge, the process algebra with propositional signals is the only process algebra that provides such a simple means as a proposition to represent the state of a process. When dealing with hybrid systems, a feature like that, extended to state transitions and state evolutions, is very common. Using the formalism of hybrid automata, for example, a hybrid system is described by means of initial, invariant, jump and flow conditions.</p><p>One of the reasons to build on existing theory is that it is considered to be good practice. We add only two operators to the combination of the process algebra with continuous relative timing from Ref. <ref type="bibr" target="#b13">[14]</ref> and the process algebra with propositional signals from Ref. <ref type="bibr" target="#b10">[11]</ref>, viz. the signal evolution operator and the signal transition operator. The latter operator actually replaces the terminal signal emission operator of the process algebra with propositional signals. The question arises whether the resulting process algebra contains superfluous operators by taking over the operators of two process algebras which have not been devised for hybrid systems. We do not need the conditional proceeding operator, because its effect can be mimicked by the signal transition operator, but its presence contributes to a clear comprehension of the whole. We need all other operators. They cannot be mimicked by each other and they are all indispensable in most descriptions of hybrid systems given in this paper.</p><p>The choice of the operators that have been added to the combination of the process algebra with continuous relative timing and the process algebra with propositional signals has been strongly influenced by the formalism of hybrid automata. As a consequence, there are close connections between the process algebra for hybrid systems and the formalism of hybrid automata. These connections are elaborated in ongoing work mentioned in Section 6.2.</p><p>Like in the formalism of hybrid automata, each switch from one continuous mode to another requires that an action is performed. This feature is clearly a consequence of our choice to build on the process algebra with continuous relative timing from Ref. <ref type="bibr" target="#b13">[14]</ref>. It is directly inherited from that process algebra. Actions may not be needed to model switches between continuous modes of systems that behave purely according to physical laws, but we believe that it is seldom artificial to use them. Moreover, we believe that the feature discussed here is not really relevant to the degree of usefulness of the proposed process algebra. However, experience in practical applications is needed to make a firm claim.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Ongoing and future work</head><p>It was mentioned in the introduction that the process algebra proposed in this paper is inspired by the work on the formalism of hybrid automata. In ongoing work, we are elaborating the connections between the proposed process algebra and the formalism of hybrid automata. In Ref. <ref type="bibr" target="#b20">[21]</ref>, we show that hybrid automata can be faithfully represented using the proposed process algebra: the representations of two hybrid automata are bisimilar if and only if their standard interpretations as timed transition systems are bisimilar. <ref type="foot" target="#foot_3">6</ref> The representation of a hybrid automaton involves a recursive specification with an equation of the form</p><formula xml:id="formula_120">X m = m ∩ V s∈S m s a s • X m s + u∈(0,∞) u rel (X m )</formula><p>for each control mode m of the hybrid automaton concerned. It is not difficult to establish that the proposed process algebra has more expressive power than the formalism of hybrid automata. An important point is that not even all recursive equations of the form</p><formula xml:id="formula_121">X m = m ∩ V s∈S m s a s • X m s + i∈I m i :→ mi ∩ V u∈(0,∞) u rel (X m )</formula><p>can be reduced to an equation of the form used to represent hybrid automata. We mentioned in Section 3.3 that we would like to add a hiding operator v for each state variable v, but that this extension would require a semantics that carries more detail than the structural operational semantics given in this paper. Working out the addition of those hiding operators is one of the options for future work.</p><p>The new process algebra for hybrid systems proposed in this paper represents a large amount of work. Therefore, it is not amazing that it induces a lot of other options for future work. We mention only a few options. Development of efficient proof techniques is important because there is no effective procedure for determining of an arbitrary equation of the proposed process algebra whether it is derivable. Investigation into restricted versions of the proposed process algebra that make an effective procedure possible is also interesting. In continuation of the current work concerning the connections with the formalism of hybrid automata, it is interesting to investigate the adaptation of model checking tools developed for hybrid automata to restricted versions of the proposed process algebra. Together with that a suitable temporal logic should be developed. Of course, it is very important that case-studies to assess the degree of usefulness in practical applications are carried out in conjunction with all the theoretical work mentioned above. If the design of hybrid systems can indeed be improved by the results of that work, it is worth turning it into an industrial method that can be used by both software engineers and control engineers when designing hybrid systems. We mention that the proposed process algebra for hybrid systems has not been designed with the objective to make easy transfer to practical control engineering possible. It appears that HyPA <ref type="bibr" target="#b28">[29]</ref>, which is discussed in Section 6.3, has been designed with that objective.</p><p>Quite another option for further work is in the area of tool support for soundness proofs for process algebras. The creation of the full soundness proofs for BPA srt hs and ACP srt hs is a very time-consuming, but for the greater part routine, affair in which mistakes are easily made. It gave us a shock to experience that our initial soundness proofs contained a few mistakes. The making of a readable electronic version of the proofs by hand takes up a great deal of time too. All this calls for a semi-automatic way for proving soundness of equational axioms, with respect to common versions of bisimulation equivalence, from transition rules. We think of a tool that can carry out routine work such as searching for applicable transition rules, producing their relevant instances, checking and recording the proof steps made, and making a readable version of the proof while it is created.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Related work</head><p>Concerning related work, we mention the early work on hybrid CSP <ref type="bibr" target="#b40">[41]</ref>, the recent work on the -calculus <ref type="bibr" target="#b51">[52]</ref>, and the very recent work on HyPA <ref type="bibr" target="#b28">[29]</ref>. In hybrid CSP and the -calculus, which are variants of timed CSP and the -calculus, respectively, one can only deal with continuous behaviour in a limited way. The main limitation of hybrid CSP, which dates back to 1994, is that parallel composition of processes is only possible if the continuous behaviour exhibited by the parallel processes is independent: the processes are not allowed to have a state variable in common. The main limitation of the -calculus is that the expressions constructed by means of the operators of the -calculus denote processes that do not exhibit continuous behaviour: continuous behaviour can only be exhibited by a special process, called an environment, which is described separately. The work on HyPA is the most closest to our work, and deserves a more detailed discussion.</p><p>HyPA is an extension of ACP for hybrid systems on which the first report appeared very shortly after the report version of this paper. In that report, it is stated that HyPA and ACP srt hs are very similar. We agree only in part. The transition systems induced by the structural operational semantics of HyPA are in some respects similar to the ones induced by the structural operational semantics of ACP srt hs . However, in our opinion, the similarities end with that. Here, we confine ourselves to mentioning some of the most important dissimilarities.</p><p>The operators of ACP are the only operators that HyPA and ACP srt hs have in common. The additional operators, which make it possible to deal with the behaviour of hybrid systems, are quite different. This dissimilarity has far-reaching consequences. The absence of operators for timing means that mere timing must be modelled in HyPA by means of state variables that behave as clocks. Because ACP srt hs includes the operators of ACP srt , we can transform the description of a hybrid system in ACP srt hs into one that makes explicit timing that arises from the evolution of its state. Similar transformations are not possible with descriptions of hybrid systems in HyPA.</p><p>Another important dissimilarity concerns alternative composition. The structural operational semantics of alternative composition in ACP srt hs provides for a form of timedeterminism: if t, r, --→ t , and t, r,</p><p>--→ t , , then t ≡ t . This property can be paraphrased roughly as follows: a choice between different idling processes is postponed so long as all can idle. However, a choice between different evolutions of the state is not postponed. The structural operational semantics of alternative composition in HyPA does not provide for a form of time-determinism. We consider the above-mentioned form of time-determinism of vital importance for a faithful representation of all time-dependent behaviour. In the case of behaviour of hybrid systems, the continuous state changes that take place during idling may surely make choices between processes available at certain points of time, but that does not amount to the property that such choices may happen during idling. It appears that this observation contradicts the main argument used in Ref. <ref type="bibr" target="#b28">[29]</ref> against the form of time-determinism present in ACP srt hs . The representation of hybrid automata in ACP srt hs sketched in Section 6.2 draws attention to the fact that, different from what is said in Ref. <ref type="bibr" target="#b28">[29]</ref>, this form of time-determinism is in line with the approach of hybrid automata. Because each control mode has just one alternative to proceed with idling, time-determinism is just not an issue.</p><p>Finally, we mention the loosely related work on duration calculus. The original duration calculus, called DC, is proposed in Ref. <ref type="bibr" target="#b24">[25]</ref>. DC is an interval temporal logic designed for expressing and reasoning about assumptions and requirements on how the state of a real-time system changes over time. An extension of DC for hybrid systems, called EDC, is proposed in Ref. <ref type="bibr" target="#b25">[26]</ref>. EDC can be used during requirement capturing and early design stages of the development of a hybrid systems. As soon as during the design details about actions taking place become relevant, a process algebra such as ACP srt hs is better suited. To investigate how the switch from EDC to ACP srt hs can be made in a semantically sound way is still another option for further work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Miscellaneous remarks</head><p>The process algebra for hybrid systems proposed in this paper does not incorporate abstraction from internal actions. This issue is not even fully understood in process algebras with timing. The version of branching bisimulation equivalence for processes with discrete relative timing proposed in Ref. <ref type="bibr" target="#b11">[12]</ref> for this purpose, and adapted to continuous relative timing in Ref. <ref type="bibr" target="#b13">[14]</ref>, is too fine for many applications. A slightly coarser equivalence is proposed in Ref. <ref type="bibr" target="#b14">[15]</ref>.</p><p>The proposed process algebra for hybrid systems does not exclude the possibility of two or more actions to be performed consecutively at the same point in time. For hybrid automata, this possibility is sometimes excluded. A variant of the proposed process algebra that excludes this possibility as well can be devised along similar lines as the process algebra with non-standard timing from Ref. <ref type="bibr" target="#b44">[45]</ref>.</p><p>Concerning Zeno behaviour, the phenomenon that infinitely many instantaneous state changes happen before a certain point of time, the following remark is in order. The axioms and lifting rules given in this paper are based on a notion of bisimulation that does not distinguish between behaviours that occur after a point of time at which infinitely many instantaneous state changes accumulate. A notion of bisimulation to deal with Zeno behaviour is proposed in Ref. <ref type="bibr" target="#b27">[28]</ref>. In our opinion, however, Zeno behaviour is primarily a sign that a questionable abstraction of a real system has been made; and behaviour occurring after such unrealizable behaviour is absolutely irrelevant.</p><p>The process algebra with continuous relative timing from Ref. <ref type="bibr" target="#b13">[14]</ref> on which we build the proposed process algebra for hybrid systems arises from an attempt to streamline a lot of work on process algebra with timing in the setting of ACP done since 1989. It originates from ACP st , a version of ACP with continuous relative timing from Ref. <ref type="bibr" target="#b9">[10]</ref>, which, unlike the earlier version of ACP with continuous relative timing from Ref. <ref type="bibr" target="#b7">[8]</ref>, does not combine performing an action with idling for a period of time. An interesting extension of the version of ACP with continuous absolute timing from Ref. <ref type="bibr" target="#b7">[8]</ref> is the real space process algebra proposed in Ref. <ref type="bibr" target="#b8">[9]</ref>. Still another option for further work is to investigate to what extent the examples concerning data transmission via a mobile intermediate station from Refs. <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b21">22]</ref> can be described using the process algebra for hybrid systems proposed in this paper.</p><p>These lemmas are easily proven by induction on the structure of basic term t. We present here the proof of the fourth lemma. The proofs of the other lemmas are similar, but less complicated.</p><p>The proof of the fourth lemma goes as follows: • t ≡ ⊥: Then ∩ V ⊥ = ⊥ by SE2, HSE10; and ⊥ ∈ B.</p><p>• t ≡ ∧ ˜ : Then ∩ V ( ∧ ˜ ) = ( ∧ ) ∧ ˜ by HSE10, HSE3, SE5. We proceed by distinguishing two cases:</p><formula xml:id="formula_122">• ∧ ∈ P st + : Then ( ∧ ) ∧ ˜ ∈ B.</formula><p>• ∧ ∈ P st + : Then ( ∧ ) ∧ ˜ = ⊥ by SE2; and ⊥ ∈ B.</p><p>• t ≡ :→ ( ã): Then ∩ V ( :→ ( ã)) = ∧ ˜ + :→ ( ã) by HSE9, HSE12, SE7, SE5, A6SR, SE3. We proceed by distinguishing two cases:</p><formula xml:id="formula_123">• ∈ P st + : Then ∧ ˜ + :→ ( ã) ∈ B.</formula><p>• ∈ P st + : Then ∧ ˜ + :→ ( ã) = ⊥ by SE3, SE2; and ⊥ ∈ B. • t ≡ :→ ( ã•t ): Analogous to the previous case.</p><formula xml:id="formula_124">• t ≡ :→ ( ∩ V r rel (t )): Then ∩ V ( :→ ( ∩ V r rel (t ))) = ∧ ˜ + :→ (( ∧ ) ∩ V ∪V r rel (t )</formula><p>) by HSE9, HSE11, A6SR, SE3. We proceed by distinguishing three cases: For ic-bisimulation equivalence, congruence follows immediately from the following. The transition rules for BPA srt hs constitute a complete transition system specification in panth format, and ic-bisimulation equivalence is the equivalence which is guaranteed to be a congruence in that case (see e.g. Refs. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b46">47]</ref>). <ref type="foot" target="#foot_4">7</ref>For bisimulation equivalence, we prove for each operator of BPA srt hs that it preserves bisimulation equivalence. We present here the proof for sequential composition. The proofs for the other operators of BPA srt hs are similar. The proof for alternative composition is equally complicated, and the proofs for the remaining operators are less complicated.</p><formula xml:id="formula_125">• ∈ P st + and ∧ ∈ P st + : Then ∧ ˜ + :→ (( ∧ ) ∩ V ∪V r rel (t )) ∈ B. • ∈ P st + and ∧ ∈ P st + : Then ∧ ˜ + :→ (( ∧ ) ∩ V ∪V r rel (t )) = ⊥ by HSE2, SE2, SE7, GC3SR, SE3, SE5, A1, A6SR; and ⊥ ∈ B. • ∈ P st + : Then ∧ ˜ + :→ (( ∧ ) ∩ V ∪V r rel (t )) = ⊥ by SE2, NE1; and ⊥ ∈ B. • t ≡ t +t : Then ∩ V (t +t ) = ∩ V t + ∩ V t</formula><p>Suppose that t 1 ↔ t 1 and t 2 ↔ t 2 . For each state , let R 1 and R 2 be bisimulation relations witnessing t 1 , ↔ t 1 , and t 2 , ↔ t 2 , , respectively. We write R i (i = 1, 2) for the union of R i over all states . Let 0 be a fixed but arbitrary state. Define</p><formula xml:id="formula_126">R 0 = R 0 ∪ R 2 , where R 0 = {( s 1 • t 2 , , s 1 • t 2 , ) | R 1 0 ( s 1 , , s 1 , )}.</formula><p>We show that R 0 is a bisimulation relation. Suppose that R 0 ( t, , t , ). In the case where R 2 ( t, , t , ), the conditions for a bisimulation relation are trivially satisfied; and in the case where R 0 ( t, , t , ), we may assume that t ≡ s 1 • t 2 , t ≡ s 1 • t 2 and R 1 0 ( s 1 , , s 1 , ). In the latter case, we distinguish between the different kinds of transition relations: • Action step relations: Suppose t, a -→ u, . We proceed by distinguishing the two possibilities for u: We have to prove that, for all closed terms t and t of BPA srt hs , we have BPA srt hs ٛ t = t implies t ↔ t . It follows from Theorem 6 that it is sufficient to prove for each axiom separately that t ↔ t for all closed substitution instances t = t of the axiom and to prove for each lifting rule, under assumption of the premises of the lifting rule, that t ↔ t for all closed substitution instances t = t of the conclusion of the lifting rule. Moreover, it follows from Lemma 5 that in order to prove that t ↔ t , it is sufficient to prove that t ↔ t . It happens that for each axiom of icBPA srt hs , we can prove that t ↔ t for all closed substitution instances t = t of the axiom. To prove that t ↔ t for all closed substitution instances t = t of an axiom, we proceed as follows. We give a binary relation R on closed terms and show that (i) for all the closed substitution instances t = t of the axiom, we have (t, t ) ∈ R and (ii) R is an ic-bisimulation relation. The proof of (i) is generally trivial. To prove (ii), we show that the conditions for an ic-bisimulation relation are satisfied for all closed terms t * and t * * such that (t * , t * * ) ∈ R. We shall loosely say that a relation contains all closed substitution instances of an equation if it contains all pairs (t, t ) such that t = t is a closed substitution instance of the equation.</p><formula xml:id="formula_127">• u ≡ v • t 2 : t, a -→ u, holds only if s 1 , a -→ v, . Because R 1 0 ( s 1 , , s 1 , ), there exists a v such that s 1 , a -→ v , and R 1 0 ( v, , v , ). So s 1 • t 2 , a -→ v • t 2 , and R 0 ( v • t 2 , , v • t 2 , ). • u ≡ t 2 : t, a -→</formula><p>The axioms of BPA srt hs are essentially the axioms of BPA srt and BPA ps with on top of that axioms NESRU, PSSRU1 and PSSRU2 and the axioms for signal evolution and signal transition given in Table <ref type="table" target="#tab_4">3</ref>. The differences, due to having (undelayable) actions ã instead of actions a, are not relevant to the purpose of building on the soundness proofs of BPA srt and BPA ps .</p><p>If we replace in the rules describing the structural operational semantics of BPA </p><formula xml:id="formula_128">--→ _ , _ v,a --→ √ , v ∈ [s(_ )] and w ∈ [s(_ )] by _ , a -→ _ , , _ , a -→ √ , , ∈ [s(_ )] and ∈ [s(_ )],</formula><p>respectively, the induced ic-bisimulation equivalence is coarser than the version of bisimulation equivalence for which the axioms of BPA ps have been proved sound. Hence, we can safely make these replacements.</p><p>After that, for some of the operators of BPA srt and BPA ps , there are still supplementary transition rules concerning additional kinds of transition relations and/or adapted transition rules with supplementary premises concerning additional kinds of transition relations. It follows that, as far as the axioms of BPA srt and BPA ps are concerned, we only have to check:</p><p>• each axiom in which rel , +, :→ or ∧ occurs with respect to the time step relations;</p><p>• each axiom in which rel or rel occurs with respect to the signal relations. Checking the axioms concerning rel and + with respect to the time step relations goes almost analogous to checking them for BPA srt : it does not have to be turned upside down in order to take the supplementary premises into account. Checking the axioms concerning :→ and ∧ with respect to the time step relations goes analogous to checking them with respect to the action step relations. Checking the axioms concerning rel and rel with respect to the signal relations is very easy.</p><p>Checking axioms NESRU, PSSRU1 and PSSRU2 with respect to all transition relations is very easy as well. What remains, is to check the axioms for signal evolution and signal transition (Table <ref type="table" target="#tab_4">3</ref>) and the lifting rules of BPA srt hs (Table <ref type="table" target="#tab_5">4</ref>) with respect to all kinds of transition relations.</p><p>For all axioms except axioms HST5 and HST14, and for lifting rule HSELR1, the checks with respect to ic-bisimulation equivalence succeed. In the case of those checks, it happens frequently that for an arbitrary substitution instance t 1 = t 2 of an axiom, we can quite easily</p><formula xml:id="formula_129">establish that t 1 , a -→ t , iff t 2 , a -→ t , , or t 1 , a -→ t 1 , iff t 2 , a -→ t 2 ,</formula><p>and t 1 = t 2 is a substitution instance of that axiom as well; and similarly for the other kinds of transition relations. This is the case except for axioms HSE6, HSE13 and HST6. We present here the checks for axiom HSE13. Checking the other axioms goes similarly, but is simpler.</p><p>The checks for axiom HSE13 go as follows. We take the relation R that consists of all closed substitution instances of axiom HSE13, the equation x = x and the equation</p><formula xml:id="formula_130">∩ V x+ ∩ V rel (y) = ∩ V (x+ ∩ V rel (y)).</formula><p>First of all, we consider the closed substitution instances of axiom HSE13. We take an arbitrary closed substitution instance, say ∩ V r </p><formula xml:id="formula_131">rel (t 1 )+ ∩ V r rel ( rel (t 2 )) = ∩ V ( r rel (t 1 )+ ∩ V r rel ( rel (t 2 ))),</formula><formula xml:id="formula_132">E s such that ∩ V r rel (t 1 )+ ∩ V r rel ( rel (t 2 )), s, --→ t , or ∩ V ( r rel (t 1 )+ ∩ V r rel ( rel (t 2 ))), s,</formula><p>--→ t , holds. We proceed by distinguishing three cases: . Next, we consider the closed substitution instances of the equation ∩ V x+ ∩ V rel (y) = ∩ V (x+ ∩ V rel (y)). We take an arbitrary closed substitution instance, say ∩ V t 1 + ∩ V rel (t 2 ) = ∩ V (t 1 + ∩ V rel (t 2 )). It is easy to check that, for all states and , a ∈ A, r &gt; 0 and ∈ E r , ∩ V t 1 + ∩ V rel (t 2 ), a -→ t * , iff ∩ V (t 1 + ∩ V rel (t 2 )), a -→ t * , , ∩ V t 1 + ∩ V rel (t 2 ), a -→ √ , iff ∩ V (t 1 + ∩ V rel (t 2 )), a -→ √ , ,</p><formula xml:id="formula_133">• s = r: ∩ V r rel (t 1 )+ ∩ V r rel ( rel (t 2 )), s, --→ t , holds only if s, --→ V , ∈ [s(t 1 )], s, --→ V , ∈ [s(t 2 )] and t ≡ ∩ V t 1 + ∩ V rel (t 2 ). ∩ V ( r rel (t 1 )+ ∩ V r rel ( rel (t 2 ))), s, --→ t , holds only if s, --→ V , ∈ [s(t 1 )], s, --→ V , ∈ [s(t 2 )] and t ≡ ∩ V (t 1 + ∩ V rel (t 2 )). Moreover, (t , t ) ∈ R. • s &lt; r: ∩ V r rel (t 1 )+ ∩ V r rel ( rel (t 2 )), s, --→ t , holds only if s, --→ V , s, --→ V and t ≡ ∩ V r-s rel (t 1 )+ ∩ V r-s rel ( rel (t 2 )). ∩ V ( r rel (t 1 )+ ∩ V r rel ( rel (t 2 ))), s, --→ t , holds only if s, --→ V , s, --→ V and t ≡ ∩ V ( r-s rel (t 1 )+ ∩ V r-s rel ( rel (t 2 ))). Moreover, (t , t ) ∈ R. • s &gt; r: ∩ V r rel (t 1 )+ ∩ V r rel ( rel (t 2 )),</formula><formula xml:id="formula_134">∩ V t 1 + ∩ V rel (t 2 ), r, --→ t * * , iff ∩ V (t 1 + ∩ V rel (t 2 )), r,</formula><p>--→ t * * , and</p><p>The proof of the second lemma goes as follows. For the cases t ≡ ⊥, t ≡ ∧ ˜ , t ≡ :→ ( ã) and t ≡ :→ ( ã • t * ), it is easy to see that a basic term is derivable. The case t ≡ :→ ( ∩ V r rel (t * )) follows immediately from the fact that for all t, t ∈ B and r &gt; 0, there is a t ∈ B such that r rel (t) t = t is derivable. This is proven as follows by case distinction for t according to Corollary 4: </p><formula xml:id="formula_135">• t =</formula><formula xml:id="formula_136">( i ∩ V i r i rel (t i )) = J ⊆I ( i∈J i ∧ i∈I \J ¬ i ) :→ r rel t i∈J i ∩ V i r i -r rel (t i ) +( i∈J i ) ∩ ( i∈J V i ) r rel ( ˜ )</formula><p>by repeatedly PSSRCM, repeatedly SRT2 and HSSRCM, repeatedly SRT3, and SRCM2. By GC1, HSE1 and the induction hypothesis there is a basic term t J such that t i∈J i ∩ V i r i -r rel (t i ) = t J for all J ⊆ I ; and by Theorem 1 there is a basic term t such that J ⊆I ( i∈J i ∧ i∈I \J ¬ i ) :→ ( r rel (t J )+( i∈J i ) ∩ ( i∈J V i ) r rel ( ˜ )) = t . Next, we look at the term * A ( rel (t )). According to the fifth lemma introduced in the proof, either * A ( rel (t )) = ⊥ is derivable or there is a ∈ P st + such that * A ( rel (t )) = ∧ ˜ is derivable; and ⊥, ∧ ˜ ∈ B. Hence, t is in all cases the alternative composition of two basic terms, and thus a basic term.</p><p>For the case t ≡ t * +t * * , it follows directly from the induction hypothesis and CM4 that a basic term is derivable.</p><p>A.5. Proof of Theorem 12 (Soundness for ACP srt hs )</p><p>We have to prove that, for all closed terms t and t of ACP srt hs , we have ACP srt hs ٛ t = t implies t ↔ t . It follows from Theorem 11 that it is sufficient to prove for each axiom separately that t ↔ t for all closed substitution instances t = t of the axiom and to prove for lifting rule HSELR1, under assumption of the premises of the lifting rule, that t ↔ t for all closed substitution instances t = t of the conclusion of the lifting rule.</p><p>The axioms of ACP srt hs are essentially the axioms of ACP srt and ACP ps , with the exception of axioms CM2SRPS and CM2SRPS, and on top of that axioms NESRU, PSSRU1 and PSSRU2, axiom PSSRCM, and the axioms for signal evolution and signal transition given in Tables 3, 13 and 14, with the exception of axioms HST5 and HST14. The differences, due to having (undelayable) actions ã instead of actions a and using terms * A ( rel (x)) instead of s (x) ∧ , are not relevant to the purpose of building on the soundness proofs of ACP srt and ACP ps .</p><p>In the rules describing the structural operational semantics of ACP srt and ACP ps , we can safely make the replacements mentioned in the soundness proof for BPA srt hs (Appendix A.3) as well.</p><p>After that, for some of the operators of ACP srt and ACP ps , there are still supplementary transition rules concerning additional kinds of transition relations and/or adapted transition rules with supplementary premises concerning additional kinds of transition relations. It follows that, as far as the axioms of ACP srt and ACP ps are concerned, we only have to check:</p><p>• each axiom in which occurs with respect to the action step and action termination relations;</p><p>• each axiom in which rel , +, :→ or ∧ occurs with respect to the time step relations; • each axiom in which rel , rel or occurs with respect to the signal relations;</p><p>• each axiom with respect to the discontinuity relations.</p><p>For the operators of icBPA srt hs , there are, in comparison with the structural operational semantics of icBPA srt hs , only supplementary transition rules concerning the discontinuity relations and no adapted transition rules at all. Moreover, the axioms and lifting rule of icBPA srt hs have already been checked with respect to all kinds of transition relations except the discontinuity relations. Hence, as far as the axioms and lifting rule of icBPA srt hs are concerned, we can restrict ourselves to check them with respect to the discontinuity relations. Checking the axioms and lifting rule of icBPA srt hs with respect to the discontinuity relations is easy.</p><p>Checking the axioms of ACP srt hs coming from ACP srt and ACP ps (other than the axioms of BPA srt and BPA ps ), with respect to certain kinds of transition relations as indicated above, goes similar to checking them for ACP srt and ACP ps . Checking axiom PSSRCM is somewhat more complicated, comparable to the checking of axiom HSE13 in the soundness proof for BPA srt hs (Appendix A.3).</p><p>What remains, is to check the additional axioms of ACP srt hs concerning signal evolution and signal transition (Table <ref type="table" target="#tab_4">13</ref>) with respect to all kinds of transition relations. Like for most axioms of BPA srt hs concerning signal evolution and signal transition, this is quite easy for most axioms. An exception is axiom HSSRCM.</p><p>The checks for axiom HSSRCM go as follows. We take the relation R that consists of all closed substitution instances of axiom HSSRCM, the equation x = x, the equation x ( ∩ V y) = x ( ∩ V y)+ ∩ V ˜ , the equation x ( ∩ V y+z) = x ( ∩ V y+z)+ ∩ V ˜ and the equation r rel (x) ( ∩ V r rel (y)) = r rel (x) r rel ( ∩ V y) + ∩ V r rel ( ˜ ). First, we consider the closed substitution instances of axiom HSSRCM. We take an arbitrary closed substitution instance, say r rel (t 1 ) ( --→ t 3 , for some closed term t 3 , state , s &gt; 0 and ∈ E s . The case of the closed substitution instances of the equation r rel (x) ( ∩ V r rel (y)) = r rel (x) r rel ( ∩ V y)+ ∩ V r rel ( ˜ ) is similar to the previous case. Next, we consider the closed substitution instances of the equation x ( ∩ V y+z) = x ( ∩ V y+z)+ ∩ V ˜ . We take an arbitrary closed substitution instance, say t 1 ( ∩ V t 2 +t 3 ) = t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ . It is easy to check that, for all states and , a ∈ A, r &gt; 0 and ∈ E r , t 1 ( ∩ V t 2 +t 3 ), a</p><formula xml:id="formula_137">-→ t * , iff t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ , a -→ t * , , t 1 ( ∩ V t 2 +t 3 ), a -→ √ , iff t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ , a -→ √ , , t 1 ( ∩ V t 2 +t 3 ), r, --→ t * * , iff t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ , r, --→ t * * , , ∈ [s(t 1 ( ∩ V t 2 +t 3 ))] iff ∈ [s(t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ )] and → ∈ [d(t 1 ( ∩ V t 2 +t 3 ))] iff → ∈ [d(t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ )].</formula><p>Moreover, (t * , t * ) ∈ R and (t * * , t * * ) ∈ R.</p><p>The case of the closed substitution instances of the equation x ( ∩ V y) = x ( ∩ V y)+ ∩ V ˜ is similar to the previous case.</p><p>The closed substitution instances of the equation x = x trivially satisfy the conditions for an ic-bisimulation relation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>CB C 1 2Fig. 1 .</head><label>11</label><figDesc>Fig. 1. Connection diagram for bottle-filling system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Connection diagram for railroad crossing system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Axioms of BPA srt ⊥</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>Additional axioms for BPA srt ps</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>is a state expression; • each constant c is a state expression; • if o is an arithmetic operator of arity n and s 1 , . . . , s n are state expressions, then o(s 1 , . . . , s n ) is a state expression. The set of atomic state propositions is inductively defined by the following formation rules: • if s 1 and s 2 are state expressions, then s 1 = s 2 is an atomic state proposition; • if is a relational operator of arity n, and s 1 , . . . , s n are state expressions, then (s 1 , . . . , s n</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>an arithmetic operator of arity n and t 1 , . . . , t n are transition expressions, then • if is a state proposition, then • and • are transition propositions. The proposition • is satisfied exactly by the transitions from a state in which holds, and the proposition • is satisfied exactly by the transitions to a state in which holds.</figDesc><table><row><cell>following formation rule:</cell></row><row><cell>o(t 1 , . . . , t n ) is a transition expression.</cell></row><row><cell>The set of atomic transition propositions is inductively defined by the following formation</cell></row><row><cell>rules:</cell></row><row><cell>• if t 1 and t 2 are transition expressions, then t 1 = t 2 is an atomic transition proposition;</cell></row><row><cell>• if is a relational operator of arity n, and t 1 , . . . , t n are transition expressions, then</cell></row><row><cell>(t 1 , . . . , t n ) is an atomic transition proposition.</cell></row><row><cell>Transition propositions are constructed from atomic transition propositions in the usual way</cell></row><row><cell>with constants T, F and the various logical connectives, and in addition according to the</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell>Additional axioms for BPA srt hs (a ∈ A, r &gt; 0)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4</head><label>4</label><figDesc>Lifting rules for BPA srt hs</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5</head><label>5</label><figDesc>Rules for operational semantics of BPA srt hs</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>t , : in state , process t is capable of first performing action a at the current point of time and then proceeding as process t in state ;</figDesc><table><row><cell>• t,</cell></row></table><note><p>a -→ √ , : in state , process t is capable of first performing action a at the current point of time and then terminating successfully in state ; • t, r,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>then there is a t 2 such that t 2 , Two configurations t 1 , 1 and t 2 , 2 are bisimulation equivalent (or simply bisimilar), written t 1 , 1 ↔ t 2 , 2 , if 1 = 2 and there exists a bisimulation B such that B( t 1 , 1 , t 2 , 2 ). Two closed terms t 1 and t 2 are bisimulation equivalent, written t 1 ↔ t 2 , if t 1 , ↔ t 2 , for all states .</figDesc><table><row><cell>a -→ t 2 , --→ t 1 , , then there is a t 2 such that t 2 , a -→ a -→ √ , ; √ , , then t 2 , r, B( t 1 , , t 2 , ); t 2 , ); • whenever t 1 , • whenever t 1 , • whenever ∈ [s(t 1 )], then ∈ [s(t 2 )].</cell><cell>and B( t 1 , , and --→ t 2 , r,</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>then there is a t 2 such that t 2 , Two closed terms t 1 and t 2 are interference-compatible bisimulation equivalent, written t 1 ↔ t 2 , if there exists an interference-compatible bisimulation B such that B(t 1 , t 2</figDesc><table /><note><p>a -→ t 2 , and B(t 1 , t 2 ); • whenever t 1 , a -→ √ , , then t 2 , a -→ √ , ; • whenever t 1 , r, --→ t 1 , , then there is a t 2 such that t 2 , r, --→ t 2 , and B(t 1 , t 2 ); • whenever ∈ [s(t 1 )], then ∈ [s(t 2 )].</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Both bisimulation equivalence and ic-bisimulation equivalence are congruences with respect to the operators of BPA srt hs . For all closed terms t 1 and t 2 of BPA srt hs , we haveBPA srt hs ٛ t 1 = t 2 implies t 1 ↔ t 2 .We shall henceforth use the name icBPA srt hs to refer to the process algebra that differs from BPA srt hs only by the absence of axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3. As a corollary of the proof of Theorem 7, we have the following.Corollary 8 (Soundness). For all closed terms t 1 and t 2 of BPA srt hs , we have icBPA srt hs ٛ t 1 = t 2 implies t 1 ↔ t 2 .</figDesc><table><row><cell>Proof. See Appendix A.2.</cell></row><row><cell>The axioms and lifting rules of BPA srt hs are sound with respect to bisimulation equivalence.</cell></row><row><cell>Theorem 7 (Soundness). Proof. See Appendix A.3.</cell></row></table><note><p><p><p><p><p><p>). For all closed terms t 1 and t 2 , if</p>t 1 ↔ t 2 then t 1 ↔ t 2 .</p>Proof. Suppose that t 1 ↔ t 2 . Suppose further that B is an ic-bisimulation witnessing that</p>t 1 ↔ t 2 . Define B = {( t 1 , , t 2 , ) | B(t 1 , t 2 ), is a state}. It is easy to see that B is a bisimulation. Moreover, if B ( t 1 , , t 2 , ), then B ( t 1 , , t 2 , ) for all states . So t 1 ↔ t 2 .</p>Bisimulation equivalence and ic-bisimulation equivalence are preserved by all operators of BPA srt hs .</p>Theorem 6 (Congruence).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 9</head><label>9</label><figDesc>Additional axioms for guarded recursion</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 15</head><label>15</label><figDesc></figDesc><table><row><cell>Additional axioms for integration</cell></row><row><cell>u∈U</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>t 1 and t 2 be closed terms of ACP srt hs . Then t 1 = t 2 is two-phase derivable from the axioms and lifting rule of ACP srt hs and the axioms and lifting rules of BPA srt hs , written ACP srt hs /BPA srt hs ٛ 2 t 1 = t 2 , if there exist closed terms t 1 and t 2 of BPA srt hs such that ACP srt hs ٛ t 1 = t 1 , ACP srt hs ٛ t 2 = t 2 , BPA srt hs ٛ t 1 = t 2 . Let t 1 and t 2 be closed terms of ACP srt hs +Ext, where Ext is INT, INT+REC or INT+REC+HSL. Then t 1 = t 2 is two-phase derivable from the axioms and lifting rule of ACP srt hs +Ext and the axioms and lifting rules of BPA srt hs +Ext, written ACP srt hs /BPA srt hs + Ext ٛ 2 t 1 = t 2 if there exist closed terms t 1 and t 2 of BPA srt hs +Ext such that</figDesc><table><row><cell>ACP srt hs</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>by HSE7. By the induction hypothesis there are basic terms t</figDesc><table /><note><p>* and t * * such that ∩ V t = t * and ∩ V t = t * * ; and t * +t * * ∈ B. A.2. Proof of Theorem 6 (Congruence for BPA srt hs )</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head></head><label></label><figDesc>Because R 0 ( t 1 • t 2 , 0 , t 1 • t 2 , 0 ), we have that R 0 is a bisimulation relation witnessing t 1 • t 2 , 0 ↔ t 1 • t 2 , 0 .Because 0 is an arbitrary state, we have that there exists a bisimulation relation witnessing t 1 • t 2 , ↔ t 1 • t 2 , for any state . So, we conclude that t 1 • t 2 ↔ t 1 • t 2 .</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>u,</cell><cell cols="2">holds only if s 1 ,</cell><cell>a -→</cell><cell>√</cell><cell>,</cell><cell>and</cell><cell>∈ [s(t 2 )].</cell></row><row><cell cols="3">Because R 1</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>t ,</cell><cell>a -→</cell><cell>√ ,</cell><cell>do not hold.</cell><cell></cell><cell></cell><cell></cell><cell>a -→</cell><cell>√ ,</cell><cell>and</cell></row><row><cell cols="4">• Time step relations: Suppose t,</cell><cell>r,</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">r, --→ v ,</cell><cell>and R 1</cell><cell></cell><cell>r, --→</cell></row><row><cell cols="8">v • t 2 , • Signal relations: Suppose ∈ [s(t)]. ∈ [s(t)] holds only if ∈ [s(s 1 )]. Because and R 0 ( v • t 2 , , v • t 2 , ).</cell></row><row><cell>R 1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="6">A.3. Proof of Theorem 7 (Soundness for BPA srt hs )</cell><cell></cell></row></table><note><p>0 ( s 1 , , s 1 , ), we have s 1 , a -→ √ , . Moreover, because R 2 ( t 2 , , t 2 , ), we have ∈ [s(t 2 )]. So s 1 • t 2 , a -→ t 2 , and R 0 ( t 2 , , t 2 , ). • Action termination relations: Suppose t, a -→ √ , . Both t, --→ u, . There is only one possibility for u, viz. u ≡ v •t 2 . t, r, --→ u, holds only if s 1 , r, --→ v, . Because R 1 0 ( s 1 , , s 1 , ), there exists a v such that s 1 , 0 ( v, , v , ). So s 1 • t 2 , 0 ( s 1 , , s 1 , ), we have ∈ [s(s 1 )]. So ∈ [s(s 1 • t 2 )].</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head></head><label></label><figDesc>, the induced ic-bisimulation equivalence is identical to the version of bisimulation equivalence for which the axioms of BPA srt have been proved sound. If we replace in the rules describing the structural operational semantics of BPA ps _</figDesc><table><row><cell>_ , _</cell><cell>a -→</cell><cell>√</cell><cell>and _</cell><cell>r -→ _ by _ ,</cell><cell>a -→ _ , , _ ,</cell><cell>a -→</cell><cell>√ ,</cell><cell>and _ ,</cell><cell>a -→ --→ _ , , r,</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>v,a</cell><cell></cell></row></table><note><p>srt _ respectively</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head></head><label></label><figDesc>and distinguish between the different kinds of transition relations:• Action step relations: For all states and , and a ∈ A, both ∩ V For all states and , and a ∈ A, both ∩ V There exist states and , s &gt; 0 and ∈</figDesc><table><row><cell>r rel ( rel (t 2 )), not hold for any t and t . a -→ t ,</cell><cell>and ∩ V ( r rel (t 1 )+ ∩ V</cell><cell>r rel ( rel (t 2 ))),</cell><cell>r rel (t 1 )+ ∩ V a -→ t , do</cell></row><row><cell cols="4">• Action termination relations: r rel (t 1 )+ ∩ V r rel ( rel (t 2 )), a -→ √ , and ∩ V ( r rel (t 1 )+ ∩ V r a -→ √ , do rel ( rel (t 2 ))), not hold.</cell></row><row><cell>• Time step relations:</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19"><head></head><label></label><figDesc>, , we have that t ≡ t . Hence, (t , t ) ∈ R.• Signal relations: For all states , ∈ [s( ∩ V</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">s, --→ t ,</cell><cell>holds only if t 1 ,</cell><cell>s-r, ---→</cell></row><row><cell>t ,</cell><cell cols="2">for some state ,</cell><cell>s, --→</cell></row><row><cell></cell><cell></cell><cell>s, --→ t ,</cell><cell>holds only if t 1 ,</cell><cell>s-r, ---→ t ,</cell><cell>for some state ,</cell></row><row><cell cols="2">s, --→</cell><cell></cell><cell></cell></row><row><cell>if</cell><cell>and</cell><cell cols="3">r rel (t 1 )+ ∩ V rel (t 1 )+ ∩ V ; and ∈ [s( ∩ V ( r r rel ( rel (t 2 ))))] holds only if r rel ( rel (t 2 )))] holds only</cell></row><row><cell>and</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>V , and ∈ [s(t 2 )]. ∩ V ( r rel (t 1 )+ ∩ V r rel ( rel (t 2 ))), V , and ∈ [s(t 2 )]. Because there is at most one t * such that t 1 , s-r, ---→ t *</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head>t )+ i∈I i :→ ( i ∩ V i r i rel (t i )):</head><label></label><figDesc>Then r rel (t) rel (t ) = * A ( rel (t )) by SRCM1aPS. According to the fifth lemma introduced in the proof, either * A ( rel (t )) = ⊥ is derivable or there is a ∈ P st+ such that * A ( rel (t )) = ∧ ˜ is derivable; and ⊥, ∧ ˜ ∈ B. • t = rel (Then r rel (t) ( rel (t )+ i∈I i :→ ( i ∩ V i (t i ))+* A ( rel (t )) by SRCM1bPS.First of all, we look at the term r rel (t) i∈I i :→ ( i ∩ V i r i rel (t i )), and proceed by distinguishing two cases (we write r min for min({r i | i ∈ I })):• r &gt; r min : Then ∧ i∈I \J ¬ i ) = t J for all J ⊆ I ; and by Theorem 1 there is a basic term t such that J ⊆I ( i∈J i ∧ i∈I \J ¬ i ) :→ (</figDesc><table><row><cell cols="2">r i rel (t i ))) = r rel (t)</cell><cell></cell><cell cols="4">i∈I i :→ ( i ∩ V i</cell><cell>r i</cell></row><row><cell cols="2">r rel (t)</cell><cell>i∈I</cell><cell cols="3">i :→ ( i ∩ V i</cell><cell cols="2">r i rel (t i ))</cell></row><row><cell>=</cell><cell cols="3">J ⊆I ( i∈J i :→ r min rel</cell><cell>r-r min rel</cell><cell>(t)</cell><cell></cell><cell>i∈J</cell><cell>i ∩ V i</cell><cell>r i -r min rel</cell><cell>(t i )</cell></row><row><cell></cell><cell></cell><cell cols="6">+ ( i∈J i ) ∩ ( i∈J V i )</cell><cell>r min rel ( ˜ )</cell></row><row><cell cols="9">by repeatedly PSSRCM, repeatedly SRT2 and HSSRCM, repeatedly SRT3, and</cell></row><row><cell cols="9">SRCM2. By GC1, HSE1 and the induction hypothesis there is a basic term t J such that r-r min rel (t) i∈J i ∩ V i r i -r min rel (t i ) r min rel (t J )+( i∈J i ) ∩ ( i∈J V i ) r min</cell></row></table><note><p>rel (t ): rel rel ( ˜ )) = t . • r r min : Then r rel (t) i∈I i :→</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21"><head></head><label></label><figDesc>∩ V r rel (t 2 )+t 3 ) = r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ), and distinguish between the different kinds of transition relations:• Action step relations: For all states and , and a ∈ A, both r rel (t 1 ) ( ∩ V do not hold for any t and t .• Action termination relations: For all states and , and a ∈ A, both r There exist states and , s &gt; 0 and∈ E s such that r ≡ t 1 ( ∩ V t 2 )+ ∩ V ˜ or ∈ [s(t 1 )], ∈ [s(t 2 )],rel (t 2 )+t 3 ) for some closed term t 3 .--→ t , holds only if either t 1 , * s-r, ---→ t 1 , , t 2 , * * s-r, ---→ t 2 , , ∈ [s(t 3 )] and t ≡ t 1 ( ∩ V t 2 ) for some closed terms t 1 , t 2 and states * and * * , or t 1 , * s-r, ---→ t 1 , , t 2 , * * s-r, ---→ t 2 , , , and t ≡ t 1 ( ∩ V t 2 +t 3 ) for some closed terms t 1 , t 2 , t 3 and states * and * * . r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V ∈ [s(t 3 )] and t ≡ t 1 ( ∩ V t 2 ) for some closed terms t 1 , t 2 and states * and * * , or t 1 , * s-r, ---→ t 1 , , t 2 , * * s-r, --→ t 3 , and t ≡ t 1 ( ∩ V t 2 +t 3 ) for some closed terms t 1 , t 2 , t 3 and states * and * * . If t 3 , Signal relations: For all states , ∈ [s( r rel (t 1 ) ( ∩ V r rel (t 2 )+t 3 ))] holds only if and ∈ [s(t 3 )]; and ∈ [s( r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ))] holds only if and ∈ [s(t 3 )]. • Discontinuity relations: For all states and , → ∈ [d( r</figDesc><table><row><cell cols="3">• s &gt; r: r rel (t 1 ) ( ∩ V</cell><cell cols="2">r rel (t 2 )+t 3 ), --→ s,</cell><cell>s,</cell><cell>V , t 3 ,</cell></row><row><cell cols="7">s, --→ --→ t 3 r V , t 3 , s, rel ( ˜ ), s, --→ t , holds only if either t 1 ,  *  s-r, ---→ t 1 , , ---→ t 2 , , t 2 ,  *  *  s-r, s, --→ V , t 3 ,</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>---→</cell></row><row><cell>t 2 , ,</cell><cell>s, --→</cell><cell cols="2">V , t 3 ,</cell><cell>s,</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>s, --→ t ,</cell></row><row><cell cols="6">holds. We proceed by distinguishing three cases:</cell></row><row><cell cols="3">• s = r: r rel (t 1 ) ( ∩ V ∈ [s(t 2 )], s, --→ s, --→</cell><cell cols="2">r rel (t 2 )+t 3 ),</cell><cell cols="2">s, --→ t ,</cell><cell>holds only if either ∈ [s(t 1 )],</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>s, --→</cell></row><row><cell cols="3">• s &lt; r: r rel (t 1 ) ( ∩ V</cell><cell cols="2">r rel (t 2 )+t 3 ),</cell><cell cols="2">s, --→ t ,</cell><cell>holds only if either s, --→</cell><cell>s, --→</cell><cell>V ,</cell></row><row><cell cols="7">t 3 , r rel (t 1 ) ( r s, --→ t 3 , rel ( ∩ V t 2 )+t 3 )+ ∩ V and t ≡ r-s rel (t 1 ) ( ∩ V r rel ( ˜ ), V , t 3 , s -→, ∈ [s(t 3 )] and t ≡ r-s rel (t 1 ) r-s s, --→ t , r-s rel ( ∩ V t 2 )+ ∩ V holds only if either r-s rel ( ˜ ) or s, --→ s, --→ V , t 3 , s, --→ t 3 , and t ≡ r-s rel (t 1 ) ( r-s rel ( ∩ V t 2 )+t 3 )+ ∩ V r-s</cell></row></table><note><p><p><p><p><p><p><p><p>r rel (t 2 )+t 3 ), a → t , and r rel (t 1 ) ( r rel</p>( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ), a -→ t , rel (t 1 ) ( ∩ V r rel (t 2 )+t 3 ), a -→ √ , and r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ), a -→ √ , do not hold. • Time step relations: rel (t 1 ) ( ∩ V r rel (t 2 )+t 3 ), s, --→ t , or r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ), V , t 3 , s -→, ∈ [s(t 3 )] and t ≡ t 1 ( ∩ V t 2 ) or ∈ [s(t 1 )], ∈ [s(t 2 )], s, --→ V , t 3 , s,</p>--→ t 3 , and t ≡ t 1 ( ∩ V t 2 +t 3 ) for some</p>closed term t 3 . r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ), s, --→ t , holds only if either ∈ [s(t 1 )], ∈ [s(t 2 )], s, --→ V , t 3 , s -→, ∈ [s(t 3 )] and t V , t 3 , s,</p>--→ t 3 ,</p>and t ≡ t 1 ( ∩ V t 2 +t 3 )+ ∩ V ˜ for some closed term t 3 . If t 3 , s -→ and ∈ [s(t 3 )], then (t , t ) ∈ R. If t 3 , s, --→ t 3 , , then also (t , t ) ∈ R. V , t 3 , s -→, ∈ [s(t 3 )] and t ≡ r-s rel (t 1 ) ( ∩ V r-s rel (t 2 )) or rel ( ˜ ) for some closed term t 3 . If t 3 , s -→ and ∈ [s(t 3 )], then (t , t ) ∈ R. If t 3 , s, --→ t 3 , , then also (t , t ) ∈ R. s -→, s -→, s -→ and ∈ [s(t 3 )], then (t , t ) ∈ R. If t 3 , s, --→ t 3 , , then also (t , t ) ∈ R. • rel (t 1 ) ( ∩ V r rel (t 2 ) +t 3 ))] holds only if either r rel (t 1 ) ( ∩ V r rel (t 2 )+t 3 ) can idle, → C V , and → ∈ [d(t 3 )] or r rel (t 1 ) ( ∩ V r rel (t 2 )+t 3 ) cannot idle and ∈ [s(t 3 )]; and → ∈ [d( r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ))] holds only if r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel</p>(</p>˜ ) can idle, → C V , and → ∈ [d(t 3 )] or r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ) cannot idle and ∈ [s(t 3 )]. Both r rel (t 1 ) ( ∩ V r rel (t 2 )+t 3 ) and r rel (t 1 ) ( r rel ( ∩ V t 2 )+t 3 )+ ∩ V r rel ( ˜ ) can only idle if V or t 3 , s,</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>A function f : I → R, where I is an interval in R , is of class C 1 in I if ḟ , the (first order) derivative of f, exists at every point of I, and is continuous on I; and f is piecewise of class C 1 in I if I can be partitioned into a finite set I of left-closed and right-open intervals such that, for each interval I ∈ I, the restriction of f to I is of class C 1 in I .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>The notation * rel (t), which will be introduced in Section 3.1, is to be read as "the relative delay of t for an arbitrary period of time".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>This equivalence is called bisimulation equivalence in Refs.<ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b46">47]</ref>. This should not be confused with what is called bisimulation equivalence in this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>The timed transition system associated with a hybrid automaton may have multiple initial states. We deal with that in the process algebra representation in the way described in Ref.<ref type="bibr" target="#b30">[31]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>This equivalence is called bisimulation equivalence in Refs.<ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b46">47]</ref>. This should not be confused with what is called bisimulation equivalence in this paper.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The work presented in this paper has been partly carried out while the second author was also part-time at Utrecht University, Department of Philosophy. We thank Pieter Cuijpers from Eindhoven University of Technology, Computing Science Department, for pointing us at the existence of two serious errors in our initial soundness proofs. We have used variants of one of his counterexamples of soundness in Sections 4.3 and 4.5. We also thank the referees for their valuable comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A</head><p>In this appendix, we outline elimination, congruence and soundness proofs for BPA srt hs and ACP srt hs . The full proofs are for the greater part very long and really tedious. They are, for example, much longer than the full proofs given in Ref. <ref type="bibr" target="#b53">[54]</ref> for a version of ACP with discrete relative timing. We focus on the most difficult parts of the proofs in this appendix. Even for those parts, we do not give full details. That is, we mention the axioms by which the equations relevant to the elimination proofs can be derived instead of presenting the derivations of the equation, and we present in the congruence and soundness proofs the conditions under which transition relations hold without mentioning how the conditions follow from the transition rules. What is left out, can easily be found by consulting the axioms referred to or the applicable transition rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1. Proof of Theorem 1 (Elimination for BPA srt</head><p>hs )</p><p>The proof is straightforward by induction on the structure of closed term t. For terms t of the forms ⊥, ã, r rel (t ), t +t and ∧ t , it is trivial to show that there is a basic term that is derivably equal to t. For terms t of the forms rel (t ), t • t , :→ t , ∩ V t and t , it follows immediately from the induction hypothesis and the following lemmas:</p><p>(1) for all t ∈ B, there is a t ∈ B such that rel (t) = t is derivable;</p><p>(2) for all t, t ∈ B, there is a t ∈ B such that t • t = t is derivable;</p><p>(3) for all ∈ P st and t ∈ B, there is a t ∈ B such that :→ t = t is derivable; (4) for all ∈ P st , V ⊆ V and t ∈ B, there is a t ∈ B such that ∩ V t = t is derivable;</p><p>(5) for all ∈ P tr and t ∈ B, there is a t ∈ B such that t = t is derivable.</p><p>The closed substitution instances of the equation x = x trivially satisfy the conditions for an ic-bisimulation relation.</p><p>Axioms HST5 and HST14 and lifting rules HSELR2 and HSELR3 have to be checked with respect to bisimulation equivalence instead of ic-bisimulation equivalence. This goes in a similar way. The differences are that we give a binary relation R on configurations, i.e. pairs of closed terms and states, and show that the conditions for bisimulation equivalence are satisfied. For example, in the case of axiom HST5, we take the relation R that consists of all pairs ( t, , t , ) where t = t is a closed substitution instance of axiom HST5 and is a state and all pairs ( t * , * , • ∧ t * , * ) where is a transition proposition, t * is a closed term and * is a state such that *</p><p>• . The restriction on * is essential here. It is the reason why checking with respect to ic-bisimulation equivalence fails.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4. Proof of Theorem 9 (Elimination for ACP srt hs )</head><p>Like the proof of Theorem 1, the proof is by induction on the structure of closed term t. For terms t of the forms ⊥, ã, r rel (t ), t +t , t • t , :→ t , ∧ t , ∩ V t , t and rel (t ), it follows immediately from the induction hypothesis and Theorem 1, that there is a basic term that is derivably equal to t. For terms of the forms t t , t t , t | t and * H (t ), it follows immediately from the induction hypothesis and the following lemmas:</p><p>(1) for all t, t ∈ B, there is a t ∈ B such that t t = t is derivable;</p><p>(2) for all t, t ∈ B, there is a t ∈ B such that t t = t is derivable;</p><p>(3) for all t, t ∈ B, there is a t ∈ B such that t | t = t is derivable; (4) for all t ∈ B, there is a t ∈ B such that * H (t) = t is derivable. The fourth lemma is easily proven by induction on the structure of the basic term t. The first three lemmas are proven simultaneously by induction on the sum of the norm of t and the norm of t . The norm of a closed term t, written |t|, is intended to be a measure of the complexity of t. It is defined as follows:</p><p>The first lemma follows immediately from the second and third lemma. The proof of the second lemma goes by case distinction on the structure of the basic term t, and the proof of the third lemma goes by case distinction on the structure of the basic terms t and t . We sketch here the proof of the second lemma. The proof of the third lemma is much simpler. The proof of the second lemma is simplified by using a fifth lemma:</p><p>(5) for all t ∈ B, either * A ( rel (t)) = ⊥ is derivable or there is a ∈ P st + such that * A ( rel (t)) = ∧ ˜ is derivable. This lemma is easily proven by induction on the structure of basic term t.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Structural operational semantics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Aceto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Fokkink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Verhoef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="197" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The algorithmic analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="3" to="34" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hybrid automata: an algorithmic approach to the specification and verification of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Grossman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Rischel</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">736</biblScope>
			<biblScope unit="page" from="209" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automata for modeling real-time systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th ICALP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Paterson</surname></persName>
		</editor>
		<meeting>17th ICALP<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">443</biblScope>
			<biblScope unit="page" from="322" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A theory of timed automata</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="page" from="183" to="235" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Compositional refinement for hierarchical hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Grosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Di Benedetto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2034</biblScope>
			<biblScope unit="page" from="33" to="48" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic symbolic verification of embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="201" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Real time process algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="142" to="188" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Real space process algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="481" to="529" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Real time process algebra with infinitesimals</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebra of Communicating Processes</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Verhoef</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">F M</forename><surname>Van Vlijmen</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994. 1995</date>
			<biblScope unit="page" from="148" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Process algebra with propositional signals</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">177</biblScope>
			<biblScope unit="page" from="381" to="405" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Discrete time process algebra with silent step</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proof, Language and Interaction: Essays in Honour of Robin Milner</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Stirling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="535" to="569" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Process algebra with timing: real time and discrete time</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="627" to="684" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Process Algebra with Timing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Monographs in Theoretical Computer Science, An EATCS Series</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A new equivalence for processes with timing-with an application to protocol verification</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<idno>02-10</idno>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics and Computer Science, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Computer Science Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Weijland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Process algebra</title>
		<title level="s">Cambridge Tracts in Theoretical Computer Science</title>
		<meeting>ess algebra<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Algebra of timed frames</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Fokkink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. J. Comput. Math</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="227" to="255" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The algebra of recursively defined processes and the algebra of regular processes</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th ICALP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<meeting>11th ICALP<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">172</biblScope>
			<biblScope unit="page" from="82" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Verification of an alternating bit protocol by means of process algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Methods of Specification and Synthesis of Software Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Bibel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Jantke</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="9" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Process algebra for hybrid systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
		<idno>03-06</idno>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics and Computer Science, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Computer Science Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Continuity controlled hybrid automata</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
		<idno>04-11</idno>
		<imprint>
			<date type="published" when="2004-04">April 2004</date>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics and Computer Science, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Computer Science Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Located actions in process algebra with timing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fund. Inform</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="183" to="211" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Discrete time process algebra and the semantics of SDL</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Usenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="1209" to="1268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Browder</surname></persName>
		</author>
		<title level="m">Mathematical Analysis: An Introduction</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A calculus of durations</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Chaochen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="269" to="276" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An extended duration calculus for hybrid real-time systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Chaochen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Grossman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Rischel</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">736</biblScope>
			<biblScope unit="page" from="36" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An interleaving model for real-time systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Logical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Taitslin</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">620</biblScope>
			<biblScope unit="page" from="81" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Topological (bi-)simulation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J L</forename><surname>Cuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<idno>02-04</idno>
		<imprint>
			<date type="published" when="2001-04">April 2001</date>
			<pubPlace>Eindhoven</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics and Computer Science, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Computer Science Report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Hybrid process algebra</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J L</forename><surname>Cuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Reniers</surname></persName>
		</author>
		<idno>03-07</idno>
		<imprint>
			<date type="published" when="2003-07">July 2003</date>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics and Computer Science, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Computer Science Report</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Timed CSP: theory and practice</title>
		<author>
			<persName><forename type="first">J</forename><surname>Davies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Real Time: Theory and Practice</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Huizing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">600</biblScope>
			<biblScope unit="page" from="640" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The linear time-branching time spectrum I</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Van Glabbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="3" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Process algebra with guards: combining Hoare logic with process algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="115" to="164" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Analysis of three hybrid systems in timed CRL</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wamel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Programming</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2/3</biblScope>
			<biblScope unit="page" from="215" to="247" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A process algebra for timed systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Regan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Comput</title>
		<imprint>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="221" to="239" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The theory of hybrid automata</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS&apos;96</title>
		<meeting><address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="278" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Assume-guarantee reasoning for hierarchical hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Di Benedetto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2034</biblScope>
			<biblScope unit="page" from="275" to="290" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">HyTech: a model checker for hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. J. Tools Technol. Transfer</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="110" to="122" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Algorithmic analysis of nonlinear hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Control</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="278" to="292" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Beyond HyTech: hybrid systems analysis using interval numerical methods</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HSCC 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1790</biblScope>
			<biblScope unit="page" from="130" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Towards refining temporal specifications into hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Grossman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Rischel</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">736</biblScope>
			<biblScope unit="page" from="60" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">A Classical Mind: Essays in Honour of</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="171" to="189" />
		</imprint>
	</monogr>
	<note>From CSP to hybrid systems</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I/O</forename><surname>Hybrid</surname></persName>
		</author>
		<author>
			<persName><surname>Automata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Comput</title>
		<imprint>
			<biblScope unit="volume">185</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="105" to="157" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Truth of duration calculus formulae in timed frames</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fund. Inform</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2/3</biblScope>
			<biblScope unit="page" from="235" to="263" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Variable binding operators in transition system specifications</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="15" to="45" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Process algebra with nonstandard timing</title>
		<meeting>ess algebra with nonstandard timing</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="55" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Revisiting timing in process algebra</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="109" to="127" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">An alternative formulation of operational conservativity with binding terms</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Middelburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communicating and Mobile Systems: The -Calculus</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A temporal calculus of communicating systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tofts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR&apos;90</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">458</biblScope>
			<biblScope unit="page" from="401" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">The algebra of timed processes ATP: theory and application</title>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Comput</title>
		<imprint>
			<biblScope unit="volume">114</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="131" to="178" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">TIC: a timed calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Quemada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De Frutos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Azcorra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="224" to="252" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The -calculus: a language for distributed control of reconfigurable embedded systems</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Rounds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hosung</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HSCC 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2623</biblScope>
			<biblScope unit="page" from="435" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A process algebra for hybrid systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Vereijken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second European Workshop on Real-Time and Hybrid Systems</title>
		<meeting><address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Discrete time process algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Vereijken</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Eindhoven</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Mathematics and Computer Science, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Real-time behaviour of asynchronous agents</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR&apos;90</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">458</biblScope>
			<biblScope unit="page" from="502" to="520" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
