<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Solving the multi-way matching problem by permutation synchronization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Deepti</forename><surname>Pachauri</surname></persName>
							<email>pachauri@cs.wisc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin</orgName>
								<address>
									<settlement>Madison</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Risi</forename><surname>Kondor</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Computer Science and Dept. of Statistics</orgName>
								<orgName type="institution">The University of Chicago</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vikas</forename><surname>Singh</surname></persName>
							<email>vsingh@biostat.wisc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin</orgName>
								<address>
									<settlement>Madison</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Biostatistics &amp; Medical Informatics</orgName>
								<orgName type="institution">University of Wisconsin</orgName>
								<address>
									<settlement>Madison</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Solving the multi-way matching problem by permutation synchronization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3936100073C7E91C1169A1998261D348</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The problem of matching not just two, but m different sets of objects to each other arises in many contexts, including finding the correspondence between feature points across multiple images in computer vision. At present it is usually solved by matching the sets pairwise, in series. In contrast, we propose a new method, Permutation Synchronization, which finds all the matchings jointly, in one shot, via a relaxation to eigenvector decomposition. The resulting algorithm is both computationally efficient, and, as we demonstrate with theoretical arguments as well as experimental results, much more stable to noise than previous methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Finding the correct bijection between two sets of objects X = {x 1 , x 2 , . . . , x n } and X ′ = {x ′  1 , x ′ 2 , . . . , x ′ n } is a fundametal problem in computer science, arising in a wide range of contexts <ref type="bibr" target="#b0">[1]</ref>. In this paper, we consider its generalization to matching not just two, but m different sets X 1 , X 2 , . . . , X m . Our primary motivation and running example is the classic problem of matching landmarks (feature points) across many images of the same object in computer vision, which is a key ingredient of image registration <ref type="bibr" target="#b1">[2]</ref>, recognition <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, stereo <ref type="bibr" target="#b4">[5]</ref>, shape matching <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>, and structure from motion (SFM) <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. However, our approach is fully general and equally applicable to problems such as matching multiple graphs <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>Presently, multi-matching is usually solved sequentially, by first finding a putative permutation τ 12 matching X 1 to X 2 , then a permutation τ 23 matching X 2 to X 3 , and so on, up to τ m-1,m . While one can conceive of various strategies for optimizing this process, the fact remains that when the data are noisy, a single error in the sequence will typically create a large number of erroneous pairwise matches <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14]</ref>. In contrast, in this paper we describe a new method, Permutation Synchronization, that estimates the entire matrix (τ ji ) m i,j=1 of assignments jointly, in a single shot, and is therefore much more robust to noise.</p><p>For consistency, the recovered matchings must satisfy τ kj τ ji = τ ki . While finding an optimal matrix of permutations satisfying these relations is, in general, combinatorially hard, we show that for the most natural choice of loss function the problem has a natural relaxation to just finding the n leading eigenvectors of the cost matrix. In addition to vastly reducing the computational cost, using recent results from random matrix theory, we show that the eigenvectors are very effective at aggregating information from all ( m 2 ) pairwise matches, and therefore make the algorithm surprisingly robust to noise. Our experiments show that in landmark matching problems Permutation Synchronization can recover the correct correspondence between landmarks across a large number of images with small error, even when a significant fraction of the pairwise matches are incorrect.</p><p>The term "synchronization" is inspired by the recent celebrated work of Singer et al. on a similar problem involving finding the right rotations (rather than matchings) between electron microscopic images <ref type="bibr" target="#b14">[15]</ref>[16] <ref type="bibr" target="#b16">[17]</ref>. Historically, multi-matching has received relatively little attention. However, independently of, and concurrently with the present work, Huang and Guibas <ref type="bibr" target="#b17">[18]</ref> have recently proposed a semidefinite programming based solution, which parallels our approach, and in problems involving occlusion might perform even better.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Synchronizing permutations</head><p>Consider a collection of m sets X 1 , X 2 , . . . , X m of n objects each, X i = {x i 1 , x i 2 , . . . , x i n }, such that for each pair (X i , X j ), each x i p in X i has a natural counterpart x j q in X j . For example, in computer vision, given m images of the same scene taken from different viewpoints, x i 1 , x i 2 , . . . , x i n might be n visual landmarks detected in image i, while x j 1 , x j 2 , . . . , x j n are n landmarks detected in image j, in which case x i p ∼ x j q signifies that x i p and x j q correspond to the same physical feature. Since the correspondence between X i and X j is a bijection, one can write it as x i p ∼ x j τji(p) for some permutation τ ji : {1, 2, . . . , n} → {1, 2, . . . , n}. Key to our approach to solving multi-matching is that with respect to the natural definition of multiplication, (τ ′ τ )(i) := (τ ′ (τ (i)), the n! possible permutations of {1, 2, . . . , n} form a group, called the symmetric group of degree n, denoted S n .</p><p>We say that the system of correspondences between X 1 , X 2 , . . . , X m is consistent if x i p ∼ x j q and x j q ∼ x k r together imply that x i p ∼ x k r . In terms of permutations this is equivalent to requiring that the array (τ ij ) m i,j=1 satisfy τ kj τ ji = τ ki ∀i, j, k.</p><p>(1) Alternatively, given some reference ordering of x 1 , x 2 , . . . , x n , we can think of each X i as realizing its own permutation σ i (in the sense of x ℓ ∼ x i σi(ℓ) ), and then τ ji becomes τ ji = σ j σ -1 i .</p><p>(</p><p>The existence of permutations σ 1 , σ 2 , . . . , σ m satisfying (2) is equivalent to requiring that (τ ji ) m i,j=1</p><p>satisfy (1). Thus, assuming consistency, solving the multi-matching problem reduces to finding just m different permutations, rather than O(m 2 ). However, the σ i 's are of course not directly observable. Rather, in a typical application we have some tentative (noisy) τji matchings which we must synchronize into the form (2) by finding the underlying σ 1 , . . . , σ m .</p><p>Given (τ ji ) m i,j=1 and some appropriate distance metric d between permutations, we formalize Permutation Synchronization as the combinatorial optimization problem minimize σ1,σ2,...,σm∈Sn</p><formula xml:id="formula_1">N ∑ i,j=1 d(σ j σ -1 i , τji ).<label>(3)</label></formula><p>The computational cost of solving (3) depends critically on the form of the distance metric d. In this paper we limit ourselves to the simplest choice</p><formula xml:id="formula_2">d(σ, τ ) = n -⟨P (σ), P (τ )⟩ ,<label>(4)</label></formula><p>where P (σ) ∈ R n×n are the usual permutation matrices</p><formula xml:id="formula_3">[P (σ)] q,p := { 1 if σ(p) = q 0 otherwise,</formula><p>and ⟨A, B⟩ is the matrix inner product ⟨A, B⟩ := tr(A ⊤ B) = ∑ n p,q=1 A p,q B p,q . The distance (4) simply counts the number of objects assigned differently by σ and τ . Furthermore, it allows us to rewrite (3) as maximize σ1,σ2,...,σm ∑ m i,j=1 ⟨P (σ j σ -1 i ), P (τ ji )⟩, suggesting the generalization maximize σ1,σ2,...,σm m ∑ i,j=1</p><formula xml:id="formula_4">⟨ P (σ j σ -1 i ), T ji ⟩ , (<label>5</label></formula><formula xml:id="formula_5">)</formula><p>where the T ji 's can now be any matrices, subject to T ⊤ ji = T ij . Intuitively, each T ji is an objective matrix, the (q, p) element of which captures the utility of matching x i p in X i to x j q in X j . This generalization is very useful when the assignments of the different x i p 's have different confidences. For example, in the landmark matching case, if, due to occlusion or for some other reason, the counterpart of x i p is not present in X j , then we can simply set [T ji ] q,p = 0 for all q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Representations and eigenvectors</head><p>The generalized Permutation Synchronization problem (5) can also be written as maximize σ1,σ2,...,σm ⟨P, T ⟩ , (</p><p>where</p><formula xml:id="formula_7">P =    P (σ 1 σ -1 1 ) . . . P (σ 1 σ -1 m ) . . . . . . . . . P (σ m σ -1 1 ) . . . P (σ m σ -1 m )    and T =    T 11 . . . T 1m . . . . . . . . . T m1 . . . T mm    .<label>(7)</label></formula><p>A matrix valued function ρ : S n → C d×d is said to be a representation of the symmetric group if ρ(σ 2 ) ρ(σ 1 ) = ρ(σ 2 σ 1 ) for any pair of permutations σ 1 , σ 2 ∈ S n . Clearly, P is a representation of S n (actually, the so-called defining representation), since P (σ 2 σ 1 ) = P (σ 2 ) P (σ 1 ). Moreover, P is a so-called orthogonal representation, because each P (σ) is real and P (σ -1 ) = P (σ) ⊤ . Our fundamental observation is that this implies that P has a very special form. Proposition 1. The synchronization matrix P is of rank n and is of the form P = U • U ⊤ , where</p><formula xml:id="formula_8">U =    P (σ 1 ) . . . P (σ m )    .</formula><p>Proof. From P being a representation of S n ,</p><formula xml:id="formula_9">P =    P (σ 1 ) P (σ 1 ) ⊤ . . . P (σ 1 ) P (σ m ) ⊤ . . . . . . . . . P (σ m ) P (σ 1 ) ⊤ . . . P (σ m ) P (σ m ) ⊤    ,<label>(8)</label></formula><p>implying P = U • U ⊤ . Since U has n columns, rank(P) is at most n. This rank is achieved because P (σ 1 ) is an orthogonal matrix, therefore it has linearly independent columns, and consequently the columns of U cannot be linearly dependent. ■ Corollary 1. Letting [P (σ i )] p denote the p'th column of P (σ i ), the normalized columns of U ,</p><formula xml:id="formula_10">u ℓ = 1 √ m    [P (σ 1 )] ℓ . . . [P (σ m )] ℓ    ℓ = 1, . . . , n,<label>(9)</label></formula><p>are mutually orthogonal unit eigenvectors of P with the same eigenvalue m, and together span the row/column space of P.</p><p>Proof. The columns of U are orthogonal because the columns of each constituent P (σ i ) are orthogonal. The normalization follows from each column of P (σ i ) having norm 1. The rest follows by Proposition 1. ■</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">An easy relaxation</head><p>Solving (6) is computationally difficult, because it involves searching the combinatorial space of a combination of m permutations. However, Proposition 1 and its corollary suggest relaxing it to maximize</p><formula xml:id="formula_11">P∈M n m ⟨P, T ⟩ , (<label>10</label></formula><formula xml:id="formula_12">)</formula><p>where M m n is the set of mn-dimensional rank n symmetric matrices whose non-zero eigenvalues are m. This is now just a generalized Rayleigh problem, the solution of which is simply</p><formula xml:id="formula_13">P = m n ∑ ℓ=1 v ℓ v ⊤ ℓ , (<label>11</label></formula><formula xml:id="formula_14">)</formula><p>where v 1 , v 2 , . . . , v ℓ are the n leading normalized eigenvectors of T . Equivalently, P = U • U ⊤ , where</p><formula xml:id="formula_15">U = √ m ( | | . . . | v 1 v 2 . . . v n | | . . . | ) . (<label>12</label></formula><formula xml:id="formula_16">)</formula><p>Thus, in contrast to the original combinatorial problem, <ref type="bibr" target="#b9">(10)</ref>  Of course, from P we must still recover the individual permutations σ 1 , σ 2 , . . . , σ m . However, as long as P is relatively close in form <ref type="bibr" target="#b6">(7)</ref>, this is quite a simple and stable process. One way to do it is to let each σ i be the permutation that best matches the (i, 1) block of P in the linear assignment sense, 3 ) time by the Kuhn-Munkres algorithm <ref type="bibr" target="#b18">[19]</ref> <ref type="foot" target="#foot_0">1</ref> , and then set τ ji = σ j σ -1 i , which will then satisfy the consistency relations. The pseudocode of the full algorithm is given in Algorithm 1.</p><formula xml:id="formula_17">σ i = arg min σ∈Sn ⟨P (σ), [P] i,1 ⟩ , which is solved in O(n</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Analysis of the relaxed algorithm</head><p>Let us now investigate under what conditions we can expect the relaxation <ref type="bibr" target="#b9">(10)</ref> to work well, in particular, in what cases we can expect the recovered matchings to be exact.</p><p>In the absence of noise, i.e., when T ji = P (τ ji ) for some array (τ ji ) j,i of permutations that already satisfy the consistency relations (1), T will have precisely the same structure as described by Proposition 1 for P. In particular, it will have n mutually orthogonal eigenvectors</p><formula xml:id="formula_18">v ℓ = 1 √ m    [P (σ 1 )] ℓ . . . [P (σ m )] ℓ    ℓ = 1, . . . , n<label>(13)</label></formula><p>with the same eigenvalue m. Due to the n-fold degeneracy, however, the matrix of eigenvectors ( <ref type="formula" target="#formula_15">12</ref>) is only defined up to multiplication by an arbitrary rotation matrix O on the right, which means that instead of the "correct" U (whose columns are (13)), the eigenvector decomposition of T may return any U ′ = U O. Fortunately, when forming the product</p><formula xml:id="formula_19">P = U ′ • U ′ ⊤ = U O O ⊤ U ⊤ = U • U ⊤</formula><p>this rotation cancels, confirming that our algorithm recovers P = T , and hence the matchings τ ji = τji , with no error.</p><p>Of course, rather than the case when the solution is handed to us from the start, we are more interested in how the algorithm performs in situations when either the T ji blocks are not permutation matrices, or they are not synchronized. To this end, we set</p><formula xml:id="formula_20">T = T 0 + N , (<label>14</label></formula><formula xml:id="formula_21">)</formula><p>where T 0 is the correct "ground truth" synchronization matrix, while N is a symmetric perturbation matrix with entries drawn independently from a zero-mean normal distribution with variance η 2 .</p><p>In general, to find the permutation best aligned with a given n × n matrix T , the Kuhn-Munkres algorithm solves for τ = arg max τ ∈Sn ⟨P (τ ), T ⟩ = arg max τ ∈Sn (vec(P (τ )) • vec(T )). Therefore, writing T = P (τ 0 ) + ϵ, where P (τ 0 ) is the "ground truth", while ϵ is an error term, it is guaranteed to return the correct permutation as long as ∥ vec(ϵ) ∥ &lt; min</p><formula xml:id="formula_22">τ ′ ∈ Sn\{τ0} ∥ vec(τ 0 ) -vec(τ ′ ) ∥ /2.</formula><p>By the symmetry of S n , the right hand side is the same for any τ 0 , so w.l.o.g. we can set τ 0 = e (the identity), and find that the minimum is achieved when τ ′ is just a transposition, e.g., the permutation that swaps 1 with 2 and leaves 3, 4, . . . , n in place. The corresponding permutation matrix differs from the idenity in exactly 4 entries, therefore a sufficient condition for correct reconstruction is that</p><formula xml:id="formula_23">∥ϵ∥ Frob = ⟨ϵ, ϵ⟩ 1/2 = ∥vec(ϵ)∥ &lt; 1 2 √ 4 = 1.</formula><p>As n grows, ∥ϵ∥ Frob becomes tightly concentrated around ηn, so the condition for recovering the correct permutation is η &lt; 1/n.</p><p>Permutation Synchronization can achieve a lower error, especially in the large m regime, because the eigenvectors aggregate information from all the T ji matrices, and tend to be very stable to perturbations. In general, perturbations of the form ( <ref type="formula" target="#formula_20">14</ref>) exhibit a characteristic phase transition. As long as the largest eigenvalue of the random matrix N falls below a given multiple of the smallest non-zero eigenvalue of T 0 , adding N will have very little effect on the eigenvectors of T . On the other hand, when the noise exceeds this limit, the spectra get fully mixed, and it becomes impossible to recover T 0 from T to any precision at all.</p><p>If N is a symmetric matrix with independent N (0, η 2 ) entries, as nm → ∞, its spectrum will tend to Wigner's famous semicircle distribution supported on the interval (-2η(nm) 1/2 , 2η(nm) 1/2 ), and with probability one the largest eigenvalue will approach 2η(nm) 1/2 <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>. In contrast, the nonzero eigenvalues of T 0 scale with m, which guarantees that for large enough m the two spectra will be nicely separated and Permutation Synchronization will have very low error. While much harder to analyze analytically, empirical evidence suggests that this type of phase transition behavior is characteristic of any reasonable noise model, for example the one in which we take each block of T and with some probability p replace it with a random permutation matrix (Figure <ref type="figure" target="#fig_0">1</ref>).</p><p>To derive more quantitative results, we consider the case where N is a so-called (symmetric) Gaussian Wigner matrix, which has independent N (0, η 2 ) entries on its diagonal, and N (0, η 2 /2) entries everywhere else. It has recently been proved that for this type of matrix the phase transition occurs at λ det min /λ stochastic max = 1/2, so to recover T 0 to any accuracy at all we must have η &lt; (m/n) 1/2 <ref type="bibr" target="#b21">[22]</ref>. Below this limit, to quantify the actual expected error, we write each leading normalized eigenvector</p><formula xml:id="formula_24">v 1 , v 2 , . . . , v n of T as v i = v * i + v ⊥ i , where v * i is the projection of v i to the space U 0 spanned by the non-zero eigenvectors v 0 1 , v 0 2 , . . . , v 0 n of T 0 . By Theorem 2.2 of [22] as nm → ∞, ∥v * i ∥ 2 a.s. ---→ 1 -η 2 n m and ∥v ⊥ i ∥ 2 a.s. ---→ η 2 n m . (<label>15</label></formula><formula xml:id="formula_25">)</formula><p>It is easy to see that</p><formula xml:id="formula_26">⟨v ⊥ i , v ⊥ j ⟩ a.s. --→ 0, which implies ⟨v * i , v * j ⟩ = ⟨v i , v j ⟩ -⟨v ⊥ i , v ⊥ j ⟩ a.s.</formula><p>--→ 0, so, setting λ = (1 -η 2 n/m) -1/2 , the normalized vectors λv * 1 , . . . , λv * n almost surely tend to an orthonormal basis for U 0 . Thus,</p><formula xml:id="formula_27">U = √ m [v 1 , . . . , v n ] is related to the "true" U 0 = √ m [v 0 1 , . . . , v 0 n ] by λU a.s. --→ U 0 O + λE ′ = (U 0 + λE)O,</formula><p>where O is some rotation and each column of the noise matrices E and E ′ has norm η(n/m) 1/2 . Since multiplying U on the right by an orthogonal matrix does not affect P, and the Kuhn-Munkres algorithm is invariant to scaling by a constant, this equation tells us that (almost surely) the effect of ( <ref type="formula" target="#formula_20">14</ref>) is equivalent to setting U = U 0 + λE. In terms of the individual P ji blocks of P = U U ⊤ , neglecting second order terms,</p><formula xml:id="formula_28">P ji = (U 0 j + λE j )(U 0 i + λE i ) ⊤ ≈ P (τ ji ) + λU 0 j E ⊤ i + λE j U 0⊤ i ,</formula><p>where τ ji is the ground truth matching and U 0 i and E i denote the appropriate n × n submatrices of U 0 and E. Conjecturing that in the limit E i and E j follow rotationally invariant distributions, almost surely</p><formula xml:id="formula_29">lim ∥ U 0 j E ⊤ i + E j U 0⊤ i ∥ Frob = lim ∥ E i + E j ∥ Frob ≤ 2 ηn/m.</formula><p>Thus, plugging in to our earlier result for the error tolerance of the Kuhn-Munkres algorithm, Permutation Synchronization will correctly recover τ ji with probability one provided 2ληn/m &lt; 1, or, equivalently,</p><formula xml:id="formula_30">η 2 &lt; m/n 1 + 4(m/n) -1 .</formula><p>This is much better than our η &lt; 1/n result for the naive algorithm, and remarkably only slightly stricter than the condition η &lt; (m/n) 1/2 for recovering the eigenvectors with any accuracy at all. Of course, these results are asymptotic (in the sense of nm → ∞), and strictly speaking only apply to additive Gaussian Wigner noise. However, as Figure <ref type="figure" target="#fig_1">2</ref> shows, in practice, even when the noise is in the form of corrupting entire permutations and nm is relatively small, qualitatively our algorithm exhibits the correct behavior, and for large enough m Permutation Synchronization does indeed recover all (τ ji ) m j,i=1 with no error even when the vast majority of the entries in T are incorrect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>Since computer vision is one of the areas where improving the accuracy of multi-matching problems is the most pressing, our experiments focused on this domain. For a more details of our results, please see the extended version of the paper available on project website.</p><p>Stereo Matching. As a proof of principle, we considered the task of aligning landmarks in 2D images of the same object taken from different viewpoints in the CMU house (m = 111 frames of a video sequence of a toy house with n = 30 hand labeled landmark points in each frame) and CMU hotel (m = 101 frames of a video sequence of a toy hotel, n = 30 hand labeled landmark points in each frame) datasets. The baseline method is to compute (τ ji ) m i,j=1 by solving</p><formula xml:id="formula_31">( m 2 )</formula><p>independent linear assignment problems based on matching landmarks by their shape context features <ref type="bibr" target="#b22">[23]</ref>. Our method takes the same pairwise matches and synchronizes them with the eigenvector based procedure. Figure <ref type="figure" target="#fig_2">3</ref> shows that this clearly outperforms the baseline, which tends to degrade progressively as the number of images increases. This is due to the fact that the appearance (or descriptors) of keypoints differ considerably for large offset pairs (which is likely when the image set is large), leading to many false matches. In contrast, our method improves as the size of the image set increases. While simple, this experiment demonstrates the utility of Permutation Synchronization for multi-view stereo matching, showing that instead of heuristically propagating local pairwise matches, it can find a much more accurate globally consistent matching at little additional cost.  Repetitive Structures. Next, we considered a dataset with severe geometric ambiguities due to repetitive structures. There is some consensus in the community that even sophisticated features (like SIFT) yield unsatisfactory results in this scenario, and deriving a good initial matching for structure from motion is problematic (see <ref type="bibr" target="#b23">[24]</ref> and references therein). Our evaluations included 16 images from the Building dataset <ref type="bibr" target="#b23">[24]</ref>. We identified 25 "similar looking" landmark points in the scene, and hand annotated them across all images. Many landmarks were occluded due to the camera angle. Qualitative results for pairwise matching and Permutation Synchronization are shown in contains m = 20 images of multiple books on a "L" shaped study table <ref type="bibr" target="#b23">[24]</ref>, and suffers geometrical ambiguities similar to the above with severe occlusion. Here we identified n = 34 landmark points, many of which were occluded in most images. The error from the baseline method was 0.92, and Permutation Synchronization decreased this by 22% to 0.70 (see extended version of the paper).</p><p>Keypoint matching with nominal user supervision. Our final experiment deals with matching problems where keypoints in each image preserve a common structure. In the literature, this is usually tackled as a graph matching problem, with the keypoints defining the vertices, and their structural relationships being encoded by the edges of the graph. Ideally, one wants to solve the problem for all images at once but most practical solutions operate on image (or graph) pairs. Note that in terms of difficulty, this problem is quite distinct from those discussed above. In stereo, the same object is imaged and what varies from one view to the other is the field of view, scale, or pose. In contrast, in keypoint matching, the background is not controlled and even sophisticated descriptors may go wrong. Recent solutions often leverage supervision to make the problem tractable <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref>. Instead of learning parameters <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b26">27]</ref>, we utilize supervision directly to provide the correct matches on a small subset of randomly picked image pairs (e.g., via a crowdsourced platform like Mechanical Turk). We hope to exploit this 'ground-truth' to significantly boost accuracy via Permutation Synchronization. For our experiments, we used the baseline method output to set up our objective matrix T but with a fixed "supervision probability", we replaced the T ji block by the correct permutation matrix, and ran Permutation Synchronization. We considered the "Bikes" sub-class from the Caltech 256 dataset, which contains multiple images of common objects with varying backdrops, and chose to match images in the "touring bike" class. Our analysis included 28 out of 110 images in this dataset that were taken "side-on". SUSAN corner detector was used to identify landmarks in each image. Further, we identified 6 interest points in each image that correspond to the frame of the bicycle. We modeled the matching cost for an image pair as the shape distance between interest points in the pair. As before, the baseline was pairwise linear assignment. For a fixed degree of supervision, we randomly selected image pairs for supervision and estimated matchings for the rest of the image pairs. We performed 50 runs for each degree of supervision. Mean error and standard deviation is shown in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>Estimating the correct matching between two sets from noisy similarity data, such as the visual feature based similarity matrices that arise in computer vision is an error-prone process. However, when we have not just two, but m different sets, the consistency conditions between the ( m 2 ) pairwise matchings severely constrain the solution. Our eigenvector decomposition based algorithm, Permutation Synchronization, exploits this fact and pools information from all pairwise similarity matrices to jointly estimate a globally consistent array of matchings in a single shot. Theoretical results suggest that this approach is so robust that no matter how high the noise level is, for large enough m the error is almost surely going to be zero. Experimental results confirm that in a range of computer vision tasks from stereo to keypoint matching in dissimilar images, the method does indeed significantly improve performance (especially when m is large, as expected in video), and can get around problems such as occlusion that a pairwise strategy cannot handle. In future work we plan to compare our method to <ref type="bibr" target="#b17">[18]</ref> (which was published after the present paper was submitted), as well as investigate using the graph connection Laplacian <ref type="bibr" target="#b27">[28]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Singular value histogram of T under the noise model where each τji with probability p = {0.10, 0.25, 0.85} is replaced by a random permutation (m = 100, n = 30).Note that apart from the extra peak at zero, the distribution of the stochastic eigenvalues is very similar to the semicircular distribution for Gaussian noise. As long as the small cluster of deterministic eigenvalues is clearly separated from the noise, Permutation Synchronization is feasible.</figDesc><graphic coords="5,113.51,82.87,133.29,99.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The fraction of (σi) m i=1 permutations that are incorrect when reconstructed by Permutation Synchronization from an array (τji) m j,i=1 , in which each entry, with probability p is replaced by a random permutation. The plots show the mean and standard deviation of errors over 20 runs as a function of p for m = 10 (red), m = 50 (blue) and m = 100 (green). (Left) n = 10. (Center) n = 25. (Right) n = 30.</figDesc><graphic coords="6,125.38,82.82,125.45,94.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: (a) Normalized error as m increases on the House dataset. Permutation Synchronization (blue) vs. the pairwise Kuhn-Munkres baseline (red). (b-c) Matches found for a representative image pair. (Green circles) landmarks, (green lines) ground truth, (red lines) found matches. (b) Pairwise linear assignment, (c) Permutation Synchronization. Note that less visible green is good.</figDesc><graphic coords="7,254.43,91.82,120.76,87.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Matches for a representative image pairs from the Building (top) and Books (bottom) datasets. (Green circles) landmark points, (green lines) ground truth matchings, (red lines) found matches. (Left) Pairwise linear assignment, (right) Permutation Synchronization. Note that less visible green is better (right).</figDesc><graphic coords="7,307.99,334.24,194.05,79.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Fig 4 (top). We highlight two important observations. First, our method resolved geometrical ambiguities by enforcing mutual consistency efficiently. Second, Permutation Synchronization robustly handles occlusion: landmark points that are occluded in one image are seamlessly assigned to null nodes in the other (see the set of unassigned points in the rightmost image in Fig 4 (top)) thanks to evidence derived from the large number of additional images in the dataset. In contrast, pairwise matching struggles with occlusion in the presence of similar looking landmarks (and feature descriptors). For n = 25 and m = 16, the error from the baseline method (Pairwise Linear Assignment) was 0.74. Permutation Synchronization decreased this by 10% to 0.64. The Books dataset (Fig 4, bottom)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Normalized error as the degree of supervision varies. Baseline method PLA (red) and Permutation Synchronization (blue)</figDesc><graphic coords="8,365.38,216.26,156.79,117.59" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Fig 5 as supervision increases. Fig 6 demonstrates qualitative results by our method (right) and pairwise linear assignment (left).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>can be solved by just finding the m leading eigenvectors of T .</figDesc><table><row><cell>Algorithm 1 Permutation Synchronization</cell></row><row><cell>Input: the objective matrix T</cell></row><row><cell>Compute the n leading eigenvectors (v1, v2, . . . , vn) of T and set U = √ m [v1, v2, . . . , vn]</cell></row><row><cell>for i = 1 to m do</cell></row><row><cell>Pi1 = U (i-1)n+1:in, 1:n U ⊤ 1:n, 1:n</cell></row><row><cell>σi = arg max σ∈Sn ⟨Pi1, σ⟩ [Kuhn-Munkres]</cell></row><row><cell>end for</cell></row><row><cell>for each (i, j) do</cell></row><row><cell>τji = σjσ -1 i</cell></row><row><cell>end for</cell></row><row><cell>Output: the matrix (τji) m i,j=1 of globally consistent</cell></row><row><cell>matchings</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that we could equally well have matched the σi's to any other column of blocks, since they are only defined relative to an arbitrary reference permutation: if, for any fixed σ0, each σi is redefined as σiσ0, the predicted relative permutations τji = σjσ0(σiσ0) -1 = σjσ -1 i stay the same.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Amit Singer for invaluable comments and for drawing our attention to <ref type="bibr" target="#b17">[18]</ref>. This work was supported in part by NSF-1320344 and by funding from the University of Wisconsin Graduate School. Figure 6: A representative triplet from the "Touring bike" dataset. (Yellow circle) Interest points in each image. (Green lines) Ground truth matching for image pairs (left-center) and (center-right). (Red lines) Matches for the image pairs: (left) supervision=0.1, (right) supervision=0.5.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Assignment problems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Burkard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dell'amico</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Martello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hammer: hierarchical attribute matching mechanism for elastic registration</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Davatzikos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TMI</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<date type="published" when="2002">2002</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Discovering localized attributes for fine-grained recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Crandall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Grauman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Object recognition as many-to-many feature matching</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Demirci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shokoufandeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Keselman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bretzner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dickinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCV</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multi-view stereo for community photo collections</title>
		<author>
			<persName><forename type="first">M</forename><surname>Goesele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Snavely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Seitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Shape matching and object recognition using low distortion correspondences</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Exponential family graph matching and ranking</title>
		<author>
			<persName><forename type="first">J</forename><surname>Petterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Caetano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mcauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIPS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Building Rome in a day</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Furukawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Snavely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Curless</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Seitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scene summarization for online image collections</title>
		<author>
			<persName><forename type="first">I</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Snavely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Seitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Multiple alignment, communication cost, and graph matching</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Pevzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM JAM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Word alignment via quadratic assignment</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lacoste-Julien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Taskar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HLT -NAACL</title>
		<meeting>HLT -NAACL</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bundle methods for machine learning</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V N</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIPS</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Large margin methods for structured and interdependent output variables</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsochantaridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Altun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMLR</title>
		<imprint>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient sampling for bipartite matching problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Volkovs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zemel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Three-dimensional structure determination from common lines in cryo-EM by eigenvectors and semidefinite programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shkolnisky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Imaging Sciences</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="543" to="572" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Representation theoretic patterns in three dimensional cryo-electron microscopy I -the intrinsic reconstitution algorithm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hadani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">174</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1219" to="1241" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Representation theoretic patterns in three-dimensional cryo-electron microscopy II -the class averaging problem</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hadani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Computational Mathematics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="589" to="616" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Consistent shape maps via semidefinite programming</title>
		<author>
			<persName><forename type="first">Qi-Xing</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonidas</forename><surname>Guibas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="177" to="186" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Hungarian method for the assignment problem</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Naval Research Logistics Quarterly</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1955">1955</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the distribution of the roots of certain symmetric matrices</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Wigner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<date type="published" when="1958">1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The eigenvalues of random symmetric matrices</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Füredi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Komlós</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The eigenvalues and eigenvectors of finite, low rank perturbations of large random matrices</title>
		<author>
			<persName><forename type="first">F</forename><surname>Benaych-Georges</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Nadakuditi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Mathematics</title>
		<imprint>
			<biblScope unit="volume">227</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="494" to="521" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Shape matching and object recognition using shape contexts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Belongie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Puzicha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PAMI</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="509" to="522" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Structure from motion for scenes with large duplicate structures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Szeliski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Steedly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Learning graph matching</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Caetano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Mcauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PAMI</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1048" to="1058" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An integer projected fixed point method for graph matching and map inference</title>
		<author>
			<persName><forename type="first">M</forename><surname>Leordeanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sukthankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Graph construction and b-matching for semi-supervised learning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jebara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A Cheeger inequality for the graph connection Laplacian</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Bandeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Spielman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Matrix Analysis and Applications</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1611" to="1630" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
