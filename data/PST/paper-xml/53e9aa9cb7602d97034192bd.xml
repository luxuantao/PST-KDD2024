<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hierarchical Policies for Software Defined Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Ferguson</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arjun</forename><surname>Guha</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chen</forename><surname>Liang</surname></persName>
							<email>chen_liang@cs.brown.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rodrigo</forename><surname>Fonseca</surname></persName>
							<email>rfonseca@cs.brown.edu</email>
							<affiliation key="aff3">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shriram</forename><surname>Krishnamurthi</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Brown University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Hierarchical Policies for Software Defined Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5B36CCF79DB722EFF4753C7874DD9EE9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.3 [Computer-Communication Networks]: Network Operations-network management</term>
					<term>C.2.4 [Computer-Communication Networks]: Distributed Systems-network operating systems</term>
					<term>C.2.1 [Computer-Communication Networks]: Network Architecture and Design Management, Design, Experimentation Software Defined Networks, OpenFlow, Participatory Networking, hierarchical policies</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Hierarchical policies are useful in many contexts in which resources are shared among multiple entities. Such policies can easily express the delegation of authority and the resolution of conflicts, which arise naturally when decision-making is decentralized. Conceptually, a hierarchical policy could be used to manage network resources, but commodity switches, which match packets using flow tables, do not realize hierarchies directly.</p><p>This paper presents Hierarchical Flow Tables (HFT), a framework for specifying and realizing hierarchical policies in software defined networks. HFT policies are organized as trees, where each component of the tree can independently determine the action to take on each packet. When independent parts of the tree arrive at conflicting decisions, HFT resolves conflicts with user-defined conflict-resolution operators, which exist at each node of the tree. We present a compiler that realizes HFT policies on a distributed network of OpenFlow switches, and prove its correctness using the Coq proof assistant. We then evaluate the use of HFT to improve performance of networked applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Hierarchies are useful in many contexts in which resources are shared and delegated among multiple entities. For example, Linux cgroups <ref type="bibr">[1]</ref> organize processes in trees to express and control the sharing of memory, CPU, and I/O bandwidth, and the Cinder operating system <ref type="bibr" target="#b12">[13]</ref> uses a hierarchy to control the sharing of battery resources among smartphone applications. In general, hierarchies are a common representation of delegation and accounting for shared resources.</p><p>This makes hierarchies a natural way to delegate management of network resources. For example, a network administrator may wish to delegate the authority to block external traffic to a security team. The team leader may wish to further delegate this authority to deputies, and if two deputies disagree on whether to block a particular flow, the leader may want a conservative conflict-resolution policy, such as "deny overrides allow." In a campus network, the network administrator may delegate authority for traffic engineering to several teams, such as media services for simulcasting, or scientists for bulk data transfers.</p><p>Existing systems, such as the previously mentioned cgroups and Cinder, can natively use a tree structure for accounting and delegation. Although software defined networks enable custom packethandling at each switch, we cannot install hierarchical policies directly on commodity hardware.</p><p>This paper presents the design, realization, and evaluation of hierarchical policies in software defined networks. We develop Hierarchical Flow Tables (HFT), which provide a semantics for policy trees -a representation of hierarchical policies designed for networks ( §2). We also develop a compiler and runtime system to realize policy trees on a network of OpenFlow switches <ref type="bibr" target="#b9">[10]</ref> by integrating information about the network topology ( §3).</p><p>Finally, HFT enables Participatory Networking <ref type="bibr" target="#b1">[2]</ref>, a framework in which end-users and their applications propose changes to the network configuration. With this, we evaluate the use of HFT to improve the performance of networked applications in our prototype participatory network ( §5). Existing systems <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b15">16]</ref>, which we compare in §6, do not support hierarchical network-wide policies such as ours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SEMANTICS OF HFT</head><p>HFT allows several principals to author a tree of policies, and specify custom conflict-resolution operators at each node in the tree. In this section, we define the semantics of a policy tree as the final action it produces on an individual packet, after it has consolidated actions from all policies in the tree. <ref type="foot" target="#foot_0">1</ref> In §3, we compile these policy trees to run efficiently on hardware.</p><p>Figure <ref type="figure">1</ref> defines packets (K), policy trees (T ), actions (A), and a function eval that matches packets against policy trees and returns an action. For our purposes, packets are a vector of header names H = header names and ingress ports patterns</p><formula xml:id="formula_0">V = const | prefix | matches M = ∅ | --→ H, V actions A = Allow | Deny | GMB(n) | 0 conflict-resolution (+) = A → A → A operators policy atoms P = M × A policy tree nodes D = (+D) × 2 P policy trees T = (+P ) × (+S) × D × 2 T packets K = -----→ H, const cmb : D × K → A cmb((+, {• • • (Mi, Ai) • • •}), K) = A 1 + • • • + A k + 0 where {A 1 , • • • , A k } = {Ai|Mi ∩ K = ∅} eval : T × K → A eval((+P , +S, D, {T1, • • • , Tn}), K) = cmb(D, K) +P A1 where A1 = eval(T1, K) +S A2 A2 = eval(T2, K) +S A3 • • • An = eval(Tn, K) +S 0 Figure 1: Semantics of HFT 2</formula><p>and values; we do not match on packets' contents. For concreteness, we depict the actions we have implemented in our prototype ( §3): admission control, guaranteed minimum bandwidth (GMB), and 0, a special "don't care" action. In §7, we outline how to support additional ones such as rate-limiting and waypointing. A policy tree is a tree of policy nodes (D), which contain sets of policy atoms (P ). An atom is a match rule and action pair, (M, A). When a packet matches a policy atom, M ∩ K = ∅, the atom produces its action. The interesting cases occur when a packet matches several policy atoms with conflicting actions. In these cases, we resolve conflicts with the conflict-resolution operators (+) attached throughout the policy tree.</p><p>Policy trees have different types of conflict-resolution operators at several points in the tree (i.e., +D, +P , +S in Figure <ref type="figure">1</ref>). These multiple types allow HFT to resolve different types of conflicts using independent logic. For example, conflicts between parent and child nodes may be resolved differently than conflicts between a single node's internal policy atoms. Therefore, the choice of conflictresolution operators is a key policy decision. Our prototype network ( §4) provides two default operators; developing and evaluating additional operators is left as future work.</p><p>The function cmb matches a packet with an individual policy tree node. If a packet matches several policy atoms, cmb uses the node's internal conflict-resolution operator, +D, to combine their actions. The compiler requires +D to be associative, commutative, and have 0 as its identity. 3  The function eval matches a packet with a policy tree by applying cmb to the policy tree node at the root, and recursively applying eval to its children. A policy tree has conflict-resolution operators +P and +S, which respectively allow it to resolve parent-child and inter-sibling conflicts differently. In particular, +P does not have to be commutative -it is always used with the parent's action on the 2 2 M ×A is the set of all subsets of pairs drawn from M and A. 3 That is, we require a + 0 = 0 + a = a.  Example: Figure <ref type="figure" target="#fig_1">2</ref> depicts a simple policy tree and illustrates how eval produces an action, given the tree and indicated packet. Each node contains its policy atoms, and atoms which match the packet are colored green. The eval function recursively produces an action from each sub-tree; these actions are the labels on each node's outgoing edge.</p><p>In this example, the policy atoms at each leaf match the packet and produce an action. Node 3 receives conflicting actions from its children, which it resolves with its inter-sibling conflict-resolution operator: GMB(10) +S Allow = GMB <ref type="bibr" target="#b9">(10)</ref>. Node 3 has no policy atoms itself, so it produces the 0 action. Since 0 is the identity of all conflict-resolution operators, 0 +P GMB(10) = GMB( <ref type="formula">10</ref>) is the resulting action from this sub-tree.</p><p>Finally, Node 1 computes the aggregate action of its children: GMB(30) +S GMB(10) = GMB(max(30, 10)). Since Node 1's policy atoms do not match the packet, the final action is 0 +P GMB(30) = GMB(30).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">COMPILING POLICIES</head><p>The preceding section assumes that a central function, eval , observes and directs all packets in the network. Although eval specifies the meaning of policy trees, this is not a practical implementation. We now describe how to compile HFT's policy trees to run on commodity switches, which support simpler, linear flow tables, to produce a practical implementation.</p><p>Our compiler works in two stages. First, we translate policy trees to network flow tables, which have a basic, linear matching semantics ( §3.1). Second, we use network flow tables to configure a distributed network of switches, translating high-level actions such as GMB(n) to low-level operations on switches ( §3.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Network Flow Tables</head><p>A network flow table (N ) is a sequence of paired match rules and actions. The scan function, defined in Figure <ref type="figure" target="#fig_2">3</ref>, matches packets against network flow tables and returns the action associated with the first matching rule. If no rules match the packet, then scan returns 0. <ref type="foot" target="#foot_1">4</ref>The matching semantics of network flow tables correspond to the matching semantics of switch flow tables exposed by Open-Flow. When a packet matches a switch flow table, only one rule's action applies. If a packet matches multiple rules, the switch selects the one with the highest priority. A rule's index in a network flow table corresponds to a switch flow table priority, with index 0 as the highest priority. Since all rules have distinct indices, a naive correspondence would give all rules distinct priorities. A more compact</p><formula xml:id="formula_1">Network Flow Tables N = ---→ M, A scan : N × K → A M1 ∩ K = ∅ • • • Mj-1 ∩ K = ∅ Mj ∩ K = ∅ scan( (M1, A1) • • • (Mn, An) , K) = Aj M1 ∩ K = ∅ • • • Mn ∩ K = ∅ scan( (M1, A1) • • • (Mn, An) , K) = 0 linD : D → N linD (+D, {M1, A1, • • • , Mj, Aj}) = N1</formula><p>where N1 = union(+D, M1, A1 , N2) The linT function is our compiler from policy trees to network flow tables. It uses linD as a helper to compile policy tree nodes. The linD function translates policy atoms to singleton network flow tables, and combines them with union(+, N , N ). Union builds a network flow table that matches packets in either N or N . Moreover, when a packet matches both N and N , union computes the intersection using the + conflict-resolution operator to combine actions.</p><formula xml:id="formula_2">• • • Nj = union(+D, Mj, Aj , ) linT : T → N linT (+P , +S, D, {T1 • • • T k }) = union(+P , linD(D), N1) where N1 = union(+S, linT (T1), N 2 ) • • • N k = union(+S, linT (T k ), ) union, inter : (+) × N × N → N union((+), N1, N2) = inter ((+), N1, N2)N1N2 inter ((+), • • • (Mi, Ai) • • • , • • • (M j , A j ) • • • ) = • • • (Mi ∩ M j , Ai + A j )) • • •</formula><p>Similarly, linT recursively builds network flow tables for its subtrees, and calls linD on its root node. It applies union to combine the results, using +S and +P where appropriate.</p><p>The functions in Figure <ref type="figure" target="#fig_2">3</ref>, linT , linD, union, and inter require the conflict-resolution operators to satisfy the following properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 1 (WELL-FORMED). T is well-formed if:</head><p>• The +D and +S operators are commutative,</p><p>• All conflict-resolution operators are associative, and • 0 is the identity of all conflict-resolution operators.</p><p>Proving the compiler correct requires the following key lemma, which states that all conflict-resolution operators distribute over scan.</p><p>LEMMA 1. For all +, N1, and N2, where 0 is the identity of +, scan(union(+, N1, N2)) = scan(N1) + scan(N2).</p><p>With this, we prove the compiler correct.  THEOREM 1 (SOUNDNESS). For all well-formed policy trees, T and packets, P , eval (T, P ) = scan(linT (T ), P ).</p><p>We mechanize all our definitions and proofs using the Coq proof assistant <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The HFT Runtime</head><p>The final step in realizing policy trees is to translate the highlevel actions in a network flow table to low-level operations on a network of switches. For example, a GMB(n) action needs to produce a circuit of switch queues and forwarding rules that direct packets to those queues. The HFT runtime uses a network information base (NIB) and a default forwarding algorithm to realize this and other actions.</p><p>A NIB is a database of network elements -hosts, switches, ports, queues, and links -and their capabilities (e.g., rate-limiters or perport output queues on a switch). The runtime uses the NIB to translate logical actions to a physical configuration. For example, to implement a bandwidth reservation, (M, GMB(n)), the runtime queries the NIB for the shortest path with available queues between the corresponding hosts. Along this path, the runtime creates queues which guarantee bandwidth n, and flow table rules to direct packets matching M to those queues. We also use the NIB to install Deny rules as close as possible to the traffic source. The HFT runtime currently implements a greedy algorithm for both of these operations. Evaluating the efficiency of this approach and considering alternatives remains as future work.</p><p>The NIB we implement is inspired by Onix <ref type="bibr" target="#b7">[8]</ref>. It uses a simple discovery protocol to find links between switches, and information from our forwarding algorithm to discover the locations of hosts. When possible, we use the slicing extension to OpenFlow 1.0 to create queues, and out-of-band commands when necessary. While OpenFlow allows us to set expiry timeouts on flow table entries, our controller must explicitly delete queues when reservations expire.</p><p>As the network flow table does not specify packet forwarding, the runtime integrates decisions made by a separate forwarding algorithm. Our implementation uses MAC learning as its forwarding algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">HFT IN PANE</head><p>HFT is the central component of PANE, our prototype implementation of Participatory Networking <ref type="bibr" target="#b1">[2]</ref>. Figure <ref type="figure" target="#fig_3">4</ref> illustrates PANE's components, with HFT's components shaded gray. PANE allows users to submit requests for network resources with a start and end time. The PANE controller first checks that requests are authorized using a static share tree, which states which users can issue which requests about which flows in the network. It then verifies if the request can be realized in the network, adding it to its policy tree. HFT's policy tree represents the accepted requests at a particular point in time. To check if an authorized request is realizable, PANE takes a snapshot of the policy tree with the potential request inserted at its start time. PANE then runs the HFT compiler on this policy tree to ensure that it will be realizable, that is, a valid network configuration can be built. If a valid configuration cannot be built -for example, if the NIB cannot find a circuit for a bandwidth reservation -PANE rejects the user's request.</p><formula xml:id="formula_3">+P : A × A → A AP +P 0 = AP 0 +P AC = AC Deny +P Allow = Allow Allow +P Allow = Allow AP +P Deny = Deny Deny +P GMB(n) = GMB(n) GMB(m) +P GMB(n) = GMB(max(m, n)) GMB(m) +P Allow = GMB(m) Allow +P GMB(m) = GMB(n) +S, +D : A × A → A A1 +S 0 = A1 0 +S A2 = A2 Deny +S A2 = Deny A1 +S Deny = Deny GMB(m) +S GMB(n) = GMB(max(m, n)) GMB(m) +S Allow = GMB(m) Allow +S GMB(m) = GMB(m) Allow +S Allow = Allow A1 +D A2 = A1 +S A2</formula><p>When requests start and expire, the PANE controller sends Open-Flow messages constructed by HFT's runtime to affected switches. As Reitblatt, et al. <ref type="bibr" target="#b11">[12]</ref> point out, it is a challenge to update switch configurations without introducing inconsistent, intermediate stages. Our implementation does not presently address this issue, but we anticipate confronting this problem in the future.</p><p>Figure <ref type="figure" target="#fig_4">5</ref> specifies PANE's conflict-resolution operators. The parentchild operator (+P ) specifies a "child overrides parent" policy for admission control. The +S and +D operators are identical, and specify a "Deny overrides Allow policy" between siblings. Our current implementation hard-codes these operators at all nodes, but we anticipate allowing principals to specify their own conflict-resolution operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>The true measure of the HFT runtime's success is its ability to successfully control traffic in an actual network. In particular, its control should reflect the integration of the NIB to provide virtual circuits with guaranteed minimum bandwidth, and optimize the placement of access control logic within the network. To capture this, we tested HFT as part of PANE, our prototype controller for a participatory network, and evaluated its performance in scenarios which exercised each benefit. In the first, a service reserved bandwidth to protect inter-process messaging, and in the second, an end-host used PANE to establish an in-network firewall to suppress a denial-of-service attack. The PANE testbed consists of software OpenFlow switches (both Open vSwitch and the reference user-mode switch) running on Linux Intel-compatible hardware and on the TP-Link WR-1043ND wireless router. Wired connections are 1 Gb/sec and wireless runs over 802.11n. Clients on the network include six dedicated Linux servers, plus fluctuating numbers of laptops and phones. The network also provides standard services such as DHCP, DNS, and NAT.</p><p>Members of our group have been using the testbed for more than four months to manage our traffic, and during this time, it has been our primary source of network connectivity. The testbed is compatible with unmodified consumer electronic devices, which can easily interact with a PANE controller running at a well-known location. <ref type="foot" target="#foot_2">5</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">ZooKeeper</head><p>ZooKeeper <ref type="bibr" target="#b5">[6]</ref> is a coordination service for distributed systems used by Twitter, Netflix, and Yahoo! among others, and is key component of HBase. Like other coordination services such as Paxos <ref type="bibr">[9]</ref>, ZooKeeper provides consistent, available, and shared state using a quorum of replicated servers (the ensemble). For resiliency in the face of network failures, ZooKeeper servers may be distributed throughout a datacenter, and thus quorum messages may be negatively affected by heavy traffic on shared links. Because ZooKeeper's role is to provide coordination for other services, such negative effects are undesirable.</p><p>To protect ZooKeeper's messages from heavy traffic on shared links, we modified ZooKeeper to make bandwidth reservations using PANE. Upon startup, each member of the ensemble made a reservation for 10 Mbps of guaranteed minimum bandwidth for messages with other ZooKeeper servers. Additionally, we modified our ZooKeeper client to make a similar reservation with each server it connected to.</p><p>We installed ZooKeeper on an ensemble of five servers, and developed a benchmarking client which we ran on a sixth. The client connected a thread to each server and maximized the throughput of synchronous ZooKeeper operations in our ensemble. At no time during these experiments were the CPUs of the client, switches, or servers fully loaded.</p><p>Figure <ref type="figure" target="#fig_5">6</ref> shows the latency of ZooKeeper CREATE requests during the experiment. In the "Pre" line, only ZooKeeper is running in the network and no reservations were made using PANE. In the "Post" line, we used iperf to generate bi-directional TCP flows over each of the six links directly connected to a host. This traffic totaled 3.3 Gbps, which we found to be the maximum Open vSwitch could sustain in our setup. As shown in the figure, this competing traffic dramatically reduced ZooKeeper's performance -average latency doubled from 24ms to 48ms (similar results were obtained with a non-OpenFlow switch). Finally, the "PANE" line shows ZooKeeper's return to high performance when it reserved bandwidth for its messages using PANE.</p><p>We found similar results for other ZooKeeper write operations such as deleting keys, writing to unique keys, and writing to the same key. Read operations do not require a quorum's participation, and are thus less affected by background traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Thwarting Denial-of-Service</head><p>PANE provides firewall capabilities to participants using HFT's Allow and Deny actions. Because these rules are placed directly in the network by HFT's runtime, rather than on the requesting edge host, PANE can drop malicious traffic as it enters the network. This behavior protects any innocent traffic which might have suffered due to sharing a network link with a denial-of-service (DoS) attack.</p><p>To demonstrate this benefit, we generated a UDP-based DoS attack within our testbed network. It was launched from a Linux server two switch-hops away from our wireless clients. Before the attack began, the clients were able to sustain a TCP transfer of 24 Mbps. During the attack, which was directed at one of the clients, the performance of this transfer dropped to 5 Mbps, rising only to 8 Mbps after the victim installed a local firewall rule. By using PANE to block the attack, the transfer's full bandwidth returned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>HFT gives policy writers a programming model in which a central controller sees all packets. This model is inspired by Frenetic <ref type="bibr" target="#b2">[3]</ref>, which uses NetCore <ref type="bibr" target="#b10">[11]</ref> as its language for expressing forwarding policies. In contrast to NetCore, HFT supports hierarchical policies, which naturally support distributed authorship. A key element of HFT is allowing overlapping and conflicting policies to co-exist in a policy tree, as it resolves conflicts with arbitrary, user-defined operators.</p><p>NetCore allows policy writers to match packets with arbitrary predicates; when predicates are not realizable on switches, packets are sent to the NetCore controller, which uses reactive specialization to install exact-match rules. In contrast, HFT's matching rules are simpler and realizable on OpenFlow switches, though we do not anticipate any problem supporting reactive specialization.</p><p>FML <ref type="bibr" target="#b4">[5]</ref> is a Datalog-inspired language for writing policies that also supports distributed authorship. In an FML policy, conflicts are resolved by a fixed scheme -deny overrides waypoints, and waypoints override allow. By contrast, HFT offers more flexibility, since each policy tree node can specify its own conflict resolution operator. For example, within a single HFT policy tree, one policy node may specify "allow overrides deny," while another specifies "deny overrides allow."</p><p>FML also allows policies to be prioritized in a linear sequence (a policy cascade), with higher-level policies overriding lower-level policies. HFT can express a prioritized sequence of policies, in addition to more general hierarchies. For example, PANE uses an inverted "child overrides parent" conflict-resolution scheme ( §4) by default, but the author of an individual policy node can adopt a more restrictive "parent overrides child" scheme. FML does not support both "child overrides parent" and "parent overrides child" schemes simultaneously.</p><p>Nettle <ref type="bibr" target="#b15">[16]</ref> is a platform for writing OpenFlow controllers in a functional reactive style. Our controller is built on Nettle, and allows policy authors to write higher-level policies than those Nettle supports natively.</p><p>FlowVisor <ref type="bibr" target="#b13">[14]</ref> slices a single network so that several OpenFlow controllers can independently control each slice. FlowVisor supports delegation -a controller can re-slice its slice of the network. Each of these controllers sends and receives primitive OpenFlow messages. In contrast, HFT allows policy authors to state highlevel, declarative policies that are agnostic to network topologies and capabilities. HFT also permits policies to overlap and resolves conflicts using high-level conflict-resolution operators.</p><p>Kim, et al. <ref type="bibr" target="#b6">[7]</ref> describe an OpenFlow controller which automatically configures QoS along flow paths using application-described requirements and a database of network state. HFT's runtime performs a similar function for the GMB action, but also supports additional actions.</p><p>TVA is a network architecture in which end-hosts authorize the receipt of packet flows via capabilities in order to prevent DoSattacks <ref type="bibr" target="#b16">[17]</ref>. HFT also supports this goal, but by allowing end-hosts to safely manage network policies for themselves, as we show in §5.2. The eXtensible Access Control Markup Language (XACML) provides four combiner functions to resolve conflicts between subpolicies <ref type="bibr" target="#b3">[4]</ref>. These functions are designed for access control decisions and assume an ordering over the subpolicies. By contrast, HFT supports user-supplied operators designed for several actions and considers all children equal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">FUTURE WORK</head><p>HFT is an extensible framework that can easily support additional actions beyond those described in Figure <ref type="figure">1</ref>. For example, we could extend actions as follows:</p><formula xml:id="formula_4">A = • • • | RateLimit(n) | Waypoint(S) | Avoid(S) S = switch ID</formula><p>A RateLimit(n) action would require the runtime to setup a ratelimiter on the switch closest to the source of traffic; our NIB can already determine the closest switch to implement Deny rules near the source. The Waypoint(S) and Deny(S), actions, which are inspired by FML <ref type="bibr" target="#b4">[5]</ref>, direct traffic to go through or avoid a particular switch; we could easily extend our NIB to find a path that must visit or avoid the given switch. We envision adding these and other high-level actions to HFT and compiling them to software defined networks with the HFT runtime.</p><p>The separation of policy trees from the underlying implementation presents them as an invariant which the runtime strives to maintain. As the network topology changes, the HFT runtime can adjust the policies' realization. For example, the addition of new switches may permit shorter paths. While we do not currently support such automatic reconfiguration in our prototype, we plan to do so in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>HFT enables hierarchical policies for software defined networks. These policies arise naturally when policy decisions are made by a decentralized group of authors, and can easily conflict with each other. Therefore, HFT's conflict-resolution operators, which authors can assign independently to each node, are a key part of an HFT policy.</p><p>HFT allows high-level, network-wide policies that do not require knowledge of the network topology. Its runtime uses a network information base (NIB), which provides topology information, such as shortest paths and nearest switches. This separation of high-level policies and topological details allows HFT to optimize the realization of its policies.</p><p>HFT makes Participatory Networking possible -end users and their applications can request high-level, abstract network resources, and rely on HFT to implement these requests. Our experiments show that HFT successfully compiles these requests to configurations which improve the performance of real applications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Evaluation of a single packet</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Network Flow Tables</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The PANE System</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: PANE's conflict-resolution operators</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Latency of ZooKeeper CREATE requests.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This semantic model, where the central controller conceptually sees all packets, is inspired by Frenetic<ref type="bibr" target="#b2">[3]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>The scan function is derived from NetCore<ref type="bibr" target="#b10">[11]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>The PANE controller could also be specified using a DHCP vendor-specific or site-specific option.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was partially supported by NSF grant 1012060. Andrew Ferguson is supported by an NDSEG fellowship.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Participatory Networking</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Place</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Hot-ICE &apos;12</title>
		<meeting>Hot-ICE &apos;12<address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Frenetic: A High-Level Language for OpenFlow Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Meola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PRESTO &apos;10</title>
		<meeting>PRESTO &apos;10<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">eXtensible Access Control Markup Language, version 1.1</title>
		<editor>S. Godik and T. M.</editor>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Practical Declarative Network Management</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Hinrichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WREN &apos;09</title>
		<meeting>WREN &apos;09<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ZooKeeper: Wait-free coordination for Internet-scale systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Konar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Junqueira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX ATC &apos;10</title>
		<meeting>USENIX ATC &apos;10<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automated and Scalable QoS Control for Network Convergence</title>
		<author>
			<persName><forename type="first">W</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tourrilhes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yalagandula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. INM/WREN &apos;10</title>
		<meeting>INM/WREN &apos;10<address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Onix: A Distributed Control Platform for Large-scale Production Networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Poutievski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI &apos;10</title>
		<meeting>OSDI &apos;10<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Part-Time Parliament</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998-05">May 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">OpenFlow: Enabling Innovation in Campus Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM CCR</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="69" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Compiler and Run-time System for Network Programming Languages</title>
		<author>
			<persName><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL &apos;12</title>
		<meeting>POPL &apos;12<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Consistent Updates for Software-Defined Networks: Change You Can Believe in!</title>
		<author>
			<persName><forename type="first">M</forename><surname>Reitblatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotNets &apos;11</title>
		<meeting>HotNets &apos;11<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Energy Management in Mobile Devices with the Cinder Operating System</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Rumble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stutsman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroSys &apos;11</title>
		<meeting>EuroSys &apos;11<address><addrLine>Salzburg, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Can the Production Network Be the Testbed?</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-K</forename><surname>Yap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Appenzeller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI &apos;10</title>
		<meeting>OSDI &apos;10<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://coq.inria.fr/" />
		<title level="m">The Coq Development Team. The Coq proof assistant reference manual -version 8.3</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Nettle: Taking the Sting Out of Programming Network Routers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PADL &apos;11</title>
		<meeting>PADL &apos;11<address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A DoS-limiting Network Architecture</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM &apos;05</title>
		<meeting>SIGCOMM &apos;05<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
