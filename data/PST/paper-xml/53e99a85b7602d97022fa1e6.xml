<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Clonal Selection Algorithms: A Comparative Case Study Using Effective Mutation Potentials</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Vincenzo</forename><surname>Cutello</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>V.le A. Doria 6</addrLine>
									<postCode>95125</postCode>
									<settlement>Catania</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Giuseppe</forename><surname>Narzisi</surname></persName>
							<email>narzisi@dmi.unict.it</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>V.le A. Doria 6</addrLine>
									<postCode>95125</postCode>
									<settlement>Catania</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Giuseppe</forename><surname>Nicosia</surname></persName>
							<email>nicosia@dmi.unict.it</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>V.le A. Doria 6</addrLine>
									<postCode>95125</postCode>
									<settlement>Catania</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mario</forename><surname>Pavone</surname></persName>
							<email>mpavone@dmi.unict.it</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>V.le A. Doria 6</addrLine>
									<postCode>95125</postCode>
									<settlement>Catania</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Clonal Selection Algorithms: A Comparative Case Study Using Effective Mutation Potentials</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EC264644DDC62589713F421104D61A08</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Clonal Selection Algorithms</term>
					<term>CLONALG</term>
					<term>opt-IA</term>
					<term>onecounting</term>
					<term>trap functions</term>
					<term>pattern recognition</term>
					<term>numerical optimization</term>
					<term>NP-complete problems</term>
					<term>2D HP Protein Structure Prediction</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a comparative study of two important Clonal Selection Algorithms (CSAs): CLONALG and opt-IA. To deeply understand the performance of both algorithms, we deal with four different classes of problems: toy problems (one-counting and trap functions), pattern recognition, numerical optimization problems and NP-complete problem (the 2D HP model for protein structure prediction problem). Two possible versions of CLONALG have been implemented and tested. The experimental results show a global better performance of opt-IA with respect to CLONALG. Considering the results obtained, we can claim that CSAs represent a new class of Evolutionary Algorithms for effectively performing searching, learning and optimization tasks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Clonal Selection Algorithms (CSAs) are a special class of Immune algorithms (IA) which are inspired by the Clonal Selection Principle <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref> of the human immune system to produce effective methods for search and optimization. In this research paper two well known CSAs are analyzed: CLONal selection ALGorithm (CLONALG) <ref type="bibr" target="#b3">[4]</ref> and optimization Immune Algorithm (opt-IA) <ref type="bibr" target="#b4">[5]</ref>, which both use a simplified model of the Clonal Selection Principle . To analyze experimentally the overall performance of those two algorithms, we will test them on a robust set of problems belonging to four different classes: toy problems, pattern recognition, numerical optimization problems and NP-complete problems. Both algorithms are population based. Each individual of the population is a candidate solution belonging to the fitness landscape of a given computational problem. Using the cloning operator, an immune algorithm produces individuals with higher affinities (higher fitness function values), by introducing blind perturbation (by means of a hypermutation operator) and selecting their improved mature progenies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">CLONALG</head><p>CLONALG is characterized by two populations: a population of antigens, Ag, and a population of antibodies, Ab (denoted with P (t) ). The individual antibody and antigen are represented by string attributes m = m L , . . . , m 1 , that is, a point in a L-dimensional shape space S, m ∈ S L .The Ab population is the set of current candidate solutions, and the Ag is the environment to be recognized. After a random initialization of the first population P (0) , the algorithm loops for a predefined maximum number of generations (N gen ). In the first step, it determines the fitness function values of all Abs with respect to the Ag (the given objective function). Next, cloning operator selects n Abs that will be cloned independently and proportionally to their antigenic affinities, generating the clone population P clo . Hence, the higher the fitness, the higher the number of clones generated for each of the n Abs. The hypermutation operator performs an affinity maturation process inversely proportional to the fitness values generating the matured clone population P hyp . After computing the antigenic affinity of the population P hyp , CLONALG creates randomly d new antibodies that will replace the d lowest fit Abs in the current population.</p><p>In this paper we use the CLONALG version for optimization tasks (except for pattern recognition where we will use the other version proposed in <ref type="bibr" target="#b3">[4]</ref>), varying the same parameters (N, n, β, d) plus ρ (not studied in <ref type="bibr" target="#b3">[4]</ref>) that controls the shape of the mutation rate with respect to the following two equations:</p><formula xml:id="formula_0">α = e (-ρ * f ) , α= 1 ρ e (-f )<label>(1)</label></formula><p>where α represents the mutation rate , and f is the fitness function value normalized in [0.1]. The number of mutations of a clone with fitness function value f is equal to L * α where L is the length of the clone receptor. The first potential mutation has been proposed in <ref type="bibr" target="#b3">[4]</ref>, the original mutation law used by CLONALG; while the second potential mutation has been introduced in <ref type="bibr" target="#b5">[6]</ref>. We will show how setting the mutation rates and the parameter ρ is crucial for the algorithm performance. In the optimization version of CLONALG the affinity proportionate cloning is not useful; we use the same law defined in <ref type="bibr" target="#b3">[4]</ref>:</p><formula xml:id="formula_1">N c = n i=1 round (β * N );</formula><p>where N c represents the total number of clones created at each generation, in this way, each antibody (or B cell) produces the same number of clones. Moreover, we assign N = n, so all Abs from the population will be selected for cloning in step 4 of the algorithm. For the pseudo-code of CLONALG see <ref type="bibr" target="#b3">[4]</ref>.</p><p>The experimental study was conducted using two versions of CLONALG, CLONALG 1 and CLONALG 2 , with different selection scheme in step 8 of the algorithm and using the two potential mutations above defined (equations 1):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">opt-IA</head><p>The opt-IA algorithm uses only two entities: antigens (Ag) and B cells (or Ab) like CLONALG. At each time step t, we have a population P (t) of size d. The initial population of candidate solutions, time t = 0, is generated randomly. The function Evaluate(P) computes the fitness function value of each B cell x ∈ P. The implemented IA uses three immune operators, cloning, hypermutation and aging. The cloning operator, simply, clones each B cell dup times producing an intermediate population P clo of size d × dup, where each cloned B cell has the same age of its parent.</p><p>The hypermutation operator acts on the B cell receptor of P clo . The number of mutations M is determined by mutation potential. We tested our IA using inversely proportional hypermutation operators, hypermacromutation operator, and combination of hypermutation operators and hypermacromutation. The two hypermutation operators and the Hypermacromutation perturb the receptors using different mutation potentials, depending upon a parameter c. In particular, the two implemented operators try to mutate each B cell receptor M times without using probability mutation p m , typically used in Genetic Algorithms.</p><p>In the Inversely Proportional Hypermutation the number of mutations is inversely proportional to the fitness value, that is it decrease as the fitness function of the current B cell increases. So at each time step t, the operator will perform at most</p><formula xml:id="formula_2">M i (f (x)) = ((1 -E * f (x) ) × (c × )) + (c × )) mutations</formula><p>, where E * is the optimum of the problem and l is the string length. In this case, M i (f (x)) has the shape of an hyperbola branch. In the Hypermacromutation the number of mutations is independent from the fitness function f and the parameter c. In this case, we choose at random two sites in the string, i and j such that (i + 1) ≤ j ≤ the operator mutates at most M m (x) = ji + 1 directions, in the range [i, j].</p><p>The aging operator eliminates old B cells in the populations P (t) , P (hyp) and/or P (macro) , to avoid premature convergence. The value τ B is the maximum number of generations B cells are allowed to remain in the population. When a B cell is τ B + 1 old it is erased from the current population, no matter what its fitness value is. We call this strategy, static pure aging. We can also define a stochastic aging where the elimination process is based on a stochastic law. The probability to remove a B cell is governed by exponential negative law with parameter τ B , using the function P die (τ B ) = (1e -ln(2)/τB ) <ref type="bibr" target="#b1">[2]</ref>. During the cloning expansion, a cloned B cell takes the age of its parent. After the hypermutation phase, a cloned B cell which successfully mutates, will be considered to have age equal to 0. Such a scheme intends to give an equal opportunity to each new B cell to effectively explore the landscape. The best B cells which"survived" the aging operator, are selected from the populations P (t) , P (hyp) and/or P (macro) , in such a way each B cell receptor is unique, i.e. each B cell receptor is different from all other receptors. In this way, we obtain the new population P (t+1)  if (H is TRUE) then 7.</p><p>P (hyp) := Hypermutation(P (clo) , c, ) 8.</p><p>Evaluate(P (hyp) ) 9.</p><p>if (M is TRUE) then 10.</p><p>P (macro) := Hypermacro(P clo ) 11.</p><p>Evaluate (P (macro) ) 12.</p><p>Aging(P (t) , P (hyp) , P (macro) , τB) 13.</p><p>P (t+1) := (µ + λ)-Selection(P (t) , P (hyp) , P (macro) ) 14.</p><p>t := t + 1 15.end while Fig. <ref type="figure">1</ref>. Pseudo-code of opt-IA tion is found, or a maximum number of fitness function evaluations (T max ) is reached. Figure <ref type="figure">1</ref> shows the pseudo-code of the proposed Immune Algorithm. The boolean variables H, M control, respectively, the hypermutation and the hypermacromutation operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Toy Problems</head><p>Toy problems play a central role in understanding the dynamics of algorithms <ref type="bibr" target="#b6">[7]</ref>. In fact, they can be used to show the main differences between different algorithms. In this section we test and study the dynamic of CLONALG and opt-IA for two classical toy problems: one-counting and trap functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">One-Counting Problem</head><p>The one-counting problem (or one-max problem), is simply defined as the problem of maximizing the number of 1 in a bit-string x of length : f (x) = i=1 x i , with x i ∈ {0, 1}. In this work we set = 100. The one-max problem is a classical test to assess if an evolutionary algorithm is able to reach an optimal solution starting from a randomly initialized population.</p><p>Experimental results. All the experimental results reported in this sections were averaged over 100 independent runs, and we fixed the max number of fitness function evaluations (T max ) to 10 4 . Figure <ref type="figure" target="#fig_0">2</ref> shows the Success Rate (SR) parameters surface for CLONALG 1 and CLONALG 2 varying β ∈ {0.1, 0.2, . . . , 1.0} and ρ ∈ {10.0, 20.0, . . . , 100.0} for the second type of mutation rate previously    defined: α = 1 ρ e (-f ) . From the plots it is clear that the parameter ρ plays an important role in reaching the optimum solution. For ρ &lt; 40.0, CLONALG (both versions) is unable to find the optimum (SR = 0). Instead, using the first type of mutation rate α = e (-ρ * f ) , CLONALG 1 and CLONALG 2 solve the one-counting problem for = 100 for each setting of the parameters ρ and β (the parameter surface are not shown), but the performance is different, as shown by the Average number Evaluation to Solution (AES) in figure <ref type="figure" target="#fig_2">3</ref>. For CLONALG 1 the only parameter that influences the behavior of the algorithms is β: if β increases, AES increases also. For CLONALG 2 instead both parameter are crucial. Figure <ref type="figure" target="#fig_0">2</ref> shows also the SR parameter surface for opt-IA varying dup ∈ {1, 2, . . . , 10} and τ B ∈ {1, 5, . . . , 25, 100, 200}. The behavior of the algorithm depends on both parameters dup and τ B , but it is not able to reach SR = 100. Figure <ref type="figure" target="#fig_3">4</ref> shows the population average fitness versus generation for CLONALG and opt-IA on the first 100 generations. For CLONALG we show both versions (CLONALG 1 and CLONALG 2 ) using the two possible mutation rates defined in section 1.1. The convergence speed of CLONALG is inferior respect to opt-IA but its SR is superior. In about 40 generations, opt-IA reaches a fitness value of 95 but from now on the aging process is more intensive refraining the convergence speed. For opt-IA we show versions with the usage of the static or stochastic aging coupled with an elitist or no-elitist strategy (i.e., the best candidate solution is always maintained from a generation to another). The better results are obtained using static aging. </p><formula xml:id="formula_3">(rate1: α = e (-ρ * f ) , rate2: α = 1 ρ e (-f ) )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Trap Functions</head><p>Trap functions <ref type="bibr" target="#b7">[8]</ref> [9], simply, take as input the number of 1's in a bit strings of length :</p><formula xml:id="formula_4">f (x) = f (u(x)) = f k=1 x k (2)</formula><p>We can define two different types of trap functions: simple trap function and complex trap function. Their definitions follow:</p><formula xml:id="formula_5">f (u) = a z (z-u), if u≤z b -z (u-z), otherwise. , f (u) = ⎧ ⎪ ⎨ ⎪ ⎩ a z 1 (z 1 -u), if u≤z 1 b -z 1 (u-z 1 ), if z 1 &lt;u≤z 2 b(z 2 -z 1 ) -z 1 1-1 -z 2 (u-z 2 )</formula><p>otherwise.</p><p>(</p><formula xml:id="formula_6">)<label>3</label></formula><p>The parameters a, b and z, will take on the values used in <ref type="bibr" target="#b7">[8]</ref>:</p><formula xml:id="formula_7">z ≈ (1/4) ; b = -z -1; 1.5b ≤ a ≤ 2b; a a multiple of z.</formula><p>The simple trap function is characterize by a global optimum (for a bit string of all 0's) and a local optimum (for a bit string of all 1's) that are the complement bit-wise of each other. The complex trap function is more difficult to investigate, in fact there are two directions to get trapped. We note that for z 2 = the complex trap function becomes the simple trap function. In this case the values of parameter Experimental results. All the experimental results reported in this sections have been averaged over 100 independent runs. Table <ref type="table" target="#tab_2">1</ref> shows the best results obtained   The results show clearly that, in terms of problem solving ability, facing toy problems is not an easy game. The cases III, IV and V for simple and complex trap functions remain no solved. Moreover, the better result are obtained using mutation rate (1/ρ) e (-f ) , respect to the ones-counting problem, where the better performance is obtained using e (-ρ * f ) .</p><formula xml:id="formula_8">S(III) 0 - 0 - 0 - 0 - 3 × 10 5 S(IV) 0 - 0 - 0 - 0 - 4 × 10 5 S(V) 0 - 0 - 0 - 0 - 5 ×</formula><formula xml:id="formula_9">C(II) 0 - 0 - 0 - 0 - 3 × 10 5 C(IV) 0 - 0 - 0 - 0 - 4 × 10 5 C(V) 0 - 0 - 0 - 0 - 5 × 10 5</formula><p>Table <ref type="table" target="#tab_4">2</ref> shows results obtained with opt-IA using a population size d = 10, a minimal duplication parameter dup = 1, and varying the parameter c ∈ {0.1, . . . , 1.0} and τ B ∈ {1, . . . , <ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr">50,</ref><ref type="bibr">100,</ref><ref type="bibr">200</ref>, ∞}. If we compare the results of opt-IA using only the inversely proportional hypermutation operator with the results obtained by CLONALG for population size of 10 Ab's we note how CLONALG outperforms opt-IA. Using the hypermacromutation operator, opt-IA obtains SR &gt; 0 for all cases of the simple and complex trap function. Finally, the usage of coupled operators (Inv+Macro) is the key feature to effectively face the trap functions as shown in the third column of table 2. The results obtained with this setting are comparable with the results in <ref type="bibr" target="#b7">[8]</ref>, where the authors, in their theoretical and experimental research work, use only cases C(I), C(II) and C(III) for the complex trap function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Pattern Recognition</head><p>In this section we consider the simple pattern recognition task to learn ten binary characters. Each character is represented as a bitstring of length L = 120 corresponding to a resolution of 12 × 10 bits for each picture. The original characters are depicted on figure <ref type="figure">6</ref>, those characters are the same used in <ref type="bibr" target="#b3">[4]</ref>. The fitness measure is the standard Hamming distance for bit strings.</p><p>Experimental results. Figure <ref type="figure">5</ref> shows the opt-IA dynamic for each input pattern to be learned. The algorithm is able to recognize all the characters in only 90 generations. This is not true for CLONALG, the overall convergence happens after 250 generations. This is visible in figure <ref type="figure">6</ref>, where the representations of the antibodies after 200 generations of the algorithms contain a bit of noise. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Numerical Optimization</head><p>Numerical optimization problems are fundamental for every field of engineering, science, and business. The task is that of global optimization of a generic objective function. However, often, the objective function is difficult to optimize because the function possesses numerous local optima which could trap the algorithm. Moreover this difficulty increases with the increase of the problem dimension. In this paper we consider the following numerical minimization problem:</p><formula xml:id="formula_10">min(f (x)), L≤ x ≤ U (4)</formula><p>where x = (x 1 , x 2 , . . . , x n ) is the variable vector in R n , f (x) denotes the objective function to minimize and L = (l 1 , l 2 , . . . , l n ), U = (u 1 , u 2 , . . . , u n ) represent, respectively, the lower and the upper bound of the variables, such that</p><formula xml:id="formula_11">x i ∈ [l i , u i ].</formula><p>Test Functions. Twentythree functions from three categories are selected <ref type="bibr" target="#b9">[10]</ref>, covering a broader range. Table <ref type="table">3</ref> lists the 23 functions and their key properties (for a complete description of all the functions and the parameters involved see <ref type="bibr" target="#b9">[10]</ref>). These function can be divided into three categories of different complexities:</p><p>unimodal functions (f 1f 7 ), which are relatively easy to optimize, but the difficulty increases as the problem dimension increases; -multimodal functions (f 8f 13 ), with many local minima, they represent the most difficult class of problems for many optimization algorithms; -multimodal functions which contain only a few local optima (f 14f 23 ). Some functions possess unique features: f 6 is a discontinuous step function having a single optimum; f 7 is a noisy quartic function involving a uniformly distributed random variable within [0, 1]. Optimizing unimodal functions is not a major issue, so in this case the convergence rate is of main interest. However, for multimodal functions the quality of the final results is more important since it reflects the algorithm's ability in escaping from local optima.</p><p>We used binary string representation: each real value x i is coded using bitstrings of length L = 22 corresponding to a precision of six decimal places.</p><p>Experimental results. In table <ref type="table" target="#tab_5">4</ref> we report results obtained with CLONALG and opt-IA with respect to one of the best evolutionary algorithms for numerical optimization in literature: Fast Evolutionary Programming (FEP) <ref type="bibr" target="#b9">[10]</ref>. FEP is based on Conventional Evolutionary Programming (CEP) but uses a new mutation operator based on Cauchy random numbers that helps the algorithm to escape from local optima. In the experiments of this section, opt-IA uses the same mutation potentials above defined for CLONALG (equation 1) for the inversely proportional hypermutation operator. Parameters for CLONALG and opt-IA are setted respectively as follow: N = n = 50, d = 0, β = 0.1 and d = 20, dup = 2, τ B = 20. If we compare the two versions of CLONALG, we can see that for unimodal functions (f 1 -f 7 ) CLONALG 2 is in general more effective Table <ref type="table">3</ref>. The 23 benchmark functions used in our experimental study; n is the dimension of the function; fmin is the minimum value of the function; S ⊆ R n are the variable bounds (for a complete description of all the functions and the parameters involved see <ref type="bibr" target="#b9">[10]</ref>)</p><formula xml:id="formula_12">Test function n S fmin f1(x) = n i=1 x 2 i 30 [-100, 100] n 0 f2(x) = n i=1 |xi| + n i=1 |xi| 30 [-10, 10] n 0 f3(x) = n i=1 i j=1 xj 2 30 [-100, 100] n 0 f4(x) = maxi{|xi|, 1 ≤ i ≤ n} 30 [-100, 100] n 0 f5(x) = n-1 i=1 [100(xi+1 -x 2 i ) 2 + (xi -1) 2 ] 30 [-30, 30] n 0 f6(x) = n i=1 ( xi + 0.5 ) 2 30 [-100, 100] n 0 f7(x) = n i=1 ix 4 i + random[0, 1) 30 [-1.28, 1.28] n 0 f8(x) = n i=1 -xi sin( |xi|) 30 [-500, 500] n -12569.5 f9(x) = n i=1 [x 2</formula><p>i -10 cos(2πxi) + 10] 30 [-5.12, 5.12] n 0</p><formula xml:id="formula_13">f10(x) = -20 exp -0.2 1 n n i=1 x 2 i 30 [-32, 32] n 0 -exp 1 n n i=1 cos 2πxi + 20 + e f11(x) = 1 4000 n i=1 x 2 i -n i=1 cos x i √ i + 1 30 [-600, 600] n 0 f12(x) = π n {10 sin 2 (πy1) 30 [-50, 50] n 0 + n-1 i=1 (yi -1) 2 [1 + 10 sin 2 (πyi+1)] + (yn -1) 2 } + n i=1 u(xi, 10, 100, 4), yi = 1 + 1 4 (xi + 1) u(xi, a, k, m) = ⎧ ⎨ ⎩ k(xi -a) m , if xi &gt; a, 0, if -a ≤ xi ≤ a, k(-xi -a) m , if xi &lt; -a. f13(x) = 0.1{sin 2 (3πx1) 30 [-50, 50] n 0 + n-1 i=1 (xi -1) 2 [1 + sin 2 (3πxi+1)] +(xn -1)[1 + sin 2 (2πxn)]} + n i=1 u(xi, 5, 100, 4) f14(x) = 1 500 + 25 j=1 1 j+ 2 i=1 (x i -a ij ) 6 -1 2 [-65.536, 65.536] n 1 f15(x) = 11 i=1 ai - x i (b 2 i +b i x 2 ) b 2 i +b i x 3 +x 4 2 4 [-5, 5] n 0.0003075 f16(x) = 4x 2 1 -2.1x 4 1 + 1 3 x 6 1 + x1x2 -4x 2 2 + 4x 4 2 2 [-5, 5] n -1.0316285 f17(x) = x2 -5.1 4π 2 x 2 1 + 5 π x1 -6 2 2 [-5, 10] × [0, 15] 0.398 +10 1 -1 8π cos x1 + 10 f18(x) = [1 + (x1 + x2 + 1) 2 (19 -14x1 + 3x 2 1 -14x2 2 [-2, 2] n 3 +6x1x2 + 3x 2 2 )] × [30 + (2x1 -3x2) 2 (18 -32x1 +12x 2 1 + 48x2 -36x1x2 + 27x 2 2 )] f19(x) = -4 i=1 ci exp -4 j=1 aij (xj -pij ) 2 4 [0, 1] n -3.86 f20(x) = -4 i=1 ci exp -6 j=1 aij (xj -pij ) 2 6 [0, 1] n -3.32 f21(x) = -5 i=1 (x -ai)(x -ai) T + ci -1 4 [0, 10] n -10.1422 f22(x) = -7 i=1 (x -ai)(x -ai) T + ci -1 4 [0, 10] n -10.3909 f23(x) = -10 i=1 (x -ai)(x -ai) T + ci -1 4 [0, 10] n -10.53</formula><p>than CLONALG 1 . Otherwise, for multimodal functions (f 8f 23 ), CLONALG 1 has a better performance. This is in agreement with the type of selection scheme used by the two versions. Since CLONALG 1 at each generation replaces each Ab by the best individual of its set of β * N mutated clones, it is able to maintain more diversity in the population. On the other hand, CLONALG 2 focuses the search on the global optimum, with the consequence of a higher probability to be trapped in a local optimum.</p><p>Considering the two versions of opt-IA, the four versions of CLONALG, and the results obtained by FEP, opt-IA outperforms CLONALG and FEP on 11   </p><formula xml:id="formula_14">) (3.5 × 10 -2 ) (1.9 × 10 -2 ) (1.6 × 10 -3 ) (1.4 × 10 -3 ) (1 .6 × 10 -3 ) (1.3 × 10 -3 ) f 8 -12554.</formula><formula xml:id="formula_15">) (2.2 × 10 -1 ) (3.9 × 10 -1 ) (1.9 × 10 -1 ) (4.1 × 10 -1 ) (3.56 × 10 -1 ) (1 .8 × 10 -4 ) f 11 1.6 × 10 -2 3.6 × 10 -2 1 .7 × 10 -2 9.4 × 10 -2 4.6 × 10 -2 9.1 × 10 -2 3.8 × 10 -2 200.000 (2.2 × 10 -2 ) (3.5 × 10 -2 ) (1 .9 × 10 -2 ) (1.4 × 10 -1 ) (7.0 × 10 -2 ) (1.36 × 10 -1 ) (5.5 × 10 -2 ) f 12 9.2 ×</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Protein Structure Prediction: HP Model</head><p>The Protein Structure Prediction problem (PSP) is simply defined as the problem of finding the 3D conformation of a protein starting from the amino-acids composition. A simplified version of this problem was introduced by Dill in <ref type="bibr" target="#b10">[11]</ref> which is called the HP model. It models proteins as two-dimensional self-avoiding walk chains of monomers on the square lattice: two residues cannot occupy the same node of the lattice. Residues are classified into two major classes: H (hydrophobic) and the P (polar). In this model, each H-H topological contact, that is, each lattice nearest-neighbor H-H contact interaction, has energy value ≤ 0, while all other contact interaction types (H-P, P-P) have zero energy. In general, in the HP model the residues interactions can be defined as follows: e HH = -| | and e HP = e P H = e P P = δ. When = 1 and δ = 0 we have the typical interaction energy matrix for the standard HP model <ref type="bibr" target="#b10">[11]</ref>. The native conformation is the one that maximizes the number of contacts H-H, i.e. the one that minimizes the free energy function. Finding the global minimum of the free energy function for the protein folding problem in the 2D HP model is NP-hard <ref type="bibr" target="#b11">[12]</ref>. The input for the algorithms is a protein sequence of s ∈ {H, P } where represents the number of amino-acids. The candidate solution is a sequence of relative directions <ref type="bibr" target="#b12">[13]</ref> r ∈ {F, R, L} -1 , where each r i is a relative direction with respect to the previous direction (r i-1 ), with i = 2, . . . , -1 (i.e., there are -2 relative directions) and r 1 the non relative direction. We obtain an overall sequence r of length -1.   Experimental results. In this section we report the results obtained for both versions of CLONALG and opt-IA on 12 instances from the Tortilla 2D HP benchmarks 1 . Since opt-IA was well studied for the HP model <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>, first of all we made a parameter tuning process for CLONALG in order to choose between CLONALG 1 and CLONALG 2 the version with the best performance for PSP, and also in order to set the best values for parameters β and ρ. In particular, parameter surfaces were determined in order to predict the best delimited region   that maximizes SR values and minimize AES value. The maximum number of fitness function evaluation (T max ) allowed for this first set of experiments is 10 5 . The results are averaged on 100 independent runs. From figures 7 and 8 it is obvious that CLONALG 2 has a better behavior with respect to CLONALG 1 , the best SR found by CLONALG 2 is 85 using mutation rate α = e (-ρ * f ) , while the best SR found by CLONALG 1 is 18. The worse performance of CLOANLG 1 is consequence of the structure of the selection scheme for the creation of the new population of antibody, as explained in section 1.1. In fact, this version is more useful for multimodal optimization problems where is necessary to find the greatest number of peaks of a specific function (maximization), as shown in <ref type="bibr" target="#b3">[4]</ref> and as demonstrated from results on numerical optimization in section 4. Again, we want to put in evidence the crucial importance of selecting the better mutation rate for each problem, and the tuning of the parameter to which is correlated (ρ).</p><p>Tables <ref type="table" target="#tab_11">5</ref> and<ref type="table" target="#tab_12">6</ref> show the best results for CLONALG (both versions) and opt-IA on the 12 PSP instances setting T max = 10 7 . All the results have been averaged over 30 independent runs. For CLONALG the values of β and ρ have been chosen according to figures 7 and 8 when the best SR is found. The mutation rate α = e (-ρ * f ) was used, according to its better performance as shown previously. Best results for opt-IA are obtained using coupled operators, inversely proportional hypermutation and Hypermacromutation. As for the traps, this is again the key feature to effectively face the problem. Both algorithms use the same minimal population dimension (N = d = 10). For the simple sequences 1,2,3,9,11 and 12 the algorithms have a similar behavior, but when we consider more difficult instances, like sequences 4,5 and 6, the overall performance of opt-IA is evident. Both algorithms are unable to solve the hard sequences 7 and 8, but although they reach the same minimum values, opt-IA has lower mean and standard deviation, showing a more robust behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>In this experimental work we made a comparative study of two famous Clonal Selection Algorithms, CLONALG and opt-IA, on significant test bed: onescounting and trap functions (toy problems), pattern recognition, numerical optimization (23 functions) and 2D HP Protein Structure Prediction problem (NP-Complete problem). A robust test bed is important in order to analyze theoretically and experimentally the overall robustness of evolutionary algorithms, as reported in <ref type="bibr" target="#b15">[16]</ref>. Two possible versions of CLONALG have been implemented and tested, coupled with two possible mutation potential for the hypermutation operator. The experimental results show a deep influence of the mutation potential for each problem and the setting of the respective parameter. Parameter tuning was made for both algorithms, and an overall better performance of opt-IA was found on all problems tackled. In particular, simulation results on numerical optimization problems show how CSAs (in particular opt-IA) are effective methods also for numerical optimization problems, obtaining comparable results respect to one of the most effective method in literature, Fast Evolutionary Programming. Obviously, the presented clonal selection algorithms can be applied to any other combinatorial and numerical optimization problem using suitable representations and variable operators <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b1">2]</ref>. In last years there have been many applications of CSAs to search, learning and optimization problems <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref>. In particular, this new class of evolutionary algorithms seem to be effective to face protein structure prediction problem <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b21">22]</ref>. This article and all the above cited research works demonstrate that the clonal selection algorithms are mature and effective computational tools <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b22">23]</ref>.</p><p>The evolutionary computation scientific community has a new class, immune algorithms <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>, that along with genetic algorithms <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref>, evolution strategies <ref type="bibr" target="#b25">[26]</ref>, evolutionary programming <ref type="bibr" target="#b26">[27]</ref> and the genetic programming <ref type="bibr" target="#b27">[28]</ref> constitutes the overall set of evolutionary algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. SR as a function of the values β and ρ using mutation rate α = 1 ρ e (-f ) for CLONALG1 (left plot) and CLONALG2 (center plot). SR as a function of the values dup and τB for opt-IA (right plot).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. AES as a function of the values β and ρ using mutation rate α = e (-ρ * f ) for CLONALG1 (left plot) and CLONALG2 (right plot)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Population average fitness for CLONALG (left plot) and opt-IA (right plot)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>z 2</head><label>2</label><figDesc>are determined by the following equation z 2 = -z 1 . Next section tables show the experimental results. Trap functions are labeled either S(type) or C(type), where S and C mean respectively Simple and Complex trap function. type varies according to the used parameter values: type I ( = 10, z = 3, a = 12, b = 6), type II ( = 20, z = 5, a = 20, b = 14), type III ( = 50, z = 10, a = 80, b = 39), type IV ( = 75, z = 20, a = 80, b = 54), type V ( = 100, z = 25, a = 100, b = 74). For the complex trap function z 1 = z and z 2 =z 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. opt-IA dynamics for each pattern using d = 10, dup = 2 and τB = 5 (left plot). CLONALG population, clones and best Ab average fitness using mutation rate α = (1/ρ) e (-f ) on 100 independent runs using the same setting of the parameters in [4]: N = 10, n = 5, m = 8, β = 10, d = 0 (right plot). For both plots, fitness values in axis y are normalized in [0, 1] and axis x is in log scale.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. CLONALG1: SR as a function of the values β and ρ for mutation rate α = e (-ρ * f ) (left plot) and mutation rate α = 1 ρ e (-f ) (right plot) on seq2 instance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. CLONALG2: SR as a function of the values β and ρ for mutation rate α = e (-ρ * f ) (left plot) and mutation rate α = 1 ρ e (-f ) (right plot) on seq2 instance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, of d B cells, for the next generation t + 1. If only d &lt; d B cells survived, the (µ + λ)-Selection operator creates dd new B cells (Birth phase). The boolean function Termination Condition() returns true if a solu-</figDesc><table><row><cell cols="2">opt-IA( , d, dup, τB, c, h, hm)</cell></row><row><cell cols="2">1. t := 0</cell></row><row><cell cols="2">2. P (t) := Initial Pop()</cell></row><row><cell cols="2">3. Evaluate(P (0) )</cell></row><row><cell cols="2">4. while (¬ Termination Condition())do</cell></row><row><cell>5.</cell><cell>P (clo) := Cloning (P (t) , dup)</cell></row><row><cell>6.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Best results obtained by CLONALG (both versions) with population size N = 10, varying β ∈ {0.1, 0.2, ..., 1.0}, ρ ∈ {1.0, 2.0, ..., 10.0} and d ∈ {1, 2, 3, 4, 5}</figDesc><table><row><cell></cell><cell>CLONALG1</cell><cell></cell><cell>CLONALG2</cell><cell></cell><cell></cell></row><row><cell>Trap</cell><cell>1 ρ e (-f )</cell><cell>e (-ρ * f )</cell><cell>1 ρ e (-f )</cell><cell>e (-ρ * f )</cell><cell>Tmax</cell></row><row><cell>SR</cell><cell>AES (β, ρ) SR</cell><cell>AES (β, ρ) SR</cell><cell>AES (β, ρ) SR</cell><cell>AES (β, ρ)</cell><cell></cell></row><row><cell cols="6">S(I) 100 1100.4 (.5,3) 100 479.7 (.8,2) 100 725.3 (.9,4) 100 539.2 (.7,2) 10 5</cell></row><row><cell cols="6">S(II) 100 27939.2 (.8,8) 100 174563.4 (.1,4) 30 173679.8 (.1,6) 31 172191.2 (.1,4) 2 × 10 5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>Best</figDesc><table><row><cell></cell><cell>Inv</cell><cell></cell><cell></cell><cell>Macro</cell><cell></cell><cell></cell><cell cols="2">Inv+Macro</cell><cell></cell></row><row><cell>Trap SR</cell><cell>AES</cell><cell cols="2">(τB, c) SR</cell><cell>AES</cell><cell cols="2">(dup, τB) SR</cell><cell>AES</cell><cell>(τB , c)</cell><cell>Tmax</cell></row><row><cell cols="4">S(I) 100 504.76 (5, 0.3) 100</cell><cell>1495.9</cell><cell cols="3">( 1 , 1) 100 477.04</cell><cell>(15, 0.2)</cell><cell>10 5</cell></row><row><cell cols="5">S(II) 97 58092.7 (20, 0.2) 28 64760.25</cell><cell cols="5">(1, 1) 100 35312.29 (100, 0.2) 2 × 10 5</cell></row><row><cell>S(III) 0</cell><cell>-</cell><cell>-</cell><cell cols="2">23 19346.09</cell><cell cols="5">(4, 13) 100 20045.81 (2 × 10 5 , 0.1) 3 × 10 5</cell></row><row><cell>S(IV) 0</cell><cell>-</cell><cell>-</cell><cell>28</cell><cell>69987</cell><cell cols="3">(10, 12) 100 42089</cell><cell>(25, 0.2)</cell><cell>4 × 10 5</cell></row><row><cell>S(V) 0</cell><cell>-</cell><cell>-</cell><cell cols="2">27 139824.41</cell><cell cols="3">(7, 1) 100 80789.94</cell><cell>(50, 0.2)</cell><cell>5 × 10 5</cell></row><row><cell cols="4">C(I) 100 371.15 (10, 0.2) 100</cell><cell>737.78</cell><cell cols="3">(5, 3) 100 388.42</cell><cell>(10, 0.2)</cell><cell>10 5</cell></row><row><cell cols="5">C(II) 100 44079.57 (10, 0.2) 100 27392.18</cell><cell>(5, 3)</cell><cell cols="2">100 29271.68</cell><cell>(5, 0.2)</cell><cell>2 × 10 5</cell></row><row><cell>C(III) 0</cell><cell>-</cell><cell>-</cell><cell cols="3">54 115908.61 (4, 7)</cell><cell cols="2">24 149006.5</cell><cell>(20, 0.1)</cell><cell>3 × 10 5</cell></row><row><cell>C(IV) 0</cell><cell>-</cell><cell>-</cell><cell cols="3">7 179593.29 (2, 9)</cell><cell>2</cell><cell>154925</cell><cell>(15, 0.4)</cell><cell>4 × 10 5</cell></row><row><cell>C(V) 0</cell><cell>-</cell><cell>-</cell><cell>2</cell><cell>353579</cell><cell>(1, 15)</cell><cell>0</cell><cell>-</cell><cell>-</cell><cell>5 × 10 5</cell></row></table><note><p><p>results obtained by opt-IA with population size d = 10, duplication parameter dup = 1, varying c ∈ {0.1, . . . , 1.0} and tauB ∈ {1, . . . , 15, 20, 25, 50, 100, 200, ∞}</p>by CLONALG (both versions) in terms of Success Rate (SR) and Average number of Evaluations to Solutions (AES), the population size has been set to the minimal value N = 10. The third column in table 1 reports the best parameter values that allowed the hypermutation operators to reach the best results. The last column of the tables reports the maximum number of evaluations allowed, T max , for each kind of trap function.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 .</head><label>4</label><figDesc>Comparison between FEP<ref type="bibr" target="#b9">[10]</ref>, CLONALG1, CLONALG2 and opt-IA on the 23 test functions. Results have been averaged over 50 independent runs, "mean best" indicates the mean best function values found in the last generation, "std dev" stands for standard deviation and Tmax is the maximum number of fitness function evaluation allowed. In boldface overall better results for each function, in italics the best results among CLONALG and opt-IA. × 10 -4 ) (1.6 × 10 -3 ) (2.6 × 10 -3 ) (1.5 × 10 -6 ) (2.4 × 10 -4 ) (2.6 × 10 -8 ) (1 .</figDesc><table><row><cell>Fun. Tmax</cell><cell>FEP[10]</cell><cell cols="2">CLONALG 1 e (-ρ * f ) , 1 ρ</cell><cell>e (-f ) ,</cell><cell cols="2">CLONALG 2 e (-ρ * f ) , 1 ρ</cell><cell>e (-f ) ,</cell><cell cols="2">opt-IA e (-ρ * f ) ,</cell><cell>1 ρ</cell><cell>e (-f )</cell></row><row><cell></cell><cell></cell><cell>ρ = 10</cell><cell cols="2">ρ = 150</cell><cell>ρ = 10</cell><cell cols="2">ρ = 150</cell><cell>ρ = 10</cell><cell>ρ = 150</cell></row><row><cell></cell><cell>mean best</cell><cell>mean best</cell><cell cols="2">mean best</cell><cell>mean best</cell><cell cols="2">mean best</cell><cell>mean best</cell><cell>mean best</cell></row><row><cell></cell><cell>(std dev)</cell><cell>(std dev)</cell><cell cols="2">(std dev)</cell><cell>(std dev)</cell><cell cols="2">(std dev)</cell><cell>(std dev)</cell><cell>(std dev)</cell></row><row><cell>f 1</cell><cell>5.7 × 10 -4</cell><cell>9.6 × 10 -4</cell><cell cols="2">3.7 × 10 -3</cell><cell>3.2 × 10 -6</cell><cell cols="2">5.5 × 10 -4</cell><cell>6.4 × 10 -8</cell><cell>3 .4 × 10 -8</cell></row><row><cell cols="2">150.000 (1.3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>3 × 10 -8 )</head><label></label><figDesc></figDesc><table><row><cell cols="8">8.1 × 10 -3 200.000 (7.7 × 10 -4 ) (2.5 × 10 -5 ) (6.6 × 10 -4 ) (2.1 × 10 -5 ) (7.1 × 10 -4 ) (4.5 × 10 -6 ) (3 .4 × 10 -6 ) 7.7 × 10 -5 2.9 × 10 -3 1.2 × 10 -4 2.7 × 10 -3 7.4 × 10 -5 7 .2 × 10 -5 f 2</cell></row><row><cell cols="3">1.6 × 10 -2 500.000 (1.4 × 10 -2 ) (1.3 × 10 -4 ) 2.2 × 10 4 f 3</cell><cell>1.5 × 10 4 (1.8 × 10 3 )</cell><cell>2.4 × 10 4 (5.7 × 10 3 )</cell><cell>5.9 × 10 3 (1.8 × 10 3 )</cell><cell>3.6 × 10 3 (1.1 × 10 3 )</cell><cell>2 .6 × 10 2 (6 .8 × 10 2 )</cell></row><row><cell>f 4 500.000</cell><cell>0.30 (0.50)</cell><cell>9.44 (1.98)</cell><cell>4.91 (1.11)</cell><cell cols="4">5 .9 × 10 -4 (3 .5 × 10 -4 ) (2.1 × 10 -3 ) (5.3 × 10 -3 ) (3.8 × 10 -3 ) 8.7 × 10 -3 1.0 × 10 -2 4.9 × 10 -3</cell></row><row><cell>f 5 2 × 10 6</cell><cell>5.06 (5.87)</cell><cell>31.07 (13.48)</cell><cell>27 .6 (1 .034 )</cell><cell>4.67 × 10 2 (6.3 × 10 2 )</cell><cell>2.35 × 10 2 (4.4 × 10 02 )</cell><cell>28.6 (0.12)</cell><cell>28.4 (0.42)</cell></row><row><cell>f 6 150.000</cell><cell>0.0 (0.0)</cell><cell>0.52 (0.49)</cell><cell>2.0 × 10 -2 (1.4 × 10 -1 )</cell><cell>0 .0 (0 .0 )</cell><cell>0 .0 (0 .0 )</cell><cell>0.2 (0.44)</cell><cell>0 .0 (0 .0 )</cell></row><row><cell cols="2">7.6 × 10 -3 300.000 (2.6 × 10 -3 f 7</cell><cell>1.3 × 10 -1</cell><cell>7.8 × 10 -2</cell><cell>4.6 × 10 -3</cell><cell>5.3 × 10 -3</cell><cell>3 .4 × 10 -3</cell><cell>3.9 × 10 -3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>By inspecting the entries on the table 4 in terms of results obtained by CSAs only, we note that, opt-IA outperforms CLONALG on 15 functions over 23 benchmark functions (execept for function 6 where both algorithms obtain the same statistical results), while CLONALG obtains the best results on 7 functions only (results reported in italic in table 4).</figDesc><table><row><cell></cell><cell>10 -6</cell><cell>0.632</cell><cell>0 .336</cell><cell>0.738</cell><cell>0.573</cell><cell>0.433</cell><cell>0.364</cell></row><row><cell cols="8">150.000 (3.6 × 10 -6 ) (2.2 × 10 -1 ) (9 .4 × 10 -2 ) (5.3 × 10 -1 ) (2.6 × 10 -1 ) (1.41 × 10 -1 ) (5.6 × 10 -2 )</cell></row><row><cell cols="8">1.6 × 10 -4 150.000 (7.3 × 10 -5 ) (2.7 × 10 -1 ) (1 .8 × 10 -1 ) (2.7 × 10 -1 ) (2.4 × 10 -1 ) (1.01 × 10 -1 ) (7.7 × 10 -2 ) 1.83 1 .39 1.84 1.69 1.51 1.75 f 13</cell></row><row><cell>f 14 10.000</cell><cell>1.22 (0.56)</cell><cell cols="2">1.0062 (4.0 × 10 -2 ) (2 .8 × 10 -2 ) 1 .0021</cell><cell>1.45 (0.95)</cell><cell>2.42 (2.60)</cell><cell>1.042 (0.11)</cell><cell>1.21 (0.54)</cell></row><row><cell cols="8">5.0 × 10 -4 400.000 (3.2 × 10 -4 ) (5.4 × 10 -4 ) (7.8 × 10 -4 ) (8.5 × 10 -3 ) (8.1 × 10 -3 ) (1 .3 × 10 -4 ) (1.4 × 10 -2 ) 1.4 × 10 -3 1.5 × 10 -3 8.3 × 10 -3 7.2 × 10 -3 7 .1 × 10 -4 7.7 × 10 -3 f 15</cell></row><row><cell>f 16</cell><cell>-1.03</cell><cell>-1 .0315</cell><cell>-1.0314</cell><cell>-1.0202</cell><cell>-1.0210</cell><cell>-1.0314</cell><cell>-1.027</cell></row><row><cell cols="7">10.000 (4.f 17 10.000 (1.4 ) 0.398 0.40061 0.399 0.462 0.422 0 .398</cell><cell>0.58 (0.44)</cell></row><row><cell>f 18 10.000</cell><cell>3.02 (0.11)</cell><cell cols="2">3.00 (1.3 × 10 -7 ) (1.3 × 10 -5 ) 3.00</cell><cell>3.54 (3.78)</cell><cell>3.46 (3.28)</cell><cell>3.0 (3.3 × 10 -8 )</cell><cell>3 .0 (0 .0 )</cell></row><row><cell>f 19</cell><cell>-3.86</cell><cell>-3.71</cell><cell>-3.71</cell><cell>-3.67</cell><cell>-3.68</cell><cell>-3.72</cell><cell>-3 .72</cell></row><row><cell>10.000 (1.f 20</cell><cell>-3.27</cell><cell>-3.30</cell><cell>-3.23</cell><cell>-3.21</cell><cell>-3.18</cell><cell>-3.31</cell><cell>-3 .31</cell></row><row><cell>20.000 (5.f 21 10.000</cell><cell>-5.52 (1.59)</cell><cell>-7.59 (1.89)</cell><cell>-5.92 (1.77)</cell><cell>-5.21 (1.78)</cell><cell>-3.98 (2.73)</cell><cell>-8 .29 (2 .25 )</cell><cell>-3.73 (0.26)</cell></row><row><cell>f 22 10.000</cell><cell>-5.52 (2.12)</cell><cell>-8.41 (1.40)</cell><cell>-5.90 (2.09)</cell><cell>-7.31 (2.67)</cell><cell>-4.66 (2.55)</cell><cell>-9 .59 (1 .72 )</cell><cell>-3.79 (0.25)</cell></row><row><cell>f 23 10.000</cell><cell>-6.57 (3.14)</cell><cell>-8.48 (1.51)</cell><cell>-5.98 (1.98)</cell><cell>-7.12 (2.48)</cell><cell>-4.38 (2.66)</cell><cell>-9 .96 (1 .46 )</cell><cell>-3.86 (0.19)</cell></row><row><cell cols="8">functions over 23, analogously to FEP, while CLONALG performs better only</cell></row><row><cell cols="5">in 3 functions (see boldface results in table 4).</cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p>9 × 10 -7 ) (1 .8 × 10 -4 ) (5.7 × 10 -4 ) (1.8 × 10 -2 ) (1.9 × 10 -2 ) (8.7 × 10 -4 ) (1.0 × 10 -2 ) 5 × 10 -7 ) (8.8 × 10 -3 ) (2.0 × 10 -3 ) (2.0 × 10 -1 ) (2.7 × 10 -2 ) (2 .0 × 10 -4 × 10 -5 ) (1.1 × 10 -2 ) (1.5 × 10 -2 ) (6.6 × 10 -2 ) (6.9 × 10 -2 ) (1.5 × 10 -4 ) (1 .4 × 10 -6 ) 9 × 10 -2 ) (1.0 × 10 -2 ) (5.9 × 10 -2 ) (8.6 × 10 -2 ) (1.</p>2 × 10 -1 ) (7.5 × 10 -3 ) (5 .9 × 10 -3 )</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 5 .</head><label>5</label><figDesc>opt-IA algorithm (d = 10, dup = 2). Results have been averaged on 30 independent runs, where b. f indicates the best values found, symbol µ stands for mean and symbol σ stands for standard deviation.</figDesc><table><row><cell></cell><cell>Protein</cell><cell></cell><cell></cell><cell cols="2">τB = 1</cell><cell></cell><cell></cell><cell></cell><cell cols="2">τB = 5</cell><cell></cell><cell></cell></row><row><cell>No.</cell><cell></cell><cell cols="2">E  *  SR</cell><cell>AES</cell><cell>b. f.</cell><cell>µ</cell><cell>σ</cell><cell>SR</cell><cell>AES</cell><cell>b. f.</cell><cell>µ</cell><cell>σ</cell></row><row><cell>1</cell><cell>2 0</cell><cell>-9</cell><cell>100</cell><cell>23710</cell><cell>-9</cell><cell>-9</cell><cell>0</cell><cell cols="2">100 20352.4</cell><cell>-9</cell><cell>-9</cell><cell>0</cell></row><row><cell>2</cell><cell>2 4</cell><cell>-9</cell><cell>100</cell><cell>69816.7</cell><cell>-9</cell><cell>-9</cell><cell>0</cell><cell cols="2">100 39959.9</cell><cell>-9</cell><cell>-9</cell><cell>0</cell></row><row><cell>3</cell><cell>2 5</cell><cell>-8</cell><cell cols="3">100 269513.9 -8</cell><cell>-8</cell><cell>0</cell><cell cols="2">100 282855.7</cell><cell>-8</cell><cell>-8</cell><cell>0</cell></row><row><cell>4</cell><cell>3 6</cell><cell cols="2">-1 4 100</cell><cell cols="9">2032504 -14 -13.93 0.25 73.33 4569496.3 -14 -13.73 0.44</cell></row><row><cell>5</cell><cell>4 8</cell><cell cols="11">-2 3 56.67 6403985.3 -23 -22.47 0.67 6.67 4343279 -23 -21.47 0.62</cell></row><row><cell>6</cell><cell>5 0</cell><cell cols="4">-2 1 100 778906.4 -21</cell><cell>-21</cell><cell>0</cell><cell cols="3">100 1135818.9 -21</cell><cell>-21</cell><cell>0</cell></row><row><cell>7</cell><cell>6 0</cell><cell>-3 6</cell><cell>0</cell><cell>//</cell><cell cols="3">-35 -33.73 0.68</cell><cell>0</cell><cell>/ /</cell><cell cols="3">-35 -34.5 0.5</cell></row><row><cell>8</cell><cell>6 4</cell><cell>-4 2</cell><cell>0</cell><cell>/ /</cell><cell cols="3">-39 -36.13 1.28</cell><cell>0</cell><cell>//</cell><cell cols="3">-38 -35.1 1.25</cell></row><row><cell>9</cell><cell>2 0</cell><cell cols="2">-1 0 100</cell><cell cols="2">18085.8 -10</cell><cell>-10</cell><cell>0</cell><cell>100</cell><cell>18473.6</cell><cell>-10</cell><cell>-10</cell><cell>0</cell></row><row><cell>10</cell><cell>18</cell><cell>-9</cell><cell>100</cell><cell>69210</cell><cell>-9</cell><cell>-9</cell><cell>0</cell><cell>100</cell><cell>130342</cell><cell>-9</cell><cell>-9</cell><cell>0</cell></row><row><cell>11</cell><cell>18</cell><cell>-8</cell><cell>100</cell><cell>41724.2</cell><cell>-8</cell><cell>-8</cell><cell>0</cell><cell>100</cell><cell>50151.2</cell><cell>-8</cell><cell>-8</cell><cell>0</cell></row><row><cell>12</cell><cell>18</cell><cell>-4</cell><cell>100</cell><cell>87494.5</cell><cell>-4</cell><cell>-4</cell><cell>0</cell><cell cols="2">100 74426.5</cell><cell>-4</cell><cell>-4</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 6 .</head><label>6</label><figDesc>CLONALG1 and CLOANLG2 using mutation rate α = e (-ρ * f ) (N = n = 10, d = 0). Results have been averaged on 30 independent runs, where b. f indicates the best values found, symbol µ stands for mean and symbol σ stands for standard deviation.</figDesc><table><row><cell></cell><cell>Protein</cell><cell></cell><cell cols="5">CLOANLG1(β = 0.4, ρ = 1.0)</cell><cell cols="5">CLOANLG2(β = 0.3, ρ = 5.0)</cell></row><row><cell>No.</cell><cell></cell><cell cols="2">E  *  SR</cell><cell>AES</cell><cell>b. f.</cell><cell>µ</cell><cell>σ</cell><cell>SR</cell><cell>AES</cell><cell>b. f.</cell><cell>µ</cell><cell>σ</cell></row><row><cell>1</cell><cell>2 0</cell><cell>-9</cell><cell>100</cell><cell>322563.50</cell><cell>-9</cell><cell>-9</cell><cell>0</cell><cell>100</cell><cell cols="2">22379.60 -9</cell><cell>-9</cell><cell>0</cell></row><row><cell>2</cell><cell>2 4</cell><cell>-9</cell><cell>90</cell><cell cols="2">2225404.75 -9</cell><cell>-8.9</cell><cell>0.3</cell><cell>100</cell><cell cols="2">69283.34 -9</cell><cell>-9</cell><cell>0</cell></row><row><cell>3</cell><cell>2 5</cell><cell cols="4">-8 96.67 1686092.38 -8</cell><cell cols="4">-7.96 0.17 100 907112.56</cell><cell>-8</cell><cell>-8</cell><cell>0</cell></row><row><cell>4</cell><cell>3 6</cell><cell>-1 4</cell><cell>0</cell><cell>//</cell><cell cols="8">-13 -12.23 0.46 23.33 5189238.50 -14 -13.2 0.47</cell></row><row><cell>5</cell><cell>4 8</cell><cell>-2 3</cell><cell>0</cell><cell>//</cell><cell cols="8">-21 -18.93 0.92 3.33 8101204.50 -23 -20.76 1.02</cell></row><row><cell>6</cell><cell>5 0</cell><cell>-2 1</cell><cell>0</cell><cell>//</cell><cell cols="8">-20 -17.43 0.95 46.67 6019418.50 -21 -20.2 0.87</cell></row><row><cell>7</cell><cell>6 0</cell><cell>-3 6</cell><cell>0</cell><cell>//</cell><cell cols="3">-34 -30.43 1.33</cell><cell>0</cell><cell>/ /</cell><cell cols="3">-35 -32.43 0.98</cell></row><row><cell>8</cell><cell>6 4</cell><cell>-4 2</cell><cell>0</cell><cell>//</cell><cell cols="3">-35 -29.26 1.74</cell><cell>0</cell><cell>/ /</cell><cell cols="3">-39 -33.43 2.21</cell></row><row><cell>9</cell><cell>2 0</cell><cell cols="2">-1 0 100</cell><cell cols="2">649403.00 -10</cell><cell>-10</cell><cell>0</cell><cell>100</cell><cell cols="2">27391.67 -10</cell><cell>-10</cell><cell>0</cell></row><row><cell>10</cell><cell>18</cell><cell cols="4">-9 96.67 2143456.50 -9</cell><cell cols="2">-8.96 0.18</cell><cell>90</cell><cell cols="2">1486671.25 -9</cell><cell>-8.9</cell><cell>0.3</cell></row><row><cell>11</cell><cell>18</cell><cell cols="3">-8 96.67 742352.56</cell><cell>-8</cell><cell cols="3">-7.96 0.18 100</cell><cell>52349.10</cell><cell>-8</cell><cell>-8</cell><cell>0</cell></row><row><cell>12</cell><cell>18</cell><cell>-4</cell><cell>100</cell><cell>740468.31</cell><cell>-4</cell><cell>-4</cell><cell>0</cell><cell>100</cell><cell cols="2">70247.73 -4</cell><cell>-4</cell><cell>0</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Burnet</surname></persName>
		</author>
		<title level="m">The Clonal Selection Theory of Acquired Immunity</title>
		<meeting><address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1959">1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Clonal Selection Principle for in silico and in vitro Computing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Developments in Biologically Inspired Computing</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>De Castro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Von Zuben</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Artificial Immune Systems: A New Computational Intelligence Paradigm</title>
		<author>
			<persName><forename type="first">De</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Timmis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>London, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Learning and optimization using the clonal selection principle</title>
		<author>
			<persName><forename type="first">De</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Von Zuben</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="239" to="251" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Exploring the capability of immune algorithms: A characterization of hypermutation operators</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pavone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Third Int. Conf. on Artificial Immune Systems (ICARIS&apos;04)</title>
		<meeting>of the Third Int. Conf. on Artificial Immune Systems (ICARIS&apos;04)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="263" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">An Artificial Immune Network for Multimodal Function Optimization&quot;, CEC&apos;02, Proceeding of IEEE Congress on Evolutionary Computation</title>
		<author>
			<persName><forename type="first">De</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Timmis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>IEEE Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modelling GA Dynamics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Prugel-Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Theoretical Aspects of Evolutionary Computing</title>
		<meeting>Theoretical Aspects of Evolutionary Computing</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="59" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An analysis of the Behavior of Simplified Evolutionary Algorithms on Trap Functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nijssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Back</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="11" to="22" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">How to Escape Traps using Clonal Selection Algorithms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pavone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Narzisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sorace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The First International Conference on Informatics in Control, Automation and Robotics</title>
		<imprint>
			<publisher>ICINCO) INSTICC Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="322" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Evolutionary programming made faster</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="82" to="102" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Theory for the folding and stability of globular proteins</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biochemistry</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1501" to="1509" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the complexity of protein folding</title>
		<author>
			<persName><forename type="first">P</forename><surname>Crescenzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Piccolboni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Comp. Bio</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="423" to="466" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Protein Structure Prediction with Evolutionary Algorithms</title>
		<author>
			<persName><forename type="first">N</forename><surname>Krasnogor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Hart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Pelta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;99</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1596" to="1601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Immune Algorithms with Aging operators for the String Folding Problem and the Protein Folding Problem</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pavone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Fifth Europ. Conf. on Comp. in Combinatorial Optimization (EVOCOP&apos;05)</title>
		<meeting>of the Fifth Europ. Conf. on Comp. in Combinatorial Optimization (EVOCOP&apos;05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3448</biblScope>
			<biblScope unit="page" from="80" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An Immune Algorithm with Hyper-Macromutations for the Dill&apos;s 2D Hydrophobic-Hydrophilic Model</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pavone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Congress on Evolutionary Computation, CEC 2004</title>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1074" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The Design of Innovation: Lessons from and for Competent Genetic Algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Goldberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Kluwer Academic Publisher</publisher>
			<biblScope unit="volume">7</biblScope>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An Immunological Approach to Combinatorial Optimization Problems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 8th Ibero-American Conf. on Artificial Intelligence (IBERAMIA&apos;02)</title>
		<meeting>of 8th Ibero-American Conf. on Artificial Intelligence (IBERAMIA&apos;02)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Hybrid Immune Algorithm with Information Gain for the Graph Coloring Problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pavone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Genetic and Evolutionary Computation Conference</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2723</biblScope>
			<biblScope unit="page" from="171" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Parameter-free, Adaptive Clonal Selection</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Garrett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Congress on Evolutionary Computing</title>
		<meeting><address><addrLine>Portland Oregon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-06">June (2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Artificial Immune Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Bentley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Timmis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International Conference</title>
		<meeting><address><addrLine>Catania, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-09-13">2004. September 13-16. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Immune Algorithms for Optimization and Protein Structure Prediction</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-12">December 2004</date>
			<pubPlace>Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Catania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PHD Thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Class of Pareto Archived Evolution Strategy Algorithms Using Immune Inspired Operators for Ab-Initio Protein Structure Prediction</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cutello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Narzisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nicosia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EvoWorkshops 2005</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3449</biblScope>
			<biblScope unit="page" from="54" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A Survey of Artificial Immune Systems: Are They Useful?</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Garrett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Genetic algorithms and the optimal allocation of trials</title>
		<author>
			<persName><forename type="first">J</forename><surname>Holland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="88" to="105" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Adaptation in Natural and Artificial Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>The University of Michigan Press</publisher>
			<pubPlace>Ann Arbor, Michigan</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<author>
			<persName><forename type="first">I</forename><surname>Rechenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Evolutions strategie: Optimierung Technischer Systeme nach Prinzipien der Biologischen Evolution</title>
		<meeting><address><addrLine>Stuttgart</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Artificial Intelligence Through Simulated Evolution</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Fogel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Walsh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1966">1966</date>
			<publisher>Wiley Publishing</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Evolving a computer program to generate random numbers using the genetic programming paradigm</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Fourth Int. Conf. on GA</title>
		<meeting>of the Fourth Int. Conf. on GA</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
