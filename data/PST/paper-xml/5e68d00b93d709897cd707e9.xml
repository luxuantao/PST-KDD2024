<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adaptive Resource Allocation in Future Wireless Networks with Blockchain and Mobile Edge Computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Fengxian</forename><surname>Guo</surname></persName>
							<email>fengxian-guo@bupt.edu.cn</email>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">F</forename><forename type="middle">Richard</forename><surname>Yu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Heli</forename><surname>Zhang</surname></persName>
							<email>zhangheli@bupt.edu.cn</email>
						</author>
						<author>
							<persName><forename type="first">Mengting</forename><surname>Liu</surname></persName>
							<email>liumengting@bupt.edu.cn</email>
						</author>
						<author>
							<persName><roleName>Fellow, IEEE</roleName><forename type="first">Victor</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
							<email>vleung@ieee.org</email>
						</author>
						<author>
							<persName><forename type="first">Hong</forename><forename type="middle">Ji</forename><surname>Guo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">H</forename><surname>Ji</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Ministry of Education</orgName>
								<orgName type="laboratory">are with the Key Laboratory of Universal Wireless Communications</orgName>
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department Systems and Computer Engi-neering</orgName>
								<orgName type="institution">Carleton University</orgName>
								<address>
									<postCode>K1S 5B6</postCode>
									<settlement>Ottawa</settlement>
									<region>ON</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Beijing Key Laboratory of Space-ground Interconnection and Convergence</orgName>
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Shenzhen University</orgName>
								<address>
									<postCode>518060</postCode>
									<settlement>Shenzhen</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Uni-versity of British Columbia</orgName>
								<address>
									<postCode>V6T 1Z4</postCode>
									<settlement>Vancouver</settlement>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adaptive Resource Allocation in Future Wireless Networks with Blockchain and Mobile Edge Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F092540D63BEC4EE8FE64FB92287CFB0</idno>
					<idno type="DOI">10.1109/TWC.2019.2956519</idno>
					<note type="submission">received January 06, 2019; revised April 06, 2019, July 13, 2019, and October 30, 2019; accepted November 12, 2019.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Mobile edge computing</term>
					<term>Computation offloading</term>
					<term>Blockchain</term>
					<term>Deep reinforcement learning</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we present a blockchain-based mobile edge computing (B-MEC) framework for adaptive resource allocation and computation offloading in future wireless networks, where the blockchain works as an overlaid system to provide management and control functions. In this framework, how to reach a consensus between the nodes while simultaneously guaranteeing the performance of both MEC and blockchain systems is a major challenge. Meanwhile, resource allocation, block size, and the number of consecutive blocks produced by each producer are critical to the performance of B-MEC. Therefore, an adaptive resource allocation and block generation scheme is proposed. To improve the throughput of the overlaid blockchain system and the quality of services (QoS) of the users in the underlaid MEC system, spectrum allocation, size of the blocks, and number of producing blocks for each producer are formulated as a joint optimization problem, where the time-varying wireless links and computation capacity of the MEC servers are considered. Since this problem is intractable using traditional methods, we resort to the deep reinforcement learning approach. Simulation results show the effectiveness of the proposed approach by comparing with other baseline methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The progressive miniaturization of hardware is enabling the massive deployment of smart mobile devices <ref type="bibr" target="#b0">[1]</ref>. Meanwhile, new applications are developing in the directions of Internet of things (IoT), Internet of vehicles (IoV), e-healthcare, tactile Internet and so on. However, the deployment of these applications is restricted by the energy, memory size, computation resources of mobile devices <ref type="bibr" target="#b1">[2]</ref>. These emerging applications with requirements in terms of intensive computational capacity and sensitive latency can rely on advanced improved wireless technologies and computation offloading. Future wireless networks are required to not only support massive wireless access but also offer the provisioning of computation offloading for mobile users.</p><p>To meet the demands of mobile users, future wireless networks will become more heterogeneous and dense. In the growth of more capable wireless networks, the scarcity of spectrum is always an impediment along the evolution of cellular networks from the first generation (1G) to the upcoming fifth generation (5G) <ref type="bibr" target="#b2">[3]</ref>. One reason is the binary quality of the current spectrum access approach, i.e., licensed and un-licensed, which is an intentional set of policy choices. To improve the spectrum efficiency, dynamic spectrum access becomes the norm. However, with an unprecedented level of network densification in the future, the spectrum management is of high complexity. Thus, smarter and more decentralized dynamic spectrum access techniques are preferred.</p><p>In future communication networks, the edge clouds will be deployed in the heterogeneous network and able to provide computation offloading services to users <ref type="bibr" target="#b3">[4]</ref>. One of the promising paradigms is mobile edge computing (MEC) <ref type="bibr" target="#b4">[5]</ref>. Many outstanding works have been done on computation offloading <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr" target="#b9">[10]</ref>, in which resource allocation, collaboration, offloading strategy and pricing algorithm are investigated.</p><p>However, some problems in this distributed and distrusted environment are failed to be considered. First, it is impractical to deploy or collaborate all the system resources, e.g., caching, computing, networking, due to the self-deployment nature and coexistence of multiple radio access service providers (SPs) and edge cloud vendors, which is precisely required by the logical system of traditional MEC. Second, there is no trusted entity in the system to audit the computation offloading process or ensure the proper and surefire payments to the SPs and edge cloud vendors. Third, privacy is often cited as one of the key concerns in cloud adoption, especially when sensitive or personal information is outsourced to the edge cloud vendors. Few cloud SPs can be fully trusted by endusers <ref type="bibr" target="#b10">[11]</ref>. Hence, new expectations are set for a decentralized, self-organized, trusted computation offloading system.</p><p>As the core technology behind Bitcoin and Ethereum, blockchain has ben gained popularity in academia and industry <ref type="bibr" target="#b11">[12]</ref>, which is a secured, shared and distributed ledger in essence. It allows two parties in a peer-to-peer network to communicate and exchange resources where the decisions are made distributedly by the majority rather than a single centralized one <ref type="bibr" target="#b12">[13]</ref>. Thanks to the decentralization and other inspiring features of blockchain, it is considered as a candidate technology to establish a secure and self-organized MEC ecosystem for future wireless networks.</p><p>To address these challenges, in this paper, we propose a novel blockchain-based MEC framework (B-MEC) for resource allocation in future wireless networks with MEC. A blockchain is a kind of distributed ledger without any centralized trusted auditors <ref type="bibr" target="#b13">[14]</ref>, which is public immutable and append-only <ref type="bibr" target="#b14">[15]</ref>. Attracted by the fantastic characteristics of blockchains in terms of decentralization, anonymity and trust, researchers have developed significant research interests in blockchains, e.g., resource allocation for <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, secure data storage and sharing in vehicular edge networks <ref type="bibr" target="#b17">[18]</ref>, security in IoT <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>, and electric vehicle networks <ref type="bibr" target="#b20">[21]</ref>. In this paper, we focus on the adaptive resource allocation issue in future wireless networks with blockchains and MEC. Our contributions are summarized as follows:</p><p>• We develop a B-MEC framework for adaptive resource allocation and computation offloading in future wireless networks, considering the issues arose from the property of heterogeneous wireless networks and MEC. This framework deploys a consensus protocol based on practical Byzantine fault tolerance (PBFT) and delegated proof of stake (DPoS). • The details and theoretical analysis of the consensus protocol are presented, where the computation task execution is self-organized by smart contracts. The performance of the blockchain system is given, i.e., throughput, time to finality, decentralization, and security. • By jointly considering the computation task execution in smart contracts and blockchain consensus maintenance, we formulate the spectrum allocation, block size, number of consecutive blocks produced by the block producers as an optimization problem, which is described as a markov decision process (MDP) by defining state space, action space, and reward function. The goal of the main problem is to optimize the performance of the joint MEC and blockchain system. • To handle the high dynamics of this system, we propose to solve this problem with a novel deep reinforcement learning (DRL) approach, with double-dueling deep Q network (DQN). Google TenserFlow is used to implement the double-dueling DQN. • Simulation results show the effectiveness of the proposed approach with various parameters by comparing with other baseline algorithms.</p><p>The rest of this paper is organized as follows. Section II describes the framework of future wireless networks with blockchains and MEC. Section III introduces the system model, followed by the consensus protocol in Section IV. The  performance of MEC and blockchain system is presented in Section V. In Section VI, the main problem is formulated. It is solved with a novel DRL approach in Section VII. Section VIII presents and discusses the simulation results. Finally, conclusion and future works are given in Section IX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. SYSTEM DESCRIPTION</head><p>In this section, we first describe the framework of future wireless networks with blockchains and MEC, in which some concepts are included. Then some challenges in this framework are discussed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Future Wireless Networks with Blockchain and MEC</head><p>As shown in Fig. <ref type="figure" target="#fig_0">1</ref>, there are three layers in this framework, i.e., users, edge networks (i.e., heterogeneous wireless networks with MEC), and blockchain. Before describing this framework, some concepts are illustrated as follows.</p><p>• Clients: mobile users in this system, which submit offloading requests to the B-MEC system. • Replicas or block producers: BSs with MEC servers, which are selected from the BSs and provide offloading services by using blockchain technology. • Primary node: the one selected from all replicas, which is authorized to produce blocks at a certain time period. • Backup nodes or validators: the block producers except the primary node, which play the role of validators. • Transactions: the offloading requests generated by the users, which are handled by the block producers. In this paper, the blockchain serves as an overlaid system to provide management and control functions to the underlaid MEC system. With the blockchain, data delivery and computation task execution are self-organized by smart contracts <ref type="bibr" target="#b21">[22]</ref>, which can provide an incentive to ensure the interests of different parties in a trust-less computing market. The transaction records the computation offloading requests from the mobile users. These transaction records are jointly approved by the consensus nodes selected from the blockchain nodes, and then digitally stored in all nodes' local blockchain replicas. Since the mobile devices usually have limited storage, the full ledger is stored only in the blockchain nodes, i.e., the edge servers in this paper. Fortunately, the blockchain provides publicly accessible records to the users about the transactions in this network, which are inevitably encrypted to provide privacy guarantee.</p><p>In this network, the offloading requests are listened by all the BSs. When it is its own turn to produce blocks, the primary node validates and processes the transactions with smart contracts. Then the computing results are sent back to the users and the transactions are packaged into a new block. After that, it comes to a consensus procedure, which will be described in details in section IV. After the consensus is reached among the nodes, the block is appended to the blockchain, which means the block reaches finality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Key Challenges of Computation Offloading in This Framework</head><p>Considering the time-varying of the wireless channels and spectrum efficiency, an adaptive spectrum allocation scheme is needed. Although the blockchain maintains non-repudiation and non-tampering properties, it is difficult to use it in wireless networks directly, since the currently employed blockchain technology doesn't take into the limitation of resources and the time-varying features of wireless networks into consideration. Hence, an adaptive consensus protocol is required for a wireless blockchain network. Furthermore, since the blockchain provides management and control functions to the MEC system, the performance of the blockchain is vital to ensure the quality of experience (QoE) of the mobile users. Hence, we need to guarantee the performance of the blockchain, i.e., throughput, decentralization, time to finality, and security, while concurrently ensuring the performance of MEC, e.g., quality of services (QoS) of the users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SYSTEM MODEL</head><p>In this section, we introduce the system model in this work. We first present the network model, then the communication model and computation model are introduced. In this paper, a discrete-time slotted system is applied, where time is partitioned into discrete time periods T = {1, ..., t, ..., T }, and each time period t has a constant duration Ṫ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Network Model</head><p>As seen in Fig. <ref type="figure" target="#fig_0">1</ref>, we assume that there are I BSs and N block producers in the heterogeneous wireless networks. Especially, the block producers are selected from the BSs, which are indexed by B = {B 1 , ..., B n , ..., B N }. Each of them is equipped with a MEC server, the computation capacity of which is denoted by F Bn (in Hz). Also, there are M users located around the BSs, each of which has a number of computational tasks (e.g., online games, navigation, VR, health monitor and so on) to be completed. The users are denoted by U = {U 1 , ..., U m , ..., U M }. To complete the tasks, the users are supposed to choose to offload the tasks to the BSs. In this paper, we don't consider the local execution on the mobile devices.</p><p>In the blockchain system, the consensus protocol adopts the idea of both DPoS and PBFT. As noted, the selection of block producers is important in DPoS, which has been well studied in existing works <ref type="bibr" target="#b22">[23]</ref>. Thus, we didn't consider it in this paper. PBFT provides safety and liveness while there are less than (N -1)/3 faulty nodes. In the B-MEC system, assume that the N block producers take turns to produce K blocks within interval Ṫ (in seconds), the size of which is S B (in bits). K varies across different time periods to account for the time-varying characteristics of wireless networks.</p><p>As noted, computation offloading in this system includes four phases, 1) submitting the offloading requests to the blockchain system, 2) executing smart contracts by the block producers, 3) sending back the results to the users, 4) reaching consensus among the block producers. As noted, it involves a communication model and a computation model, which will be presented next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Communication Model</head><p>In the B-MEC system, it involves two types of wireless links: 1) data transmission from the users to the BSs, 2) message delivery among the BSs.</p><p>To capture the characteristics of the time-varying wireless channels in this system, we resort to finite state Markov channel (FSMC) model. In this paper, we define the channel state according to the received signal-to-noise ratio (SNR). The amplitude of the SNR of the received signals are partitioned into L non-overlapping levels, and there are L+1 corresponding thresholds {h l , l = 0, 1, 2, ..., L}. Generally, h 0 and h L are known, which denote the minimum and maximum measured values of the SNR. The available state set of the finite markov chain is given by H = {H 1 , H 2 , ..., H l , ..., H L }. Let γ denote the channel state, the realization of which at time period t is denoted by Γ(t). In details, we have Γ(t) = H l , when there is γ ∈ {h l-1 , h l ).</p><p>We assume the channel is block-fading, where the received SNR is constant during one time period, but evolves between different time periods according to a set of Markov transition probabilities. Let p l,g = P r{Γ t+1 = H l |Γ t = H g } be the transition probability from state H g to H l , where l, g ∈ {1, ..., L}. Then the L × L transition probability matrix can be defined as P = [p l,g ] L×L .</p><p>Based on the presented FSMC model, let Γ Um,Bn be the SNR from user U m to BS B n , and Γ Bn,B n be the SNR from BS B n to BS B n .</p><p>Multicast OFDMA <ref type="bibr" target="#b23">[24]</ref> is considered in this paper, where a sub-channel is used by one transmitter to multicast the same message to several receivers. Assume that there exists E sub-channels with the same bandwidth W 0 over the whole spectrum bandwidth W , where there is E ≥ M +N . As noted, each user and BS have the chance to be a transmitter of one multicast group. Assume that the user U m is allocated with W Um sub-channels, and BS B n is assigned with W Bn subchannels. Due to the limited wireless spectrum, the following constraint should be met</p><formula xml:id="formula_0">Um∈U W Um W 0 + Bn∈B W W Bn W 0 ≤ W,<label>(1)</label></formula><p>which means the spectrum allocated to all users and BSs should not exceed the total bandwidth in this system. Hence, the received data rate of user U m at BS B n is</p><formula xml:id="formula_1">R Um,Bn = W Um W 0 log(1 + Γ Um,Bn ).<label>(2)</label></formula><p>The received data rate of BS B n to B n is expressed by</p><formula xml:id="formula_2">R Bn,B n = W Bn W 0 log(1 + Γ Bn,B n ).<label>(3)</label></formula><p>Since each BS receives the broadcasting messages from all the users and the other BSs, the backhaul data rate should not exceed the received data rate. Thus, we have</p><formula xml:id="formula_3">Um∈U R Um,Bn + n ∈B/{n} R B n ,Bn ≥ R Bn,B n .<label>(4)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Computation Model</head><p>In this system, the blocks are generated continuously without waiting for confirmation. This results in the fact that there may be several un-confirmed blocks existing in this system at the same time, on which it needs to be reached consensus. Hence, each BS needs to process different computation tasks from different blocks, i.e., executing smart contracts, generating and verifying the signatures, generating and verifying MACs. After one BS receives a message, it contains certain computation tasks. Assume that the computation task of message s is denoted by a 2-tuple I s = {d s , f s }, where d s denotes data size of the message s, while f s is the total CPU cycles to complete this task. Particularly, define s ∈ {p, v}, where p denotes producing while v denotes verifying.</p><p>Denote the computation capacity assigned to one message by F s (in Hz or CPU cycles per second). In this system, one BS may process different messages at the same time. For example, the primary node needs to produce blocks while verifying the other messages from the other BSs. It results in the fact that we don't exactly know the computational resources for each message at the next time instant. Hence, we model the evolution of F s as a finite state Markov process. The computation capacity is partitioned into Y nonoverlapping levels, which is expressed as</p><formula xml:id="formula_4">C = {C 1 , ..., C Y }. The realization of F s at time period t is Ψ s (t) = C y , when there is F s ∈ [c y-1 , c y ]. There are C y ∈ C and c 0 = 0 &lt; c 1 &lt; ... &lt; c Y = F max ,</formula><p>where F max denotes the maximum computation capacity of the processing BS.</p><p>For simplicity, we assume that the computation capacity allocated to message s is constant in one specific time period, but it evolves to the next state according to the transition probability. Let q x,y denote the probability that Ψ s (t) moves from state x to state y at time period t. The Y × Y state transition probability matrix is defined as Q = [q x,y ] Y ×Y , where we have q x,y = P r(Ψ s (t + 1) = y|Ψ s (t) = x) and x, y ∈ C.</p><p>Based on the above model, define the computation resources assigned from BS B n to message s is Ψ Bn,s (t). The execution time for completing task I s at BS B n can be calculated by</p><formula xml:id="formula_5">T Bn,s = f s Ψ Bn,s (t) .<label>(5)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. ADAPTIVE CONSENSUS PROTOCOL</head><p>In this section, we first present the adaptive consensus protocol proposed in this paper, which is based on PBFT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview of the Consensus Protocol</head><p>After the new block is generated, it is then broadcasted to the validators. When the validators verify the new block, the signatures of them are added to the block. After reaching consensus, the new block will be appended to the blockchain.</p><p>A signed block contains the block number, block size, block header, signed block summary and transactions. In the block header, it contains the version of the block, the hash of the previous block, a timestamp (i.e., the creation time of the new block), Markle root of all the transactions, and IDs of the validators. Signed block summary contains the summary of the transactions, e.g., the number of the included transactions, the structure of the transactions. Worth noting, it only contains the summary of the transactions, while the integral transactions are attached at the end of the block. The transactions mainly contain the transaction number, ID, scope, smart contract, signature and MAC. Here the smart contract is used to complete the computation tasks offloaded by the users, and the required transaction data represents what is required to complete the computation tasks, e.g., associated program codes or captured images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Theoretical Analysis</head><p>In the following, we give detailed steps and theoretical analysis of the consensus protocol. Compared with traditional systems without blockchain, this blockchain system also needs to validate the signatures and MACs except for executing the offloaded tasks, which can be treated as a computation overhead to execute the transactions. Since smart contracts are in charge of the execution of offloaded tasks, we assume that the computation of the offloaded tasks is included in the execution of smart contracts. It is assumed that executing the smart contract for one transaction, generating or verifying one signature, generating or verifying one MAC require α, β, and θ CPU cycles, respectively. Based on PBFT, the consensus protocol consists of five steps as the following.</p><p>1) Request: In one time period, the users submit offloading requests to the replicas, and the requests are as transactions stored in the pending pool. The primary node, which is one of the replicas, selects its' preferred transactions. For one transaction, the primary node will first verify its signature. If valid, it then verifies the transaction's MAC. If still valid, the primary node will execute smart contracts for this transaction. After verifying the preferred transactions, all transactions, computing results and other important information will be packaged into the new block. This procedure occurs within the block interval Ṫ /K.</p><p>Assume that the average size of one transaction is denoted by . In this phase, the transmission latency in this phase T tr req can be expressed by</p><formula xml:id="formula_6">T tr req = max Um∈U { R Um,Bp }.<label>(6)</label></formula><p>where R Um,Bp denotes the transmission rate from user U m to the primary node B p .</p><p>Considering the size of one block, the maximum number of transactions that can be included in a block is S B / . Uncivil execution is assumed that a g fraction of transactions submitted by the clients are correct <ref type="bibr" target="#b24">[25]</ref>. In this phase, the primary node needs to verify the signatures and MACs for S B /g transactions and it also needs to execute smart contracts for S B / transactions. Hence, the computation cost at the primary node is ∆ req,Bp = S B (β+θ) g + S B α . Thus, the computation delay is</p><formula xml:id="formula_7">T c req = ∆ req,Bp F Bp,p .<label>(7)</label></formula><p>As noted, there is no computation cost at the backup nodes.</p><p>2) Pre-prepare: After producing the new block, the primary node multicasts the signed block along with a pre-prepare message to all the backup nodes for validation, where the preprepare message contains the ID, signature of the primary node and hashed result of the new block. Since the smart contract is in charge of the execution of the offloaded computation tasks, the backup nodes need to make sure that the offloading tasks are actually executed by the primary node except for validating the identities and the economic parts. In this case, the intuitive method is to implement the smart contracts and compare the computation results.</p><p>Hence, after receiving the pre-prepare message and the new block, the backup nodes first verify the signature and MAC of the block, then the signatures and MACs of the transactions. Different from the work in <ref type="bibr" target="#b19">[20]</ref>, then smart contracts are executed by the backup nodes to validate the transactions. If the pre-prepare message is accepted by some backup node, it enters the next step.</p><p>In this phase, the transmission latency T tr prep can be calculated by</p><formula xml:id="formula_8">T tr prep = max Bn∈B/{Bp} { S B R Bp,Bn }. (<label>8</label></formula><formula xml:id="formula_9">)</formula><p>As noted, the primary node needs to generate one signature and N -1 MACs in this phase, which is given by ∆ prep,Bp = β + (N -1)θ. The computation cost at the backup nodes is ∆ prep,Bn = β + θ + S B (α + β + θ), where there is B n = B p . Hence, the computation latency in this phase is</p><formula xml:id="formula_10">T c prep = max Bn∈B { ∆ prep,Bn F Bn,v }.<label>(9)</label></formula><p>3) Prepare: After verifying the new block, each backup node sends a prepare message to all the other replicas, in which the replica ID and the signature are contained. Each replica will check the prepare message to make sure that it is consistent with the pre-prepare message. Once upon receipt 2f matching prepare messages from the other replicas, it enters the next step.</p><p>In this phase, the transmission cost is caused by sending the prepare message to all other replicas, which can be calculated by</p><formula xml:id="formula_11">T tr pre = max Bn,B n ∈B/{Bp},Bn =B n { S B R Bn,B n }.<label>(10)</label></formula><p>For the computation cost, the primary node needs to verify 2f signatures and MACs from the other replicas, which can be expressed by ∆ pre,Bp = 2f (β + θ). For the other backup nodes, each needs to generate a signature and N -1 MACs for the prepare message. Then 2f signatures and MACs are required to be validated. Hence, the computation cost at the backup nodes B n ( = B p ) can be given by ∆ pre,Bn = β + (N -1)θ + 2f (β + θ). Hence, the computation latency in this phase is</p><formula xml:id="formula_12">T c pre = max Bn∈B { ∆ pre,Bn F Bn,v }.<label>(11)</label></formula><p>4) Commit: Following receipt 2f matching prepare messages from the other replicas that are consistent with the preprepare message, each replica sends a commit message to all the others, which includes the ID and signature of the replica. Once upon receipt 2f matching commit messages, it enters the next step.</p><p>To deliver the commit messages, the transmission latency can be expressed by</p><formula xml:id="formula_13">T tr c = max Bn,B n ∈B,Bn =B n { S B R Bn,B n }.<label>(12)</label></formula><p>In this phase, each replica needs to generate 1 signature and N -1 MACs to form the commit messages. After receiving the commit messages, each replica needs to verify 2f signatures and MACs. Hence, the computation cost at each replica is ∆ c,Bn = β + (N -1)θ + 2f (β + θ). Hence, the computation latency in this phase is</p><formula xml:id="formula_14">T c c = max Bn∈B { ∆ c,Bn F Bn,v }.<label>(13)</label></formula><p>5) Reply: After collecting 2f matching commit messages, the new block becomes a valid one and it will be appended to the blockchain. A reply message will be delivered, in which the signature, ID, computation result for the offloading task are included. Different from the original BFT protocol <ref type="bibr" target="#b24">[25]</ref>, the reply message is delivered to the primary node, instead of the clients, due to the mobile devices' limited memory size.</p><p>In this phase, the transmission cost is</p><formula xml:id="formula_15">T tr r = max Bn∈B/{Bp} { S B R Bn,Bp }. (<label>14</label></formula><formula xml:id="formula_16">)</formula><p>For the computation cost, each backup node needs to generate S B / signatures, and S B / MACs for the primary node, which can be given by ∆ r,Bn = S B (β + θ). For the primary node, it needs to verify 2f signatures and MACs, the computation cost of which is given by ∆ r,Bp = 2f (β + θ). Hence, the computation latency in this phase is</p><formula xml:id="formula_17">T c r = max Bn∈B { ∆ r,Bn F Bn,v }.<label>(15)</label></formula><p>V. PERFORMANCE ANALYSIS</p><p>In this section, we give details of the performance of the MEC system and blockchain system. For the MEC system, the QoS of the users in terms of delay is given, which is the time from submitting the requests to receiving the results. In the blockchain system, the most important criterions to measure the system performance are throughput, time to finality, decentralization, and security. To address the four-way trade-off issue, the four properties will be presented in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Performance of MEC</head><p>To measure the QoS of the users, the delay experienced by the users is introduced, which consists of three parts, submitting the requests to the BS, executing the offloading tasks (executing smart contracts), sending back the results to the users. As analyzed in Section IV.B, the transmission latency T tr req to submitting the requests is as expression <ref type="bibr" target="#b5">(6)</ref>. As analyzed in Section IV.B, the primary node first verifies the signature and MAC of the requests, then executes the offloading requests. The computation cost for one offloading request is α + β + θ. The processing latency consists of two parts, queuing delay and executing delay. For each transaction, the executing delay is</p><formula xml:id="formula_18">T e = α + β + θ F Bp,p .<label>(16)</label></formula><p>Hence, the average queuing delay can be expressed by</p><formula xml:id="formula_19">T q = 1 2 ( S B -1)T e .<label>(17)</label></formula><p>In this work, we don't consider the sending back procedure as in <ref type="bibr" target="#b8">[9]</ref>, since the size of the output may be much smaller than the input data, which corresponds to many practical scenarios, such as virus detection, face recognition, and video analysis. Hence, the average delay experienced by the users are</p><formula xml:id="formula_20">T U = T tr req + T e + T q .<label>(18)</label></formula><p>B. Performance of the Blockchain System 1) Throughput: The throughput of the blockchain system can be measured by the number of transactions that can be processed successfully in unit time, which is related to two procedures, i.e., block generation, and consensus reaching. When producing a block, it is limited by the block size and the processing capacity of the primary node. Considering the block size, the transactions that can be included into the block per time is</p><formula xml:id="formula_21">Ξ(S B , K) = S B K Ṫ .<label>(19)</label></formula><p>The computation cost of producing one block is shown in Section IV.B. We assume that the computation resources of the primary node that are assigned to produce blocks is F p,p Hz. Considering the limited computation resources, the following constraint should be met</p><formula xml:id="formula_22">S B (β + θ)/g + α F p,p ≤ Ṫ K ,<label>(20)</label></formula><p>the left of which denotes the processing time to produce a block.</p><p>Since the primary node produces K blocks continuously, the last several blocks may be ignored due to the propagation delay to the next primary node. We assume the transmission data rate from the current primary node to the next one is R p,p+1 . Hence, the number of ignored blocks can be calculated by</p><formula xml:id="formula_23">IB(S B , K) = S B /R p,p+1 Ṫ /K -1 .<label>(21)</label></formula><p>As noted, there is IB ≤ K, which is apparent that the system won't missing more blocks than produced ones. The throughput of the consensus protocol can be expressed by</p><formula xml:id="formula_24">Υ(S B , K, W) = Ξ (K -IB) K = S B Ṫ (K - S B K R p,p Ṫ + 1),<label>(22)</label></formula><p>where W = {W Um , W B,n , U m ∈ U, B n ∈ B} denotes the spectrum allocation profile. Υ denotes the number of transactions that can be included into the blocks and transmitted to the next primary node successfully.</p><p>2) Time to Finality/Confirmation Latency: To guarantee the security of the transactions, it is essential to prevent the transactions to be arbitrarily changed or reversed. Time to finality is the time that the transactions can't be revoked once committed to the blockchain, which is important to some real-time applications. Longer delay frustrates users and makes applications built on a blockchain less competitive with existing non-blockchain alternatives.</p><p>Time to finality T f includes two parts, time for propagation T p and time for computation T c .</p><formula xml:id="formula_25">T f = T p + T c . (<label>23</label></formula><formula xml:id="formula_26">)</formula><p>Assume that each transmission procedure should be done within a timeout τ tr . As discussed in section IV.B, the propagation time can be calculated by </p><formula xml:id="formula_27">T p =</formula><p>In this consensus protocol, it involves five procedures. The computation cost and computation latency for each procedure are shown in section IV.B. We assume that each message should be processed within a timeout τ c . Thus, for computation latency T c , we have</p><formula xml:id="formula_29">T c = t c req + t c prep + t c pre + t c c + t c r = min{T c req , τ c } + min{T c prep , τ c } + min{T c pre , τ c } + min{T c c , τ c } + min{T c r , τ c }. (<label>25</label></formula><formula xml:id="formula_30">)</formula><p>3) Decentralization: To characterize the decentralization of the blockchain systems, we resort to Gini coefficient, which is often used as a gauge of economic inequality, measuring income distribution or wealth distribution among a population <ref type="bibr" target="#b25">[26]</ref>. The definition to measure inequality is based on Lorenz curve <ref type="bibr" target="#b26">[27]</ref>. Focusing on the decentralization of the block producers, we consider the number of blocks that each replica produces over time, the set of which is denoted by K = {K(1), K(2), ..., K(T )}. Hence, the Gini coefficient of the distribution among K is expressed by</p><formula xml:id="formula_31">G(K) = t∈T t ∈T |K(t) -K(t )| 2 t∈T t ∈B K(t) = t∈T t ∈T |K(t) -K(t )| 2N t∈T K(t) .<label>(26)</label></formula><p>Note that there is G(K) ∈ [0, 1]. The smaller the value of the Gini coefficient is, the more decentralized the blockchain system is. A Gini coefficient of zero expresses perfect equality, where all values in K are the same. It means every replica produces the same number of blocks in a round. A Gini coefficient of 1 expresses maximal inequality among values. For example, only one replica produces several blocks, but the other replicas don't have a chance or can't produce one block. In this case, the blockchain system becomes totally centralized, which violates the idea of the blockchain, a distributed ledger. To ensure the decentralization of the blockchain system, we have the following constraint</p><formula xml:id="formula_32">G(K) ≤ η,<label>(27)</label></formula><p>where η ∈ [0, 1] denotes the thresholds of decentralization in terms of K. 4) Security: To guarantee the security of the transactions, it is essential to prevent the transactions to be arbitrarily changed or reversed. As such, finality is vital when designing a blockchain consensus protocol. In PBFT-based consensus protocol, absolute finality can be provided when a 2/3 fraction of nodes are honest. So the number of loyal nodes is essential to guarantee the security of the consensus protocol. To guarantee the security of the system, the following constraint should be met</p><formula xml:id="formula_33">f ≤ N -1 3 .<label>(28)</label></formula><p>In another word, to prevent from revoking or modifying a transaction, the number of malicious nodes should not exceed (N -1)/3. In this paper, we don't consider the security problem of the consensus protocol. In another word, the above condition is assumed to be satisfied already.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. PROBLEM FORMULATION</head><p>In order to improve the throughput of this system, we need to jointly optimize spectrum allocation, block size, number of blocks produced by each replica. Since it is intractable to solve this problem with the traditional methods, we resort to DRL, which will be introduced in the next section. To implement the approach, we formulate the joint optimization problem as a MDP, where the state, action, and reward function are defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. State</head><p>Let S = {s(t), t ∈ T } be the system state space, where s(t) denotes the state at time period t. Here s t evolves across T . The network state consists of the SNR between the users and the BSs, SNR between different BSs, computing resources assigned by the BSs to different messages, primary node ID. Hence, the network state s(t) at time period t is expressed by </p><formula xml:id="formula_34">s(t) = {Γ U1 (t</formula><p>where there are Γ Um (t) = {Γ Um,Bn (t), B n ∈ B}, Γ Bn (t) = {Γ Bn,B n (t), B n ∈ B, B n = B n }, and Ψ Bn (t) = {Ψ Bn,s (t)}. In this paper, the primary node in each time period is known as a priori.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Action</head><p>In this paper, we focus on spectrum allocation, block size, number of successive blocks produced by one block producer. Let A = {A(t), t ∈ T } be the system action space. Here A(t) denotes the action at time period t, which can be expressed by </p><formula xml:id="formula_36">A(t) = {W U1 (t</formula><p>where the first two rows denote the spectrum allocation indicators for the users and BSs, respectively. Particularly, we have W Um ∈ {1, ..., E} and W Bn ∈ {1, ..., E}. Considering the limited wireless resources, the capacity constraint should be met, which is shown in expression <ref type="bibr" target="#b0">(1)</ref>. Here, S B (t) denotes the block size at time period t, and K(t) denotes the number of successive blocks at time period t. Especially, the replicas take turns to produce blocks, there is only one primary node in a certain time period. For the primary node B p (t) at time period t, it produces K(t) blocks. To simplify this problem, we discretize the action space, where S B and K are selected in the set S B and K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Reward Function</head><p>In this paper, we aim to maximize the performance of the joint MEC and blockchain system by making decisions on the action space. The reward function is designed to be max</p><formula xml:id="formula_38">S B ,K,W R(S B , K, W) s.t. C1 : T f k (t) ≤ T max , ∀k ∈ K(t) C2 : G(K) ≤ η C3 : Um∈U W Um + Bn∈B W W Bn ≤ E C4 : Um∈U R Um,Bn + n ∈B/{n} R B n ,Bn ≥ R Bn,B n (31)</formula><p>where R(S B , K, W) = T t =t t -t r(t) denotes the long term reward over the time periods T . Here ∈ [0, 1) is the discount rate, which indicates the weight of the future reward. For fixed t, the bigger is, the more influence the future reward r(t) has. As noted, with fixed , t -t approaches zero when t -t is large enough, which means that the future reward has less impact on the long term reward with the time going on.</p><p>In the proposed problem, T f k (t) in constraint C1 denotes the time to finality of the k-th block produced in time period t. Constraints C1 and C2 represents the limitations on time to finality, and decentralization, respectively. C3 denotes the allocated sub-channels should not exceed the total system wireless resources. C4 denotes the backhaul capacity constraint. As noted, constraints C1 ∼ C4 may not be met, which means the whole system may have a low system performance. Adopting the idea of penalty function, we define the immediate reward r(t) as</p><formula xml:id="formula_39">r(t) = ϑ B Υ(t) + ϑ M 1 T U , when C1 ∼ C4 is satisfied, 0, otherwise.<label>(32</label></formula><p>) where ϑ B and ϑ M ∈ [0, 1] are the weights corresponding to the blockchain system and MEC system. And there is ϑ B + ϑ M = 1. Note that the weights can be dynamic, which indicate the dynamic preference on these two systems. For ease of modeling, assume that the weights remain stationary within one time period, while can be changed over different periods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. PROPOSED LEARNING APPROACH</head><p>In this section, we first introduce necessary background related to DRL, then present the approach to solve the considered problem.</p><p>A. DRL Background 1) RL: RL is a branch of machine learning, in which the agent learns the optimal policy by interacting with an unknown environment to maximize the expected long term reward <ref type="bibr" target="#b27">[28]</ref>. A RL agent can be modeled as a MDP. The way that an agent acts in a MDP framework is as follows. Given the state s(t) ∈ S in environment X, the agent takes an action a(t) from the legal set A at each time step.</p><p>After taking the action from the given state, it enters the next state s(t + 1) according to the state transition probability P (s(t + 1)|s(t), a(t)). At the same time, it receives an instant reward r(t). In RL, the objective is defined as the expected long term reward, which is</p><formula xml:id="formula_40">R(t) = T t =t t -t r(t),<label>(33)</label></formula><p>where ∈ [0, 1] is the discount factor on the future rewards.</p><p>2) DRL: Recently, many researches have shown that deep learning can be combined with RL to solve problems with high dimensional raw data input, which is referred to DRL <ref type="bibr" target="#b28">[29]</ref>. In the training process of DRL, it utilizes a deep neural network (DNN) called DQN to derive the relationship between the action-state pair and the Q function Q(s, a; θ), in which θ represents the weights of the neural networks. DQN is trained by updating θ in each iteration to approximate the real Q values. This is achieved until two improved technique are applied in DQN, experience replay and the target network.</p><p>Furthermore, the main DQN is trained towards the target DQN by minimizing the loss function, which is defined as</p><formula xml:id="formula_41">Loss(θ(t)) = E[(y(t) -Q(s(t), a(t); θ(t)))],<label>(34)</label></formula><p>where y(t) is the target Q value, which can be estimated by</p><formula xml:id="formula_42">y(t) = r(t) + max a(t+1) Q(s(t + 1), a(t + 1); θ -(t + 1)). (<label>35</label></formula><formula xml:id="formula_43">)</formula><p>Here, the target DQN is updated every G steps, i.e., θ -(t) = θ t-G .</p><p>3) Beyond DRL: To improve the performance of DRL, two important techniques, double DQN, and dueling DQN, are applied in this work, which will be described next.</p><p>Double DQN: To handle the problem of overestimations of Q values, double DQN is proposed by Hado van Hasselt <ref type="bibr" target="#b29">[30]</ref>, the idea of which is to decompose the selection from the estimation for the actions. In mathematics, it can be expressed by y DoubleDQN = r + Q(s , argmaxQ(s , a; θ); θ -), <ref type="bibr" target="#b35">(36)</ref> which selects the actions according to online weights θ, while the estimation is based on the current values. This simple trick can help yield more accurate estimations, thus improving the performance of DRL.</p><p>Dueling DQN: Motivated by the fact that not every action affects the state when in some state, dueling DQN is proposed <ref type="bibr" target="#b30">[31]</ref>, the idea of which is to decompose the Q value into two parts, the value of being in that state V (s) and the advantage of taking that action at that state A(s, a). The idea can be expressed by</p><formula xml:id="formula_44">Q(s, a) = A(s, a) + V (s).<label>(37)</label></formula><p>In this case, dueling DQN can intuitively learn which state is more valuable without learning the effect of each action at that state. By doing so, it can help find more reliable Q values for each action and accelerate the training process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Proposed Algorithm</head><p>To solve the proposed problem, an offline DRL-based approach is proposed. In this approach, double-dueling DQN model is first trained to learn the optimal policies in an offline way. After the model is trained, it can be used by the B-MEC system to jointly allocate the wireless resources and decide the size of the blocks and the number of consecutive produced blocks for each replica in an online way. In this way, it avoids long training time compared to the online learning approach.</p><p>In each training step, the state information is sent to the Q network, and the Q network sends back the optimal action a * (t) at each time step. Action selection follows the ε-greedy policy. The transitions, i.e., experience, from all the trains are accumulated in the experience replay buffer in parallel. A mini-batch of samples are selected from the experience replay buffer to train the Q network parameter θ. The target Q network parameter θ -is updated every G steps, i.e., copying from the main Q network. The training process is shown in Algorithm 1, in which there are two points to be specified. First, the Q values are first divided into two parts, the value being in the state V (s) and the advantage of taking that action in that state A(s, a). In the last layer of DQN, combine these two parts into one Q value. Second, when updating the target Q network, a learning rate α is introduced, where α ∈ [0, 1] is the weight to adjust the preference on the current and previous learning values.</p><p>In each training step, the system state transits into a new state according to the system transition probability after an  randomly select an action a t = a * (t). Execute action a(t) in the system, and observe the reward r(t) and the next state s(t + 1).</p><formula xml:id="formula_45">a(t) = a * (t) = arg max a Q(x, a; θ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>17:</head><p>Store the experience (s(t), a(t), r(t), s(t + 1)) into the experience replay buffer. Calculate the target Q-value through expression (</p><p>Update the main DQN by minimizing the loss L(θ) expression <ref type="bibr" target="#b33">(34)</ref>, and perform a descent step on with respect to θ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>21:</head><p>Every G steps, update the target DQN parameters with learning rate α, θ -= αθ + (1 -α)θ -every G steps 22:</p><p>Update the learning rate according to the optimizer (e.g., Adam, Adagrad) 23:</p><p>end for 24: end for action is performed. And the reward can be observed based on the reward function. After the states, actions, the reward function, transition probabilities, and constraints of B-MEC system are identified, the optimal policy can be learned offline. In order to obtain the optimal solution, the states, actions, reward function, and constraints are identified in Section VI. As noted, the transition probabilities and reward need to be identified when conducting the simulation, while both of them are not needed when carrying out the Q networks in a real B-MEC system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Complexity Analysis</head><p>Next, we analyze the computational complexity and space complexity of the proposed DRL-based algorithm for practical scenarios where there are tens and even hundreds of users and BSs in a small area.</p><p>Theorems 1. In practical scenarios, the computational complexity of the proposed training DRL algorithm is</p><formula xml:id="formula_47">O(E (N +M ) ) or O(N + M ) (E-(N +M )) .</formula><p>Proof of Theorem 1. To prove the above theorem and thus analyze the complexity of the proposed algorithm, one must consider the size of the state function of the system as well as the action space at each state vector <ref type="bibr" target="#b31">[32]</ref>. As such, based on the action space definition, the system needs to update each user and BS's spectrum allocation indicator, the block size and number of blocks produced by each block producer, and, thus, its actions is also a function of channel association vector, block size level, and block number level.</p><p>For each state, the action of the system is a function of channel association vector, block size level, and block number level. Nevertheless, the number of possible channel association of the users and BSs in the system is much more than the number of possible block size level and block number level. Therefore, one can focus on the number of possible channel association of the users and BSs only for analyzing the convergence complexity of the proposed training algorithm, by the law of large numbers. Consequently, the computational complexity of the proposed algorithm is O(E (N +M ) ) when the system update the channel allocation indicator of the N block producers and M users with E sub-channels. In this paper, we assume that the number of sub-channels is more than the total number of users and BSs, i.e., E &gt; N + M . Thus, from another perspective, the computation complexity can be also expressed by O(N + M ) (E-(N +M )) . This completes the proof.</p><p>From Theorem 1, we can conclude that the convergence speed of the proposed training algorithm is strongly related to the state space dimension. It is of significant importance to note here that there exists a tradeoff between the computational complexity of the proposed DRL training algorithm and the resulting network performance <ref type="bibr" target="#b31">[32]</ref>. Worth noted, the complexity of the proposed algorithm can be ignored in this paper, due to the training process, which is the most costly, is conducted in an offline way.</p><p>Theorems 2. The space complexity of the proposed DRLbased algorithm is O(SAH max ), where S is the number of states, A is the number of actions, and H max is the number of steps in one episode.</p><p>Proof of Theorem 2. According to <ref type="bibr" target="#b32">[33]</ref>, space complexity is measured by the amount of memory required to implement the algorithm. Inferred from the work in <ref type="bibr" target="#b33">[34]</ref>, the space complexity is related to the number of states, the number of actions, and the number of steps per episode. In this paper, the number of states can be expressed by S = (N + M ) (E-(N +M )) × Y N × N . The number of actions can be calculated by A = (N + M ) × |S B | × |K|. In this paper, the number of maximum steps in each episode is H max , as defined in Algorithm 1.</p><p>In this case, the space complexity to implement the proposed algorithm can be expressed by</p><formula xml:id="formula_48">O(SAH max ) = O((N + M ) (E-(N +M )+1) × Y N × N × |S B | × |K| × H max ).</formula><p>This completes the proof. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. SIMULATION RESULTS AND DISCUSSION</head><p>In this section, we use computer simulation to demonstrate the effectiveness of the proposed scheme. First, the simulation settings are presented. Then it follows the simulation results with various parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Simulation Setting</head><p>We conduct our simulation on a GPU based server, which has four GTX 1080 TI NVIDIA GPUs, a 128G RAM, and an Intel Xeon CPU. The software environment is TensorFlow 1.8.0 with Python 3.6 on Ubuntu 18.04 LTS.</p><p>For the wireless network, there are 4 BSs, surrounded by 3 mobile users. Each BS is equipped with a MEC server. Since the block producer selection is not considered in this paper, all the BSs are assumed to be selected as block producers. The computation resources assigned to each message are from the set {200, 500, 1000} GHz, the transition probability of which is Q = [0.7, 0.2, 0.1; 0.2, 0.1, 0.7; 0.1, 0.7, 0.2]. The channel state also follows MDP. We assume three scenarios with different SNR state settings, labeled as SN R 1 , SN R 2 , and SN R 3 . There are three states in the first scenario with SN R 1 , low (H l = 1), medium (H l = 7), and high (H l = 15), the transition probability of which is</p><formula xml:id="formula_49">P 1 =   0.6 0.3 0.1 0.3 0.1 0.6 0.1 0.6 0.3   . (<label>38</label></formula><formula xml:id="formula_50">)</formula><p>The second scenario with SN R 2 has the following setting, five states {1, 3, 7, 15, 31} and transition probabilities </p><formula xml:id="formula_51">P 2 =       0.</formula><p>In the third scenario with SN R 3 , there are ten states {1, 2, 3, 5, 7, 11, 15, 23, 31, 47}, the transition probability of which is as the settings in <ref type="bibr" target="#b34">[35]</ref>. The other related settings are illustrated in Table <ref type="table" target="#tab_5">I</ref>. For double-dueling DQN, we use four full-connected layers in the main network and target network. The first 3 layers have 256, 256 and 128 neurons, respectively. The forth neural layer is split into Advantage (action advantage) and Value (state value) functions, which comes from the idea of dueling DQN. In the last layer, the Advantage and Value functions are merged as the Q value. The other parameters of the proposed approach are presented in Table <ref type="table" target="#tab_5">I</ref>.</p><p>To evaluate the effectiveness of the proposed approach, we first compare the performance achieved by DQN, double DQN, dueling DQN, and the utilized double-dueling DQN. Then we choose four comparison algorithms: 1) the proposed scheme with fixed spectrum allocation, in which the learning agent only needs to determine the optimal block size and the number of consecutively produced blocks for each replica; 2) the proposed scheme with fixed block size, in which the block size is set to be 1 MB; 3) the proposed scheme with fixed block number, in which each block producer can produce a fixed number of blocks at one time period, i.e., 4; 4) the existing static scheme, in which the decisions are made through maximizing the immediate reward. Last, we choose two existing algorithms in other works, the proportional fairness utility based algorithm (PFA) widely used for resource allocation <ref type="bibr" target="#b35">[36]</ref> and the random selection algorithm (RSA) in <ref type="bibr" target="#b36">[37]</ref>, where an action is randomly selected to execute in each step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Simulation Results and Discussion</head><p>The performance of double-dueling DQN based scheme with different learning rates is shown in Fig. <ref type="figure" target="#fig_4">2</ref>. From this figure, we can observe that the convergence is faster with the learning rate equal to 0.001 than that with learning rate 0.0001. The learning rate adjusts the weights of the current and previous learning value. A larger learning rate means that the learning agent will place more emphasis on the current learning value, and vice versa. In another word, a bigger learning rate denotes a longer learning step. However, a big learning rate can result in a local optimum point and miss the global optimum point due to the big learning step. Hence, the learning rate should be carefully chosen, which is set to be 0.001 in this paper. The effects of different discount rates on the performance of the proposed approach are shown in Fig. <ref type="figure">3</ref>. In DRL, the actions are chosen by optimizing the long term reward, where the future rewards are discounted by multiplying the discount rate, as defined in equation <ref type="bibr" target="#b32">(33)</ref>. The learning agent will choose the action maximizing the current reward with a small discount rate and vice versa. Since the current action would influence future rewards in this paper, the long term reward increases with the discount rate growing. However, it is meaningless to put too many weights on the future in an unstable system. Also, it would incur high computational complexity. To explore a tradeoff between the performance and the computational complexity, an appropriate discount rate should be chosen, which is set as 0.9 in the rest of the simulations.</p><p>Fig. <ref type="figure">4</ref> shows the effects of the mini-batch size of the proposed approach on the convergence performance. The xaxis denotes the training steps and the y-axis represents the value of loss function. The mini-batch size indicates how many experience cases are used to train the Q network in each training step. We can observe from Fig. <ref type="figure">4</ref> that the convergence is faster with the mini-batch size growing, which is because that more experiences are used to train the Q network with a bigger mini-batch size. Similar to the other parameters, an appropriate mini-batch size should be chosen, which is set to   be 64 in the rest of the simulations. Different DRL methods are compared in Fig. <ref type="figure" target="#fig_6">5</ref>. For fairness, all methods adopt the same simulation parameters. The Y-axis represents the value of loss function, which represents the gap to approximate the Q function, while the x-axis represents the training steps. First, we can see that double-dueling DQN converges first. Second, double-dueling DQN performs a more accurate approximation of the Q function than the other three DRL methods. That is because dueling DQN divides the Q function into the state value function and the action advantage function, which allows a better approximation of the Q values and enables faster convergence. Furthermore, double DQN selects the actions according to the online weights, which mitigates the overestimation compared with traditional DQN. It also results in more accurate approximation.</p><p>Fig. <ref type="figure" target="#fig_7">6</ref> shows the convergence of different schemes, where the y-axis denotes the long term reward. First, the existing static scheme converges firstly, but obtains the worst performance in terms of reward. That is because that the decisions are made according to the current reward, which needs less training steps. As a result, it doesn't consider the effects of the current action on the future rewards, which obviously obtains the lowest reward. Second, the proposed scheme maintains higher long term reward than the other three schemes. With the adaptive spectrum allocation policy, the latency can be    reduced. With an adaptive block size and a properly chosen number of producing blocks, the throughput of blockchain system can be improved. All these aspects contribute to better system performance. Hence, the proposed scheme, which jointly optimizes these aspects, obtains the best performance of all. Fig. <ref type="figure" target="#fig_8">7</ref> depicts the relationship between the system performance and the average transaction size. This figure can be used to show the performance of the proposed approach with different types of transactions, which are corresponding to different offloading tasks. With the average transaction size increasing, the system performance decreases. The reasons are 1) one block can contain fewer transactions when the transaction size rises; 2) the transmission latency from the users to the BSs increases, which lowers the performance of MEC system. Focusing on the comparison of different schemes, the proposed scheme obtains the highest long term reward with the variation of average transaction size, then follows the proposed scheme with fixed spectrum allocation, fixed block size and fixed block number, and the existing static scheme has the worst performance. The reasons are described as before.</p><p>Fig. <ref type="figure" target="#fig_10">8</ref> shows the relationship between the system performance and time to finality threshold. One observation is that the long term reward increases with the time to finality threshold raising and intends to be steady finally. With a flexible latency constraint, less punishment may be added to the reward, which naturally leads to a higher performance. However, when the time to finality threshold becomes big enough, it has little influence on the reward. Another observation is that the scheme with fixed block size acts better than that with fixed block number. The reason is that it can adjust the block number, which in turn adjusts the block interval to deal with the strict time to finality threshold and avoids missing blocks. Furthermore, we can find that the existing static scheme has the poorest performance, which reveals the superiority of double-dueling DQN based schemes. The proposed scheme maintains the best performance of all as well. Fig. <ref type="figure" target="#fig_11">9</ref> plots the reward to show the scalability and the the ability of the framework in dealing with dynamic changes of users in the system, where the number of BSs is fixed, i.e., 5, and the number of users varies from 2 to 20. In the simulation, we first train the algorithm offline in the scenario with 20 users and 5 BSs. When the offline-trained algorithm is applied online with changing number of users, the extra parameters in the states and actions are set to be null to cope with the smaller number of users. In another word, the results in Fig. <ref type="figure" target="#fig_11">9</ref> are obtained online using the algorithm that is trained offline. From the simulations, we can first observe that the long-term reward decreases with increasing number of users. The reasons are: 1) the average resources decrease, resulting in higher latency, and 2) more blocks may be ignored, inducing smaller throughput. Second, we can see that the proposed algorithm outperforms the other existing algorithms, which shows the superiority of the proposed scheme, even with a large number of users. Third, the results show that the offlinetrained algorithm can work effectively online under changing conditions.</p><p>In Fig. <ref type="figure" target="#fig_0">10</ref>, the performance of the proposed approach is verified by comparing with the other two baseline algorithms in three scenarios, where the SNR state settings vary in different scenarios. In the simulation, we train the proposed framework again when the dynamics of the SNR have changed. First, the scenario with SN R 3 achieves the best reward. That is because the system can obtain a better SNR state in this scenario, which introduce larger throughput and lower latencies, resulting in larger rewards. Second, it can be seen that the proposed  scheme becomes less stable when the number of SNR states increase. The reason is due to the mismatch between the states and actions. Third, there is little difference on the convergence speeds of these algorithms. That is because the number of states, actions, and steps in one episode is rather larger than the state set's dimension, which can be ignored by the law of large numbers. Fourth, the proposed scheme obtains the best performance, due to the superiority of DRL, which also shows the ability of the proposed scheme to adapt to different network dynamics.</p><p>At last, we analyze the throughput and latency of the proposed algorithm, as shown in Fig. <ref type="figure" target="#fig_13">11</ref>, where the number of BSs is fixed to 10 and the number of users ranges from 5 to 25. Similar to Fig. <ref type="figure" target="#fig_11">9</ref>, the results in Fig. <ref type="figure" target="#fig_13">11</ref> are also obtained online using the offline-trained algorithm, and it also shows that the proposed approach of training offline and operating online can work well in practice. Obviously, the throughput decreases and the latency increases with the number of users increasing. First, the resources are fixed. So the average amount of resources decreases with the number of users going up. Second, the queuing delay grows when the number of users raises, which induces larger latency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION AND FUTURE WORK</head><p>In this paper, we developed a novel blockchain-based framework for resource allocation in future wireless networks with MEC. With blockchain, the data delivery and computation execution on the edge servers are self-organized by smart contracts. A consensus protocol in this distributed wireless network was proposed, along with the details and theoretical analysis. The performance of MEC and blockchain system was given, i.e., the latency of the users, throughput, time to finality, decentralization, security. To improve the performance of the joint MEC and blockchain system, the main problem was formulated, where the spectrum allocation, block size, and block number were optimized. Since this problem is intractable using traditional methods, we resorted to a novel double-dueling deep Q learning approach to solve this problem. Simulation results demonstrated the effectiveness of the proposed scheme by comparing with the other baseline schemes. Future work is in progress to consider caching in the proposed framework.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Blockchain-enabled MEC in the heterogeneous wireless networks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>18 :</head><label>18</label><figDesc>Sample a mini-batch of size U19:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Reward under different learning rates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>5 Fig. 3 :Fig. 4 :</head><label>534</label><figDesc>Fig. 3: Reward under different discount rates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Comparison of DQN, double DQN, dueling DQN, double-dueling DQN.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Convergence of difference comparison algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Long term reward vs. average transaction size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Long term reward vs. time to finality threshold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: Rewards with different numbers of BSs and users.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>4 Proposed Scheme with SNR 1 Proposed Scheme with SNR 2 Proposed Scheme with SNR 3 RSA with SNR 1 RSA with SNR 2 RSA with SNR 3 PFA with SNR 1 PFA with SNR 2 PFA with SNR 3 Fig. 10 :</head><label>412312312310</label><figDesc>Fig. 10: Rewards under different SNR state settings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 :</head><label>11</label><figDesc>Fig. 11: Throughput and latency (seconds) versus the number of users.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>tr } + min{T tr prep , τ tr } + min{T tr pre , τ tr } + min{T tr c , τ tr } + min{T tr r , τ tr }.</figDesc><table><row><cell>t tr req + t tr prep + t tr pre + t tr c + t tr r</cell></row><row><cell>= min{T tr req , τ</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>), ..., Γ Um (t), ..., Γ U M (t); Γ B1 (t), ..., Γ Bn (t), ..., Γ B N (t); Ψ B1 (t), ..., Ψ Bn (t), ..., Ψ B N (t); B p (t)},</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Algorithm 1 Offline DRL-based Performance Optimization for B-MEC 1: Input: Maximum training episode E max , maximum steps H max in each episode, mini-batch size U , initial learning rate α, exploration probability ε, discount rate . 2: Initialization 3: Initialize the state of the B-MEC system s 1 , set ε = 1 4: Initialize the experience replay buffer 5: Initialize the main DQN with random weights with θ. 6: Initialize the target DQN with weights θ -= θ. 7: for episode = 1, ..., E max do</figDesc><table><row><cell>8:</cell><cell>for t = 1, ..., H max do</cell></row><row><cell>9:</cell><cell>Choose a random probability p,</cell></row><row><cell>10:</cell><cell>if p &gt; ε then</cell></row><row><cell>11:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE I :</head><label>I</label><figDesc>The simulation parameters</figDesc><table><row><cell>Simulation parameters</cell><cell>Value</cell></row><row><cell>Channel number</cell><cell>8</cell></row><row><cell>CPU cycles for a signature</cell><cell>0.001 G cycles</cell></row><row><cell>CPU cycles for a MAC</cell><cell>0.01 G cycles</cell></row><row><cell>CPU cycles to execute smart contract</cell><cell>0.01 G cycles</cell></row><row><cell>Weight for blockchain system ϑ B</cell><cell>0.5</cell></row><row><cell>Weight for MEC system ϑ M</cell><cell>0.5</cell></row><row><cell>Average size of transactions</cell><cell>100 B</cell></row><row><cell>Block size space</cell><cell>{0.5, 1, 2, 4} MB</cell></row><row><cell>Block number space</cell><cell>{2, 4, 6, 8}</cell></row><row><cell>Time period Ṫ</cell><cell>2 seconds</cell></row><row><cell>Threshold for time to finality Tmax</cell><cell>{2, 4, 6, 8} seconds</cell></row><row><cell>Total training steps</cell><cell>200000</cell></row><row><cell>Experience replay buffer size</cell><cell>10000</cell></row><row><cell>Mini-batch size</cell><cell>32</cell></row><row><cell>Discount rate</cell><cell>0.9</cell></row><row><cell>Final exploration rate</cell><cell>0.01</cell></row><row><cell>Learning rate</cell><cell>0.001</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by National Natural Science Foundation of China under Grant 61671088, National Natural Science Foundation of China under Grant 61771070, BUPT Excellent Ph.D. Students Foundation under Grant CX2018201, and the Canadian Natural Sciences and Engineering Research Council under grant RGPIN-2019-06348. The associate editor coordinating the review of this paper and approving it for publication was D. Niyato.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Hong Ji (SM'09) received the B.S. degree in communications engineering and the M.S. and Ph.D. degrees in information and communications engineering from the Beijing University of Posts and Telecommunications (BUPT), Beijing, China, in 1989, 1992, and 2002, respectively. In 2006, she was a Visiting Scholar with The University of British Columbia, Vancouver, BC, Canada. She is currently a Professor with BUPT. She has authored more than 300 journal/conference papers. Several of her papers had been selected for Best paper. Her research interests include wireless networks and mobile systems, including cloud computing, machine learning, intelligent networks, green communications, radio access, ICT applications, system architectures, management algorithms, and performance evaluations. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Secure and energy-efficient handover in fog networks using blockchain-based DMM</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Palmieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N K</forename><surname>Jayakody</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Mag</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="22" to="31" />
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Performance guaranteed computation offloading for mobile-edge cloud computing</title>
		<author>
			<persName><forename type="first">X</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Wireless Comm. Letters</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="774" to="777" />
			<date type="published" when="2017-12">Dec. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Spectrum sharing through contracts for cognitive radios</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Kalathil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1999" to="2011" />
			<date type="published" when="2013-10">Oct. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dynamic computation offloading for mobile cloud computing: A stochastic game-theoretic approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="771" to="786" />
			<date type="published" when="2019-04">Apr. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Mobile edge computing: A key technology towards 5G</title>
		<author>
			<persName><surname>Etsi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016-09">Sep. 2016</date>
			<publisher>White Paper</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Computation offloading and resource allocation for wireless powered mobile edge computing with latency constraint</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Wireless Comm. Letters</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1320" to="1323" />
			<date type="published" when="2019-10">Oct. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Distributed resource allocation and computation offloading in fog and cloud networks with non-orthogonal multiple access</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vehi. Tech</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="12" to="137" />
			<date type="published" when="2018-12">Dec. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Collaborative mobile edge computation offloading for IoT over fiber-wireless networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Qin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="66" to="71" />
			<date type="published" when="2018-01">Jan. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Joint computation offloading and interference management in wireless cellular networks with mobile edge computing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vehi. Tech</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="7432" to="7445" />
			<date type="published" when="2017-08">Aug. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Price-based distributed offloading for mobileedge computing with computation capacity constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Wireless Comm. Letters</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="420" to="423" />
			<date type="published" when="2018-06">June 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Secure and verifiable policy update outsourcing for big data access control in the cloud</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="3461" to="3470" />
			<date type="published" when="2015-12">Dec. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bitcoin and beyond: A technical survey on decentralized digital currencies</title>
		<author>
			<persName><forename type="first">F</forename><surname>Tschorsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Scheuermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Surveys Tutorials</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="2084" to="2123" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Security services using blockchains: A state of the art survey</title>
		<author>
			<persName><forename type="first">T</forename><surname>Salman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zolanvari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Erbad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Samaka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Surveys Tutorials</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="858" to="880" />
			<date type="published" when="2019">2019</date>
			<pubPlace>Firstquarter</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Virtualization for distributed ledger technology (vDLT)</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">28</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">AI and blockchain: A disruptive integration</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Thai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="48" to="53" />
			<date type="published" when="2018-09">Sep. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Decentralized resource allocation for video transcoding and delivery in blockchainbased system with mobile edge computing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vehi. Tech</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="11" to="169" />
			<date type="published" when="2019-11">Nov. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Distributed resource allocation in blockchain-based video streaming systems with mobile edge computing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Wireless Comm</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="695" to="708" />
			<date type="published" when="2019-01">Jan. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Blockchain for secure and efficient data sharing in vehicular edge computing and networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maharjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of Things Journal</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="4660" to="4670" />
			<date type="published" when="2019-06">June 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Blockchain-based secure time protection scheme in IoT</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of Things Journal</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="4671" to="4679" />
			<date type="published" when="2019-06">June 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Blockchainbased software-defined industrial Internet of things: A dueling deep Q -learning approach</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of Things Journal</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="4627" to="4639" />
			<date type="published" when="2019-06">June 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Blockchain-enabled security in electric vehicles cloud and edge computing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="78" to="83" />
			<date type="published" when="2018-05">May 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Ethereum: A secure decentralised generalised transaction ledger (eip-150 revision)</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Ethereum Project Yellow Paper</title>
		<imprint>
			<biblScope unit="volume">151</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Performance optimization for blockchain-enabled industrial Internet of things (IIoT) systems: A deep reinforcement learning approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Industrial Informatics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="3559" to="3570" />
			<date type="published" when="2019-06">June 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Chunk-based resource allocation in multicast OFDMA systems with average BER constraint</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Papoutsis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Kotsopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comm. Letters</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="551" to="553" />
			<date type="published" when="2011-05">May 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Making byzantine fault tolerant systems tolerate byzantine faults</title>
		<author>
			<persName><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marchetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th NSDI</title>
		<meeting>6th NSDI</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="153" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Measuring inequality</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cowell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Multi-attribute node importance evaluation method based on Gini-coefficient in complex power grids</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wenli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhigang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IET Gener. Transm. Distr</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2027" to="2034" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Reinforcement learning: A survey</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Kaelbling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Littman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="237" to="285" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Human-level control through deep reinforcement learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Volodymyr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Koray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Joel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M G</forename></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alex</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Georg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">518</biblScope>
			<biblScope unit="issue">7540</biblScope>
			<biblScope unit="page">529</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Double Q-learning</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Hasselt</surname></persName>
		</author>
		<ptr target="http://papers.nips.cc/paper/3964-double-q-learning.pdf" />
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 23</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="2613" to="2621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dueling network architectures for deep reinforcement learning</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lanctot</surname></persName>
		</author>
		<idno>abs/1511.06581</idno>
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Interference management for cellular-connected UAVs: A deep reinforcement learning approach</title>
		<author>
			<persName><forename type="first">U</forename><surname>Challita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Saad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bettstetter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Wireless Comm</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="2125" to="2140" />
			<date type="published" when="2019-04">Apr. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">PAC model-free reinforcement learning</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Strehl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Wiewiora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Langford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Littman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd Inter. Conf. Machine Learning</title>
		<meeting>23rd Inter. Conf. Machine Learning</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="881" to="888" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Is Q-learning provably efficient</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">A</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bubeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NIPS 2018</title>
		<meeting>NIPS 2018</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="4863" to="4873" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Deep-reinforcement-learning-based optimization for cacheenabled opportunistic interference alignment wireless networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C M</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vehi. Tech</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">445</biblScope>
			<date type="published" when="2017-11">Nov 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Proactive resource management for lte in unlicensed spectrum: A deep learning perspective</title>
		<author>
			<persName><forename type="first">U</forename><surname>Challita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Saad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Wireless Comm</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="4674" to="4689" />
			<date type="published" when="2018-07">July 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Her current research interests include future wireless networks, mobile edge computing, blockchain, and machine learning. F. Richard Yu (S&apos;00-M&apos;04-SM&apos;08-F&apos;18) received the PhD degree in electrical engineering from the University of British Columbia (UBC) in 2003. From 2002 to 2006, he was with Ericsson (in Lund, Sweden) and a start-up in California, USA. He joined Carleton University in 2007, where he is currently a Professor. He received the IEEE</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His research interests include connected/autonomous vehicles, security, artificial intelligence, distributed ledger technology, and wireless cyber-physical systems. He serves on the editorial boards of several journals, including Co-Editorin-Chief for Ad Hoc and Sensor Wireless Networks, Area Editor for IEEE COMMUNICATIONS SURVEYS AND TUTORIALS, Lead Series Editor for IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, and IEEE TRANSACTIONS ON GREEN COMMUNICATIONS AND NETWORKING</title>
		<title level="s">BUPT) in Beijing</title>
		<meeting><address><addrLine>China; China</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Communication Magazine</publisher>
			<date type="published" when="2005">Aug. 2018. 2015. September 2018 to September 2019. 2019. 2017. 2014. 2012. 2005. 2014</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="2375" to="2385" />
		</imprint>
		<respStmt>
			<orgName>University of British Columbia, Vancouver, Canada and Carleton University, Ottawa</orgName>
		</respStmt>
	</monogr>
	<note>From 2014 to 2018, she was the Lecturer in the School of Information and Communication Engineering at BUPT. From 2018, she has been the associate professor in the School of Information and Communication Engineering at BUPT. She has been the reviewer for Journals of IEEE Wireless Communications. She participated in many National projects funded by National Science and Technology Major Project, National 863 High-tech and National Natural Science Foundation of China, and cooperated with many Corporations in research. Her research interests include heterogeneous networks, long-term evolution/fifth generation and Internet of Things</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
