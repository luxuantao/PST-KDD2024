<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Burstiness-Aware Search for Document Sequences</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Theodoros</forename><surname>Lappas</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Riverside</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benjamin</forename><surname>Arai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Riverside</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Manolis</forename><surname>Platakis</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Informatics and Telecommunications</orgName>
								<orgName type="institution">University of Athens</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dimitrios</forename><surname>Kotsakos</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Informatics and Telecommunications</orgName>
								<orgName type="institution">University of Athens</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dimitrios</forename><surname>Gunopulos</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Riverside</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Informatics and Telecommunications</orgName>
								<orgName type="institution">University of Athens</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">On Burstiness-Aware Search for Document Sequences</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A41FAA01FE464540468D2B868BFFBF58</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.3.1 [Information Storage and Retrieval]: Content Analysis and Indexing-Indexing methods</term>
					<term>H.2.8 [Database Management]: Database applications-Data Mining</term>
					<term>G.3 [Probability and Statistics]: Time series analysis Algorithms, Theory Document Sequences, Search, Burstiness</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>As the number and size of large timestamped collections (e.g. sequences of digitized newspapers, periodicals, blogs) increase, the problem of efficiently indexing and searching such data becomes more important. Term burstiness has been extensively researched as a mechanism to address event detection in the context of such collections. In this paper, we explore how burstiness information can be further utilized to enhance the search process. We present a novel approach to model the burstiness of a term, using discrepancy theory concepts. This allows us to build a parameter-free, lineartime approach to identify the time intervals of maximum burstiness for a given term. Finally, we describe the first burstiness-driven search framework and thoroughly evaluate our approach in the context of different scenarios.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Suppose we are presented with a long document sequence, formed by newspaper articles spanning several local titles (e.g., New York Times, The Wall Street Journal, etc.), over a large period of time. Such corpora is becoming increasingly available, due to initiatives such as The National Digital Newspaper Program (NDNP) <ref type="bibr">[15]</ref> by the Library of Congress (LC), and other similar ventures for the digitization of periodicals by large corporations such as Microsoft (www.microsoft.com) and Google (www.google.com). The articles in such collections cover newsworthy events that took place at various times. Each event is characterized by a set of descriptive keywords, revealing basic information such as the place where the event occurred, or the names of the persons involved. For the duration of the event's lifespan and consequent coverage in the news, these characteristic terms appear repeatedly in relevant articles, leading to uncommonly high frequencies (bursts). In the typical search paradigm, the user encodes a topic of interest using a query (i.e. a set of keywords), which is then submitted to a search engine. Typical search engines rely on static, frequency-based measures (e.g. tf-idf ) for the purposes of indexing and querying the underlying collection. These measures record the frequency of a term in each document, typically normalized by a global frequency measure, in order to capture the impact of the term in the entire collection. The underlying assumption is that an occurrence of a term has the same significance, regardless of the moment in time it occurs. Our claim is that, for a contiguous document sequence observed through time, this assumption is invalid: the importance of terms varies through time, as they are used to describe current influential events that are discussed in the corpus. Therefore, it is essential to consider the temporal dimension of the data in the indexing and ranking process. The ultimate purpose of our work is the creation of an efficient, end-to-end framework that, given a document sequence, identifies "bursty" intervals for each term and utilizes this information toward an efficient, burstiness-aware search mechanism.</p><p>Even though some work has been devoted to measuring burstiness in different contexts, the concept has yet to be formalized. A major contribution of our work is a formal definition of burstiness that is based on the concept of discrepancy. Discrepancy theory has applications in several fields including machine learning, computer graphics and computational geometry <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b1">1]</ref>. The concept is generally used to describe the deviation of a situation from the "expected" behavioral baseline. Based on our definition, we present a parameter-free, linear-time algorithm to identify the time-intervals that maximize the burstiness score of any given term. We present the theoretical foundations of our work and proceed to evaluate it thoroughly on a new dataset. Our Contributions: In this paper we make the following contributions: i. A formal definition of term burstiness in the terms of numerical discrepancy.</p><p>ii. A parameter-free, linear-time method to identify the maximum burstiness intervals for a given term.</p><p>iii. An efficient search framework for documents, that considers term burstiness in the indexing and ranking process. The framework uses an extension of the wellknown TA algorithm <ref type="bibr">[9]</ref> for finding the top intervals.</p><p>The rest of this paper is organized as follows: Section 2 discusses related work. Section 3 describes the basic notation used in the paper. Section 4 introduces our definition of burstiness and discusses efficient techniques for the identification of bursty intervals for a given term. In Section 5, we present two different versions of a complete, burstinessaware search framework. Finally, we conclude with a thorough experimental evaluation in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>The concept of burstiness has been studied in several domains. A significant portion of this work has been inspired by Kleinberg's seminal paper on the bursty and hierarchical structure of streams <ref type="bibr" target="#b13">[13]</ref>. We discuss Kleinberg's approach in more detail in Section (6.2). A considerable amount of work has been devoted to developing efficient burst-detection methods <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>. Even though we propose a method of our own, we do so in the process of creating a complete search framework, which is the main contribution of our work. The main benefits of our method are that it runs in linear-time and is also completely parameter-free. This makes it ideal for very large sequences of documents, spanning significant periods of time. That being said, our search framework is compatible with any burst detection method that can report non-overlapping bursty intervals and their respective scores, for any given term.</p><p>Another burst-detection method is presented by Fung et al. <ref type="bibr" target="#b10">[10]</ref>. In this work, bursty terms are clustered to represent events discussed in the data. In <ref type="bibr" target="#b11">[11]</ref>, the authors classify terms in four burstiness categories, based on their frequency trajectory. Their use of spectral analysis is similar to the one used by Vlachos et al. in <ref type="bibr" target="#b17">[18]</ref>, where the authors focus on periodic and bursty artifacts in query logs. In <ref type="bibr" target="#b18">[19]</ref>, the authors use a wavelet-based structure for aggregate monitoring of data streams.</p><p>Burstiness has also been evaluated in the context of other applications, such as stream clustering <ref type="bibr" target="#b12">[12]</ref>, and even in the context of graphs <ref type="bibr" target="#b14">[14]</ref>. Further, He et al. <ref type="bibr" target="#b15">[16]</ref> apply Kleinberg's model to topic clustering.</p><p>Bansal and Koudas <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b3">3]</ref> have presented a system for the analysis of streaming blogs. Even though no details on the employed methods are given, their work is relevant to ours, in that they ultimately map bursty terms to specific blogposts. To the best of our knowledge, our work is the first that directly incorporates burstiness information in the indexing and ranking of documents, leading to a complete burstiness-aware search framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PRELIMINARIES</head><p>In this paper, we explore corpora that are formed as a sequence of documents, spanning a pre-defined timeline. For a timeline of m consecutive timestamps, we define a document sequence S as:</p><formula xml:id="formula_0">S = S1, S2, ..., Sm<label>(3.1)</label></formula><p>where Si represents the set of documents appearing on the i th timestamp. Further, we define the frequency sequence Yt for a given term t as:</p><formula xml:id="formula_1">Yt = yt1, yt2, ..., ytm<label>(3.2)</label></formula><p>where yti expresses the frequency of term t on the i th timestamp of the timeline. We assume that yti is equal to the number of documents in Si that include term t. Finally, by Yt[l : r], we represent an interval of Yt that includes all timestamps from y tl to ytr (inclusive). Note that the words "interval" and "segment" are used interchangeably throughout the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DEFINING TERM BURSTINESS</head><p>In this section we present a formal definition of term burstiness in the terms of numerical discrepancy. We then show how the problem of finding the maximum burstiness intervals can be solved in linear time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Discrepancy Model of Burstiness</head><p>We first present the general definition of numerical discrepancy <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b4">4]</ref>. Let P be a set of points distributed over random locations in [0, 1] d , where d is the number of dimensions on the plane. For any region R in [0, 1] d , let µ(R) be the Euclidean measure of R ∩ [0, 1] d (i.e. the area of R), and µP (R) be the discrete measure |R ∩ P|/|P| (i.e. the fraction of points of P inside R). Then, the numerical discrepancy of R with respect to P is defined as:</p><formula xml:id="formula_2">DP (R) = |µ(R) -µP (R)| (4.1)</formula><p>Even though the concept is meaningful for any d &gt; 1, we will focus on the one-dimensional case, suitable for our sequence representation. For d = 1, a region R is reduced to a onedimensional interval I, defined within the unit interval [0, 1]. Following Equation (4.1), the discrepancy of a given interval I is defined as the absolute value of the difference between its length and the ratio of points from P that fall within I:</p><formula xml:id="formula_3">DP (I) = |µ(I) -µP (I)| = len(I) - |P ∩ I| |P| ,<label>(4.2)</label></formula><p>where len(I) is the length (i.e. the euclidean measure) of interval I. Conceptually, µ(I) expresses the baseline, i.e. the fraction of points from P that is expected to fall within I, while µP (I) represents the observed fraction. This constitutes an appropriate definition for term burstiness, which is similarly expressed by increased frequency values that diverge from a term's individual baseline. In the mapping of term burstiness to numerical discrepancy, the set of points P is represented by the total frequency of a term, observed throughout the entire document sequence. Next, we formally define the baseline µ(I) and the observed fraction µP (I) in the context of term burstiness. Depending on the nature of the data, µ(I) can be either pre-defined or based on the underlying distribution. In <ref type="bibr" target="#b1">[1]</ref>, the authors explore discrepancy in the context of different distributions <ref type="bibr">(Poisson, Binomial)</ref>. Even though such an approach may work well in some scenarios, the assumption that the entire dataset can be accurately described by a single distribution is not always valid. In addition, the use of a probability distribution introduces parameters that are not always intuitive to tune. Given an interval Yt[l : r] of the frequency sequence for a term t, we define the baseline as len(Yt[l : r]) × Avg(Yt), i.e. the average frequency observed over all timestamps, multiplied by the length of the interval. To conform with the definition of numerical discrepancy, we then project Yt[l : r] on the unit interval [0, 1] by dividing the baseline by n i=1 yti.</p><p>Formally, let I be the projection of Yt[l : r] on [0, 1]. Then, we define the baseline µ(I) for I as:</p><formula xml:id="formula_4">µ(I) = len(Yt[l : r]) × Avg(Yt) m i=1 yti (4.3)</formula><p>By replacing the average and solving further, we get:</p><formula xml:id="formula_5">= len(Yt[l : r]) × ( m i=1 yti)/m m i=1 yti = len(Yt[l : r]) m = len(I) (4.4)</formula><p>Indeed, the baseline is equal to the Euclidean measure (length) of I, as mandated by Eq. (4.2).</p><p>Next, we define µP (I), the fraction of the term's frequency observed within the interval, as the frequency of t observed within interval Y [l : r], divided by the total frequency of t throughout the sequence: Note that Eq. (4.6) takes positives values if the observation is either greater or less than the baseline. Conceptually, the latter occurs if the frequency of a term within an interval is less than expected. Even though this typically constitutes a case of discrepancy, it is of little value for the purposes of measuring term burstiness. Instead, we would like burstiness to be positive only for uncommonly high frequency observations. Thus, given a term t and an interval [l : r] on the timeline, we define the Burstiness of t in [l : r] as:</p><formula xml:id="formula_6">µP (I) =</formula><formula xml:id="formula_7">B(t, [l : r]) = r i=l yti m j=1 ytj - len(Yt[l : r]) m (4.7)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Maximizing Burstiness</head><p>Using Eq. (4.7), we can measure the burstiness of a given term for any interval on the timeline. The next step is to identify high-burstiness intervals for each term. On a higher level, the problem definition is the following: Problem 1. Bursty Intervals Problem: Given the frequency sequence Yt of a given term t, identify the set of intervals that maximize the Burstiness function B(t, •) .</p><p>Next, we argue that Problem 1 is equivalent to the wellknown maximum sum segments problem, defined as such: Problem 2. Maximum Sum Segments Problem: Given an input sequence X = x1, x2, ..., xn of real numbers, identify the K segments with the highest total scores, where the score f (X[i : j]) of a segment X[i : j] = xi, xi+1, ..., xj is equal to the sum of its elements:</p><formula xml:id="formula_8">f (X[i : j]) = j k=i x k (4.8)</formula><p>The Maximum Sum Segments Problem comes up in different domains and has been extensively researched in the past <ref type="bibr" target="#b5">[5]</ref>. To show that Problems (1) and ( <ref type="formula">2</ref>) are equivalent, it is sufficient to show that, given a term t, the Burstiness score of any given interval is equal to the sum of the Burstiness values observed in the individual timestamps of the interval. Formally:</p><formula xml:id="formula_9">B(t, [l : r]) = r k=l B(t, [k : k]) (4.9) Proof. r k=l B(t, [k : k]) = r k=l y tk m j=1 ytj - 1 m = r i=l yti m j=1 ytj - len(Yt[l : r]) m = B(t, [l : r])</formula><p>Problem ( <ref type="formula">1</ref>) is now reduced to solving the Maximum Sum Segments Problem on the burstiness sequence Bt, defined as such:</p><formula xml:id="formula_10">Bt(i) = B(t, [i : i]) = yti m j=1 ytj - 1 m , 1 ≤ i ≤ m (4.10)</formula><p>Eq. (4.10) assumes the global baseline given by Eq. (4.3). Alternatively, one could use the local average of each interval as a baseline. In that case, consecutive segments of Bt could be computed separately, and then concatenated to form the entire sequence. This could allow for a more flexible calculation of burstiness, and avoid reporting anticipated periodical bursts (e.g. a burst of the term "Christmas" during December).</p><p>The standard formulation of the Maximum Sum Segments problem has the following disadvantage: given a high-scoring segment, one can easily generate several others by simply appending or removing a small number of elements. These segments convey little extra information regarding the burstiness of a term. To address this, we adopt a slightly different formulation, based on the concept of the maximal segment:</p><formula xml:id="formula_11">Definition 1. Maximal Segment: Let X be a non-empty score sequence. A segment X[i : j] is maximal in X if i. All proper sub-segments of X[i : j] have a lower score ii. No proper super-segments of X[i : j] in X satisfies (i).</formula><p>Figure <ref type="bibr" target="#b1">(1)</ref> illustrates the Burstiness Sequence Bt for the term "Earthquake", as it manifested in a daily newspaper over a fixed period of time. The values on the x-axis represent consecutive timestamps. Following Eq. (4.10), negative values correspond to points when the observed frequency was less than the baseline. Here, "WZ" is identified as a maximal segment; conceptually, extending the interval from either side can only reduce its score, since more negative than positive values will be included.</p><p>No two maximal sequences can overlap. A formal proof appears in <ref type="bibr" target="#b16">[17]</ref>, but essentially, given two maximal overlapping sequences, either the union or the intersection of the two would have higher discrepancy than one of the two, creating a contradiction. Thus, every element of the input sequence belongs to exactly one maximal segment. Therefore, for any given sequence of real numbers, there exists a finite set that contains all the maximal scoring segments. We can now formalize the problem as such: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Algorithms for the All Maximal Segments Problem</head><p>In <ref type="bibr" target="#b16">[17]</ref> the authors present a linear-time algorithm for solving the All Maximal Segments Problem. The algorithm accepts as input a sequence of real numbers and reports the set of all maximal segments. For the rest of this paper, we refer to this algorithm as MAX-1. The details and pseudocode of the algorithm can be found in <ref type="bibr" target="#b16">[17]</ref>. MAX-1 filters out maximal segments with a negative score. This is ideal for the purposes of burstiness evaluation, since negative-scoring intervals represent regions where the observed frequency of a term was less than the expected. Finally, in addition to being linear, the approach is completely parameter-free. Next, we present an extension of MAX-1 and discuss its advantages.</p><p>In <ref type="bibr" target="#b13">[13]</ref>, Kleinberg discusses anisochronies, the non-uniform relationships between the time spanned by a story's events and the amount of time devoted to these events in the actual telling of the story. Considering the coverage of events in news streams (e.g. newspapers, blogs), we identify two primary levels of bursty behavior for the terms describing an event: the first level represents the extended time period when the event was generally discussed in the news. Depending on the nature and significance of the event, this period can be extended to include weeks or even months. The second burstiness level pertains to smaller intervals within this extended period, when the event was particularly popular and extensively covered in the news. In the context of a newspaper, such intervals may represent the first time an event made the headlines, or a new development in an older event that brings it back to the front page.</p><p>Conceptually, the intervals reported by MAX-1 capture the first level of burstiness activity for a given term. By reapplying the algorithm on each of the reported maximal intervals independently, we can easily identify the secondlevel burstiness intervals. For the rest of this paper, we refer to this algorithm as MAX-2. The pseudocode is shown in Algorithm <ref type="bibr" target="#b1">(1)</ref>. Multiple iterations of MAX-2 could be used to obtain a hierarchical structure of the bursty intervals. As we demonstrate in the Experiments section, a single iteration is enough to capture the burstiness patterns of events. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">QUERY EVALUATION</head><p>In this section, we describe two different ways to utilize burstiness information to create a complete, burstinessaware search framework. The described search frameworks constitute the main contribution of our work. Our first approach focuses on indexing and ranking documents directly, while the second approach is more advanced and performs a more informative, interval-based evaluation of a given query. For each approach, we start by discussing the underlying indexing mechanism, and then proceed to discuss the respective query evaluation algorithms.</p><p>It is important to note that both approaches are compatible with any method than can evaluate the frequency sequence of a term over a specified timeline, and report nonoverlapping bursty intervals and their respective scores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluating Documents</head><p>Next, we describe a burstiness-aware query evaluation framework that retrieves and ranks documents based on a given query. First, we discuss the employed indexing mechanism.</p><p>Indexing: In the standard inverted index structure, each term is mapped to the list of documents that contain the term. In a more advanced scenario, the document lists are sorted on a pre-computed score that expresses the strength of the connection between the term and the document. In order to use such a structure in our framework, we need to define a formula that evaluates a document with respect to a given term, in the context of burstiness: Definition 2. Given a term t and a document d, let I t,d be the bursty interval of t that includes (the timestamp of) d. Then, the Burstiness of d with respect to t is defined as:</p><formula xml:id="formula_12">d-score(t, d) =    B(t, I t,d ) × f req(t, d) , if I t,d = ∅ 0, otherwise    (5.1)</formula><p>where d-score stands for document score. Conceptually, B(t, I t,d ) returns the burstiness score of I t,d , as defined by Eq. (4.7). Also, f req(t, d) returns the frequency of term t with respect to document d. In our experiments, we assume f req(t, d) = log(T F (t, d) + 1), where T F (t, d) returns the number of occurrences of t in d. The logarithm is used to moderate the effect of the frequency and ensure that burstiness is the dominant factor. Finally, if d-score(t, d) = 0, d is not included in the sorted list. Note that</p><p>We can now build an inverted index structure, where each term is mapped to a list of documents, sorted on their d-score. Next, we discuss how we can use this index to evaluate multiterm queries.</p><p>Evaluation: First, we formally define the Document Evaluation Problem as such: Problem 4. Document Evaluation Problem: Given a query of terms q = {t0, t1, ...}, retrieve the k documents with the k highest values for t∈q d-score(t, d).</p><p>With an appropriate index structure at our disposal, the next step is to find a query evaluation algorithm to address Problem 4. For this purpose, we use the Threshold Algorithm (TA) <ref type="bibr">[9]</ref>, an efficient top-k evaluation algorithm, which is able to deal with multi-predicate queries. The algorithm goes through the sorted lists mapped to the terms of a query, evaluating documents in descending order. For every document seen under sorted access in some list, a random access probe retrieves the respective scores of the document from the other lists. The cumulative score is then calculated, and the document is considered as a top-k candidate. The algorithm maintains a threshold value T , based on the score of the last document seen from every List. As soon as k documents with a cumulative score of at least T have been found, the algorithm terminates. The authors prove that, while this mechanism allows for early termination, it does not affect the optimality of the result. Algorithm (2) contains the pseudocode of the TA algorithm. The algorithm is designed so that candidates from different sorted lists can be also evaluated in parallel. In that case, lines 5-11 of the algorithm can be handled by independent threads.</p><p>The proposed Inverted Index structure and the TA algorithm compose a complete search framework that efficiently solves the Document Evaluation Problem. The framework is thoroughly evaluated in the Experiments Section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Evaluating Intervals</head><p>The framework described in the previous section focuses on the indexing and ranking of documents. In this section, we describe an alternative approach that places the focus on intervals. Given a query of terms, we would like to find periods of time when all terms simultaneously displayed bursty behavior, indicating the occurrence of an underlying event.</p><p>Next, we describe a search framework for this problem.</p><p>Indexing: First, we define a formula that evaluates the burstiness of interval with respect to a given term: Definition 3. Let It be the set of bursty intervals for a term t. Then, given a query of terms q = {t0, t1, ..}, an interval I is identified as bursty with respect to q, if ∀t ∈ q, ∃ I ∈ It, s.t. I ⊆ I . Then, the burstiness score of I with respect to q is defined as:</p><formula xml:id="formula_13">i-score(I, q) = t∈q B(t, super(It, I)) ,<label>(5.2)</label></formula><p>Algorithm 2 TA Algorithm Input: query q = {t0, t1, ...}, int k Output: Set of top-k documents 1: TopK ← ∅ // sorted, holds at most k elements 2: Threshold T ← 0 3: L = {L0, L1, ..} // set of Doc Lists for each term in q 4: while (Not All lists in L Have Been Exhausted) do 5:</p><p>for (every List L ∈ L) do 6:</p><p>cand ← getNext(L) 7:</p><p>total ← cand.score // Holds cumulative score 8:</p><p>T ← (T -lastSeen(L) + cand.score) 9:</p><p>for (every List L ∈ L, L = L) do 10: total+ = getDScore(L , cand) 11:</p><p>TopK.insert(cand, total) 12:</p><p>if ((TopK.size() == k) &amp;&amp; (TopK.last() &gt;= T)) 13:</p><p>return TopK // Early Termination 14: return TopK</p><p>• getNext(L) returns the next candidate to be evaluated from list L, under sorted access.</p><p>• getDScore(L , cand) is a random access probe that retrieves the d-score of the candidate document from list L .</p><p>• lastSeen(L) returns the score of the last candidate seen under sorted access in List L • TopK.last() returns the score of the lowest-scoring element in the Result.</p><p>where i-score stands for interval-score. Also, super(It, I) returns the interval I ∈ It, s.t. I ⊆ I (i.e. I is a supersegment of I).</p><p>Conceptually, I is bursty with respect to a query if it has been included in a bursty interval for all the terms in the query. The i-score of I is then the sum of the scores of all the bursty intervals that include it. Note that this definition requires the bursty-interval set It for a given term t to consist of non-overlapping intervals. This guarantees that at most one interval I ∈ It is a super-segment of I. Using Eq. (5.2), we can now build an inverted index structure, where each term is mapped to a list of intervals, sorted on their i-score. Next, we discuss how we can use this index to evaluate multi-term queries.</p><p>Evaluation: First, we formally define the Interval Evaluation Problem as such: Problem 5. Interval Evaluation Problem: Given a query of terms q = {t0, t1, ...}, retrieve the k intervals with the highest values for t∈q i-score(t, d).</p><p>For the top-k evaluation phase, we introduce a modified version of the TA Algorithm, which we refer to as TA * (Algorithm (3)). TA * is similar to TA, differing only in the use of the random access probe. In the standard version, a random access probe looks for the candidate document in the various document lists and retrieves its d-score (line 10 of Algorithm 2). In the case of intervals, this step is more complicated, since the candidate may overlap with multiple intervals in a list. Procedure (1) provides an implementation of the Random Access probe. Given an Interval I and a list of intervals L the probe returns the set of (sub)intervals of I that overlap with some interval in L. The procedure can be easily implemented with the use of interval-trees <ref type="bibr" target="#b6">[6]</ref>. for (every List L ∈ L) do 6:</p><p>cand ← getNext(L) 7:</p><p>T ← (Tlastseen(L) + cand.score) 8:</p><formula xml:id="formula_14">X [i] ← {cand} 9:</formula><p>for (every List L ∈ L, L = L) do 10:</p><formula xml:id="formula_15">X [j] ← RandomAccess(cand, L ) 11: F ← merge(X [0], X [1], ...) 12:</formula><p>for every Interval I in F do 13:</p><p>TopK.insert(I, I.score) 14:</p><p>if ((TopK.size() == k) &amp;&amp; (TopK.last() &gt;= T)) 15:</p><p>return TopK // Early Termination 16: return TopK</p><p>• getNext(L), lastSeen(L) and TopK.last() are as in the TA Algorithm.</p><p>• The X [ ] variables represent sets of intervals.</p><p>• The RandomAccess() function is described in Procedure 1.</p><p>• The use of the merge() function is shown in Figure <ref type="bibr" target="#b2">(2)</ref>.</p><p>After the sets of overlapping (sub)intervals from each List have been retrieved, they are merged to produce the final set F, consisting of segments included in bursty intervals for all the terms of the query (Line 11 of Algorithm 3). Figure <ref type="bibr" target="#b2">(2)</ref> shows an example of the merging process for a query q = {t0, t1, t2, t3}. The interval-set X [0] contains only one interval: the candidate, selected under sorted access from the bursty-interval list of term t0. Also, X [1], X <ref type="bibr" target="#b2">[2]</ref> and X <ref type="bibr" target="#b3">[3]</ref> contain intervals that overlap with the candidate, retrieved by applying the RandomAccess Procedure on the bursty-interval lists of terms t1, t2 and t3, respectively. According to Definition 3, only the interval I = [5 : 7] qualifies as bursty with respect to q. Following Eq. (5.2), the burstiness score of candidate I is equal to The top-k set produced by TA * optimally solves the Interval Evaluation Problem. The reported intervals reveal bursty periods for any multi-term query. This allows us to not only locate events correlated with particular terms, but also estimate their lifespan. Further, the framework can be easily extended to report the documents that appear within each interval, and also contain all the query terms. Thus, we can obtain ranked groups of documents, where each group is relevant to a specific bursty period. Clearly, this is more informative than a mechanism that simply reports k documents from completely arbitrary timestamps. </p><formula xml:id="formula_16">X[ 3] X[ 2] X[ 1] X[ 0 ]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTS</head><p>In this section, we illustrate the efficacy of our search framework through a rigorous experimental evaluation. Section 6.1 describes the datasets we used. Section 6.2 discusses the different burst-detection methods used in our experiments. Finally, Sections 6.3-6.5 evaluate our search framework in different scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Datasets</head><p>Newspaper Datasets: We have conducted a series of experiments using real-world datasets from the Center for Bibliographical Studies and Research (CBSR) at the University of California, Riverside (UCR). CBSR has received two grants from the National Endowment for the Humanities to participate in the National Digital Newspaper Program (NDNP). The NDNP is a joint venture of the National Endowment for the Humanities and the Library of Congress to create a national digital newspaper resource, representing papers from all states, published between 1836-1922.</p><p>For the experimental evaluation we have gathered over 390,000 articles from the San Francisco Call, a daily newspaper with publication dates between 1900-1909. After the removal of stopwords, approximately 120,000 distinct terms were identified. We have several attributes for each article, including the title, the date of publication, and the raw (punctuation and capitalization included) content. Due to the age and size of the corpus, some issues were not located for digitization, leaving small gaps in the data set. To address this, we extracted 3 independent document sequences from the data, for which all the articles were available:</p><p>• SF-Call-1: A sequence of 122,114 articles spanning from Jan 01, 1900 to Dec 31, 1901.</p><p>• SF-Call-2: A sequence of 144,289 articles spanning from Jan 01, 1903 to Dec 31, 1904.</p><p>• SF-Call-3: A sequence of 153,412 articles spanning from Jan 01, 1908 to Dec 31, 1909.</p><p>These large sequences of chronologically ordered articles will serve as datasets for the experiments described in this section. The data is available on request. Major Events List: In order to perform a qualitative evaluation of our approaches, we manually composed a list of major events that took place at a time covered by one of the three Newspaper Datasets. The events were taken from Wikipedia (www.wikipedia.com), which maintains annual lists of major events. For every event, a query was composed, consisting of keywords chosen for their particular significance with respect to the event. Table (3) contains the list of events and their respective queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Burst Detection</head><p>Throughout the experiments section, we evaluate the performance of the proposed search frameworks, using the MAX-1 and MAX-2 algorithms, described in Section 4, to obtain the required bursty intervals. As an alternative, we try the popular burst-detection method proposed by Kleinberg in <ref type="bibr" target="#b13">[13]</ref>. This algorithm is based on a Hidden Markov Model, with states that correspond to frequency levels for individual terms. State transitions (bursts) correspond to points in time, around which the frequency of a term changes significantly. Given the frequency sequence Yt of a term t, dynamic programming is used to fit the most possible state sequence that is likely to have generated Yt. The state assigned to each interval will serve as its burstiness score, which is required by our framework. For the rest of this paper, we refer to this algorithm as KLEIN.</p><p>The states reported by KLEIN form a hierarchical structure, with a long burst of low intensity including several bursts of higher intensity. Clearly, this violates our requirement for non-overlapping bursty intervals. To address this, we give priority to higher-state intervals, by assigning to every timestamp i the highest state observed over all the reported intervals that include i. To be fair, if the length of the highest-state interval is too small(&lt;3), we take the interval with the second-highest state. We believe this to be a reasonable and intuitive aggregation method.</p><p>Further, by assigning a high cost to state transitions, one can restrain the number of states in the hierarchy reported by KLEIN, thus eliminating short bursts and leading to longer intervals. Reasonably long intervals that reflect the true lifespan of an event are desirable, since they are likely to contain more relevant documents. On the other hand, the assignment of very high costs will limit the score-space to a small set of (low-intensity) states. Consider having to rank 10 documents based on their state, where each document has 1 of 2 distinct states; inevitably, multiple ties will lead to a meaningless ranking. For our experiments, KLEIN was tuned to find a balance between reasonably long intervals and an adequate number of distinct states. Note that our parameter-free algorithms resolve such issues by using the concept of the maximal segment to automatically extend a segment as long as it can benefit its score.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Document Ranking</head><p>The purpose of this experiment is to evaluate the Document Evaluation framework described in Section 5.1. The evaluation is done as follows: First, an inverted index is built on top of each on the three Newspaper Datasets, as described in Section 5.1. Then, the queries from the Major Events List are evaluated using the TA Algorithm. Queries mapped to events from 1900 and 1901 are evaluated using the index built on top of SF-Call-1 and so forth. The entire process is repeated 3 times, each time using one of the three burst-detection algorithms (MAX-1, MAX-2 and KLEIN) to build the search framework. We also compare against Lucene (lucene.apache.org), a popular text-search engine. Lucene uses frequency-based measures such as the frequency of the term within each document and the term's global frequency to rank documents in the context of a given query. A human annotator studied each of the top-10 documents reported for each event, marking them as "relevant" or "nonrelevant". This allows us to evaluate the achieved precision, defined as the ratio of the number of relevant documents over the total number of retrieved documents. The results are shown in Table <ref type="bibr" target="#b1">(1)</ref>. The table contains a separate column for the achieved recall in the top-5 documents, to provide more insight on the quality of the produced ranking. Our framework performs consistently well, clearly outperforming Lucene in almost every case. Regarding the different burst detection algorithms, MAX-1 and MAX-2 achieved near-perfect precision values for all submitted queries. KLEIN's precision was just as good, although it failed to retrieve any documents for 5 of the 16 queries. This can be due to the fact that KLEIN did not identify any intervals as bursty for all the terms in the query. Alternatively, even if such a region was identified, it did not include any documents containing all the query-terms. This could be addressed by separately tuning the parameters of the algorithm for each term. In practice, however, this is not desirable for obvious reasons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Interval Ranking</head><p>The purpose of this experiment is to evaluate the Interval Evaluation framework described in Section 5.2. The experiment is similar to the one described in the previous Section. In this case, the index built on top of each of the Newspaper Datasets was the one described in 5.2, which considers term burstiness to index intervals rather than documents. Also, the TA * Algorithm was used to evaluate the queries from the Major Events List. For each event, we identify the interval among the reported 10 that is closest to the actual date of the event. We then report the start and end dates of that interval. The process is again repeated 3 times, each time using one of the three burst-detection algorithms. The results are shown in Table <ref type="bibr" target="#b4">(4)</ref>.</p><p>Both MAX-1 and MAX-2 produce reasonable intervals for the evaluated queries. As anticipated, MAX-2 gives tighter intervals, which commonly span a few days or weeks around the actual date of the event. The intervals produced by KLEIN are of similar or smaller length. Also, no bursty intervals were identified for queries 3, 5, 12, 14 and 16. As discussed in Section 6.2, even though the algorithm could be tuned to report larger segments, this would also reduce the number of states and thus have an adverse effect top-k evaluation.</p><p>In general, KLEIN produced accurate results, indicating that our search framework is compatible with any efficient burstdetection method. Finally, it is also important to note that, for all three algorithms, the intervals closest to the actual event date were always ranked first in the top-10 list.</p><p>In order to illustrate the utility of the proposed Interval Evaluation Framework, we do an additional experiment: let A be the set of all articles within the interval reported by a query. Also, let V be the set of distinct terms appearing in the titles of the articles in A. We then report the top-10 terms from V, ranked in descending order on the number of titles they appeared in. For lack of space, we only report the results reported by MAX-2, since it produced the most reasonable intervals for all the queries in the Major Events List. The results, shown in Table <ref type="bibr" target="#b5">(5)</ref>, prove that the documents of a top-k interval can be used to identify terms that describe the underlying event. In the context of a search engine, these terms can compose an informative cloud that suggests insightful queries to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Index Statistics</head><p>In this experiment, we show that, by focusing only on bursty intervals, we can greatly reduce the number of documents mapped to each term. This fact, combined with the high-quality results shown in the previous experiments, proves that our index structure is compact, while preserving all the useful information for each term.</p><p>First, we build the Document Evaluation framework, described in Section 5.1, for each of the three Newspaper Datasets. For each dataset, we compute the average number of documents mapped to a term. The process is repeated 3 times, once for each of the three burst-detection algorithms. We compare against Lucene, which essentially maps each term to all the documents that include it. A similar evaluation is done for the Interval Evaluation Framework, described in Section 5.2: for each term, we compute the percentage of the timeline (spanned by each collection) that is covered by bursty intervals. We then report the average over all terms. The results are shown in in Table <ref type="bibr" target="#b2">(2)</ref>. As can be seen from the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>In this paper we explored how term burstiness can be used to enhance the search process for large document sequences. We provided a formal definition of burstiness and proposed efficient, parameter-free algorithms for the identification of bursty intervals for any given term. The main contribution of our work is an efficient search framework that considers term burstiness in the indexing and ranking process. We describe two alternative versions of our framework, and discuss how they can be useful to a user querying a document sequence. Finally, we thoroughly evaluated our approaches on a new dataset, in the context of different scenarios. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(4.4) and (4.5) in Eq. (4.2), we get:DP (I) = len(Yt[l : r]) m -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Problem 3 .Figure 1 :</head><label>31</label><figDesc>Figure 1: Burstiness sequence Bt for t="earthquake"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 1 :</head><label>1</label><figDesc>MAX-2 Input: I: Set of first-level maximal intervals for Yt Output: I : Set of second-level maximal intervals for Yt 1: I ← ∅ 2: for every interval I ∈ I do 3: I ← I ∪MAX-1(I) // MAX-1 returns 1st level intervals 4: Return I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Procedure 1</head><label>1</label><figDesc>RandomAccess(Interval I, Interval List L) Return a set of intervals I, s.t. ∀ I ∈ L, where I ∩ I = ∅, ∃I * ∈ I, where I * = I ∩ I AND I * .score = I.score + I .score Algorithm 3 TA * Algorithm Input: query q = {t0, t1, ...}, int k Output: Set of top-k Intervals 1: TopK ← ∅ // sorted, holds at most k distinct elements 2: Threshold T ← 0 3: L ← {L0, L1, ..} // set of Doc Lists for each term in q 4: while (Not All lists in L Have Been Exhausted) do 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>t∈q B(t, super(It, I)) = 6 + 4 + 5 + 4 = 19.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Interval Merging Process</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Achieved Precision on Major Events List</figDesc><table><row><cell>ID</cell><cell cols="2">Lucene</cell><cell cols="2">MAX-1</cell><cell cols="2">MAX-2</cell><cell cols="2">KLEIN</cell></row><row><cell>1</cell><cell>1/5</cell><cell>2/10</cell><cell cols="3">5/5 10/10 5/5</cell><cell>9/10</cell><cell>5/5</cell><cell>8/10</cell></row><row><cell>2</cell><cell>3/5</cell><cell>5/10</cell><cell>5/5</cell><cell>7/10</cell><cell>5/5</cell><cell>8/10</cell><cell>5/5</cell><cell>8/10</cell></row><row><cell>3</cell><cell>3/5</cell><cell>6/10</cell><cell cols="4">5/5 10/10 5/5 10/10</cell><cell>-</cell><cell>-</cell></row><row><cell>4</cell><cell>3/5</cell><cell>7/10</cell><cell cols="6">5/5 10/10 5/5 10/10 5/5 10/10</cell></row><row><cell>5</cell><cell>1/5</cell><cell>2/10</cell><cell>3/5</cell><cell>6/10</cell><cell>4/5</cell><cell>8/10</cell><cell>-</cell><cell>-</cell></row><row><cell>6</cell><cell>4/5</cell><cell>6/10</cell><cell>5/5</cell><cell>9/10</cell><cell>5/5</cell><cell>9/10</cell><cell cols="2">5/5 10/10</cell></row><row><cell>7</cell><cell>3/5</cell><cell>6/10</cell><cell cols="5">5/5 10/10 5/5 10/10 4/5</cell><cell>9/10</cell></row><row><cell>8</cell><cell>3/5</cell><cell>4/10</cell><cell cols="5">5/5 10/10 5/5 10/10 4/5</cell><cell>9/10</cell></row><row><cell>9</cell><cell>5/5</cell><cell>9/10</cell><cell cols="5">5/5 10/10 5/5 10/10 5/5</cell><cell>9/10</cell></row><row><cell>10</cell><cell>0/5</cell><cell>1/10</cell><cell cols="6">5/5 10/10 5/5 10/10 5/5 10/10</cell></row><row><cell>11</cell><cell cols="8">5/5 10/10 5/5 10/10 5/5 10/10 5/5 10/10</cell></row><row><cell>12</cell><cell>4/5</cell><cell>8/10</cell><cell cols="4">5/5 10/10 5/5 10/10</cell><cell>-</cell><cell>-</cell></row><row><cell>13</cell><cell>3/5</cell><cell>6/10</cell><cell cols="5">5/5 10/10 5/5 10/10 5/5</cell><cell>8/10</cell></row><row><cell>14</cell><cell>4/5</cell><cell>7/10</cell><cell>5/5</cell><cell>8/10</cell><cell>5/5</cell><cell>7/10</cell><cell>-</cell><cell>-</cell></row><row><cell>15</cell><cell>3/5</cell><cell>5/10</cell><cell>4/5</cell><cell>8/10</cell><cell>5/5</cell><cell>9/10</cell><cell>5/5</cell><cell>7/10</cell></row><row><cell>16</cell><cell>2/5</cell><cell>2/10</cell><cell>5/5</cell><cell>9/10</cell><cell>5/5</cell><cell>9/10</cell><cell>-</cell><cell>-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Table, our framework achieves a Statistics Table</figDesc><table><row><cell></cell><cell cols="2">SF-Call-1 SF-Call-2</cell><cell>SF-Call-3</cell></row><row><cell cols="4">Avg. number of documents per term</cell></row><row><cell>Lucene</cell><cell>124.45</cell><cell>119.3</cell><cell>112.4</cell></row><row><cell>MAX-1</cell><cell>85.6</cell><cell>83.5</cell><cell>74.9</cell></row><row><cell>MAX-2</cell><cell>73.5</cell><cell>75.2</cell><cell>63.2</cell></row><row><cell>KLEIN</cell><cell>72.35</cell><cell>74.9</cell><cell>72.7</cell></row><row><cell cols="4">Avg. covered timeline % per term</cell></row><row><cell>MAX-1</cell><cell>0.27</cell><cell>0.24</cell><cell>0.27</cell></row><row><cell>MAX-2</cell><cell>0.09</cell><cell>0.08</cell><cell>0.08</cell></row><row><cell>KLEIN</cell><cell>0.1</cell><cell>0.12</cell><cell>0.14</cell></row><row><cell cols="4">significant reduction in the number of documents. As antic-</cell></row><row><cell cols="4">ipated, MAX-2 and KLEIN result in higher reductions, since</cell></row></table><note><p>they generally produce smaller intervals. Further, only a small percentage (as low as 8%) of the timeline is covered by bursty intervals. Nonetheless, as illustrated by our previous experiments, these intervals provide all the information that our search framework needs to effectively evaluate queries.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Major Events List ID Description Date Query 1 Mormon Leader B. H. Roberts is refused a seat in the US Congress due to his polygamy. Jan 17 1900 polygamy 2 The German passenger ship Saale, owned by the North German Lloyd, catches fire at the docks in Hoboken, killing 326 people. British troops under Colonel Francis Younghusband battle with Tibetan Troops, marking the beginning of the British Expedition to Tibet Mar 31 1904 guru 12 A fire aboard the steamboat General Slocum in New York City's East River kills 1,021. Jun 15 1904 steamboat disaster 13 Eugen Schauman assassinates Nikolai Bobrikov, Governor-General of Finland Jun 16 1904 finland governor 14 King Carlos I of Portugal and Prince Luiz are shot dead in Lisbon. Feb 1 1908 carlos luiz 15 Louis Bleriot is the first man to fly across the English Channel in an aircraft. Richter scale earthquake destroys Messina, Sicily and rocks Calabria, killing over 75,000 people and living thousands homeless.</figDesc><table><row><cell>Jun 30 1900</cell><cell>saale</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Predicted Intervals for Major EventsEvent ID</figDesc><table><row><cell></cell><cell>Actual Date</cell><cell>MAX-1</cell><cell>MAX-2</cell><cell>KLEIN</cell></row><row><cell>1</cell><cell>Jan 17 1900</cell><cell>5 Jan -3 Apr (1900)</cell><cell>5 Jan -26 Jan (1900)</cell><cell>5 Jan -23 Jan (1900)</cell></row><row><cell>2</cell><cell>June 30 1900</cell><cell>25 Jan -12 Jul (1900)</cell><cell>1 Jul -12 Jul (1900)</cell><cell>1 Jul -12 Jul (1900)</cell></row><row><cell>3</cell><cell>Jul 29 1900</cell><cell>15 Jul -19 Aug (1900)</cell><cell>30 Jul -5 Aug (1900)</cell><cell>-</cell></row><row><cell>4</cell><cell>Sep 8 1900</cell><cell>3 Sep -10 Mar (1900/01)</cell><cell>9 Sep -6 Oct (1900)</cell><cell>10 Sep -14 Sep (1900)</cell></row><row><cell>5</cell><cell>Jan 22 1901</cell><cell>5 Oct -17 Mar (1900/01)</cell><cell>28 Dec -8 Feb (1900/01)</cell><cell>-</cell></row><row><cell>6</cell><cell>May 3 1901</cell><cell>24 Apr -29 Jul (1901)</cell><cell>27 Apr -20 May (1901)</cell><cell>4 May -23 May (1901)</cell></row><row><cell>7</cell><cell>Jun 11 1903</cell><cell>11 Jun -25 Oct (1903)</cell><cell>12 Jun -25 Jun (1903)</cell><cell>12 Jun -19 Jun (1903)</cell></row><row><cell>8</cell><cell>July 20 1903</cell><cell>5 Jul -4 Jan (1903/04)</cell><cell>7 Jul -22 Jul (1903)</cell><cell>20 Jul -22 Jul (1903)</cell></row><row><cell>9</cell><cell>Dec 30 1903</cell><cell>22 Dec -20 Aug (1903/04)</cell><cell cols="2">31 Dec -26 Jan (1903/04) 31 Dec -17 Jan (1903/04)</cell></row><row><cell>10</cell><cell>February 7 1904</cell><cell>19 Jul -20 Mar (1903/04)</cell><cell>5 Feb -20 Feb (1904)</cell><cell>8 Feb -20 Feb (1904)</cell></row><row><cell>11</cell><cell>Mar 31 1904</cell><cell>1 Apr -6 Apr (1904)</cell><cell>3 Apr -5 Apr (1904)</cell><cell>1 Apr -6 Apr (1904)</cell></row><row><cell>12</cell><cell>Jun 15 1904</cell><cell>14 May -4 Sep 1904 (1904)</cell><cell>16 Jun -20 Jun (1904)</cell><cell>-</cell></row><row><cell>13</cell><cell>Jun 16 1904</cell><cell>20 Mar -30 Oct (1904)</cell><cell>17 Jun -31 Jul (1904)</cell><cell>20 Jun -23 Jun (1904)</cell></row><row><cell>14</cell><cell>Feb 1 1908</cell><cell>2 Feb -20 Feb (1908)</cell><cell>2 Feb -11 Feb (1908)</cell><cell>-</cell></row><row><cell>15</cell><cell>Jul 25 1909</cell><cell>5 Mar -10 Nov (1909)</cell><cell>19 Jun -8 Aug (1909)</cell><cell>18 Jul -27 Jul (1909)</cell></row><row><cell>16</cell><cell>Dec 28 1909</cell><cell>28 Nov -28 Oct (1908/09)</cell><cell>26 Dec -18 Jan (1908/09)</cell><cell>-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Frequent keywords extracted from the top-k documents for each query ID Cloud 1 January state washington roberts present practice utah member house law 2 burn german york lloyd bodies fires recovered north river hoboken 3 humbert july state anarchist italiy unit rome bressi general police 4 city people galveston state sufferers received great money reported relief 5 state present great king queen people passed service palace city 6 city people fire state florida unite part sufferers generous report 7 belgrade queen peter officers alexander minister murder governor assassin palace 8 july leo rome cardinal holy pontiff church vatican present great 9 chicago fire place city building iroquois work time manager people 10 February state city general york fire company aid busy american 11 tibet british fight chinese mission general hostile colonel petersburg influence 12 bodies general york slocum fire boat hoboken police dead 13 general bobrikoff russia petersburg assassin government author people condition land 14 queen king crown assassination portugal prince oporto royal brother lisbon 15 flight july miles aviator attempt cross return bleriot condition machine 16 italian earthquake people city aid messina sufferers ruins relief stricken</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>This work was supported by NSF IIS-0534781, NSF 0803410, the ONR N00014-07-C-0311 Aware, the Healthe-Child, and the SemsorGrid4Env projects.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The hunting of the bump: on maximizing statistical discrepancy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatasubramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA &apos;06</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="1137" to="1146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Blogscope: a system for online analysis of high volume text streams</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<idno>VLDB &apos;07</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">BlogScope: spatio-temporal analysis of the blogosphere</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In WWW &apos;07</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The discrepancy method: randomness and complexity</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chazelle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Improved algorithmms for the k maximum-sums problems</title>
		<author>
			<persName><forename type="first">C.-H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">362</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="162" to="170" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-09">September 2001</date>
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
	<note>Introduction to Algorithms, Second Edition</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Computing the maximum bichromatic discrepancy, with applications to computer graphics and machine learning</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Maass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="453" to="470" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computing the discrepancy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCG &apos;93</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="47" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optimal aggregation algorithms for middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS &apos;01</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Parameter free bursty events detection in text streams</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P C</forename><surname>Fung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Analyzing feature trajectories for event detection</title>
		<author>
			<persName><forename type="first">Q</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-P</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR &apos;07</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Bursty feature representation for clustering text streams</title>
		<author>
			<persName><forename type="first">Q</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-P</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIAM &apos;07</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Bursty and hierarchical structure in streams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD &apos;02</title>
		<meeting><address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="91" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">On the bursty evolution of blogspace</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Novak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tomkins</surname></persName>
		</author>
		<idno>WWW &apos;03</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Using burstiness to improve clustering of topics in news streams</title>
		<author>
			<persName><forename type="first">Qi</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuiyu</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ee-Peng</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM &apos;07</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A linear time algorithm for finding all maximal scoring subsequences</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Ruzzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tompa</surname></persName>
		</author>
		<idno>ISMB 1999</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Identifying similarities, periodicities and bursts for online search queries</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vlachos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Meek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vagena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;04</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="131" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient elastic burst detection in data streams</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD &apos;03</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="336" to="345" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
