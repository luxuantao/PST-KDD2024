<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatic Predicate Abstraction of C Programs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Ball</surname></persName>
							<email>tball@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Rupak</forename><surname>Majumdar</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Todd</forename><surname>Millstein</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sriram</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
							<email>sriram@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Univ</forename><surname>Of Washington</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research U.C. Berkeley</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Automatic Predicate Abstraction of C Programs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">097DD1085EAAF57B38627EFD26000225</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Model checking has been widely successful in validating and debugging designs in the hardware and protocol domains. However, state-space explosion limits the applicability of model checking tools, so model checkers typically operate on abstractions of systems.</p><p>Recently, there has been significant interest in applying model checking to software. For infinite-state systems like software, abstraction is even more critical. Techniques for abstracting software are a prerequisite to making software model checking a reality.</p><p>We present the first algorithm to automatically construct a predicate abstraction of programs written in an industrial programming language such as C, and its implementation in a tool -C2bp. The C2bp tool is part of the SLAM toolkit, which uses a combination of predicate abstraction, model checking, symbolic reasoning, and iterative refinement to statically check temporal safety properties of programs.</p><p>Predicate abstraction of software has many applications, including detecting program errors, synthesizing program invariants, and improving the precision of program analyses through predicate sensitivity. We discuss our experience applying the C2bp predicate abstraction tool to a variety of problems, ranging from checking that list-manipulating code preserves heap invariants to finding errors in Windows NT device drivers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the hardware and protocol domains, model checking has been used to validate and debug systems by algorithmic exploration of their state spaces. State-space explosion is a major limitation, and typically model checkers explore the state space of an abstracted system. For software, which Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLDI 2001, Snowbird, Utah, USA. Copyright 2001 ACM 0-89791-88-6/97/05...$5.00 is typically infinite-state, abstraction is even more critical. Any effort to model check software must first construct an abstract model of the software.</p><p>A promising approach to construct abstractions automatically, called predicate abstraction, was first proposed by Graf and Saïdi <ref type="bibr" target="#b18">[19]</ref>. With predicate abstraction, the concrete states of a system are mapped to abstract states according to their evaluation under a finite set of predicates. Automatic predicate abstraction algorithms have been designed and implemented before for finite-state systems and for infinite-state systems specified as guarded commands. However, no one has demonstrated automatic predicate abstraction on a programming language such as C.</p><p>We present a tool called C2bp that performs automatic predicate abstraction of C programs. Given a C program P and a set E of predicates (pure C boolean expressions containing no function calls), C2bp automatically creates a boolean program BP(P, E), which is an abstraction of P . A boolean program is essentially a C program in which the only type available is boolean (the boolean program language has some additional constructs that will be presented later). The boolean program has the same control-flow structure as P but contains only |E| boolean variables, each representing a predicate in E. For example, if the predicate (x &lt; y) is in E, where x and y are integer variables in P , then there is a boolean variable in BP(P, E) whose truth at a program point p implies that (x &lt; y) is true at p in P . For each statement s of P , C2bp automatically constructs the corresponding boolean transfer functions that conservatively represent the effect of s on the predicates in E. The resulting boolean program can be analyzed precisely using a tool called Bebop <ref type="bibr" target="#b4">[5]</ref> that performs interprocedural dataflow analysis <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b27">28]</ref> using binary decision diagrams.</p><p>We present the details of the C2bp algorithm, as well as results from applying C2bp to a variety of problems and programs:</p><p>• We have applied C2bp and Bebop to pointermanipulating programs to identify invariants involving pointers. In one example, these invariants lead to more precise aliasing information than is possible with a flowsensitive alias analysis. In another example, we show that list-manipulating code preserves various structural properties of the heap, as has been done with shape analysis <ref type="bibr" target="#b29">[30]</ref>. This is noteworthy because our predicate language is a quantifier-free logic, rather than the more powerful logic of <ref type="bibr" target="#b29">[30]</ref>.</p><p>• We have applied C2bp and Bebop to examples from Necula's work on proof-carrying code <ref type="bibr" target="#b25">[26]</ref> to automatically identify loop invariants in these examples that the PCC compiler was required to generate.</p><p>• We have used C2bp in the SLAM toolkit to check temporal safety properties of Windows NT device drivers.</p><p>The SLAM toolkit uses C2bp and Bebop to statically determine whether or not an assertion violation can take place in C code. A unique part of the toolkit is its use of a demand-driven iterative process to automatically find predicates that are relevant to the particular assertion under examination. When the current set of predicates and the boolean program abstraction that it induces are insufficient to show that an assertion does/doesn't fail, new predicates are found to refine the abstraction. Although the SLAM process may not converge in theory, due to the undecidability of the assertion violation problem, it has converged on all NT device drivers we have analyzed (even though they contain loops).</p><p>For a detailed proof of soundness of the abstraction algorithm presented in this paper, the interested reader is referred to our technical report <ref type="bibr" target="#b2">[3]</ref>. In work with Andreas Podelski <ref type="bibr" target="#b3">[4]</ref> we have used the framework of abstraction interpretation to formalize the precision of the C2bp algorithm for single procedure programs with no pointers. Section 4.6 reviews the soundness theorem for C2bp that we have proved and describes our precision results.</p><p>The rest of this paper is organized as follows. Section 2 gives an example of applying C2bp to a pointermanipulating C procedure. Section 3 lists the challenges in performing predicate abstraction on C programs. Section 4 describes our predicate abstraction algorithm in detail. Section 5 describes extensions and optimizations to the C2bp tool. Section 6 presents results on applying the C2bp tool to a variety of C programs. Section 7 reviews related work and Section 8 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Example:</head><p>Invariant Detection in Pointermanipulating Programs This section presents the application of C2bp and the Bebop model checker to a pointer-manipulating procedure. The combination of the two tools determines program-pointspecific invariants about the procedure, which can be used to refine pointer aliasing information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">C2bp</head><p>Consider the partition function of Figure <ref type="figure" target="#fig_0">1(a)</ref>. This procedure takes a pointer to a list of integers l and an integer v and partitions the list into two lists: one containing the cells with value greater than v (returned by the function) and the other containing the cells with value less than or equal to v (the original list, destructively updated).</p><p>We input the program in Figure <ref type="figure" target="#fig_0">1</ref>(a) along with the following predicate input file to C2bp:</p><formula xml:id="formula_0">partition { curr == NULL, prev == NULL, curr-&gt;val &gt; v, prev-&gt;val &gt; v }</formula><p>The predicate input file specifies a set of four predicates, local to the procedure partition. Figure <ref type="figure" target="#fig_0">1</ref>(b) shows the boolean program resulting from the abstraction of the procedure partition with respect to these predicates. <ref type="foot" target="#foot_0">1</ref> The boolean program declares four variables of type bool in procedure partition, each corresponding to one of the four predicates from the predicate input file. <ref type="foot" target="#foot_1">2</ref> The variables' initial values are unconstrained.</p><p>The boolean program is guaranteed to be an abstraction of the C program in the following sense: any feasible execution path of the C program is a feasible execution path of the boolean program. Of course, there may be feasible execution paths of the boolean program that are infeasible in the C program. Such paths can lead to imprecision in subsequent model checking.</p><p>We now informally describe how the C2bp tool translates each statement of the C program into a corresponding set of statements in the boolean program. An assignment statement in the C program is translated to a set of assignments that capture the effect of the original assignment statement on the input predicates. For example, the assignment statement "prev=NULL;" in the C program is translated to two assignment statements in the boolean program. The first, "{prev==NULL}=true;", reflects the truth of the predicate (prev = NULL) after the assignment. The value of the predicate (prev → val &gt; v) is undefined after this assignment and is thus invalidated by the assignment statement "{prev-&gt;val&gt;v} = unknown();". The unknown function is defined as: bool unknown() { if (*) { return true; } else { return false; } }</p><p>The unknown function uses the control expression "*", which non-deterministically chooses the then or the else branch, to return either true or false.</p><p>The C2bp tool determines that the other two predicates are unaffected by the assignment "prev=NULL;", so they need not be updated. The C2bp tool uses a flowinsensitive points-to analysis <ref type="bibr" target="#b11">[12]</ref> to resolve aliases between pointers. In this program, since none of the pointer variables in the set { curr, prev, next, newl } has its address taken, none of these variables can be aliased by any other expression in the procedure. As a result, C2bp resolves that the only predicates that the assignment "prev=NULL;" affects are (prev = NULL) and (prev → val &gt; v).</p><p>As another example, the assignment "prev=curr;" is also abstracted to assignments to the two predicates involving prev. These predicates are assigned the values of the corresponding predicates on curr, as expected. Finally, C2bp determines that the assignment "newl=NULL;" cannot affect any of the four input predicates, so the assignment is translated to the skip statement, the boolean program's "no-op".</p><p>In the above examples, most of the input predicates are updated accurately. For example, the assignment "{prev==NULL}={curr==NULL};" in the boolean program exactly represents the effect of the assignment "prev=curr" on the predicate (prev = NULL). However, it is possible for such exact information to be unavailable, because some of the necessary predicates have not been input to C2bp. In that case, we must replace exact information with a conservative approximation. For example, the assignment "curr=nextCurr;" can affect the two predicates involving curr. However, because there are no predicates about nextCurr in the predicate input file, there is no way to deduce the correct truth value of these predicates. This represents a worst case of sorts, as the input predicates provide absolutely no information about the appropriate truth values for the two predicates to be updated. As a result, the two predicates are "invalidated" using the unknown function, as defined above. The C2bp tool translates conditional statements in the C program into non-deterministic conditional statements in the boolean program, using the control expression "*". However, it also inserts "assume" statements to capture the semantics of conditionals with respect to the input predicates. For example, the first statement inside the while loop is "assume(!{curr==NULL});". The assume acts as a filter on the state space of the boolean program: in this case, it is impossible to reach the program point after the assume if the variable {curr==NULL} is true. In this way, we faithfully model the guard of the original while loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Bebop</head><p>The boolean program output by C2bp is input to the Bebop model checker <ref type="bibr" target="#b4">[5]</ref>, which computes the set of reachable states for each statement of a boolean program using an interprocedural dataflow analysis algorithm in the spirit of Sharir-Pnueli and Reps-Horwitz-Sagiv <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b27">28]</ref>. A state of a boolean program at a statement s is simply a valuation to the boolean variables that are in scope at statement s (in other words, a bit vector, with one bit for each variable in scope). The set of reachable states (or invariant) of a boolean program at s is thus a set of bit vectors (equivalently, a boolean function over the set of variables in scope at s).</p><p>Bebop differs from typical implementations of dataflow algorithms in two crucial ways. First, it computes over sets of bit vectors at each statement rather than single bit vectors. This is necessary to capture correlations between variables. Second, it uses binary decision diagrams <ref type="bibr" target="#b8">[9]</ref> (BDDs) to implicitly represent the set of reachable states of a program, as well as the transfer functions for each statement in a boolean program. However, Bebop uses an explicit control-flow graph representation, as in a compiler, rather than encoding the control-flow with BDDs, as done in most symbolic model checkers.</p><p>For our example, Bebop outputs the following invariant representing the reachable states at label L of the boolean program:</p><formula xml:id="formula_1">(curr = NULL) ∧ (curr → val &gt; v) ∧ ((prev → val ≤ v) ∨ (prev = NULL))</formula><p>Because C2bp is sound, this boolean function is also an invariant over the state of the C program at label L.</p><p>Such invariants can be used for many different purposes; we give several examples in Section 6. One interesting usage of the above invariant is to refine alias information. In particular, the invariant implies that *prev and *curr are never aliases at label L in the procedure partition. In other words, variables prev and curr never point to the same memory location at label L. This can be seen as follows:</p><p>• If (prev = NULL), then (prev = curr) because (curr = NULL).</p><p>• If (prev = NULL), then since (curr → val &gt; v) and (prev → val ≤ v), it follows that (prev → val = curr → val), which implies (prev = curr). <ref type="foot" target="#foot_2">3</ref>This fact can be deduced automatically from the given invariant. In particular, a decision procedure can determine that the invariant implies (prev = curr). In this way, we can automatically refine an existing alias analysis. Traditional flow-sensitive alias analyses would not discover that *prev and *curr are not aliases at label L, since such analyses do not use the values of fields (such as prev-&gt;val) to eliminate possible aliasing relationships.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Summary</head><p>We have shown how C2bp is used to compute a boolean program that is a sound abstraction of a C program with respect to a set of predicates E. Subsequent model checking of the boolean program can discover strong invariants that are expressed as boolean functions over the predicates in E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Challenges of Predicate Abstraction for C</head><p>The complexities of a programming language like C gives rise to several technical challenges in performing predicate abstraction:</p><p>• Pointers. There are two closely related subproblems in dealing with pointers: (1) assignments through dereferenced pointers in the original C program, and</p><p>(2) pointers and pointer dereferences in the predicates over which the abstraction is computed. We handle the two cases in a uniform manner and describe how to use points-to analysis <ref type="bibr" target="#b11">[12]</ref> to improve the precision of our abstraction.</p><p>• Procedures. Programs with procedures are handled by allowing procedural abstraction in the target language <ref type="bibr" target="#b4">[5]</ref>. In particular, boolean programs have global variables, procedures with local variables, and call-byvalue parameter passing. Having explicit procedures allows us to make both abstraction and analysis more efficient by exploiting procedural abstraction present in the C program. It also allows us to handle recursive and mutually recursive procedures with no additional mechanism. This differs from most other approaches to software model checking, which inline procedure calls <ref type="bibr" target="#b9">[10]</ref>.</p><p>In the following section, we describe a modular abstraction process for procedures: each procedure can be abstracted given only the signatures of the abstractions of its callees, and such signatures can be constructed for each procedure in isolation.</p><p>• Procedure calls. The abstraction process for procedure calls is challenging, particularly in the presence of pointers. After a call, the caller must conservatively update local state that may have been modified by the callee. We provide a sound and precise approach to abstracting procedure calls that takes such side-effects into account.</p><p>• Unknown values. It is not always possible to determine the effect of a statement in the C program on a predicate, in terms of the input predicate set E. We deal with such non-determinism directly in the boolean program via the non-deterministic control expression "*", which allows us to implicitly express a three-valued domain for boolean variables.</p><p>• Precision-efficiency tradeoff. Computing the abstract transfer function for each statement in the C program with respect to the set E of predicates may require the use of a theorem prover. Obtaining a precise abstract transfer function requires O(2 |E| ) calls to the theorem prover, in the worst case. We have explored several optimization techniques to reduce the number of calls made to the theorem prover. Some of these techniques result in an equivalent boolean program, while others trade off precision for computation speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Predicate Abstraction</head><p>This section describes the design and implementation of C2bp in detail. Given a C program P and a set E = {ϕ1, ϕ2, . . . , ϕn} of pure boolean C expressions over the variables of P and constants of the C language, C2bp automatically constructs an abstraction of P with respect to E <ref type="bibr" target="#b18">[19]</ref>. This abstraction is represented as a boolean program BP(P, E), which is a program that has identical control structure to P but contains only boolean variables. In particular, BP(P, E) contains n boolean variables V = {b1, b2, . . . , bn}, where each boolean variable bi represents the predicate ϕi (1 ≤ i ≤ n). As described in Section 4.6, BP(P, E) is guaranteed to be an abstraction of P in that the set of execution traces of BP(P, E) is a superset of the set of execution traces of P .</p><p>Our tool handles all syntactic constructs of the C language, including pointers, structures, and procedures. Its main limitation is that it uses a logical model of memory when analyzing C programs. That is, it models the expression p+i, where p is a pointer and i is an integer, as yielding a pointer value that points to the object pointed to by p.</p><p>In the sequel, we assume that the C program has been converted into a simple intermediate form in which: (1) all intraprocedural control-flow is accomplished with if-thenelse statements and gotos; (2) all expressions are free of side-effects and short-circuit evaluation and do not contain multiple dereferences of a pointer (e.g., **p); (3) a function call only occurs at the top-most level of an expression (for example, "z=x+f(y);" is replaced by "t=f(y); z=x+t;").</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Weakest Preconditions and Cubes</head><p>For a statement s and a predicate ϕ, let W P (s, ϕ) denote the weakest liberal precondition <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b19">20]</ref> of ϕ with respect to statement s. W P (s, ϕ) is defined as the weakest predicate whose truth before s entails the truth of ϕ after s terminates (if it terminates). Let "x = e" be an assignment, where x is a scalar variable and e is an expression of the appropriate type. Let ϕ be a predicate. By definition W P (x = e, ϕ) is ϕ with all occurrences of x replaced with e, denoted ϕ[e/x]. For example:</p><formula xml:id="formula_2">W P (x=x+1, x &lt; 5) = (x + 1) &lt; 5 = (x &lt; 4)</formula><p>The weakest precondition computation is central to the predicate abstraction process. Suppose statement s occurs between program points p and p . If ϕ is a predicate in E with corresponding boolean variable b then it is safe to assign b the value true in BP(P, E) between program points p and p if the boolean variable b corresponding to W P (s, ϕ) is true at program point p. However, no such variable b may exist if W P (s, ϕ) is not in E. For example, suppose E = {(x &lt; 5), (x = 2)}. We have seen that W P (x=x+1, x &lt; 5) = (x &lt; 4), but the predicate (x &lt; 4) is not in E. In this case, C2bp uses decision procedures (i.e., a theorem prover) to strengthen the weakest precondition to an expression over the predicates in E. In our example, we can show that (x = 2) ⇒ (x &lt; 4). Therefore if (x = 2) is true before "x=x+1;", then (x &lt; 5) is true afterwards.</p><p>We formalize this strengthening of a predicate as follows. A cube over V is a conjunction ci 1 ∧ . . . ∧ ci k , where each ci j ∈ {bi j , ¬bi j } for some bi j ∈ V . For a variable bi ∈ V , let E(bi) denote the corresponding predicate ϕi, and let E(¬bi) denote the predicate ¬ϕi. Extend E to cubes and disjunctions of cubes in the natural way. For any predicate ϕ and set of boolean variables V , let FV (ϕ) denote the largest disjunction of cubes c over V such that E(c) implies ϕ. The predicate E(FV (ϕ)) represents the weakest predicate over E(V ) that implies ϕ. In our example, E(FV (x &lt; 4)) = (x = 2).</p><p>It will also be useful to define a corresponding weakening of a predicate. Define GV (ϕ) as ¬FV (¬ϕ). The predicate E(GV (ϕ)) represents the strongest predicate over E(V ) that is implied by ϕ.</p><p>For each cube, the implication check involves a call to a theorem prover implementing the required decision procedures. Our implementation of C2bp uses two theorem provers: Simplify <ref type="bibr" target="#b14">[15]</ref> and Vampyre <ref type="bibr" target="#b6">[7]</ref>, both Nelson-Oppen style provers <ref type="bibr" target="#b26">[27]</ref>. A naive computation of FV (•) and GV (•) requires exponentially many calls to the theorem prover in the worst case. Section 5 describes several optimizations that make the FV and GV computations practical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Pointers and aliasing</head><p>In the presence of pointers, W P (x=e, ϕ) is not necessarily ϕ[e/x]. As an example, W P (x = 3, * p &gt; 5) is not ( * p &gt; 5) because if x and * p are aliases, then ( * p &gt; 5) cannot be true after the assignment to x. A similar problem occurs when a pointer dereference is on the left-hand side of the assignment.</p><p>To handle these problems, we adapt Morris' general axiom of assignment <ref type="bibr" target="#b24">[25]</ref>. A location is either a variable, a int bar(int* q, int y) { bar { int l1, l2; y &gt;= 0, ... *q &lt;= y, return l1; y == l1, } y &gt; l2 } void foo(int* p, int x) { foo { int r; *p &lt;= 0, if (*p &lt;= x)</p><p>x == 0, *p = x; r == 0 else } *p = *p + x; r = bar(p, x); ... } Figure <ref type="figure">2</ref>: An example input to C2bp. On the left are two simple C procedures (bar is not shown in its entirety). On the right is the set of predicates to model. structure field access from a location, or a dereference of a location. Consider the computation of W P (x=e, ϕ), where x is a location, and let y be a location mentioned in the predicate ϕ. Then there are two cases to consider: either x and y are aliases, and hence the assignment of e to x will cause the value of y to become e; or they are not aliases, and the assignment to x leaves y unchanged. Define In the absence of alias information, if the predicate ϕ has k locations occurring in it, the weakest precondition will have 2 k syntactic disjuncts, each disjunct considering a possible alias scenario of the k locations with x. C2bp uses a pointer analysis to improve the precision of the weakest precondition computation. If the pointer analysis says that x and y cannot be aliased at the program point before x=e, then we can prune the disjuncts representing a scenario where x is aliased to y, and we can partially evaluate the disjuncts representing a scenario where x is not aliased to y. This has the effect of improving the precision of the resulting boolean program BP(P, E) produced by C2bp. Our implementation uses Das's points-to algorithm <ref type="bibr" target="#b11">[12]</ref> to obtain flow-insensitive, context-insensitive may-alias information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Predicate Abstraction of Assignments</head><p>Consider an assignment statement "x = e;" at label in P . The boolean program BP(P, E) produced by C2bp will contain at label a parallel assignment to the boolean variables in scope at . A boolean variable bi in BP(P, E) can have the value true after if FV (W P (x = e, ϕi)) holds before . Similarly, bi can have the value false after if FV (W P (x = e, ¬ϕi)) holds before . Note that these two predicates cannot be simultaneously true. Finally, if neither of these predicates holds before , then bi should be set non-deterministically. This can happen because the predicates in E are not strong enough to provide the appropriate information, or because the theorem prover is incomplete. Therefore, BP(P, E) contains the following parallel assignment at label : where the choose function is always part of BP(P, E) and is defined as follows:</p><p>bool choose(bool pos, bool neg) { if (pos) { return true; } if (neg) { return false; } return unknown(); } For example, consider abstracting the statement "*p=*p+x" in procedure foo of Figure <ref type="figure">2</ref> with respect to the three predicates declared to be local to foo. Let us call this statement s. In this example, a may-alias analysis reveals that * p cannot alias x or r. The weakest precondition W P (s, * p ≤ 0) is ( * p + x) ≤ 0, since *p cannot alias x.</p><p>We have E(FV ( * p + x ≤ 0)) = ( * p ≤ 0) ∧ (x = 0). Similarly, W P (s, ¬( * p ≤ 0)) is ¬(( * p + x) ≤ 0), and E(FV (¬( * p + x ≤ 0))) = ¬( * p ≤ 0) ∧ (x = 0). The weakest preconditions of s with respect to the predicates (x = 0) and (r = 0) are the respective predicates themselves, since * p cannot alias x or r. Thus, BP(P, E) will contain the following statement in place of the given assignment statement, where we use {e} to denote the boolean variable representing predicate e: {*p&lt;=0}, {x==0}, {r==0} = choose({*p&lt;=0} &amp;&amp; {x==0}, !{*p&lt;=0} &amp;&amp; {x==0}), choose({x==0} , !{x==0}), choose({r==0} , !{r==0});</p><p>Note that the abstraction process for assignment statements is based on weakest precondition computations that are local to each assignment and can be computed by a purely syntactic manipulation of predicates. C2bp does not compute compositions of weakest preconditions over paths with complex control flow. In particular, C2bp does not require programs to be annotated with function pre-or postconditions, or with loop invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Predicate Abstraction of Gotos and Conditionals</head><p>Every goto statement in the C program is simply copied to the boolean program.</p><p>Translating conditionals is more involved. Consider some conditional if (ϕ) {...} else {...} in program P . At the beginning of the then branch in P , the predicate ϕ holds. Therefore, at the beginning of the then branch in the corresponding conditional in BP(P, E), the condition GV (ϕ) is known to hold. Similarly, at the beginning of the else branch in P , we know that ¬ϕ holds, so GV (¬ϕ) is known to hold at that program point in BP(P, E). Therefore, BP(P, E) will contain the following abstraction of the above conditional:</p><formula xml:id="formula_3">if( * ){ assume(GV (ϕ))</formula><p>. . . }else{ assume(GV (¬ϕ)) . . . } Note that the test in the abstracted conditional is * , so both paths through the conditional are possible. Within the then and else branches, we use the assume statement to retain the semantics of the original conditional test. The assume statement is the dual of assert: assume(ϕ) never fails. Executions on which ϕ does not hold at the point of the assume are simply ignored <ref type="bibr" target="#b15">[16]</ref>.</p><p>As an example, consider the conditional in procedure foo of Figure <ref type="figure">2</ref>. The abstraction of this conditional with respect to the three predicates local to foo is:</p><formula xml:id="formula_4">if ( * ) { // if (*p &lt;= x) assume ({x == 0} =⇒ {*p &lt;= 0}); . . . } else { assume ({x == 0} =⇒ !{*p &lt;= 0});</formula><p>. . . }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Predicate Abstraction of Procedure Calls</head><p>We now describe how C2bp handles multi-procedure programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">Notation</head><p>Recall that the input to C2bp is the program P and a set E of predicates. Let GP be the global variables of the program P . Each predicate in E is annotated as being either global to BP(P, E) or local to a particular procedure in BP(P, E) (see Figure <ref type="figure">2</ref>, in which predicates are local to bar or foo -there are no global predicates in this example), thereby determining the scope of the corresponding boolean variable in BP(P, E). A global predicate can refer only to variables in GP . Let EG denote the global predicates of E and let VG denote the corresponding global boolean variables of BP(P, E).</p><p>For a procedure R, let ER denote the subset of predicates in E that are local to R, and let VR denote the corresponding local boolean variables of R in BP(P, E). In the following, we do not distinguish between a boolean variable b and its corresponding predicate E(b) when unambiguous from the context (that is, in the context of BP(P, E) we always mean b and in the context of P we always mean E(b)). Let FR be the formal parameters of R, and let LR be the local variables of R. Let r ∈ LR ∪ FR be the return variable of R (we assume, without loss of generality, that there is only one return statement in R, and it has the form "return r").</p><p>Let vars (e) be the set of variables referenced in expression e. Let drfs(e) be the set of variables dereferenced in expression e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Determining signatures</head><p>A key feature of our approach is modularity: each procedure can be abstracted by C2bp given only the signatures of procedures that it calls. The signature of procedure R can be determined in isolation from the rest of the program, given ER. C2bp operates in two passes. In the first pass it determines the signature of each procedure. It uses these signatures to abstract procedure calls (along with all other statements) in the second pass.</p><p>Let R be a procedure in P and let R be its abstraction in BP(P, E). The signature of procedure R is a four-tuple (FR, r, E f , Er), where:</p><p>• FR is the set of formal parameters of R,</p><p>• r is the return variable of R, E f is the set of formal parameter predicates of R . This is the subset of predicates in ER that do not refer to any local variables of R. All predicates in ER -E f will be locals of R . Er is the set of predicates to be returned by R (boolean programs allow procedures to have multiple return values). Such return predicates serve two purposes. One is to provide callers with information about r, the return value of R. The other purpose is to provide callers with information about any global variables and call-by-reference parameters, so that local predicates of callers can be updated precisely. To handle the first concern, Er contains those predicates in ER that mention r but do not mention any (other) locals of R in P , as callers will not know about these locals. To handle the second concern, Er contains those predicates in E f that reference a global variable or dereference a formal parameter of R.</p><formula xml:id="formula_5">• E f is</formula><p>As an example, consider procedure bar in Figure <ref type="figure">2</ref>. In the signature of bar, E f is { * q ≤ y, y ≥ 0} and Er is {y = l1, * q ≤ y}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.3">Handling procedure calls</head><p>Consider a call v = R(a1, . . . , aj) to procedure R at label of some procedure S in P . The abstraction BP(P, E) contains a call to R at label . Let the signature of R be (FR, r, E f , Er). For each formal parameter predicate e ∈ E f , C2bp computes an actual value to pass into the call. Let e = e[a1/f1, a2/f2, . . . , aj /fj ] where FR = {f1, f2, . . . , fj }. The expression e represents the predicate e translated to the calling context. The actual parameter computed for the formal e is choose(FV S ∪V G (e ), FV S ∪V G (¬e )).</p><p>We now explain how C2bp handles the return values from the call to R . Assume Er = {e1, . . . , ep}. C2bp creates p fresh local variables T = {t1, . . . , tp} in procedure S and assigns to them, in parallel, the return values of R : t1, . . . , tp = R (. . . );</p><p>The final step is to update each local predicate of S whose value may have changed as a result of the call. Any predicate in ES that mentions v must be updated. In addition, we must update any predicate in ES that mentions a global variable, a (possibly transitive) dereference of an actual parameter to the call, or an alias of either of these kinds of locations. C2bp uses the pointer alias analysis to determine a conservative over-approximation Eu to this set of predicates to update.</p><p>Let E = (ES∪EG)-Eu. The predicates in E along with the predicates in Er are used to update the predicates in Eu. Let V ⊆ VS ∪ VG be the boolean variables in BP(P, E) corresponding to E .</p><p>First C2bp translates the predicates in Er to the calling context. In particular, for each ei ∈ Er, let e i = ei[v/r, a1/f1, a2/f2, . . . , aj/fj ] and let E r = {e 1 , . . . , e p }. <ref type="foot" target="#foot_3">4</ref> Define E(ti) = e i , for each ti ∈ T . For each e ∈ Eu, the corresponding boolean variable b ∈ VS is assigned the following value:</p><formula xml:id="formula_6">choose(F V ∪T (e), F V ∪T (¬e)).</formula><p>For example, consider the call "bar(p,x)" in Figure <ref type="figure">2</ref>. Recall that in the signature of bar, the formal parameter predicates (E f ) are { * q ≤ y, y ≥ 0} and the return predicates (Er) are {y = l1, * q ≤ y}. The abstraction of this call in the boolean program is as follows: prm1 = choose({*p&lt;=0}&amp;&amp;{x==0}, // for formal {*q&lt;=y} !{*p&lt;=0}&amp;&amp;{x==0}); prm2 = choose({x==0}, false); // for formal {y&gt;=0} t1, t2 = bar(prm1, prm2); // t1 for {*q&lt;=y} // t2 for {y==l1}</p><p>{*p&lt;=0} = choose(t1&amp;&amp;{x==0}, !t1&amp;&amp;{x==0}); {r==0} = choose(t2&amp;&amp;{x==0}, !t2&amp;&amp;{x==0};</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Formal properties</head><p>We give two properties that relate P and BP(P, E). The first property, soundness, states that B is an abstraction of P -every feasible path in P is feasible in B as well. Since a boolean program that allows all paths to be feasible is sound as well, we also need to state the sense in which B is precise. We do that via the terminology of abstract interpretation <ref type="bibr" target="#b10">[11]</ref>. Soundness. For any path p feasible in P , it is guaranteed that p is feasible in BP(P, E) as well. Further, if Ω is the state of the C program P after executing path p, then there exists an execution of p in the boolean program B ending in a state Γ such that for every 1 ≤ i ≤ n, ϕi holds in Ω iff bi is true in Γ. A proof of the soundness of C2bp can be found in <ref type="bibr" target="#b2">[3]</ref>.</p><p>Precision. The framework of abstract interpretation can be used to specify abstractions declaratively. A boolean abstraction maps concrete states to abstract states according to their evaluation under a finite set of predicates. A cartesian abstraction maps a set of boolean vectors to a threevalued vector obtained by ignoring dependencies between the components of the vectors (see, for example, the work on set-based analysis <ref type="bibr" target="#b20">[21]</ref>). For example, the set of boolean vectors {(0, 1), (1, 0)} is mapped by the cartesian abstraction to the three-valued vector (?, ?), where ? represents the "don't know" value. For single procedures without pointers, the abstraction computed by C2bp is equivalent to a composition of the boolean and cartesian abstractions <ref type="bibr" target="#b3">[4]</ref>. We improve precision by using disjunctive completion and focus operations, both of which are implemented in Bebop using BDDs <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Extensions</head><p>This section describes various techniques we have applied to increase the precision and efficiency of C2bp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The enforce construct</head><p>Often the predicates in E are correlated in some way. For example, consider the predicates (x = 1) and (x = 2). The semantics associated with these predicates forbids the predicates from being simultaneously true. However, when we use uninterpreted boolean variables b1 and b2 for the predicates in BP(P, E), we do not preclude an execution of the boolean program in which both variables evaluate true in some state. In order to rule out abstract executions containing such spurious situations, we add an enforce construct to boolean programs: the statement enforce θ in a procedure has the effect of putting assume θ between every statement in the procedure. This ensures that θ is a data invariant maintained throughout the procedure's execution. We compute θ for each procedure R simply as FV R ∪V G (false). For example, given only predicates (x = 1) and</p><formula xml:id="formula_7">(x = 2), E(θ) is ¬((x = 1) ∧ (x = 2)).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Optimizations</head><p>The method described above for constructing abstract models of C programs is impractical without several important optimizations. Profiling shows that the running time of C2bp is dominated by the cost of theorem proving, as we are making an exponential number of calls to the prover at each program point. Therefore, our optimization efforts have focused on cutting down the number of calls to the theorem prover.</p><p>First, when computing FV (ϕ), cubes are considered in increasing order by length. If a cube c is shown to imply ϕ, then we know that any cube that contains c as a subset will also imply ϕ, is redundant with c, and can therefore be safely pruned. In this way, the F computation actually produces a disjunction of only the prime implicants of FV (ϕ). If a cube c does not imply ϕ but it implies ¬ϕ, then any cube that contains c as a subset also will not imply ϕ, and can therefore be safely pruned.</p><p>Second, for every assignment statement, rather than updating the values of every boolean variable in scope, we do not update those variables whose truth value will definitely not change as a result of the assignment. The truth value of a variable b will definitely not change as a result of an</p><formula xml:id="formula_8">assignment x=e if W P (x=e, E(b)) = E(b).</formula><p>Third, for each computation FV (ϕ), we perform an analysis to produce a set V ⊆ V , such that E(V ) contains all predicates from E(V ) that can possibly be part of a cube that implies ϕ. Therefore, FV (ϕ) can safely be replaced by F V (ϕ), reducing the number of cubes to explore. This set V is determined by a syntactic cone-of-influence computation. Starting with an empty set E we find predicates in E(V ) that mention a location or an alias of a location in ϕ, add these predicates to E , determine the set of locations mentioned in these predicates, and iterate until reaching a fixpoint. V ⊆ V is the set of boolean variables such that E(V ) = E . Fourth, we try several syntactic heuristics to construct FV (ϕ) directly from ϕ. As a simple example, if there exists a boolean variable b such that E(b) = ϕ, then we return b, without requiring any calls to the theorem prover. Fifth, we cache all computations by the theorem prover and the alias analysis, so that work is not repeated.</p><p>While the worst-case complexity of computing the abstraction is exponential in the number of predicates, the above optimizations dramatically reduce the number of calls made to the theorem prover in most examples. Moreover, the above optimizations all have the property that they leave the resulting BP(P, E) semantically equivalent to the boolean program produced without these optimizations. Some of the optimizations described rely on the existence of the enforce data invariant for soundness.</p><p>If we are willing to sacrifice some precision, there are other optimization opportunities. For example, we can limit the length of cubes considered in the F computation to some constant k, lowering the F function's complexity from exponential to O(n k ). In practice, we have found that setting k to 3 provides the needed precision in most cases. As another optimization, we can compute the F function only on atomic predicates. That is, we recursively convert F(ϕ1 ∧ ϕ2) to F(ϕ1) ∧ F(ϕ2) and F(ϕ1 ∨ ϕ2) to F(ϕ1) ∨ F(ϕ2). This allows us to make use of all of the existing optimizations of the F function described above in a finer-grained manner. Distribution of F through ∧ loses no precision, while distribution of F through ∨ can lose precision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experience</head><p>We have implemented C2bp in OCaml, on top of the AST toolkit (a modified version of Microsoft's C/C++ compiler that exports an abstract syntax tree interface to clients), the Simplify <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b26">27]</ref> and Vampyre <ref type="bibr" target="#b6">[7]</ref> theorem provers, and Das's points-to analysis <ref type="bibr" target="#b11">[12]</ref>.</p><p>We have applied C2bp to two problem areas: (1) checking safety properties of Windows NT device drivers, in the context of the SLAM project and the SLAM toolkit; (2) discovering invariants regarding array bounds checking and list-manipulating code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The SLAM Toolkit and its Application to NT Device Drivers</head><p>The goal of the SLAM project is to automatically check that a program respects a set of temporal safety properties of the interfaces it uses. Safety properties are the class of properties that state that "something bad does not happen". An example is requiring that a lock is never released without first being acquired (see <ref type="bibr" target="#b22">[23]</ref> for a formal definition). Given a program and a safety property, we wish to either validate that the code respects the property, or find an execution path that shows how the code violates the property. Given a safety property to check on a C program, the SLAM process has the following phases: (1) abstraction, (2) model checking, and (3) predicate discovery. We have developed the SLAM toolkit to support each of these phases:</p><p>• C2bp, which is the topic of this paper;</p><p>• Bebop, a tool for model checking boolean programs <ref type="bibr" target="#b4">[5]</ref>;</p><p>• Newton, a tool that discovers additional predicates to refine the boolean program, by analyzing the feasibility of paths in the C program (the subject of a future paper).</p><p>The SLAM toolkit provides a fully automatic way of checking temporal safety properties of system software. Violations are reported by the SLAM toolkit as paths over the program P . The toolkit never reports spurious error paths. Instead, it detects such paths and uses them to automatically refine the boolean program abstraction (to eliminate these paths from consideration). Since property checking is undecidable, the SLAM refinement algorithm may not converge. In addition, it may terminate with a "don't know" answer due to the incompleteness of the underlying theorem provers. However, in our experience, it usually converges in a few iterations with a definite answer. One reason for this is that the properties we checked are very control-intensive, and have relatively simple dependencies on data.</p><p>We ran the SLAM toolkit on four drivers from the Windows 2000 Driver Development Kit 5 , as well as an internally developed floppy device driver, to check for proper usage of locks and proper handling of interrupt request packets (see <ref type="bibr" target="#b5">[6]</ref> for the details of the properties checked). The device drivers in the DDK are supposed to be exemplars for others to base their device drivers on. For the two properties we checked, the SLAM toolkit validated these drivers (i.e., found no errors). For the floppy driver under development, the SLAM toolkit found an error in how interrupt request packets are handled.</p><p>Table <ref type="table" target="#tab_0">1</ref> shows the sizes of these drivers, the number of predicates in the predicate input file, the number of theorem prover queries that C2bp made, and the run time for C2bp. For all these examples (and those of the next section), Bebop ran in under 10 seconds on the boolean program output by C2bp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Array Bounds Checking and Heap Invariants</head><p>Table <ref type="table" target="#tab_1">2</ref> shows the results of running C2bp on a set of toy illustrative examples. The program kmp is a Knuth-Morris-Pratt string matcher and qsort is an array implementation of quicksort, both examples used by Necula <ref type="bibr" target="#b25">[26]</ref>. The program partition is the list partition example from Figure <ref type="figure" target="#fig_0">1</ref>, listfind is a list search example, and reverse is an example that reverses a list twice. In most cases, the cone-ofinfluence heuristics in C2bp were able to reduce the number of theorem prover calls to a manageable number. In the case of the reverse example, every pair of pointers could potentially alias, and the cone-of-influence heuristics could not avoid the exponential number of calls to the theorem prover.  In our experiments, we were able to construct useful invariants in the code by modeling only a few predicates that occurred in the program. For example, in the array bounds checking examples (kmp and qsort), where an array a was indexed in a loop by a variable index, we simply had to model the bounds index ≥ 0 and index ≤ length(a) in order to produce the appropriate loop invariant. We found that in most cases, the component predicates of the invariant were easy to guess by looking at the conditionals in the programs.</p><p>The list reversal example reverse is a simplified version of a mark-and-sweep garbage collector. We show the program in Figure <ref type="figure" target="#fig_4">3</ref>. In the first while loop, the list is traversed in the forward direction, while maintaining back pointers to the previous nodes. In the second loop, the pointers are reversed to get the original list. We wish to verify that the procedure mark leaves the shape of the structure unchanged: i.e., for every node h in the list, h → next points to the same node before and after the procedure mark. To check this, we introduced auxiliary variables h and hnext into the C code. The variable h is chosen non-deterministically to point at any (non-null) element of the list, and hnext is initialized with h-&gt;next. We input the following predicates to C2bp (along with the program of Figure <ref type="figure" target="#fig_4">3</ref>):</p><formula xml:id="formula_9">mark { h == 0, prev == h, this == h, this-&gt;next == hnext, prev == this, h-&gt;next == hnext, hnext-&gt;next == h }</formula><p>With this choice of predicates, C2bp constructs an abstract program which is analyzed using Bebop. Bebop shows that at the end of the mark procedure, h → next = hnext holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Our work is inspired by the predicate abstraction work of Graf and Saidi <ref type="bibr" target="#b18">[19]</ref>. Predicate abstraction has been used in the verification of cache coherence protocols <ref type="bibr" target="#b12">[13]</ref>. However, these efforts work at the specification level, on a language with guarded commands. Doing predicate abstraction on a general-purpose programming language is the novel aspect of our work. A method for constructing abstract models from Java programs has been developed in the Bandera project <ref type="bibr" target="#b16">[17]</ref>. Their tool requires the user to provide finitedomain abstractions of data types. Predicate abstraction as implemented in C2bp is more general, as it allows the finite partitioning of a variable's possible values and additionally allows relationships between variables to be defined. Another approach is to use richer type systems to model finite-state abstractions of programs <ref type="bibr" target="#b13">[14]</ref>.</p><p>Shape analysis <ref type="bibr" target="#b29">[30]</ref> also uses a form of predicate abstraction, where the predicate language is a first-order logic augmented with transitive closure. In contrast, our predicates are quantifier-free. Shape analysis requires the user to specify how each statement affects each predicate of interest, whereas the C2bp tool computes the abstract transition system automatically using a theorem prover.</p><p>Predicate abstraction is a general technique that can be used to add predicate (read "path") sensitivity to program analyses. Ammons and Larus use code duplication followed by a traditional dataflow analysis to achieve path-sensitive results <ref type="bibr" target="#b0">[1]</ref>. Bodik and Anik use symbolic back-substitution (i.e., weakest preconditions) followed by value numbering to improve the results of a subsequent three-valued dataflow analysis <ref type="bibr" target="#b7">[8]</ref>. The combination of predicate abstraction by C2bp and path-sensitive dataflow analyses in Bebop could be used to achieve similar results.</p><p>Prior work for generating loop invariants has used symbolic execution on the concrete semantics, augmented with widening heuristics <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b32">33]</ref>. The Houdini tool guesses a candidate set of annotations (invariants) and uses the ESC/Java checker to refute inconsistent annotations until convergence <ref type="bibr" target="#b17">[18]</ref>. In contrast, the tools C2bp and Bebop use a combination of abstraction (from C program to boolean program) and iterative analysis of the abstracted C program to find loop invariants expressible as boolean functions over a given set of predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>We summarize our main contributions:</p><p>• C2bp is the first predicate abstraction tool that works on a general-purpose programming language.</p><p>• We have taken efforts to handle features such as procedures and pointers in a sound and precise way.</p><p>• We have explored several optimizations to reduce the number of calls made to the theorem prover by C2bp.</p><p>• We have demonstrated the use of C2bp on programs from varying domains -device drivers, arraymanipulating programs, and pointer-manipulating programs.</p><p>Though we fully support pointers in C2bp, our predicates are quantifier-free. Stating certain properties of unbounded data structures may require a more expressive logic. For this purpose, it would be interesting to enrich the predicate language with dependent types and recursive types. Among other things, the aliasing problem becomes more complicated in this setting. For example, if T is a type that denotes lists of even length, then the predicate (p ∈ T ) is true if p points to an object of type T . Consider an assignment of the form q-&gt;next = NULL. To update (p ∈ T ), we have to consider the possibility that q can point anywhere inside the list pointed to by p. <ref type="foot" target="#foot_4">6</ref> One way around this difficulty is to use linear types to encode that there are no external pointers to the list other than p. It would also be interesting to investigate the use of predicates expressible in some recent pointer logics <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b21">22]</ref>.</p><p>We have focused on predicate abstraction of singlethreaded programs, and it would be interesting to extend C2bp to work for multi-threaded code. Several issues need to be resolved here. First, one needs to establish an appropriate notion of atomicity of execution. Next, while abstracting any statement one has to account for the possibility of interference from another thread. Even if such an abstraction were possible, model checking boolean programs with even two threads is undecidable. One possible solution is to further abstract boolean programs to finite-state machines, and then use traditional model checking algorithms to explore interleaving executions of the finite-state machines. A further problem is that in certain situations, it is not possible to know the number of threads in advance. If we were to first abstract boolean programs to finite-state machines, then it is possible to use parameterized model checking to handle an arbitrary number of threads <ref type="bibr" target="#b1">[2]</ref>. It is not clear if these abstractions can be performed automatically.</p><p>We have chosen C as our source language for predicate abstraction. However, our fundamental contribution is a set of techniques to handle procedure calls and pointers during predicate abstraction. The techniques in this paper can be adapted to construct predicate abstractions of programs written in other imperative languages such as Java.</p><p>We plan to improve some inefficiencies we have in the implementation. The theorem prover is currently started as a separate process each time it is used, which is very inefficient. A more fundamental issue is that we currently use theorem provers as black boxes. We plan to investigate if opening up the internals of the theorem prover can improve the efficiency of the abstraction process.</p><p>Generating predicates for a predicate abstraction tool like C2bp is another open research problem. We are currently building a tool called Newton in the SLAM toolkit to generate predicates from the model checker's counterexamples, using path simulation. We are also exploring predicate generation using value flow analysis on the program, with respect to the properties of interest. Our current approach seems to work as long as the properties of interest have relatively simple dependencies on data. For data-intensive properties, predicate generation may have to use widening heuristics as in <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b32">33]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) List partition example; (b) The boolean program of the list partition example, abstracted with respect to the set of input predicates { curr==NULL, prev==NULL, curr-&gt;val &gt; v, prev-&gt;val &gt; v }. The unknown function is used to generate the value true or false non-deterministically (see body text for an explanation).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>ϕ[x, e, y] = ( &amp;x = &amp;y ∧ ϕ[e/y])∨ ( &amp;x = &amp;y ∧ ϕ) Let y1, y2, . . . , yn be the locations mentioned in ϕ. Then W P (x=e, ϕ) is defined to be ϕ[x, e, y1][x, e, y2] . . . [x, e, yn]. In the example above, we have W P (x = 3, * p &gt; 5) = ( &amp;x = p ∧ 3 &gt; 5) ∨ ( &amp;x = p ∧ * p &gt; 5)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>b1, . . . , bn = choose(FV (W P (x=e, ϕ1)), FV (W P (x=e, ¬ϕ1))), . . . , choose(FV (W P (x=e, ϕn)), FV (W P (x=e, ¬ϕn)))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>the set of formal parameter predicates of R , defined as {e ∈ ER | vars(e) ∩ LR = ∅}, and • Er is the set of return predicates of R , defined as: {e ∈ ER | (r ∈ vars(e) ∧ (vars(e) \ {r} ∩ LR = ∅))∨ (e ∈ E f ∧ (vars(e) ∩ GP = ∅ ∨drfs(e) ∩ FR = ∅))}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: List traversal using back pointers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>The device drivers run through C2bp.</figDesc><table><row><cell cols="5">program lines predicates thm. prover runtime</cell></row><row><cell></cell><cell></cell><cell></cell><cell>calls</cell><cell>(seconds)</cell></row><row><cell>floppy</cell><cell cols="2">6500 23</cell><cell>5509</cell><cell>98</cell></row><row><cell>ioctl</cell><cell cols="2">1250 5</cell><cell>500</cell><cell>13</cell></row><row><cell cols="2">openclos 544</cell><cell>5</cell><cell>132</cell><cell>6</cell></row><row><cell>srdriver</cell><cell>350</cell><cell>30</cell><cell>3034</cell><cell>93</cell></row><row><cell>log</cell><cell>236</cell><cell>6</cell><cell>98</cell><cell>5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>The array and heap intensive programs analyzed with C2bp.</figDesc><table><row><cell>5 freely available from http://www.microsoft.com/ddk/</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The boolean program shown is not the exact output of C2bp-it has been simplified to aid readability.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In boolean programs, variable identifiers can be regular C identifiers or an arbitrary string enclosed between "{" and "}".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Here we use the contrapositive of the rule usually applied in unification-based alias analysis: (p = q) ⇒ ( * p = * q). That is, ( * p = * q) ⇒ (p = q).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>For simplicity, we assume that each formal still refers to the same value as its corresponding actual at the end of the call. This can be checked using a standard modification side-effect analysis<ref type="bibr" target="#b23">[24]</ref>. If a formal cannot be proven to refer to the same value as its corresponding actual at the end of the call, then any predicates that mention the formal must be removed from Er in the signature of R.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>We thank Frank Pfenning for this observation.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We thank Andreas Podelski for helping us describe the C2bp tool in terms of abstract interpretation. We thank Manuvir Das for providing us his onelevel flow analysis tool. We thank the developers of the AST toolkit at Microsoft Research, and Manuel Fähndrich for providing us his OCaml interface to the AST toolkit. We thank Craig Chambers for several interesting discussions about C2bp. Thanks also to the members of the Software Productivity Tools research group at Microsoft Research for many enlightening discussions on program analysis, programming languages and device drivers, as well as their numerous contributions to the SLAM toolkit.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Improving data-flow analysis with path profiles</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ammons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 98: Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="72" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Parameterized verification of multithreaded software libraries</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 01: Tools and Algorithms for Construction and Analysis of Systems</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2031</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Polymorphic predicate abstraction</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<idno>2001-10</idno>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report MSR Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Boolean and cartesian abstractions for model checking C programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 01: Tools and Algorithms for Construction and Analysis of Systems</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2031</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bebop: A symbolic model checker for Boolean programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN 00: SPIN Workshop</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="113" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatically validating temporal safety properties of interfaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN 2001: SPIN Workshop</title>
		<imprint>
			<date type="published" when="2001-05">May 2001</date>
			<biblScope unit="volume">2057</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Vampyre: A proof generating theorem prover</title>
		<author>
			<persName><forename type="first">D</forename><surname>Blei</surname></persName>
		</author>
		<ptr target="http://www.eecs.berkeley.edu/˜rupak/vampyre" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Path-sensitive value-flow analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Anik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 98: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="237" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Graph-based algorithms for boolean function manipulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers, C</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="677" to="691" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Extracting finitestate models from Java source code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Robby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE 00: Software Engineering</title>
		<meeting><address><addrLine>Bandera</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Abstract interpretation: a unified lattice model for the static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 77: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Unification-based pointer analysis with directional assignments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 00: Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Experience with predicate abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 00: Computer-Aided Verification</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1633</biblScope>
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Enforcing high-level protocols in low-level software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 01: Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saxe</surname></persName>
		</author>
		<ptr target="http://research.compaq.com/src/esc/simplify.html" />
		<title level="m">Simplify theorem prover</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Tool-supported program abstraction for finite-state verification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Joehanes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Robby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE 01: Software Engineering</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Annotation inference for modular checkers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Construction of abstract state graphs with PVS</title>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saïdi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 97: Computer-aided Verification</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1254</biblScope>
			<biblScope unit="page" from="72" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The Science of Programming</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Set-based analysis of ML programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LFP 94: LISP and Functional Programming</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="306" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">BI as an assertion language for mutable data structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ishtiaq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 01: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="14" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Proving the correctness of multiprocess programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="143" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
	<note>SE-</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Interprocedural side effect analysis with pointer aliasing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Landi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 93: Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="56" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A general axiom of assignment</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theoretical Foundations of Programming Methodology</title>
		<title level="s">Lecture Notes of an International Summer School</title>
		<imprint>
			<publisher>D. Reidel Publishing Company</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Proof carrying code</title>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 97: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="106" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Techniques for program verification</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<idno>CSL81-10</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Xerox Palo Alto Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Precise interprocedural dataflow analysis via graph reachability</title>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 95: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="49" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Intuitionistic reasoning about shared mutable data structure</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Millenial Perspectives in Computer Science</title>
		<imprint>
			<publisher>Palgrave</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="303" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Parametric shape analysis via 3-valued logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 99: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="105" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Two approaches to interprocedural data dalow analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sharir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Flow Analysis: Theory and Applications</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="189" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Implementation of an array bound checker</title>
		<author>
			<persName><forename type="first">N</forename><surname>Suzuki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ishihata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL 77: Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="132" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Safety checking of machine code</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI 00: Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="70" to="82" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
