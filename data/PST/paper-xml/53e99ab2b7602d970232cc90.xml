<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Framed temporal logic programming $</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-10-07">7 October 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zhenhua</forename><surname>Duan</surname></persName>
							<email>zhhduan@mail.xidian.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computing Theory and Technology</orgName>
								<orgName type="institution">Xidian University</orgName>
								<address>
									<postCode>710071</postCode>
									<settlement>Xi&apos;an</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiaoxiao</forename><surname>Yang</surname></persName>
							<email>xxyang@mail.xidian.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computing Theory and Technology</orgName>
								<orgName type="institution">Xidian University</orgName>
								<address>
									<postCode>710071</postCode>
									<settlement>Xi&apos;an</settlement>
									<country key="CN">PR China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Maciej</forename><surname>Koutny</surname></persName>
							<email>maciej.koutny@newcastle.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">University of Newcastle</orgName>
								<address>
									<postCode>NE1 7RU</postCode>
									<settlement>Newcastle upon Tyne</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Framed temporal logic programming $</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-10-07">7 October 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">2BAF65F0EBEAAB211E88E848460F5A69</idno>
					<idno type="DOI">10.1016/j.scico.2007.09.001</idno>
					<note type="submission">Received 4 June 2006; received in revised form 16 May 2007; accepted 3 September 2007</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Temporal logic programming</term>
					<term>Framing</term>
					<term>Minimal model</term>
					<term>Monotonicity</term>
					<term>Synchronization</term>
					<term>Communication</term>
					<term>Semantics</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A Projection Temporal Logic is discussed and some of its laws are given. After that, an executable temporal logic programming language, called Framed Tempura, is formalized. A minimal model-based approach for framing in temporal logic programming is presented. Since framing destroys monotonicity, canonical models -used to define the semantics of non-framed programs -are no longer appropriate. To deal with this, a minimal model theory is developed, using which the temporal semantics of framed programs is captured. The existence of a minimal model for a given framed program is demonstrated. A synchronous communication mechanism for concurrent programs is provided by means of the framing technique and minimal model semantics.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Temporal logic <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b20">21]</ref> has been proposed for the purpose of verifying properties of programs. Before that, verification suffered from a disadvantage that different languages (and thus different semantic domains) had been used for writing programs, for writing about their properties and for writing about whether and how a program satisfies a given property <ref type="bibr" target="#b19">[20]</ref>. One way to address this problem is to use the same language as much as possible. It was therefore suggested that a subset of temporal logic be used as the foundational basis for a programming language <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b25">26]</ref>. This means that writing programs, specifying their properties and verifying those properties, could all be treated within the same notation. There are some aspects of programming in temporal logics that have not yet received sufficient attention, notably the problems of framing, synchronization and communication. As synchronization and communication are closely related to framing, we will first discuss some general issues regarding framing techniques in Temporal Logic Programming (TLP).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Motivation</head><p>Introducing framing to TLP is motivated by both practical and theoretical considerations; in particular, improving the efficiency of a program and synchronizing communication between parallel processes. Let us begin with an example in Tempura <ref type="bibr" target="#b22">[23]</ref>: PROG I : (x = 1) ∧ ((y := 2) ; (y := x + y))</p><p>where " ;" (chop) is a sequential operator, "=" assigns a value to a variable at the current state, and ":=" does the same at the next state.</p><p>The program only tells us that x = 1 at the initial state of an interval over which the program is interpreted, and that y = 2 at the second state. One might expect (or even require) that y = 3 (the sum of the values of x and y) at the third state, but the program does not guarantee this. The reason is that x is unspecified at the second state, and so y is unspecified at the third state (as well as in the initial state). There are several ways to achieve the desired effect, and an ad hoc fix to the problem is to make the stability of variables' values explicit. The above example would then be rewritten as PROG II : (x = 1) ∧ (more → ( x = x)) ∧ ((y := 2) ; (y := x + y))</p><p>where is the modal operator associated with the temporal "always", is the "next" operator, and more means that the current interval is not yet over. Now x is assigned its current value repeatedly, from one state to another, so that its value is inherited. But these additional assignments are tedious and may decrease the efficiency of the program. Although for a small program repeated assignments may be tolerable, in some cases they may be unacceptable. For instance, maintaining in such a way a large array with changing only a few its entries at different times, would lead to a disaster in terms of performance. Moreover, the verification and transformation of programs would also suffer in such a case. It is therefore important to have an efficient method (a framing technique) allowing one to carry forward variables' values, from the current state to the next.</p><p>Another problem one needs to consider is that of communication between concurrent processes. In TLP languages, such as XYZ/E <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27]</ref> and Tempura <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23]</ref>, such a communication is based on shared variables. 1 To effect communication between parallel processes in a shared variables model, a synchronization construct await(c), or some equivalent, is required <ref type="bibr" target="#b20">[21]</ref>. The meaning of await(c) is simple: it changes no variables, but waits until the condition c becomes true, at which point it terminates.</p><p>How could the await(c) construct be implemented in a TLP like Tempura? To start with, the halt(c) statement might play a role similar to that of await(c). However, halt(c) requires that c become true only at the end of an interval, and it does not prevent the variables from being changed. Thus problems arise whether we adopt repeated or unrepeated assignments, when we attempt to synchronize parallel components. For instance, the program: PROG III : (x = 0) ∧ halt(x = 1) ∧ len <ref type="bibr" target="#b1">(2)</ref> where len specifies the temporal length of an interval, is satisfied by any interval comprising three states such that x = 0 and x = 1 at the first and third state, respectively. On the other hand, if we used repeated assignment, the program:</p><formula xml:id="formula_0">PROG IV : (x = 0) ∧ (more → ( x = x)) ∧ halt(x = 1) ∧ len(2)</formula><p>is obviously unsatisfiable. As another example, the program:</p><formula xml:id="formula_1">PROG V : (x = 0) ∧ halt(x = 1)</formula><p>is satisfiable over an interval such that x = 0 in its first state, and x = 1 in the last one. It terminates at some indefinite state where x = 1 because x is only defined at the initial state. On the other hand, if we used repeated assignment, the program PROG VI : (x = 0) ∧ (more → ( x = x)) ∧ halt(x = 1) 1 This should be contrasted with communication by message passing used by, e.g., CCS <ref type="bibr" target="#b21">[22]</ref> and CSP <ref type="bibr" target="#b17">[18]</ref>. would be forever waiting for (x = 1) to become true. No process acting in parallel can set x to 1, since such an assignment would conflict with x = 0.</p><p>The above problem is due to the fact that, unlike in conventional programming languages, the values of variables are not inherited automatically from one state to another, and the assignments are not destructive in TLP languages. Modelling an await(c) construct in TLP requires, on the one hand, a kind of indefinite stability, since it cannot be known at the point of use how long the waiting will be. On the other hand, one must also allow variables to change their values so that an external process can change the boolean guard c. Solving this problem can also be attempted by a suitable framing technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Logic with framing</head><p>Framing is concerned with how the value of a variable can be carried from one state to the next. It has been employed by the conventional imperative languages for years. TLP offers no ready-made solution in this respect as variables' values are not assumed to be carried forward.</p><p>Considerable attention has been given to framing in the past two decades <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b26">27]</ref>. However, no consensus has yet emerged as to what is the best underlying semantics of framing operators. For example, in <ref type="bibr" target="#b8">[9]</ref> a framing technique based on an explicit frame operator was formalized, together with a specification (modelling) language FTLL. In this paper, we describe a similar approach but at a much greater depth of details. Based on the proposed framing technique, we introduce an executable version of a framed programming language, called Framed Tempura. We investigate the properties of the frame operator and, in particular, the behaviour of concurrent programs under a specific model of framing in which framed and non-framed variables can be mixed.</p><p>In our discussion, we use Projection Temporal Logic (PTL), which is an extension of Interval Temporal Logic (ITL) <ref type="bibr" target="#b22">[23]</ref>. The key operator used is the new projection operator, ( p 1 , . . . , p m ) prj q, which can be thought of as a combination of the original parallel and projection operators in ITL <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">23]</ref>. <ref type="foot" target="#foot_0">2</ref> Within the PTL framework, we define a new assignment operator (⇐) and an assignment flag (af), and then formalize a framing operator frame(x). These new constructs are interpreted within a minimal model semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Framed programs</head><p>To make the framing technique useful in practice, we develop an extension of Tempura <ref type="bibr" target="#b22">[23]</ref>, called Framed Tempura. Using its framing operator, one can specify the framing status of variables throughout an interval in a flexible manner, and to verify properties of a reactive system in a manageable way.</p><p>When a framing technique is introduced to TLP, the semantics of a program needs to be carefully reconsidered. The semantics of an imperative program can be captured in an operational or denotational or axiomatic way. In TLP, these kinds of semantics can also be investigated. Since a TLP language, e.g., Tempura, is a subset of the corresponding logic, and this logic has its model theory and axiom system, the semantics of a TLP program can be captured by both the model theory and axiomatic theory. When executed, of course, a program can also be interpreted in an operational way. Actually, the model theory, in some sense, plays a similar role in TLP languages as the denotational semantics theory in imperative programming languages.</p><p>To capture the temporal semantics of nonframed Tempura programs, canonical models can be used <ref type="bibr" target="#b5">[6]</ref>. However, since framing destroys monotonicity, a program can have different meanings under different canonical models, and so a canonical model may no longer capture the intended meaning of a program. In logic programming languages such as Prolog, negation by failure has been used in programs, and a program is interpreted by the minimal model semantics, or the fixpoint semantics <ref type="bibr" target="#b1">[2]</ref>. This has led to the introduction of a similar idea in TLP, and to interpret framed programs faithfully, we will use minimal models. We discuss the semantics of framed programs; in particular, we define the normal form of framed programs and show that a framed program can be transformed into its normal form. We also show that a satisfiable framed program has at least one minimal model.</p><p>The synchronous communication construct, await(c), can easily be defined using the framing operator. Note that an interpreter for the Framed Tempura has been developed using the framing technique presented in this paper; however, it will not be presented here.</p><p>The next section introduces PTL, and Section 3 describes Framed Tempura. The semantics of framed programs is discussed in Section 4. After that we present some programming examples in Section 5. Conclusions are drawn in Section 6, and the Appendix contains proofs of selected results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Projection temporal logic</head><p>PTL (Projection Temporal Logic) -an extension of ITL <ref type="bibr" target="#b22">[23]</ref> -is a first order temporal logic <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b20">21]</ref> with projection <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b8">9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Syntax</head><p>Let Π be a countable set of propositions, and V be a countable set of typed static and dynamic variables. The terms e and formulas p of the logic are defined as follows:</p><formula xml:id="formula_2">e ::= v | e | -e | beg(e) | end(e) | f (e 1 , . . . , e m ) p ::= π | e 1 = e 2 | P(e 1 , . . . , e m ) | ¬ p | p 1 ∧ p 2 | ∃v : p | p | -p | ( p 1 , . . . , p m ) prj p | p +</formula><p>where v is a static or dynamic variable, and π is a proposition. In f (e 1 , . . . , e m ) and P(e 1 , . . . , e m ), where f is a function and P is a predicate, it is assumed that the types of the terms are compatible with those of the arguments of f and P.</p><p>A formula (term) is called a state formula (term) if it does not contain any temporal operators, ı.e. next ( ), previous ( -), beginning value (beg), ending value (end), projection (prj) and chop-plus ( + ); otherwise it is a temporal formula (term). Temporal operators previous ( -) and beginning value (beg) are called past temporal operators, whereas next ( ), ending value (end), projection (prj) and chop-plus ( + ) are future temporal operators. A formula is called a non-past (non-future) formula if it does not contain any past (future) temporal operators.</p><p>The derived logic connectives, ∨, → and ↔, as well as the logic formulas, true and false, are defined as usual.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Semantics</head><p>A state s is a pair of assignments (I var , I prop ) which, for each variable v ∈ V gives s[v] An interval σ df = s 0 , s 1 , . . . is a non-empty (possibly infinite) sequence of states. It is assumed that each static variable is assigned the same value in all the states in σ . The length of σ , denoted by |σ |, is defined as ω if σ is infinite; otherwise it is the number of the states in σ minus one.</p><p>To have a uniform notation for both finite and infinite intervals, we will use extended integers as indices. That is, we consider the set N 0 of non-negative integers with added ω, N ω df = N 0 ∪ {ω}, and extend the standard arithmetic comparison operators (=, &lt; and ≤) to N ω , by setting ω = ω and n &lt; ω, for all n ∈ N 0 . Furthermore, we define as ≤ -{(ω, ω)}. To simplify definitions, we will denote σ as s 0 , . . . , s |σ | , where s |σ | is undefined if σ is infinite. With such a notation, σ (i.. j) (for 0 ≤ i j ≤ |σ |) denotes the sub-interval s i , . . . , s j and σ (k) (for 0 ≤ k |σ |) denotes s k , . . . , s |σ | . 3 For a variable v, we will denote σ v = σ whenever σ is an interval which is the same as σ except that different values can be assigned to v. To define the semantics of the projection operator we need an auxiliary operator. Let σ = s 0 , s 1 , . . . be an interval and r 1 , . . . , r h be integers (h ≥ 1) such that 0</p><formula xml:id="formula_3">≤ r 1 ≤ r 2 ≤ • • • ≤ r h ≤ |σ |. The projection of σ onto r 1 , . . . , r h is the interval (called projected interval) σ↓(r 1 , . . . , r h ) df = s t 1 , s t 2 . . . , s t l , (t 1 &lt; t 2 &lt; • • • &lt; t l )</formula><p>where t 1 , . . . , t l are obtained from r 1 , . . . , r h by deleting all duplicates. In other words, t 1 , . . . , t l is the longest strictly increasing subsequence of r 1 , . . . , r h . For example, s 0 , s 1 , s 2 , s 3 , s 4 , s 5 ↓(0, 2, 2, 2, 3, 4, 4, 5) = s 0 , s 2 , s 3 , s 4 , s 5 .</p><p>An interpretation for a PTL term or formula is a tuple I df = (σ, i, k, j), where σ = s 0 , s 1 , . . . is an interval and i, j, k ∈ N ω are such that i ≤ k j ≤ |σ |. Intuitively, we use (σ, i, k, j) to mean that a term or formula is interpreted over a subinterval σ (i.. j) with the current state being s k . Then, for every term e, the evaluation of e relative to I is defined as I[e], by induction on the structure of the term, as shown in Fig. <ref type="figure" target="#fig_6">1</ref>, and the satisfaction relation for formulas, |=, is defined as the least relation satisfying the rules in Fig. <ref type="figure" target="#fig_10">2</ref>.</p><p>It can be shown that I |= p if and only if (σ (i.. j) , 0, ki, ji) |= p. That is, the relevant part of σ in I = (σ, i, k, j) is σ (i.. j) . In particular, the valuations of variables and predicates outside the bounds given by i and j do not matter. Furthermore, if p is a formula which does not use the previous operator then I |= p if and only if (σ (k.. j) , 0, 0, jk) |= p.</p><p>If there is an interpretation I such that I |= p then a formula p is satisfiable. We also define the satisfaction relation for an interval σ and formula p, by stating that σ |= p if (σ, 0, 0, |σ |) |= p. Furthermore, we denote |= p if σ |= p, for all intervals σ . ⇐⇒ I 0 var [x] = I 0 var <ref type="bibr" target="#b0">[1]</ref> and (σ, 0, 1, 2</p><formula xml:id="formula_4">)[ x] = (σ, 0, 1, 2)[x] + I 0 var [x] ⇐⇒ 1 = 1 and (σ, 0, 2, 2)[x] = I 1 var [x] + 1 ⇐⇒ 1 = 1 and I 2 var [x] = 2 + 1 ⇐⇒ 1 = 1 and 3 = 2 + 1 ⇐⇒ true</formula><p>Note that integer 1 is treated as a static variable, so we can write I 0 var <ref type="bibr" target="#b0">[1]</ref>. In ( p 1 , . . . , p m ) prj q, to ensure smooth synchronization between p 1 , . . . , p m and q, the previous operator is not allowed within q; however, it can still be used in the p i 's. The projection operator is executable. In programming language terms, the interpretation of ( p 1 , . . . , p m ) prj q is somewhat sophisticated as we need two sequences of clocks (states) running according to two different time scales: one is a local state sequence, over which p 1 , . . . , p m are executed, and the other is a global state sequence over which q is executed in parallel with the sequence of processes p 1 , . . . , p m , as follows (see Fig. <ref type="figure" target="#fig_2">3</ref>). We start q and p 1 at the first global state and p 1 is executed over a sequence of local states until its termination. Then (the remaining part of) q and p 2 are executed at the second global state, and p 2 is executed over a sequence of local states until its termination, and so on. Although q and p 1 start at the same time, p 1 , . . . , p m and q may terminate at different time points. If q terminates before some p h+1 , then, subsequently, p h+1 , . . . , p m are executed sequentially. If p 1 , . . . , p m are finished before q, then the execution of q is continued until its termination.</p><p>Two formulas, p and q, are weakly (strongly) equivalent if |= p ↔ q (resp. |= ( p ↔ q)), and we denote this by p ≈ q (resp. p ≡ q). Similarly, we denote p → q (weak implication) and p ⊃ q (strong implication), if |= p → q and |= ( p → q), respectively. </p><formula xml:id="formula_5">IVAR I[v] df = s k [v] = I k var [v] IFUN I[ f (</formula><formula xml:id="formula_6">= r 0 ≤ r 1 ≤ • • • ≤ r m ≤ j such that (σ, i, r 0 , r 1 ) |= p 1 and</formula><p>(σ, r l-1 , r l-1 , r l ) |= p l for all 1 &lt; l ≤ m and (σ , 0, 0, |σ |) |= q for σ given by :</p><p>if r m &lt; j then σ = σ↓(r 0 , . . . , r m )•σ (r m +1.. j) -if r m = j then σ = σ↓(r 0 , . . . , r h ) for some 0</p><formula xml:id="formula_7">≤ h ≤ m IPLUS I |= p + if there are k = r 0 ≤ r 1 ≤ • • • ≤ r n-1 r n = j (n ≥ 1) such that (σ, i, r 0 , r 1 ) |= p and (σ, r l-1 , r l-1 , r l ) |= p for all 1 &lt; l ≤ n Fig. 2.</formula><p>Interpreting PTL formulas, where v is a variable, e 1 , . . . , e m are terms, and p, q, p 1 , . . . , p m are formulas.</p><p>Note that weakly equivalent formulas have the same truth value in the first state of every model (i.e., interval), while strongly equivalent formulas have the same truth value in every state of every model. And, similarly, for the weak and the strong implication relations.</p><p>It should be clear that the strong equivalence (implication) implies the weak equivalence (resp. implication) but the converse does not hold.</p><p>Theorem 2.1. Let p be a PTL formula, and q be a sub-formula of p. If r is a formula such that q ≡ r , then p ≡ p[r/q], where p[r/q] is p with q replaced by r .   <ref type="figure">------|---------------|-----------------------|---|  |-----------------------q-------------------------</ref> The proof of Theorem 2.1 can be found in the Appendix. This law is the common substitution law and useful in the reduction of programs.</p><formula xml:id="formula_8">-&gt;| t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 |---|---|---|---|---|---|---|---|---|---|---|---| |&lt;--p1-&gt;|&lt;-----p2------&gt;|&lt;---------p3---------&gt;| i=2 4 6 9<label>12</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Derived formulas and logic laws</head><p>Table <ref type="table" target="#tab_2">1</ref> introduces a number of useful derived formulas. Note that: empty represents the final state and first represents the first state of the current interval; len(n) specifies the distance n from the current state to the final state of an interval; sometimes(♦ p) means that p holds eventually in the future including the current state; always ( p) means that p holds always in the future from now on; weak next ( p) tells us that either the current state is the final one or p holds at the next state of the present interval; Prj( p 1 , . . . , p m ) represents a sequential computation of p 1 , . . . , p m since the projected interval is a singleton; and chop ( p ; q) represents a computation of p followed by q; and chop-star ( p * ) holds over an interval if it can be partitioned into finitely many subintervals and p holds over each of these.</p><p>Example 2.2. As already mentioned, projection can be thought of as a special parallel computation which is executed on two different time scales. Consider the following formulas:</p><formula xml:id="formula_9">p 1 df = len(2) ∧ (more → (( i) = i + 2)) p 2 df = len(4) ∧ (more → (( i) = i + 3)) p 3 df = len(6) ∧ (more → (( i) = i + 4)) q df = len(4) ∧ (i = 2) ∧ ( j = 0) ∧ (more → (( j) = j + i)).</formula><p>Then executing ( p 1 , p 2 , p 3 ) prj q yields the result shown in Fig. <ref type="figure" target="#fig_4">4</ref>. </p><formula xml:id="formula_10">= ¬ true AMORE more df = ¬empty AFIRST first df = ¬ -true APRJ Prj( p 1 , . . . , p m ) df = ( p 1 , . . . , p m ) prj empty ACHOP p ; q df = Prj( p, q) ASOME ♦ p df = Prj(true, p) AALWS p df = ¬♦¬ p AWNEXT p df = empty ∨ p ALEN len(n) df = empty if n = 0 len(n -1) if n &gt; 1 ASKIP skip df = len(1) ACHOP-STAR p * df = empty ∨ p + A PTL formula p is left end closed (lec-formula) if (σ, k, k, j) |= p if and only if (σ, i, k, j) |= p, for any interpretation (σ, i, k, j). Similarly, q is right end closed (rec-formula) if (σ, i, k, k) |= q if and</formula><p>only if (σ, i, k, j) |= q for any interpretation (σ, i, k, j). Intuitively, being lec-formula means that if p holds over a subinterval σ (k.. j) resulting from σ (i.. j) by chopping it at the state s k , then p does not refer to any state to the left of s k , and similarly for a recformula. For instance, (more</p><formula xml:id="formula_11">→ ( p 1 ↔ -p 2 )) is a lec-formula, and first is a rec-formula. A formula p is non-local (or terminable) if σ |= p implies |σ | ≥ 1 (resp. |σ | = 0).</formula><p>Theorem 2.2. The laws in Tables <ref type="table">2</ref> and<ref type="table" target="#tab_3">3</ref> all hold.</p><p>The proof of Theorem 2.2 can be found in the Appendix. These logic laws are basic laws and useful for the reduction of programs. In particular, they play an important role in transforming a program into its normal form.</p><p>To reduce programs with existential quantification, we will use renaming. Given a formula ∃x : p(x) with a bound variable x, we can remove the existential quantification to obtain a formula p(y) with a free variable y by renaming x as y. To do so, we require that: (i) y does not occur free or bound in ∃x : p(x); (ii) y and x are both either dynamic or static; and (iii) y is substituted only for those occurrences of x which are bound by the outer ∃x. We will call p(y) a renamed formula of ∃x : p(x). Proposition 2.3. Let p(y) be a renamed formula of ∃x : p(x). Then ∃x : p(x) is satisfiable iff p(y) is satisfiable. Moreover, any model of p(y) is also a model of ∃x : p(x).</p><p>Note that projection as defined here and chop-plus are related operators, with p + being equivalent to</p><formula xml:id="formula_12">∃m : m ≥ 1 ∧ Prj( p, . . . , p m times</formula><p>).</p><p>Note that the chop operator is central to ITL <ref type="bibr" target="#b22">[23]</ref> as well as chop-star and projection <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>. Moreover, <ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref> further develop the projection construct of <ref type="bibr" target="#b22">[23]</ref>.</p><p>In what follows, in order to avoid excessive use of parentheses, we will sometimes use the following priority levels of PTL (and Framed Tempura) operators:</p><formula xml:id="formula_13">LEVEL 1 ¬ LEVEL 2 -♦ LEVEL 3 ∃ LEVEL 4 := = LEVEL 5 ∧ ∨ LEVEL 6 → ↔ LEVEL 7 ; prj Table 2 PTL laws I LAW1 empty ; p ≡ p if lec( p) LAW2 ( p ∧ empty) ; q ≡ p ∧ q if rec( p) and lec(q) LAW3 p ∧ empty ; q ⊃ q if lec(q) LAW4 p ; empty ≡ p ∧ ♦empty LAW5 p ; q ∧ empty ≡ p ∧ (empty → q) if lec(q) LAW6 ¬ p ≡ ¬ p LAW7 ¬ p ≡ ¬ p LAW8 ( p ∧ q) ≡ p ∧ q LAW9 ( p ∨ q) ≡ p ∨ q LAW10 ( p → q) ≡ p → q LAW11 r ; ( p ∨ q) ≡ (r ; p) ∨ (r ; q) LAW12 ( p ∨ q ; r ) ≡ ( p ; r ) ∨ (q ; r ) LAW13 p ≡ p ∧ more LAW14 (∃x : p) ≡ ∃x : p LAW15 ( p) ; q ≡ ( p ; q) LAW16 w ∧ ( p ; q) ≡ (w ∧ p) ; q LAW17 more ⊃ e 1 = e 2 ↔ (e 1 = e 2 ) LAW18 ¬first ∧ more ⊃ -e = - e LAW19 ( p ∧ empty) ; empty ≡ p ∧ empty LAW20 p + ≡ p ∨ ( p ; p + ) LAW21 p + ≡ p ∨ (( p ∧ more) ; p + ) if lec( p) LAW22 p ≡ ( p ; empty) ∨ ( p ∧ more) LAW23 ♦ p ≡ p ∨ ♦ p LAW24 p ≡ p ∧ p LAW25 p ⊃ more LAW26 p * ≡ empty ∨ ( p ; p * ) ∨ ( p ∧ more) LAW27 p * ≡ empty ∨ ( p ∧ more ; p * ) ∨ ( p ∧ more) if lec( p) LAW28 ¬first ∧ more ⊃ ( -p) ↔ ( - p) LAW29 e 1 + e 2 = (e 1 + e 2 ) LAW30 ( p ∧ empty) ; (q ∧ empty) ≡ p ∧ q ∧ empty if rec( p) and lec(q) LAW31 p + ∧ empty ≡ p ∧ empty LAW32 ∃x : p(x) ≡ ∃y : p(y) LAW33 ∀x : p(x) ≡ ∀y : p(y) LAW34 ∃x : p(x) ≡ ∃x : q(x) if p(x) ≡ q(x) LAW35 ∀x : p(x) ≡ ∀x : q(x) if p(x) ≡ q(x) LAW36</formula><p>p prj q ≡ ( p ; q) LAW37 empty prj q ≡ q LAW38 q prj empty ≡ q</p><p>It is assumed that in LAW32-LAW35 variables x and y are both either static or dynamic, and neither does x appear in p(y) nor does y appear in p(x). Note that lec( p) means that p is a lec-formula, and rec( p) means that p is a rec-formula and w is a state formula.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">An executable TLP language</head><p>The programming language we use -a subset of PTL -extends Tempura with framing, projection, and await operators <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>. In addition, program variables can refer to their previous values. After introducing the basic constructs of Tempura and the previous operator, we will formalize the frame operator and the await construct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Syntax</head><p>Generally speaking, Tempura programs are deterministic and so disjunction is usually unavailable. Hence, the negation -being fundamentally non-deterministic -is not a primitive operator of the language. Instead, a conditional statement and empty, both defined in terms of negation, are taken as primitives. Programs are constructed from the operators described below, together with a suitable choice of expressions which may involve the previous operator. (p, empty, q) prj q ≡ (p, q) prj q LAW41 ( p ∧ empty) ; (p prj q) ⊃ ( p, p) prj q LAW42 (p, empty ∧ w, p, q) prj q ≡ (p, w ∧ p, q) prj q LAW43 (p, p ∨ w, q) prj q ≡ ((p, p, q) prj q) ∨ ((p, w, q) prj q) LAW44 p prj ( p ∨ q) ≡ (p prj p) ∨ (p prj q) LAW45 p prj q ≡ (( p ∧ more) ; q) ∨ (( p ∧ empty) ;</p><formula xml:id="formula_14">q) LAW46 ( p ∧ more) ; (p prj q) ⊃ ( p, p) prj q LAW47 ( p, p) prj q ≡ (( p ∧ more) ; (p) prj q) ∨ (( p ∧ empty) ; (p) prj q) LAW48 ( p 1 , . . . , p m ) prj q ≡ ( p 1 ; ( p 2 , . . . , p m ) prj q) LAW49 p prj q ≡ p ∧ q LAW50 (w ∧ p, p) prj q ≡ w ∧ (( p, p) prj q) LAW51 p prj (w ∧ q) ≡ w ∧ (p prj q) LAW52 fin(w) ∧ ( p ; q) ≡ p ; (fin(w) ∧ q) LAW53</formula><p>skip prj q ≡ q LAW54 q prj skip ⊃ q LAW55 ( p, q) prj skip ⊃ p ; q LAW56 Assuming p 0 ≡ p m+1 ≡ empty:</p><formula xml:id="formula_15">p prj q ≡ m-1 t=0 (( p 0 ∧ • • • ∧ p t ) ∧ empty ; p t+1 ∧ more ; ( p t+2 , . . . , p m+1 ) prj q) ∨ (( p 0 ∧ • • • ∧ p m ) ; q)</formula><p>Note that p and q stand for (possibly empty) sequences of formulas: p 1 , . . . , p m and q 1 , . . . , q n . It is assumed that: (i) in LAW42, LAW50, LAW51 and LAW52 w is a state formula; (ii) in LAW53 and LAW54 q is nonlocal; (iii) in LAW55 p or q is a nonlocal formula; and (iv) in LAW49 p and q are state formulas.</p><p>Altogether, there are eleven elementary statements. Five of them are basic constructs taken directly from PTL: the equality (=), conjunction (∧), existential quantification (∃x : p), next ( ) and projection (prj). The remaining statements are: the conditional, always 4 ( ), chop ( ; ), while, parallel and empty. From the point of view of the programming language, the eleven statements are all primitives since the negation (¬), sometimes (♦), disjunction (∨) and chop-plus (+) are absent in the definition of the extended Tempura. This also implies that some operators cannot be derived as before. Note that in an induction proof of a property of programs, the assignment and empty statements can be thought of as basic statements and the others can be treated as composite statements. In what follows, x is a variable, e is an arbitrary arithmetic expression, b is a state boolean expression (consisting of propositions, variables and boolean connectives), and p and q are programs. It is assumed that in LAW58-LAW59 p is a lec-formula, and in LAW57-LAW58 p is terminable.</p><formula xml:id="formula_16">ASSIGNMENT (UNIFICATION) x = e CONJUNCTION p ∧ q CONDITIONAL if b then p else q df = (b → p) ∧ (¬b → q) EXISTS ∃x : p NEXT p ALWAYS p SEQUENCE p ; q WHILE LOOP while b do p df = ( p ∧ b) * ∧ (empty → ¬b) PROJECTION ( p 1 , . . . , p m ) prj q PARALLEL p q df = p ∧ (q ; true) ∨ q ∧ ( p ; true) TERMINATION empty</formula><p>The assignment (x = e) means that the value of variable x is equal to the value of the expression e, and its interpretation is subject to IEQUAL. Whenever such an assignment is encountered, we evaluate x and e by I[x] and I[e] to see whether</p><formula xml:id="formula_17">I[x] = I[e].</formula><p>Therefore, if e is evaluated to a constant in D and x has not been specified before (or it was specified to have the same value as e), then we say e is assigned to x. In this case, the equality (x = e) is satisfied otherwise it is false. In other words, x is unified with e as, e.g., in Prolog.</p><p>Theorem 3.1. The laws in Table <ref type="table">4</ref> all hold.</p><p>The proof of Theorem 3.1 can be found in the Appendix. These logic laws are concerned with while statement and useful for reducing programs with while construct.</p><p>Note that the equality in Tempura has two functions: assignment and comparison. The former is a statement in a program while the latter is in a condition (boolean expression) associated with conditional or iterative statements. An assignment is true as long as it is satisfiable whereas a condition is true if all the variables involved in it are specified and the condition is evaluated to true.</p><p>As in the conventional programming languages, the conditional statement if b then p else q means that if b is evaluated to true then the process (ı.e. sub-program) p is executed; otherwise, q is executed. The 'next' statement p means that p holds at the next state, while p means that p holds in all the states from now on. The terminal statement empty simply means that the current state is the final state of the interval over which a program is executed. The sequential statement p ; q means that p holds from now until some point in the future and from that time point q holds. Intuitively, p is a program which is executed from the current state until its termination, and then q is executed. The conjunction p ∧q is executed in a parallel manner. The processes p and q start at the same state but may terminate at different states. They share all the states and variables during the simultaneous execution. The iteration while b do p allows process p to be repeatedly executed a finite (or infinite) number of times over a finite (resp. infinite) interval as long as the condition b holds at the beginning of each execution. If b becomes false, then the while statement terminates; otherwise, p is executed. For instance, over an infinite interval, the statement while true do p allows p to be executed a finite or infinite number of times, each time on a finite subinterval (or on an infinite subinterval for the last execution). This statement is obviously false within any finite interval if the execution of p requires a non-singleton interval. Another special case is while b do empty which is simply equivalent to ¬b ∧ empty.</p><p>The projection ( p 1 , . . . , p m ) prj q means that q is executed in parallel with p 1 ; . . . ; p m over an interval obtained by taking the endpoints of the intervals over which the p i 's are executed. The construct permits the processes p 1 , . . . p m , q to be autonomous, each process having the right to specify the interval over which it is executed. In particular, the sequence of p i 's and q may terminate at different time points. The parallel computation presented here proceeds synchronously, and may be modelled by true concurrency. It is weaker than the asynchronous parallel computation modelled by interleaving, and is close to conjunction. The basic difference between p q and p ∧ q is that the former allows both processes p and q to specify their own intervals while the latter does not. For instance, len(2) len(3) is satisfiable but len(2) ∧ len(3) is not. The existential quantification (∃x : p) intends to hide the variable x within the process p. It may permit p to use a local variable x, and this idea can be realized in an operational semantics. However, within the temporal semantics, the concept of a local variable is not effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Derived statements</head><p>The first group of derived statements are various assignment operators. Below, x is a variable, u static variable, e expression (term), and op any of the binary assignment operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>NEXT</head><p>x</p><formula xml:id="formula_18">•= e df = x = e UNIT x := e df = skip ∧ (x •= e) MULTIPLE (x 1 , . . . , x n ) op (e 1 , . . . , e n ) df = (x 1 op e 1 ) ∧ • • • ∧ (x n op e n )</formula><p>The 'next' assignment specifies the value of a variable at the next state, while the unit assignment additionally specifies the length of the interval over which the assignment takes place to be 1.</p><p>The Although the language does not include disjunction, negation and universal quantification as basic statements, it is not guaranteed that programs are deterministic. The problem is that the immediate assignment (x = e) is nondeterministic since</p><formula xml:id="formula_19">(x = e) ≡ (((x = e) ∧ empty) ∨ ((x = e) ∧ more))</formula><p>and so are, for instance, (x = e) and (x = e). If the unit assignment (x := e) rather than an immediate assignment was used as a primitive statement, the language would become deterministic. However, an immediate assignment has its advantages, e.g., it can easily be used to initialize variables and it corresponds to the equality taken directly from the underlying logic. To write a deterministic program, constructs like len(k) or halt(b) or more (for non-terminating program) are needed in order to specify a definite interval.</p><p>The third group of derived statements are iterative operators (below b is a state boolean expression). In what follows, we will use the term 'program' to mean any program belonging to the extended Tempura. Typically, it will be a deterministic and terminating program which involves the previous operator only in expressions. However, some results are discussed in a broader scope in which non-deterministic programs and/or infinite intervals are considered. To avoid ambiguity, whenever only a deterministic program or only a finite interval is involved, we state this explicitly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Expressions and data structures</head><p>The choice of permissible expressions is wider but only constants, variables, arrays, strings and list expressions, as well as restricted temporal expressions are mentioned in this paper. There are integer and boolean constants, and variables are divided into simple variables (x) and structured variables (x <ref type="bibr" target="#b0">[1]</ref>). One may refer to the value of a variable at the previous and next state of an interval. Arithmetic expressions (e) and boolean expressions (b) are defined as follows (below n is an integer variable): </p><formula xml:id="formula_20">| b 1 ∧ b 2 | b 1 ∨ b 2 | b 1 → b 2 | b 1 ↔ b 2</formula><p>Note that e and -e are only meaningful in a state different from the final and first one, respectively.</p><p>A list is a finite or infinite sequence l = a 0 , a 1 , . . . of elements separated by commas and enclosed within the angle brackets. Its length |l| is the number of the elements in l minus 1; the i-th element is denoted by l[i], and the sublist from the i-th element to the j-th element by l(i.. j). The empty list is denoted by . To manipulate lists, we use the following operators: concatenation (•); fusion (•); head (hd) returning the first element of l; last (lt) returning the last element of l; and tail (tl) returning the sublist l(1..|l|). The first two operators are defined thus:</p><formula xml:id="formula_21">l 1 • l 2 df =    l 1 if |l 1 | = ω or l 2 = l 2</formula><p>if l 1 = a 0 , . . . , a i , a i+1 , . . . if l 1 = a 0 , . . . , a i and l 2 = a i+1 , a i+2 . . .</p><formula xml:id="formula_22">l 1 • l 2 df =        l 1 if |l 1 | = ω or l 2 = l 2 if l 1 = a 0 , . . . , a i , a i+1 , . . . if l 1 = a 0 , . . . , a i and l 2 = a i , a i+1 . . . undefined otherwise</formula><p>Text strings are surrounded by the double quotation marks. They may be indexed and manipulated in the same way as lists. Finally, arrays are sets of indexed elements of the same type. A two-dimensional array can be expressed as a list with the row-first implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Framing</head><p>As mentioned in the introduction, framing is concerned with the persistence of the values of variables from one state to another. There are at least two realistic ways to go about framing. For example, <ref type="bibr" target="#b16">[17]</ref> defines assignment as</p><formula xml:id="formula_23">(x := e) df = (x = e) ∧ (y 1 = y 1 ) ∧ • • • ∧ (y m = y m )</formula><p>where the apostrophes represent the new values of variables, and y 1 , . . . , y m are all the remaining variables of a program. Intuitively, whenever a variable is assigned a value, all the other variables remain stable. However, this method can only manage framing in a limited case in which all variables are framed, and the conjunction of assignments is forbidden since (x := e) ∧ (y := f ) is false whenever e (or f ) does not evaluate to the current value of x (resp. y). Since in Tempura parallel composition is based on conjunction, adopting the above strategy for framing would rule out parallel assignments.</p><p>Another way to introduce framing is through an explicit operator, enabling one to establish a flexible framed environment in which framed and non-framed variables can be mixed, with frame operators being used in sequential, conjunctive and parallel manner. The key characteristic of a frame operator could be stated thus: frame(x) means that variable x keeps its old value over an interval if no assignment to x has been encountered.</p><p>The crux is how to perceive the assignment of a value to x, and we will use for this purpose a dedicated assignment flag af(x) which cannot be used freely in a program but only in the context of assignment and frame operator. This predicate is true whenever an assignment of a value to x is encountered, and false otherwise. The assignment flag is easy to understand but rather difficult to formalize in a logic framework. The problem is that a program provides only positive information about explicit assignments whereas what we need is a negative information about those variables which are not assigned values at the current state. One might search for the positive information syntactically and obtain the negative information by complement, but doing this in a logic framework is hard.</p><p>Let SV ⊂ V be the set of variables which can be subjected to the framing technique. Since the assignment operators defined so far cannot manage framing in a desired way, we introduce new operators. First, for each variable x ∈ SV we introduce a special proposition aflag x , and then define the new assignments, in the following way (below e, e 1 , . . . , e n = nil, and op is any of the three new assignments):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>POSITIVE IMMEDIATE</head><p>x ⇐ e The meaning of these assignments is similar to those defined in Section 3.2.</p><p>The definition of the assignment flag is simple: af(x) df = aflag x , for every variable x ∈ SV (recall that aflag x cannot be used for any other purpose). The predicate af(x) is associated with some assignment operator and can be used to assert whether or not such an assignment has taken place to x in the execution of a program. Whenever such an assignment is encountered, af(x) should be true. Conversely, when af(x) is true, such an assignment should have been perceived in the execution of the program. As expected, when x ⇐ e is encountered, aflag x is set to true, hence af(x) is true.</p><p>Finally, we can define our looking back framing operators:</p><formula xml:id="formula_24">lbf(x) df = ¬af(x) → ∃b : ( -x = b ∧ x = b) frame(x) df = (more → lbf(x)) frame(x 1 , . . . , x n ) df = frame(x 1 ) ∧ • • • ∧ frame(x n )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Semantics of framed programs</head><p>We will interpret a framed program P using minimal (canonical) models. To this end, we assume that P contains a finite set V P of variables and a finite set Π P of propositions, respectively interpreted over</p><formula xml:id="formula_25">D df = D ∪ {nil} and B df = {true, false}.</formula><p>There are three main ways of interpreting propositions contained in P, namely the canonical, complete and partial, as in the semantics of logic programming languages <ref type="bibr" target="#b1">[2]</ref>. Here we will use the canonical one. That is, each I k var in a model σ = (I 0 var , I 0 prop ), (I 1 var , I 1 prop ), . . . is used as in the underlying logic, but I k prop is changed to the canonical interpretation.</p><p>A canonical interpretation on propositions is a set I prop ⊆ Π P and, implicitly, all propositions not in I prop are false. Note that in the logic framework I k prop is an assignment of a truth value in B to each proposition p ∈ Π at state s k ; whereas in a canonical interpretation, I k prop is a set of propositions of Π P which are true at s k . Clearly, these two definitions are equivalent except that they refer to different sets of variables and propositions.</p><p>Let σ = (I 0 var , I 0 prop ), (I 1 var , I 1 prop ), . . . be a model. We denote the sequence of interpretation on propositions of σ by σ pr op = I 0 prop , I • σ σ if σ σ and σ σ .</p><p>For example, ({x:1}, ∅) . = ({x:2}, ∅) and ({x:1}, ∅) (∅, {aflag x }) . If there exists a model σ with σ pr op being canonical and σ |= P as in the logic, then the program P is satisfiable under the canonical interpretation on propositions. We denote this by σ |= c P, and call σ pr op a canonical interpretation sequence (on propositions) of P. If σ |= P, for all σ with canonical σ pr op , then P is valid under the canonical interpretation on propositions. We denote this by |= c P. Note that the definition of a canonical interpretation of a program is independent of its syntax in the sense that it does not refer to the program's structure. Hence it can also be applied to temporal formulas.</p><p>Since a program can be satisfied by several different canonical models, one needs to carefully choose a model which reflects its intended meaning. We now formulate a central definition of this paper. One can see that it has the following four kinds of canonical models:</p><formula xml:id="formula_26">σ 1 = ({x:1}, {aflag x }), (∅, {aflag x }) σ 2 = ({x:1}, {aflag x }), ({x:1}, ∅) σ 3 = ({x:1}, ∅), (∅, {aflag x }) σ 4 = ({x:1}, ∅), ({x:1}, ∅) .</formula><p>The intended meaning of PROG VII is captured by its minimal model, in this case σ 4 . For this model, x is defined in both states of the interval and its value is equal to 1.</p><p>Using framing, program PROG I from the introduction can be amended as follows:</p><p>PROG VIII : frame(x) ∧ (x = 1) ∧ ((y := 2) ; (y := x + y)).</p><p>Note that PROG VIII has the same meaning as program PROG II, but it is more concise and has simpler implementation.</p><p>Theorem 4.1. The laws in Table <ref type="table" target="#tab_6">5</ref> all hold.</p><p>The proof of Theorem 4.1 can be found in the Appendix. These logic laws are basically algebraic properties of framing operators including equivalent, distributive, absorptive and idempotent laws. Note that the properties of the framing operator in Table <ref type="table" target="#tab_6">5</ref> are useful, in particular, in the reduction of framed programs. Another useful result is that the strong equivalence between programs also holds under the minimal model semantics.</p><p>Theorem 4.2. Let p and q be framed programs. We have,</p><formula xml:id="formula_27">1. p ≡ q implies p ≡ m q 2. I |= m p ∨ q implies I |= m p or I |= m q.</formula><p>Proof. (1) Suppose that I = (σ, 0, r, |σ |) |= m p. Then I |= p. Since p ≡ q, we have I |= q. If I |= m q, then there is I = (σ , 0, r, |σ |) such that I |= q and σ σ . By p ≡ q, we have I |= p and σ σ . In <ref type="bibr" target="#b5">[6]</ref> it was shown that if P is a (possibly non-deterministic or non-terminable) satisfiable framed program which has a finite model, or has finitely many models, then it also has at least one minimal model. However, for a program which has infinitely many infinite models and no finite model, the construction used in <ref type="bibr" target="#b5">[6]</ref> does not work. In this paper we extend the result of <ref type="bibr" target="#b5">[6]</ref> by showing that </p><formula xml:id="formula_28">≡ frame(x) ; frame(x) ≡ frame(x) ∧ frame(x) ≡ (¬first → lbf(x)) LAW62 frame(x) ∧ more ≡ (lbf(x) ∧ frame(x)) LAW63 frame(x) ∧ empty ≡ empty LAW64 frame(x) ∧ ( p ∨ q) ≡ frame(x) ∧ (frame(x) ∧ p ∨ q) ≡ frame(x) ∧ ( p ∨ frame(x) ∧ q) ≡ frame(x) ∧ (frame(x) ∧ p ∨ frame(x) ∧ q) ≡ frame(x) ∧ p ∨ frame(x) ∧ q LAW65 frame(x) ∧ ( p ; q) ≡ frame(x) ∧ (frame(x) ∧ p ; q) ≡ frame(x) ∧ ( p ; frame(x) ∧ q) ≡ frame(x) ∧ (frame(x) ∧ p ; frame(x) ∧ q) ≡ frame(x) ∧ p ; frame(x) ∧ q LAW66 frame(x) ∧ ( p q) ≡ frame(x) ∧ (frame(x) ∧ p q) ≡ frame(x) ∧ ( p frame(x) ∧ q) ≡ frame(x) ∧ (frame(x) ∧ p frame(x) ∧ q) ≡ frame(x) ∧ p frame(x) ∧ q</formula><p>Theorem 4.3. Each satisfiable framed program has at least one minimal model on propositions.</p><p>The proof of Theorem 4.3 can be found in the Appendix. This theorem asserts the existence of minimal models for a given framed program. The proof of the theorem requires more sophisticated technique than those used previously, and is based on the notion of a normal form graph (NFG) of a framed program introduced in the Appendix. Note that the proof itself provides a method for constructing a minimal model of a framed program.</p><p>It is worth noting that adding frame operators to PTL shifts the underlying semantics from a monotonic <ref type="bibr" target="#b14">[15]</ref> to non-monotonic one, ı.e. {w} z does not necessarily imply {w, u} z. Intuitively, adding a new positive fact, i.e., an explicit assignment, to a set of positive facts within a framing context can make it impossible to infer the negation of the fact which was previously possible.</p><p>Remark 4.4. The equivalence relation ≡ m on framed programs is not preserved through conjunction, sequence, parallel composition, projection and chop plus operators. For example, if we take</p><formula xml:id="formula_29">p df = (y = 1) ∧ (¬af(y) → y = -y) p df = (y = 1) ∧ (y = -y) q df = (y = 1) ∧ (¬af(y) → y = -y) ∧ (y ⇐ 9) q df = (y = 1) ∧ (y ⇐ 9)</formula><p>then we have p ≡ m p and q ≡ m q . On the other hand, p ∧ q ≡ m q and p ∧ q ≡ m false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Normal form of framed programs</head><p>We now introduce a normal form of framed programs and establish a fundamental property that each framed program can be transformed into a normal form. Note that the normal form is similar to that of non-framed programs given in <ref type="bibr" target="#b5">[6]</ref> except that it also involves the assignment flags.</p><formula xml:id="formula_30">Definition 4.2. A framed program q is in normal form if q = k i=1 h i ∧ empty ∨ h j=1 b j ∧ f j</formula><p>where k + h ≥ 1 and the following hold:</p><p>• Each f j is a lec-formula and f j is an internal program; the latter means variables may refer to the previous states but not beyond the first state of the current interval. <ref type="foot" target="#foot_1">5</ref>• Each b j and h i is either true or a state formula of the form p 1 ∧ • • • ∧ p m (m ≥ 1) such that each p z is either (x = e) with e ∈ D, or aflag x , or ¬aflag x .</p><p>The conjuncts h i ∧ empty and b j ∧ f j are called basic terminal products and basic future products, respectively. Moreover, b j (h i ) and f j are called present components and future components, respectively. Note that we may always assume that all the present components are different.</p><p>Theorem 4.5. For each program prog there is a program prog in normal form satisfying prog ≡ prog .</p><p>The proof of Theorem 4.5 can be found in the Appendix. It tells us that for each framed program there is an equivalent program in normal form. To take advantage of the normal form of framed programs, we need results allowing us to reduce programs in a convenient way.</p><p>Proposition 4.6. The following are satisfied:</p><formula xml:id="formula_31">1. (x = e) ≡ (aflag x ∧ (x = e)) ∨ (¬aflag x ∧ (x = e)). 2. lbf(x) ≡ aflag x ∨ (¬aflag x ∧ (x = -x)).</formula><p>Proof. Follows from the definitions.</p><p>We can use the above proposition in the reduction of framed programs, as shown below.</p><p>Example 4.2. For the framed program</p><formula xml:id="formula_32">PROG IX : frame(x) ∧ (x ⇐ 1) ∧ (x = 2) ∧ len(1)</formula><p>we have the following:</p><formula xml:id="formula_33">frame(x) ∧ (x ⇐ 1) ∧ (x = 2) ∧ len(1) ≡ (more → lbf(x)) ∧ (x ⇐ 1) ∧ (x = 2) ∧ (empty) ≡ (more → lbf(x)) ∧ (more → lbf(x)) ∧ (x ⇐ 1) ∧ (x = 2) ∧ more ∧ (empty) ≡ lbf(x) ∧ (more → lbf(x)) ∧ (x ⇐ 1) ∧ (x = 2) ∧ (empty) ≡ (x ⇐ 1) ∧ (lbf(x) ∧ (more → lbf(x)) ∧ (x = 2) ∧ empty) ≡ (x = 1) ∧ aflag x ∧ (lbf(x) ∧ (x = 2) ∧ empty).</formula><p>Thus the normal form of PROG IX is</p><formula xml:id="formula_34">0 i=1 h i ∧ empty ∨ 1 j=1 b j ∧ f j = b 1 ∧ f 1</formula><p>where:</p><formula xml:id="formula_35">b 1 ≡ (x = 1) ∧ aflag x f 1 ≡ lbf(x) ∧ (x = 2) ∧ empty ≡ (aflag x ∨ (¬aflag x ∧ (x = -x))) ∧ ((aflag x ∧ (x = 2)) ∨ (¬aflag x ∧ (x = 2)) ∧ empty ≡ (aflag x ∧ (x = 2) ∧ empty) ∨ (¬aflag x ∧ (x = 1) ∧ (x = 2) ∧ empty) ≡ aflag x ∧ (x = 2) ∧ empty.</formula><p>This shows that although there is no explicit assignments using ⇐ at a state, a potential positive assignment can occur since x = e can be treated as (aflag x ∧ (x = e)) ∨ (¬aflag x ∧ (x = e)).</p><p>Note that framed programs can be non-deterministic, as there may be several models satisfying the program under the canonical models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROG X :</head><p>frame(x, y, s) ∧ (x, y, s) = (0, 0, 0) ∧ for n times do ((x := + x + 1) ; (y := + y + x) ; (s := + s + y))</p><p>PROG XI : frame(x, y, s) ∧ (x, y, s) = (0, 0, 0) ∧ (for n times do (x := + x + 1) ; len(2)) ∧ (for (n + 1) times do (y := + y + x) ; skip) ∧ for (n + 2) times do (s := + s + y)</p><p>PROG XII : frame(x, y, s) ∧ (x, y, s) = (0, 0, 0) for n times do (x := + x + 1) (skip ; for n times do (y := + y + x)) (len(2) ; for n times do (s := + s + y))</p><p>PROG XIII :</p><formula xml:id="formula_36">frame(x, y, s) ∧ (x, y, s) = (0, 0, 0) ∧ ((x := + x + 1) ; ((x, y) := + (x + 1, y + x)) ; for n -2 times do ((x, y, s) := + (x + 1, y + x, s + y)) ; ((y, s, ) := + (y + x, s + y)) ; (s := + s + y))</formula><p>PROG XIV : frame(x, y, s) ∧ (x, y, s) = (0, 0, 0) ∧ for n times do (x := + x + 1) ∧ ((skip ; for n times do (y := + y + x))||(len(2) ; for n times do (s := + s + y))) Remark 4.7. There are two simple heuristics to be followed in the reduction of a framed program under the minimal model semantics:</p><p>1. Use the relation ≡ as far as possible during a reduction; 2. Do not use the minimal model to obtain ¬aflag x until the last stage of a reduction, and make sure that x has really not been assigned a value by ⇐ within all the conjuncts at the current state.</p><p>Moreover, the following facts are useful when carrying the reduction: Let q be a normal form of a framed program as in Definition 4.2.</p><p>1. If aflag x is not contained within the h i 's and b j 's then q ≡ m ¬aflag x ∧ q.</p><p>2. If aflag x and (x = e ), where e = e (e , e ∈ D), are not contained within the h i 's and b j 's then</p><formula xml:id="formula_37">(x = e) ∧ q ≡ m ¬aflag x ∧ (x = e) ∧ q (aflag x ∨ ¬aflag x ∧ (x = e)) ∧ q ≡ m ¬aflag x ∧ (x = e) ∧ q.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Programming in framed tempura</head><p>In this section, we show how framing can be used in TLP; and some basic techniques in various types of programs including sequential, conjunctive, parallel, or mixed computations are illustrated with examples. Each example shown in Fig. <ref type="figure" target="#fig_11">5</ref> indicates a useful property.</p><p>We consider a simple computation: given a positive integer n, to compute the sum of all integers in the sequence 1, . . . , n; and the sum of the sums of integers in every prefix of the sequence 1, . . . , n, i.e., 1+(1+2)</p><formula xml:id="formula_38">+• • •+(1+• • •+n).</formula><p>In the following, let n be a static variable, x, y, s dynamic variables. x represents an integer, y represents 1 + • • • + n, and s represents 1</p><formula xml:id="formula_39">+ (1 + 2) + • • • + (1 + • • • + n).</formula><p>The programs are designed in different manners for the purpose of showing the different applications of framing techniques. In each case, Fig. <ref type="figure" target="#fig_13">6</ref> shows the computation of a program for n = 4.  <ref type="figure">---|----|----|----|----|----|----|----|----|----|----|----</ref>  <ref type="figure">|-----|-----|-----|-----|-----|-----</ref>  <ref type="figure">|-----|-----|-----|-----|-----|-----</ref>  In each iteration, x is incremented by 1, y by x, and s by y. After n iterations, the computation sequences are 1, . . . , n for x, 0, 1, 1 + 2, . . . , 1 + • • • + n for y, and 0, 0, 1, 1</p><formula xml:id="formula_40">+ (1 + 2), . . . , 1 + (1 + 2) + • • • + (1 + 2 + • • • + n) for s.</formula><p>Hence, the values of y and s at the final state are correct results.</p><p>At state s 1 , s 2 , the computations proceed sequentially, at state s 3 , s 4 , conjunctively by for iteration, and at state s 5 , s 6 , again sequentially.</p><p>Introducing the framing operator enables us not only to write concise programs but also to define await construct within the underlying logic. Hence, synchronized communication can be handled within Framed Tempura.</p><p>As discussed earlier, the communication between parallel components in Tempura is based on shared variables. To synchronize the real concurrent computation, we need a synchronous communication construct such as await(c) by which the semaphore constructs can be defined. In Tempura, the statement halt(c) may play a similar role as await(c). But, within a non-framed environment, they are actually different. halt(c) is capable of changing variables contained in c at the final state over an interval but await(c) is not although they both wait for c to become true and terminate the interval over which they act. The key difference between await(c) and halt(c) is that the former can only wait until another process acting in parallel changes c to true, while the latter can change c itself at the final state without the help of other processes acting in parallel.</p><p>Therefore, halt(c), in general, as a synchronization construct for concurrent computations, is not suitable. However, if the variables contained in c are all framed, and no positive assignments appear in c (this is usually satisfied because we consider c as a condition, ı.e. a boolean expression), for this specific case, halt(c) is equivalent to await(c). This is immediate since the variables in c are framed and only positive assignments are able to change framed variables. For instance, frame(x) ∧ halt(x = 1) is similar to await(x = 1).</p><p>Defining await(c) is difficult without some kind of framing construct since the values of variables are not inherited automatically from one state to another. But one requires some kind of indefinite stability, since it cannot be known at the point of use how long the waiting will last. At the same time one must also allow variables to change, so that an external process can modify the boolean parameter and it can eventually become true.</p><p>The await statement is defined as follows: <ref type="figure">-----|------|------|------|------|------|------|------|------|------|  x=0</ref> 1 wait 1 2 wait 2 3 wait 3 4 wait 4</p><formula xml:id="formula_41">await(c) df = frame(x 1 ) ∧ • • • ∧ frame(x h ) ∧ halt(c) s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 |-</formula><formula xml:id="formula_42">5 wait 5 |------|------|------|------|------|------|------|------|------|------| y=0 wait 0</formula><p>1 wait 1 2 wait 2 3 wait 3 4 wait 4 5 where x 1 , . . . , x h are dynamic variables contained in c. With the help of the frame operator, the semaphore statements (i.e., P-V operations) can be defined respectively by:</p><formula xml:id="formula_43">P(r ) df = frame(r ) ∧ (halt(r &gt; 0) ; (r := + r -1)) V (r ) df = frame(r ) ∧ (r := + r + 1)</formula><p>where r is a dynamic variable initialized to 1.</p><p>Since frame(x) and halt(c) are both executable within the Framed Tempura, so is await(c). Therefore, synchronized communication for concurrent computations can be implemented. For instance, the following program synchronizes variables x and y in a parallel computation (see Fig. <ref type="figure" target="#fig_14">7</ref>): PROG XV : frame(x) ∧ frame(y) ∧ (x, y) = (0, 0)∧ while (x &lt; 5) do (x := + x + 1 ; await(y ≥ x)) while (y &lt; 5) do (await(y &lt; x) ; y := + y + 1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Concluding remarks</head><p>In this paper, we presented a framing technique with some distinct advantages; in particular, it has simple semantics and can be used in different environments (including sequential, conjunctive, parallel and mixed contexts), and allows mixing of framed and non-framed variables. We believe that it allows one to write concise, efficient and elegant programs, which allow synchronization and communication between parallel components.</p><p>The temporal semantics of framed programs is captured using the minimal model. This model allows us to treat variables which are framed and not assigned new values by the positive immediate assignments in such a way that their values are inherited. The minimal model does it by means of perceiving the defaults of positive immediate assignments. It should be emphasized that by using the minimal model, the underlying logic is changed from monotonic to non-monotonic. This implies that some logic laws related to the monotonic law such as substitution law are no longer valid within framed programs.</p><p>In the future, we will further investigate the operational semantics and axiomatic semantics of framed programs. Furthermore, we will explore the consistency between the minimal model semantics and operational semantics. In addition, based on these semantics, verification of framed programs will also be investigated by means of the model checking technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix. Proofs of selected results</head><p>Proof of Theorem 2.1. We need to show that, for all PTL formulas f, g, h, if f ≡ g then:</p><formula xml:id="formula_44">(i) f ∧ h ≡ g ∧ h (ii) h ∧ f ≡ h ∧ g (iii) ¬ f ≡ ¬g (iv) f + ≡ g + (v) f ≡ g (vi) -f ≡ -g.</formula><p>Each of (i)-(vi) is an immediate consequence of the definitions. We then take formulas p i ≡ p i (1 ≤ i ≤ m) and q ≡ q . We need to prove that (vii) ∃x : q ≡ ∃x : q (viii) ( p 1 , . . . , p m ) prj q ≡ ( p 1 , . . . , p m ) prj q .</p><p>Let σ be a model and k an integer such that 0 ≤ k |σ |. To show (vii) we observe that</p><formula xml:id="formula_45">(σ, 0, k, |σ |) |= ∃x : q ⇐⇒ (σ , 0, k, |σ |) |= q for some σ x = σ ⇐⇒ (σ , 0, k, |σ |) |= q for some σ x = σ ⇐⇒ (σ, 0, k, |σ |) |= ∃x : q .</formula><p>To show (viii), let I = (σ, 0, k, j) where j = |σ |. Then I |= ( p 1 , . . . , p m ) prj q iff there are k = r 0 ≤ r 1 ≤ • • • ≤ r m ≤ j such that (σ, i, r 0 , r 1 ) |= p 1 and (σ, r l-1 , r l-1 , r l ) |= p l for all 1 &lt; l ≤ m, and (σ , 0, 0, |σ |) |= q for σ given by: 1. If r m &lt; j then σ = σ↓(r 0 , . . . , r m )•σ (r m +1.. j) 2. If r m = j then σ = σ↓(r 0 , . . . , r h ) for some 0 ≤ h ≤ m.</p><p>Hence, by the induction hypothesis, I |= ( p 1 , . . . , p m ) prj q .</p><p>Proof of Theorem 2.2. Most of the laws can be found in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10]</ref>. We here prove some of them laws as others can be shown in the similar way. Note that p ≡ q is equivalent to saying that, for every interpretation I, we have I |= p iff I |= q. Below σ is an interval and k an integer such that 0 ≤ k |σ |. Note that the last equivalence holds since p is a rec-formula and q a lec-formula. Case 3: LAW8. Then   Case 9: LAW42. Then: I = (σ, 0, k, |σ |), p = p 1 , . . . , p m and q = q 1 , . . . , q n . We proceed as follows: I |= (p, empty ∧ w, p, q) prj q iff there exist integers r 1 , . </p><formula xml:id="formula_46">(σ, 0, k, |σ |) |= p ∧ q ⇐⇒ (σ, 0, k + 1, |σ |) |= p and (σ, 0, k + 1, |σ |) |= q and k &lt; |σ | ⇐⇒ (σ, 0, k + 1, |σ |) |= p ∧ q ⇐⇒ (σ, 0, k, |σ |) |= ( p ∧ q).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Moreover</head><p>σ ↓ (r 0 , . . . r t , r e ) = σ ↓ (r 0 , . . . r t ) (r t = r e ) and σ ↓ (r 0 , . . . r t , r e , r t+1 , . . . r m ) = σ ↓ (r 0 , . . . r t , r t+1 , . . . r m )(r t = r e ). Therefore (σ, 0, k, |σ |) |= ( p 1 , . . . p t , empty ∧ p, p t+1 , . . . p m ) prj q ≡ (p, w ∧ p, q) prj q.</p><p>Proof of Theorem 3.1. Case 1: LAW59. Then: </p><formula xml:id="formula_47">while b do p ≡ (b ∧ p) * ∧ fin(¬b) (i) ≡ (empty ∨ (b ∧ p ∧ more ; (b ∧ p) * )) ∧ fin(¬b) ∨ b ∧ p ∧ more ∧ fin(¬b) (ii) ≡ empty ∧ (empty → ¬b) ∨ (b ∧ p ∧ more ; (b ∧ p) * ) ∧ fin(¬b) ∨ b ∧ p ∧ more (iii) ≡ empty ∧ (empty → ¬b) ∨ (b ∧ p ∧ more ; (b ∧ p) * ) ∧ fin(¬b) ∨ b ∧ p ∧ more (iv) ≡ (empty ∧ ¬b) ∨ (b ∧ p ∧ more ; fin(¬b) ∧ (b ∧ pp) * ) ∨ b ∧ p ∧ more (v) ≡ (empty ∧ ¬b) ∨ (b ∧ p ∧ more ; while b do p) ∨ b ∧ p ∧ more.<label>(vi</label></formula><formula xml:id="formula_48">≡ (empty ∨ (b ∧ p ; (b ∧ p) * )) ∧ fin(¬b) ∨ b ∧ p ∧ more ∧ fin(¬b) (ii) ≡ empty ∧ (empty → ¬b) ∨ (b ∧ p ; (b ∧ p) * ) ∧ fin(¬b) ∨ b ∧ p ∧ more (iii) ≡ empty ∧ (empty → ¬b) ∨ (b ∧ p ; (b ∧ p) * ) ∧ fin(¬b) ∨ b ∧ p ∧ more (iv) ≡ (empty ∧ ¬b) ∨ (b ∧ p ; fin(¬b) ∧ (b ∧ p) * ) ∨ b ∧ p ∧ more (v) ≡ (empty ∧ ¬b) ∨ (b ∧ p ; while b do p) ∨ b ∧ p ∧ more.<label>(i)</label></formula><p>In the above: (i, vi) follow from definitions; (ii) from LAW26; (iii) from ( more) ∧ fin(¬b) ≡ more; (iv) from LAW24; and (v) from LAW52.</p><p>Proof of Theorem 4.1. We here prove some of them laws as others can be shown in the similar way.</p><p>Case 1: LAW62. Then frame(x) ∧ more ≡ (more → lbf(x)) ∧ more (i) Case 4: LAW66. Then</p><formula xml:id="formula_50">≡ (more → lbf(x)) ∧ (more → lbf(x)) ∧ more (ii) ≡ lbf(x) ∧ more ∧ (more → lbf(x)) (iii) ≡ lbf(x) ∧ more ∧ frame(x) (iv) ≡ (lbf(x) ∧ frame(x)) ∧ more (v) ≡ (lbf(x) ∧ frame(x)).<label>(vi</label></formula><formula xml:id="formula_51">I |= frame(x) ∧ (frame(x) ∧ p q) ⇐⇒ I |= frame(x) ∧ ((frame(x) ∧ p ; true) ∧ q) ∨ frame(x) ∧ p ∧ (q ; true)) (i) ⇐⇒ I |= frame(x) ∧ q ∧ (frame(x) ∧ p ; true) ∨ frame(x) ∧ p ∧ (q ; true) (ii) ⇐⇒ I |= frame(x) ∧ q ∧ ( p ; true) ∨ frame(x) ∧ p ∧ (q ; true) (iii) ⇐⇒ I |= frame(x) ∧ (q ∧ ( p ; true) ∨ p ∧ (q ; true)) (iv) ⇐⇒ I |= frame(x) ∧ ( p q).<label>(v)</label></formula><p>In the above: (i) and (v) follow from definitions; (ii) from LAW64 and LAW61; (iii) from LAW65; and (iv) from LAW64.</p><p>Proof of Theorem 4.5. To simplify the proof, we assume that the expressions involved in a framed program are well evaluated at every state during a reduction. The proof proceeds by induction on the structure of a program (cases not dealt with below can be handled in a similar way). An immediate assignment is a non-deterministic program, so it needs other constructs to specify a definite interval. If an empty interval is specified, it is reduced to</p><formula xml:id="formula_52">((x = e) ∧ aflag x ∧ empty) ∨ ((x = e) ∧ ¬aflag x ∧ empty)</formula><p>otherwise, it is reduced to</p><formula xml:id="formula_53">(((x = e) ∧ aflag x ) ∧ true) ∨ (((x = e) ∧ ¬aflag x ) ∧ true).</formula><p>Case 2: prog = (x ⇐ e). Then:</p><formula xml:id="formula_54">prog ≡ ((x = e) ∧ aflag x ) ∧ (empty ∨ more) ≡ ((x = e) ∧ aflag x ∧ empty) ∨ (((x = e) ∧ aflag x ) ∧ true).</formula><p>Case 3: prog = empty. Then the result clearly holds. Case 4: prog = p. Then prog is already in normal form. Case 5: prog = q. Then:</p><p>prog ≡ q ∧ q (i)</p><formula xml:id="formula_55">≡ (h j ∧ empty) ∨ (b i ∧ f i ) ∧ (empty ∨ q) (ii) ≡ (h j ∧ empty) ∨ ((b i ∧ f i ) ∧ q) (iii) ≡ (h j ∧ empty) ∨ (b i ∧ (f i ∧ q)).<label>(iv)</label></formula><p>In the above: (i) follows from LAW24; (ii) from the hypothesis and AWNEXT; (iii) from AMORE; and (iv) from LAW8. Case 6: prog = p ∧ q, where (here and below)</p><formula xml:id="formula_56">p ≡ l 1 k=1 (p k ∧ empty) ∨ t 1 i=1 (r i ∧ t i ) and q ≡ l 2 h=1 (h h ∧ empty) ∨ t 2 j=1 (b j ∧ f j )</formula><p>and we can rewrite prog, as follows:</p><formula xml:id="formula_57">prog ≡ (p k ∧ empty) ∨ (r i ∧ t i ) ∧ (h h ∧ empty) ∨ (b j ∧ f j ) (i) ≡ (p k ∧ h k ∧ empty) ∨ (r i ∧ t i ) ∧ (b j ∧ t j ) (ii) ≡ (p k ∧ h k ∧ empty) ∨ 1≤i≤t 1 ,1≤ j≤t 2 ((r i ∧ b j ) ∧ (t i ∧ f j )). (iii)</formula><p>In the above: (i) follows from the hypothesis; (ii) from AMORE and LAW25; and (iii) from LAW8.  (iv)</p><p>In the above: (i) follows from the hypothesis; (ii) from LAW11 and LAW12; (iii) from LAW30, LAW15, LAW11 and LAW12; and (iv) from LAW9 and LAW11.</p><p>Case 8: prog = p q. First, we have that:</p><p>(q ; true) ≡ (h h ∧ empty) ∨ (b j ∧ f j ) ; true (i) where b t 2 +1 ≡ h 1 and f t 2 +1 ≡ true. In the above: (i) follows from the hypothesis; (ii) from LAW12; (iii) from LAW15 and LAW16; and (iv) from empty ; true ≡ true. Thus p ∧ (q ; true) ≡ (p k ∧ empty) ∨ (r i ∧ t i )</p><formula xml:id="formula_58">≡ (h h ∧ empty) ; true ∨ (b j ∧ f j ) ; true<label>(ii)</label></formula><formula xml:id="formula_59">∧ (h h ∧ empty) ∨ t 2 +1</formula><p>j=1 (b j ∧ (f j ; true)) (i)</p><formula xml:id="formula_60">≡ (p k ∧ h k ∧ empty) ∨ (r i ∧ t i ) ∧ t 2 +1</formula><p>j=1 (b j ∧ (f j ; true)) (ii)</p><formula xml:id="formula_61">≡ (p k ∧ h k ∧ empty) ∨ 1≤i≤t 1 ,1≤ j≤t 2 +1</formula><p>((r i ∧ b j ) ∧ (t i ∧ (f j ; true))).</p><p>In the above: (i) follows from the hypothesis; and (ii) from AMORE. Similarly, we can prove that q ∧ ( p ; true) ≡ (h k ∧ p k ∧ empty) ∨ 1≤i≤t 1 +1,1≤ j≤t 2 ((b i ∧ r j ) ∧ (f i ∧ (t j ; true))) .</p><p>As a consequence, we have that prog ≡ p ∧ (q ; true) ∨ q ∧ ( p ; true)</p><formula xml:id="formula_62">≡ (p k ∧ h k ∧ empty) ∨ 1≤i≤t 1 ,1≤ j≤t 2 +1</formula><p>((r i ∧ b j ) ∧ (t i ∧ (f j ; true)))</p><formula xml:id="formula_63">∨ (h k ∧ p k ∧ empty) ∨ 1≤i≤t 1 +1,1≤ j≤t 2</formula><p>((b i ∧ r j ) ∧ (f i ∧ (t j ; true)))</p><formula xml:id="formula_64">≡ (p k ∧ h k ∧ empty) ∨ 1≤i≤t 1 ,1≤ j≤t 2 +1</formula><p>((r i ∧ b j ) ∧ (t i ∧ (f j ; true)))</p><formula xml:id="formula_65">∨ 1≤i≤t 1 +1,1≤ j≤t 2</formula><p>((b i ∧ r j ) ∧ (f i ∧ (t j ; true))) .</p><p>Case 9: prog = ( p 1 , . . . , p m ) prj q, where q is a non-past formula. Suppose</p><formula xml:id="formula_66">q ≡ (h r ∧ empty) ∨ (b i ∧ f i )</formula><p>and, for 1 ≤ l ≤ m, p l ≡ (p lr ∧ empty) ∨ (r l j ∧ t l j ).  </p><formula xml:id="formula_67">≡ b i ∧ p 11 ∧ • • • ∧ p m1 ∧ f i ∨ 1≤ j≤k 1 ,1≤i≤h b i ∧ r 1 j ∧ (t<label>1</label></formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>df=</head><label></label><figDesc>I var [v], and for each proposition π ∈ Π gives s[π ] df = I prop [π ]. Each I var [v] is a value in data domain D with the appropriate type or nil (undefined), whereas I prop [π ] is true or false. In the examples, the assignment I var can be specified as the set of pairs of the form v : I var [v], where I var [v] = nil. Similarly, I prop can be specified as the set of those π for which I prop [π] = true. Sometimes only the relevant elements may be listed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 2 . 1 .</head><label>21</label><figDesc>As our first example, consider the formula p df = (x = 1) ∧ (( x) = (( x) + x)) and the interval σ = (I 0 var , I 0 prop ), . . . such that I 0 var = {x : 1}, I 1 var = {x : 2} and I 2 var = {x : 3}. One can show that I |= p, where I df = (σ, 0, 0, 2), in the following way: I |= p ⇐⇒ I |= (x = 1) and I |= ( x) = (( x) + x) ⇐⇒ I[x] = I[1] and I[ x] = I[ x] + I[x]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Possible executions of ( p 1 , p 2 , p 3 ) prj q.</figDesc><graphic coords="7,135.98,62.65,268.56,188.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Computing using the projection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>while b do p ≡ if b then ( p ; while b do p) else empty LAW58 while b do p ≡ if b then ( p ∧ more ; while b do p) else empty LAW59 while b do p ≡ ((¬b ∧ empty) ∨ (b ∧ p ∧ more ; while b do p)) ∨ b ∧ p ∧ more LAW60 while b do p ≡ ((¬b ∧ empty) ∨ (b ∧ p ; while b do p)) ∨ b ∧ p ∧ more</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FOR LOOP for 0 times do p df = empty for n + 1</head><label>1</label><figDesc>times do p df = (for n times do p) ; p REPEAT LOOP repeat p until b df = p ; while ¬b do p</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>e</head><label></label><figDesc>::= n | e 1 + e 2 | e 1 -e 2 | e 1 * e 2 | e 1 /e 2 | e 1 mod e 2 | e | -e b ::= true | false | e 1 &gt; e 2 | e 1 ≥ e 2 | e 1 &lt; e 2 | e 1 ≤ e 2 | e 1 = e 2 | e 1 = e 2 | ¬b 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>df=</head><label></label><figDesc>(x = e) ∧ aflag x NEXT x •= + e df = ( x = e) ∧ aflag x UNIT x := + e df = (x •= + e) ∧ skip MULTIPLE (x 1 , . . . x n ) op (e 1 , . . . , e n ) df = (x 1 op e 1 ) ∧ • • • ∧ (x n op e n )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Definition 4 . 1 .</head><label>41</label><figDesc>Let P be a program, and I = (σ, i, k, j) be a canonical interpretation. Then I is a minimal interpretation of P if I |= c P, and there is no σ such that σ σ and (σ , i, k, j) |= c p. We denote this by I |= m p.A minimal model of a program P is any canonical model σ such that (σ, 0, 0, |σ |) |= m p. We denote this by σ |= m p. Moreover, the equivalence relations ≡ m and ≈ m as well as the strong implication relation ⊃ m can be defined similarly as the relations ≡, ≈ and ⊃. Example 4.1. Consider the program PROG VII : frame(x) ∧ (x = 1) ∧ len(1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>( 2 )</head><label>2</label><figDesc>Let I = (σ, 0, k, |σ |). We have I |= p or I |= q, so suppose that the former holds. If I |= m p, then there exists I = (σ , 0, k, |σ |) such that I |= p and σ σ , leading to I |= p∨q and σ σ . This contradicts I |= m p∨q.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Sequential, conjunctive, parallel, mixed sequential &amp; conjunctive and mixed conjunctive &amp; parallel computations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Different kinds of computations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. A synchronized computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Case 1 :</head><label>1</label><figDesc>LAW1. Then (σ, 0, k, |σ |) |= empty ; p ⇐⇒ (σ, 0, k, r ) |= empty and (σ, r, r, |σ |) |= p for some r ⇐⇒ k = r and (σ, r, r, |σ |) |= p ⇐⇒ (σ, k, k, |σ |) |= p ⇐⇒ (σ, i, k, |σ |) |= p. Note that the last equivalence holds since p is a lec-formula. Case 2: LAW2. Then (σ, 0, k, |σ |) |= ( p ∧ empty) ; q ⇐⇒ (σ, 0, k, r ) |= p ∧ empty and (σ, r, r, |σ |) |= q for some r ⇐⇒ (σ, 0, k, r ) |= p and r = k and (σ, r, r, |σ |) |= q ⇐⇒ (σ, 0, k, k) |= p and (σ, k, k, |σ |) |= q ⇐⇒ (σ, 0, k, |σ |) |= p and (σ, 0, k, |σ |) |= q.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Case 4 :</head><label>4</label><figDesc>LAW11. Then (σ, 0, k, |σ |) |= w ; p ∨ q ⇐⇒ (σ, 0, k, r ) |= w and ((σ, r, r, |σ |) |= p or (σ, r, r, |σ |) |= q) for some r ⇐⇒ (σ, 0, k, r ) |= w and (σ, r, r, |σ |) |= p for some r or (σ, 0, k, r ) |= w and (σ, r, r, |σ |) |= q for some r ⇐⇒ (σ, 0, k, |σ |) |= (w ; p) ∨ (w ; q).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Case 5 :</head><label>5</label><figDesc>LAW14. Then we need to show that (σ, 0, k, |σ |) |= (∃x : p) ↔ ∃x : p. If k = |σ |, this is vacuously true. If k &lt; |σ |, we have (σ, 0, k, |σ |) |= (∃x : p) ⇐⇒ (σ, 0, k + 1, |σ |) |= ∃x : p (i) ⇐⇒ (σ , 0, k + 1, |σ |) |= p for some σ x = σ (ii) ⇐⇒ (σ , 0, k, |σ |) |= p for some σ x = σ (iii) ⇐⇒ (σ, 0, k, |σ |) |= ∃x : p. (iv) In the above: (i) follows from INEXT; (ii) from IEXISTS; (iii) from INEXT; and (iv) from IEXISTS. Case 6: LAW15. Then (σ, 0, k, |σ |) |= p ; q ⇐⇒ (σ, 0, k, r ) |= p and (σ, r, r, |σ |) |= q for some r ⇐⇒ (σ, 0, k + 1, r ) |= p and k &lt; r and (σ, r, r, |σ |) |= q for some r ⇐⇒ (σ, 0, k + 1, |σ |) |= p ; q ⇐⇒ (σ, 0, k, |σ |) |= ( p ; q).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>)</head><label></label><figDesc>In the above: (i) follows from definition; (ii) from LAW27; (iii) from ( more) ∧ fin(¬b) ≡ more; (iv) from LAW24; (v) from LAW52; and (vi) from definition. Case 2: LAW57. Then: while b do p ≡ (empty ∧ ¬b) ∨ (b ∧ p ; while b do p) ≡ (empty ∧ ¬b) ∨ b ∧ ( p ; while b do p) ≡ if b then ( p ; while b do p) else empty. Case 3: LAW58. Then while b do p ≡ (empty ∧ ¬b) ∨ (b ∧ p ∧ more ; while b do p) ≡ (empty ∧ ¬b) ∨ b ∧ ( p ∧ more ; while b do p) ≡ if b then ( p ∧ more ; while b do p) else empty. Case 4: LAW60. Then while b do p ≡ (b ∧ p) * ∧ fin(¬b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>)</head><label></label><figDesc>In the above: (i) follows from def.lbf; (ii) from LAW24; (iii) from LAW13; (iv) from the definition of lbf; (v) from LAW8; and (vi) from LAW25. Case 2: LAW64. Then I |= frame(x) ∧ ( p ∨ q) ⇐⇒ I |= frame(x) and I |= p ∨ q (i) ⇐⇒ I |= frame(x) and (I |= p or I |= q) ⇐⇒ (I |= frame(x) and I |= p) or (I |= frame(x) andI |= q) ⇐⇒ I |= frame(x) ∧ p or I |= frame(x) ∧ q (ii) ⇐⇒ I |= frame(x) ∧ p ∨ frame(x) ∧ qwhere I is an interpretation. In the above: (i) and (ii) follow from IAND. Case 3: LAW65. Then I |= frame(x) ∧ (frame(x) ∧ p ; q) ⇐⇒ I |= frame(x) and I |= (frame(x) ∧ p ; q) (i) ⇐⇒ I |= frame(x) and (σ, 0, k, r ) |= frame(x) ∧ p and (σ, r, r, |σ |) |= q for some r (ii) ⇐⇒ I |= frame(x) and (σ, 0, k, r ) |= frame(x) and (σ, 0, k, r ) |= p and (σ, r, r, |σ |) |= q for some r (iii) ⇐⇒ I |= frame(x) and (σ, 0, k, r ) |= frame(x) and I |= p ; q for some r (iv) ⇐⇒ I |= frame(x) and I |= p ; q (v) ⇐⇒ I |= frame(x) ∧ ( p ; q) (vi) where I = (σ, 0, k, |σ |) is an interpretation. In the above: (i) follows from IAND; (ii) from ICHOP; (iii) from IAND; (iv) from ICHOP; (vi) from IAND; and (v) from the fact that if σ is an interval and 0 ≤ k ≤ r |σ |, then (σ, 0, k, |σ |) |= frame(x) =⇒ (σ, 0, k, r ) |= frame(x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Case 1 :</head><label>1</label><figDesc>prog = (x = e). Then: prog ≡ ((x = e) ∧ aflag x ∨ (x = e) ∧ ¬aflag x ) ∧ (empty ∨ more) ≡ ((x = e) ∧ aflag x ∨ (x = e) ∧ ¬aflag x ) ∧ empty∨ ((x = e) ∧ aflag x ∨ (x = e) ∧ ¬aflag x ) ∧ true ≡ ((x = e) ∧ aflag x ∧ empty) ∨ (x = e ∧ ¬aflag x ∧ empty) ∨ (((x = e) ∧ aflag x ) ∧ true) ∨(((x = e) ∧ ¬aflag x ) ∧ true).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>(</head><label></label><figDesc>r i ∧ (t i ; (b j ∧ f j ))).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>≡</head><label></label><figDesc>h h ∧ (empty ; true) ∨ (b j ∧ (f j ; true)) (iii) ≡ h h ∧ true ∨ (b j ∧ (f j ; true)) (iv) ≡ (h h ∧ empty) ∨ h 1 ∧ true ∨ (b j ∧ (f j ; true)) ≡ (h h ∧ empty) ∨ t 2 +1j=1 (b j ∧ (f j ; true))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>j ; ( p 2 , . . . , p m ) prj f i ) ∨ 1≤t≤m-1,1≤ j≤k t+1 ,1≤i≤h (b i ∧ p 11 ∧ • • • ∧ p t1 ∧ r t+1, j ∧ (t t+1, j ; ( p t+2 , . . . , p m+1 ) prj f i ). ( * * )From (*) and (**) it follows that prog can be reduced to normal form. Case 10: prog = if b then p else q. Then if b is true in a context in which prog is executed then prog is reduced to p and otherwise to q. Case 11: prog = while b do p. Then, by LAW59, we havewhile b do p ≡ ¬b ∧ empty ∨ (b ∧ p ∧ more ; while b do p) ∨ p ∧ b ∧ more.Therefore, if b is false at the current state according to the context in which prog is executed, then the while statement is reduced to empty. Otherwise, it is reduced to p ∧ more ; while b do p ∨ p ∧ more which is immediately re-reduced, as follows:p ∧ more ; while b do p ∨ p ∧ more ≡ p ∧ ( true ; while b do p ∨ more ∧ more) (i) ≡ p ∧ ( (true ; while b do p ) ∨ more) (ii) ≡ p ∧ ((true ; while b do p ) ∨ more) (iii) ≡ p k ∧ empty ∨ r i ∧ t i ∧ ((true ; while b do p ) ∨ more) (iv) ≡ r i ∧ t i ∧ ((true ; while b do p ) ∨ more) (v) ≡ r i ∧ (t i ∧ ((true ; while b do p ) ∨ more)).(vi)In the above: (i) follows from LAW24; (ii) from LAW13 and LAW15; (iii) from LAW9; (iv) and (v) from the hypothesis; and (vi) from LAW8 and LAW11.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>e 1 , . . . , e m )]</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>df =</cell><cell cols="2">f (I[e 1 ], . . . , I[e m ]) if I[e h ] = nil for all 1 ≤ h ≤ m nil otherwise</cell></row><row><cell cols="2">IENEXT</cell><cell>I[ e]</cell><cell>df =</cell><cell>(σ, i, k + 1, j)[e] nil</cell><cell>if k &lt; j otherwise</cell></row><row><cell cols="2">IEPREV</cell><cell>I[ -e]</cell><cell>df =</cell><cell>(σ, i, k -1, j)[e] nil</cell><cell>if i &lt; k otherwise</cell></row><row><cell>IBEG</cell><cell cols="2">I[beg(e)]</cell><cell cols="2">df = (σ, i, i, j)[e]</cell></row><row><cell>IEND</cell><cell cols="2">I[end(e)]</cell><cell>df =</cell><cell>(σ, i, j, j)[e] nil</cell><cell>if j = ω otherwise</cell></row><row><cell cols="6">Fig. 1. Interpreting PTL terms, where v is a static or dynamic variable, and e, e 1 , . . . , e m are terms. Note that I = (σ, i, k, j) is an interpretation.</cell></row><row><cell>IPROP</cell><cell>I |= π</cell><cell></cell><cell></cell><cell cols="2">if s k [π] = I k prop [π ] = true</cell></row><row><cell>IPRED</cell><cell cols="3">I |= P(e 1 , . . . , e m )</cell><cell cols="2">if P(I[e 1 ], . . . , I[e m ]) = true,</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">and I[e h ] = nil for all 1 ≤ h ≤ m</cell></row><row><cell cols="3">IEQUAL I |= e 1 = e 2</cell><cell></cell><cell>if I[e 1 ] = I[e 2 ]</cell></row><row><cell>INEG</cell><cell cols="2">I |= ¬ p</cell><cell></cell><cell>if I |= p</cell></row><row><cell>IAND</cell><cell cols="2">I |= p ∧ q</cell><cell></cell><cell>if I |= p and I |= q</cell></row><row><cell>INEXT</cell><cell>I |=</cell><cell>p</cell><cell></cell><cell cols="2">if k &lt; j and (σ, i, k + 1, j) |= p</cell></row><row><cell>IPREV</cell><cell cols="2">I |= -p</cell><cell></cell><cell cols="2">if i &lt; k and (σ, i, k -1, j) |= p</cell></row><row><cell cols="3">IEXISTS I |= ∃v : p</cell><cell></cell><cell cols="2">if (σ , i, k, j) |= p for some σ</cell><cell>v = σ</cell></row><row><cell>IPRJ</cell><cell cols="2">I |= ( p 1 , . . . , p</cell><cell></cell><cell></cell></row></table><note><p>m ) prj q if there are k</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>Derived PTL formulas</cell><cell></cell><cell></cell></row><row><cell>AEMPTY</cell><cell>empty</cell><cell>df</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell>PTL laws II</cell><cell></cell></row><row><cell>LAW39</cell><cell>p prj empty ≡ p 1 ; . . . ; p m</cell></row><row><cell>LAW40</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>next group of derived operators are concerned with termination and the final state.</figDesc><table><row><cell>FINAL</cell><cell>fin( p)</cell><cell>df =</cell><cell>(empty → p)</cell></row><row><cell cols="2">KEEP keep( p)</cell><cell>df =</cell><cell>(¬empty → p)</cell></row><row><cell>HALT</cell><cell>halt( p)</cell><cell></cell><cell></cell></row></table><note><p>df = (empty ↔ p) Note that: fin( p) holds over an interval as long as p holds at the final state; keep( p) holds over an interval if p holds at every non-final state; and halt( p) holds over an interval if and only if p holds at the final state.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5</head><label>5</label><figDesc></figDesc><table><row><cell>Framing laws</cell><cell></cell></row><row><cell>LAW61</cell><cell>frame(x) ≡ frame(x) frame(x)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>. . r t , r e , r t+1 , . . . r m and r 0 = k such that I |= [ p 1 , . . . p t , empty ∧ p, p t+1 , . . . p m ](r 1 , . . . r t , r e , r t+1 , . . . r m ) and r m = |σ | and σ ↓ (r 0 , . . . r h ) |= q for some 0 ≤ h ≤ m or h = e or r m &lt; |σ | and σ ↓ (r 0 , . . . r t , r e , r t+1 , . . .r m ) • σ (r m +1...|σ |) |= q. Since (σ, 0, k, |σ |) |= [ p 1 , . . . p t ,empty ∧ p, p t+1 , . . . p m ](r 1 , . . . r t , r e , r t+1 , . . . r m ) ⇐⇒ (σ, 0, k, r 1 ) |= p 1 and (σ, r l-1 , r l-1 , r l ) |= p l for all l, 1 &lt; l ≤ t and (σ, r t , r t , r e ) |= empty ∧ p and (σ, r e , r e , r t+1 ) |= p t+1 and (σ, r l-1 , r l-1 , r l ) |= p Since p is a state-formula we have (σ, r t , r t , r t ) |= p ⇔ (σ, r t , r t , r t+1 ) |= p. Hence ⇐⇒ (σ, 0, k, r 1 ) |= p 1 and (σ, r l-1 , r l-1 , r l ) |= p for all l, 1 &lt; l ≤ t and ⇐⇒ (σ, r t , r t , r t+1 ) |= p ∧ p t+1 and (σ, r l-1 , r l-1 , r l ) |= p l for all t + 1 &lt; l ≤ m ⇐⇒ (σ, 0, k, |σ |) |= [ p 1 , . . . p t , p ∧ p t+1 , . . . p m ](r 1 , . . . r t , r t+1 , . . . r m ).</figDesc><table /><note><p>l for all t + 1 &lt; l ≤ m ⇐⇒ (σ, 0, k, r 1 ) |= p 1 and (σ, r l-1 , r l-1 , r l ) |= p l for all l, 1 &lt; l ≤ t and (σ, r t , r t , r t ) |= p and (σ, r t , r t , r t+1 ) |= p t+1 and (r t = r e , p is a state-formula) (σ, r l-1 , r l-1 , r l ) |= p l for all t + 1 &lt; l ≤ m</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>Case 7: prog = p ; q. Then:prog ≡ (p k ∧ empty) ∨ (r i ∧ t i ) ; (h h ∧ empty) ∨ (b j ∧ f j ) (i) ≡ (p k ∧ empty) ; (h h ∧ empty) ∨ (r i ∧ t i ) ; (h h ∧ empty) ∨ (p k ∧ empty) ; (b j ∧ f j ) ∨ (r i ∧ t i ) ; (b j ∧ f j ) (ii) ≡ (p k ∧ h k ∧ empty) ∨ (r i ∧ (t i ; (h 1 ∧ empty))) ∨ (p 1 ∧ b j ∧ f j ) ∨ (r i ∧ (t i ; (b j ∧ f j ))) (iii) ≡ (p k ∧ h k ∧ empty) ∨ (r i ∧ (t i ; (h 1 ∧ empty)))∨ ((p 1 ∧ b j ) ∧ f j ) ∨ 1≤i≤t 1 ,1≤ j≤t 2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>Moreover, we have that( p 1 , . . . , p m ) prj (b i ∧ f i ) ≡ b i ∧ (( p 1 , . . . , p m ) prj f i ) (i) ≡ b i ∧ (( p 1 ∧ p 2 ∧ • • • ∧ p m ∧ empty) ; f i ) ∧ • • • ∧ p t ∧ empty) ; p t+1 ∧ more ; ( p t+2 , . . . , p m+1 ) prj f i ) (ii) ≡ b i ∧ ((p 11 ∧ • • • ∧ p m1 ∧ empty) ; f i ) ≡ b i ∧ p 11 ∧ • • • ∧ p m1 ∧ (empty ; q f ) 01 ∧ p 11 ∧ • • • ∧ p t1 ∧ empty) ; ∧ t t+1 j ; ( p t+2 , . . . , p m+1 ) prj f i (iv) ≡ b i ∧ p 11 ∧ • • • ∧ p m1 ∧ f i ∨ 1≤ j≤k 1 (b i ∧ r 1 j ∧ p f 1 j ; ( p 2 , . . . , p m ) prj f i ) ∨ 1≤t≤m-1,1≤ j≤k t+1 (b i ∧ p 11 ∧ • • • ∧ p t1 ∧ r t+1, j ∧ t t+1, j ; ( p t+2 , . . . , p m+1 ) prj f i ) (v) ≡ b i ∧ p 11 ∧ • • • ∧ p m1 ∧ f i ∨ 1≤ j≤k 1 b i ∧ r 1 j ∧ (t 1 j ; ( p 2 , . . . , p m ) prj f i ) ∨ 1≤t≤m-1,1≤ j≤k t+1 (b i ∧ p 11 ∧ • • • ∧ p t1 ∧r t+1, j ∧ (t t+1, j ; ( p t+2 , . . . , p m+1 ) prj f i ). (vi) In the above: (i) follows from LAW51; (ii) from LAW56; (iii) from p 01 ≡ empty; (iv) from LAW16 and LAW25; (v) from LAW11 and LAW2; and (vi) from LAW15. Therefore, ( p 1 , . . . , p m ) prj (b i ∧ f i )</figDesc><table><row><cell>∨b i ∧</cell><cell>m-1</cell><cell>(p k t+1</cell><cell>r t+1 j</cell></row><row><cell></cell><cell>t=0</cell><cell>j=1</cell><cell></cell></row><row><cell cols="2">m-1</cell><cell></cell><cell></cell></row><row><cell cols="3">∨b i ∧ (( p 0 ∨b i ∧ t=0 m-1</cell><cell></cell></row><row><cell>k t+1</cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p><p><p>Then prog ≡ ( p 1 , . . . , p m ) prj (h r ∧ empty) ∨ (b i ∧ f i ) (i) ≡ ( p 1 , . . . , p m ) prj (h 1 ∧ empty) ∨ ( p 1 , . . . , p m ) prj ((b i ∧ f i )). (ii)</p>In the above: (i) follows from the hypothesis; and (ii) from LAW44. Furthermore, we have</p>(</p>p 1 , . . . , p m ) prj (h 1 ∧ empty) ≡ h 1 ∧ ( p 1 , . . . , p m ) prj empty (i) ≡ h 1 ∧ ( p 1 ; . . . ; p m ). (ii) In the above: (i) follows from LAW51; and (ii) from LAW39. By Case 7, ( p 1 ; . . . ; p m ) can be reduced to a normal form and so can h 1 ∧ ( p 1 ; . . . ; p m ). Hence h 1 ∧ ( p 1 ; . . . ; p m ) ≡ (p r ∧ empty) ∨ (r j ∧ t j ). ( * ) t=0 (p 01 ∧ p 11 ∧ p 21 ∧ • • • ∧ p t1 ∧ empty) ; j=1 r t+1, j ∧ t t+1, j ∧ more ; ( p t+2 , . . . , p m+1 ) prj f i (iii)</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>PTL subsumes ITL since it can express the chop and projection operators of ITL.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>For instance, --x is not permitted, but -x is.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>$ This research was supported by NSFC Grant 60433010 and 60373103, and Defence Pre-Research Project of China NO. 51315050105.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Case 12: prog = frame(x). Then:</p><p>≡ empty ∧ (empty ∨ lbf(x)) ∨ lbf(x) ∧ (empty ∨ lbf(x))</p><p>≡ empty ∨ lbf(x) ∧ empty ∨ lbf(x)</p><p>≡ empty ∨ lbf(x) ∧ empty ∨ lbf(x) .</p><p>In the above: (i) follows from more df = ¬empty; (ii) from LAW24; and (iii) from p df = empty ∨ p. By Proposition 4.6(2), we have lbf(x) ≡ aflag x ∨ ¬aflag x ∧ x = -x. If aflag x = true, then the reduction is:</p><p>Case 13: prog = (∃x : p(x)). Then we first use the renaming method to reduce this to p(y), as in Proposition 2.3, and then apply the induction hypothesis.</p><p>Proof of Theorem 4.3. Armed with the normal form, a program q can be decomposed to a so-called Normal Form Graph(NFG) <ref type="bibr" target="#b10">[11]</ref> as follows (see Fig. <ref type="figure">8(a)</ref>):</p><p>Initially, the root (denoted by a small double circle) of the Graph is labelled by program q, each basic product in the normal form of q becomes a son of q. With the terminal product, the edge labelled by present component h and a terminal vertex labelled by a small black dot without appearing of empty; and with the future product, the edge labelled by b j and the next vertex (a small circle) labelled by next component f j . Then, f j can further be reduced to a sub-graph of q and so on. If two vertices are identical, we merge them into one. It is clear that if q has only finite models, its NFG is also finite.</p><p>In order to distinguish operations between sequences and sets, we denote a finite canonical interpretation sequence (I 0 prop , . . . , I k prop ) by I k , and its corresponding coded set {(0, I 0 prop ), . . . , (k, I k prop )} by I k . Thus, for an arbitrary canonical interpretation sequence I = (I 0 prop , . . . , are all canonical interpretations associated with edges departing from node I k . By Theorem 4.5, a framed program p can be reduced to its normal form. Since p is satisfiable, so p has at least one Initially I -1 = ∅, then we repeatedly apply function T to sets I -1 , I 0 , . . . . Thus, we have,</p><p>Let I = ∞ n=0 I n , I n stands for the prefix of minimal interpretation sequence I . We now prove the following conclusions:</p><p>1. I is a canonical interpretation sequence of p. We first prove T (I ) = I . </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">METATEM: A framework for programming in temporal logic</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gough</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formulisms, Correctness</title>
		<meeting>REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formulisms, Correctness</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">430</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Negation in rule-based data base languages: A survey</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="3" to="83" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Specication and prototyping of structrued multimedia documents using interval temporal logic</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bowman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cameron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Temporal Logic</title>
		<meeting>International Conference on Temporal Logic</meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Tableau method for interval temporal logic with projection</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bowman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TABLEAUX98</title>
		<meeting>TABLEAUX98</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1397</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A decision procedure and complete axiomatisation of finite interval temporal logic with projection</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bowman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="195" to="239" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">An extended interval temporal logic and a framing technique for temporal logic programming</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Newcastle upon Tyne</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<title level="m">Temporal Logic and Temporal Logic Programming</title>
		<meeting><address><addrLine>Beijing</addrLine></address></meeting>
		<imprint>
			<publisher>Science Press</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A logic for biological systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Holcombe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BioSystems</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="93" to="105" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A framed temporal logic programming language</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koutny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Science and Technology</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="341" to="351" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Projection in temporal logic programming</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koutny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Logic Programming and Automatic Reasoning</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</editor>
		<meeting>Logic Programming and Automatic Reasoning</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">822</biblScope>
			<biblScope unit="page" from="333" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Semantics of framed temporal logic programs</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koutny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICLP 2005</title>
		<meeting>ICLP 2005</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3668</biblScope>
			<biblScope unit="page" from="356" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Using branching temporal logic to synthesize synchronization skeletons</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="241" to="266" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Towards a semantics for concurrent MTETATEM</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Executable Modal and Temporal Logics</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">897</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Logic programming language based on temporal logic and its compilation to PROLOG</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fujita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moto-Oka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 3rd International Conference on Logic Programming</title>
		<meeting>3rd International Conference on Logic Programming<address><addrLine>Tokio</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">225</biblScope>
			<biblScope unit="page" from="695" to="709" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Theoretical foundations for non-monotonic reasoning in expert systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="1984">1984</date>
			<publisher>Dept. of Computing, Imperial College</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Programming in temporal logic</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W S</forename><surname>Hale</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Cambridge University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A practical theory of programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C R</forename><surname>Hehner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="133" to="158" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<imprint>
			<publisher>Prentice Hall International</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Kröger</surname></persName>
		</author>
		<title level="m">Temporal Logic of Programs</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The temporal logic of actions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transaction on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The Temporal Logic of Reactive and Concurrent Systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Executing Temporal Logic Programs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Moszkowski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Some very compositional temporal properties, in: Programming Concepts</title>
		<author>
			<persName><forename type="first">B</forename><surname>Moszkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Methods and Calculi</title>
		<imprint>
			<biblScope unit="page" from="307" to="326" />
			<date type="published" when="1994">1994</date>
			<publisher>Elsevier Science B.V., North-Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">0: A parallel executable temporal logic language</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of ACM SIGSOFT, International Workshop on Formal Methods in Software Development</title>
		<meeting>eeding of ACM SIGSOFT, International Workshop on Formal Methods in Software Development</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Toward a unified logic basis for programming languages</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IFIP Congress</title>
		<meeting>IFIP Congress</meeting>
		<imprint>
			<publisher>Elsevier Science Publishers B.V., North-Holland</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="425" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A temporal logic language oriented toward software engineering,-introduction to XYZ system (I)</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Chinese Journal of Advanced Software Research</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
