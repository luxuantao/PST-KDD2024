<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Li</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<country>Korea Advanced</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Institute of Science and Technology (KAIST)</orgName>
								<address>
									<postCode>305-701</postCode>
									<settlement>Daejeon</settlement>
									<country>Korea. He</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">College of Automation Science and Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">School of Electronic and Information Engineering</orgName>
								<orgName type="institution">South China University of Technology</orgName>
								<address>
									<postCode>510641</postCode>
									<settlement>Guangzhou</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<country>Korea Advanced</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department">Institute of Science and Technology (KAIST)</orgName>
								<address>
									<postCode>305-701</postCode>
									<settlement>Daejeon</settlement>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="department">College of Automation Science and Engineering</orgName>
								<orgName type="institution">University of Technology</orgName>
								<address>
									<postCode>510641</postCode>
									<settlement>Guangzhou</settlement>
									<country>South China, China</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">90A06BDF146E0D87490C24ACECA05001</idno>
					<idno type="DOI">10.1109/TCSVT.2008.2009252</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DE-Based Reversible Data Hiding With Improved Overflow Location Map</head><p>Yongjian Hu, Heung-Kyu Lee, and Jianwei Li</p><p>Abstract-For difference-expansion (DE)-based reversible data hiding, the embedded bit-stream mainly consists of two parts: one part that conveys the secret message and the other part that contains embedding information, including the 2-D binary (overflow) location map and the header file. The first part is the payload while the second part is the auxiliary information package for blind detection. To increase embedding capacity, we have to make the size of the second part as small as possible. Tian's <ref type="bibr" target="#b7">[8]</ref> classical DE method has a large auxiliary information package. Thodi et al. <ref type="bibr" target="#b20">[21]</ref> mitigated the problem by using a payload-independent overflow location map. However, the compressibility of the overflow location map is still undesirable in some image types. In this paper, we focus on improving the overflow location map. We design a new embedding scheme that helps us construct an efficient payload-dependent overflow location map. Such an overflow location map has good compressibility. Our accurate capacity control capability also reduces unnecessary alteration to the image. Under the same image quality, the proposed algorithm often has larger embedding capacity. It performs well in different types of images, including those where other algorithms often have difficulty in acquiring good embedding capacity and high image quality.</p><p>Index Terms-Difference expansion embedding, location map, predicted error expansion, reversible data hiding, watermarking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>R EVERSIBLE data hiding was first proposed for authen- tication. Early reversible algorithms (e.g., <ref type="bibr" target="#b0">[1]</ref>) often have small embedding capacity and poor image quality. With the improvement of embedding capacity and image quality, this technique is being considered not only for the whole spectrum of fragile watermarking, such as authentication watermarks or wa-termarks protecting the image integrity <ref type="bibr" target="#b1">[2]</ref>, but also for covert communication, even for some unprecedented applications like image/video coding (e.g., <ref type="bibr" target="#b2">[3]</ref>).</p><p>There are different ways to embed reversible data in literature. Ni et al. <ref type="bibr" target="#b3">[4]</ref> proposed a scheme of using peak/zero points in the histogram of spatial domain images. De Vleeschouwer et al. <ref type="bibr" target="#b4">[5]</ref> proposed a circular histogram scheme and used the relative position of the center of mass of the zone-based histogram to convey the information bits. Fridrich et al. <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b5">[6]</ref> proposed several methods to embed data. The central idea of their work is to compress the selected image features (e.g., the bitplane in <ref type="bibr" target="#b5">[6]</ref> and the vector state in <ref type="bibr" target="#b1">[2]</ref>) for acquiring spare space. The compressed original image features as well as their location information (also called location map) are embedded along with the payload. Fridrich et al.'s prototype has influenced many other researches such as <ref type="bibr" target="#b6">[7]</ref>, where Celik et al. proposed a generalized-LSB data embedding method. Based on integer Haar wavelet transform, Tian <ref type="bibr" target="#b7">[8]</ref> proposed another prototype using DE embedding. This prototype usually has larger embedding capacity and is easy to extend. Some variants or extensions have already appeared in literature. For example, Alattar <ref type="bibr" target="#b8">[9]</ref> extended Tian's pixel-pair difference expansion using difference expansion of vectors. Kamstra et al. <ref type="bibr" target="#b9">[10]</ref> improved the capacity control and the location map by sorting possible expandable locations. Thodi et al. <ref type="bibr" target="#b10">[11]</ref> made better use of redundancy of neighboring pixels. Some authors also proposed other kinds of transform domain methods. Coltuc et al. <ref type="bibr" target="#b11">[12]</ref> proposed a reversible contrast mapping (RCM) -based embedding method. Lee et al. <ref type="bibr" target="#b12">[13]</ref> performed the LSB-substitution and bit-shifting to embed data bits into the wavelet coefficients derived from an integer-to-integer wavelet transform. Other researches in reversible data hiding include theoretical analysis in <ref type="bibr" target="#b13">[14]</ref>, near-constant image-independent embedding capacity in <ref type="bibr" target="#b14">[15]</ref>, reversible watermarking for halftone images in <ref type="bibr" target="#b15">[16]</ref>, location-map free data extraction in <ref type="bibr" target="#b16">[17]</ref>, side match vector quantization (SMVQ) -based compression domain data embedding in <ref type="bibr" target="#b17">[18]</ref>, using 2-D vector maps as the cover data in <ref type="bibr" target="#b18">[19]</ref>, and reversible visible watermarking in <ref type="bibr" target="#b19">[20]</ref>.</p><p>Generally, reversible data hiding has no robustness against any attack. It depends on a completely reversible technique to get back the embedded data and losslessly recover the original image. Reversibility is no doubt the most basic requirement of reversible data hiding. In addition, the performance of a reversible data hiding algorithm can be measured by payload capacity limit, visual quality and complexity <ref type="bibr" target="#b7">[8]</ref>. To increase payload embedding capacity, and meanwhile, keep high image quality, DE-based methods have to make the auxiliary information package as small as possible. The auxiliary information package often consists of the header file and the (overflow) location map. Generally, the header file has few hundreds of bits, so the major attention is paid to the construction of the location map. Basically, there exist two drawbacks in Tian's DE method: lack of embedding capacity control capability and low compressibility of the location map. Some later researches have attempted to overcome these problems. One of the latest researches can be found in <ref type="bibr" target="#b20">[21]</ref>, where Thodi et al. solved the first problem by dividing the histogram of expandable differences into the inner/embedding region and outer/shifting regions, and the second problem by using a payload-independent overflow location map. The experimental results given by them are better than most other results available in literature. Although their method has good performance in common images, it often does not work well in other types of images, for instance, texture images and high-tone images, where the compressibility of their overflow location map is low.</p><p>In this paper, we propose a new DE-based method. Our work focuses on improving the compressibility of the overflow location map. We design a new embedding scheme that enables the 2-D binary overflow location map matrix as sparse as possible, so that its compressibility would be high. We implement our algorithm in the predicted error image. The construction of the payload-dependent overflow location map is based on the histogram of all predicted errors, including expandable, shiftable, unexpandable and unshiftable (overflow/underflow) predicted errors. Moreover, our efficient capacity control capability not only benefits the overflow location map, but also reduces the alteration to the histogram. The proposed algorithm can achieve good embedding capacity in different types of images, including those where other current algorithms often can not perform well.</p><p>The rest of the paper is organized as follows. In Section II, we describe our algorithm in detail. In Section III, we give the experimental results and discussions. We evaluate our method by comparing it with other current methods. In Section IV, we draw the conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. ALGORITHM</head><p>In <ref type="bibr" target="#b7">[8]</ref>, Tian performed integer Haar wavelet transform in row/column direction on the original image and used the pixel-pair difference for DE embedding. However, as pointed out in <ref type="bibr" target="#b20">[21]</ref>, the performance of DE-based reversible data hiding can be improved by using features that better decorrelate the image. Therefore, we use the predicted image pixel error instead of the pixel-pair difference for expansion embedding. A predictor <ref type="bibr" target="#b20">[21]</ref> below can exploit the neighboring information to predict an image pixel if if otherwise <ref type="bibr" target="#b0">(1)</ref> where and represent a pixel and its predicted value, respectively. , and constitute the context of , where , and are in sequence its right, lower, and diagonal neighbors. We attempt to embed one information bit into a predicted error, , where . To ensure lossless recovery of the original image, we only embed information bits into predicted errors that do not cause the overflow/underflow of image gray levels. In other words, the pixel value reconstructed from the embedded predicted error does not exceed the integer range for an 8-bit image. A predicted error without causing the overflow/underflow problem is defined as an expandable/embeddable predicted error. We will give a strict definition later. According to <ref type="bibr" target="#b7">[8]</ref>, the DE embedding rule can be defined as follows.</p><p>(</p><formula xml:id="formula_0">)<label>2</label></formula><p>where is a binary information bit. We further define a variant of (2) as <ref type="bibr" target="#b2">(3)</ref> As will be seen, the use of (2) shifts the histogram rightwards in the first-round data embedding, whereas the use of (3) shifts the histogram leftwards in the first-round data embedding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Embedding and Data Extraction Rules and Overflow/underflow Constraints</head><p>The basic data hiding process of our proposed algorithm is depicted in Fig. <ref type="figure" target="#fig_0">1</ref>. In this subsection, we will introduce the embedding rules and the overflow/underflow constraints, which will be used during selecting embeddable locations and constructing the overflow location map, as shown in the dashed block in Fig. <ref type="figure" target="#fig_0">1</ref>. Fig. <ref type="figure" target="#fig_1">2</ref> shows a typical histogram of predicted errors for a common image. In our embedding scheme, we divide the histogram into two parts: the inner region for embedding and the outer regions for shifting. Assume that two thresholds, and , are used to control the right and left boundaries of the inner region, respectively. To avoid confusion of description, we further assume that we use (2) as the embedding formula. We will explain the details of this assumption in Section II-B. Note that, without specific indication, we will keep this assumption in the rest of the paper. So the inner region is represented as , and the corresponding outer regions are and . Here and refer to the left and right ends of the histogram, respectively.</p><p>The whole embedding process includes two manipulations. First, the outer region has to be shifted before embedding. The shifted pixel value, , is computed as</p><formula xml:id="formula_1">if if . (<label>4</label></formula><formula xml:id="formula_2">)</formula><p>Then, in the inner region, an expandable value, , is embedded by DE embedding as if <ref type="bibr" target="#b4">(5)</ref> As for overflow and underflow (for simplicity, we use overflow to represent either overflow or underflow in the rest of the paper), we can ensure invertible embedding if we restrict in the range of . It also contains two situations. We first discuss the constraint on DE embedding. According to (5), we have  According to (4), we then have the constraint on histogram shifting as</p><formula xml:id="formula_3">if if .<label>(6)</label></formula><formula xml:id="formula_4">if if . (<label>7</label></formula><formula xml:id="formula_5">)</formula><p>Using ( <ref type="formula" target="#formula_3">6</ref>) and ( <ref type="formula" target="#formula_4">7</ref>), we can define four different types of predicted errors. A predicted error that satisfies ( <ref type="formula" target="#formula_3">6</ref>) is defined as an expandable/embeddable predicted error or location; otherwise, it is defined as an (embedding) overflow location. A predicted error that satisfies ( <ref type="formula" target="#formula_4">7</ref>) is defined as a shiftable predicted error or location; otherwise, it is defined as a (shifting) overflow location.</p><p>At the decoder, we have . The recovery process also includes two manipulations. In the embedded region, the embedded/hidden bit is extracted as In the shifted regions, the original pixel value is resumed as</p><formula xml:id="formula_6">if if . (<label>11</label></formula><formula xml:id="formula_7">)</formula><p>To better understand the above formulas, we give an example in Fig. <ref type="figure" target="#fig_3">3</ref>, which lists four typical data embedding situations in an image. Assume that , , , , and we want to insert a binary information bit . So the inner region is , and the right and left outer regions are and , respectively. After embedding, the embedded region is , and the shifted regions are and , respectively. We first consider the situation in Fig. <ref type="figure" target="#fig_3">3(a)</ref>, where . According to (1), we have . Thus, . Since is located in the inner region and satisfies <ref type="bibr" target="#b5">(6)</ref>, it is expandable. We have by (2) and by <ref type="bibr" target="#b4">(5)</ref>. During decoding, we can get back from . Since is located in the embedded region, we obtain by ( <ref type="formula">8</ref>) and by <ref type="bibr" target="#b8">(9)</ref>. Therefore, we can recover the original pixel value by <ref type="bibr" target="#b9">(10)</ref>, i.e., . In Fig. <ref type="figure" target="#fig_3">3</ref>(b), . According to (1), we have . Thus, . In this case, is located in the outer region, , and satisfies <ref type="bibr" target="#b6">(7)</ref>, so that it is shiftable. We can not embed any information bit. We then shift the pixel and get by <ref type="bibr" target="#b3">(4)</ref>. During decoding, we can get back from . Since is in the shifted region, , we recover the original pixel value by <ref type="bibr" target="#b10">(11)</ref>, i.e., . In Fig. <ref type="figure" target="#fig_3">3</ref>(c), . According to (1), we have . Thus, . In this case, is located in the inner region. However, due to , it does not satisfy <ref type="bibr" target="#b5">(6)</ref>. So it is an embedding overflow location. We will not change it during embedding. Finally, we consider the situation in Fig. <ref type="figure" target="#fig_3">3(d),</ref><ref type="figure">where</ref> . According to (1), we have . Thus, . Since is located in the outer region, , but does not satisfy <ref type="bibr" target="#b6">(7)</ref>, it is a shifting overflow location. We will not change it during shifting.</p><p>So far we have shown the usage of the formulas obtained under (2). If ( <ref type="formula">3</ref>) is used as the embedding formula, the corresponding embedding and data extraction rules and overflow constraints can be deduced in a similar way. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Selecting Embeddable Locations and Constructing the Overflow Location Map</head><p>The selection of embeddable locations is the key issue in DE-based methods. In order to reduce embedding distortion, a DE-based method often gives priority to small differences (i.e., differences with small magnitude). According to the knowledge of image processing, the histogram of differences/predicted errors is close to a zero-mean Laplacian distribution. So we exploit the histogram characteristics to select embeddable predicted errors. The generation of inner region begins from the peak of the histogram. The inner region expands outwards along the horizontal axis to suit the payload. Our selection scheme is motivated by the work in <ref type="bibr" target="#b20">[21]</ref>, where Thodi et al. introduced a way to directly select embeddable locations from the expandable difference histogram. Given a payload, , they first divided the histogram into the inner region and outer regions (see Fig. <ref type="figure" target="#fig_1">2</ref>). The two types of regions are not allowed to overlap with each other. Their algorithm tries to determine the inner region with the possible smallest differences. Assume is the selection threshold. Their inner region is denoted as . is initially set to 0, so that the minimum inner region is . If bins 0 and 1 can not provide enough expandable locations, increase by 1. In other words, two more bins, i.e., bins 1 and 2, are added into the inner region by simultaneously shifting the inner region's boundaries outwards by 1. Such a bin addition process continues until the inner region has enough bins for . On the other side, after using (2), the inner region will be expanded due to the doubling of absolute value of the difference. Thus, the outer regions have to be shifted before embedding. Keeping the expanded inner region and the outer regions not intersected with each other is the basic requirement of lossless recovery of the image. Otherwise, the original values in the overlapped regions would be permanently lost. So the right and left outer regions are simultaneously shifted outwards along the horizontal axis by at least . In the process of searching for embeddable locations and shifting outer regions, the overflow problem never occurs because this histogram purely consists of expandable differences. To ensure the reversibility of embedding, a 2-D binary overflow location map, , recording all possible overflow locations of differences in the image must be created and preserved before using the histogram. Equivalently, <ref type="bibr">Thodi et al. used</ref> to record all expandable locations in the image. The compressed overflow location map, , is embedded along with the payload into the image. The central idea of Thodi et al.'s histogram-based selection scheme is to save the locations of all possible expandable differences in , and then, assign the necessary amount of expandable differences to the payload by modifying the capacity controller . More detailed information can be found in <ref type="bibr" target="#b20">[21]</ref>.</p><p>There are two drawbacks in Thodi et al.'s scheme. The first one is about the overflow location map. In some images, their overflow location map can not be efficiently compressed. This is obviously not desired, especially when the payload is not large with respect to the size of the compressed overflow location map. The second is about histogram shifting. From ( <ref type="formula" target="#formula_1">4</ref>) and ( <ref type="formula">5</ref>), it can be easily seen that not only embedding but also histogram shifting alters image pixel values. Although simultaneously shifting these two outer regions has small impact on image quality when the histogram is sharp and narrow, the impact becomes larger when the histogram is flat. This paper improves their scheme from these two aspects.</p><p>Intuitively, we can solve the second problem by interleavingly shifting the outer regions. We shift one outer region at a time. As soon as we find the critical threshold that satisfies the payload, we stop the shifting process. However, as long as we use the histogram of expandable differences, we have to use the overflow location map similar to that in <ref type="bibr" target="#b20">[21]</ref>. So we must find a new way. Our solution is based on using the histogram that consists of all predicted errors, including expandable, shiftable, unexpandable and unshiftable ones. We design a new embedding scheme for such a histogram, which enables us to construct the overflow location map during the embeddable location selection and histogram shifting. Our inner region begins from and we first select the predicted errors with (i.e., bin 0) as embeddable locations. According to the embedding formulas ( <ref type="formula" target="#formula_0">2</ref>) and (3), there are two possible results after embedding: becomes 0/1 when using (2), or when using (3). The former indicates that we first shift the right outer region outwards in order to vacate a space for the rightward expansion of the inner region, whereas the latter indicates that we first shift the left outer region outwards for the leftward expansion of the inner region. These two choices need different embedding and extraction rules as well as the constraints on overflow locations. However, there is no essential difference between using (2) and (3). The two choices only refine our interleaving histogram shifting scheme. Our underlying idea is that, since the histogram is not strictly symmetric about the origin, we choose the histogram side with less bins to move, so that fewer predicted errors are shifted when the payload is small. This scheme would apparently benefit image quality under light payloads, but the effect becomes weaker as the payload gets heavier. Below we describe our iterative expandable location selection process. We interleavingly increase the right and left boundaries to find a suitable inner region for the payload. We still keep the previous assumption of using <ref type="bibr" target="#b1">(2)</ref> and regard the right direction as the first shifting/expansion direction.</p><p>We use Fig. <ref type="figure" target="#fig_4">4</ref> to help us explain the process of selecting embeddable locations. For a payload , we can find suitable inner region and outer regions by searching for suitable and . In the first iteration, we let and . The inner region is , and the left and right outer regions are and , respectively. There is only bin 0 in the current inner region. We shift the right outer region by so that it becomes , and meanwhile, we do not change the left outer region. If bin 0 provides enough expandable locations for , we obtain the suitable thresholds. We then exit the search process. Otherwise, we go to the second search iteration. We increase , and the left and right outer regions are and , respectively. We accordingly shift the outer regions to get new left and right outer regions as and , respectively. If bins 0 and 1 still do not provide enough embeddable locations, we go to the third iteration. We increase by 1 and do not change . So we have and . The inner region is then , and the left and right outer regions are and , respectively. We accordingly shift the outer regions to get new left and right outer regions as and , respectively. We test whether bins 0, 1 and 1 provide enough expandable locations. The search process con-tinues until the bins in the inner region provide enough embeddable locations for .</p><p>During the above search process, we respectively apply ( <ref type="formula" target="#formula_3">6</ref>) and ( <ref type="formula" target="#formula_4">7</ref>) to the predicted errors in the inner region and outer regions to pick out overflow locations. We record each overflow location as "1" in the overflow location map. As a result, overflow locations come from not only embedding but also shifting operations. Since the constraint imposed by ( <ref type="formula" target="#formula_3">6</ref>) is much stricter than that by <ref type="bibr" target="#b6">(7)</ref>, it is easier for the former to create an overflow location. Thus, the overflow location map matrix obtained by the combined use of ( <ref type="formula" target="#formula_3">6</ref>) and ( <ref type="formula" target="#formula_4">7</ref>) is sparser than that obtained by only using ( <ref type="formula" target="#formula_3">6</ref>) without the constraints of and , or equivalently, with and . The latter overflow location map purely consists of embedding overflow locations. Practically, without the constraints of and , ( <ref type="formula" target="#formula_3">6</ref>) is effective on all predicted errors in the predicted error image. This is the rule that Thodi et al. <ref type="bibr" target="#b20">[21]</ref> adopted to acquire their overflow location map when their prediction-error based algorithms are implemented. We briefly call this rule as Thodi et al.'s OLMC (overflow location map construction) rule call the combined use of ( <ref type="formula" target="#formula_3">6</ref>) and ( <ref type="formula" target="#formula_4">7</ref>) as our OLMC rule. We investigate the difference between the two overflow location maps obtained by using these two rules. We consider several cases. First, we fix the histogram and discuss the influence of the payload. If the payload is small, the inner region is narrow and the outer regions are accordingly large. If our OLMC rule is used, there are few overflow locations in the overflow location map. When compressed by a compression algorithm (e.g., JBIG-kit 1 ), our overflow location map would create a very small compressed version. On the other side, if Thodi et al.'s OLMC rule is used, the embedding overflow locations in the whole histogram instead of the inner region are taken into consideration. Thereby, there are more overflow locations in the overflow location map and the compressed overflow location map has a larger size. So the difference between these two maps is often obvious. However, as the payload increases, the inner region becomes larger and the outer regions become smaller, so that their difference becomes smaller. When the payload reaches the maximum capacity, all expandable locations are used. In this case, the inner region covers the whole histogram and there is no outer region. Consequently, using our OLMC rule is equivalent to using Thodi et al.'s OLMC rule. These two overflow location maps are identical. Next, we fix the payload and discuss the influence of the histogram. If the histogram is sharp, the outer regions are often small. Using these two rules may create the overflow location maps with little difference. However, if the histogram is flat, the outer regions are often large. The overflow location map obtained by using our OLMC rule has fewer overflow locations, so that it has higher compressibility. In addition to the influence of the histogram and payload, image pixel values also affect the construction of the overflow location map. For example, if there are many pixel values close to 0 or 255, the constraint of for or for can easily yield an underflow or overflow location. In this case, using Thodi et al.'s OLMC rule would create more overflow locations. As a result, their overflow location map has lower compressibility. Usually, a texture image has a flat histogram and a high-tone image has large regions with image pixel values close to 255.</p><p>The above analysis indicates that Thodi et al.'s overflow location map does not change with payloads and is equivalent to the one obtained by using our OLMC rule under the maximum embedding capacity (i.e., at the maximum embedding rate). In contrast, our overflow location map changes with payloads. Except at the maximum embedding rate, our overflow location map always has fewer overflow locations than theirs, and thus, has higher compressibility. Unlike Thodi et al.'s overflow location map that exactly indicates all expandable locations, ours can only distinguish expandable and shiftable locations from overflow locations. We need to use and to fur- ther distinguish expandable locations from shiftable ones. The construction process of our overflow location map is also illustrated in Fig. <ref type="figure" target="#fig_4">4</ref>. Note that is the total length of to-be-embedded bit-stream, as will be defined next. The histogram of predicted errors can be directly calculated from the predicted error image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Data Encoding and Extraction</head><p>Our algorithm is implemented through two stages. In the first stage, we select embeddable locations and build the overflow location map, and construct the header file with the embedding information. In the second stage, we encode the auxiliary information package along with the payload into the selected embeddable locations and create the embedded image. The two stages are clearly exhibited in Fig. <ref type="figure" target="#fig_0">1</ref>, where the dashed block represents the first stage and the rest parts represent the second stage. The auxiliary information package, , consists of the header file, , and the compressed overflow location map, . The structure of header file is given as follows:</p><p>where is the function for calculating the bit-stream length. Flag Bit refers to the first histogram shifting direction, for instance, a binary "1" for the right and "0" for the left; End Position denotes the coordinate of the last pixel we use during embedding. So the length of auxiliary information package . The total length of to-be-embedded bit-stream, , is calculated as . We introduce End Position to achieve accurate capacity control capability. Generally, the amount of embeddable pixels in the inner region under the selected and is not equal to but larger than . The use of End Position further decreases the number of pixels to be altered. End Position is determined by the steps shown in Fig. <ref type="figure" target="#fig_4">4</ref>.</p><p>The data encoding process still adopts the raster scanning manner and begins from the upper left corner of the image. Normally, we use <ref type="bibr" target="#b4">(5)</ref> to embed the bits from and bit-streams in sequence into the selected embeddable locations, and use (4) to shift the pixel of the outer regions. However, such an embedding manner would lead to a problem for blind data extraction. If not provided with the embedding information, the decoder can not extract data from the test image. So we must secretly transmit to the decoder through the available channel. One way of transmitting is to save the bits of in a place of the embedded image that is easy to locate. Such an idea was originally proposed in <ref type="bibr" target="#b10">[11]</ref>. In this paper, we give a brief description. Suppose that the embedded image is obtained. We preserve the bits of into the LSBs of the first image pixels by LSB replacement, no matter whether these image pixels have been embedded or not. The starting pixel is still the upper left corner of the image. While performing LSB replacement operation, the replaced LSBs are collected in a temporary data package. Such a data package is then saved in the area originally allotted for the storage of . As a result, we exchange the storage place of these two data packages. In practical implementation, this storage place exchange operation is carried out during the process of data embedding. The reader is referred to <ref type="bibr" target="#b10">[11]</ref> for more detailed information. Note that Fig. <ref type="figure" target="#fig_0">1</ref>  Data extraction is implemented in the exactly reverse steps of data Before performing data extraction, we get back and from the LSBs of the first image pixels beginning from the upper left corner of the image. According to the structure of , we extract Flag Bit, , , and End Position in sequence. Then, according to the header file of JBIG file, we further get the length of . Afterwards, we perform JBIG decompression to resume . Relying on the embedding information of and , we scan the test image from the last embedded pixel (i.e., End Position) in the reverse raster scanning manner. We perform (1) and get back from . Based on , we first judge whether the current pixel is embedded or shifted by using the combined information of , and , and then, take the reverse operation by using ( <ref type="formula">8</ref>), ( <ref type="formula">9</ref>), <ref type="bibr" target="#b9">(10)</ref>, or <ref type="bibr" target="#b10">(11)</ref>. The original image is losslessly resumed as soon as the embedded secret message is completely extracted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>only shows</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. EXPERIMENT AND DISCUSSION</head><p>The proposed algorithm has been tested on different types of images. The six test images downloaded from the database<ref type="foot" target="#foot_0">2</ref> are shown in Fig. <ref type="figure" target="#fig_6">5</ref>. The experimental results of these test images are shown in Figs. <ref type="figure" target="#fig_7">6</ref> and<ref type="figure" target="#fig_8">7</ref>. We compare our method with Tian's DE method in <ref type="bibr" target="#b7">[8]</ref>, Kamstra et al.'s Extended DE method in <ref type="bibr" target="#b9">[10]</ref>, and Thodi et al.'s P2 method in <ref type="bibr" target="#b20">[21]</ref>. Thodi et al. presented five versions of their algorithm, among which the prediction-error-expansion-based P2 method is one of the best. We evaluate the performance of these four algorithms by using the embedding capacity versus compressed (overflow) location map length curve and the embedding capacity versus image quality curve.</p><p>For common images like Man, the histogram is sharp and narrow. Fig. <ref type="figure" target="#fig_7">6</ref>(a) shows that P2's compressed overflow location map has a constant length at different embedding rates, and the compressibility of the overflow location map is high. Different from P2, our compressed overflow location map has changing lengths for different payloads. Our overflow location map has even higher compressibility though the advantage is not large. Fig. <ref type="figure" target="#fig_7">6</ref>(b) shows that both P2 and our method have very good performance, but our method is slightly better than P2 in PSNR (peak signal-to-noise-ratio) values under the same payload. The location map of Tian's DE method has very poor compressibility. When the payload is small, the compressed location map consumes far more embedding space than the payload. This is because Tian's method lacks capacity control capability. As the payload becomes larger, the compressibility of Tian's location map improves. The zigzag shape of DE method's embedding capacity versus compressed location map length curve results from the combined effect of multi-layer embedding and the size of the difference image. The curve's valley indicates that the compressibility of the location map reaches the highest when all expandable differences are used in the difference image. It can be seen that DE method has similar embedding capacity versus compressed location map length curves for all the six test images, and the major differences of these curves are in valleys and peaks. The advantage of our method over DE method is obvious. Fig. <ref type="figure" target="#fig_7">6(b)</ref> shows that the largest PSNR difference between our curve and DE method's is about 9 dB. Although the location map of Extended DE method has high compressibility, it is essentially different from the other three maps. This map is derived from the sorting list that is based on the characteristics of the low-pass image. Basically, this sorting list can not guarantee to give priority to small differences. As mentioned in <ref type="bibr" target="#b9">[10]</ref>, locations at the beginning of the sorting list are more likely to be expandable than locations that occur more toward the end. This statement implies that Extended DE method performs well under small payloads. For DE, P2 and our methods, high compressibility usually corresponds to good algorithm performance. However, the high compressibility of Extended DE method's location map is mainly due to the smoothness of the low-pass image. As shown in Fig. <ref type="figure" target="#fig_7">6</ref>(b), Extended DE method has good performance at low embedding rates, but its performance degrades quickly as the embedding rate increases. Specifically, from 0.5 bpp (bits per pixel), there is much performance difference between Extended DE method and DE method.</p><p>For texture images like Baboon, the histogram is flat. Fig. <ref type="figure" target="#fig_7">6(c)</ref> shows that P2 has a much larger compressed overflow location map than our method. When the embedding rate is less than 0.7 bpp, P2's compressed overflow location map is about 2 bits longer than ours. This result indicates that our method has the strong capacity control capability and our payload-dependent overflow location map is highly compression-efficient. Only when the embedding rate is greater than 0.8 bpp, the length of our compressed overflow location map increases apparently. The increase in length accelerates from 0.9 bpp. This is because most of the expandable predicted errors are used for large payloads. Fig. <ref type="figure" target="#fig_7">6(d</ref>) exhibits the advantage of our method over P2 and DE method. The largest PSNR differences between our curve and these two curves are about 7 dB and 15 dB, respectively. These results happen at 0.05 bpp. The smaller the payload, the larger the PSNR difference. As for Extended DE method, the length of its compressed location map increases rapidly at large embedding rates. Apparently, the smoothness of the low-pass image is not the only factor affecting the compressibility of the location map. Actually, Kamstra et al. used the same rule as Tian and Thodi et al. did when selecting expandable locations. As more locations are selected for large payloads, more unexpandable locations are included in their sorting list. Thus, the location map derived from the sorting list has poorer compressibility. Since Kamstra et al.'s location map is a payload-dependent one, the problem of inefficient compression only becomes more serious as the payload increases. The reader is referred to <ref type="bibr" target="#b9">[10]</ref> for more detailed information. Fig. <ref type="figure" target="#fig_7">6</ref>(d) shows that our method is still better than Extended DE method, especially at medium embedding rates.</p><p>For high-tone images like Girl, the histogram is sharp and narrow, but P2 can not maintain its good performance. Fig. <ref type="figure" target="#fig_7">6(e)</ref> shows that P2 has a compressed overflow location map with a very large size, about 4 10 bits. It indicates that Thodi et al.'s method is very sensitive to high-tone images. On the contrary, our overflow location map has good compressibility at low embedding rates. The length of our compressed overflow location map only increases as the payload increases. Fig. <ref type="figure" target="#fig_7">6</ref>(f) shows that our method is apparently superior to P2 at low-and medium-embedding rates. P2's PSNR values are even close to those of DE method from 0.1-0.3 bpp. The performance difference between our method and P2 dwindles as the payload increases. The length of compressed location map of Extended DE method increases quickly with the increase of the payload, so that Extended DE method only performs well at low embedding rates. Our method often performs much better than Extended DE method.</p><p>Aerospace image Aerial has large flat regions, some of which are bright. Its histogram is sharp, but not as sharp as that of Man. Fig. <ref type="figure" target="#fig_8">7</ref>(a) shows that the four curves often can not perform as well as their counterparts do in Fig. <ref type="figure" target="#fig_7">6(a)</ref>. Therefore, the four curves in Fig. <ref type="figure" target="#fig_8">7</ref>(b) look like their counterparts in Fig. <ref type="figure" target="#fig_7">6(b)</ref>, but the performance of the former is often not as good as that of the latter. In particular, due to flat bright image regions, P2 faces the problem similar to that on Girl. Therefore, P2 has greater performance degradation than our method. The performance of Extended DE method also degrades more rapidly. When the embedding rate is less than 0.1 bpp, Extended DE method is even better than our method; but it performs almost as DE method does when the embedding rate is greater than 0.5 bpp.</p><p>There are some images with partial textures and uneven brightness, for example, Stream and bridge. P2 faces two challenges. First, the histogram is not sharp but very ragged. Second, the image is very bright in some regions but very dark in others. Both of them have negative impact on the compressibility of P2's overflow location map, and thus, degrade its performance. Fig. <ref type="figure" target="#fig_8">7</ref>(c) shows that the length of our compressed overflow location map increases slowly. Fig. <ref type="figure" target="#fig_8">7</ref>(d) demonstrates that our method outperforms the other three, and the performance difference is larger when the embedding rate is less than 0.2 bpp.</p><p>Finally, we give an extreme example to further show how our method works. Grass is an image with strong textures and uneven brightness. Its histogram is much flatter and wider. Fig. <ref type="figure" target="#fig_8">7</ref>(e) exhibits that the length of our compressed overflow location map increases very slowly when the embedding rate is less than 0.5 bpp. On the contrary, the other three methods perform poorly. The length of P2's compressed overflow location map is about 4.5 10 bits. DE method has the embedding capacity versus compressed location map length curve with the poorest behavior among the six test images. The valley is not low and the peak is very high. As for Extended DE method, the length of its compressed location map increases rapidly from very small embedding rates. Fig. <ref type="figure" target="#fig_8">7</ref>(f) demonstrates that our embedding capacity versus image quality curve is far above the other three curves at low-and medium-embedding rates.</p><p>Before finishing this section, we make a brief discussion on computational complexity of our proposed algorithm. Our simulation is carried out on a Pentium-4 3.44 GHz PC with 1G RAM. Our algorithm is implemented in Visual C 6.0. For image Man, the embedding process takes about 0.125 sec at 0.1 bpp and 0.985 sec at 0.99 bpp. The corresponding detection process takes about 0.047 sec and 0.078 sec, respectively. For different images and at different embedding rates, the consuming time would change a little.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CONCLUSION</head><p>In this paper, we have investigated the problem of the overflow location map, which is an important issue in DE-based reversible data hiding. In order to increase embedding capacity, we improve the compressibility of the overflow location map by designing a new embedding scheme. Our overflow location map depends on the payload. Unlike other (overflow) location maps, it contains two types of overflow locations: one from embedding and the other from shifting. Since the constraint on shifting is looser than that on embedding, it results in fewer overflow locations. Therefore, our overflow location map matrix is often sparser than other current ones. This feature makes our overflow location map have higher compressibility. Our interleaving histogram shifting scheme also enhances capacity control capability, and thus, benefits image quality. Compared with other reversible data hiding methods in literature, the proposed algorithm often has better resilience to different images and larger embedding capacity under the same image quality.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Basic data hiding process.</figDesc><graphic coords="3,44.64,68.28,504.00,138.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Sample histogram of predicted errors.</figDesc><graphic coords="3,72.12,253.30,185.25,152.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>refers to the floor function. The original predicted error value and the original pixel value are, respectively, com-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Four typical data embedding situations. The pixel in the upper left corner of the block is (a) expandable, (b) shiftable, (c) in the inner region but not expandable, and (d) in the outer region but not shiftable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Selecting embeddable locations and constructing the overflow location map.</figDesc><graphic coords="5,127.56,68.62,338.00,491.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 [</head><label>1</label><figDesc>Online]. Available: http://www.cl.cam.ac.uk/~mgk25/jbigkit/</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Test images of 512 2 512 2 8 bits. In the upper row and from left to right: Man, Baboon, and Girl. In the lower row and from left to right: Aerial, Stream and bridge, and Grass.</figDesc><graphic coords="7,136.56,66.48,320.00,186.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Performance comparison on test images Man, Baboon, and Girl. We compare our method with Thodi et al.'s P2 method, Tian's DE method, and Kamstra et al.'s Extended DE method. We give the embedding capacity versus compressed (overflow) location map length curve in the left column and the embedding capacity versus image quality curve in the right column.</figDesc><graphic coords="8,92.34,66.62,405.00,541.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Performance comparison on test images Aerial, Stream and bridge, and Grass. We compare our method with Thodi et al.'s P2 method, Tian's DE method, and Kamstra et al.'s Extended DE method. We give the embedding capacity versus compressed (overflow) location map length curve in the left column and the embedding capacity versus image quality curve in the right column.</figDesc><graphic coords="9,96.96,66.42,399.00,546.00" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>http://sipi.usc.edu/database/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors would like to thank the Associate Editor Prof. M. Barni and the anonymous reviewers for their valuable comments and suggestions that have helped us improve the quality and clarity of the paper.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by BK 21 project of KAIST, KOSEF Grant NRL program R0A-2007-000-20023-0 of MOST, National Science Foundation of China under Grants 60772115 and 60572140. This paper was recommended by Associate Editor M. Barni.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>His research interests include digital image processing, data hiding and pattern recognition.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Lossless recovery of an original image containing embedded data</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Honsinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rabbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Stoffel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">U.S. Patent</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">278</biblScope>
			<date type="published" when="2001">Aug. 21. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Lossless data embedding-New paradigm in digital watermarking</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fridrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Goljan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Du</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP J. Appl. Signal Process</title>
		<imprint>
			<biblScope unit="volume">2002</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="185" to="196" />
			<date type="published" when="2002-02">Feb. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Enhanced image trans-coding using reversible data hiding</title>
		<author>
			<persName><forename type="first">R</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">C</forename><surname>Au</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-K</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-W</forename><surname>Cha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Symp. Circuits Syst</title>
		<meeting>IEEE Int. Symp. Circuits Syst</meeting>
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
			<biblScope unit="page" from="1273" to="1276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reversible data hiding</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Q</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. Video Technol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="354" to="362" />
			<date type="published" when="2006-03">Mar. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Circular interpretation of bijective transformations in lossless watermarking for media asset management</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Vleeschouwer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Delaigle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Macq</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Multimedia</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="97" to="105" />
			<date type="published" when="2003-03">Mar. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Invertible authentication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fridrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Goljan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPIE 2001, Security and Watermarking of Multimedia Contents III</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Delp</surname></persName>
		</editor>
		<meeting>SPIE 2001, Security and Watermarking of Multimedia Contents III</meeting>
		<imprint>
			<biblScope unit="volume">4314</biblScope>
			<biblScope unit="page" from="197" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Lossless generalized-LSB data embedding</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Tekalp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Saber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Image Process</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="157" to="160" />
			<date type="published" when="2005-02">Feb. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Reversible data embedding using a difference expansion</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. Video Technol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="890" to="896" />
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Reversible watermark using the difference expansion of a generalized integer transform</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Alattar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Image Process</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1147" to="1156" />
			<date type="published" when="2004-08">Aug. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reversible data embedding into images using wavelet techniques and sorting</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kamstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J A M</forename><surname>Heijmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Image Process</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2082" to="2090" />
			<date type="published" when="2005-12">Dec. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Prediction-error based reversible watermarking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Thodi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Rodriguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Image Process</title>
		<meeting>IEEE Int. Conf. Image ess</meeting>
		<imprint>
			<date type="published" when="2004-10">Oct. 2004</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1549" to="1552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Very fast watermarking by reversible contrast mapping</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coltuc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Chassery</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Process. Lett</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="255" to="258" />
			<date type="published" when="2007-04">Apr. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Reversible image watermarking based on integer-to-integer wavelet transform</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kalker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Forensics Security</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="321" to="330" />
			<date type="published" when="2007-09">Sep. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Capacity bounds and constructions for reversible data-hiding</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kalker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M J</forename><surname>Willems</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int. Conf. Digital Signal Process</title>
		<meeting>14th Int. Conf. Digital Signal ess</meeting>
		<imprint>
			<date type="published" when="2002-07">Jul. 2002</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="71" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reversible watermarking scheme with image-independent embedding capacity</title>
		<author>
			<persName><forename type="first">C.-T</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEE Vis. Image Signal Process</title>
		<meeting>IEE Vis. Image Signal ess</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="page" from="779" to="786" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Reversible watermarking for error diffused halftone images using statistical features</title>
		<author>
			<persName><forename type="first">Z.-M</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop Digital Watermarking</title>
		<meeting>Int. Workshop Digital Watermarking</meeting>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
			<biblScope unit="volume">4283</biblScope>
			<biblScope unit="page" from="71" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A location-map free reversible data hiding method using block-based single parameter</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fujiyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Image Process</title>
		<meeting>IEEE Int. Conf. Image ess</meeting>
		<imprint>
			<date type="published" when="2007-09">Sep. 2007</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="257" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A reversible data hiding scheme based on side match vector quantization</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. Video Technol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1301" to="1308" />
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reversible datahiding scheme for 2-D vector maps based on difference expansion</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">G</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">M</forename><surname>Niu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Forensics Security</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="311" to="320" />
			<date type="published" when="2007-09">Sep. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reversible visible watermarking and lossless recovery of original images</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jeon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. Video Technol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1423" to="1429" />
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Expansion embedding techniques for reversible watermarking</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Thodi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Rodriguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Image Process</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="721" to="730" />
			<date type="published" when="2007-03">Mar. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
