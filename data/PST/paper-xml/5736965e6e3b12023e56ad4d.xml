<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mining High Utility Patterns in One Phase without Generating Candidates</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Junqiang</forename><surname>Liu</surname></persName>
							<email>jjliu@alumni.sfu.ca</email>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Ke</forename><surname>Wang</surname></persName>
							<email>wangk@cs.sfu.ca</email>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Benjamin</forename><forename type="middle">C M</forename><surname>Fung</surname></persName>
							<email>ben.fung@mcgill.ca</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Information and Electronic Engi-neering</orgName>
								<orgName type="institution">Zhejiang Gongshang University</orgName>
								<address>
									<postCode>310018</postCode>
									<settlement>Hangzhou</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University</orgName>
								<address>
									<postCode>V5A 1S6</postCode>
									<settlement>Burnaby</settlement>
									<region>British Columbia</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">School of Information Studies</orgName>
								<orgName type="institution">McGill University</orgName>
								<address>
									<postCode>H3A 1X1</postCode>
									<settlement>Montreal</settlement>
									<region>Quebec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Mining High Utility Patterns in One Phase without Generating Candidates</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2F6EE9AC656DAD5CE0B7CE0DF46E51DB</idno>
					<idno type="DOI">10.1109/TKDE.2015.2510012</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TKDE.2015.2510012, IEEE Transactions on Knowledge and Data Engineering This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TKDE.2015.2510012, IEEE Transactions on Knowledge and Data Engineering This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TKDE.2015.2510012, IEEE Transactions on Knowledge and Data Engineering This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TKDE.2015.2510012, IEEE Transactions on Knowledge and Data Engineering This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TKDE.2015.2510012, IEEE Transactions on Knowledge and Data Engineering This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TKDE.2015.2510012, IEEE Transactions on Knowledge and Data Engineering</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>data mining</term>
					<term>utility mining</term>
					<term>high utility patterns</term>
					<term>frequent patterns</term>
					<term>pattern mining</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Utility mining is a new development of data mining technology. Among utility mining problems, utility mining with the itemset share framework is a hard one as no anti-monotonicity property holds with the interestingness measure. Prior works on this problem all employ a two-phase, candidate generation approach with one exception that is however inefficient and not scalable with large databases. The two-phase approach suffers from scalability issue due to the huge number of candidates. This paper proposes a novel algorithm that finds high utility patterns in a single phase without generating candidates. The novelties lie in a high utility pattern growth approach, a lookahead strategy, and a linear data structure. Concretely, our pattern growth approach is to search a reverse set enumeration tree and to prune search space by utility upper bounding. We also look ahead to identify high utility patterns without enumeration by a closure property and a singleton property. Our linear data structure enables us to compute a tight bound for powerful pruning and to directly identify high utility patterns in an efficient and scalable way, which targets the root cause with prior algorithms. Extensive experiments on sparse and dense, synthetic and real world data suggest that our algorithm is up to 1 to 3 orders of magnitude more efficient and is more scalable than the state-of-the-art algorithms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Finding interesting patterns has been an important data mining task, and has a variety of applications, for example, genome analysis, condition monitoring, cross marketing, and inventory prediction, where interestingness measures <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b40">[41]</ref> play an important role. With frequent pattern mining <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b42">[43]</ref>, <ref type="bibr" target="#b17">[18]</ref>, a pattern is regarded as interesting if its occurrence frequency exceeds a user-specified threshold. For example, mining frequent patterns from a shopping transaction database refers to the discovery of sets of products that are frequently purchased together by customers. However, a user's interest may relate to many factors that are not necessarily expressed in terms of the occurrence frequency. For example, a supermarket manager may be interested in discovering combinations of products with high profits or revenues, which relates to the unit profits and purchased quantities of products that are not considered in frequent pattern mining.</p><p>Utility mining <ref type="bibr" target="#b40">[41]</ref> emerged recently to address the limitation of frequent pattern mining by considering the user's expectation or goal as well as the raw data. Utility mining with the itemset share framework <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b38">[39]</ref>, for example, discovering combinations of products with high profits or revenues, is much harder than other categories of utility mining problems, for example, weighted itemset mining <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b29">[30]</ref> and objective-oriented utility-based association mining <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b10">[11]</ref>. Concretely, the interestingness measures in the latter categories observe an anti-monotonicity property, that is, a superset of an uninteresting pattern is also uninteresting. Such a property can be employed in pruning search space, which is also the foundation of all frequent pattern mining algorithms <ref type="bibr" target="#b2">[3]</ref>. Unfortunately, the anti-monotonicity property does not apply to utility mining with the itemset share framework <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b38">[39]</ref>. Therefore, utility mining with the itemset share framework is more challenging than the other categories of utility mining as well as frequent pattern mining.</p><p>Most of the prior utility mining algorithms with the itemset share framework <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b38">[39]</ref> adopt a two-phase, candidate generation approach, that is, first find candidates of high utility patterns in the first phase, and then scan the raw data one more time to identify high utility patterns from the candidates in the second phase.</p><p>The challenge is that the number of candidates can be huge, which is the scalability and efficiency bottleneck. Although a lot of effort has been made <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b37">[38]</ref> to reduce the number of candidates generated in the first phase, the challenge still persists when the raw data contains many long transactions or the minimum utility threshold is small. Such a huge number of candidates causes scalability issue not only in the first phase but also in the second phase, and consequently degrades the efficiency. One exception is the HUIMiner algorithm <ref type="bibr" target="#b27">[28]</ref>, which is however even less efficient than two phase algorithms when mining large databases due to inefficient join operations, lack of strong pruning, and scalability issue with its vertical data structure.</p><p>To address the challenge, this paper proposes a new algorithm, d 2 HUP, for utility mining with the itemset share framework, which employs several techniques proposed for mining frequent patterns, including exploring a regular set enumeration in a reverse lexicographic order <ref type="bibr" target="#b42">[43]</ref> and heuristics for ordering items <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b42">[43]</ref>. Our contributions are as follows:</p><p>• A high utility pattern growth approach is proposed, which we argue is one without candidate generation because while the two-phase, candidate generation approach employed by prior algorithms first generates high TWU patterns (candidates) with TWU being an interim, antimonotone measure and then identifies high utility patterns from high TWU patterns, our approach directly discovers high utility patterns in a single phase without generating high TWU patterns (candidates). The strength of our approach comes from powerful pruning techniques based on tight upper bounds on utilities. • A lookahead strategy is incorporated with our approach, which tries to identify high utility patterns earlier without recursive enumeration. Such a strategy is based on a closure property and a singleton property, and enhances the efficiency in dealing with dense data. • A linear data structure, CAUL, is proposed to represent original utility information in raw data, which targets the root cause with prior algorithms, that is, they all employ a data structure to maintain the utility estimates instead of the original utility information, and thus can only determine the candidacy of a pattern but not the actual utility of the pattern in their first phase. The rest of the paper is organized as follows. Section 2 defines the utility mining problem. Section 3 surveys related works. Section 4 proposes our pattern growth approach. Section 5 presents our algorithm. Section 6 discusses the data structure and implementation. Section 7 experimentally evaluates our algorithm. Section 8 analyzes individual techniques. Section 9 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">UTILITY MINING PROBLEM</head><p>This section defines the utility mining problem with the itemset share framework that we study.</p><p>Let I be the universe of items. Let D be a database of transactions {t   The internal utility of an item i in a transaction t, denoted by iu(i, t), is the share of i in t. The external utility of an item i, denoted by eu(i), is the weight of i independent of any transaction. The utility of an item i in a transaction t, denoted by u(i, t), is the function f of iu(i, t) and eu(i), that is, u(i, t) = f (iu(i, t), eu(i)). We assume that the range of f is nonnegative, that is, u(i, t) ≥ 0.</p><p>Although the utility function f may not be nonnegative in an application, it is generally agreed that we can transform the utility function f into a nonnegative function as discussed by Yao et al. <ref type="bibr" target="#b40">[41]</ref>.</p><p>Running example: Consider the data of a supermarket. TABLE 1(a) lists the quantity (share) of each product (item) in each shopping transaction where I = {a, b, c, d, e, f, g} and D = {t 1 , t 2 , t 3 , t 4 , t 5 }, and TABLE 1(b) lists the price (weight) of each product. For transaction t 2 = {a, b, c, f}, we have iu(a,</p><formula xml:id="formula_0">t 2 ) = 6, iu(b, t 2 ) = 2, iu(c, t 2 ) = 2, iu(f, t 2 ) = 5, eu(a) = 1, eu(b) = 3, eu(c) = 5, and eu(f) = 1.</formula><p>Here, u(i, t) is the product of iu(i, t) and eu(i). Thus, u(a, t 2 ) = 6, u(b, t 2 ) = 6, u(c, t 2 ) = 10, u(f, t 2 ) = 5, and so on.</p><p>DEFINITION 2: (a) A transaction t contains a pattern X if X is a subset of t, that is, X ⊆ t, which means that every item i in X has a non-zero share in t, that is, iu(i, t) ̸ = 0. (b) The transaction set of a pattern X, denoted by T S(X), is the set of transactions that contain X. The number of transactions in T S(X) is the support of X, denoted by s(X).</p><p>DEFINITION 3: (a) For a pattern X contained in a transaction t, that is, X ⊆ t, the utility of X in t, denoted by u(X, t), is the sum of the utility of every constituent item of X in t, that is,</p><formula xml:id="formula_1">u(X, t) = ∑ i∈X⊆t u(i, t).</formula><p>(b) The utility of X, denoted by u(X), is the sum of the utility of X in every transaction containing X, that is,</p><formula xml:id="formula_2">u(X) = ∑ t∈T S(X) u(X, t) = ∑ t∈T S(X) ∑ i∈X u(i, t).</formula><p>DEFINITION 4: A pattern X is a high utility pattern, abbreviated as HUP, if the utility of X is no less than a user-defined minimum utility threshold, denoted by minU . High utility pattern mining is to discover all high utility patterns, that is,</p><formula xml:id="formula_3">HU P set = {X|X ⊆ I, u(X) ≥ minU }.</formula><p>In the running example, the manager wants to know every combination of products with sales revenue no less than 30, that is, minU = 30. Since T S({a, b}) = {t 2 , t 3 , t 4 , t 5 }, we have u({a, b}) = u({a, b}, t 2 )+u({a, b}, t 3 )+u({a, b}, t 4 )+u({a, b}, t 5 ) = u(a, t 2 )+u(b, t 2 )+u(a, t 3 )+u(b, t 3 )+u(a, t 4 )+u(b, t 4 )+ u(a, t 5 ) + u(b, t 5 ) = 27. Similarly, u({a, c}) = 28, u({b, c}) = 24, u({a, b, c}) = 31, u({a, b, c, d}) = 13, and so on. Therefore, HU P set = { {a, b, c}, {a, b, d}, {a, d, e}, {a, b, d, e}, {b, d, e}, {d, e}, {a, b, c, d, e, g} }.</p><p>An observation is that the utilities of patterns are neither anti-monotone nor monotone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORKS</head><p>High utility pattern mining problem is closely related to frequent pattern mining, including constraint-based mining. In this section, we briefly review prior works both on frequent pattern mining and on utility mining, and discuss how our work connects to and differs from the prior works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Frequent Pattern Mining</head><p>Frequent pattern mining was first proposed by Agrawal et al. <ref type="bibr" target="#b1">[2]</ref>, which is to discover all patterns whose supports are no less than a user-defined minimum support threshold. Frequent pattern mining employs the anti-monotonicity property: the support of a superset of a pattern is no more than the support of the pattern. Algorithms for mining frequent patterns as well as algorithms for mining high utility patterns fall into three categories, breadth-first search, depthfirst search, and hybrid search.</p><p>Apriori by Agrawal and Srikant <ref type="bibr" target="#b2">[3]</ref> is a very famous breadth-first algorithm for mining frequent patterns, which scans the disk-resident database as many times as the maximum length of frequent patterns. FPgrowth by Han et al. <ref type="bibr" target="#b17">[18]</ref> is a well-known depth-first algorithm, which compresses the database by FP-trees in main memory. Eclat by Zaki <ref type="bibr" target="#b42">[43]</ref> is a famous hybrid algorithm. It keeps a database or a database partition <ref type="bibr" target="#b33">[34]</ref> in memory by a vertical tid-list layout <ref type="bibr" target="#b20">[21]</ref> and can work in either depth-first or breadth-first manner.</p><p>This paper adopts a depth-first strategy since breadth-first search is typically more memoryintensive and more likely to exhaust main memory and thus slower. Concretely, our algorithm depth-first searches a reverse set enumeration tree, which can be thought of as exploring a regular set enumeration tree <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b32">[33]</ref> right-to-left in a reverse lexicographic order <ref type="bibr" target="#b42">[43]</ref>. While Eclat <ref type="bibr" target="#b42">[43]</ref> also explores such an order, our algorithm is the first fully exploiting the benefit in mining high utility patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Constraint-based Mining</head><p>Constraint-based mining is a milestone in evolving from frequent pattern mining to utility mining. Works on this area mainly focus on how to push constraints into frequent pattern mining algorithms.</p><p>Pei et al. <ref type="bibr" target="#b31">[32]</ref> discussed constraints that are similar to (normalized) weighted supports <ref type="bibr" target="#b9">[10]</ref>, and first observed an interesting property, called convertible anti-monotonicity, by arranging the items in weightdescending order. The authors demonstrated how to push them into the FP-growth algorithm <ref type="bibr" target="#b17">[18]</ref> .</p><p>Bucila et al. <ref type="bibr" target="#b8">[9]</ref> considered mining patterns that satisfy a conjunction of anti-monotone and monotone constraints, and proposed an algorithm, DualMiner, that efficiently prunes its search space using both antimonotone and monotone constraints.</p><p>Bonchi et al. <ref type="bibr" target="#b5">[6]</ref> introduced the ExAnte property which states that any transaction that does not satisfy the given monotone constraint can be removed from the input database, and integrated the property with Apriori-style algorithms. Bonchi and Goethals <ref type="bibr" target="#b6">[7]</ref> applied the ExAnte property with the FP-growth algorithm. Bonchi and Lucchese <ref type="bibr" target="#b7">[8]</ref> generalized the data reduction technique to a unified framework.</p><p>De Raedt et al. <ref type="bibr" target="#b13">[14]</ref> investigated how standard constraint programming techniques can be applied to constraint-based mining problems with constraints that are monotone, anti-monotone, and convertible.</p><p>Bayardo and Agrawal <ref type="bibr" target="#b4">[5]</ref>, and Morishita and Sese <ref type="bibr" target="#b30">[31]</ref> proposed techniques of pruning based on upper bounds when the constraint is neither monotone, antimonotone, nor convertible. This paper also employs such a standard technique. Our contribution is to develop tight upper bounds on the utility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Some Categories of Utility Mining</head><p>Interestingness measures can be classified as objective measures, subjective measures, and semantic measures <ref type="bibr" target="#b16">[17]</ref>. Objective measures <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b36">[37]</ref>, such as support or confidence, are based only on data; Subjective measures <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b12">[13]</ref>, such as unexpectedness or novelty, take into account the user's domain knowledge; Semantic measures <ref type="bibr" target="#b40">[41]</ref>, also known as utilities, consider the data as well as the user's expectation. Below, we discuss three categories in detail.</p><p>Hilderman et al. <ref type="bibr" target="#b18">[19]</ref> proposed the itemset share framework that takes into account the weights both on attributes, for example, the price of a product, and on attribute-value pairs, for example, the quantity of a product in a shopping basket. Then, support and confidence measures can be generalized based on count-shares as well as on amount-shares. Yao et al. <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b38">[39]</ref> proposed a utility measure equivalent to Definition 3 that instantiates this framework. This paper falls into that category.</p><p>Cai et al. <ref type="bibr" target="#b9">[10]</ref> proposed weighted itemset mining. Lin et al. <ref type="bibr" target="#b24">[25]</ref> proposed value added association mining. Both works assigns each item a weight representing its importance, which results in (normalized) weighted supports, also known as horizontal weights. Lu et al. <ref type="bibr" target="#b29">[30]</ref> proposed to assign a weight to each transaction representing the significance of the transaction, also known as vertical weights.</p><p>Shen et al. <ref type="bibr" target="#b34">[35]</ref> and Chan et al. <ref type="bibr" target="#b10">[11]</ref> proposed objective-oriented utility-based association mining that explicitly models associations of a specific form "P attern → Objective" where P attern is a set of nonobjective-attribute value pairs, and Objective is a logic expression asserting objective-attributes with each objective-attribute value satisfying (violating) Objective assigned a positive (negative) utility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Algorithms with the Itemset Share Framework</head><p>As the utility measure with the itemset share framework is neither anti-monotone, monotone, nor convertible, most prior algorithms resort to an interim measure, transaction weighted utilization, proposed by Liu et al. <ref type="bibr" target="#b28">[29]</ref>, and adopt a two-phase, candidate generation approach.</p><p>Transaction weighted utilization (TWU) of a pattern is the sum of the transaction utilities of all the transactions containing the pattern. For the running example, TWU({a, b}) = 88, the sum of the utilities of transactions t 2 , t 3 , t 4 , and t 5 , TWU({a, b, c}) = 57, that of t 2 and t 3 , and TWU({a, b, c, d}) = 30, that of t 3 . Clearly, TWU is anti-monotone.</p><p>TWU or its variants is employed by most prior algorithms, which first invoke either Apriori <ref type="bibr" target="#b2">[3]</ref> or FPgrowth <ref type="bibr" target="#b17">[18]</ref> to find high TWU patterns (candidates), and then scan the raw data once more to identify high utility patterns from the candidates. An exception is that Yao et al. <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b39">[40]</ref> presented an upper bound property, that is, the utility of a size-k pattern is no more than the average utility of its size-(k-1) subsets, which is however looser than the TWU property.</p><p>Liu et al. <ref type="bibr" target="#b28">[29]</ref> proposed the anti-monotonicity property with TWU, based on which they developed the TwoPhase algorithm by adapting Apriori <ref type="bibr" target="#b2">[3]</ref>.</p><p>Li et al. <ref type="bibr" target="#b23">[24]</ref> proposed an isolated items discarding strategy (IIDS). An isolated item is one that is not contained in any length-k candidate, and hence it will not occur in any candidate with a length greater than k. Any multi-pass, level-wise can employ IIDS to reduce the number of redundant candidates.</p><p>Lan et al. <ref type="bibr" target="#b22">[23]</ref> proposed an projection-based algorithm, based on the TWU model <ref type="bibr" target="#b28">[29]</ref>, that speeds up the execution by an indexing mechanism.</p><p>Erwin et al. <ref type="bibr" target="#b14">[15]</ref> proposed the CTU-PROL algorithm for mining high utility patterns that integrates the TWU anti-monotonicity property and pattern growth approach <ref type="bibr" target="#b17">[18]</ref> in the first phase, which is facilitated by a compact utility pattern tree structure, CUP-tree.</p><p>Ahmed et al. <ref type="bibr" target="#b3">[4]</ref> proposed a tree-based algorithm, IHUP T W U , for mining high utility patterns, which uses an IHUP T W U -tree to maintain the TWU information of transactions, and mines the set of candidates of high utility patterns by adapting FP-growth <ref type="bibr" target="#b17">[18]</ref>. Notice that CTU-PROL <ref type="bibr" target="#b14">[15]</ref> and IHUP T W U produce the same amount of candidates in the first phase.</p><p>Tseng et al. <ref type="bibr" target="#b37">[38]</ref> proposed the latest, FP-growth based algorithm, UP-Growth, which uses an UP-tree to maintain the revised TWU information, improves the TWU property based pruning, and thus generates fewer candidates in the first phase.</p><p>Yun et al. <ref type="bibr" target="#b41">[42]</ref> and Dawar et al. <ref type="bibr" target="#b11">[12]</ref> improved UP-Growth <ref type="bibr" target="#b37">[38]</ref> by pruning more candidates, while the inherent issue of the two phase approach remains.</p><p>Our preliminary work <ref type="bibr" target="#b26">[27]</ref> and Liu and Qu <ref type="bibr" target="#b27">[28]</ref>, simultaneously and independently, proposed to mine high utility patterns without candidate generation. The HUIMiner algorithm by Liu and Qu <ref type="bibr" target="#b27">[28]</ref> employs a vertical data structure to represent utility information, which employs inefficient join operations and is also not scalable. HUIMiner is even less efficient than an improved version of UP-Growth <ref type="bibr" target="#b37">[38]</ref> when mining large databases. Therefore, scalability and efficiency remains to be a challenge with HUIMiner <ref type="bibr" target="#b27">[28]</ref>. Our work addresses such a challenge with large databases.</p><p>Fournier-Viger et al. <ref type="bibr" target="#b15">[16]</ref> improved HUIMiner <ref type="bibr" target="#b27">[28]</ref> by pre-computing the TWUs of pairs of items to reduce the number of join operations. Krishnamoorthy <ref type="bibr" target="#b21">[22]</ref> improved HUIMiner <ref type="bibr" target="#b27">[28]</ref> by a partition strategy. Their improvement is within a factor of 2 to 6, while our algorithm is up to 45 times faster than HUIMiner <ref type="bibr" target="#b27">[28]</ref> on the same databases.</p><p>This paper has enhanced our preliminary work <ref type="bibr" target="#b26">[27]</ref> with efficient computation by pseudo projection, and with optimizations by partial materialization and controlled irrelevant item filtering. We have put more thoughts into our algorithm and improved the implementation. Moreover, comparative experiments with state-of-art algorithms and experimental anatomy of our individual techniques have been performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">HIGH UTILITY PATTERN GROWTH</head><p>The general approach to mining high utility pattern is to enumerate each subset X of I, and test if X has a utility over the threshold. However, an exhaustive enumeration is infeasible due to the huge number of subsets of I, and hence it is critical to employ strong pruning techniques.</p><p>This section proposes a new approach to the problem, that is, a high utility pattern growth approach. We first introduce a reverse set enumeration tree as a way to enumerate patterns, and then propose strong pruning techniques that drastically reduces the number of patterns to be enumerated, which lays the theoretical foundation for our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Growing Reverse Set Enumeration Tree</head><p>Our pattern growth approach can be thought of as growing or searching a reverse set enumeration tree in a depth-first manner as shown in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>The construction of the reverse set enumeration tree follows an imposed ordering Ω of items. Concretely, the root is labelled by no item, each node N other than the root is labelled by an item, denoted by item(N ), the path from N to the root represents a pattern, denoted by pat(N ), and the child nodes of N are labelled by items listed before item(N ) in Ω. It follows that the sequence of items along the path from N to the root is in accordance with Ω.</p><p>DEFINITION 5: The imposed ordering of items, denoted by Ω, is a pre-determined, ordered sequence of all the items in I. Accordingly, for items i and j, i ≺ j denotes that i is listed before j; i ≺ X denotes that i ≺ j for every j ∈ X, and W ≺ X denotes that i ≺ X for every i ∈ W , in accordance with Ω.</p><p>The imposed ordering Ω of items can be determined by a heuristic proposed by <ref type="bibr" target="#b42">[43]</ref>. Given Ω, a pattern can also be represented as an ordered sequence. For brevity, we use the set notation, for example, {a, b, c}, in place of the sequence notation, for example, &lt;a, b, c&gt;. For example in Fig. <ref type="figure" target="#fig_0">1</ref>, the imposed ordering is the lexicographic order, i.e., Ω = {a, b, c, d, e, f, g}, then a ≺ b, a ≺ c, a ≺ {b, c}, {a, b} ≺ {c, d}, and so on.</p><p>The reverse set enumeration tree is equivalent to a regular set enumeration tree <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b32">[33]</ref> that is imposed with a reverse lexicographic order <ref type="bibr" target="#b42">[43]</ref> and explored right-to-left, which yields a property: a pattern is always enumerated before its supersets <ref type="bibr" target="#b42">[43]</ref> in a depth-first search. For example, {a} and {b} are before {a, b}, and {a, b} and {c} before {a, b, c}.</p><p>Most importantly, by such a construction, the transaction set supporting the enumerated pattern can be determined by a pseudo projection, for example, T S({a, b}) can be projected from T S({b}) without materialization, and thus we can compute the utility of the pattern and a utility upper bound used for pruning in an efficient and scalable way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Pruning by Utility Upper Bounding</head><p>It is computationally infeasible to enumerate all patterns, and a standard technique is to prune the search space. However, for utility mining with the itemset share framework, no anti-monotonicity property can be employed for pruning. An alternative is pruning based on utility upper bounding <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b30">[31]</ref>.</p><p>With our pattern growth approach, it is to estimate an upper bound on utilities of all possible patterns represented by nodes in the subtree rooted at the node currently being explored, when growing the reverse set enumeration tree. If such an upper bound is less than minU , the subtree can be pruned as all patterns in the subtree are not high utility patterns.</p><p>Notice that a pattern Y represented by a node C in the subtree rooted at a node N is a prefix extension of the pattern X represented by N , which leads to a way to estimate an upper bound on the utility of Y .</p><p>DEFINITION 6:</p><formula xml:id="formula_4">Given an ordering Ω, a pattern Y is a prefix extension of a pattern X, if X is a suffix of Y , that is, if Y = W ∪ X for some W with W ≺ X in Ω.</formula><p>DEFINITION 7: Given an ordering Ω, a pattern Y is the full prefix extension of a pattern X w.r.t. a transaction t containing X, denoted as Y = f pe(X, t), if Y is a prefix extension of X derived by adding exactly all the items in t that are listed before</p><formula xml:id="formula_5">X in Ω, that is, if Y = W ∪ X with W = {i|i ∈ t ∧ i ≺ X ∧ X ⊆ t}.</formula><p>For the running example, the full prefix extensions of {c} w.r.t. t 1 and t 2 are f pe({c}, t 1 ) = {a, c} and f pe({c}, t 2 ) = {a, b, c} respectively. THEOREM 1: (Basic upper bounds) For a pattern X, the sum of the utility of the full prefix extension of X w.r.t. each transaction in T S(X), denoted by uB f pe (X), is no less than the utility of any prefix extension Y of X, that is,</p><formula xml:id="formula_6">uB f pe (X) = ∑ t∈T S(X) u(f pe(X, t), t) ≥ u(Y ) (1) Proof: The premise, Y is a prefix extension of X, means X ⊆ Y ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and thus has two implications. First, T S(Y ) ⊆ T S(X). Second, ∀t ∈ T S(Y ), Y ⊆ f pe(X, t).</head><p>As the utility function is non-negative, we have</p><formula xml:id="formula_7">uB f pe (X) = ∑ t∈T S(X) u(f pe(X, t), t) ≥ ∑ t∈T S(Y ) u(f pe(X, t), t) ≥ ∑ t∈T S(Y ) u(Y, t) = u(Y )</formula><p>For example, when enumerating {} by Node 0 in Fig. <ref type="figure" target="#fig_0">1</ref>, we get T S({a}) = D and uB f pe</p><formula xml:id="formula_8">({a}) = u({a}) = 13 &lt; minU = 30, T S({b}) = {t 2 , t 3 , t 4 , t 5 } and uB f pe ({b}) = u({a, b}) = 27 &lt; minU , T S({c}) = {t 1 , t 2 , t 3 } and uB f pe ({c}) = u({a, c}, t 1 ) + u({a, b, c}, t 2 ) + u({a, b, c}, t 3 ) = 37</formula><p>&gt; minU , and so on. Thus, Nodes 1 and 2 (with Node 3) are pruned, and Nodes 4, 8, 16, 32, and 64 will be visited.</p><p>Clearly, the tighter the upper bound, the stronger the pruning. An observation is that many items never occur in high utility patterns when raw data are sparse <ref type="bibr" target="#b23">[24]</ref>. It is possible to exclude them to tighten the upper bound.</p><p>COROLLARY 2: (Relevance of an item) For a pattern X and an item i ≺ X, the sum of the utility of the full prefix extension of X w.r.t. every transaction in T S({i} ∪ X), denoted by uB item (i, X), is no less than the utility of a prefix extension Y of X that contains i, that is,</p><formula xml:id="formula_9">uB item (i, X) = ∑ t∈T S({i}∪X) u(f pe(X, t), t) ≥ u(Y ) (2)</formula><p>Proof: The extra premise in addition to Theorem 1 is that i ⊆ Y , which results in that {i} ∪ X ⊆ Y . In the light of Theorem 1, we get this corollary.</p><p>Corollary 2 states that an item i ≺ X is irrelevant to any high utility pattern that is a prefix extension of X if uB item (i, X) &lt; minU , and can be ignored in enumerating prefix extensions of X.</p><p>For example, when enumerating {d, e} by Node 24 in Fig. <ref type="figure" target="#fig_0">1</ref>, we have uB item (a, {d, e}) = uB item (b, {d, e}) = u({a, b, c, d, e}, t 3 )+u({a, b, d, e}, t 4 ) = 45 &gt; minU , and uB item (c, {d, e}) = u({a, b, c, d, e}, t 3 ) = 25 &lt; minU . Thus, items a and b are relevant, and item c is irrelevant in enumerating prefix extensions of {d, e}. Furthermore, we can apply Corollary 2 iteratively as excluding an irrelevant item may decrease uB item and uB f pe of other items.</p><p>COROLLARY 3: (Tighter upper bounds) For a pattern X and its prefix extension Y that is relevant in growing high utility patterns, a tighter upper bound on the utility of Y is</p><formula xml:id="formula_10">uB ′ f pe (X) = ∑ t∈T S(X) u(f pe ′ (X, t), t) ≥ u(Y )<label>(3)</label></formula><p>where f pe ′ (X, t) is derived from f pe(X, t) by excluding all irrelevant items i ≺ X by Corollary 2.</p><p>For example, as item c is irrelevant in enumerating prefix extensions of {d, e} represented by Node 24 in Fig. <ref type="figure" target="#fig_0">1</ref>, we compute uB item the second time by excluding item c, which yields uB item (a, {d, e}) = uB item (b, {d, e}) = u({a, b, d, e}, t 3 )+u({a, b, d, e}, t 4 ) = 40. The bounds get tighter though the set of relevant items does not shrink.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Avoiding Enumeration by Lookahead</head><p>It is always beneficial to look ahead in a search process if it incurs little extra computation. Inspired by closed frequent pattern mining <ref type="bibr" target="#b43">[44]</ref>, we observe that when all the prefix extensions of the pattern currently enumerated have the same support, in particular for two cases, it is inexpensive to look ahead.</p><p>Case 1: Every prefix extension of a pattern has the same support and has a utility no less than minU , which can be tested by Theorem 4 with little overhead.</p><p>THEOREM 4: (Closure) For a pattern X and a set W of items with X ∩ W = ∅, if a property denoted as Closure(X, W, minU ) is satisfied, i.e., if s({i} ∪ X) = s(X) and u({i} ∪ X) ≥ minU for all i ∈ W , then</p><formula xml:id="formula_11">u(S ∪ X) ≥ minU, ∀S ⊆ W ∧ S ̸ = ∅. (<label>4</label></formula><formula xml:id="formula_12">)</formula><p>Proof: ∀i ∈ W , it is always true that T S({i}∪X) ⊆ T S(X) as X ⊂ {i} ∪ X; by the premise, s({i}</p><formula xml:id="formula_13">∪ X) = s(X), we have T S({i} ∪ X) = T S(X), which results in T S(S ∪ X) = T S(X) for S ⊆ W . Therefore, ∀S ⊆ W ∧ S ̸ = ∅, u(S∪X) = ∑ t∈T S(S∪X) u(S∪X, t) = ∑ t∈T S({i}∪X),i∈S u(S∪X, t) ≥ ∑ t∈T S({i}∪X),i∈W u({i} ∪ X, t) = u({i} ∪ X) ≥ minU.</formula><p>For example, when enumerating {d, e} by Node 24 in Fig. <ref type="figure" target="#fig_0">1</ref>, we get s({a} ∪ {d, e}) = s({b} ∪ {d, e}) = s({d, e}) = 2, and u({a} ∪ {d, e}) = 34 &gt; minU and u({b} ∪ {d, e}) = 36 &gt; minU while items a and b are relevant items and item c is not. Therefore, we know that all the prefix extensions of {d, e} with relevant items a and b, enumerated by Nodes 24 -27, are high utility patterns without searching the rest of the subtree rooted at Node 24.</p><p>Case 2: All the prefix extensions of a pattern have the same support, but among which only the longest has a utility no less than minU . Such a case can be identified by Theorem 5 with little computation.</p><p>THEOREM 5: (Singleton) For a pattern X and a set W of items with X ∩ W = ∅, if a property denoted as Singleton(X, W, minU ) holds, that is, if s({i} ∪ X) = s(X) for all i ∈ W and</p><formula xml:id="formula_14">minU ≤ u(W ∪ X) &lt; minU + min j∈W ∑ t∈T S(X) u({j}, t) then u(S ∪ X) &lt; minU, ∀S ⊂ W. (<label>5</label></formula><formula xml:id="formula_15">)</formula><p>Proof:</p><formula xml:id="formula_16">In the light of Theorem 4, T S(S ∪ X) = T S(X) for S ⊆ W . It follows that ∀S ⊂ W , u(S ∪ X) = ∑ t∈T S(S∪X) u(S ∪ X, t) = ∑ t∈T S(W ∪X) u(W ∪ X, t) - ∑ t∈T S(W \S∪X) u(W \ S, t) ≤ u(W ∪ X) - ∑ t∈T S({j}∪X)∧j∈W \S u({j}, t) ≤ u(W ∪ X) -min j∈W ∑ t∈T S(X) u({j}, t) &lt; minU.</formula><p>For example, when enumerating {g} by Node 64 in Fig. <ref type="figure" target="#fig_0">1,</ref><ref type="figure">items a,</ref><ref type="figure">b,</ref><ref type="figure">c,</ref><ref type="figure">d</ref>, and e are relevant, and s({a} <ref type="figure"></ref>and<ref type="figure">u({a, b, c, d</ref>, e}∪{g}) = 30 = minU . Thus, we know that {a, b, c, d, e, g} is a high utility pattern and all its proper subsets are not without traversing the rest of the subtree.</p><formula xml:id="formula_17">∪ {g}) = s({b} ∪ {g}) = s({c} ∪ {g}) = s({d} ∪ {g}) = s({e}∪{g}) = s({g}) = 1,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">MINING PATTERNS IN ONE PHASE WITH-OUT CANDIDATE GENERATION</head><p>This section presents our algorithm, d 2 HUP, namely Direct Discovery of High Utility Patterns, which is an integration of the depth-first search of the reverse set enumeration tree, the pruning techniques that drastically reduces the number of patterns to be enumerated, and a novel data structure that enables efficient computation of utilities and upper bounds which will be detailed in Section 6.1.</p><p>Moreover, our algorithm lists items in the descending order of uB item based on a heuristic proposed by <ref type="bibr" target="#b42">[43]</ref>. The pseudo code of d 2 HUP is shown in Algorithm 1, which works as follows.</p><p>d 2 HUP builds T S({}) by scanning the database D and the external utility table XU T to compute s({i}), u({i}), uB item (i, {}), and uB f pe ({i}) for each item i by Definitions 2 and 3, Corollaries 2, and Theorem 1 or Corollary 3, and makes Ω in the descending order of uB item (at line 1). d 2 HUP starts searching high utility patterns from the root of reverse set enumeration tree (at lines 2 -3) by calling the DFS(N, T S(pat(N )), minU, Ω) subroutine.</p><p>For the node N currently being visited, DFS prints pat(N )) as a high utility pattern if its utility is no less than the threshold (at line 4), makes the set W of relevant items (at line 5), and then gets through one of the three branches as follows.</p><p>If the closure property holds, DFS outputs every prefix extension of pat(N ) with relevant items as a high utility pattern by Theorem 4 (at lines 6 -7);</p><p>If the singleton property holds, DFS prints the union of all the relevant items and pat(N ) as a high utility pattern by Theorem 5 (at lines 8 -9);</p><p>For each relevant item i ∈ W , if the upper bound on the utilities of prefix extensions of {i} ∪ pat(N ) is no less the threshold, DFS prepares T S(pat(C)) for the child node C with item(C) ← i and pat(C) ← {i} ∪ pat(N ), and recursively searches the subtree rooted at C (at lines 10 -15). Note that DFS computes T S(pat(C)) by a pseudo projection from T S(pat(N )), which is implemented as Algorithm 2 in Section 6.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Revisit the Running Example</head><p>The execution process of d 2 HUP can be thought of as searching a pruned version of a reverse set enumeration tree, which is shown in Fig. <ref type="figure" target="#fig_2">2</ref> for our running example where each node N is labelled with item(N ), s(pat(N )), and u(pat(N )). and by enumerating Node 0 (at lines 1 -3). For each node N to be enumerated, d 2 HUP represents T S(pat(N )) by the data structure detailed in Section 6.1, part of which is a summary table indicating s({i}), u({i}), uB item (i, {}), and uB f pe ({i}) for each item i in T S(pat(N )). Such a summary table is also attached to N in Fig. <ref type="figure" target="#fig_2">2</ref>.</p><p>Node 0 represents the empty pattern {}, which is not a high utility pattern (at line 4). According to the summary table of T S({}) attached to Node 0 in Fig. <ref type="figure" target="#fig_2">2</ref>, all items are relevant, that is, W = {a, b, c, d, e, f, g} (at line 5), and neither the closure property nor the singleton property holds (at lines 6 -9). Nodes 1 and 2 will not be enumerated as uB f pe ({a}) and uB f pe ({b}) are below the threshold. DFS will search Nodes 4, 8, 16, 32, and 64 (at lines 8 -11) as uB f pe ({i}) ≥ minU for i ∈{c, d, e, f, g}.</p><p>When visiting Node 4, the utilities and bounds for i ∈ {a, b} are already maintained in T S({c}) which is derived from T S({}) by a pseudo projection presented in Section 6.3. It turns out that {c} represented by Node 4 is not a high utility pattern, neither the closure property nor the singleton property holds, and Node 5 is pruned as uB f pe ({a, c}) &lt; minU . Subsequently, DFS will recursively visits Node 6 where the closure property holds and hence {a, b, c} is output as a high utility pattern without visiting Node 7.</p><p>The remaining nodes that will be explored in the order of depth-first search are Node 8, Node 10 where the closure property holds, Node 16, Node 24 where the closure property also holds, Node 32, and Node 64 where the singleton property holds and hence {a, b, c, d, e, g} is identified as the only high utility pattern without searching the subtree under Node 64.</p><p>In short, d 2 HUP only enumerates Nodes 0, 4, 6, 8, 10, 16, 24, 32, and 64, a total of 9 nodes, in finding all the high utility patterns, while the entire reverse set enumeration tree consists of 2 7 = 128 nodes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EFFICIENT IMPLEMENTATION BY REPRE-SENTING TRANSACTIONS SCALABLY</head><p>When growing the reverse set enumeration tree, the d 2 HUP algorithm needs to determine T S(pat(N )) for each node N being visited for computing utilities and utility upper bounds for prefix extensions of pat(N ) as shown at line 1 and line 13 in Algorithm 1. How to represent and maintain T S(pat(N )) together with related utilities and upper bounds is the key to the scalability and efficiency of the proposed algorithm.</p><p>This section introduces a linear data structure, CAUL, namely a Chain of Accurate Utility Lists, which is not tree-based, nor graph-based, but simply consists of linear lists. CAUL maintains the original utility information for each enumerated pattern in a way that enables us to compute the utility and to estimate tight utility upper bounds efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Scalable Representation of Utility Information</head><p>For the pattern, pat(N ), represented by a reverse set enumeration tree node N currently visited by a depthfirst search, we use CAUL to maintain the utility information in the transaction set T S(pat(N )) of the node N , denoted by T S caul (pat(N )), which is necessary for computing the utilities and upper bounds of its prefix extensions. T S caul (pat(N )) consists of 2 parts, utility lists and a summary table.</p><p>For each transaction t ∈ T S(pat(N )), there is a utility list holding the utilities of all the items in t relevant in growing prefix extensions of pat(N ). That is, ∀j ∈ f pe(pat(N ), t) \ pat(N ), u(j, t) are stored in the utility list in the imposed ordering Ω. In addition, an extra element is appended to the utility list to maintain u(pat(N ), t).</p><p>The summary table maintains an entry for each distinct item j relevant in growing prefix exten-  <ref type="table" target="#tab_2">1</ref>, for the null root of the reverse set enumeration trees in Fig. <ref type="figure" target="#fig_0">1</ref> and Fig. <ref type="figure" target="#fig_2">2</ref>.</p><p>sions of pat(N ), which is denoted as a quintuple, summary[j] = (s[j], u[j], uB item [j], uB f pe <ref type="bibr">[j]</ref>, link[j]), as described in the following. Summary entries are also arranged in the imposed ordering Ω.</p><p>• s[j] for s({j} ∪ pat(N )) by Definition 2;</p><p>• u[j] for u({j} ∪ pat(N )) by Definition 3;</p><p>• uB item <ref type="bibr">[j]</ref> for uB item (j, pat(N )) by Corollary 2;</p><p>• uB f pe <ref type="bibr">[j]</ref> for uB f pe ({j} ∪ pat(N )) by Theorem 1,3;</p><p>• link[j] for a chain threading together the occurrences of the same item j in the utility lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T S caul ({}) is built by scanning the database D and the external utility table XU T , filtering out globally irrelevant items, and computing s[j], u[j], uB item [j],</head><p>and uB f pe <ref type="bibr">[j]</ref> for each relevant item j.</p><p>For example, Fig. <ref type="figure" target="#fig_3">3</ref> shows T S caul ({}) for Node 0 in Fig. <ref type="figure" target="#fig_0">1</ref> and Fig. <ref type="figure" target="#fig_2">2</ref>. The first list represents t 1 with its first element storing item a and u(a, t 1 ) = 1, its second element storing item c and u(c, t 1 ) = 5, and so on. In any of the five lists, there is no extra element to hold the utility of {} in the transaction since it is 0. The occurrences of item a in all the five lists are threaded by link  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Approach Generating No Candidates Enabled</head><p>One difference between our CAUL and the data structures by prior algorithms <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b37">[38]</ref> is that CAUL keeps the original utility information for each transaction, while the latter keep the utility estimate, TWU, instead. This is the root cause why we are able to mine high utility patterns without generating candidates, while the prior algorithms have to take a two-phase, candidate generation approach.</p><p>We characterize our approach as one without candidate generation in the following senses.</p><p>• While the two-phase, candidate generation approach first generates high TWU patterns (candidates) and then identifies high utility patterns from high TWU patterns, our approach directly finds high utility patterns without generating any high TWU patterns (candidates). • For pattern X being enumerated and represented by a reverse set enumeration tree node N , the utility of X is already computed in the CAUL of the parent node P of N , i.e., in T S caul (pat(P )). Therefore, our approach can read off the utility of X from the CAUL and determine if X is a high utility pattern before X is enumerated, and thus X is not a candidate. • Our approach keeps in main memory only the pattern currently being enumerated, i.e., only the path of the reverse set enumeration tree that is being explored, while the prior algorithms materialize all high TWU patterns (candidates) in main memory in order to identify high utility patterns in an additional screening step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Efficient Computation by Pseudo Projection</head><p>For any node N and its parent node P with pat(N ) = {i} ∪ pat(P ) on the reverse set enumeration tree, T S caul (pat(N )) can be efficiently computed by a pseudo projection <ref type="bibr" target="#b25">[26]</ref>, where the pseudo T S caul (pat(N )) shares the same memory space with T S caul (pat(P )).</p><p>The utility lists of the pseudo T S caul (pat(N )) are delimited by following link[i] in T S caul (pat(P )), and the summary entry for each item j ≺ i of the pseudo T S caul (pat(N )) is computed by scanning each delimited utility list.</p><p>Algorithm 2: PseudoProject(T S caul (pat(P )), i) For example, Fig. <ref type="figure" target="#fig_5">4</ref>(a) shows the pseudo T S caul ({c}) for Node 4 derived from T S caul ({}) for Node 0 in Fig. <ref type="figure" target="#fig_0">1</ref> and Fig. <ref type="figure" target="#fig_2">2</ref>. Three utility lists, t 1 , t 2 , and t 3 , are delimited from within T S caul ({}), and the first two entries of the summary table of T S caul ({}) are updated, which forms the pseudo T S caul ({c}). We can do pseudo projection recursively in two senses.</p><formula xml:id="formula_18">1 foreach relevant item j ≺ i do 2 (s[j], u[j], uB item [j], uB f pe [j], link[j]) ← 0 3 end foreach 4 foreach utility list t threaded by link[i] do 5 u(pat(N ), t) ← u(pat(P ), t) + u(i, t) 6 Σ ← u(pat(N ), t) 7 foreach relevant item j ∈ t ∧ j ≺ i by Ω do 8 s[j] ← s[j] + 1 9 u[j] ← u[j] + u(j, t) + u(pat(N ), t) 10 Σ ← Σ + u(j, t) 11 uB f pe [j] ← uB f pe [j] + Σ 12 end foreach 13 foreach relevant item j ∈ t ∧ j ≺ i by Ω do 14 uB item [j] ← uB item [j] + Σ</formula><p>First, T S caul (pat(P )) for a reverse set enumeration tree node P can be projected to the pseudo T S caul (pat(N ) for a child node N of P , which in turn can be projected to the pseudo T S caul (pat(C) for a grand child node C of P . For example, Fig. <ref type="figure" target="#fig_5">4(b)</ref> shows the pseudo T S caul ({b, c}), for Node 6 in Fig. <ref type="figure" target="#fig_0">1</ref> and Fig. <ref type="figure" target="#fig_2">2</ref>, by calling PseudoProject(the pseudo T S caul ({c}), b).</p><p>Second, although T S caul (pat(P )) is partially modified in projecting to the pseudo T S caul (pat(N )) and to the pseudo T S caul (pat(C)), we can derive the pseudo T S caul (pat(S)) for a sibling node S of node N from this modified T S caul (pat(P )). For example, we can build the pseudo T S caul ({d}) when visiting Node 8 since the threading chain starting from link[d] in T S caul ({}) is untouched before visiting Node 8. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Materialization versus Pseudo Projection</head><p>We may only keep T S caul ({}) in memory and get T S caul for all patterns by recursive pseudo projection, which is the most scalable way to maintain original utility information and is the core of our approach. Furthermore, we can optimize our approach by considering two trade-offs. Maximum Number of Rounds γ for Irrelevant Item Filtering. The body of the PseudoProject algorithm iterates multiple rounds to filter out irrelevant items. We introduce a parameter, to make a tradeoff between the benefit of more pruning by tightening upper bounds and the additional computational overhead for iterative irrelevant item filtering. When no more irrelevant items are identified by Corollary 2 or a maximum number of rounds has been reached, the iteration terminates.</p><p>Materialization Threshold ϕ for Space-Time Tradeoff. We introduce a materialization threshold ϕ to make a tradeoff between the scalability resulted from representing T S caul (pat(N )) by pseudo projection and the efficiency resulted from leaving out irrelevant items by materializing T S caul (pat(N )). When the percentage of relevant items is below the threshold, a materialized copy will be made by copying the pseudo T S caul (pat(N )) to memory space separate from T S caul (pat(P )) so that irrelevant items are left out, u(pat(N ), t) = u(pat(P ), t) + u(i, t) is stored in an extra element for each list t, and lists with an identical set of items are merged.</p><p>For example, Fig. <ref type="figure" target="#fig_5">4</ref>(c) shows the materialized T S caul ({c}) where the summary entries are copied from 4(a), the first list has an element for the only relevant item, a, in t 1 , and a special element for u({c}, t 1 ). As the sets of relevant items are identical, t 2 and t 3 are merged into the second list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">COMPARATIVE EVALUATION</head><p>We evaluate our d 2 HUP algorithm by comparing with the state-of-the-art algorithms, TwoPhase <ref type="bibr" target="#b28">[29]</ref>, IHUP T W U <ref type="bibr" target="#b3">[4]</ref>, UP-Growth <ref type="bibr" target="#b37">[38]</ref>, and HUIMiner <ref type="bibr" target="#b27">[28]</ref>. The code of TwoPhase <ref type="bibr" target="#b28">[29]</ref> and HUIMiner <ref type="bibr" target="#b27">[28]</ref> were provided by the original authors. Due to unavailability, we implemented an improved version of IHUP T W U <ref type="bibr" target="#b3">[4]</ref> and an improved version of UP-Growth <ref type="bibr" target="#b37">[38]</ref>, namely IHUP + T W U and UP + U P G respectively. The latter employ a search tree to compactly represent all candidates, facilitate fast matching between candidates and transactions, and improve the efficiency of the second phase greatly. When mining large databases, UP + U P G is even faster than HUIMiner <ref type="bibr" target="#b27">[28]</ref>, and UP-Growth <ref type="bibr" target="#b37">[38]</ref> simply did not report the running time of the second phase because it is too long <ref type="bibr" target="#b37">[38]</ref>.</p><p>Six datasets are used in comparative experiments. T10I6D1M and T20I6D1M with utility information are exactly the same dataset as in <ref type="bibr" target="#b28">[29]</ref>, and Chainstore is the same as in <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b27">[28]</ref>. WebView-1 and Chess contain no utility information originally. We generate the utility information by following the method in <ref type="bibr" target="#b28">[29]</ref>. So do <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b27">[28]</ref>. Thus, Chess with utility information used by <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b27">[28]</ref> and us share the same features, but are not the same datasets. Foodmart is from the Microsoft foodmart database. The datasets are summarized by TABLE <ref type="table" target="#tab_4">2</ref> where the first column is the name of a dataset, the second (|t|) is the average and maximum length of transactions, the third (|I|) is the number of distinct items, the fourth (|D|) is the number of transactions, and the fifth (Type) is a rough categorization based on the number of high utility patterns to be mined, partially depending on the minimum utility threshold as in TABLE <ref type="table" target="#tab_5">3</ref>. The minimum utility thresholds minU (%) in terms of the percentage of overall utility for each dataset are selected in a way that the results can be verified with <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b27">[28]</ref>. The experiments were performed on a PC with 1.80GHz CPU and 8GB memory running CentOS 6.3. The parameter setting of γ = 3 and ϕ = 0.5 is used as the default for d 2 HUP unless specified otherwise, which is discussed in Section 8.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Enumerated Patterns and Candidates</head><p>TABLE <ref type="table" target="#tab_5">3</ref> shows the number of high utility patterns (hups), the maximum length of high utility patterns (ml), the numbers of patterns enumerated by our d 2 HUP algorithm and HUIMiner respectively, and the numbers of candidates generated in the first phase by UP + U P G , IHUP + T W U , and TwoPhase respectively, with different datasets and varying minU .</p><p>Our d 2 HUP algorithm enumerates less patterns than HUIMiner, and the numbers of candidates generated by UP + U P G , IHUP + T W U , and TwoPhase are 1 to 2 orders, 2 to 4 orders, and over 3 orders of magnitude more than the number of patterns enumerated by d 2 HUP respectively. The reasons are as follows.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Running Time and Memory Usage</head><p>Fig. <ref type="figure" target="#fig_6">5</ref> shows the running time by the five algorithms. For example, for T10I6D1M with minU = 0.01%, d 2 HUP takes 27 seconds, HUIMiner 154, UP + U P G 101, IHUP + T W U 109, and TwoPhase runs out of memory. The observations are as follows.</p><p>First, d 2 HUP is up to 1 to 3 orders of magnitude more efficient than UP + U P G , IHUP + T W U , and T-woPhase. In particular, d 2 HUP is up to 6.6 times, 6.8 times, 7.8 times, 261 times, 472 times, and 1,502 times faster than UP + U P G on T20I6D1M, T10I6D1M, Chainstore, WebView-1, Foodmart, and Chess respectively. The reasons are as follows:</p><p>• The number of patterns enumerated by d 2 HUP is much smaller than the number of candidates generated by UP + U P G , IHUP + T W U , and TwoPhase. Thus, d 2 HUP even takes less time than the first phase of the latter algorithms.</p><p>• The latter materialize candidates and need a second phase to match each candidate with transactions in the database, which causes scalability issue when the number of candidates is large, and has efficiency issue when the database is large. Second, d 2 HUP is up to 1 order of magnitude more efficient than HUIMiner <ref type="bibr" target="#b27">[28]</ref>. Concretely, d 2 HUP is up to 6.3 times, 6.5 times, 16.8 times, 45 times, 49 times, and 875 times faster than HUIMiner on T10I6D1M, T20I6D1M, Chess, Chain-store, Foodmart, and WebView-1 respectively. The reasons are:</p><p>• d 2 HUP has stronger pruning and enumerates less patterns than HUIMiner. • d 2 HUP proposes the data structure, CAUL, that enables efficient computation, while HUIMiner employs inefficient join operations on a vertical data structure, which is also not scalable. Third, for a small and dense dataset like Chess, d 2 HUP with the parameter setting ϕ = 1, depicted by 'd2HUP(f1)' in Fig. <ref type="figure" target="#fig_6">5(c</ref>), outperforms HUIMiner by over 1 order of magnitude, but d 2 HUP with the default setting is a little bit less efficient than HUIMiner. The reason is that although the pseudo CAUL benefits scalability, it entails additional computation due to keeping irrelevant items. In this case, due to a huge number of high utility patterns, the scalability benefit does not excel while the additional computation cost is amplified. A good choice for d 2 HUP is to make a materialized copy of the pseudo CAUL (ϕ = 1).</p><p>Memory Usage. We collect the peak memory usage statistics by every algorithm during its execution except TwoPhase as shown in Fig. <ref type="figure" target="#fig_7">6</ref>. For example, for T10I6D1M with minU = 0.1%, the peak memory usage by d 2 HUP is 147MB, and that by HUIMiner, by UP + U P G , and by IHUP + T W U are 191MB, 153MB, and 154MB respectively. The following is a summary. • The memory usage by UP + U P G and IHUP + T W U are 50% to 2 orders, and 90% to 2 orders of magnitude more than d 2 HUP respectively. TwoPhase uses the most, and usually runs out of memory when minU is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Comparison with varying data characteristics</head><p>We compare our d 2 HUP algorithm with the best prior algorithms, HUIMiner and UP + U P G on varying data characteristics, including different utility distributions, changing number of items, different average length of transactions, and changing data size based on the T10I6D1M dataset as it is large and of a mixed type.</p><p>First, we generate external utilities antiproportional to supports and proportional to supports, in addition to generating external utilities randomly. Fig. <ref type="figure" target="#fig_8">7</ref>(a) shows the running time of the three algorithms on the respective resulting dataset with minU ranging from 0.1% down to 0.001%. The running time with external utilities anti-proportional to supports, as depicted by '(a)', is less than that proportional to supports, as depicted by '(p)', and the latter is less than that generated randomly. For every utility distribution, d 2 HUP takes much less time than HUIMiner and UP + U P G . Second, we conduct a comparative experiment with the number of items ranging from 1K to 10K as shown in Fig. <ref type="figure" target="#fig_8">7(b</ref>). The running time by d 2 HUP and by UP + U P G do not change much because relevant items do increase much with the increase of items. However, the running time by HUIMiner increases sharply with the increase of items.</p><p>Third, we evaluate the effect of the transaction lengths by comparing results both on T10I6D1M and on T20I6D1M. As in Fig. <ref type="figure" target="#fig_8">7(c</ref>) where the results with T20I6D1M are depicted by '(T20)', the running time increases with the average length of transactions since both the average length and the number of high utility patterns also increase, so do the running time gaps among d 2 HUP, HUIMiner, and UP + U P G . Finally, Fig. <ref type="figure" target="#fig_8">7(d)</ref> shows the scalability evaluation result with |D| varying from 100K to 1000K. Clearly, d 2 HUP has better scalability than HUIMiner and UP + U P G according to the slopes of the curves.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">EXPERIMENTAL ANATOMY OF D 2 HUP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Analysis of Additional Pruning Techniques</head><p>First of all, let us note that our "basic approach" is to depth-first search the reverse set enumeration tree with pruning by basic upper bounding (Theorem 1) which is enabled by the pseudo projection of CAUL.</p><p>In terms of the maximum number of rounds γ for iterative irrelevant item filtering and the materialization threshold ϕ, our "basic approach" corresponds to the setting of γ = 1 and ϕ = 0 without lookahead. Fig. <ref type="figure" target="#fig_9">8</ref> reports the running time with γ ranging from 1 to 6 and ϕ ranging from 0 to 1 both with and without lookahead. By comparing with Fig. <ref type="figure" target="#fig_6">5</ref> we can find that our "basic approach" already outperforms prior algorithms significantly. For example, for the T10I6D1M dataset (minU = 0.001%), the running time of our "basic approach" is 36 seconds while that of UP + U P G and IHUP + T W U is 294 and 374 respectively. Second, for all datasets and every setting of γ and ϕ, our lookahead strategy (Theorems 4 and 5) is beneficial in terms of decreasing the running time as depicted by 'with LK' in Fig. <ref type="figure" target="#fig_9">8</ref>. The lookahead is extremely helpful with dense datasets, for example, for Chess, and large datasets, for example, for T10I6D1M.</p><p>Third, in terms of pruning the search space, more irrelevant item filtering (Corollaries 2 and 3) by increasing γ, as depicted by 'rec', and more CAUL materialization by increasing ϕ, as depicted by 'mat', are very helpful as the utility upper bounds become tighter, which also decreases the running time with sparse data, for example, for WebView-1. However, it comes with additional computational and thus the running time does not always decrease with the increase of γ and ϕ, for example, for Chain-store.</p><p>In short, while the setting of γ = 1 and ϕ = 0 with lookahead is good, we recommend to use the setting of γ = 3 and ϕ = 0.5 with lookahead as the default.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Evaluating the Transaction Representation</head><p>We evaluate the memory footprints of the pseudo CAUL and the materialized CAUL by d 2 HUP, the memory footprint of the tree based structure, UP-tree <ref type="bibr" target="#b37">[38]</ref>, by UP + U P G , and the vertical data structure, U-Lists <ref type="bibr" target="#b27">[28]</ref>, by HUIMiner. The results as shown in Fig. <ref type="figure" target="#fig_10">9</ref> can be summarized as follows.</p><p>First, both the pseudo and materialized CAUL have a smaller memory footprint than UP-tree for large datasets, like Chain-store and T10I6D1M. The reason is that transactions in a large dataset are diversified, the memory saved by merging common prefixes of transactions does not offset the additional memory spent on auxiliary fields in each UP-tree node for maintaining the tree structural information.</p><p>Second, for small and dense datasets, UP-tree has higher compression ratio, and thus UP-tree has smaller memory footprint than CAUL, which is however not significant as in such a case CAUL also uses little memory, for example, less than 6MB for Chess.</p><p>Third, U-List has the largest memory footprint because U-List has no compression at all.</p><p>Finally, materializing CAUL usually increases the memory footprint by a small percentage, but by a large percentage for a dense dataset, like Chess. In the latter case, the overall memory footprint may still be small as a dense dataset is usually not that large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION AND FUTURE WORK</head><p>This paper proposes a new algorithm, d 2 HUP, for utility mining with the itemset share framework, which finds high utility patterns without candidate generation. Our contributions include: 1) A linear data structure, CAUL, is proposed, which targets the root cause of the two-phase, candidate generation approach adopted by prior algorithms, that is, their data structures cannot keep the original utility information.</p><p>2) A high utility pattern growth approach is presented, which integrates a pattern enumeration strategy, pruning by utility upper bounding, and CAUL. This basic approach outperforms prior algorithms strikingly. 3) Our approach is enhanced significantly by the lookahead strategy that identifies high utility patterns without enumeration.</p><p>In the future, we will work on high utility sequential pattern mining, parallel and distributed algorithms, and their application in big data analytics.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Reverse set enumeration tree where each node is numbered in the order of depth-first search.</figDesc><graphic coords="5,36.95,52.91,234.19,82.43" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 1 :end foreach d 2</head><label>12</label><figDesc>d 2 HUP(D, XU T, minU ) 1 build T S({}) and Ω from D and XU T 2 N ← root of reverse set enumeration tree 3 DFS(N, T S(pat(N )), minU, Ω)Subroutine: DFS(N, T S(pat(N )), minU, Ω) 4 if u(pat(N )) ≥ minU then output pat(N ) 5 W ← {i|i ≺ pat(N )∧uB item (i, pat(N ))≥minU } 6 if Closure(pat(N ), W,minU ) is satisfied 7 then output nonempty subsets of W ∪pat(N ) 8 else if Singleton(pat(N ), W, minU ) is satisfied 9 then output W ∪ pat(N ) as an HUP 10 else foreach item i ∈ W in Ω do 11 if uB f pe ({i} ∪ pat(N )) ≥ minU 12 then C ← the child node of N for i 13 T S(pat(C)) ← Project(T S(pat(N )), i) 14 DFS(C, T S(pat(C)), minU, Ω) 15 HUP starts by computing T S({})</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Pruned version of the reverse set enumeration tree in Fig. 1, showing how d 2 HUP works given minU = 30.</figDesc><graphic coords="8,127.30,51.30,306.85,214.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. T S caul ({}): CAUL representing transaction set T S({}), derived from D in TABLE 1, for the null root of the reverse set enumeration trees in Fig. 1 and Fig.2.</figDesc><graphic coords="8,290.89,304.27,231.40,75.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>[a] of the first summary entry. The other components, s[a], u[a], uB item [a], and uB f pe [a], of the first summary entry keep s({a}), u({a}), uB item (a, {}), and uB f pe ({a}) respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Projections from T S caul ({}).</figDesc><graphic coords="9,39.33,51.03,231.53,270.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Running time vs. minU (%).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Peak memory usage vs. minU (%).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Running time with varying data characteristic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Running time of d 2 HUP with varying γ and ϕ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Memory footprints of trans. representations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 1 Database</head><label>1</label><figDesc>D and eXternal Utility Table XU T</figDesc><table><row><cell cols="6">(a) D: shopping transactions</cell><cell></cell><cell></cell><cell cols="2">(b) XU T : prices</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>ITEM</cell><cell></cell><cell></cell><cell></cell><cell>ITEM</cell><cell>PRICE</cell></row><row><cell>TID</cell><cell cols="2">a b</cell><cell>c</cell><cell>d</cell><cell>e</cell><cell>f</cell><cell>g</cell><cell>a</cell><cell>1</cell></row><row><cell>t 1</cell><cell>1</cell><cell></cell><cell>1</cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell>b</cell><cell>3</cell></row><row><cell>t 2</cell><cell>6</cell><cell>2</cell><cell>2</cell><cell></cell><cell></cell><cell>5</cell><cell></cell><cell>c</cell><cell>5</cell></row><row><cell>t 3</cell><cell>1</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>6</cell><cell></cell><cell>5</cell><cell>d</cell><cell>2</cell></row><row><cell>t 4</cell><cell>3</cell><cell>1</cell><cell></cell><cell>4</cell><cell>3</cell><cell></cell><cell></cell><cell>e</cell><cell>2</cell></row><row><cell>t 5</cell><cell>2</cell><cell>1</cell><cell></cell><cell>2</cell><cell></cell><cell>2</cell><cell></cell><cell>f</cell><cell>1</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>g</cell><cell>1</cell></row><row><cell cols="10">t i ⊆ I. Each item in a transaction is assigned a non-</cell></row><row><cell cols="10">zero share. Each distinct item has a weight indepen-</cell></row><row><cell cols="10">dent of any transaction, given by an eXternal Utility</cell></row><row><cell cols="10">Table (XU T ). The research problem of finding all high</cell></row><row><cell cols="10">utility patterns is formally defined as follows.</cell></row><row><cell cols="4">DEFINITION 1:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 2</head><label>2</label><figDesc>Characteristics of Six Datasets</figDesc><table><row><cell>Dataset</cell><cell>|t|</cell><cell>|I|</cell><cell>|D|</cell><cell>Type</cell></row><row><cell>T10I6D1M</cell><cell>10 : 33</cell><cell>1,000</cell><cell>933, 493</cell><cell>mixed</cell></row><row><cell>WebView-1</cell><cell>2.5 : 267</cell><cell>497</cell><cell>59, 602</cell><cell>sparse</cell></row><row><cell>Chess</cell><cell>37 : 37</cell><cell>76</cell><cell>3, 197</cell><cell>dense</cell></row><row><cell cols="2">Chain-store 7.2 : 170</cell><cell cols="3">46,086 1, 112, 949 sparse</cell></row><row><cell>T20I6D1M</cell><cell>20 : 49</cell><cell>1,000</cell><cell>999, 287</cell><cell>mixed</cell></row><row><cell>Foodmart</cell><cell>4.8 : 27</cell><cell>1,559</cell><cell>34, 015</cell><cell>dense</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE 3</head><label>3</label><figDesc></figDesc><table><row><cell cols="6">Patterns enumerated by d 2 HUP, HUIMiner, and</cell><cell></cell></row><row><cell cols="6">candidates by UP + U P G , IHUP + T W U , TwoPhase</cell><cell></cell></row><row><cell cols="2">(a) T10I6D1M</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>minU</cell><cell>hups(ml)</cell><cell cols="2">d 2 HUP HUIM.</cell><cell>UP+</cell><cell>IHUP+</cell><cell>T.P.</cell></row><row><cell>0.5%</cell><cell>25 (1)</cell><cell>639</cell><cell>639</cell><cell>673</cell><cell>711</cell><cell>226K</cell></row><row><cell>0.1%</cell><cell>389 (8)</cell><cell>1,092</cell><cell>1,871</cell><cell>8,735</cell><cell>32K</cell><cell>611K</cell></row><row><cell>.01%</cell><cell>873K (17)</cell><cell>1.06M</cell><cell>1.21M</cell><cell>1.7M</cell><cell>2.1M</cell><cell>-</cell></row><row><cell>.005%</cell><cell>1.6M (17)</cell><cell>1.8M</cell><cell>2M</cell><cell>2.4M</cell><cell>2.9M</cell><cell>-</cell></row><row><cell cols="2">(b) WebView-1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>minU</cell><cell>hups(ml)</cell><cell cols="2">d 2 HUP HUIM.</cell><cell>UP+</cell><cell>IHUP+</cell><cell>T.P.</cell></row><row><cell>3.2%</cell><cell>2 (1)</cell><cell>11</cell><cell>19</cell><cell>159</cell><cell>71K</cell><cell>95K</cell></row><row><cell>3%</cell><cell>2 (1)</cell><cell>21</cell><cell>27</cell><cell>171</cell><cell>12M</cell><cell>-</cell></row><row><cell>2.1%</cell><cell>6 (1)</cell><cell>203</cell><cell>15.7M</cell><cell>1,809</cell><cell>-</cell><cell>-</cell></row><row><cell>1.9%</cell><cell>11K (148)</cell><cell>160K</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell>(c) Chess</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>minU</cell><cell>hups(ml)</cell><cell cols="2">d 2 HUP HUIM.</cell><cell>UP+</cell><cell>IHUP+</cell><cell>T.P.</cell></row><row><cell>60%</cell><cell>0 (0)</cell><cell>0</cell><cell>0</cell><cell>34</cell><cell>299K</cell><cell>304K</cell></row><row><cell>30%</cell><cell>7.4K (16)</cell><cell>13.9K</cell><cell>16.8K</cell><cell>1.34M</cell><cell>43.7M</cell><cell>-</cell></row><row><cell>20%</cell><cell>1.1M (20)</cell><cell>1.08M</cell><cell>1.61M</cell><cell>43.7M</cell><cell>-</cell><cell>-</cell></row><row><cell>10%</cell><cell>124M (25)</cell><cell>83.6M</cell><cell>158M</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell cols="2">(d) Chain-store</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>minU</cell><cell>hups(ml)</cell><cell cols="2">d 2 HUP HUIM.</cell><cell>UP+</cell><cell>IHUP+</cell><cell>T.P.</cell></row><row><cell>0.25%</cell><cell>17 (1)</cell><cell>152</cell><cell>135</cell><cell>1,123</cell><cell>1,577</cell><cell>628K</cell></row><row><cell>0.1%</cell><cell>80 (2)</cell><cell>1,661</cell><cell>1,629</cell><cell>3,876</cell><cell>7,117</cell><cell>7.3M</cell></row><row><cell>0.01%</cell><cell>3,839 (6)</cell><cell>21.4K</cell><cell>28.4K</cell><cell>66.6K</cell><cell>286K</cell><cell>-</cell></row><row><cell>.005%</cell><cell>12K (11)</cell><cell>43.1K</cell><cell>71.2K</cell><cell>225K</cell><cell>9.48M</cell><cell>-</cell></row><row><cell cols="2">(e) T20I6D1M</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>minU</cell><cell>hups(ml)</cell><cell cols="2">d 2 HUP HUIM.</cell><cell>UP+</cell><cell>IHUP+</cell><cell>T.P.</cell></row><row><cell>0.5%</cell><cell>25 (1)</cell><cell>786</cell><cell>786</cell><cell>798</cell><cell>3,311</cell><cell>334K</cell></row><row><cell>0.1%</cell><cell>669 (11)</cell><cell>2,302</cell><cell>10.3K</cell><cell>66.4K</cell><cell>207K</cell><cell>-</cell></row><row><cell>.01%</cell><cell>923K (17)</cell><cell>1.24M</cell><cell>1.54M</cell><cell>2.92M</cell><cell>6.1M</cell><cell>-</cell></row><row><cell>.005%</cell><cell>1.8M (17)</cell><cell>2.35M</cell><cell>2.81M</cell><cell>9.55M</cell><cell>23.4M</cell><cell>-</cell></row><row><cell cols="2">(f) Foodmart</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>minU</cell><cell>hups(ml)</cell><cell cols="2">d 2 HUP HUIM.</cell><cell>UP+</cell><cell>IHUP+</cell><cell>T.P.</cell></row><row><cell>0.1%</cell><cell>198 (1)</cell><cell>1,553</cell><cell>1,556</cell><cell>1,559</cell><cell>1,559</cell><cell>1.2M</cell></row><row><cell>0.02%</cell><cell>1,467 (27)</cell><cell>1,590</cell><cell>2,097</cell><cell>26.1K</cell><cell>-</cell><cell>-</cell></row><row><cell cols="2">0.015% 1.72M (27)</cell><cell>1.58M</cell><cell>3.78M</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell>0.01%</cell><cell>74.2M (27)</cell><cell>17.5M</cell><cell>91.5M</cell><cell>-</cell><cell>-</cell><cell>-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>We propose the lookahead strategy to improve the pruning while HUIMiner does not.</figDesc><table><row><cell>• Our utility upper bounds are tighter than the</cell></row><row><cell>upper bounds by HUIMiner and the TWUs by</cell></row><row><cell>UP + U P G , IHUP + T W U , and TwoPhase respectively,</cell></row><row><cell>which results in stronger pruning.</cell></row></table><note><p>• • CAUL enables tightening upper bounds iteratively in the mining process while the data structures by UP + U P G , IHUP + T W U , and TwoPhase cannot.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING, VOL. X, NO. X, MONTH YEAR</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported in part by the National Natural Science Foundation of China (61272306), and the Zhejiang Provincial Natural Science Foundation of China (LY12F02024). The authors would like to express their gratitude to the anonymous reviewers.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PLACE PHOTO HERE</head><p>Junqiang <ref type="bibr">Liu</ref>  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Depth first generation of long patterns</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Prasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="108" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining association rules between sets of items in large databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="207" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast algorithms for mining association rules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="487" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient tree structures for high utility pattern mining in incremental databases</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Tanbeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-S</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-K</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1708" to="1721" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Mining the most interesting rules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bayardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="145" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Exante: A preprocessing method for frequent-pattern mining</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Giannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mazzanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pedreschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intelligent Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="25" to="31" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Fp-bonsai: The art of growing and pruning small fp-trees</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Goethals</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>PAKDD</publisher>
			<biblScope unit="page" from="155" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Extending the state-of-the-art of constraint-based pattern discovery</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lucchese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data and Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="377" to="399" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dualminer: A dual-pruning algorithm for itemsets with constraints</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bucila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="241" to="272" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Mining association rules with weighted items</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W C</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Kwong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Database Engineering and Applications Symposium</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="68" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Mining high utility itemsets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Up-hist tree: An efficient data structure for mining high utility patterns from transaction databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Goyal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IDEAS</title>
		<imprint>
			<biblScope unit="page" from="56" to="61" />
			<date type="published" when="2015">2015</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Maximum entropy models and subjective interestingness: an application to tiles in binary databases</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">De</forename><surname>Bie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="407" to="446" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Constraint programming for itemset mining</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Guns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nijssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="204" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Efficient mining of high utility itemsets from large datasets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Erwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Achuthan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>PAKDD</publisher>
			<biblScope unit="page" from="554" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fhm: Faster high-utility itemset mining using estimated utility cooccurrence pruning</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fournier-Viger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Tseng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISMIS</title>
		<imprint>
			<biblScope unit="page" from="83" to="92" />
			<date type="published" when="2014">2014</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interestingness measures for data mining: A survey</title>
		<author>
			<persName><forename type="first">L</forename><surname>Geng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Mining frequent patterns without candidate generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Mining market basket data using share measures and characterized itemsets</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Hilderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cercone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>PAKDD</publisher>
			<biblScope unit="page" from="72" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Measuring the interestingness of discovered knowledge: A principled approach</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Hilderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intelligent Data Analysis</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="347" to="382" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A perspective on databases and data mining</title>
		<author>
			<persName><forename type="first">M</forename><surname>Holsheimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<biblScope unit="page" from="150" to="155" />
			<date type="published" when="1995">1995</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Pruning strategies for mining high utility itemsets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Syst. Appl</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="2371" to="2381" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An efficient projectionbased indexing approach for mining high utility itemsets</title>
		<author>
			<persName><forename type="first">G.-C</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-P</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Tseng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KAIS</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="85" to="107" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Isolated items discarding strategy for discovering high utility itemsets</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data &amp; Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="198" to="217" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Value added association rules</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Y</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Louie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>PAKDD</publisher>
			<biblScope unit="page" from="328" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Mining frequent item sets by opportunistic projection</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="229" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Direct discovery of high utility itemsets without candidate generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Fung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="984" to="989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Mining high utility itemsets without candidate generation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Qu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A fast high utility itemsets mining algorithm</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Choudhary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Utility-Based Data Mining Workshop in SIGKDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="253" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Mining weighted association rules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intelligent Data Analysis</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="225" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Traversing itemset lattice with statistical metric pruning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Morishita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="226" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Pushing convertible constraints in frequent itemset mining</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lakshmanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="227" to="252" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Prefixspan: Mining sequential patterns efficiently by prefixprojected pattern growth</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An efficient algorithm for mining association rules in large databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Savasere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Omiecinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Navathe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="432" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Objective-oriented utilitybased association mining</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="426" to="433" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On subjective measures of interestingness in knowledge discovery</title>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tuzhilin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="275" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Selecting the right objective measure for association analysis</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="293" to="313" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Efficient algorithms for mining high utility itemsets from transactional databases</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-E</forename><surname>Shie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1772" to="1786" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Mining itemset utilities from transaction databases</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data &amp; Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="603" to="626" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A foundational approach to mining itemset utilities from databases</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Butz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SDM</title>
		<imprint>
			<publisher>SIAM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="482" to="486" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A unified framework for utility-based measures for mining itemsets</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Geng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Utility-Based Data Mining in SIGKDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="28" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">High utility itemset mining with techniques for reducing overestimated utilities and pruning candidates</title>
		<author>
			<persName><forename type="first">U</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ryang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Ryu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Syst. Appl</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="3861" to="3878" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Scalable algorithms for association mining</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="372" to="390" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Efficient algorithms for mining closed itemsets and their lattice structure</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hsiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="462" to="478" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
