<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Efficient Top-k Query Processing in Highly Distributed Environments</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Akrivi</forename><surname>Vlachou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">Athens University of Economics and Business</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christos</forename><surname>Doulkeridis</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">Athens University of Economics and Business</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Kjetil</forename><surname>Nørvåg</surname></persName>
							<email>kjetil.norvag@idi.ntnu.no</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">NTNU</orgName>
								<address>
									<settlement>Trondheim</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michalis</forename><surname>Vazirgiannis</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">Athens University of Economics and Business</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On Efficient Top-k Query Processing in Highly Distributed Environments</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8A5AB348BC2DF8A395D94A0B51B5DBD5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.4 [Database Management]: Systems-Query processing Algorithms</term>
					<term>Experimentation</term>
					<term>Performance</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Lately the advances in centralized database management systems show a trend towards supporting rank-aware query operators, like top-k, that enable users to retrieve only the most interesting data objects. A challenging problem is to support rank-aware queries in highly distributed environments. In this paper, we present a novel approach, called SPEERTO, for top-k query processing in large-scale peer-topeer networks, where the dataset is horizontally distributed over the peers. Towards this goal, we explore the applicability of the skyline operator for efficiently routing top-k queries in a large super-peer network. Relying on a thresholding scheme, SPEERTO returns the exact results progressively to the user, while the number of queried super-peers and transferred data is minimized. Finally, we propose different variations of SPEERTO that allow balancing between transferred data volume and response time. Through simulations we demonstrate the feasibility of our approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>and overwhelming result sets. Top-k queries retrieve the objects that best match the user requirements by employing user-specified scoring functions that result in an ordered set of objects containing the best k objects only <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b14">14]</ref>.</p><p>A number of applications can significantly benefit from support for top-k query processing, for example multimedia retrieval (including images) <ref type="bibr">[9,</ref><ref type="bibr" target="#b12">12]</ref>, digital libraries <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16]</ref>, web search <ref type="bibr" target="#b18">[18]</ref>, and e-commerce <ref type="bibr" target="#b17">[17]</ref>. Consider for example online booking systems, e.g, travel and accommodation, where the user is only interested in the best offers (airtickets, hotels) according to a set of dynamic, user-specified criteria.</p><p>Due to applications and systems such as sensor networks, data streams, and peer-to-peer (P2P) systems, data generation and storage is becoming increasingly distributed. Thus an emerging challenge is to support top-k query processing over a highly distributed network of collaborative computers (i.e. servers or peers). In this paper we focus on top-k query processing in P2P systems, which is a context that can also easily be generalized to other distributed systems. There is only limited previous work on supporting top-k queries in P2P systems, and those approaches either assume vertical data partitioning to peers <ref type="bibr" target="#b18">[18]</ref>, rely on caching techniques <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b22">22]</ref>, or deliver approximate query result sets <ref type="bibr" target="#b13">[13]</ref>. In contrast to these approaches, our work assumes horizontal data partitioning among peers and supports a large class of scoring functions. Each user may define his/her own arbitrary preferences for each query, therefore the queries are not necessarily re-occurring, which renders caching techniques inappropriate. The challenge is to provide efficient algorithms for processing top-k queries, i.e. queries that return only the exact best k results to the user.</p><p>In this paper we present SPEERTO <ref type="foot" target="#foot_0">1</ref> , a framework that supports top-k query processing over horizontally partitioned data stored on peers organized in a super-peer network. Users are allowed to specify a monotone function for each query that aggregates a certain number of the objects characteristics into a single score that defines a total ordering, and therefore enables the retrieval of top-k results. Our approach is based on novel use of the skyline operator <ref type="bibr" target="#b5">[5]</ref> for answering top-k queries. For a maximum value of K, denoting an upper bound on the number of results requested by any top-k query (k ≤ K), each peer computes its K-skyband <ref type="bibr" target="#b20">[20]</ref> as a pre-processing step. Each super-peer maintains and aggregates the K-skyband sets of its peers to answer any incoming top-k query. By exchanging skyline sets (which are a subset of the K-skyband sets) at super-peer level, SPEERTO always provides the exact and complete result set in a progressive way, while queries are deliberately routed to those super-peers that actually contribute to the top-k (k ≤ K) result.</p><p>To summarize, SPEERTO utilizes a threshold-based superpeer selection mechanism based on the skyline points of each super-peer. Although the skyline operator <ref type="bibr" target="#b5">[5]</ref> has received recently considerable attention, the usage of the skyline operator for answering top-k queries has yet not been explored. We study the correctness of our approach and its effectiveness in terms of number of queried super-peers and transferred objects. The main contributions of our work are:</p><p>• An exploration of the applicability of the skyline operator for efficiently answering top-k queries for a wide class of scoring functions, indicating user-specified preferences, in large P2P networks.</p><p>• A presentation of SPEERTO, a novel framework which efficiently supports progressive processing of top-k queries using the skyline and K-skyband sets, employing a thresholding scheme in order to facilitate pruning of objects that cannot belong to the result set. Moreover, the correctness and optimality in terms of queried super-peers and transferred data are demonstrated.</p><p>• A detailed study of different variations of SPEERTO in order to balance between different performance metrics, like response time and volume of exchanged data.</p><p>• An extensive experimental evaluation showing that our approach performs efficiently and provides a viable solution. We also evaluate SPEERTO for top-k queries with k &gt; K where we achieve high recall values.</p><p>The rest of this paper is organized as follows: Section 2 reviews the related work, and in Section 3 we provide the preliminaries for presenting SPEERTO. In Section 4, we describe how to construct the skyline-based routing mechanism for top-k query processing over a super-peer architecture. Thereafter, in Section 5 our threshold-based top-k algorithm is presented, while in Section 6 we discuss extensions of SPEERTO. The experimental evaluation is presented in Section 7, and finally we conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Several papers have dealt with the issue of top-k query processing in centralized database management systems <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b14">14]</ref>. Previous work in distributed environments <ref type="bibr">[9,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b17">17]</ref> has focused on vertically distributed data over multiple sources, where each source provides a ranking over some attributes. Most approaches, such as recently <ref type="bibr" target="#b2">[2]</ref>, try to improve some limitations of the Threshold Algorithm <ref type="bibr" target="#b11">[11]</ref>. A common underlying assumption of these papers is that data is vertically distributed to nodes, in contrast to our case where we assume horizontal distribution of data. Marian et al. <ref type="bibr" target="#b17">[17]</ref> study top-k query evaluation over web-accessible databases, including random accesses to score lists, instead of sorted accesses only, as in <ref type="bibr" target="#b11">[11]</ref>. Following the same concept, there exists some previous work for top-k queries in P2P over vertically distributed data. In <ref type="bibr" target="#b6">[6]</ref>, Cao and Wang propose an algorithm called "Three-Phase Uniform Threshold" (TPUT) that aims to prune unnecessary data objects and it is guaranteed to terminate in three round-trips. Later, TPUT was improved by KLEE <ref type="bibr" target="#b18">[18]</ref>. KLEE has two variants, one that requires three phases and another that only needs two round-trips. KLEE also provides mechanisms for trading performance with result quality, thus supporting approximate top-k retrieval. However, processing top-k queries in the context of horizontally distributed data and P2P systems has not been adequately addressed yet.</p><p>For horizontally distributed data among peers, P2P top-k query processing has been studied in only a few works so far. Balke et al. <ref type="bibr" target="#b4">[4]</ref> try to minimize the data object traffic induced by top-k processing. However, this approach requires that each query is processed by all super-peers, unless the exact same query reoccurs, which is unlikely as there is an infinite number of potential queries posed by different users. A similar approach for unstructured P2P systems is presented in <ref type="bibr" target="#b1">[1]</ref>, where the main technique is a variant of flooding, followed by a merging score-list step at intermediate peers. In <ref type="bibr" target="#b22">[22]</ref>, the authors rely on result caching to prune network paths and answer queries without contacting all peers. Their approach relies on caching techniques, therefore the performance is dependent on the query distribution. Even more important, they assume acyclic networks, which is restrictive for dynamic peer-to-peer networks. Hose et al. <ref type="bibr" target="#b13">[13]</ref> construct routing filters in the form of histograms, in order to prune query paths and return approximate results. These filters are built on each peer progressively, as the peer communicates with other peers, using a query feedback approach. However this approach delivers approximate answers and the performance drops with increasing dimensionality since multi-dimensional histograms should be used.</p><p>In the area of P2P information retrieval, there exists some work that takes into account top-k queries. However this work is not entirely within the context of our work, as their main focus is on document retrieval and on defining an appropriate scoring function. For example, in <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16]</ref>, Lu and Callan focus on search in a digital library context, using hierarchical P2P networks and propose result merging algorithms based on sampled documents from neighboring peers.</p><p>Finally, the skyline operator <ref type="bibr" target="#b5">[5]</ref> has recently received considerable attention, but its usage for answering top-k queries has not been explored yet. In <ref type="bibr" target="#b21">[21]</ref> the authors improve the performance of ranked join indices based on the concept of dominating sets. In <ref type="bibr" target="#b19">[19]</ref> a method for continuous topk queries over streams is presented that monitors the top-k objects by using the K-skyband on a two dimensional transformed score-time space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PRELIMINARIES</head><p>In this section, we present the problem statement, the basics regarding top-k queries, and a short overview of the P2P system where the proposed approach is deployed. An overview of the symbols used can be found in Table <ref type="table" target="#tab_0">1</ref>. The feature space is defined by the d scoring functions sj , therefore it is a d-dimensional space. An object oi ∈ O can be represented as a point p in the feature space: p = {p <ref type="bibr" target="#b1">[1]</ref>, ..., p[d]}, where p[j] = sj(oi) is a value on dimension dj . Figure <ref type="figure" target="#fig_0">1</ref> depicts a 2-dimensional example. In the rest of this paper we use the terms object and data point interchangeably.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem Statement</head><p>In our approach we assume an aggregation function f that is increasingly monotone</p><formula xml:id="formula_0">, i.e. if p[i] ≤ p [i] for every i, then f (p) = f (p[1], ..., p[d]) ≤ f (p [1], ..., p [d]) = f (p ).</formula><p>The restriction of monotonicity is a common property <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b11">11]</ref> and it conveys the meaning that whenever the score of all dimensions of the point p is at least as good as another point p , then we expect that the overall score of p is as least good as p . The result of a top-k query is the ranked list of the k objects with lowest score values.</p><p>A special case of monotone functions is the weighted sum function, also called linear. Each feature sj(oi) has an associated query-dependent weight wj indicating sj's relative importance for the query. The aggregated score for object oi is defined as a weighted sum of the individual scores: score(oi) = d j=1 wj ×sj(oi), where wj ≥ 0 (1 ≤ j ≤ d) and ∃j such that wj &gt; 0. As some weights can be set equal to zero, our approach also supports top-k queries with respect to only to a subset of the available features. The weights indicate the user's preferences and influence the ordering of the data objects and therefore the top-k result set. Consider for example the dataset depicted in Figure <ref type="figure" target="#fig_0">1</ref>. By assigning a high weight to feature s2, point p is the top-1 object, while if a low weight is used, point q becomes the top-1 object.</p><p>Our approach is applicable for any increasingly monotone aggregate function, but in our examples we use the weighted sum function, which is one of the most common scoring functions for top-k retrieval. In our setting a top-k query q k (f ) takes two parameters: a user specified monotone function f and the number of requested objects k. In the special case of the weighted sum, the user specifies the weighting of each feature, i.e. how important this feature is based on his preferences. Therefore the query can be expressed as q k (w), where w is a d-dimensional vector w = {w1, ...w d }. Notice that both the scoring function and the parameter k may differ for each query and we are interested in retrieving the k objects with the best (minimum) values of the scoring function.</p><p>Feature Space s 1</p><formula xml:id="formula_1">s 2 p q p[2] p[1] q[1] q[2]</formula><p>Data Objects o i </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">System Overview</head><p>The overall aim is to provide a routing mechanism for answering top-k queries in P2P networks, assuming a superpeer architecture. More formally, we assume an unstructured P2P network of Np peers. Some peers have special roles, due to their enhanced features, such as availability, stability, storage capability and bandwidth capacity. These peers are called super-peers SPi (1 ≤ i ≤ Nsp), and they constitute only a small fraction of the peers in the network, i.e. Nsp &lt;&lt; Np. Peers that join the network directly connect to one of the super-peers. Each super-peer maintains links to simple peers, based on the value of its degree parameter DEGp. In addition, a super-peer is initially connected to a limited set of at most DEGsp other super-peers (DEGsp &lt; DEGp). Later, at query time, each super-peer is able to open direct connection to any other super-peer in the network, using its IP address. However notice that the approach is also applicable, when no direct connection between super-peers can be established, and the communication is achieved by query forwarding through other super-peers.</p><p>Each peer Pi holds ni d-dimensional points, denoted as a set Oi (1 ≤ i ≤ Np). Since we assume horizontal data distribution, the size of the complete set of points is n = Np i=1 ni and the dataset O is the union of all peers' datasets Oi (O = ∪Oi). Each peer maintains its own data objects, such as images or documents, and only the feature values of few selected objects, namely the K-skyband <ref type="bibr" target="#b20">[20]</ref> points, are published as representative points to the respective super-peer, while the original data is stored at the peer. By maintaining the K-skyband points, any super-peer is capable of answering any top-k (k ≤ K) query as far as only the data of all peers connected to the super-peer are concerned. The remaining challenge is to answer top-k queries over the entire super-peer network, in a way that only super-peers that contributed to the query are contacted. In the following, we propose an approach that supports top-k queries over data distributed in a super-peer network, utilizing routing indices based on skylines <ref type="bibr" target="#b5">[5]</ref>. Our technique guarantees accurate results, while minimizing the number of queried super-peers and the amount of network traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SKYLINE-BASED ROUTING</head><p>In this section, we first discuss the relation between topk and skyline queries (Section 4.1). Thereafter, in Section 4.2, we describe how to construct the skyline-based routing mechanism for top-k query processing over a super-peer architecture. Finally, in Section 4.3, we outline the effects of churn and dynamic data on the routing mechanism. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Top-k and Skyline Queries</head><p>Consider a linear top-k query defined by a vector w. As discussed in <ref type="bibr" target="#b21">[21]</ref> the magnitude of the query vector does not influence the query result as long as the direction remains the same. Therefore, we make the assumption that 1≤i≤d wi = 1. In a d-dimensional space we define as query borderline the d -1 dimensional hyper-plane, which is vertical to vector w and contains the furthest data point, which belongs to the top-k result set. If we consider the 2-dimensional example depicted in Figure <ref type="figure" target="#fig_1">2</ref>  In the example of Figure <ref type="figure" target="#fig_1">2</ref>, a, i and n are the skyline points. Notice that i, which is the best match for the top-1 query with w = [0.5, 0.5], belongs to the skyline. Observation. The top-1 object for any increasingly monotone function belongs to the skyline set. Proof: Consider a point q that does not belong to the skyline, but it is the top-1 for a query defined by an increasingly monotone function f . Then there exists another point p that dominates q, i.e. on each dimension di ∈ D, p[i] ≤ q[i]; and on at least one dimension dj ∈ D, p[j] &lt; q[j], and since f is increasingly monotone this leads to a contradiction, because q is the top-1, i.e. f (p) &gt; f(q). Thus, the top-1 object for any increasingly monotone function belongs to the skyline.2</p><p>Motivated by the fact that the top-1 always belongs to the skyline for any monotone function, we use the skyline as a pre-processing step to answer top-k queries. In order to collect the points necessary to answer exact top-k queries, we adopt the concept of K-skyband <ref type="bibr" target="#b20">[20]</ref>. A K-skyband query returns the set of points which are dominated by at most K -1 other ones. Thus, the conventional skyline is a special instance of the K-skyband, where K = 1. In Figure <ref type="figure" target="#fig_1">2</ref>, the K-skyband for K = 3 includes all points that lie in the line-shadowed area. Notice that this area contains the top-3 points for any query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Routing Mechanism Construction Phase</head><p>In SPEERTO the super-peers are responsible for answering arbitrary top-k queries over their peers' data. This is enabled by a pre-processing phase where super-peers gather some carefully selected data from their peers. Thereafter, at query processing time, a super-peer can execute the query over its locally aggregated data and retrieve the fraction of the top-k query result that corresponds to its peers.</p><p>As discussed before, the result of top-k queries for any increasingly monotone function can be answered from the K-skyband (where k ≤ K). The K-skyband is a set of points, such that there exists no other point that can belong to the result of any top-k query for any increasingly monotone function. In our approach each peer computes its K-skyband during a construction phase. Each super-peer gathers K-skyband sets from its simple peers and merges the individual K-skyband sets by discarding points that are dominated by more than K -1 points. In this way a superpeer is capable to answer any incoming top-k query over its peers' data. The choice of the algorithm used by the peer for the K-skyband computation is indifferent to our framework, as it does not influence its performance. It should be stressed that even though the skyline operator is CPUintensive <ref type="bibr" target="#b7">[7]</ref> and therefore more costly than a top-k query, SPEERTO uses the skyline as a pre-processing step, i.e. its construction is a one-time cost, and then any top-k query with arbitrary k (k ≤ K) and scoring function can be processed (see <ref type="bibr">Section 5)</ref>.</p><p>Given the K-skyband at each super-peer, there exist two naive solutions to process global top-k queries. In the first, each super-peer broadcasts its K-skyband to all other superpeers, then each super-peer has enough data to answer any top-k (k ≤ K) query locally. The advantage is that the query is processed (at any super-peer) without contacting remote super-peers. However, this approach is not feasible in a highly distributed environment, because of the size of the skyband and the cost of distributing it to all the superpeers and keeping it updated.</p><p>The second naive approach is to flood each query to all super-peers to find the correct top-k result. The advantage of this approach is that the cost of distributing the skybands is avoided. However, flooding is costly, and although appropriate for distributing metadata needed for creating routing indices, it is too costly to employ for each individual query.</p><p>SPEERTO employs a more efficient approach than the naive approaches described above, that combines the advantages of the aforementioned approaches, while alleviating the disadvantages. SPEERTO broadcasts only some summary information of the K-skyband, namely the skyline set, and utilizes a threshold-based super-peer selection mechanism (see Section 5). Intuitively, the skyline is the border of the K-skyband with respect to the axes. Notice that the cardinality of the skyline is significantly smaller than the cardinality of the K-skyband.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Routing Indices, Updates and Churn</head><p>Routing indices at super-peer level are built during the construction phase, prior to query processing. A super-peer first assembles the K-skyband of its peers, then computes a new K-skyband over the assembled peer data, and finally it computes its skyline. The skyline information is broadcast to other super-peers and serves as routing index. Essentially, in this way, each super-peer receives and maintains the sky-line of other super-peers. Our approach for top-k queries in a P2P system gives correct and complete results under the assumption of a system with no churn and static data. In this section, we discuss about churn and dynamic data.</p><p>Data updates only infrequently change the skyline, and small changes in the skyline do not significantly change the accuracy of the top-k query processing (see <ref type="bibr">Section 7)</ref>. Therefore, it is not necessary to continuously maintain the skyline updated at remote super-peers, and periodic updates suffice. Obviously, high update rates can lead to time intervals where the results may not be accurate temporarily. The maintenance approach of remote skylines is based on broadcasting the skyline updates, when either the skyline has significantly changed or the validity time has expired. While skylines are used to select super-peers during top-k processing, the Kskyband on a super-peer is used to generate the actual results, and has to be more frequently updated. However, this cost is still less significant because a peer is relatively close to its super-peer in terms of network distance. In Section 6, we discuss an extension of SPEERTO which is more robust to updates.</p><p>Churn of super-peers is detected by lack of response during query processing. When this occurs, the skyline entry of the departed super-peer is removed at the querying super-peer. When a super-peer joins the network, its skyline is broadcast as described previously. Churn of simple peers is handled by recomputing the super-peer K-skyband, when a simple peer leaves or joins. In the case that the skyline of the super-peer is modified, the skyline has to be updated at all super-peers, in order to ensure accurate results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">P2P TOP-K QUERY PROCESSING</head><p>In this section, we introduce a threshold-based algorithm (Section 5.1) that answers arbitrary top-k queries by querying only the necessary super-peers. In the following, we also show that our threshold-based algorithm is optimal in terms of the number of contacted super-peers and the volume of transferred data (Section 5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Threshold-based Top-k Algorithm</head><p>Our distributed top-k algorithm assumes that there exists a construction phase, where each peer computes the Kskyband of its local data. Then, each super-peer gathers the K-skyband sets of all its associated peers. The K-skyband information is merged at each super-peer, resulting in a new K-skyband set, denoted as KSKYi, which is stored locally at the super-peer. Finally, each super-peer broadcasts to the other super-peers only some summary information of the K-skyband, namely the skyline set, sufficient for every super-peer to route any top-k query to those super-peers that can contribute to the final result. Each super-peer SPi assembles Nsp sets of skyline points SKYi, (1 ≤ i ≤ Nsp). These points are called routing objects.</p><p>Actually, the super-peers store the feature values of the objects that are stored on the peers. During query processing the super-peer retrieves the entire data object from the corresponding peer. Note that in contrast to routing objects that only contain the IP address of their super-peer, data objects may contain more information (and hence be much larger) than the routing objects<ref type="foot" target="#foot_1">2</ref> . During query processing data objects that probably belong to the query result set are also retrieved from peers indexed by other super-peers and transferred through these super-peers to the querying super-peer. For sake of simplicity, we refer to the points that belong to the K-skyband of a super-peer also as data objects, and ignore the fact that the actual data objects are transferred at query time from the peer to the super-peer. The communication cost between super-peer and peer is considered as less significant than the query propagation through the super-peer network because a peer is relatively close to its super-peer in terms of network distance. In case that the data objects do not contain more information than the feature values, there is no communication between super-peer and peer during query processing.</p><p>In the following, we describe our threshold-based top-k algorithm assuming that every super-peer SPi (1 ≤ i ≤ Nsp) stores the routing objects SKYi of all other super-peers (1 ≤ i ≤ Nsp) and the merged K-skyband set (KSKYi) of its associated peers only.</p><p>Let us first consider a two dimensional space as a showcase scenario as illustrated in Figure <ref type="figure" target="#fig_3">3</ref>. In the figure, we depict the routing and data objects stored at super-peer SPA. In more details, the skylines of two super-peers SPA and SPB are shown along with the routing objects from the other super-peers. For clarity reasons, we label only the routing objects of the two super-peers SPA and SPB that are actually involved in the top-k query of the example. Routing objects are depicted as black circles, while data objects are marked with crosses. The data objects are the points that belong to the KSKYA, i.e. the aggregated K-skyband set of super-peer SPA. Therefore, Figure <ref type="figure" target="#fig_3">3</ref> depicts the information that is available to super-peer SPA when query processing starts. As described in more detail below, during query processing more data objects are transferred to the querying super-peer SPA through the neighboring super-peers.</p><p>In a two dimensional space, progressive processing a topk query given an arbitrary weighting is similar to sweeping the query borderline, with specific slope defined by the query weights, through space from the axes toward the data. The first data point that the line meets is the top-1, the second the top-2, etc. until it finds top-k data points. Actually, each time the line meets a data point, this point can be immediately returned to the user, as it is really the next top object of the query (progressive property of our algorithm). Note that some of the points that the borderline meets are routing objects. In this case the routing object must be Algorithm 1 Query processing on super-peer SPQ 1: </p><formula xml:id="formula_2">Input: Query q k (f ) 2: list = {∅} 3: list = SPQ.query∪SKY i (q k (f )) 4: threshold = f (list[k]) 5: c =</formula><formula xml:id="formula_3">threshold = f (list[k -c]) 18:</formula><p>end while replaced by some data points of the super-peer to which the routing object belongs to. At each step the query borderline is an indication of how far we have examined the data space and it guarantees that there does not exist any other point in the examined space that has not been retrieved yet. This guarantees that there is no data point that has a smaller scoring value than the retrieved points.</p><p>A threshold value is defined as the score of the k-th routing or data object encountered so far. In the 2-d space, this defines a threshold line that gradually sweeps the space towards the axes origin. The region defined between the query and the threshold borderline is called active region and it contains at least (kc) objects, where c is the number of data points that is already returned to the user. In each step, the active region contains all objects that may appear in the final result set. Notice that the querying super-peer is not aware of all data points that fall in the active region, therefore if a routing object is retrieved, the query must be broadcast to the corresponding super-peer.</p><p>Continuing the example depicted in Figure <ref type="figure" target="#fig_3">3</ref>, consider a linear top-4 query with weights w = (0.5, 0.5). Let us further assume that the query is posed at super-peer SPA. The top-4 objects (i, a, h and z) based on the data and routing objects stored on SPA are retrieved, and the score of the 4th object (z), defines the threshold borderline. This guarantees that the results of this top-k query are found in the active region. Notice that some data points of SPB may fall in the active region and therefore point z may not belong to the top-4 result set. First, the routing object i is examined and since it belongs to SPA the data object i is retrieved and returned to the user. In the next step, point a is retrieved and returned as the top-2 point. Afterwards, we retrieve the routing object h that belongs to SPB. Therefore, superpeer SPB is queried and assuming that no other data point of SPB falls in the active region, points h and z are returned to the user.</p><p>Algorithm 1 describes how P2P top-k query processing is performed. The routing and data objects retrieved thus far are kept in a sorted list based on the scoring value. This list is initialized by the querying super-peer (SPQ) with the topk objects of the skyline results ∪SKYi. We use as threshold the scoring value of the k-th object, as any other object with higher score cannot belong to the final result set. In each iteration the top object of the list is examined. Then a topk query is broadcast to the super-peer (SP ) responsible for this object. After SP 's data objects are retrieved by SPQ, all routing objects of SP are removed from the sorted list before inserting its data objects, since they are no longer necessary to maintain. Then, the threshold is updated with the scoring value of the k-th object in the list. In each subsequent iteration, if a data object is retrieved, it is returned to the user as the top-1, top-2, etc. result. Otherwise, if a routing object is retrieved, a top-(kc) query is send to the corresponding super-peer along with the current threshold value (c denotes the number of results returned thus far to the user). The super-peer sends back kc objects, or less if there are not kc objects with value below the threshold.</p><p>The algorithm terminates when k data objects have been retrieved from the sorted list.</p><p>Example: Consider a small super-peer network consisting of four super-peers SPA, ... SPD, and a querying super-peer SPQ = SPA that has assembled the skylines (routing objects) of the other super-peers, as depicted in Figure <ref type="figure" target="#fig_4">4</ref>. Let us assume that SPA needs to answer a top-3 query with a linear aggregate function that assigns equal weights to both dimensions. On the right side of the figure, the skyband information maintained on each super-peer is depicted in tables. The grey-shadowed objects are the skyline objects that are broadcast to other super-peers and they are also depicted on the left part of the figure graphically. According to Algorithm 1, the sorted list is initialized with routing objects: i(3,2), m(6,0.5) and h(4,3) and threshold is set to 3.5. The first object that is processed is object i(3,2) that belongs to super-peer SPB. Thus SPA sends a top-3 query to SPB, and retrieves its local (at SPB) top-3 results. These data objects are i(3,2), (4,2.5) and then for the third ranked object there are actually three objects with the same aggregate score o(9,1), a(1,9) and (7,3). These three data objects are not returned to SPA since they are discarded by the threshold value. So, only two points are returned to SPA by SPB and they are merged with the objects already existing in the list. The threshold value is set to 3.25, as the new k-th object (4,2.5) has a lower score value than the old threshold value. Then i(3,2) is returned to the user as top-1. Therefore the list becomes of size 2 and it contains: m(6,0.5), (4,2.5).</p><p>Next m is processed and as it belongs to SPC , SPA sends a message to SPC requesting its top-2 objects. SPC returns m(6,0.5), while f (2,6) is pruned by the threshold. Thereafter, m is returned to the user and the list contains only one object (4,2.5). This object is processed next, and since it is a data object, it is returned to the user immediately as the top-3. Finally, the algorithm terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Correctness and Optimality</head><p>The usage of the threshold ensures that SPEERTO progressively returns accurate and exact answers for any top-k (k ≤ K) query. Moreover, it reduces communication costs by preventing unnecessary data objects from being transferred in the network during query processing. SPEERTO also avoids querying super-peers that do not contribute to the result set. In the following we assume that the query is answered using a snapshot of the P2P network, i.e. static network and contents, and we show the correctness of our algorithm and the optimality in terms of queried super-peers and transferred data. Correctness of the algorithm: After k data objects have been examined, an object that has not been seen cannot be in the top-k result set. Observation 1 ensures that for every super-peer SP and for any increasingly monotone function the best match for SP is a routing object that exists on SPQ. The objects are kept sorted by the scoring function of the query, thus, if the next object is a data object o this means that there is no super-peer for which its best match has a better score than o. Otherwise, if the next object is a routing object, the corresponding super-peer is queried. Therefore, all super-peers that may contribute to the result set are queried. Finally, the objects that are discarded due to the threshold cannot belong to the result set since there exist at least k objects with a better score. So, our algorithm does not suffer by false negatives or positives. Minimized number of queried super-peers: A superpeer SP is queried only if a routing object o is the next best match in the sorted list. Since all points with a smaller scoring value have been examined previously, the routing object o corresponds to the next best match. So, there is at least one point of SP that contributes to the top-k result set, namely o, and thus avoiding to query SP would lead to a wrong result set. Minimized transferred data during query processing: Let o be an object that has a score smaller than the threshold and can be discarded without violating the accuracy of our algorithm. Since the threshold is larger than the score of o, there are less than k objects in the sorted list with a smaller score. If all objects in the sorted list that have a smaller score than object o are data objects, then o belongs to the top-k result set. This leads to a contradiction, since the accuracy of the algorithm is violated. Therefore any object with smaller value than the threshold cannot be discarded, and our algorithm transfers the minimum number of data objects during query processing.</p><p>To summarize the benefit of the proposed threshold-based algorithm is threefold: a) results can be returned progressively to the user, b) communication costs are reduced, by defining a threshold value, which prevents unnecessary data objects to be transferred in the network during query processing, and c) the number of contacted super-peers is minimized during query processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXTENSIONS OF SPEERTO</head><p>In this section we study some extensions of the SPEERTO framework. By relaxing SPEERTO's optimality in terms of number of queried super-peers and transferred objects, we manage to a) decrease the response time and b) decrease storage and -more importantly -maintenance costs due to updates. In order to reduce the response time, we propose a variant of SPEERTO that queries in parallel more than one super-peer (Section 6.1). Thereafter, we propose an extension that restricts the cardinality of the skyline (Section 6.2) aiming to reduce the construction and maintenance costs of the SPEERTO framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Parallel Query Processing</head><p>In each iteration, Algorithm 1 examines the first object in the sorted list and queries the corresponding super-peer. A straightforward extension of this approach is to query more than one super-peers in each iteration simultaneously, using the current threshold. In the original algorithm, by querying each super-peer and then adjusting (when possible) the threshold, the query is sent to the next super-peer, only after the previous one has returned its results. In the parallel variant, the querying part is non blocking, therefore the total response time is reduced. On the other hand we cannot guarantee the optimality of the amount of transferred data, since some super-peers are queried using a higher threshold, than in the case of refining the threshold after each superpeer was queried. Moreover, some super-peers that do not contribute to the final result set may be queried, while they could have been discarded by data objects retrieved by previously queried super-peers.</p><p>The remaining question is how many super-peers should be queried in each iteration. The most simple way is to have a fixed number, according to the querying super-peer's SPQ traffic/workload and maximum number of open connections that can be established. However this approach adapts neither to the number of queried objects k, nor to the number of objects that have already been retrieved. Therefore, it is more effective to dynamically estimate the number of necessary super-peers to be queried, in order to retrieve the top-k objects. Each super-peer may employ its own heuristic based on statistics. In the following, we present a simple strategy that does not rely on any statistic or on previous queries.</p><p>The parallel variant works in the following way. Initially, one super-peer is queried using q k (f ). All Nr retrieved objects have a score less than the current threshold t and higher than the score of the first retrieved object o1, i.e. score(o1). So we estimate the mean score from this super-peer as:</p><formula xml:id="formula_4">m = t-score(o 1 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Nr</head><p>. The next object (o2) in the list is examined and if it is a routing object we estimate the number of objects that will be retrieved:</p><formula xml:id="formula_5">Nr2 = score(o 2 )-score(o 1 ) m .</formula><p>Then the next object is examined. If it is a data object, the super-peers that are found so far, are queried. If it is a routing object (o3), we estimate again the number of objects Nr3 = score(o 3 )-score(o 2 ) m that will be retrieved. This continues until either a data object is found, or so many routing objects have been examined that the estimated number of objects (Nr2 + Nr3) is more than the (kc) remaining objects to be retrieved. After the super-peers found so far are queried, each returns Nr2 and Nr3 objects respectively and a new mean score is computed for each one, i.e. </p><formula xml:id="formula_6">m2 = t-score(o 2 ) N r2 and m3 = t-score(o 3 ) N r3</formula><p>. Then, we compute a new threshold t and the new overall mean score m that is used instead of m as: m = m+m 2 +m 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head><p>. The algorithm continues until k data objects are returned to the user. It should be stressed that our approach does not require global statistics and it has no additional communication or maintenance cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Reducing the Skyline Cardinality</head><p>One of the major drawbacks of the skyline operator is the high cardinality |SKY | of the result set <ref type="bibr" target="#b7">[7]</ref>, especially for high-dimensional or anti-correlated datasets. In our framework this would lead to high construction and maintenance cost and storage requirements at super-peers. Moreover, local query processing at each super-peer becomes more expensive for higher numbers of routing objects. Given an upper limit U , in this section we study how to abstract the skyline aSKY with at most U points (U &lt; |SKY |). This abstraction has the following properties: a) each point p ∈ SKY is either dominated by or equal to at least one point q ∈ aSKY b) |aSKY | ≤ U &lt; |SKY |, and c) it only slightly influences the routing power of the skyline, i.e. move the query borderline as little as possible. Obviously, the abstraction is not unique.</p><p>The problem is to find an approximation of the skyline of fixed size to distribute to all super-peers as a routing mechanism. The resulting trade-off is between skyline size and the accuracy of the approximation (leading to more contacted super-peers and more transferred data). Consider for example the dataset depicted on Figure <ref type="figure" target="#fig_5">5</ref>, where the points q, p, m, k are the skyline points. Given a upper limit U = 3 for the skyline abstraction, let us assume that we decide to replace the points q, p with one point r. SPEERTO selects the super-peers that are contacted during query processing based on the skyline points. In order not to violate the accuracy of SPEERTO, the abstraction of SPEERTO must ensure that whenever a super-peer should be contacted based on the skyline points, the super-peer will also be contacted based on the abstraction. Let us assume that Figure <ref type="figure" target="#fig_5">5</ref> depicts the skyline points of one super-peer SPA, then for any query the query borderline meets point r before points p and q. On the other hand, if a skyline point of another super-peer falls in the dashed area (triangle) then based on the abstract skyline we contact super-peer SPA, while based on the real skyline points we could avoid contacting SPA. Therefore, the abstraction causes an increase in the number Algorithm 2 Skyline abstraction on super-peer SPi 1:</p><formula xml:id="formula_7">Input: SKYi 2: p = argmax ∀t∈SKY i ( 1≤i≤d ln (t[i] + 1)) 3: min dist = ∞ 4: for ((∀t ∈ SKYi) and (p = t)) do 5: dist = min 1≤i≤d (|p[i] -t[i]|) 6: if (dist ≤ min dist) then 7: min dist = dist 8: q = t 9:</formula><p>end if 10: end for 11:</p><formula xml:id="formula_8">for (1 ≤ i ≤ d) do 12: r[i] = min(p[i]</formula><p>, q[i]) 13: end for of contacted super-peers. In general, the larger the shadowed area in Figure <ref type="figure" target="#fig_5">5</ref>, the higher the probability of querying more super-peers.</p><p>A benefit of the abstract skyline is that our approach becomes more robust to updates. SPEERTO can guarantee accurate query answers in the case of updates, if the routing objects of the respective skyline do not change. Otherwise, the new routing objects have to be broadcast to all superpeers. The abstract skyline is a lower bound of the skyline and is less likely to change than the original skyline. In the case of high churn rate and/or updates, the abstract skyline may be appropriate, in order to reduce the maintenance cost of routing indices and shorten the time intervals where we cannot provide exact query results. A shortcoming of the abstract skyline is that we can not use the threshold any more, since we are no longer certain that at least k objects exist in the query space.</p><p>We now present a heuristic for calculating the abstract skyline. Intuitively, each time we pick pairs of skyline points p, q that can be replaced by a new point r, until we have at most U points. Algorithm 2 describes the procedure of choosing two points and replacing them with one new point. Inspired by SFS <ref type="bibr" target="#b10">[10]</ref>, we choose the skyline point p with the largest entropy value E(p) = 1≤i≤d ln (p[i] + 1), because the smaller the entropy value the less likely p is to be dominated by other points. This insinuates that a point with lower entropy value has a stronger dominance power and therefore is considered as more important. Thereafter, we have to determine a suitable point q to merge with the selected point. For each dimension di we find the skyline point that has the smallest distance from p. We choose the point q that has the smallest distance in any dimension. Then p and q are replaced by point r, defined by the minimum values of p and q on all dimensions. Thereafter, all skyline points dominated by r are removed. Notice that r indeed dominates other skyline points for higher than two-dimensional spaces. This process iterates and terminates when U &lt; |SKY |.</p><p>As an example, consider again the dataset depicted on Figure <ref type="figure" target="#fig_5">5</ref>. Let us assume that point p has the largest entropy value and that point q is the nearest point based on the distance for any dimension. Then according to Algorithm 2 the two skyline points p and q are replaced with point r. This replacement does not affect the correctness of SPEERTO, since the query borderline for any query meets point r before points p and q. Therefore, the query is routed to the corresponding super-peer and the accurate top-k result set is retrieved. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTAL EVALUATION</head><p>We studied the performance of our framework using simulations. The simulator was implemented in Java<ref type="foot" target="#foot_2">3</ref> and it run on 3.8GHz Athlon Dual Core AMD processors with 2GB RAM. In order to test the algorithms with realistic network sizes, we ran multiple instances of the peers on the same machine and simulated the network interconnection.</p><p>The P2P network topology used in the experiments consists of Nsp interconnected super-peers in a random graph topology. In our experiments we vary the network size (Np) from 2000 to 20000 peers. We used synthetic (uniform and clustered) data collections. The dataset is horizontally partitioned evenly among peers. The uniform dataset includes random points in a space [0, L] d . For the clustered dataset, each super-peer picks cluster centroids randomly and all associated peers obtain points, the coordinates of which follow a Gaussian distribution on each axis with variance 0.025, and a mean equal to the corresponding coordinate of the centroid. We conduct experiments varying the dimensionality (2-10) and the cardinality (1M-2.5M) of the dataset. Each time we generate 20 queries with random weightings.</p><p>For all queries, we measure the average: (i) total response time (including network delay), (ii) response time for the k first results, (iii) number of contacted super-peers, (iv) volume of transferred data, and (v) number of transferred objects. Unless mentioned explicitly, we use the following default values: d = 4, K = 50, 10 ≤ k ≤ 50, n = 10 6 , Np = 2000, while Nsp = 10% × Np, and the dataset is uniform. We also assume 50KB/sec as network transfer bandwidth on connections between super-peers. The response time is measured as the sum of processing time and network transfer time required for the objects transferred in the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Performance of SPEERTO</head><p>We first examine the efficiency of SPEERTO on a network of Np = 2000 peers, while we increase the dimensionality from d = 2 to d = 10. We set K = 50 and thus we can answer exactly any top-k query with k ≤ 50. We obtain similar results for Np = 6000, omitted due to space constraints.</p><p>The cost of skyline exchange is considered for uniform and clustered data. In Figure <ref type="figure" target="#fig_6">6</ref>, the volume of transferred data per super-peer is depicted for varying dimensionality d. For the highest value d = 10, each super-peer induces on average 147MB of data in the network for the uniform dataset. The clustered dataset induces a slightly higher volume.</p><p>In Figure <ref type="figure" target="#fig_8">7</ref>, the performance of SPEERTO is studied, in terms of volume of transferred objects, overall response time, and response time for the first k objects. First we examine the performance on uniformly distributed data and increase the dimensionality from d = 2 to 10, and we study top-10 to top-50 queries, assuming K = 50. In Figure <ref type="figure" target="#fig_8">7</ref>(a), the response time is presented for different values of k. The plot illustrates the total response time taking into account the network delay, which depends on the size of transmitted data. We depict the results measured for uniform dataset with varying dimensionality. As expected the response time increases with the dimensionality. The increasing time with d is due to the fact that a) the size of transferred objects increases, and b) the processing time is higher, since the K-skyband and the skyline size increases with d as well. The cardinality of the K-skyband and the skyline influences the processing time of our threshold algorithm, which is executed on the objects stored on the querying superpeer. Thereafter we focus on the progressive property of SPEERTO, shown in Figure <ref type="figure" target="#fig_8">7</ref>(b). The chart shows the response time for the first 10 results, for varying dimensionality. Notice that the first results are returned to the user immediately.</p><p>Figure <ref type="figure" target="#fig_8">7</ref>(c) shows the number of contacted super-peers during top-k query processing. The number of contacted super-peers increases slightly with the dimensionality. Mainly the number of contacted super-peers depends on the number of objects k that are retrieved. For example if k = 50 objects are retrieved, more than 40 out of 200 super-peers are contacted. Since the dataset is uniformly distributed among the peers and therefore also among the super-peers, we can not avoid to contact all super-peers that contribute to the query result set.</p><p>In the following charts we study the effectiveness of the proposed threshold-based algorithm. The next two charts (7(d) and 7(e)) show the gain of threshold usage in SPEERTO. Figure <ref type="figure" target="#fig_8">7(d)</ref> shows the improvement factor in terms of number of transferred objects, when threshold is used. The gain is very high, for example for d = 6 and top-k=50, only 50 objects are transferred, while without the threshold 1097 additional objects would have been transferred, i.e., the improvement factor is 21.9. Even though the gain in terms of number of transferred objects seems not to increase with the dimensionality, the benefit in terms of volume is higher, since the volume of the objects increases as the dimensionality increases. Figure <ref type="figure" target="#fig_8">7</ref>(e) shows the percentage of super-peers that actually prune some objects that would otherwise be returned to the querying super-peer. In general, 90% of the queried super-peers manage to discard some objects, instead of returning them to the querying super-peer, due to the threshold.</p><p>In the next series of experiments we examine the proposed method's scaling features regarding data cardinality. Figure <ref type="figure" target="#fig_8">7</ref>(f) depicts the response time while varying the cardinality of the dataset from n = 1M to n = 2.5M. The slightly increasing response time with cardinality n is mainly due to higher processing times caused by the increase of the K-skyband and the skyline size. The number of contacted super-peers and transferred data are not influenced by the cardinality of the dataset.</p><p>We also study the scalability of SPEERTO with respect to the network size (Figure <ref type="figure" target="#fig_8">7</ref>(g)). The network size Np does not affect the overall response time, as the number of queried  super-peers (Figure <ref type="figure" target="#fig_8">7</ref>(h)) remains practically the same for a given top-k query. In the next experiment, we study the performance on clustered data. Figure <ref type="figure" target="#fig_8">7</ref>(i) depicts the response time for clustered data distribution while varying the dimensionality of the dataset. The clustered dataset leads to much smaller response time than the uniform distribution, because only a few super-peers are contacted during query processing. Therefore, SPEERTO performs better for the clustered dataset in terms of response time, contacted super-peers, and transferred data objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Top-k Queries with k &gt; K</head><p>In the next experiments we evaluate the effectiveness of SPEERTO for top-k queries with k &gt; K. We compare the actual top-k results with the ones retrieved from the Kskyband, by measuring the relative recall, i.e., the fraction of the produced top-k results that are in the true top-k results.</p><p>In Figure <ref type="figure" target="#fig_9">8</ref>(a), we show the recall achieved for uniform distribution and cardinality 0.5M, while varying d from 2 to 4. The K parameter of the skyband is set to 10, which ensures us the exact results at least for any top-10 query. We evaluate the performance of our approach for 10 ≤ k ≤ 200. As expected recall decreases as k increases, but notice that the errors in the top-k list occur in the lower positioned objects, which are less important to the user. The skyband size is manageable and less than 1% of the dataset in any case. For d = 2 the skyband contains less than 100 points, thus recall decreases rapidly. For d = 4 the skyband size grows to less than 3500 data objects, and recall decreases less rapidly. In Figure <ref type="figure" target="#fig_9">8</ref>(e) we vary K between 1 and 100 and evaluate the recall on top-100 queries for different dimensionality values. For K = 1 (which is the skyline set) we achieve recall of more than 90% for dimensionality 6 and 8, while the size </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">SPEERTO Extensions</head><p>We also evaluate the merits of the SPEERTO extensions proposed. In Figure <ref type="figure">9</ref>, we provide a comparative chart of the parallel version (PAR) of our algorithm compared to the original one. The results show a reduction in response time when the parallel variant is employed. The chart depicts the improvement percentage of our parallel approach for uniform datasets of different dimensionality. In average, the gain in response time is more than 20%, while the number of transferred objects is only marginally increased.</p><p>Finally, we evaluate the performance of the abstract skyline variant. In Figure <ref type="figure" target="#fig_12">10</ref>(a), we depict the increase of the number of transferred objects when the abstract skyline vari-ant is used. In this experiment we use uniform datasets of different dimensionality. The number of transferred objects increases rapidly, since the threshold is not used. The abstract skyline variant transfers up to 30% more data objects. In Figures <ref type="figure" target="#fig_12">10(b</ref>) and 10(c), the gain of the abstraction in the case of data additions is depicted, for data dimensionality d = 2 and d = 3. The x-axis depicts the percentage of points added to the dataset, while the y-axis depicts the number of super-peers that have to update their skyline set. For example when d = 2 and 2% of the dataset is added, by keeping the 50% of the skyline points, only 4% of the super-peers need to update their skyline. In Figure <ref type="figure" target="#fig_12">10</ref>(c), we notice that for d = 3 the number of modified super-peers increases, but again the gain of abstraction is significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>In this paper we presented SPEERTO, a novel approach for answering top-k queries in a P2P network. Relying on a super-peer architecture, we proposed a threshold-based algorithm which forwards the top-k query requests among super-peers, in such a way that the amount of transferred data is minimized. For a maximum value of K, SPEERTO returns the correct answers for any top-k query (k ≤ K), while supporting a large class of scoring functions. We proposed a variant of SPEERTO that queries in parallel more than one super-peers and an extension that restricts the cardinality of the skyline. We provided an extensive experimental evaluation showing that SPEERTO performs efficiently and provides a viable solution when a large degree of distribution is required. In addition, we studied experimentally the recall of top-k queries with k &gt; K and showed that we provide almost accurate results even for small K values.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Feature space</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Skyline, K-skyband, and top-k</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>the point i is the top-1 object for the query 0.5 * x + 0.5 * y. The line 0.5 * x + 0.5 * y = f (i) = 2.5 is considered as the borderline for the top-1 query with w = [0.5, 0.5]. In the following we define the skyline set and discuss its relation to top-k queries. Skyline Definition. Assuming a space D defined by d dimensions {d1, d2, .., d d } and given a set of points O, a point p ∈ O with p = {p[1], ..., p[d]} is said to dominate another point q ∈ O, if on each dimension di ∈ D, p[i] ≤ q[i]; and on at least one dimension dj ∈ D, p[j] &lt; q[j]. The skyline is a set of points SKY ⊆ O which are not dominated by any other point. The points in SKY are called skyline points.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example of query borderline</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Example of top-k algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Abstract skyline</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Construction cost</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Performance of SPEERTO (Nsp = 200, Np = 2000, K = 50)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 (</head><label>8</label><figDesc>a) shows that using the 10-skyband we can answer top-100 queries with recall around 40% for d = 2, while for d = 4 we can answer queries for higher k values with better recall. Experiments on clustered datasets resulted in similar recall values (Figure8(b)). By varying the cardinality we noticed that recall (Figure8(c)) and the skyband size (Figure8(d)) are hardly influenced, which makes our approach feasible for large-scale systems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: Top-k queries with k &gt; K</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Data updates for d = 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Abstract skyline extension of SPEERTO</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Overview of symbols</head><label>1</label><figDesc>We assume that the features sj are numerical scoring functions with non-negative values that evaluate certain features of database objects. For example, sj can be extracted characteristics, aggregations of attribute values,</figDesc><table><row><cell cols="2">Symbols Description</cell></row><row><cell>d</cell><cell>Data dimensionality</cell></row><row><cell>n</cell><cell>Dataset cardinality</cell></row><row><cell>K</cell><cell>The maximum number of k</cell></row><row><cell>Np</cell><cell>Number of peers</cell></row><row><cell>Nsp</cell><cell>Number of super-peers</cell></row><row><cell>DEGp</cell><cell>Degree of simple peer</cell></row><row><cell>DEGsp</cell><cell>Degree of super-peer</cell></row><row><cell>SKYi</cell><cell>Skyline set of the i th super-peer</cell></row><row><cell>KSKYi</cell><cell>K-skyband set of the i th super-peer</cell></row><row><cell cols="2">or scoring functions for low-level features [3]. Furthermore,</cell></row><row><cell cols="2">without loss of generality, we assume that smaller score val-</cell></row><row><cell cols="2">ues are preferable.</cell></row></table><note><p><p>Given a data collection</p>O of n objects oi (1 ≤ i ≤ n), we assume d features sj(oi) (1 ≤ j ≤ d) that describe an object oi ∈ O.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Skyline-based Peer-to-Peer Top-k Query Processing. SPEERTO is inspired by a Greek word (spirto) that means fire match, but also used to characterize a very intelligent person.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>An example is a data object that is an image, the routing object can in this case be just descriptive features.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Our implementation uses the XXL library available at: http://www.xxl-library.de</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Reducing network traffic in unstructured P2P systems using top-k queries. Distributed and Parallel Databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Akbarinia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pacitti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="67" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Best position algorithms for top-k queries</title>
		<author>
			<persName><forename type="first">R</forename><surname>Akbarinia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pacitti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Int. Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>Int. Conf. on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="495" to="506" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multi-objective query processing for database systems</title>
		<author>
			<persName><forename type="first">W.-T</forename><surname>Balke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Güntzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Int. Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>Int. Conf. on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="936" to="947" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Progressive distributed top-k retrieval in peer-to-peer networks</title>
		<author>
			<persName><forename type="first">W.-T</forename><surname>Balke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nejdl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Siberski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Thaden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Int. Conf. on Data Engineering (ICDE)</title>
		<meeting>IEEE Int. Conf. on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="174" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The skyline operator</title>
		<author>
			<persName><forename type="first">S</forename><surname>Börzsönyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Stocker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Int. Conf. on Data Engineering (ICDE)</title>
		<meeting>IEEE Int. Conf. on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="421" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient top-k query calculation in distributed networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Annual ACM Symposium on Principles of Distributed Computing (PODC)</title>
		<meeting>Annual ACM Symposium on Principles of Distributed Computing (PODC)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="206" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Robust cardinality and cost estimation for skyline operator</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">N</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Int. Conf. on Data Engineering (ICDE)</title>
		<meeting>IEEE Int. Conf. on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">64</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Evaluating top-k selection queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Int. Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>Int. Conf. on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="397" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optimizing top-k selection queries over multimedia repositories</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="992" to="1009" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Skyline with presorting</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gryz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Int. Conf. on Data Engineering (ICDE)</title>
		<meeting>Int. Conf. on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="717" to="719" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal aggregation algorithms for middleware</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Symposium on Principles of Database Systems (PODS)</title>
		<meeting>Symposium on Principles of Database Systems (PODS)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="102" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimizing multi-feature queries for image databases</title>
		<author>
			<persName><forename type="first">U</forename><surname>Güntzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-T</forename><surname>Balke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kießling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Int. Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>Int. Conf. on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="419" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Processing top-N queries in P2P-based web integration systems with probabilistic guarantees</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karnstedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Workshop on Web and Databases (WebDB)</title>
		<meeting>International Workshop on Web and Databases (WebDB)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="109" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">PREFER: A system for the efficient execution of multi-parametric ranked queries</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Int. Conf. on Management of Data (SIGMOD)</title>
		<meeting>ACM Int. Conf. on Management of Data (SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="259" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Merging retrieval results in hierarchical peer-to-peer networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Callan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Int. Conf. on Research and Development in Information Retrieval (SIGIR)</title>
		<meeting>the ACM Int. Conf. on Research and Development in Information Retrieval (SIGIR)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="472" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Federated search of text-based digital libraries in hierarchical peer-to-peer networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Callan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on IR Research (ECIR)</title>
		<meeting>European Conference on IR Research (ECIR)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="52" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Evaluating top-k queries over web-accessible databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="319" to="362" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">KLEE: a framework for distributed top-k query algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Triantafillou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Int. Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>Int. Conf. on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="637" to="648" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Continuous monitoring of top-k queries over sliding windows</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mouratidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bakiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Int. Conf. on Management of Data (SIGMOD)</title>
		<meeting>ACM Int. Conf. on Management of Data (SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="635" to="646" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Progressive skyline computation in database systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="82" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Ranked join indices</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tsaparas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Palpanas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Int. Conf. on Data Engineering (ICDE)</title>
		<meeting>IEEE Int. Conf. on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="277" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient top-k processing in large-scaled distributed environments</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data and Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="315" to="335" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
