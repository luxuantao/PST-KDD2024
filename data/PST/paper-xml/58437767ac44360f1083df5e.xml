<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Statistical Deobfuscation of Android Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Benjamin</forename><surname>Bichsel</surname></persName>
							<email>bichselb@student.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">ETH Zurich</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Veselin</forename><surname>Raychev</surname></persName>
							<email>veselin.raychev@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">ETH Zurich</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Petar</forename><surname>Tsankov</surname></persName>
							<email>ptsankov@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">ETH Zurich</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Martin</forename><surname>Vechev</surname></persName>
							<email>martin.vechev@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">ETH Zurich</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Statistical Deobfuscation of Android Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EB0CA8F9CF97A335FC153E45EA404113</idno>
					<idno type="DOI">10.1145/2976749.2978422</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work presents a new approach for deobfuscating Android APKs based on probabilistic learning of large code bases (termed "Big Code"). The key idea is to learn a probabilistic model over thousands of non-obfuscated Android applications and to use this probabilistic model to deobfuscate new, unseen Android APKs. The concrete focus of the paper is on reversing layout obfuscation, a popular transformation which renames key program elements such as classes, packages and methods, thus making it difficult to understand what the program does.</p><p>Concretely, the paper: (i) phrases the layout deobfuscation problem of Android APKs as structured prediction in a probabilistic graphical model, (ii) instantiates this model with a rich set of features and constraints that capture the Android setting, ensuring both semantic equivalence and high prediction accuracy, and (iii) shows how to leverage powerful inference and learning algorithms to achieve overall precision and scalability of the probabilistic predictions.</p><p>We implemented our approach in a tool called DeGuard and used it to: (i) reverse the layout obfuscation performed by the popular ProGuard system on benign, open-source applications, (ii) predict third-party libraries imported by benign APKs (also obfuscated by ProGuard), and (iii) rename obfuscated program elements of Android malware. The experimental results indicate that DeGuard is practically effective: it recovers 79.1% of the program element names obfuscated with ProGuard, it predicts third-party libraries with accuracy of 91.3%, and it reveals string decoders and classes that handle sensitive data in Android malware.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>This paper presents a new approach for deobfuscating Android applications based on probabilistic models. Our approach uses large amounts of existing Android programs available in public repositories (referred to as "Big Code") to learn a powerful probabilistic model which captures key features of non-obfuscated Android programs. It then uses Focus: Layout Deobfuscation.</p><p>The focus of this paper is on reversing layout obfuscation of Android APKs. While general obfuscation can include other transformations (e.g., changes to the program's data representation or control-flow <ref type="bibr" target="#b23">[25]</ref>), layout obfuscation remains a key part of virtually all obfuscation tools. In layout obfuscation, the names of program elements that carry key semantic information are replaced with other (short) identifiers with no semantic meaning. Examples of such elements are comments, variable, method and class names. Renaming these program elements makes it much harder for humans to read and understand what the program does and is useful in a variety of security scenarios including protection of intellectual property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benefits and Challenges.</head><p>Among others, reversing layout obfuscation for Android APKs has various benefits including: (i) it makes it easier for security analysts to inspect Android applications obfuscated with ProGuard, (ii) it identifies third-party libraries embedded in Android APKs, and (iii) it enables one to automatically search for certain identifiers in the code.</p><p>However, reversing layout obfuscation is a hard problem. The reason is that once the original names are removed from the application and replaced with short meaningless identifiers, there is little hope in recovering the original names by simply inspecting the application alone, in isolation.</p><p>Probabilistic Learning from "Big Code".</p><p>To address challenges that are difficult to solve by considering the program in isolation, the last couple of years have seen an emerging interest in new kinds of statistical tools which learn probabilistic models from "Big Code" and then use these models to provide likely solutions to tasks that are difficult to solve otherwise. Examples of such tasks include machine translation between programming languages <ref type="bibr" target="#b16">[18]</ref>, statistical code synthesis <ref type="bibr" target="#b30">[32,</ref><ref type="bibr" target="#b28">30]</ref>, and predicting names and types in source code <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b7">9]</ref>. Interestingly, due to their unique capabilities, some of these probabilistic systems have quickly become popular in the developer community <ref type="bibr" target="#b29">[31]</ref>.</p><p>This Work: Android Deobfuscation via "Big Code".</p><p>Motivated by these advances, we present a new approach for reversing Android layout obfuscation by learning from thousands of readily available, non-obfuscated Android applications. Technically, our approach works by phrasing the problem of predicting identifier names (e.g., class names, method names, etc.) renamed by layout obfuscation as structured prediction with probabilistic graphical models. In particular, we leverage Conditional Random Fields (CRFs) <ref type="bibr" target="#b21">[23]</ref>, a powerful model widely used in various areas including computer vision and natural language processing. To our knowledge, this is the first time probabilistic graphical models learned from "Big Code" have been applied to address a core security challenge. Using our approach we present a tool called DeGuard, and show that it can automatically reverse layout obfuscation of Android APKs as performed by ProGuard with high precision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Main Contributions.</head><p>The main contributions of this paper are:</p><p>• A structured prediction approach for performing probabilistic layout deobfuscation of Android APKs.</p><p>• A set of features and constraints cleanly capturing key parts of Android applications. Combined, these ensure our probabilistic predictions result in high precision and preserve application's semantics.</p><p>• A complete implementation of our approach in a scalable probabilistic system called DeGuard 1 .</p><p>• An evaluation of DeGuard on open-source Android applications obfuscated by ProGuard and Android malware samples. Our results show that DeGuard is practically effective: it correctly predicts 79.1% of the program elements obfuscated by ProGuard, it identifies 91.3% of the imported third-party libraries, and reveals relevant string decoders and classes in malware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">OVERVIEW</head><p>In this section we provide an informal overview of our statistical deobfuscation approach for Android. First, we discuss ProGuard, which is the most widely used tool for obfuscating Android applications. We then present the key steps of our DeGuard system. The purpose here is to provide an intuitive understanding of the approach. Full formal details are presented in the later sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">ProGuard</head><p>ProGuard obfuscates program elements including names of fields, methods, classes, and packages, by replacing them with semantically obscure names. It also removes unused classes, fields, and methods to minimize the size of the resulting Android application package (APK) released to users. ProGuard processes both the application and all third-party libraries that the application imports (e.g., advertising and analytics libraries). All third-party libraries imported by the application are therefore concealed in the released APK.</p><p>ProGuard cannot obfuscate all program elements as that would change the application's semantics. For example, the names of methods part of the Android API and the names of classes referenced in static files, are kept intact. 1 http://apk-deguard.com</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example.</head><p>Figure <ref type="figure">1</ref>(a) shows a fragment of an Android application that has been obfuscated with ProGuard (the obfuscated program elements are highlighted with red). The depicted code fragment can be easily obtained from the APK using standard tools, such as Dex2Jar [2] and Java Decompiler <ref type="bibr" target="#b2">[4]</ref>.</p><p>Here, the name of the class is replaced with the nondescriptive name a and similarly, the private field of type SQLiteDatabase and the method returning a Cursor object are renamed with the obscure names b and c, respectively. It is evident that inspection of this code, as well as any other code using the obfuscated class a, is challenging. For example, the intended behavior of the following two lines of code is concealed due to the non-descriptive class and method names:</p><formula xml:id="formula_0">a obj = new a(); obj.c(str);</formula><p>As mentioned, ProGuard keeps the names of some program elements to preserve the application's semantics. For example, the name of the class SQLiteOpenHelper and its methods getWritableDatabase and rawQuery are not renamed because this class is part of the core Android API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">DeGuard</head><p>Given an Android APK as input, DeGuard outputs a semantically equivalent Android APK with descriptive names for fields, methods, classes, and packages. We depict the source code of the output APK produced by DeGuard in Figure <ref type="figure">1</ref>(d). The key steps of our approach are shown with thick gray arrows ( ) in Figure <ref type="figure">1</ref>. We now describe these steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dependency Graph.</head><p>DeGuard analyzes the input APK and formalizes the structure of the Android application as a graph over the program elements, where an edge signifies that the corresponding two program elements are related. The graph in Figure <ref type="figure">1</ref>(b) illustrates a fragment of the generated dependency graph for our example.</p><p>The red circular nodes denote the unknown (i.e., obfuscated) program elements whose names the tool will try to predict, and the purple rectangular nodes are the known program elements, which will not be modified by the tool. The name of the class a is therefore represented with a red node, while the class SQLiteOpenHelper with a purple one. The graph's edges are labeled with a particular relationship, which represents how the two program elements are related. For example, the edge from node a to node SQLiteOpenHelper is labeled with the relationship extends to formalize that the former class extends the latter. Since program elements can have multiple relationships, the dependency graph may in general contain multiple edges between two nodes (thus, technically, the dependency graph is a multigraph).</p><p>Formally, the relationships between two nodes represent different feature functions. The constructed dependency graph, along with all feature functions specifies a Conditional Random Field (CRF) <ref type="bibr" target="#b21">[23]</ref>, a powerful probabilistic graphical model. We formally define the dependency graph, feature functions, and CRFs in Section 3, and the features for Android applications in Section 4. (c) Graph with predicted unknown identifiers Figure <ref type="figure">1</ref>: Statistical deobfuscation of Android applications using DeGuard. The red color indicates the elements whose names are to be renamed (in the input), the green color are the same elements with the new names (in the output), and the purple color denotes the elements whose names are known and remain the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntactic and Semantic Constraints.</head><p>Given an Android APK, DeGuard automatically derives a set of constraints which restricts the possible names assigned to the unknown program elements. These naming constraints guarantee that the deobfuscated APK generated by DeGuard is: (i) a syntactically well-formed program, and (ii) semantically equivalent to the input APK. Two example constraints are: all fields declared in the same class must have distinct names and all classes that belong to the same package must have distinct names. Any wellformed application must satisfy these two syntactic properties. Naming constraints of methods are more intricate due to method overriding. For example, if a method in a subclass overrides a method in a superclass (in the input APK), then the two methods must have the same name after deobfuscation to preserve the overriding property.</p><p>For example, suppose the package of class a also contains a class with the (non-obfuscated) name MainActivity. The constraint a = MainActivity in Figure <ref type="figure">1</ref>(b) specifies that the predicted name for node a must be distinct from the name MainActivity. Indeed, if these two classes have identical names, then the resulting output APK would not be syntactically well-formed.</p><p>In Section 5, we describe an algorithm that, for any APK, generates all necessary syntactic and semantic constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Probabilistic Prediction.</head><p>Using the derived dependency graph and constraints, De-Guard infers the most likely names for all obfuscated elements. The predicted names for our example are depicted in Figure <ref type="figure">1(c)</ref>. DeGuard predicts that the name of the obfuscated class a is DBUtils and that the name of the obfuscated field b is db. Below, we describe how DeGuard concludes that these are the most likely names for this example.</p><p>To predict the names of the obfuscated elements, De-Guard performs a joint prediction that considers all program elements, known and unknown. To illustrate this inference step, consider the graph in Figure <ref type="figure">1(c</ref>). The tables associated with the graph's edges represent the likelihood, of each (pairwise) assignment of names to program elements (nodes). We remark that each table is derived from feature functions associated with weights, which together represent (log-)likelihoods. We formally define feature functions and explain the derivation of the likelihood tables in Section 3. Here, we illustrate how these likelihood tables are used to choose the most likely names. Our goal is to find an assignment for all program elements that maximizes a score that is the sum of the weights in each table.</p><p>For our example, according to the top-most table, the weight of assigning the name DBUtils to the class is 0.3. However, DeGuard does not select DBUtils as the name of this class. This is because selecting the name DBUtils does not result in the highest possible overall score. Suppose we select the name DBUtils. Then, we have two possible names for the obfuscated field b, namely db and instance. According to the likelihood tables, both the former and the latter choice result in a total score of 1.2. However, if we select the name DBHelper and db, then the total score is 1.3, which is the highest possible score for this example. DeGuard therefore returns these names as most likely.</p><p>Formally, DeGuard performs a Maximum a Posteriori (MAP) inference query on the CRF model defined by the dependency graph and the feature functions. We define MAP inference in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Security Applications</head><p>DeGuard can be used to tackle several practical security problems. In our evaluation, we show that DeGuard can effectively reverse ProGuard's layout obfuscation for benign Android APKs. Although ProGuard obfuscates 86.7% of the program elements on average, DeGuard correctly predicts the names for 79.1% of those elements.</p><p>Predicting libraries is another important problem, which is particularly relevant for Android <ref type="bibr" target="#b12">[14]</ref>. Mobile developers tend to rely on a large number of libraries which often contain security vulnerabilities -from personal information release <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b9">11]</ref> to severe man-in-the-middle vulnerabilities <ref type="bibr" target="#b0">[1]</ref>. In our experiments, DeGuard reveals over 90% of the third-party libraries concealed by ProGuard.</p><p>Further, numerous security analyses rely on descriptive program identifiers. Examples include analyses that perform statistical filtering of potential vulnerabilities <ref type="bibr" target="#b35">[37]</ref> and probabilistic systems for detecting privacy leaks <ref type="bibr" target="#b9">[11]</ref>. These systems assume that the application's program elements are non-obfuscated. DeGuard can be used to deobfuscate applications before they are analyzed by such systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Challenges</head><p>We discuss three key challenges when building a prediction system for deobfuscating Android applications:</p><p>(i) Capturing the rich structure of Android applications: precisely encoding the structure of Android applications using a concise, yet adequate set of program elements and relationships is important to ensure the predictions made by the system are accurate. This is difficult as a large set of relationships may hurt the scalability of the system while missing important relationships, or defining bad ones, can reduce the prediction accuracy.</p><p>(ii) Semantic equivalence: the rich structure of Java poses nontrivial constraints that must be captured to ensure the resulting deobfuscated Android APK has equivalent semantics to the input APK.</p><p>(iii) Scalable learning: the expressive structure of Android applications inevitably results in complex dependency graphs and a large variety of features that cannot be handled efficiently by off-the-shelf machine learning systems. According to our experiments, the most scalable available prediction system for programs <ref type="bibr" target="#b29">[31]</ref> required an order of magnitude longer than DeGuard to learn a probabilistic model for Android.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Scope and Limitations</head><p>In this work, we focus on deobfuscating Android applications that have been transformed using layout obfuscation mechanisms, which rename fields, methods, classes and packages with semantically obscure names. Other obfuscation techniques, such as data obfuscation mechanisms, which alter data structures, control-flow and cryptographic obfuscation mechanisms fall outside the scope of this work. We remark that malicious Android applications often uses multiple obfuscation techniques to prevent reverse engineering. Security experts must thus use a combination of deobfuscation tools to effectively deobfuscated Android malware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BACKGROUND</head><p>In this section we provide the necessary background on probabilistic models, queries, and learning which we leverage in this work. These concepts are well known in the field of probabilistic graphical models <ref type="bibr" target="#b18">[20]</ref>. The main purpose here is to review these parts and to illustrate how they are used by our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem Statement.</head><p>We phrase the problem of predicting the most likely names assigned to all obfuscated program elements as a problem in structured prediction. Intuitively, we model the elements of a program as a tuple of random variables (V1, . . . , Vn) ranging over a set of name labels Names. The set Names in our case contains all possible names from which we can choose to name program elements. Then, the joint distribution P (V1, . . . , Vn) (discussed later in this section) over these variables assigns a probability to each assignment of names to variables.</p><p>Let O = (V1, . . . , V | O| ) be the variables representing obfuscated program elements, i.e., the variables whose names we would like to predict. The names of the remaining variables K = (V | O|+1 , . . . , Vn) are known and will not be affected by the renaming. Then, to predict the most likely names for the obfuscated program elements, we compute the Maximum a Posteriori (MAP) inference query:</p><formula xml:id="formula_1">o = argmax o ∈Ω P ( O = o | K = k)</formula><p>where Ω ⊆ Names | O| is the set of all possible assignments of names to the obfuscated variables O, and k ∈ Names | K| defines the names assigned to the known variables K. Next, we describe how we actually represent and compute the conditional probability P ( O = o | K = k) for a given assignment of names k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dependency Graph.</head><p>A dependency graph for a given program is an undirected multigraph G = (V, E), where V is a set of random variables representing program elements and E ⊆ V ×V ×Rels is a set of labeled edges. Here, Rels is a set of relationships between program elements; we instantiate this set for Android applications in Section 4. An edge (Vi, Vj, rel ) says that elements Vi and Vj are related via rel . An example of a dependency graph is shown in Figure <ref type="figure">1(b)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Features and Weights.</head><p>We define a pairwise feature function ϕ as follows:</p><formula xml:id="formula_2">ϕ : Names × Names × Rels → R</formula><p>This function maps a pair of names and their relationship to a real number. In Section 4, we define several kinds of feature functions and based on these we obtain the entire set of pairwise features {ϕ1, . . . , ϕm} automatically during the learning phase (described at the end of this section). For example, for each observed edge (Vi, Vj, rel ) in the training set of dependency graphs where the names assigned to Vi and Vj are ni and nj, respectively, we define a pairwise feature ϕ(N, N , Rel ) = 1 if N = ni, N = nj, and Rel = rel ; otherwise, ϕi(N1, N2, rel ) = 0. Further, for any ϕi, we associate a weight wi, also computed during the learning phase.</p><p>Given a dependency graph G = (V, E), a prediction o for the obfuscated variables O, and an assignment k for the fixed, known variables K, we associate a feature function fi to each pairwise feature ϕi defined as follows:</p><formula xml:id="formula_3">fi( o, k) = (V j ,V l ,rel)∈E ϕi(( o, k)j, ( o, k) l , rel )</formula><p>Here, ( o, k)j denotes the jth name in the vector ( o, k). We can think of fi as lifting ϕi to quantify ϕi's effect on all the edges in the graph (i.e., adding up ϕi's effect on each edge). The end result computed by fi is a real number capturing the overall effect of ϕi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conditional Random Fields.</head><p>A conditional random field (CRF) is a probabilistic model which defines a conditional probability distribution, that is,</p><formula xml:id="formula_4">P ( O = o | K = k) as follows: P ( O = o | K = k) = 1 Z exp( m i=1 wifi( o, k)),</formula><p>where each fi, 1 ≤ i ≤ m, is a feature function associated with a weight wi, and Z is a normalization constant. We do not define Z as it can be omitted for our specific type of query.</p><p>It is then immediate that the dependency graph, together with the feature functions f1, . . . , fm and their associated weights w1, . . . , wm, define a CRF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Prediction via MAP Inference.</head><p>To compute the most likely assignment o for the variables O, we perform a MAP inference query:</p><formula xml:id="formula_5">o = argmax o ∈Ω P ( O = o | K = k)</formula><p>Using our CRF model, we can compute the probability of an assignment o using the formula:</p><formula xml:id="formula_6">P ( O = o | K = k) = 1 Z exp( m i=1 wifi( o, k))</formula><p>We omit the constant Z (as it does not affect the result of the MAP inference query), expand fi( o, k), and rewrite the formula as follows:</p><formula xml:id="formula_7">P ( O = o | K = k) ∼ ∼ exp( m i=1 wi (V j ,V l ,rel)∈E ϕi(( o, k)j, ( o, k) l , rel )) = = exp( (V j ,V l ,rel)∈E m i=1 wi ϕi(( o, k)j, ( o, k) l , rel ))</formula><p>We refer to the above as the total score of an assignment ( o, k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MAP Inference Example.</head><p>We now explain the above equation by referring to our example from Section 2. The product wi ϕi(( o, k)j, ( o, k) l , rel ) scores a particular pairwise feature function ϕi. In our example, each row in the tables given in Figure <ref type="figure">1</ref>(c) defines a pairwise feature function and its weight. Consider the first row of the top-most table. This row denotes a pairwise feature function which returns 1 if its inputs are (SQLiteOpenHelper, DBUtils, extends) and 0 for all other inputs. That feature function also has a weight of wi = 0.3, which is determined during learning. We do not include the type of relationship in the tables since in this example the program elements are connected via a single relationship. In our example, the MAP inference query will return the assignment o highlighted in green (i.e., DBHelper and db) as that assignment satisfies the constraints in Ω (in our example we have a single inequality constraint) and the total score of o is the highest: 0.2 + 0.4 + 0.7 = 1.3. To compute this score, DeGuard implements a greedy MAP inference algorithm which we describe in Section 6.1.</p><p>Learning from "Big Code".</p><p>The input to the learning phase of DeGuard is a set of p programs { o (j) , k (j) } p j=1 for which both vectors of names o and k are given. That is, the training data contains non-obfuscated applications, which can be downloaded from repositories for open-source Android applications, such as F-Droid <ref type="bibr" target="#b1">[3]</ref>. From this input, the learning outputs weights {wi} m i=1 such that names in the training data programs are correctly predicted. There are several variations of this learning procedure <ref type="bibr" target="#b27">[29,</ref><ref type="bibr" target="#b18">20]</ref>. For our application we use learning with pseudo-likelihoods as described in <ref type="bibr">[35, §5.4</ref>]. We describe this algorithm in more detail in Section 6.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">FEATURE FUNCTIONS</head><p>In this section, we present the pairwise feature functions used for our Android deobfuscation task. As described earlier in Section 3, these feature functions are used to build the dependency graph. Recall that the construction of an application's dependency graph amounts to introducing a node for each program element and then connecting the program elements that are related. The signature of a dependency graph is therefore defined by the application's program elements and the relationships between them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Program Elements</head><p>A program's dependency graph is defined over nodes that represent different program elements. To capture the structure of an Android application, we introduce nodes for each of the following program elements:</p><p>• Types. We introduce a node for each primitive type (e.g., int, long, float etc.), reference type (e.g., Object, ArrayList, etc.), and array type (e.g., int[], Object[], etc.) that appears in the application. For example, we introduce a node to represent the reference type SQLiteDatabase in the example of Figure <ref type="figure">1</ref>(a).</p><p>• Fields. We introduce a node for each field declared in the application's classes. For example, we introduce a node to represent the field of type SQLiteDatabase in the example of Figure <ref type="figure">1</ref>(a).</p><p>• Packages. We introduce a node for each package in the application. For example, given a package a.b, we introduce two nodes: one to represent the package a, and another to represent the package a.b.</p><p>• Methods. We introduce a node for each method declared in the application's classes. For the example of Figure <ref type="figure">1</ref>(a), we introduce two nodes: one node to represent the constructor &lt;init&gt;() and another node for the method c(). If a class overrides a given method, we use one node to represent both the method declared in the superclass and the one declared in the subclass. This guarantees that overriding methods are renamed consistently, which is necessary for preserving the application's semantics.</p><p>• Expressions. We introduce a node to represent constant values (e.g., integers, strings, etc.) and the value null. For example, we add a node 5 to capture the constant value 5. Nodes for other kinds of constant values are introduced analogously.</p><p>• Access Modifiers. We introduce nodes to represent access modifiers, such as static, synchronized, private, protected, public, and so forth.</p><p>• Operations. We introduce nodes to represent operations (e.g., +, -, etc.).</p><p>We remark that we ignore generic types because they are removed by the compiler during the type erasure process <ref type="bibr" target="#b5">[7]</ref>. Furthermore, we ignore the names of local variables and method parameters since they are not part of the application's APK. For example, we do not introduce a node to represent the method parameter's name str of the method c() in Figure <ref type="figure">1(b)</ref>. We do however capture the types of local variables and method parameters, e.g. we capture that the method c() has a parameter of type String.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Known and Unknown Program Elements.</head><p>We capture whether a node's name is obfuscated and is to be predicted, or is known and should not be predicted, using the following set of rules:</p><p>• Nodes that represent packages, classes, methods, and fields that are part of the Android API are known. For example, the node of the class SQLiteOpenHelper in our example is known because this class is part of the Android API. All program elements that are part of the Android API are referred by their name, and thus any obfuscator keeps their names intact.</p><p>• Constructor methods (both dynamic and static) have fixed names and are thus known.</p><p>• If a method overrides a known method (e.g., a method that is part of the Android API), then the nodes representing both methods are known. We enforce this rule implicitly by keeping a single node to represent both methods. We explain this shortly.</p><p>• All remaining packages, classes, methods, and fields are unknown.</p><p>Grouping Method Nodes.</p><p>In the context of inheritance and method overriding, introducing a node for each declared method leads to issues. The reason is that the two methods must have the same signature, where a method's signature is defined by the method's name along with the number and types of its parameters. To guarantee that the deobfuscation is semantic-preserving, we combine all methods related via inheritance in a single node. We refer to the process of combining all such methods as grouping.</p><p>To detect all overrides that occur in a given set of classes, for each class we collect all of the methods it implements. Then, for each of these methods, we link it with all the methods it overrides. Finally, we combine all methods that are (possibly indirectly) linked together into a single node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Relationships</head><p>To capture the structure of an Android application, we introduce relationships between its program elements. We define all such relationships in Figure <ref type="figure" target="#fig_0">2</ref>. The second column in the table defines the type of each edge. For example, the first edge type is (m, op, performs-op). This edge type says that it connects a method m to an operation op with the relationship performs-op. The third column specifies under what condition the edge is added between two nodes (of the correct type). The edge of the first type is added whenever the method m performs an operation op. The types m and op are the ones we already defined in Section 4.1. We organize the relationships into two broad categories: method relationships and structural relationships.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Method Relationships.</head><p>Method relationships capture the semantic behavior of methods. This is important because method names typically describe the method's behavior. For example, the method name execSQL in our example of Figure <ref type="figure">1</ref> describes that this method executes an SQL command. We remark on several points pertaining to method relationships. First, the program elements denoted by o, arg and v are not necessarily fields. For example, the method call field.foo().bar() results in two edges of type receiver: (foo, bar, receiver) and (field, foo, receiver). Second, for every loop occurring in a method, we capture how different values and fields are used within the loop using the relationships loop-read and loop-write. To capture which classes are accessed by a method, we introduce the relationship writes-classfield and the relationship calls-classmethod.</p><p>Finally, we remark that the relationships defined above, in addition to capturing the semantics of methods, also capture how fields, classes and methods are used by the application. For example, adding the information that method m reads field f also conveys that f is read by m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structural Relationships.</head><p>The structural relationships capture the relations between the nodes, such as whether two classes are defined within the same package or not. These features are particularly important for predicting obfuscated third-party libraries, as the correct prediction of a small number of classes within the library's package significantly aids to accurately predict the library's remaining program elements. Note that for method parameters, we express not only their type, but also how often they occur. This is captured with the relationship argtype-N. Further, we define the two relationships read-before and written-before to capture the order of reads and writes to fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparison to Other Prediction Systems.</head><p>Android applications have significantly more complex structure compared to programs encoded in, e.g., untyped, dynamic languages. Precisely capturing this structure is key to enable the accurate prediction of Android applications. De-Guard is the first prediction system for programs that sup- there is an initialization statement statements f = e (f1, f2, read-before) field f1 is read before field f2 (f1, f2, written-before) field f1 is written before field f2 ports a rich set of structural relationships, including types, structural hierarchies, and access modifiers. In our evaluation, we show that DeGuard strikes a balance between the accuracy and efficiency of prediction: the set of relationships defined above are sufficient to accurately predict a significant part (roughly 80%) of the program elements obfuscated by ProGuard, while keeping the complete prediction time reasonable (under a minute on average).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Pairwise Feature Functions</head><p>The pairwise features ϕi are derived from the relationships defined above, based on the relationships observed in the dependency graphs used in the learning phase. Formally, let G1 = (V1, E1), . . . , Gm = (Vm, Em) be the set of dependency graphs used in the learning phase with naming assignments. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONSTRAINTS</head><p>In this section we define the constraints that our deobfuscation mechanism must satisfy while renaming program elements to ensure both syntactic and semantic validity of the deobfuscated application. First, we describe method naming constraints, which are more complex to define due to method overrides. Afterwards, we describe naming constraints for fields, classes, and packages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Naming Constraints for Methods</head><p>Method naming constraints are necessary for both semantic reasons and for syntactic well-formedness. According to Java's semantics, whenever a class extends another class, the method declared in the subclass overrides a method declared in the super class if the two methods have the same Further, all methods within the same class must have distinct signatures. Below, we give an example to illustrate different kinds of method naming constraints. Afterwards, we describe how DeGuard derives these constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example.</head><p>We illustrate method naming constraints with an example. Consider the program in Figure <ref type="figure" target="#fig_2">3</ref>. Here we have three classes that exemplify different cases of method naming constraints.</p><p>The name of the method A.a(A) is not constrained by any method declared in Figure <ref type="figure" target="#fig_2">3</ref> because it has a unique list of parameter types. Here, the method A.a(A) is the only method that has one parameter of type A. In contrast, A.b(Object) cannot be renamed to equals, because then it would override java.lang.Object.equals(Object) from the Java standard library. This constraint is needed because A implicitly extends Object and the list of parameter types a matches that of the method equals declared in the class Object.</p><p>The names of the methods B.g() and B.h() must be distinct even though their return types and access level modifiers are different. This is because neither the return type nor the access level modifier is part of a method signature, and therefore renaming both methods to the same name results in the same method signature.</p><p>The names of the methods B.g() and A.c() must be distinct due to the semantics of method overriding in the presence of inheritance. Here, the class B extends A. Therefore, a potential change of the name of B.g() to that of A.c() would result in overriding method A.c(). The names of the methods B.h() and A.c() must be also distinct due to the semantics of method overriding, even though B.h() is private. The method C.x()'s name is not constrained by the name of B.h() because B.h() is declared as private. According to Java's semantics, no method may override private methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Expressing Method Constraints.</head><p>Our example shows that in addition to equality constraints, inequality constraints are also needed to formalize all naming properties of methods. Equality constraints can be handled implicitly by representing methods that must have an identical signature with one node in the dependency graph (see Section 4). This guarantees that all such methods are renamed consistently. Inequality constraints, necessary to avoid accidental overrides due to inheritance, must be ex- Formally, let V = {V1, . . . , Vn} be the set of nodes in the dependency graph. We define an inequality constraint as a set of nodes C ⊆ V . An assignment y = (y1, . . . , yn) of names to program elements satisfies the inequality constraint C if ∀Vi, Vj ∈ C. yi = yj. For example, to specify that the methods C.x() and B.g() must have distinct names, we use the inequality constraint C = {C.x(), B.g()}. Note that we define inequality constraint using sets of elements whose elements must be pairwise distinct, as opposed to standard binary inequality constraints (e.g., C.x() = B.g()) because the encoding of the former is more concise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deriving Inequality Constraints for Methods.</head><p>We next describe how we derive inequality constraints for methods. Without loss of generality, we treat interfaces identically to classes. The inequality constraints for methods are derived using Algorithm 1. The function find-Constraints calls handleClass with the class Object and the empty set of method names (since Object has no super classes). The recursive call on Line 10 reaches all other classes as every class (transitively) extends Object.</p><p>The function handleClass(class, aboveMethods) reports all inequality constraints for class, where the parameter aboveMethods contains all methods that the methods declared in class can potentially override.</p><p>The function reportConstraints reports the inequality constraints for the methods contained in methods. To do this, it first partitions the methods based on their parameter types. All methods in a given partition must have distinct names, because otherwise, they would have the same signature. On the other hand, no method is constrained by the methods in the other partitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Result on the Example.</head><p>Here, we show the result of applying Algorithm 1 on the program in Figure <ref type="figure" target="#fig_2">3</ref>. For simplicity, we assume that A does not extend java.lang.Object. More precisely, a call to handleClass(A, ∅) results in the inequality constraints {A.c(), B.g(), B.h()} and {A.c(), B.g(), C.x()}. Note that we implicitly remove singleton inequality constraints as these are always satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Naming Constraints for Fields, Classes, and Packages</head><p>The deobfuscation mechanism must satisfy the following properties: (i) any two packages contained in the same package must have distinct names, (ii) any two classes contained in the same package must have distinct names, and (iii) any two fields declared in the same class must have distinct names. We remark that the types of fields are irrelevant for naming constraints. This is because a field is referred to by its name, and the type of a field is not part of this name. This is in contrast to methods, which are called by their signature and where the types of a method's parameters are part of the method's signature.</p><p>For a given Android app, the naming constraints for fields, classes, and packages, are formalized using inequality constraints in the same way we formalize the constraints for method names. We derive all inequality constraints for fields, classes, and packages, by iterating over all classes and packages and reporting inequality constraints as defined by the above properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">IMPLEMENTATION AND EVALUATION</head><p>In this section we describe the implementation of De-Guard and the experiments we conducted with it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The DeGuard System</head><p>We now present our DeGuard system, which is publicly available at http://apk-deguard.com. DeGuard is implemened using Soot <ref type="bibr" target="#b36">[38]</ref>, a framework for static analysis of Java and Android applications. Given an Android APK, Soot transforms it into an intermediate format (called Jimple) that simplifies the analysis of the application. To construct the application's dependency graph, we use Soot's API to traverse all program elements.</p><p>To predict the names of all obfuscated elements for a given application, DeGuard performs a MAP inference query on the CRF model constructed from the application's program elements, the set of pairwise features (described in 4), and the feature weights. Next, we describe how DeGuard learns a probabilistic model (the pairwise features and their weights) from non-obfuscated Android applications, and how it uses this probabilistic model to predict likely names of obfuscated program elements using MAP inference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Feature Functions and Weights.</head><p>To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid <ref type="bibr" target="#b1">[3]</ref>, a popular repository for open-source Android applications. Out of these 1784 applications, we randomly selected 100 which we intentionally left as our benchmark applications, i.e., the ones we later use in our evaluation. We used the remaining 1684 applications as our training set of applications.</p><p>The set of possible names assigned to obfuscated program elements is drawn from the names observed in the training set. The pairwise features ϕ1, . . . , ϕm are also derived from the training set, as described in Section 4.3. The only component missing in our probabilistic model are weights w = [w1, . . . , wm] associated with the pairwise features. One way to learn the weights is to use maximum likelihood estimation, where the weights w are chosen such that the training data has the highest probability. That is, we chose weights w that maximize the probability P ( O = o j | K = k j ), computed as defined in Section 3, for all programs o j , k j in the training set. Unfortunately, computing the weights using precise maximum likelihood estimation is prohibitively expensive in our context, due to the large number of nodes and possible labels that can be assigned to them. DeGuard therefore learns the weights using pseudo likelihood, which approximates the conditional distribution P ( O | K) as the product of the conditional distributions P (Oi | N (Oi), K) of each unknown node Oi ∈ O conditioned on the node's neighbors N (Oi) and the known nodes K. For the complete details on training using pseudo likelihoods see <ref type="bibr">[35, §5.4</ref>].</p><p>Using the training described above, the training of this model took about 2 hours on a 32-core machine with four 2.13GHz Xeon processors running Ubuntu 14.04 with 64-Bit OpenJDK Java 1.7.0 51.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MAP Inference.</head><p>To predict likely names o to be assigned to all obfuscated elements O, DeGuard computes the MAP inference query</p><formula xml:id="formula_8">o = argmax o ∈Ω P ( O = o | K = k)</formula><p>where k are the names assigned to the known elements K. For this step, we use the publicly available Nice2Predict framework <ref type="bibr" target="#b3">[5]</ref>. Nice2Predict computes the MAP query using a scalable, greedy algorithm, where names assigned to obfuscated program elements are iteratively changed oneby-one or in pairs until the score stops improving. At every iteration, all naming constraints are checked for violations. More details on this algorithm are provided in <ref type="bibr" target="#b29">[31]</ref>. After predicting the names for all obfuscated elements, DeGuard renames them using the Soot API, and then constructs and outputs the deobfuscated APK.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Experimental Evaluation</head><p>We now present our experiments with DeGuard. First, we evaluate DeGuard's accuracy on deobfuscating benign, open-source applications obfuscated using ProGuard. Second, we discuss our experience in inspecting malware samples deobfuscated using DeGuard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">ProGuard Experiments</head><p>We perform two tasks to evaluate DeGuard's performance on ProGuard-obfuscated applications. First, we measure DeGuard's accuracy on predicting the names of program elements obfuscated by ProGuard. Second, based on the results of the first task, we report DeGuard's accuracy on the task of predicting the names of obfuscated third-party libraries imported in the APK.</p><p>To conduct the above tasks, we obfuscated 100 benign applications from F-Droid. These are the 100 applications that we intentionally did not use during the learning phase. For all 100 applications, we enabled ProGuard obfuscation by modifying their build files, without modifying ProGuard's obfuscation rules, which specify which elements are obfuscated. In our experiments, we use the non-obfuscated versions of the applications as an oracle to check whether De-Guard correctly deobfuscates the program elements' names by renaming them to their original (i.e., non-obfuscated) names. ProGuard-obfuscated APKs.</p><p>In Figures <ref type="figure">4</ref> and<ref type="figure">5</ref> we show two relevant metrics that reveal the dependency structure of the 100 applications that we obfuscated using ProGuard. The bar chart depicted in Figure <ref type="figure">4</ref> shows the distribution of total number of neighbors. This figure shows one bar for each neighborhood size, where the bar's height indicates the percentage of nodes that have exactly that number of neighbors. For example, the fifth bar indicates that the percentage of nodes with exactly 4 neighbors is around 22%. Similarly, the bar chart shown in Figure <ref type="figure">5</ref> shows the distribution of known neighbors. The data in these two figures reveals two key points about our features: (i) the nodes are well-connected (99% of the nodes have at least 3 neighbors), and (ii) most nodes have known neighbors (99% have at least one known neighbor). That is, our features lead to dependency graphs where informed prediction seems possible (rather than graphs which are mostly disconnected where there would be little or no flow into a node whose name is to be predicted).</p><p>Task 1: Predicting Program Element Names.</p><p>For this task, we deobfuscated the 100 benchmark applications, which we previously obfuscated with ProGuard. We remark that ProGuard, in addition to renaming program elements, also removes some elements. For example, it removes fields, methods, and classes that are not used by the application. Hence, we evaluate whether DeGuard correctly deobfuscates elements not removed by ProGuard.</p><p>Figure <ref type="figure" target="#fig_4">6</ref> shows the percentage of known elements (which DeGuard does not try to reverse), correctly predicted elements, and mis-predicted elements, averaged over all 100 applications deobfuscated by DeGuard. Each bar has three segments, which represent the three kinds of program ele- ments: (i) known, which are the elements not obfuscated by ProGuard and which the system keeps as is, (ii) correct, which are the elements that DeGuard correctly renames to their original names, and (iii) mis-predicted, which are the elements for which DeGuard predicts names that differ from the original ones. Here, the first four bars show data about fields, methods, classes, and packages, respectively, and the fifth bar shows the aggregate data for all program elements. We use the predictions made for the package names in the second task discussed in this section.</p><p>The data shows that ProGuard obfuscates a substantial number of the program elements. On average, only 1.6% of the fields, 33% of the methods, 9.4% of the classes, and 9.3% of the packages are known. Thus, on average, ProGuard obfuscates 86.7% of each application's program elements.</p><p>The data further shows that DeGuard correctly deobfuscates a significant part of the obfuscated program elements. For example, while only 1.6% of the fields in the obfuscated applications are known, after DeGuard deobfuscates them, 80.6% of all fields have names identical to the original ones. We remark that 80.6% is a lower bound on how well DeGuard deobfuscates fields. This is because some of the names classified as mis-predicted are semantically close to the original ones. For example, in the application FacebookNotifications, DeGuard suggested appView and mWindowManager as names for two fields, while the original names are webview and windowManager, respectively.</p><p>Overall, the data shows that among all program elements, DeGuard increases the percentage of names that are identical to the original ones from 13.3% (in the obfuscated APK) to 79.1% (in the deobfuscated APK). We remark that the applications used in this experiment are benign. DeGuard's prediction accuracy on malicious applications may therefore be lower.</p><p>Task 2: Predicting Third-party Libraries.</p><p>We next use the deobfuscation results for package names obtained from Task 1 in order to evaluate DeGuard's effectiveness for predicting third-party libraries.</p><p>We first explain what we mean by the term library. We identify libraries by their package names. We classified package names into library and application-specific using a simple heuristic: any package name that appears in multiple applications is classified as corresponding to a library. This heuristic works well because most application-specific pack-renames it to Base64. Further, DeGuard reveals that the method a(String) decodes strings formatted in Base64 (we confirmed this by inspecting the implementation of method a(String)) and renames it to decode(String). The statement Base64.decode(String) is more descriptive compared to d.a(String), and we thus believe that DeGuard can help security analysts in inspecting this malware sample.</p><p>Revealing Sensitive Data Usage.</p><p>Malware often steals personal information, such as location data, device identifiers, and phone numbers. We search the deobfuscated code of our malware samples for identifiers such as location and deviceId and discovered that DeGuard often deobfuscates the names of fields that store sensitive data and methods that handle sensitive data. As an example, in Figure <ref type="figure">8</ref> we show an obfuscated code snippet taken from the Bgserv malware sample 3 , along with the deobfuscated code output by DeGuard. We observe that DeGuard renames the obfuscated field o, which stores the device's location, to location. Further, it renames the method j() to requestLocationUpdates(). We inspected the method j() to reveal that it instantiates the interface LocationListener and implements the method onLocationChanged() to receive location updates. The name requestLocationUpdates() assigned by DeGuard captures the behavior of this method.</p><p>In the remaining malware samples, we discovered that De-Guard renames a number of fields and methods that handle other kinds of sensitive data, such as device identifiers. We believe that DeGuard can help in inspecting malware that misuses sensitive data, e.g., by allowing security experts to search for certain identifiers in the deobfuscated code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Limitations.</head><p>In addition to obfuscating program identifiers, most of malware samples we inspected are obfuscated with additional techniques to further hinder reverse engineering. Examples include custom encoding of strings (e.g. using custom encryption), extensive use of reflection, control flow obfuscation, code reordering using goto statements, and others. Reversing these additional obfuscation steps is beyond the scope of DeGuard. To inspect malware, security analysts must therefore use a combination of deobfuscation tools tailored to reversing different obfuscation techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>This section summarizes the works that are most closely related to ours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Suggesting names for program elements.</head><p>Several works have studied the effect of identifier names <ref type="bibr" target="#b34">[36,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b10">12]</ref> and have shown that good names have significant impact on one's ability to understand the source code. These studies have inspired tools <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b31">33]</ref> that rename identifiers within a project to make them follow a given coding convention. In contrast to DeGuard, the systems presented in <ref type="bibr" target="#b11">[13]</ref> and <ref type="bibr" target="#b31">[33]</ref> cannot be used for deobfuscation. The tool described in <ref type="bibr" target="#b11">[13]</ref> relies on the names to be replaced to have meaningful, non-obfuscated names, so it can improve them. This system cannot predict meaningful replacements of names such as "a". The tool of <ref type="bibr" target="#b31">[33]</ref> does not suggest 3 SHA1: 03f9fc8769422f66c59922319bffad46d0ceea94 new names: it only identifies bad names based on syntactic guidelines and provides that feedback to developers.</p><p>The works of Allamanis et al. <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b7">9]</ref> suggest names for Java program elements using n-gram language models and neural networks. Their technique, however, only allows predicting the name of a single program element and is thus not applicable to a deobfuscation task where most names are missing.</p><p>LibRadar <ref type="bibr" target="#b24">[26]</ref> detects third-party Android libraries by extracting a unique fingerprint from each library and creating a mapping from fingerprints to library names. Obfuscated libraries are then identified by their fingerprints. In contrast to DeGuard, LibRadar is less general as it predicts names only for packages, and it is less robust because it relies on stable features (i.e., completely unaffected by obfuscation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Probabilistic models for programs.</head><p>A recent surge in the number of open-source repositories has triggered several authors to create large-scale probabilistic models for code. These models are then used for novel applications such as code completion <ref type="bibr" target="#b30">[32]</ref>, generating code from natural language <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b8">10]</ref>, sampling code snippets <ref type="bibr" target="#b25">[27]</ref>, programming language translation <ref type="bibr" target="#b16">[18]</ref>, type annotating programs <ref type="bibr" target="#b17">[19,</ref><ref type="bibr" target="#b29">31]</ref> and others.</p><p>Closest to our work is <ref type="bibr" target="#b29">[31]</ref> which also uses structured prediction and the Nice2Predict framework <ref type="bibr" target="#b3">[5]</ref> to guess names of local variables for JavaScript programs. Our setting however is different and requires more diverse feature functions, constraints and range of elements for which names are to be predicted; further, we use an order of magnitude more scalable learning mechanism than <ref type="bibr" target="#b29">[31]</ref>.</p><p>Several works <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b22">24]</ref> use graphical models to discover properties about programs such as function specifications and invariants. These works, however, do not use MAP inference to discover overall optimal solutions for all predicted properties (and most do not learn from existing programs). The work of Shin et al. <ref type="bibr" target="#b32">[34]</ref> uses neural networks and a large training set to identify libraries in binaries. In the context of Android, a recent paper by Octeau et al. <ref type="bibr" target="#b26">[28]</ref> uses a probabilistic model and static analysis to determine if two applications may communicate via the Android intent mechanisms. However, theirs is a rather different task than the one addressed by our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>We presented a new approach for layout deobfuscation of Android APKs. The key idea is to phrase the problem of reversing obfuscated names as structured prediction in a probabilistic graphical model and to leverage the vast availability of non-obfuscated Android programs to learn this model. We implemented our approach in a system called DeGuard and demonstrated that DeGuard can successfully and with high precision reverse obfuscations performed by ProGuard, a task beyond the reach of existing systems. We believe that our work indicates the promise of leveraging probabilistic models over "Big Code" for addressing important challenges in security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENTS</head><p>The research in this work has been partially supported by ERC starting grant #680358. We thank Matteo Panzacchi for extending Nice2Predict <ref type="bibr" target="#b3">[5]</ref> with support for pseudo likelihood estimation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Relationships used to relate the program elements of Android applications. The second column defines the edge type (i.e. the program elements it related). Each relationship is added if the condition in the third column is true.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>For each edge (Vi, Vj, rel ) ∈ E1 ∪ . . . ∪ Em that appears in the dependency graphs, we define a pairwise feature ϕi(N, N , Rel ) = 1 if N = ni, N = nj, Rel = rel 0 otherwise where ni and nj are the names assigned to the program elements denoted by Vi and Vj. The pairwise features define an indicator function for each pair of labels and kind of relationship observed in the training set of non-obfuscated programs. While the pairwise features are derived from the training data, the weights associated to these features are learned during the learning phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An example that illustrates different types of method naming constraints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Distribution of total number of neighbors over the 100 ProGuard-obfuscated Android applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FieldsFigure 6 :</head><label>6</label><figDesc>Figure 6: Average percentage of known, correctly predicted, and mis-predicted program elements calculated over the 100 Android applications deobfuscated by DeGuard.</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>age names are unique to a particular application. For example, org.apache.commons.collections4 is classified as a library, while com.pindroid.providers is classified as an application-specific package name. Based on our heuristic, we identified a total of 133 libraries imported in the APKs.</p><p>To measure DeGuard's effectiveness in predicting libraries we use two (standard) metrics -precision and recall. Let L denote the set of all obfuscated libraries imported by an application and P denote the set of predicted libraries by DeGuard. Here, P contains all package names that map to one of the 133 names that we have previously classified as libraries. We compute DeGuard's precision using the formula precision = |L ∩ P |/|P |, and recall using the formula recall = |L ∩ P |/|L|. Intuitively, precision shows the percentage of libraries that DeGuard correctly predicts, and recall captures the percentage of libraries that DeGuard attempts to predict.</p><p>DeGuard's precision and recall for predicting libraries is, on average, 91.3% and 91.0%, respectively. This result indicates that DeGuard predicts libraries more accurately compared to arbitrary program elements. Further, DeGuard almost never mis-predicts a library. This is likely because the training set, which we use to learn the weights of all features, may contain applications that import the same libraries that we attempt to predict.</p><p>We remark that the benchmark applications in this experiment are not malicious, and so the libraries that they import are also benign. Malicious third-party libraries embedded in applications can be more difficult to identify.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Prediction Speed.</head><p>For most applications, DeGuard takes on average less than a minute to deobfuscate its APK. Around 10% of the time is spent in constructing the dependency graph and deriving all syntactic and semantics constraints. The remaining 90% of the time is spent in computing the most likely naming assignment using the approximate MAP inference query. An interesting future work item is to investigate faster MAP inference algorithms leveraging the specifics of our dependency graphs.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of ProGuard Experiments.</head><p>In summary, our experiments demonstrate that: (i) De-Guard correctly predicts an overwhelming part of the program elements obfuscated by ProGuard, thereby effectively reversing ProGuard's obfuscation mechanism; (ii) it precisely identifies third-party Android libraries, and (iii) it is robust and efficient, taking on average less than a minute per application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Experiments with Malware Samples</head><p>We randomly selected one sample from each of the 49 malware families reported in <ref type="bibr" target="#b38">[40]</ref>. We used DeGuard to deobfuscate the selected samples and manually inspected some of them. While we cannot report DeGuard's exact precision on the selected samples (since they are all obfuscated), we report on several interesting examples that suggest that DeGuard can be useful when inspecting malware. We also discuss DeGuard's limitations in the context of malware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Revealing Base64 String Decoders.</head><p>Malware often disguises text strings using the Base64 encoding scheme. DeGuard can be used to discover the classes that implement such standard encoding schemes. Concretely, DeGuard discovered the Base64 decoders in three of the malware samples that we inspected. We remark that eight other samples also have Base64 decoders, but the classes that implement this encoding are not obfuscated.</p><p>As an example, in Figure <ref type="figure">7</ref> we show code snippets taken from the GingerMaster <ref type="bibr" target="#b37">[39]</ref> malware sample 2 . Figure <ref type="figure">7</ref> </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Advertising SDK Can Be Hijacked for Making Phone Calls</title>
		<ptr target="http://www.hotforsecurity.com/blog/advertising-sdk-can-be-hijacked-for-making-phone-calls-geo-locating-7461.html" />
	</analytic>
	<monogr>
		<title level="m">Geo-Locating</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">F-Droid</forename></persName>
		</author>
		<ptr target="https://f-droid.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Java</forename><surname>Decompiler</surname></persName>
		</author>
		<ptr target="http://jd.benow.ca/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="https://github.com/eth-srl/Nice2Predict" />
		<title level="m">Nice2Predict</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://proguard.sourceforge.net/" />
		<title level="m">ProGuard</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Type</forename><surname>Erasure</surname></persName>
		</author>
		<ptr target="https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Learning natural coding conventions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sutton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Suggesting accurate method and class names</title>
		<author>
			<persName><forename type="first">M</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sutton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bimodal modelling of source code and natural language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarlow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for android apps</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Le Traon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Octeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exploring the influence of identifier names on code quality: An empirical study</title>
		<author>
			<persName><forename type="first">S</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wermelinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sharp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Restructuring program identifier names</title>
		<author>
			<persName><forename type="first">B</forename><surname>Caprile</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tonella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Following devil&apos;s footprints: Cross-platform analysis of potentially harmful libraries on android and ios</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Taintdroid: An information-flow tracking system for realtime privacy monitoring on smartphones</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Program verification as probabilistic inference</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jojic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Synthesizing java expressions from free-form queries</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gvero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Phrase-based statistical translation of programming languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Karaivanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Raychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Onward!</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Estimating types in binaries using predictive modeling</title>
		<author>
			<persName><forename type="first">O</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>El-Yaniv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Friedman</surname></persName>
		</author>
		<title level="m">Probabilistic Graphical Models: Principles and Techniques -Adaptive Computation and Machine Learning</title>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A factor graph model for software bug finding</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kremenek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJCAI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">From uncertainty to belief: Inferring the specification within</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kremenek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Twohey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Conditional Random Fields: Probabilistic Models for Segmenting and Labeling Sequence Data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Lafferty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C N</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Merlin: Specification inference for explicit information flow problems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Protecting Java Code via Code Obfuscation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Low</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Crossroads</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1998-04">Apr. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Libradar: fast and accurate detection of third-party libraries in android apps</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE 2016 -Companion Volume</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Structured generative models of natural source code</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Maddison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarlow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Combining static analysis with probabilistic models to enable market-scale android inter-component analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Octeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Le Traon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">(Approximate) Subgradient Methods for Structured Prediction</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Ratliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bagnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zinkevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AISTATS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Learning programs from noisy data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Raychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bielik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krause</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Predicting program properties from &quot;big code</title>
		<author>
			<persName><forename type="first">V</forename><surname>Raychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krause</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Code completion with statistical language models</title>
		<author>
			<persName><forename type="first">V</forename><surname>Raychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Tool assisted identifier naming for improved software readability: an empirical study</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Relf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISESE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Recognizing functions in binaries with neural networks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C R</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Moazzezi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An introduction to conditional random fields</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Found. Trends Mach. Learn</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="267" to="373" />
			<date type="published" when="2012-04">Apr. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The effects of comments and identifier names on program comprehensibility: an experimental investigation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Takang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Grubb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Macredie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Prog. Lang</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="143" to="167" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Aletheia: Improving the usability of static security analysis</title>
		<author>
			<persName><forename type="first">O</forename><surname>Tripp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guarnieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistoia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aravkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Soot -a Java Bytecode Optimization Framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collaborative Research</title>
		<meeting>the 1999 Conference of the Centre for Advanced Studies on Collaborative Research</meeting>
		<imprint>
			<publisher>IBM Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Yu</surname></persName>
		</author>
		<ptr target="https://www.sophos.com/en-us/medialibrary/PDFs/technical%20papers/Yu-VB2013.pdf" />
		<title level="m">Ginmaster: A case study in android malware</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Dissecting android malware: Characterization and evolution</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
