<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">T-CREST: Time-predictable Multi-Core Architecture for Embedded Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-04-04">April 4, 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Martin</forename><surname>Schoeberl</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Denmark</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sahar</forename><surname>Abbaspour</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Denmark</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benny</forename><surname>Akesson</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Czech Technical University</orgName>
								<address>
									<settlement>Prague</settlement>
									<country key="CZ">Czech Republic</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Neil</forename><surname>Audsley</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of York</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Raffaele</forename><surname>Capasso</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Intecs S.p.A</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jamie</forename><surname>Garside</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of York</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kees</forename><surname>Goossens</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<country key="NL">the Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sven</forename><surname>Goossens</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Scott</forename><surname>Hansen</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<country key="NL">the Netherlands</country>
								</address>
							</affiliation>
							<affiliation key="aff5">
								<orgName type="laboratory">The Open Group</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Reinhold</forename><surname>Heckmann</surname></persName>
							<affiliation key="aff6">
								<orgName type="institution">AbsInt Angewandte Informatik GmbH</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Stefan</forename><surname>Hepp</surname></persName>
							<affiliation key="aff7">
								<orgName type="institution">Vienna University of Technology</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benedikt</forename><surname>Huber</surname></persName>
							<affiliation key="aff7">
								<orgName type="institution">Vienna University of Technology</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Jordan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Denmark</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Evangelia</forename><surname>Kasapaki</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Denmark</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jens</forename><surname>Knoop</surname></persName>
							<affiliation key="aff7">
								<orgName type="institution">Vienna University of Technology</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yonghui</forename><surname>Li</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Eindhoven University of Technology</orgName>
								<address>
									<country key="NL">the Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Prokesch</surname></persName>
							<affiliation key="aff7">
								<orgName type="institution">Vienna University of Technology</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wolfgang</forename><surname>Puffitsch</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Denmark</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Puschner</surname></persName>
							<affiliation key="aff7">
								<orgName type="institution">Vienna University of Technology</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">André</forename><surname>Rocha</surname></persName>
							<affiliation key="aff8">
								<orgName type="laboratory">GMV</orgName>
								<address>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cláudio</forename><surname>Silva</surname></persName>
							<affiliation key="aff8">
								<orgName type="laboratory">GMV</orgName>
								<address>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jens</forename><surname>Sparsø</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technical University of Denmark</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alessandro</forename><surname>Tocchi</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Intecs S.p.A</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">T-CREST: Time-predictable Multi-Core Architecture for Embedded Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-04-04">April 4, 2015</date>
						</imprint>
					</monogr>
					<idno type="MD5">766F2EFE47F420ED0E19479609FCF7B7</idno>
					<idno type="DOI">10.1016/j.sysarc.2015.04.002</idno>
					<note type="submission">Received Date: 14 July 2014 Revised Date: 19 January 2015 Accepted Date: 2 April 2015 Preprint submitted to Journal of L A T E X Templates</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Real-time systems</term>
					<term>time-predictable computer architecture 2010 MSC: 00-01</term>
					<term>99-00</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Real-time systems need time-predictable platforms to allow static analysis of the worst-case execution time (WCET). Standard multi-core processors are optimized for the average case and are hardly analyzable. Within the T-CREST project we propose novel solutions for time-predictable multi-core architectures that are optimized for the WCET instead of the average-case execution time. The resulting time-predictable resources (processors, interconnect, memory arbiter, and memory controller) and tools (compiler, WCET analysis) are designed to ease WCET analysis and to optimize WCET performance. Compared to other processors the WCET performance is outstanding.</p><p>The T-CREST platform is evaluated with two industrial use cases. An application from the avionic domain demonstrates that tasks executing on different cores do not interfere with respect to their WCET. A signal processing application from the railway domain shows that the WCET can be reduced for computation-intensive tasks when distributing the tasks on several cores and using the network-on-chip for communication. With three cores the WCET is improved by a factor of 1.8 and with 15 cores by a factor of 5.7.</p><p>The T-CREST project is the result of a collaborative research and development project executed by eight partners from academia and industry. The European Commission funded T-CREST.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Safety-critical systems are important parts of our daily life. They have to be reliable, as our lives can depend on them. Examples are controllers in airplanes, braking controllers in cars, or train control systems. Those safetycritical systems need to be certified and the maximum execution time needs to be bounded and known so that response times can be assured when critical situations require a timely reaction. Note that just using a faster processor is not a solution for time predictability. Even with high performance processors in our desktop PCs we notice once in a while that the PC is "frozen" for a few seconds. For word processing we accept this minor inconvenience, but for a safety-critical system such a "pause" can result in a catastrophic failure.</p><p>The mission of T-CREST was to develop tools and build a platform that avoids such unexpected pauses. The T-CREST time-predictable platform simplifies the safety argument with respect to maximum execution time and leverages the possible performance improvement of multi-core systems for real-time systems. Thus the T-CREST platform results in lower costs for safety-relevant applications, in reduced system complexity, and at the same time in faster timepredictable code execution.</p><p>Standard computer architecture is driven by the following paradigm: make the common case fast and the uncommon case correct. This design approach leads to architectures where computer architects optimize the average-case execution time at the expense of the worst-case execution time (WCET). Modeling the dynamic features of current processors, memories, and interconnects for WCET analysis often results in computationally infeasible problems. The bounds calculated by the analysis are thus overly conservative.</p><p>We need a sea change and we shall take the constructive approach by designing computer architectures where predictable timing is a first-order design factor. For real-time systems we thus propose to design architectures with a new paradigm: make the worst-case fast and the whole system easy to analyze. Despite the advantages of analyzable system resources, only a few research projects exist in the field of hardware optimized for the WCET.</p><p>Within T-CREST we propose novel solutions for time-predictable multi-core architectures. The resulting time-predictable resources (processors, interconnect, memories, etc.) are an easy target for WCET analysis and the WCET performance is outstanding compared to current processors. Time-predictable caching and time-predictable chip-multiprocessing (CMP) provides a solution for the need of increased processing power in the real-time domain.</p><p>Besides the hardware, we developed a compiler infrastructure in the project. We developed WCET-aware optimization methods using the known behavior of the hardware. We adapted the WCET analysis tool aiT to support the developed hardware and guide the compilation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">The T-CREST Platform and Supported Programming Models</head><p>T-CREST covers technologies from the chip level (processor, memory, asynchronous network-on-chip), via compiler, single-path code generation, and WCET analysis tools, up to system evaluation with two industry use cases. New languages or new operating system concepts for time-predictable real-time systems are not in the scope of this project. Most of the T-CREST hardware is opensource under the industry friendly, simplified BSD license. <ref type="foot" target="#foot_0">1</ref>The overall architecture of the T-CREST platform is shown in Figure <ref type="figure" target="#fig_0">1</ref>. The platform consist of a number of processor nodes and two networks-onchip; one that supports message passing between processor nodes and one that provides access to a shared external memory. A processor node includes a Patmos processor <ref type="bibr" target="#b0">[1]</ref>, special instruction and data cache memories (a method cache <ref type="bibr" target="#b1">[2]</ref> and a stack cache <ref type="bibr" target="#b2">[3]</ref>) and local private scratchpad memories (SPMs) for instructions and data. Message passing is implemented using DMA driven writes from the local SPM in a processor node to the SPM in a remote processor node. The message passing NoC <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref> supports this by offering virtual endto-end channels. The memory NoC <ref type="bibr" target="#b6">[7]</ref> provides access to a shared external SDRAM memory that is controlled by a real-time memory controller <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>.</p><p>The memory NoC and the memory controller do not include any hardware support for cache coherency. The main means of processor-to-processor communication is the message passing NoC. The shared memory is primarily intended for initialization and to extend the memory resources beyond what can fit onto a single chip. Processor-to-processor communication via shared memory is permitted, but coherency mechanisms are implemented in software. This allows for sharing of large data structures protected by locks that implement cache coherency in software.</p><p>The decisions not to use hardware based cache coherency and the inclusion of hardware support for message passing is in line with many current CMPs and multi-processor systems on chip <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>. The main reason behind this trend is that the cost of implementing cache coherency in hardware in a multiprocessor platform using a packet switched NoC is becoming prohibitive, both in terms of area and in terms of network load.</p><p>We have adopted these fundamental architectural decisions and the scope of this paper is to study how message passing and shared memory access can be implemented in a time-predictable manner and optimized with an aim of minimizing the WCET. The platform is further supported by a compiler also developed with a focus on WCET, and the aiT WCET-tool has been extended to support the Patmos processor. The T-CREST platform consisting of Patmos processor nodes that are connected via an on-chip network for message passing communication and a memory tree to a memory controller for shared memory access.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Project Contributions</head><p>The main contributions of the T-CREST project are:</p><p>• The T-CREST platform provides a time-predictable multi-core platform so that we can perform reliable WCET analysis and tighter WCET bounds enable higher processor utilization.</p><p>• The T-CREST platform supports a globally-asynchronous locally-synchronous timing organization to enable the implementation of large scale multi-core platforms. An asynchronous network-on-chip connects synchronous processors.</p><p>• The T-CREST memory network-on-chip and the memory controller support time-predictable accesses to the shared main memory to allow WCET analysis of such accesses.</p><p>• The T-CREST compiler and the WCET analysis tool aiT are tightly integrated to support the T-CREST processor Patmos and to enable WCET driven compiler optimization.</p><p>• The T-CREST platform improves the worst-case performance logarithmically in the number of processing cores, under the assumption that the application is a good candidate for parallelization, to provide more processing power for future, more complex embedded real-time systems. For a digital-signal processing application we showed that three cores improve the WCET by a factor of 1.8 and 15 cores by a factor of 5.7</p><p>• Most technology of T-CREST is available in open source and we consider this as a main contribution to the real-time architecture research community. The Patmos reference handbook <ref type="bibr" target="#b13">[14]</ref> contains download and detailed build instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Paper Organization</head><p>The paper is organized into 8 sections. The following Section 2 compares the T-CREST approach with related work. We organized the rest of the paper according to the different research and development areas of the T-CREST project. Section 3 introduces the time-predictable processor Patmos developed within T-CREST. Section 4 describes T-CREST's core-to-core message passing network-on-chip that supports asynchronous message passing across point-topoint virtual circuits. Section 5 presents the memory hierarchy of the T-CREST platform and explains how to provide time-predictable access to off-chip DRAM memory. Section 6 describes the compilation tool chain for the Patmos architecture and its integration with WCET analysis. Section 7 presents the evaluation of the capability of the T-CREST platform to host real industrial applications with delicate predictability requirements, using domain-specific use case applications from the avionics and railway domains. Finally, Section 8 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Research on time-predictable architectures is a steadily growing field that is gaining momentum. This section presents related research papers and discusses the relation between T-CREST and other projects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Related Projects</head><p>The projects MERASA, parMERASA, JEOPARD, PREDATOR, ALL-TIMES, and Scalopes are related to the T-CREST project in some regards.</p><p>The FP-7 project MERASA (Multi-Core Execution of Hard Real-Time Applications Supporting Analysability) <ref type="bibr" target="#b14">[15]</ref> investigated time-predictable execution on a bus-based CMP with multi-threaded version of the TriCore processor. In contrast to MERASA, we developed a network-on-chip based multi-core architecture. Furthermore, we tackled the time predictability challenge by developing a new processor architecture, with a WCET optimized instruction set, and the supporting compiler.</p><p>The FP-7 project parMERASA is a followup project of MERASA and tackles the parallelization of applications <ref type="bibr" target="#b15">[16]</ref>. Unlike MERASA, parMERASA targets a network-on-chip based multi-core architecture. The parMERASA project focuses on tools and system-level software to support parallelization, WCET analysis and verification. In contrast to T-CREST, parMERASA uses a simulator for their target platform rather than implementing a time-predictable architecture.</p><p>The FP-7 project JEOPARD (Java Environment for Parallel Realtime Development) investigated architectures and tools for real-time Java on CMP systems. JEOPARD considered all levels of the architecture: the hardware, the operating system, the JVM, static analysis tools, and evaluation of the architecture with three use cases. While JEOPARD targeted real-time Java, the Java processor JOP <ref type="bibr" target="#b16">[17]</ref> provided an inspiration for Patmos, in particular with regard to the cache design. Furthermore, TDMA based memory access arbitration and its WCET analysis was explored within JEOPARD <ref type="bibr" target="#b17">[18]</ref>.</p><p>The FP-7 project PREDATOR studied the interplay between efficiency requirements and critical constraints in embedded system design, aiming at a design for predictability and efficiency. Results on the notion of predictability in general and on the predictability of hardware and software features lead to advice what to avoid when developing a predictable system <ref type="bibr" target="#b18">[19]</ref>. This work provided one of the foundations for the work in T-CREST. The processor design in T-CREST follows the design principles of predictable architectures elaborated in the PREDATOR project.</p><p>The main goal of the FP-7 project ALL-TIMES <ref type="bibr" target="#b19">[20]</ref> was to enhance the timing analysis technology for safety-critical embedded systems. The project aimed at combining available timing tools from SMEs and universities into an integrated tool chain using open tool frameworks and interfaces, and at developing new timing analysis methods and tools where appropriate.</p><p>Wolfgang: contrast with/relate to T-CREST... like ALL-TIMES, we are also (mostly) open source, but I'm not sure how to put this nicely.</p><p>In the context of the Scalopes project, the CompSOC platform <ref type="bibr" target="#b20">[21]</ref> and tool flow <ref type="bibr" target="#b21">[22]</ref> were developed. The NoC used in the context of Scalopes (Aethereal/aelite) provided an inspiration for the asynchronous NoC developed in T-CREST. However, the T-CREST NoC uses an architecture that reduces systemlevel cost significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Time-Predictable Processors</head><p>Within T-CREST we used the results from the memory access arbitration and adapted the cache solutions <ref type="bibr" target="#b22">[23]</ref> from the Java processor JOP. JOP is a time-predictable processor that uses Java bytecode as its instruction set. In contrast, the T-CREST processor Patmos uses a RISC instruction set to enable the execution of more traditional languages like C. A key feature of JOP is its cache architecture, with an instruction cache that caches whole methods <ref type="bibr" target="#b23">[24]</ref> and separate caches for stack and heap data. Patmos keeps this general cache architecture, but adapts it to fit a RISC instruction set <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. Within the T-CREST project, we also adapted the analysis methodology developed for the object cache of JOP <ref type="bibr" target="#b24">[25]</ref> in the analysis tool platin <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>The focus of the precision timed (PRET) machine <ref type="bibr" target="#b27">[28]</ref> is primarily on repeatable timing and less on predictable timing. A deadline instruction can be used to enforce repeatable timing of a task. A first simulation of their PRET architecture is presented in <ref type="bibr" target="#b28">[29]</ref>. The first hardware implementation of PRET implements the ARM instruction set <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref>. PRET implements a RISC pipeline and performs chip-level multithreading for four threads to eliminate data forwarding and branch prediction <ref type="bibr" target="#b31">[32]</ref>. Scratchpad memories are used instead of instruction and data caches.</p><p>A recent version of PRET, FlexPRET <ref type="bibr" target="#b32">[33]</ref>, extends PRET to support mixedcriticality systems. FlexPRET supports two different thread types, hard and soft real-time threads, directly in the hardware. Both thread types have fixed slots assigned in the fine-grain thread scheduling. However, soft real-time threads can use slots that are not used by a hard real-time thread (e.g., because of stalling or a thread has finished its current release). FlexPRET switched the instruction set to RISC V <ref type="bibr" target="#b33">[34]</ref>.</p><p>The main difference between our proposal and PRET is that we focus on time predictability <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36]</ref> and PRET on repeatable timing. Our approach therefore allows run-time dynamism in scheduling and execution, whereas PRET is essentially static, resulting in a higher implementation cost. In our opinion a time-predictable architecture does not need to provide repeatable timing as long as WCET analysis can deliver tight WCET bounds. Furthermore, PRET implements the standard instruction set, whereas we explore an instruction set that supports WCET based optimization and WCET analysis. In contrast to the PRET we use a dual-issue pipeline for maximum single thread performance. For multi-threaded applications we provide a multi-core version of Patmos.</p><p>Fernandez et al. <ref type="bibr" target="#b36">[37]</ref> present a detailed study of task interference in a Leon4 based quad-core processor developed by Aeroflex Gaisler and used by the European Space Agency. The processor is a conventional multiprocessor that has been developed with critical real-time systems in mind. The study shows that interference may cause the execution time of a task to increase by a factor of 2-9 times. The results are a strong argument in support of time-predictable multi-core architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Core-to-Core Network-on-Chip</head><p>To achieve time-predictability of the on-chip communication, the NoC needs to provide end-to-end connections that can be analyzed individually. Ways to implement end-to-end connections are circuit-switching (physical or virtual) or by controlling the rate of traffic flows.</p><p>SoCBUS <ref type="bibr" target="#b37">[38]</ref> and the NoC used in the 4S-platform <ref type="bibr" target="#b38">[39]</ref> implement pure circuit switching. In this approach it is straightforward to analyze the circuits provided. However, the 4S platform NoC uses static circuits. This limits flexibility and may potentially waste resources and the approach is best suited for relatively static streaming applications. In this respect SoCBUS is more flexible but its dynamic dial-up mechanism does not in itself guarantee the establishment of a circuit in bounded time. To establish a bound some form of system level analysis is needed. TDM as used in Argo always guarantees the connections established in the schedule and offers more flexibility on the sharing of resources.</p><p>Virtual circuit switching is an alternative approach and TDM is a way to implement virtual circuit in a time-multiplexing way. NoCs that follow the TDM approach are AEthereal <ref type="bibr" target="#b39">[40]</ref>, aelite <ref type="bibr" target="#b40">[41]</ref>, Nostrum <ref type="bibr" target="#b41">[42]</ref> and TTNoC <ref type="bibr" target="#b42">[43]</ref>, <ref type="bibr" target="#b43">[44]</ref>, and Argo. Argo differs in its novel timing organization. Argo employs an asynchronous implementation of routers and a novel network interface design for a reduced system-level cost.</p><p>An alternative approach for time predictability is to apply rate control in the traffic flows. MANGO <ref type="bibr" target="#b44">[45]</ref> and the Kalray NoC <ref type="bibr" target="#b45">[46]</ref> follow this approach. MANGO implements an arbitration mechanism for virtual channels on links and Kalray NoC enforces a throughput limit on traffic flows. Schedulability analysis <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b47">48]</ref> and network calculus <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50]</ref> are analytical approaches that aim at solving the contention problem and offering time-guarantees. However, the above techniques lead to high cost in the router implementation. Argo avoids this implementation complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">External Memory Access</head><p>External memory access in the T-CREST platform is provided by connecting the cores via a tree-shaped memory interconnect to a memory controller backend. Using a tree-shaped interconnect is motivated by two criteria: (1) a task's memory communication and inter-task communications requirements are not necessarily the same and (2) conventional arbiters do not scale to today's multicore requirements <ref type="bibr" target="#b50">[51]</ref>.</p><p>Separating the requirements of memory access and task communication is nothing new, for example the MEDEA architecture <ref type="bibr" target="#b51">[52]</ref> provides separate arbitration for both communication and memory requests. The Tilera Tile processor <ref type="bibr" target="#b52">[53]</ref> incorporates entirely separate networks for tile-to-tile accesses, I/O accesses, and shared memory accesses. While these works separate the inter-core and memory communication into distinct networks, no work currently separates them into entirely different network topologies.</p><p>Tree-based interconnects have been used in other work to connect processors to memory. Balkan and Uzi <ref type="bibr" target="#b53">[54]</ref> and Rahimi et al. <ref type="bibr" target="#b54">[55]</ref> use a "mesh-of-trees" approach in order to connect multiple processors to multiple memory banks. The approach presented here uses a similar, but simpler interconnect, since only one memory "bank" is used.</p><p>The tree approach also allows for scalable arbitration within interconnects, which are distributed across the tree, rather than being realized as a single large arbiter. Small TDM arbiters at the leaves of the tree can control the access to the memory tree in a scalable distributed way <ref type="bibr" target="#b55">[56]</ref>.</p><p>Another tree-based approach is presented by Gomony et al. <ref type="bibr" target="#b50">[51]</ref>, but encodes a priority within each packet and uses a generic arbitration framework. Each multiplexer then admits the packet with the highest priority. This has the advantage of being able to issue requests in work-conserving mode by adding a fixed offset to the static priority if the requestor is exceeding its given bounds. Both show that using a distributed approach allows the memory interconnect to run at a much higher frequency, although both approaches require global clock synchronization.</p><p>The T-CREST memory controller back-end differentiates from related memory controller back-ends by considering the following two challenges: (1) memory clients in complex systems comprising multiple types of processing elements that may have different request sizes and (2) different systems require different tradeoffs between (worst-case) execution time, bandwidth, and power consumption.</p><p>Existing memory controller back-ends do not fully satisfy these diverse requirements as most current controllers are not designed with real-time applications in mind and do not provide bounds on WCET of transactions <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b58">59]</ref>. On the other hand, existing real-time memory controllers are using either (semi-)static command scheduling and cannot provide low average execution time to memory traffic <ref type="bibr" target="#b59">[60,</ref><ref type="bibr" target="#b60">61,</ref><ref type="bibr" target="#b61">62]</ref> or dynamic scheduling, but are limited in architecture or analysis to a single transaction size and memory map configuration <ref type="bibr" target="#b62">[63,</ref><ref type="bibr" target="#b63">64,</ref><ref type="bibr" target="#b64">65]</ref>.</p><p>Looking more specifically at work from related projects, the PRET memory controller <ref type="bibr" target="#b61">[62]</ref> aims at achieving repeatable and predictable timing by mapping memory clients to privatized memory banks that are then accessed using timedivision multiplexing. The command scheduling of each memory request is done statically and takes a fixed amount of time. The benefit of this scheme is that memory clients cannot interfere with each other's bank state by e.g., closing rows opened by another thread. The drawback of this approach is that the number of threads is limited by the number of available memory banks, making this solution unsuitable for the T-CREST project</p><p>The MERASA memory controller <ref type="bibr" target="#b65">[66]</ref> is more similar to the T-CREST memory controller in the sense that it does not privatize memory banks and uses dynamic command scheduling. The command-scheduling algorithm is a modified version of the DRAMSim memory simulator <ref type="bibr" target="#b66">[67]</ref>, although the modifications to the original scheduling algorithm are not specified and there is no hardware implementation. In addition, the analysis is limited to a fixed transaction size and a single memory map configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Compiler</head><p>The WCET-aware C compiler (WCC) <ref type="bibr" target="#b67">[68,</ref><ref type="bibr" target="#b68">69]</ref> is a custom developed C compiler that focuses on WCET optimization, targeting Infineon TriCore microcontrollers. The AbsInt aiT tool performs WCET analysis. Analysis results such as basic block execution times, encountered instruction cache misses, or the found worst-case path are back-annotated to the intermediate representation of WCC to be used by high-level optimizations. For this, all optimization and transformation passes in WCC need to maintain a mapping between the blocks of the intermediate and low-level representations. The work on the WCC compiler done in the PREDATOR project represents an important first step towards developing WCET-aware compilation techniques for single-core architectures by selecting between alternative code sequences.</p><p>In contrast to the WCC compiler, the T-CREST compiler is based upon an existing open-source, industrial-strength compiler, the LLVM <ref type="bibr" target="#b69">[70]</ref> framework. General and target-independent compiler passes and tools such as the platin toolkit are complemented by dedicated support for architecture-specific features of Patmos, which has been co-designed together with the hardware platform itself.</p><p>Kirner et al. transform flow information in parallel to high-level optimizations <ref type="bibr" target="#b70">[71]</ref>. Their transformation technique requires the compiler to generate control flow update rules for optimizations that modify the control-flow graph or change loop bounds or other flow constraints. These update rules specify the relation between edge-execution frequencies before and after the optimization, and are used to consistently transform all flow constraints affected by the optimization.</p><p>In contrast to this work and the WCC compiler, in the T-CREST compiler framework existing compiler passes are not modified to maintain any mappings or to record all performed transformations. Instead, the compiler uses novel techniques to transform metainformation among different levels of program representation. A combination of source code markers, compiler analyses, and relation graphs is used to transform flow facts and to back-annotate analysis results. This approach enables a simple integration of WCET analyses and the LLVM framework, and allows existing high-level compiler analyses to improve the precision of the WCET-analysis result. Few code transformation techniques other than the single-path approach have been proposed that target the time-predictability of programs. Negi et al. <ref type="bibr" target="#b71">[72]</ref> presented a transformation to reduce the number of paths required to be analyzed by making infeasible paths explicit or by factoring out code blocks with constant execution time. Both transformations seem hard to be performed automatically in a compiler and no general solution has been supplied so far.</p><p>The implementation of single-path code generation in a compiler backend has been proposed long ago <ref type="bibr" target="#b72">[73]</ref> but has never been actually implemented before. Yan and Zhang <ref type="bibr" target="#b73">[74]</ref> study the application of the single-path approach at the assembly level by a compiler in the context of a compilation framework for VLIW processors. They limit their investigation of the single-path approach to basic blocks of innermost loop regions, omitting loop transformation and interprocedural support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.">WCET Analysis</head><p>A comprehensive survey of methods and tools for determining the WCET is given in <ref type="bibr" target="#b74">[75]</ref>. The most successful formal method for WCET computation is static program analysis based on abstract interpretation. Static program analyzers compute information about the software under analysis without actually executing it. Most interesting program properties-including the WCET-are undecidable in the concrete semantics. The theory of abstract interpretation <ref type="bibr" target="#b75">[76]</ref> provides a formal methodology for semantics-based static analysis of dynamic program properties where the concrete semantics is mapped to a simpler abstract semantics. The static analysis is computed with respect to that abstract semantics, enabling a trade-off between efficiency and precision. A static analyzer is called sound if the computed results hold for any possible program execution. Applied to WCET analysis, soundness means that the WCET bounds will never be exceeded by any possible program execution. Abstract interpretation supports formal soundness proofs for the specified program analysis.</p><p>In addition to soundness, further essential requirements for static WCET analyzers are efficiency and precision. These properties are related to the predictability of the hardware <ref type="bibr" target="#b76">[77,</ref><ref type="bibr" target="#b77">78]</ref> and software <ref type="bibr" target="#b78">[79]</ref> that is being analyzed.</p><p>Over the last few years, a more or less standard architecture for timing analysis tools has emerged <ref type="bibr" target="#b79">[80,</ref><ref type="bibr" target="#b80">81]</ref> which is composed of three major building blocks: (1) control flow reconstruction and static analyses for control and data flow, (2) micro-architectural analysis, computing upper bounds on execution times of basic blocks, and (3) path analysis, computing the longest execution paths through the whole program.</p><p>The commercially available tool aiT<ref type="foot" target="#foot_1">2</ref>  <ref type="bibr" target="#b81">[82,</ref><ref type="bibr" target="#b82">83]</ref> implements the architecture outlined above. The tool has been successfully employed in the avionics <ref type="bibr" target="#b83">[84,</ref><ref type="bibr" target="#b84">85]</ref> and automotive <ref type="bibr" target="#b85">[86]</ref> industries to determine precise bounds on execution times of safety-critical software.</p><p>Heptane <ref type="foot" target="#foot_2">3</ref> is an open-source static WCET analysis tool developed at IRISA.</p><p>While it initially used a tree-based WCET computation approach <ref type="bibr" target="#b86">[87]</ref>, more recent versions use-like most other WCET analysis tools-an integer linear programming approach. OTAWA <ref type="foot" target="#foot_3">4</ref> is an open-source static WCET analysis framework developed at the University of Toulouse <ref type="bibr" target="#b87">[88]</ref>. It is designed to enable the combination of analysis algorithms and to simplify the implementation of new approaches.</p><p>WCA is the WCET analysis tool for the Java processor JOP <ref type="bibr" target="#b88">[89]</ref>. While the former presented WCET analysis tools target several general-purpose embedded processors, WCA was specifically designed for the time-predictable processor JOP. This tight coupling of the hardware design and WCET analysis enabled co-design of architectural features and their analysis, e.g., an object cache and its analysis <ref type="bibr" target="#b24">[25]</ref>. Within T-CREST we approached the design of the architecture in a similar way by getting feedback from the WCET analysis tool aiT on Patmos features.</p><p>An alternative to static WCET analysis is measurement-based WCET analysis. On the one hand, measurement-based WCET analysis does not require a formal model of the processor and therefore promises easy adaption to new architectures. On the other hand, it faces the challenge that it is difficult to provoke a worst-case scenario during the measurements and guarantee the soundness of the WCET bound. An example for a commercial measurement-based WCET analysis tool is RapiTime<ref type="foot" target="#foot_4">5</ref> by Rapita Systems <ref type="bibr" target="#b89">[90]</ref>. The MERASA project used both OTAWA and RapiTime to evaluate their hardware design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The Processor</head><p>The basis of a time-predictable system is a time-predictable processor. Within T-CREST we developed the time-predictable processor Patmos <ref type="bibr" target="#b0">[1]</ref>. Patmos is a 32-bit, RISC-style microprocessor optimized for time-predictable execution. The user can configure Patmos to include a two-way pipeline for high performance or a single-way pipeline to save hardware resources.</p><p>Patmos is statically scheduled, in the sense that all instruction delays are explicitly visible at the instruction set architectural (ISA) level and the programmer or compiler need to respect the pipeline delays to guarantee correct execution. This approach simplifies the processor model for WCET analysis and helps to improve the latter's accuracy.</p><p>The modeling of the memory hierarchy is critical for WCET analysis. Patmos simplifies this task by offering caches that are especially designed for WCET analysis. Accesses to different data areas are different with respect to WCET analysis. Static program analysis can easily track addresses of static data, constants, and stack allocated data. Heap allocated data on the other hand demands for different caching techniques to be analyzable <ref type="bibr">[91]</ref>. Therefore, Patmos contains two data caches, one for the stack and one for other data. Access to non-analyzable addresses (e.g., heap allocated structures) bypass the data cache with the non-cached load and store instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Fully Predicated Instruction Set</head><p>The Patmos instruction set is similar to a RISC style load/store instruction set. Instructions take at most three register operands. Only the first pipeline executes control-flow instructions and instructions that access memory, while both pipelines can execute arithmetic and logic instructions.</p><p>To reduce the number of conditional branches and to support the single-path programming paradigm <ref type="bibr" target="#b91">[92,</ref><ref type="bibr" target="#b92">93]</ref>, the compiler can predicate all instructions. Compare instructions, which the compiler can predicate as well, set predicates.</p><p>Patmos has 8 predicate registers; logic operations like AND and OR operate directly on these predicate registers.</p><p>Apart from the usual encoding of constants in the 32-bit instruction words, Patmos also supports operations with 32-bit constants, where the second slot of the instruction bundle contains the constant. This feature is also present if Patmos contains only a single pipeline.</p><p>The type of the accessed data area is explicitly encoded with the load and store instructions. This feature helps the WCET analysis to distinguish between the different data caches. Furthermore, an earlier stage in the pipeline can detect which cache a load or store instruction will access.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Dual-Issue Pipeline</head><p>Patmos contains 5 pipeline stages: (1) instruction fetch, (2) decode and register read, (3) execute, (4) memory access, and (5) register write back. Figure <ref type="figure" target="#fig_1">2</ref> shows an overview of Patmos' pipeline.</p><p>The two pipelines share the register file with 32 registers. Patmos supports full forwarding between the two pipelines. The basic features are similar to a standard RISC pipeline. Patmos splits the data cache for different cache areas. Typed load and store instructions distinguish between the different caches. To simplify the diagram in Figure <ref type="figure" target="#fig_1">2</ref>, we omitted forwarding and external memory access data paths. We implemented the method cache (M$), the register file (RF), the stack cache (S$), the data cache (D$), and the scratchpad memories (SP) in on-chip memories of an FPGA. All on-chip memories of Patmos use registered input ports. As we cannot access the memory-internal input registers, we duplicate the program counter (PC) with an explicit register. The instruction register (IR) stores the instruction fetched from the method cache.</p><p>The register file is using that instruction also to fetch the two (four in a dual issue configuration) register values during the decode stage.</p><p>As Patmos provides full forwarding from both pipelines, this forwarding network consumes a lot of resources. If the full power of dual issue is not needed, the user can configure Patmos as single-issue pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Local Memories</head><p>Patmos contains three caches (method, data, and stack cache). The size of all caches can be configured before the hardware generation. Patmos also contains (optional) scratchpad memories (SPMs) for instructions and data. A program can use these SPMs in addition to caches or instead of caches, when code and/or data caching shall be under program control.</p><p>To distinguish between the different caches and SPMs, Patmos implements typed load and store instructions. The compiler (for the stack cache) or the programmer (for the data SPM and IO devices) assigns the type information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">Method Cache</head><p>Patmos contains a method cache <ref type="bibr" target="#b1">[2]</ref> that stores whole functions. We use the term method cache as this form of caching has been originally introduced for a Java processor <ref type="bibr" target="#b23">[24]</ref>. Caching whole functions means that the processor may load full functions on a call or a return. All other instructions of Patmos hit in the method cache. Our assumption is that those possible miss points allow for an easier and more precise WCET analysis. We developed a scope based WCET analysis for this method cache <ref type="bibr" target="#b26">[27]</ref>.</p><p>The assumption of a method cache is that the cache is larger than all individual functions in a program. However, not all programs guarantee this assumption. Furthermore, an optimizing compiler inlines functions to avoid the call and return overhead, leading to even bigger functions. To mitigate this issue we have implemented a function splitter that splits too large functions into smaller (sub)functions that fit into the cache (see Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">Stack Cache</head><p>The latency bounds of memory accesses are crucial for time-predictability.</p><p>For the calculation of the WCET bound, cache analysis tries to statically predict hits and misses <ref type="bibr" target="#b93">[94]</ref>. With a known address of a load or store instruction we can classify the operation as a hit or miss. Addresses of heap-allocated data are only known at runtime and therefore not statically predictable. Since accessing an unknown address can destroy the cache state during analysis, we use a separate cache for stack allocated data, which improves the time-predictability of the design. This design separates predictable and unpredictable load and store operations to different caches (or uncached accesses). Without dynamically sized stack objects, we can statically determine the addresses of data allocated on the stack. Moreover, a dedicated stack cache reduces the number of loads from the data cache and decreases the number of slow main memory accesses. Furthermore, it eliminates some long latency stores to the write-through data cache, thereby reducing the WCET of the design.</p><p>The stack area in a program contains the return address, registers saved by the current function, and local variables and data structures. Particular uses of the stack in C-like languages (e.g., dynamic allocation, passing pointers to addresses on the stack, stack objects exceeding the stack cache size) are not directly supported by the predictable stack cache design. For this reason, the compiler manages a shadow stack outside the stack cache, where objects not appropriate for the stack cache are allocated.</p><p>The Patmos stack cache <ref type="bibr" target="#b2">[3]</ref> provides a window into the main memory, implemented using only two processor-internal registers. Three instructions manipulate the stack cache: (1) reserve reserves space in the stack cache, (2) free frees space on the stack cache, and (3) ensure forces data to be available in the stack cache. Only the reserve and ensure instructions may trigger a possible exchange with the main memory (spill and fill). All stack cache load and store instructions hit in the stack cache and thus we model them as single cycle operation for the WCET analysis. The extent to which stack manipulation instructions actually cause memory transactions can be statically predicted <ref type="bibr" target="#b94">[95]</ref>. A specialized analysis bounds the stack cache utilization throughout the program and remains scalable by only introducing context-sensitivity when needed.</p><p>Call stacks are usually shallow and standard optimizations available in modern compilers (e.g., LLVM) are effective at reducing stack frame sizes; therefore, even a small stack cache provides good hit rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3.">Data Cache</head><p>We have two implementations of the data cache: (1) a direct-mapped cache and (2) a two-way set-associative cache with a least recently used (LRU) replacement policy. Set-associative caches, as long as they use the LRU replacement strategy, are very predictable and fully supported by the aiT WCET analysis tool. The data caches use write-through and no allocation on a write. We chose write-through as it is hard to predict statically when a write-back operation happens, and thus many state-of-the-art WCET analysis tools do not support write-back caches. The design decision to use a write-through policy is an excellent example how WCET analyzability influences the hardware design for a time-predictable processor-we optimize for the WCET. A write-back cache would actually increase the WCET bound, as each cache miss penalty includes a possible cache write-back. To mitigate the performance effects of the write-through policy, we implemented a small buffer that combines writes into bursts.</p><p>For statically unknown load and store addresses, Patmos has load and store instructions that bypass all caches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4.">Miss Detection and Pipeline Stalling</head><p>The cache configuration of Patmos is special with respect to miss detection: for all three caches, the memory stage detects all misses and stalls the pipeline. This is normal for a data cache, but a standard instruction cache misses in the fetch stage. However, the method cache performs miss detection only on call and return. Therefore, these instructions can stall as well in the memory stage.</p><p>The consequence of a single stalling pipeline stage is twofold: (1) the hardware implementation of stalling is simpler and (2) cache analysis becomes simpler. No two instructions can trigger a cache miss in the same clock cycle for two caches. We consider this feature to contribute to a timing-composable architecture, as we can analyze different caches independently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The Core-to-Core Message Passing Network-on-Chip</head><p>The core-to-core communication NoC is packet switched and it uses source routing. The topology is a bi-torus. The NoC supports asynchronous message passing across point-to-point virtual circuits, and it implements these using DMA-driven block-transfers from the local SPM in one processor node into an SPM in a remote node. We named the T-CREST NoC Argo.</p><p>We can implement virtual circuits using (statically scheduled) time division multiplexing (TDM) of the resources (routers and links) in the NoC or by using non-blocking routers in combination with a rate-controlled service discipline <ref type="bibr" target="#b95">[96]</ref>. We decided for a TDM-based NoC for two reasons: (i) A TDM router avoids dynamic arbitration and virtual channel buffers and its hardware implementation is correspondingly simple. (ii) TDM avoids interference of traffic and timing analysis is straightforward. In a TDM-based NoC, the network interface (NI) injects packets into the network of routers and links according to a predetermined periodic and static schedule. The schedule determines when the NI injects a packet for a given destination into the packet-switched NoC, and once injected the packet travels along a pipelined path from source to destination. The schedule guarantees absence of deadlocks, and the fact that it avoids arbitration, buffering, and flow control results in small and efficient circuit implementations. For symmetric networks and an all-to-all communication pattern we found a simple heuristics to generate the TDM schedule <ref type="bibr" target="#b96">[97]</ref>. For application specific schedules we use a metaheuristic scheduler <ref type="bibr" target="#b97">[98]</ref>.</p><p>The functionality of the T-CREST core-to-core NoC is similar to the aelite NoC <ref type="bibr" target="#b98">[99]</ref>. The key contribution of the T-CREST project is the novel hardware architecture that results in a more efficient and smaller circuit implementation that we present below.</p><p>A traditional implementation, illustrated in Figure <ref type="figure" target="#fig_2">3</ref>, implements a transmit/receive buffer and a DMA controller in both ends of every single virtual circuit. The DMA controllers transmit and receive packets to/from buffers in the NI. Data moves across the NoC from the NI in the source to the NI in the destination using a static TDM schedule. The result is that data moves from the sending processor node to the receiving processor node in three steps: (i) from the sending processor into the NI, (ii) from this NI across the network of routers and links and into the destination NI, and (iii) from this NI into the receiving processor node. And because these steps are independent/autonomous, flow control has to be introduced to avoid overflow and underflow of buffers in the NIs. In this way the NoC as a whole does not enjoy the benefits of TDM-that it eliminates the need for arbitration, buffering, and flow control. By rethinking the architecture and keeping the essence of TDM in mind we have developed a new architecture <ref type="bibr" target="#b99">[100]</ref> where we have moved the DMA controllers into the NIs and integrated them with the TDM scheduling, see Figure <ref type="figure" target="#fig_3">4</ref>. As the TDM schedule interleaves the DMA transfers out of a processor node, only one DMA controller can be active at a time. This allows a single table-based implementation of all the pointers and counters of all the DMA controllers. In combination with a single shared SPM in every processor this allows TDM driven data transfer from the source SPM to the destination SPM without any buffering or flow control, as illustrated in <ref type="bibr" target="#b99">[100]</ref>. The DMA moves data out of a processor node in an interleaved fashion across a sequence of TDM schedule periods. Therefore, the size of a TDM slot (and the resulting packet size) can be small, which helps to keep the latency short. This new architecture results in substantial area reductions in the NIs.</p><p>Another key feature of the architecture is its efficient support of a globallyasynchronous locally-synchronous (GALS) timing organization of the entire platform. The new architecture avoids all clock domain crossings (and all the associated synchronization and metastability issues) except for the interface used by the processor to set up the DMA controller. Here a clock domain crossing module (CDC) must be used as illustrated in connect the NIs must offer some timing elasticity. This is traditionally provided by adding dual-clock FIFOs in every input port of every router as illustrated in Figure <ref type="figure" target="#fig_2">3</ref>. The addition of these FIFOs roughly doubles the area and power consumption of a clocked synchronous router <ref type="bibr" target="#b4">[5]</ref>. Our NoC uses asynchronous routers instead and as asynchronous pipelines inherently behave as self-timed ripple FIFOs we avoid these explicit synchronizer FIFOs. The asynchronous router uses the same three stage pipelined design as the synchronous router, the only difference is the use of asynchronous handshake latches instead of clocked registers, as Figure <ref type="figure" target="#fig_11">5</ref> shows. The three pipeline stages of the router are: (i) link traversal, (ii) header-parsing unit (HPU), and (iii) the crossbar switch (Xbar). The handshake latch used in our design consists of a normal enable latch and a handshake controller that implements a two-phase (NRZ) bundled-data protocol <ref type="bibr" target="#b101">[102]</ref>. We present the asynchronous router design in more detail in <ref type="bibr" target="#b4">[5]</ref>.</p><p>Figure <ref type="figure" target="#fig_5">6</ref> shows the packet format used in our architecture. A packet consists of three phits, a header phit and two payload phits. A phit is the smallest atom that is transmitted in a (clock) cycle. Each phit contains a 32-bit word and three additional control bits that define whether the phit is a header phit (start) of a packet (sop) or the end phit of a packet (eop) and whether it is a valid phit or not (vld). The header phit contains the route and the destination write address (wp). The HPU stage in the router decodes the route field of the header phit and provides control signals to the crossbar to direct the packet to the correct output port.</p><p>The fact that the NoC allow some skew between the NIs does not affect the WCET analysis of the time it takes to transmit a message across the NoC. As all the NIs operate using a single clock source, analyzing the WCET is basically a matter of counting cycles, and in a statically scheduled TDM-based  NoC this is straightforward: The time to transmit a packet is the worst case wait for the first slot reserved, plus the time it takes to transmit the data in a sequence of reserved slots, plus finally the time it takes the last package of the message to traverse the NoC. This is all a matter of counting NI clock cycles.</p><p>The skew between the source and destination NI adds just a few clock cycles of uncertainty/variation and this is negligible. Instances of Argo were implemented in ASIC and FPGA technologies. The implementation technology for the ASIC flow is a 65 nm CMOS standard cell STMicroelectronics library and the target FPGA board is a Xilinx ML605 board. Table <ref type="table" target="#tab_0">1</ref> shows area results for the components of the NoC; a router and a NI.</p><p>Detailed results of the implementation of the components appear in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b99">100]</ref>.</p><p>The asynchronous design of the routers provides time elasticity. In <ref type="bibr" target="#b5">[6]</ref> we analyze a network of such routers and show that it can tolerate several cycles of skew between the NIs. In conclusion the use of asynchronous routers offers more timing elasticity than clocked mesochronous routers and at the same time the hardware area of an asynchronous router is approximately half of the area of a mesochronous clocked router <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>Overall, the entire NoC was implemented in 2x2 and 4x4 instances, which were verified to operate under skew. A 4x4 instance of Argo, with all-to-all communication (240 uni-directional channels) and schedule period of 23 timeslots, implemented in ASIC technology consumes an area of 0.72 mm 2 . A similar instance of aelite with 11 NIs, 6 routers and 45 bi-directional channels consumes an area of 2.5 mm 2 <ref type="bibr" target="#b40">[41]</ref>. The two instances are not directly comparable but the numbers indicate that Argo is at least 3.5 times smaller than alternative TDM NoCs, since aelite is already a very small NoC.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The Memory Hierarchy</head><p>This section presents the memory hierarchy of the T-CREST platform and explains how to provide time-predictable access to off-chip DRAM. The two key requirements for the DRAM sub-system are: (1) it must be a time-predictable architecture and have an analysis that is able to tightly bound the response time of a memory transaction, and ( <ref type="formula">2</ref>) it has to scale to a large number of processing elements to fit in a multi-core environment.</p><p>The DRAM sub-system comprises three components, the Bluetree memory tree, a prefetcher, and a dynamically scheduled SDRAM back-end, as shown in Figure <ref type="figure" target="#fig_7">7a</ref>. These components are described in the following sections, starting with Bluetree in Section 5.1, followed by the prefetcher in Section 5.2 and the back-end in Section 5.3. Section 5.4 then presents the WCET of a memory request accessing the DRAM through the memory tree for different numbers of contending processors and compares to the case of a TDM-based memory tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">The Bluetree Memory Tree</head><p>The Bluetree memory tree <ref type="bibr" target="#b102">[103]</ref> is a memory interconnect motivated by the growing bandwidth requirements of modern embedded systems, along with the need to decouple the memory requirements of a task from its communication requirements; a mapping on a Manhattan grid NoC, which allows a set of tasks to meet their communication deadlines, may not allow all high-bandwidth memory clients to meet their requirements, and vice versa.</p><p>In addition, conventional monolithic arbiters cannot scale to the requirements of modern systems. Typical arbiters demultiplex the input stream into a number of virtual channels, perform accounting on these channels, and then multiplex those virtual channels back onto the output stream. As the number of virtual channels increases, the complexity and size of the multiplexer/demultiplexer increase, which in turn results in a slower maximum clock speed <ref type="bibr" target="#b103">[104]</ref>.</p><p>We designed the Bluetree memory interconnect to support the memory requirements of modern systems, leaving the TDM-based NoC for core-to-core communication only. This tree does not allow for communication between processing nodes, only from processing nodes to main memory. The design distributes memory arbitration across the routers, rather than using a large monolithic arbiter next to memory. This allows the tree to fulfill the scalability requirements of the system, enabling a larger number of requesters at a higher clock frequency than would be available with a single monolithic arbiter.</p><p>This tree consists of a set of 2-into-1 full-duplex multiplexers, each with a small arbiter. Figure <ref type="figure" target="#fig_7">7b</ref> shows a block diagram of the internals of one of these multiplexers. Each of these multiplexers contains two input FIFOs, which are then multiplexed onto an output FIFO through a simple arbiter. The downward path contains a single register and is, per definition, non-blocking. The content of this register moves each cycle towards the correct client. We combine these multiplexers into a system such as the one shown in Figure <ref type="figure" target="#fig_7">7a</ref>.</p><p>In order to prevent a single core dominating the tree, and to be able to satisfy the requirement that the memory subsystem can be time-predictable, each multiplexer contains a blocking counter. This encodes the number of times that a high-priority packet (i.e., a packet from the left) has blocked a lowpriority packet (i.e., a packet from the right). When this counter becomes equal to a fixed value m, the counter is reset and a single low-priority packet is given service. This then allows providing an upper bound of the WCET for a memory transaction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Prefetcher</head><p>Another issue with shared memory is the potentially large worst-case response time for memory transactions (as Table <ref type="table" target="#tab_1">2</ref> shows). The prefetcher can, to some extent, hide this latency. This is a hardware unit that attempts to speculatively issue memory requests for data, which the processor may require in the near future.</p><p>Such a technique is typically not employed within real-time systems due to the unpredictability that such a unit can introduce; a useless prefetch will tie up the memory controller for a period of time and introduce additional blocking for other tasks. If the prefetcher dispatches useless prefetches, and does so without any consideration for any other tasks, it is possible that the prefetcher may actually harm the worst-case response time of the system. This is undesirable since the worst-case analysis of the system is then invalidated by the inclusion of the prefetcher.</p><p>Instead, we propose a prefetching approach that we can use alongside standard worst-case analysis, to improve the average case while we maintain the required time predictability of the system <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b104">105]</ref>. We make the observation that bandwidth provisioning is typically static, and may not be fully utilized by a task during its whole life-cycle. Typically in these cases, arbiters allow other tasks that have fully utilized their bandwidth bound to request in workconserving mode. In the context of Bluetree, if a low-priority packet is given service without being blocked by a high-priority packet, or m high-priority packets are given service without any being blocked by a low-priority packet, the arbiter is operating in work-conserving mode. In these cases, rather than relaying a request in work-conserving mode, the prefetcher can use this slot. The prefetcher fills an empty packet and transmits it to memory. Since, in the context of system analysis, this slot would have been a memory request normally, this approach requires no modification to the system analysis, and allows for prefetching without harming the worst-case execution time.</p><p>Another inherent problem with prefetching is that the prefetcher inserts the data into a processor's cache that may displace useful information, thus effectively invalidating any cache analysis that has already taken place to ascertain a worst-case execution time. In order to alleviate this issue, we add a small "prefetch cache" in-between the processor and the first multiplexer. This is a small direct-mapped cache that stores incoming prefetches, and then relays them to the processor when requested. This has the same line size as a Bluetree request (i.e., 16 bytes), and logically requires as many indices as the number of possible prefetch streams, which is eight in this case, thus needs to be of size 128 bytes. In reality, this is slightly larger (i.e., 512 bytes) in order to alleviate any cache locality issues.</p><p>After a prefetch has taken place and it was useful to the processor, the prefetch cache relays a "prefetch hit" message back to the prefetcher on the same cycle that the processor accesses the data. This is then used to generate another prefetch on behalf of that processor. Since this packet would have been a memory request for the aforementioned data, a prefetch can also be safely transmitted in this case, since the prefetch replaces the memory request that would have taken place had the prefetcher not been operating, and hence the "prefetch hit" packet can also use the slot.</p><p>Given this analysis, we use a simple stream prefetcher within this framework.</p><p>Stream prefetching <ref type="bibr" target="#b105">[106]</ref> makes the assumption that if the data at addresses A, A + 1, and A + 2 has been requested, it is likely that the data at address A + 3 will be required in the near future. We can also use other approaches such as stride prefetching <ref type="bibr" target="#b106">[107]</ref>, Markov prefetching <ref type="bibr" target="#b107">[108]</ref>, or global history buffer based approaches <ref type="bibr" target="#b108">[109]</ref> with this framework without harming the WCET of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Time-predictable SDRAM Back-End</head><p>This section presents our time-predictable dynamically scheduled memory controller back-end. The two main contributions of the T-CREST memory controller back-end are: (1) the architecture and the dynamic command scheduling algorithm are time-predictable, (2) the analysis supports different request sizes and memory map configurations, enabling the designer to choose the number of parallel banks to serve a transaction. This allows trade-offs between bandwidth, (worst-case) execution time, and power consumption <ref type="bibr" target="#b109">[110]</ref>.</p><p>The off-chip memory on the Xilinx ML-605 development board, used in PHY only offers a 32-bit interface. The SDRAM back-end interfaces with this memory and is responsible for generating and scheduling commands to access the memory according to the incoming requests in a time-predictable manner, while satisfying the minimum timing constraints between the commands.</p><p>We implemented the back-end architecture in VHDL and it has five pipeline stages, as shown in Figure <ref type="figure" target="#fig_8">8</ref>. After a transaction arrives at the interface of the back-end, Stage 1 obtains the relevant information, including the transaction type (read or write), logical address, and the required number of bursts for the given transaction size. Stage 2 splits the transaction into the required number of bursts, and translates the target address to the corresponding physical address (bank, row and column) in the memory. Thereafter, the command generator in Stage 3 produces the required activate, read, write, and precharge commands for each burst. To prevent the memory from losing data, refresh commands are also generated periodically every 7.8 µs. The generated commands are then inserted into the command FIFO. In Stage 4, the timing selector is responsible for checking the associated timing constraints for scheduling the command at the head of the command FIFO. The command scheduler issues the command in Stage 5 if the timing constraints are satisfied. The action in each stage consumes one clock cycle, except burst splitting in Stage 2, which requires one cycle per burst, and command generation in Stage 3, which takes one cycle per command.</p><p>The back-end runs at a frequency of 150 MHz, while the memory itself runs at 300 MHz. This means that the data path of the memory controller works with 128 bit words provided by the memory tree internally, but reads or writes 4x 32-bit words per clock cycle to the memory to compensate for the double frequency (150 MHz to 300 MHz) and the double data rate (two data transfers per 300 MHz clock cycle).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">WCET of a Memory Transaction</head><p>Having presented the concepts and architectures of the memory tree and the memory controller back-end, we now consider the WCET of a single outstanding memory request in the T-CREST platform for a varying number of processors, and hence for different tree depths, and compare to the case of a TDM-based system. Note that it is assumed that application software has been mapped to cores within the architecture prior to WCET calculation.</p><p>We report the WCET of a memory transaction in clock cycles at 300 MHz, the frequency of the memory. The results assume a fully balanced tree and a scaling factor of 3 for Bluetree to account for it running at a lower frequency of 100 MHz.</p><p>The analysis of the memory controller back-end uses the analytical framework, presented in <ref type="bibr" target="#b110">[111]</ref>, developed as a part of T-CREST, and adjusted slightly to account for pipeline delays in the FPGA implementation. This analysis framework is general and explicitly models all dependencies between DRAM commands. This enables it to derive the WCET for memory transactions of different sizes in a parameterized way depending on the number of banks used in parallel to serve each transaction, which is determined at design time. Note that refresh is not included in the WCET of memory transactions, but modeled as a high-priority periodic task during schedulability analysis of the system. DDR3 specification gives the period of the refresh as 7.8 µs and our analysis of the timing selector and command scheduler bounds the refresh time.</p><p>Given a fixed request size of 32 bytes, the memory controller can accept a new request every 28 cycles. However, the first request in a sequence incurs a pipeline delay of 25 cycles in the worst case, making the WCET of an isolated memory transaction 53 cycles at 300 MHz. Given a blocking factor, we can calculate and bound the number of times the multiplexer can block a request while transiting up the tree. For a fully congested tree (i.e., one in which every client issues a request in every cycle which it can), we can use Equations ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula">2</ref>) to calculate the number of times multiplexers may block a packet for a given blocking factor m, when transmitted from a multiplexer at level i. Here, the high priority side is the left-hand side of the multiplexer, and the low priority side is the right-hand side. Additionally, the multiplexer at the root of the tree is level 1, and level n at the leaves of the tree.</p><formula xml:id="formula_0">B i = i n=1 (B i -1)<label>(1)</label></formula><formula xml:id="formula_1">B i =          2 i = 1 ∧ High Priority m i = 1 ∧ Low Priority 2 × B i-1 i = 1 ∧ High Priority m × B i-1 i = 1 ∧ Low Priority (2)</formula><p>B i calculates the periodicity, in the worst case, that an input to the multiplexer at level i gains service, and is slightly pessimistic in order to cater to the case where m = 2. In this case, the multiplexer at level 1 will gain service once in every two requests to the multiplexer (as there is contention with only one other requestor). This is multiplicative as the blocking also depends on the multiplexers further up the tree (towards memory). When an up-stream multiplexer blocks, it will block an entire subtree. In this case, any multiplexers in this subtree will not be able to relay any packets, hence blocking counters will not be updated, and the entire subtree will be stalled. Because of this stalling, the periodicity of lower multiplexers also depends on those further up the tree. We can calculate the blocking occurring at each level of the tree by subtracting one from this periodicity.</p><p>B i then sums the amount of blocking experienced at each level of the tree to ascertain the final blocking figure. We multiply this figure by the worst-case memory delay in order to ascertain the number of cycles that a request can be blocked.</p><p>Given these equations, we can use Equation ( <ref type="formula" target="#formula_2">3</ref>) to calculate the total round trip time for a memory request from the multiplexer at level i. Here, t up is the number of cycles required to transit a multiplexer when traveling to memory, and is six cycles (one to transit the arbiter and be enqueued into the output FIFO, one to leave the output FIFO, then multiplied by the scaling factor). t down is the time taken to transit a multiplexer when traveling downwards, and is three cycles (one cycle to cross each multiplexer, then scaled). t mem is the worst case time for a memory transaction (28 cycles); 25 cycles are the pipeline fill delay; and finally t mem is the execution time of the requested memory transaction.</p><formula xml:id="formula_2">t i mux = (t up × i) + (t down × i) + (B i × t mem ) + 25 + t mem<label>(3)</label></formula><p>With this equation we calculate the worst-case execution time of a tree with a varying number of clients (from 2 to 64), and a blocking factor of m = 2 and show the result in Table <ref type="table" target="#tab_1">2</ref>. These figures also detail the worst-case timings given when only varying levels of the tree are fully congested. As an example, the tree for two clients has a single multiplexer. In this case, the figure for L1 shows the WCET when the multiplexer at level 1 is congested, whereas No blocking shows the case where the multiplexer is not congested and thus a request can be immediately transmitted. Similarly, for four processors (with two levels of multiplexers), the figure for L1 shows the case where only the root level is congested, and the figure for L2 shows the case where the multiplexer at level 2 and the root multiplexer are fully congested.</p><p>The TDM case concerns itself with the worst-case response time for a TDMbased arbiter, assuming each TDM slot equals the WCET of a 32 byte request in the back-end (28 clock cycles). This also assumes that each processor has an identical time slice and identical periodicity. This worst case will occur when the client in question issues a request just after its slot has become available. In this case, it will have to wait until its current slot has expired and all other slots have been serviced. It will then have to wait for its own memory request to be serviced. The pipeline delay (25 clock cycles) is factored in also. This implies a total delay therefore of (28 × nP rocs) -1 + 28 + 25 clock cycles.</p><p>We can see that, while the worst-case delay is worse than the TDM case for a fully backlogged tree, the tree will typically perform better when it is not fully loaded. This is due to the inherent work-conserving nature of the tree, since the tree operates on blocking factors rather than a static slot table. The timing performance of the tree will therefore depend upon the tasks running within it, and thus there will be a distribution of execution times between the case with no contention and the case where the tree is maximally loaded. In standard TDM, however, the worst-case and the actual case are identical; a task will still need to wait its turn, even if the other turns are unfulfilled.</p><p>This worst-case is also not indicative of the actual system. Since Patmos can only have a single outstanding memory request at once, there can only be 64 outstanding memory requests at a time. Since a tree with six levels will have 126 buffers distributed across the inputs to the multiplexers, the tree cannot be maximally loaded (the maximum 64 outstanding requests can only partially fill the 126 buffers). In reality, the worst-case performance will be closer to the performance if all but the last levels of the tree are fully loaded-less pessimistic analysis incorporating this intuition remains an open issue. Finally, we note that in reality systems rarely at run-time experience their worst-case, particularly in terms of WCET <ref type="bibr" target="#b74">[75]</ref>. Hence in terms of memory accesses, a constituent part of WCET, actual memory latencies times will be an application dependent distribution between the worst-case in Table <ref type="table" target="#tab_1">2</ref> and the best (i.e., no blocking).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">The Compiler and WCET Analysis</head><p>An integral part of the T-CREST design philosophy is to use static (compiletime) alternatives for commonly used performance-enhancing features at runtime. This reduces the dynamic behavior and processor states outside the control (and visibility) of the code at the ISA level. In conformance with this philosophy, the compiler must generate code that specifically targets the Patmos ISA and has control over its components.</p><p>Besides the hardware architectural means to obtain tight WCET bounds, we pursue a tight integration of the compilation process and timing analysis <ref type="bibr" target="#b25">[26]</ref>. On one hand, the compiler preserves information available during the compilation process that usually is discarded, although it would be valuable for automated and precise timing analysis. This includes preserving information about the control-flow structure, but also flow annotations provided by the user that constrain the possible flow of control, e.g., bounds on the maximum number of loop iterations (loop bounds). The compiler provides this information as additional input to the WCET tool. On the other hand, results from the timing analysis are fed back to the compiler, to guide optimizations that aim at reducing the guaranteed worst-case performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Support for the Patmos ISA</head><p>The architectural design for time predictability (see Section 3) requires dedicated support from the compiler. The absence of dynamic instruction reordering and assignment to the available functional units requires the compiler to create a feasible instruction schedule, which respects instruction latencies, bundles instructions for dual-issue, and fills delay slots of control-flow instructions.</p><p>For method cache support, the compiler splits functions that otherwise are too large to fit in the method cache as a whole <ref type="bibr" target="#b111">[112]</ref>. For optimization purposes, the compiler also splits large functions with many divergent control-flow paths to avoid loading unused code into the cache. The Patmos ISA allows splitting functions with low overhead.</p><p>The explicitly managed stack cache requires the compiler to insert special control instructions, typically at function entries, calls, and returns. The compiler can allocate data objects of fixed size to the stack cache for which it can guarantee the persistence of their stack frame during their lifetime (e.g., register spill slots, local variables with fixed size). At the same time, the compiler manages the shadow stack for objects that cannot be allocated in the stack cache. Using the stack cache results in an average runtime speedup of 1.57 for the MiBench benchmarks <ref type="bibr" target="#b2">[3]</ref>. Most stack frames allocated on the stack cache never need to be spilled to memory. Furthermore, allocating data on the stack cache reduces the cache pressure on the data cache, leading to a lower data cache miss rates, as shown in <ref type="bibr" target="#b112">[113]</ref>.</p><p>The Patmos ISA exposes the type of memory accessed in typed memory instructions. Hence, the compiler generates different instructions for accessing the main memory through the data cache, the data on the local stack cache, the scratchpad memory, or to bypass the data cache for memory accesses to unpredictable memory locations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Single-Path Code Generation</head><p>The fully predicated instruction set of Patmos eases single-path code with minimal control-flow complexity and stable execution-time behavior. The compiler can generate single-path code in an automated way, by using a transformation that extends if-conversion techniques. Martin: Ref for if-conversion is missing. The following sentence then starts with fixed loop iterations, which is not if-conversion. Loops are transformed to employ a fixed iteration count and predicates are maintained across function calls <ref type="bibr" target="#b92">[93,</ref><ref type="bibr" target="#b113">114]</ref>.</p><p>Regions of single-path code are specified by entry functions. These functions and the functions called from within are generated to exhibit a singleton execution path. The respective application code is limited to reducible control flow without indirect function calls and recursion. Structured loops are required to specify local loop bounds in the source code, which results in constant loop trip counts. In single-path code, some control-flow paths are executed sequentially rather than alternatively based on input data. This increases the number of executed instructions and may increase the WCET. Since the method cache fetches whole functions or subfunctions in any case, the total number of instructions fetched does not necessarily increase though. Instead, the amount of code fetched but not executed is typically reduced to zero for single-path code for most cached code blocks. However, in cases where loops contain code that is not executed in all iterations, the cache may not reach a stable cache state that contains only frequently executed paths if the whole body does not fit into the cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Compilation Tool Chain</head><p>Figure <ref type="figure" target="#fig_9">9</ref> gives an overview of the compiler tool chain. The Patmos compiler extends the LLVM compiler construction framework <ref type="bibr" target="#b69">[70]</ref>. At the beginning of the compilation process, the C frontend clang translates each C source code file to LLVM's language-and target-independent intermediate representation called bitcode. Bitcode is a control-flow graph oriented representation of the program using static single assignment form. The llvm-link tool links the application code with standard and support libraries at bitcode level. This linked application presents subsequent analysis and optimization passes, as well as the code generation backend, with a complete view of the whole program, thus enabling WCET-oriented optimizations.</p><p>The opt optimizer performs generic, target independent optimizations, such as common sub-expression elimination, constant propagation, etc. The llc tool constitutes the backend, translating LLVM bitcode into machine code for the Patmos ISA, and handling the target-specific features for time predictability.</p><p>The backend produces a relocatable ELF binary containing symbolic address information, which gold processes, <ref type="foot" target="#foot_5">6</ref> defining the final data and memory layout, and resolving symbol relocations.</p><p>In addition to the machine code, the backend exports supplementary information for WCET analysis and optimization purposes in form of a Program Metainfo File. This information contains, among others, flow information (in form of loop bounds provided by symbolic analysis on bitcode level), structural information (targets of indirect branches), information on memory accesses (memory areas accessed by individual load/store instructions), as well as information to relate bitcode and machine code program representations, as detailed in Section 6.5. The platin toolkit enhances (e.g., by a hardware model), processes, and translates this information to the input format for annotations of AbsInt's timing analysis tool aiT <ref type="bibr" target="#b81">[82]</ref>, which uses this information in addition to the ELF binary to compute tight WCET bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">The WCET Analyzer aiT</head><p>The aiT tool <ref type="bibr" target="#b81">[82,</ref><ref type="bibr" target="#b82">83]</ref> determines safe and precise upper bounds for the worstcase execution times of non-interrupted tasks in real-time systems. Separate versions of aiT offer support for different processor architectures. Within T-CREST, we extended aiT to support the Patmos architecture, which allows us to analyze the WCET of tasks from Patmos executables.</p><p>aiT takes as input a binary executable and an AIS file, i.e., an annotation file in the proprietary AIS format that provides further information about the program. After reconstructing the control flow from the executable, aiT performs a loop analysis to automatically compute upper bounds of loop iterations, and a value analysis to determine safe approximations of the values of processor registers and memory cells for every program point and execution context. The user can extend and refine the results of these automatic analyses in the AIS file.</p><p>An architectural analysis simulates the execution behavior of the input program through an abstract hardware model. The analysis determines lower and upper bounds for the execution times of basic blocks by performing an abstract interpretation of the program execution on the particular architecture, taking into account its pipeline, caches, memory buses, and attached peripheral devices. Using the results of these analyses, the path analysis phase searches for the longest execution path and from it, derives a safe estimate for the WCET.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.">Compiler and WCET Analysis Integration</head><p>Due to the considerable changes that backend code generation involves in LLVM, bitcode is not a suitable target for WCET analysis. On the other hand, when the compiler lowers bitcode to machine code it loses a large amount of the compiler's analysis information.</p><p>Support for WCET analysis integration requires that the compiler maintains semantic information between program representation levels, passes information about machine code to the WCET analysis tool, and has control over the performed optimizations and machine code generation <ref type="bibr" target="#b114">[115]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.1.">Preservation of Meta-Information</head><p>Due to the complexity of modern compilers and their optimizations, transforming information from the source level to the machine-code level is not trivial to retrofit into an existing industrial-quality framework. The compilation flow described in Section 6.3 permits to use different strategies for the preservation of meta-information in different stages of compilation:</p><p>• The translation from source code to the platform-independent intermediate representation by clang includes translation of information available only at the source-level (e.g., annotations in form of pragmas) to bitcode meta-information. In order to separate concerns, clang performs no optimizations at this stage.</p><p>• The compiler performs high-level optimizations on bitcode. Some of the available optimizations perform major structural changes to the program (e.g., loop unswitching or loop unrolling). Consequently, we extended these optimizations to preserve meta-information relevant for timing analysis. In particular, techniques for maintaining loop bounds, which are crucial for WCET analysis, require considerable additional effort for each optimization <ref type="bibr" target="#b70">[71]</ref>. However, as these optimizations are implemented in a platform-independent way, it is likely that the investments on preserving meta-information pay off.</p><p>• In order to preserve meta-information in the compiler backend, the compiler maintains relations between basic blocks (and memory accesses) at the bitcode and the machine code level. Based on this information, we derive control flow relation graphs that model regular relations between execution paths at both levels. The compiler uses these control flow relation graphs to transforms flow facts from bitcode to machine code <ref type="bibr" target="#b115">[116]</ref>.</p><p>Thus it is not necessary to add dedicated support for flow-fact updates in the backend.</p><p>• The compiler and linker generate and store in the binary all symbolic names necessary to specify information for the timing analysis tool. This permits to specify all information about machine code by referring to symbolic addresses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.2.">Exchange of Program and Timing Information</head><p>Compiler passes and our integration toolkit platin integrate the LLVM compiler and AbsInt's WCET analysis tool aiT <ref type="bibr" target="#b81">[82]</ref>. We adapted the compiler to export information on both bitcode and machine code, and on the relation between these representations. This compiler pass is largely platform independent.</p><p>The compiler exports the program information after it performed all optimizations. This way, a particular target backend only has to provide target-specific information. Our platin (Portable LLVM-based Annotation and Timing Analysis Integration) tool uses this information. The main responsibility of platin is to consolidate and transform information about the program, its control flow and its timing behavior. platin collects this information from the compiler, development and analysis tools.</p><p>At the core of the information exchange strategy is the Program Metainfo Language (PML) file format that stores information relevant for WCET analysis and compiler optimizations. We designed PML to allow information exchange with different tools at both the bitcode and machine code level. Fundamental concepts such as control-flow graphs, loop nest trees, or linear flow constraints are thus defined in a way that is applicable to both bitcode and machine code. The relation between optimized bitcode and machine code is also stored, which allows transforming information obtained from auxiliary analysis tools that operate at the bitcode level to machine code level for use by aiT. An example for a particularly useful analysis on bitcode level is loop trip count analysis, already available in the LLVM framework. At the machine code level, the PML format is largely platform independent. To achieve platform independence, platin specifies machine code related concepts like jump tables in a uniform way.</p><p>For timing analysis with the aiT tool, which carries out its analysis on binary code, an AIS annotation file is exported from the PML file, which in conjunction with the executable, serves as input to the analyzer. The automatically generated annotations provide information on jump tables and indirect calls, potential targets of memory accesses as well as loop bounds and flow frequency constraints. As the annotation language may only refer to instructions at the binary level, flow constraints that refer to control-flow edges or empty basic blocks (for example) are not directly expressible in the AIS format. Therefore, we reuse the technique developed for flow-fact transformations between bitcode and machine code level, and reformulate those program entities that are not supported by the AIS format.</p><p>When the WCET analysis is complete, platin merges back the analysis results into the PML database. This information is available for the compiler to guide further optimizations for improving time predictability and worst-case performance. For example, the compiler might bypass the cache for those memory accesses that the timing analysis tool classifies as unpredictable. Evaluation of this WCET analysis based optimization is future work.</p><p>To obtain a profile regarding a program's statically analyzed worst-case behavior, platin makes use of the criticality metric <ref type="bibr" target="#b116">[117]</ref>. It assigns to each basic block a value in the range [0, 1] that signifies its importance relative to the WCET bound. E.g., all blocks on the worst-case execution path have criticality of 1, while infeasible code has criticality 0. The resulting profile information gives a complete view of the program instead of the singular worst-case path result that static WCET analysis tools usually yield. Similar to an execution profile obtained for improving average-case performance, the programmer and compiler can base their optimization decisions on the criticality of a piece of code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Evaluation</head><p>To evaluate the T-CREST platform prototype, we use industrial use cases derived from real-world applications. We build these use cases upon domainspecific applications from the avionics and railway domains. Their purpose is to evaluate and validate the T-CREST platform as a whole, complementing the validation and verification activities realized, individually, over the technological elements of the platform. Therefore, in this section we discuss the evaluation from a platform point-of-view where the subject of the evaluation is the complete T-CREST platform.</p><p>All use cases were adapted to exploit the specific features provided by the platform. To provide better coverage of these features and to address the different industrial usage models, the avionics use cases explored achieving a higher degree of system integration than currently available in commercial platforms, whereas the railway use case focused on parallelization. Accordingly, the most complex avionics use case deploys three independent and unrelated applications over the platform, validating that their temporal behavior is unaffected. The most complex railway use case exploits the multi-core characteristics of the T-CREST platform to improve the performance of a Fast Fourier Transformation based application by parallelizing it.</p><p>Once the applications were ported, the first validation of the platform was to verify if they could comply with their original requirements and execute according with the expected behavior. This was the case for all the use cases from avionics and railway. Next, the behavior of the platform with regard to the WCET was assessed. The WCET for selected tasks was estimated using AbsInt's WCET analysis tool aiT.</p><p>aiT enables us to obtain WCET estimations for each individual application in a single or multi-core configuration. Multi-core WCET bounds are obtained by configuring the settings for latencies for reads and writes to memory. Apart from the memory latency, the application executable, an AIS annotations file, and the analysis entry point are the sole inputs required for the WCET analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Avionics Use Case</head><p>The avionics use cases consist of a set of avionics applications that are typically hosted on one single computing platform as it is common practice in on-board systems integrated according to the principles of Integrated Modular Avionics (IMA). IMA is an architectural concept, originated in aeronautical systems, that enables multiple unrelated applications, with different criticalities, to share the same computing platform without interference by applying robust partitioning. The application of IMA concepts resulted in a reduction of hardware used in aircrafts by enabling resource sharing among different applications. In consequence, IMA reduced the main drivers of aircraft operational costs, in particular weight, volume, and energy consumption. Any hardware platform applicable to avionics systems shall support the key elements of the IMA concept. More specifically, it shall support application independence.</p><p>The avionics evaluation uses three distinct applications: AOC, CAS, and IOP. The AOC (Airlines Operational Centre) is the on-board part of an Air Traffic Management (ATM) system that enables digital text communication between the aircrew and ground ATM units. Skysoft (today GMV Portugal) in cooperation with BAE Systems developed the application according to DO-178B Design Assurance Level (DAL) C. The AOC can be described as a communication router and message database. It stores reports sent from ground stations or created by aircraft subsystems, such as weather reports, trajectories and route planning information. The AOC schedules these reports for delivery or sends them to the destination on demand.</p><p>In addition, the Crew Alert System (CAS) system receives signals from onboard subsystems, such as doors, engines, or the environment control system and displays relevant aircraft information such as engine parameters (e.g., temperature values, fuel flow, and quantity). The CAS improves situational awareness by allowing the aircrew to view complex information in a graphical format and also by alerting the crew to unusual or hazardous situations. CAS is an ARINC 653 prototype application whose development followed DO-178B guidance for DAL A.</p><p>The last application, the I/O Partition (IOP), is an IMA application that acts as a router mediating the access from other application partitions to data buses and avionics networks in a robust and safe manner. The IOP interfaces other partitions through ARINC 653 queuing and sampling ports. The user associates each port with a set of routing configurations that enable data traversing via this port to be forwarded to a given physical I/O interface and an address in that interface. In consequence, access to a network becomes transparent to application partitions. The application only sends and receives data from a typical queuing or sampling port. The IOP handles all routing configurations. All applications, originally, communicated with other applications and external systems through queuing and sampling ports. These communication interfaces are usually based on buffers in main memory and, hence, are subject to heavy contention in a multi-core processor. As part of the optimization to the T-CREST platform, we mapped the port interfaces, used by the demonstrators, to the inter-core communication that the configurable NoC provides.</p><p>To provide a run-time environment to the avionics applications, we ported the RTEMS real-time operating system (RTOS) to the T-CREST platform. RTEMS is a free and open source RTOS, used as a baseline for dozens of space missions, that is compatible with open standards such as POSIX or iTRON <ref type="bibr" target="#b117">[118]</ref>. RTEMS was ported in a single-core configuration. When supported by a second stage bootloader, also developed as part of the evaluation process, it enables the deployment of Asymmetric Multiprocessing (AMP) configurations over the T-CREST platform where an operating system instance is present in each one of the platform cores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Railway Use Case</head><p>The T-CREST methodology is also evaluated with a use case from the railway domain. In current railway systems, especially in urban areas, analog technologies that limit performance, require constant maintenance, and infer high management costs are still widespread. It is therefore required to shift towards optimized innovative solutions in terms of hardware and software. The goal is to enhance safety and efficiency, and at the same time allow a reduction of the installation costs. The railway use case is an adaptation of the GSM-R Integrity Detection System (GRIDES) to the T-CREST platform. GSM-R is an extension of the commercial GSM standard with additional railway specific services. Acquiring and analyzing the GSM-R radio signal, within the allocated bandwidth (for both, the uplink and downlink channels) and in proximity of one or more railway lines, enables the assessment of the link's health. The GRIDES system consists of a network of intelligent diagnostic units that measure the quality of the GSM-R radio link along railway tracks. It is necessary to monitor the radio link status continuously. Therefore, we need to know the WCET of the tasks to guarantee the continuous operation. The number of radio channels and the complexity of the radio interference detection algorithm require the use of highperformance systems. To be able to extend the area that GRIDES can monitor, cost-effective architectures are desirable. In this context the T-CREST project is well suited. The railway domain specific use case evaluates the T-CREST platform with the goal to verify its adaptability to this domain's rules, and to gain a better understanding of its possibilities. The complexity of the process requires timing/performance optimization and the research of new strategies and tools for automation. The automatic derivation of execution time bounds is a promising strategy. Therefore, the verification of the WCET-oriented T-CREST platform tools is interesting for industry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Evaluation Results of the Avionics Use Case</head><p>The main objective of the avionics evaluation was to demonstrate that, given a configuration of the T-CREST platform, it is possible to independently obtain the WCET of any application, regardless of other software executing on the platform. This temporal independence between applications is a cornerstone in the IMA concept, being difficult to obtain in current multi-core systems. The lack of analyzable multi-core platforms hampers their adoption in the aerospace market, preventing the potential benefits in terms of higher system integration that could lead to improved and cost-efficient avionics systems.</p><p>In order to validate application independence, a demonstrator was setup where each core hosts a different application (AOC, IOP, CAS) that would, in a typical IMA system, be a standalone partition. Figure <ref type="figure" target="#fig_10">10</ref> shows this situation, representing a potential deployment where several distinct avionics systems are integrated over the same multi-core platform. This distribution of applications on cores in an asymmetric fashion was used to validate that the timing of each application depends solely on its own execution and the hardware configuration. To provide further insight over the behavior of the T-CREST platform, several test cases were setup by varying the number, configuration, and distribution of the avionics applications. For the different test cases, we estimated the WCET of selected tasks and, in some cases, compared against a measurement of the average case execution time of those same tasks. The measured execution time is obtained by reading the cycle accurate timer of Patmos at specific points in the source code.</p><p>The following set of tables shows the WCET results of the avionics use cases.</p><p>Each table belongs to a single use case application and a corresponding function that was selected as the target of the WCET analysis. The results are shown per test case, and were obtained using the latency values for 75 MHz, as this is the processor frequency of our evaluation platform.</p><p>As presented in the Tables <ref type="table" target="#tab_2">3</ref> and<ref type="table" target="#tab_3">4</ref>, we were able to obtain WCET estimations for every avionics application. Table <ref type="table" target="#tab_2">3</ref> shows that the main factor influencing the WCET estimation is the number of cores available in the platform. Whereas variations in concurrently executing applications, here appearing as different test cases, have no noticeable impact on the WCET estimation. The worstcase execution time estimation for the cas loop entry point displays a twofold increase when changed to a nine-core platform from a quad-core platform. Some applications, listed on Table <ref type="table" target="#tab_2">3</ref>, exhibit a very small variance in the WCET estimation for different test cases while using the same number of cores. This small variation is due to different configurations being used in different test cases. Some of these configurations (e.g., number of ARINC 653 ports) have a small impact over loop bounds and, hence, over the estimated worst-case execution time. This effect is also present on the WCET estimation results from the IOP application presented in Table <ref type="table" target="#tab_3">4</ref>. All WCET estimations are, as expected, higher than the average case measurements. However, the rather big To further improve the T-CREST evaluation process we decided to setup a simple comparison between the T-CREST platform and a SPARC/LEON processor. LEON processors are very common in real-time systems, especially in the space domain. We selected the IOP application to compare the T-CREST platform against a LEON 3 processor, as it was originally a LEON application.</p><p>Alongside the compiled IOP executable for LEON 3, a manually composed AIS annotations file is used as input to AbsInt's WCET analysis tool in order to obtain the estimated WCET values for the LEON processor. These values are then compared with the values obtained using the same source code compiled for the T-CREST platform. However, this comparison is solely feasible for single core as it is not possible to determine WCET for multi-core configurations of the LEON processor (the problem is unbounded).</p><p>Nonetheless, an approximate value of the expectable WCET, for multi-core LEON, is estimated by factoring single-core WCET values with a maximum interference multiplier representative of a LEON multi-core processor. This maximum interference multiplier is extracted from the literature <ref type="bibr" target="#b118">[119]</ref>, namely an European Space Agency funded study aimed at characterizing the NGMP processor (quad-core <ref type="bibr">LEON 4)</ref>. In this study, it was found that inter-core interference could increase the execution time of a given code segment up to twenty times compared to its single-core value.</p><p>Table <ref type="table" target="#tab_4">5</ref> presents the comparison between LEON 3 and T-CREST/Patmos. From the comparison in Table <ref type="table" target="#tab_4">5</ref> we can conclude that, in single-core configurations, Patmos and LEON have similar results with one alternately exhibiting a marginal reduction (&lt;5 %) in the WCET bound over the other depending on the specific analysis entry point being used.</p><p>In multi-core configurations, the difference is more significant; Patmos, as part of the T-CREST platform, can be directly targeted by static WCET analysis techniques. Such analysis is unfeasible in multi-core versions of the LEON processor, like the NGMP. Being analyzable in terms of WCET behavior offers the T-CREST platform a key advantage over the LEON multi-core processor. When comparing the WCET values obtained in multi-core T-CREST with those empirically estimated for the LEON, we can see the T-CREST platform yielding a seven times lower WCET bound. Nonetheless, the LEON values presented cannot be used to build a safety case around the software because they are rough estimates derived from empirically obtained interference patterns.</p><p>Another element assessed early on the avionics evaluation process was the stack cache, since it is a T-CREST innovation that directly impacts our applications. We compared the WCET estimations from selected tasks of the Avionics applications while varying the size of the stack cache and its presence. Table <ref type="table" target="#tab_5">6</ref> presents these WCET estimations. The T-CREST system was configured with a burst length of 32 words and a cache line size of 128 bytes.</p><p>From Table <ref type="table" target="#tab_5">6</ref> we can conclude that the avionics tasks analyzed make a shallow use of the stack, since the increase of the stack cache size results in a very small improvement in terms of WCET estimations. The presence of the stack cache resulted in an improvement in terms of worst-case performance for two-thirds of the analyzed tasks over the configuration with data cache only. The remaining tasks do not benefit from the stack cache due to their cache access patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.">Evaluation Results of the Railway Use Case</head><p>Program parallelization was investigated to increase the performance of an application executing on the T-CREST platform. Three railway use cases are used to evaluate the platform.</p><p>The first use case provides the preliminary porting of the GRIDES project to the T-CREST platform with changes related to the platform to, but without multi-core adaptations. Only one Patmos core was used. In the second scenario three Patmos cores were used. A true parallel management of the Uplink and Downlink channel groups was used. The aim of the third test was to evaluate the improvements provided by the Patmos multi-core architecture. To perform this test, the GRIDES architecture has been redesigned to use the multi-core architecture and to group Uplink and Downlink channels to use 15 cores.</p><p>Table <ref type="table" target="#tab_6">7</ref> shows WCET estimations for the GRIDES application executing on different numbers of cores. The table shows WCET numbers for the Bluetree memory arbiter and a TDM based memory arbiter. The table shows better performance for the application running on the multi-core architecture compared to the single core version. The achieved improvement of the tri-core version over the single-core version is 1.78 times, while the improvement achieved with the 15-core version over the single-core version is 5.67.  • https://github.com/t-crest Further information on the project is available at:</p><p>• Official project web site http://www.t-crest.org</p><p>• Processor and compiler web site: http://patmos.compute.dtu.dk/</p><p>• For questions and discussions join the Patmos mailing list: https:// groups.yahoo.com/group/patmos-processor/</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>The T-CREST project provides a time-predictable multi-core architecture for future hard real-time systems. Within T-CREST we provide time-predictable hardware: the Patmos processor, the Argo network-on-chip, the Bluetree memory tree, and an SDRAM memory controller. A WCET optimizing compiler built from the LLVM compiler framework supports the processor. We integrated the compiler and the WCET analysis tool aiT that supports Patmos.</p><p>We evaluated the T-CREST platform with real-time applications from the avionics and railway domains. An application from the avionic domain demonstrates that tasks executing on different cores do not interfere with respect to their WCET. A signal processing application from the railway domain shows that the WCET can be reduced for computation-intensive tasks when distributing the tasks on several cores.</p><p>Most of the technology of T-CREST is available in open source and we consider it as a platform for further research on time-predictable architectures.</p><p>The paragraph with related work about memory controllers was moved from Section 5.3 to the related work section and some additional detail about the PRET and MERASA memory controllers was added. Furthermore, we have added related work for the memory tree, the compiler, and WCET analysis tools.</p><p>Section 7: I would expect from this kind of paper, that summarizes all the work done in a project, to provide a fairly large bunch of results that would show the relevance of the proposed mechanism., individually and implemented altogether.</p><p>Instead of that, Section 7 extensively describes the use cases from the avionics and railways domains (over more than 4 pages), then provides few results on half a page (one table and 15 lines). These results consist of the raw estimated WCET of several tasks taken from the use cases, considering 3 different stack cache sizes compared to using only a data cache. The other contributions of the project (method cache, NoC, memory system, compiler, etc.) are not evaluated. In addition, these few results are not commented while it should be explained why the stack cache performs worse than the data cache for some of the tasks.</p><p>At the time of the paper submission we where in the middle of the project evaluation by the user partners. Now with this major revision we can present results and have considerable extended the evaluation section (and cut down the use case description). The evaluation section now contains complete system evaluations for several applications and a comparison with the LEON multicore processor.</p><p>I guess that more results can be found in the papers published earlier. But then I would expect to find here more global experiments that would validate the proposed architecture and the associated tools and show:</p><p>-what performance can be achieved compared to a single-core architecture</p><p>With the railway use case we where able to provide WCET based speedups and report them in the evaluation section.</p><p>-how the worst-case performance compares to the observed (measured or simulated) performance One table in the evaluation section compares WCET estimates and average-case measurements.</p><p>-the price (in terms of performance) of time predictability This is hard to assess. We have added a comparison the other way round: the price of WCET overestimation when not designing for time predictability. We compare WCET estimates of the T-CREST platform with WCET estimates of a multi-core LEON. Thanks, fixed.</p><p>Compiler section: related work is missing, same for WCET analysis tool. The section sounds prototype description driven and less directed towards innovation.</p><p>We have restructured related work and added material for the compiler and WCET analysis in the related work section. p. 24 "bitcode and machine code" what does bitcode mean?</p><p>We have added a brief description what bitcode means.</p><p>The avionics section is too lengthy and more a declaration of intend (".. it will be probably possible..."). "We will explore... in the near future." It seems the project has ended.</p><p>We have cut down this description and change the wording to reflect that the project has ended.</p><p>It is hard to believe that all those complex software systems have been intended or were ported to the T-CREST. Please shorten this section and focus on what was done and what is described in the evaluations.</p><p>We have cut down the description. The described avionics applications have been ported to T-CREST and used in the evaluation.</p><p>The railway section ends without results. What was implemented on T-CREST; which WCET estimates have been reached.</p><p>We now have results from the railway use case and can present WCET speedup numbers for multi-core configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>p. 29 in Table 2 TYPO form</head><p>Thanks, fixed.</p><p>Results of the evaluation only concerns WCET values of some tasks and loop section out of some avionics study. Could it be enhanced by average case performance or FPGA based measured performance to show how good the WCET values are? Do you have more quantitative results? Also the 15 line result description is too short and does not explain much.</p><p>We now have results from two use cases and extended the evaluation section. We also have a comparison between an average case measurement and WCET estimates.</p><p>Conclusions are also totally inappropriate.</p><p>We moved the information about the source access into the evaluation section and added a summary of the evaluation results.</p><p>Within the new Subsection 1.1 we describe that the main communication mechanism is message passing with just a backup of software managed cache coherence for shared memory.</p><p>-Is there any advantage of using both? Or in some cases better to use only one model? Which one?</p><p>We argue in the new Subsection 1.1 for message passing for many cores, as cache coherence does not scale. We mention that large data structures can be shared in main memory when protected by locks, which implement the software cache coherency.</p><p>The evaluation section is way too short and insufficient to derive conclusions about the benefits of the T-CREST design. Moreover, no numbers are provided for the railway case study. This is a real critical point in the paper.</p><p>For the major revision of the article we have now the results of all use cases and extended the evaluation section considerable.</p><p>Moreover, partially evaluating T-CREST components would help a lot on understanding the different features but only numbers for the memory hierarchy are provided. On that respect, I would like having an evaluation of:</p><p>-Single-path code generation: Is there some limitations at the application level? Which is the pressure on the Method cache due to fetching all control flow paths?</p><p>We have added a subsection (Single-Path Code Generation) to the compiler section, describing the limitations at the application level and arguing about the pressure on the method cache.</p><p>-Cache hierarchy: Which is the impact of not using caches on heap allocated structures; what about the "shadow stack cache".</p><p>We have added references to stack-cache papers that evaluate the performance of the stack cache and its impact on the data cache in the compiler section.</p><p>We have not yet explored how cache bypassing for heap allocated data structures influences WCET estimation and added a sentence that this is future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Other considerations:</head><p>-Patmos seems to implement a register window mechanism. One different is the Patmos mechanisms with respect to other register window implementations, e.g. Sparc or Itanium? Patmos does not implement a register window. However, I could not find the text in the paper that hinted for the register window and therefore did not change anything in the paper for this issue. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The T-CREST platform consisting of Patmos processor nodes that are connected via an on-chip network for message passing communication and a memory tree to a memory controller for shared memory access.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Pipeline of Patmos with fetch, decode, execute, memory, and write back stages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Data transfer on a traditional TDM-based NoC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Data transfer in the T-CREST core-to-core message passing NoC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .Figure 5 :</head><label>45</label><figDesc>Figure 5: Block diagram showing the micro-architecture of the asynchronous router.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Packet format of the Argo NoC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Overview of the memory hierarchy. Arbiter Down (b) Internals of a memory tree multiplexer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The Bluetree memory network-on-chip.</figDesc><graphic coords="21,306.07,143.24,155.98,124.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Control path of the dynamically scheduled back-end.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Compilation tool chain overview.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Mapping of ARINC 653 partitions to cores onto the T-CREST platform.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>7. 5 .</head><label>5</label><figDesc>Access to Open-Source Components Many of the components developed within T-CREST are available in open source, most of them in the industry friendly BSD license. The sources are hosted at GitHub and the reader can find the sources of T-CREST at:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Martin</head><label></label><figDesc>Schoeberl received his PhD from the Vienna University of Technology in 2005. From 2005 to 2010 he has been Assistant Professor at the Institute of Computer Engineering. He is now Associate Professor at the Technical University of Denmark. His research interest is on hard real-time systems, time-predictable computer architecture, and real-time Java. Martin Schoeberl has been involved in a number of national and international research projects: JEOPARD, CJ4ES, T-CREST, RTEMP, and the TACLe COST action. He is now technical lead of the EC funded project T-CREST. He has more then 100 publications in peer reviewed journals, conferences, and books.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>ASIC and FPGA area results for a router and an NI of Argo NoC.</figDesc><table><row><cell></cell><cell>ASIC</cell><cell></cell><cell>FPGA</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">#LUT #FF BRAM bits</cell></row><row><cell>Router</cell><cell>7965 µm 2</cell><cell>538</cell><cell>580</cell><cell>-</cell></row><row><cell>NI</cell><cell>33587 µm 2</cell><cell>457</cell><cell>250</cell><cell>1024</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>WCET (cycles @ 300 MHz) of a 32-byte transaction for multiple processors.</figDesc><table><row><cell cols="2">Cores TDM</cell><cell>L6</cell><cell>L5</cell><cell>L4</cell><cell>L3</cell><cell>L2</cell><cell cols="2">L1 No blocking</cell></row><row><cell>2</cell><cell>108</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>90</cell><cell>62</cell></row><row><cell>4</cell><cell>164</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>183</cell><cell>99</cell><cell>71</cell></row><row><cell>8</cell><cell>276</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell cols="3">388 192 108</cell><cell>80</cell></row><row><cell>16</cell><cell>500</cell><cell>-</cell><cell>-</cell><cell cols="4">817 397 201 117</cell><cell>89</cell></row><row><cell>32</cell><cell>948</cell><cell>-</cell><cell cols="5">1694 826 406 210 126</cell><cell>98</cell></row><row><cell>64</cell><cell cols="7">1844 3467 1703 835 415 219 135</cell><cell>107</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>WCET results for selected tasks of avionics use cases</figDesc><table><row><cell>Analysis entry</cell><cell>Test case</cell><cell cols="2">Cores WCET estimation</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(in ms)</cell></row><row><cell>cas loop</cell><cell>CAS+IOP AOC+CAS+IOP</cell><cell>4 9</cell><cell>284 619</cell></row><row><cell>AGPAOCReceiveMainLoop</cell><cell>AOC+IOP AOC+CAS+IOP</cell><cell>9 9</cell><cell>5.41 5.45</cell></row><row><cell>AirplanePAOCMainTask</cell><cell>AOC+IOP AOC+CAS+IOP</cell><cell>9 9</cell><cell>1.92 1.94</cell></row><row><cell>decoderLoop</cell><cell>AOC+IOP AOC+CAS+IOP</cell><cell>9 9</cell><cell>210 210</cell></row><row><cell>AOCAlertMainLoop</cell><cell>AOC+IOP AOC+CAS+IOP</cell><cell>9 9</cell><cell>2.72 2.74</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>WCET estimations and average-case execution time measurements for IOP: pre dispatcher and pos router entry points</figDesc><table><row><cell>Analysis entry</cell><cell>Test case</cell><cell>Cores</cell><cell>WCET</cell><cell>Timing</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">estimation measurement</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(in ms)</cell><cell>(in ms)</cell></row><row><cell></cell><cell>CAS+IOP</cell><cell>4</cell><cell>6.24</cell><cell>0.952</cell></row><row><cell>pre dispatcher</cell><cell>AOC+IOP</cell><cell>9</cell><cell>14.64</cell><cell>0.239</cell></row><row><cell></cell><cell>AOC+CAS+IOP</cell><cell>9</cell><cell>23.57</cell><cell>1.110</cell></row><row><cell></cell><cell>CAS+IOP</cell><cell>4</cell><cell>6.42</cell><cell>0.121</cell></row><row><cell>pre router</cell><cell>AOC+IOP</cell><cell>9</cell><cell>15.35</cell><cell>0.120</cell></row><row><cell></cell><cell>AOC+CAS+IOP</cell><cell>9</cell><cell>27.07</cell><cell>0.151</cell></row><row><cell cols="5">difference between WCET estimates and measurements has no real meaning,</cell></row><row><cell cols="5">as average case measurements probably do not trigger the worst-case execution</cell></row><row><cell cols="5">path. Martin: This overestimation is high. Why? I hope the reviewers will not</cell></row><row><cell>kill us for it.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Comparison of WCET results between Patmos and LEON for the IOP application</figDesc><table><row><cell>Analysis entry</cell><cell cols="3">Cores Target CPU WCET estimation</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(in ms)</cell></row><row><cell>pre dispatcher</cell><cell>1</cell><cell>Patmos LEON</cell><cell>2.20 2.32</cell></row><row><cell></cell><cell>4</cell><cell>Patmos LEON</cell><cell>5.75 45.28</cell></row><row><cell>pre router</cell><cell>1</cell><cell>Patmos LEON</cell><cell>2.21 2.15</cell></row><row><cell></cell><cell>4</cell><cell>Patmos LEON</cell><cell>6.06 41.81</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 :</head><label>6</label><figDesc>WCET of tasks from the avionics use case (in clock cycles).</figDesc><table><row><cell>Task</cell><cell cols="3">Stack cache size (bytes)</cell><cell>D-Cache</cell></row><row><cell></cell><cell>128</cell><cell>256</cell><cell>512</cell><cell>only</cell></row><row><cell>AGP ClientMainLoop</cell><cell>8747009</cell><cell>8747009</cell><cell>8747009</cell><cell>8817249</cell></row><row><cell>Airplane PAOCMainTask</cell><cell>3710092</cell><cell>3710092</cell><cell>3710092</cell><cell>4539013</cell></row><row><cell>AOC decoderLoop</cell><cell cols="4">2677263042 2677202454 2677202454 2233634812</cell></row><row><cell>AOC feederLoop</cell><cell>1403864</cell><cell>1403864</cell><cell>1403864</cell><cell>1411845</cell></row><row><cell>AOC replierLoop</cell><cell>6242675</cell><cell>6242675</cell><cell>6242675</cell><cell>6753912</cell></row><row><cell>Pilot MDCUMainLoop</cell><cell cols="4">6082657125 6082657125 6082657125 5986097713</cell></row><row><cell>CAS loop</cell><cell>6225437</cell><cell>6225437</cell><cell>6225437</cell><cell>6670233</cell></row><row><cell>IOP grbc manager</cell><cell cols="3">1041521886 1041521886 1041521886</cell><cell>851933301</cell></row><row><cell>dry2 1</cell><cell>553319</cell><cell>553319</cell><cell>553319</cell><cell>577039</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7 :</head><label>7</label><figDesc>Worst-case execution time from aiT analysis for Bluetree and TDM in GRIDES</figDesc><table><row><cell cols="3">Cores Bluetree WCET (in s) TDM WCET (in s)</cell></row><row><cell>1</cell><cell>322</cell><cell>322</cell></row><row><cell>3</cell><cell>225</cell><cell>180</cell></row><row><cell>15</cell><cell>102</cell><cell>56</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>see https://github.com/t-crest</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.absint.com/ait/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://www.irisa.fr/alf/index.php?view=article&amp;id=29</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>http://www.otawa.fr/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://www.rapitasystems.com/products/rapitime</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>gold is part of the GNU binutils, see http://sourceware.org/binutils/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>This work was partially funded by the European Union's 7th Framework Programme under grant agreement no. 288008: Time-predictable Multi-Core Architecture for Embedded Systems (T-CREST) and the EU COST Action IC1202: Timing Analysis on Code Level (TACLe). Sahar Abbaspour is a PhD student at the Technical University of Denmark. She has recieved her Masters degree in Computer Engineering in 2011 from University of Tehran. Her research interest is on time-predictable computer architecture and currently she is working on time-predictable data caching. Benny Akesson received his M.Sc. degree at Lund Institute of Technology, Sweden in 2005 and a Ph.D. from Eindhoven University of Technology, the Netherlands in 2010. Since then, he has been employed as a Postdoctoral Researcher at Eindhoven University of Technology, CISTER-ISEP Research Unit, and Czech Technical University in Prague. His research interests include design and analysis of multi-core real-time systems with shared resources. Professor Neil Audsley received a BSc (1984) and PhD (1993) from the Department of Computer Science at the University of York, UK. In 2013 he received a Personal Chair from the University of York, where he leads a substantial team researching Real-Time Embedded Systems. Specific areas of research include high performance real-time systems (including aspects of big data); real-time operating systems and their acceleration on FPGAs; real-time architectures, specifically memory hierarchies, Network-on-Chip and heterogeneous systems; scheduling, timing analysis and worst-case execution time; model-driven development. Professor Audsley's research has been funded by a number of national (EPSRC) and european (EU) grants, including TEMPO, eMuCo, ToucHMore, MADES, JEOPARD, JUNIPER, T-CREST and DreamCloud. He has published widely, having upwards of 150 publications in peer reviewed journals, conferences and books. Raffaele Capasso is a Project Manager at Intecs since 2002. He has a computer science diploma. With experience in the railway domain technologies, in defence domain technologies for combat managements systems and naval systems, in air traffic control domain technologies and radar data processing. He has been involved in several projects, including T-CREST (EC). for Naples office. Jamie Garside received his MEng degree at the University of York, and is currently working towards his PhD at the same university. His research interests include networks-on-chip, memory interconnect and prefetching. Kees Goossens received his PhD in Computer Science from the University of Edinburgh in 1993 on hardware verification using embeddings of formal semantics of hardware description languages in proof systems. He worked for Philips/NXP Research from 1995 to 2010 on networks on chip for consumer electronics, where real-time performance, predictability, and costs are major constraints. He was part-time full professor at Delft university from 2007 to 2010, and is now full professor at the Eindhoven university of technology, where his research focusses on composable (virtualised), predictable (real-time), low-power embedded systems. He published 3 books, 150+ papers, and 16 patents Sven Goossens was born in Wouw, The Netherlands in 1986. He received a MSc in embedded systems from the Eindhoven University of Technology in 2010, and is currently a PhD candidate at the same university. His research interests include mixed time-criticality systems, composability and SDRAM controllers. Scott Hansen is Director for European Projects at The Open Group and has been the project leader for 16 previous European Commission funded projects including large RTD STREP and IP projects, as well as accompanying measures, and thematic networks. Based in the Brussels, he co-ordinates the research efforts of The Open Group in Europe amongst European members, as well as with other European standards bodies, and industry consortia, where he sits on the ICT Standards Board, a European Commission funded grouping of Standards Organisations and Industry consortia. He holds degrees in computer science, business management and industrial engineering, and has over 20 years experience working in both large multi-national organisations and smaller start-ups managing technology development, deployment, exploitation as well as the financial and administrative disciplines associated with successful introduction of new technologies. Reinhold Heckmann studied Computer Science at Saarland University in Saarbruecken, Germany, where he received the Dr. rer. nat. degree in 1991. After being Lecturing Assistant at Saarland University and Research Fellow at Imperial College, London, he became Senior Researcher at AbsInt Angewandte Informatik GmbH in 2000. Within AbsInt, he is working on the foundations of timing analysis for hard-real time systems. This work has been pursued in the context of various European research projects funded by the FP5, FP6, FP7, Artemis, and ITEA programmes, including INTERESTED (FP7 IST-214889), PREDATOR (FP7 IST-216008), ALL-TIMES (FP7 IST-215068), T-CREST (FP7 IST-288008), and CERTAINTY (FP7 IST-288175). Stefan Hepp received his MSc in computer engineering from Vienna University of Technology in 2011, where he is currently working toward his Ph.D. under the supervision of Professor Jens Knoop. His research interests include worst-case execution time oriented code optimizations, cache analysis techniques and time-predictable architectures. Benedikt Huber received his MSc in computational intelligence from Vienna University of Technology in 2009. Since then, he worked as a research and teaching assistant at the same university's real-time systems group. His research focus is on WCET analysis in the context of time-predictable system design. Alexander Jordan received his PhD in Computer Science from the Vienna University of Technology in 2014 and is currently employed as a postdoctoral research assistant at DTU in Denmark. Working as an Embedded Software engineer for several years, his research interests nowadays include code generation techniques, program analysis and optimization. Evangelia Kasapaki has received her BSc and MSc from Computer Science Department, University of Crete, Greece in 2006 and 2008 respectively and is currently a PhD student in Technical University of Denmark. She has worked as a Electronic Design Automation software engineer from 2008 to 2011, in Nanochronous Logic, Inc, when she started her PhD. Her research interests include asynchronous design, Networks-on-Chip and SoC design, real-time systems and Electronic Design Automation. Jens Knoop is a full professor at the Vienna University of Technology, where he leads the languages and compilers group. His research interests include program analysis, optimization, and verification, especially of safety-critical real-time systems. Jens Knoop is a member of the IEEE and the ACM. Yonghui Li got his bachelor and master degrees both from Xidian University in 2009 and 2012, respectively. Since May 2012, he is working towards a PhD at Eindhoven University of Technology. His research interests include Networks-on-Chip, memory controllers, and real-time systems. Daniel Prokesch received his MSc in computer engineering from Vienna University of Technology in 2011. Currently, he is a PhD candidate under supervision of Professor Peter Puschner at the same university. His research interests include time-predictable system design, WCET analysis and code generation techniques.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Reviews and Reply Letter</head><p>We are grateful for the detailed reviews of the three anonymous reviewers that helped us to improve the paper. In this section we provide the review reply letter describing our changes. We repeat all review comments and describe our changes within the comments formatted as following:</p><p>Our reply is formatted as block quote and in italics.</p><p>Appendix A.1. Reviewer #1:</p><p>The paper gives an overview of the research carried out within the T-CREST European project. It seems that most of the contents has been published in several previous papers, then the material is not new. However, the synthetic view of the whole project that is presented in this paper is nice and I think it deserves publication.</p><p>Thank you! We think the main contribution of this paper is the integration of the whole project, including evaluation.</p><p>The T-CREST project aimed at designing a time-predictable multi-core architecture and the tools needed to program it and to analyse its worst-case performance. Several technical contributions are overviewed in the paper:</p><p>-a time-predictable core (Patmos) that implements a specific instruction set architecture -time-predictable local memories (method cache, stack cache) designed to make WCET analysis easier and tighter -a time-predictable core-to-core message passing Network on Chip based on time division multiplexing. It supports a GALS (globally-asynchronous/locallysynchronous) architecture.</p><p>-a time-predictable memory hierarchy composed of a tree interconnect, a hardware prefetcher and a memory controller back-end -a compiler that supports the Patmos ISA, optimises the code to enhance time predictability and delivers relevant information to the WCET analysis -a WCET analyser derived from the well-known aiT tool On the whole the paper is well written and pleasant to read. Its organisation -one section per major contribution -is relevant. The level of technical details is fine for this kind of paper, and is enough to understand the challenges addressed in the project and the proposed solutions. The reader can refer to cited papers for further information if needed. However, I have noted that some of the figures are very small and difficult to read. This is the case in particular for Figures <ref type="figure">3</ref> and<ref type="figure">10</ref>. They should be enlarged.</p><p>We have split former Figure <ref type="figure">3</ref> into two figures and also updated the drawing. Former Figure <ref type="figure">10</ref> is now in vector graphics and has been enlarged as well. It should now be readable.</p><p>My reservations are about Sections 2 (Related Work) and 7 (Evaluation). Section 2: I do not like the way related work is reported here. It is presented as a catalogue of ongoing or terminated projects, mentioning their major contributions on the different topics also addressed in T-CREST (core, NoC, memory, compiler, etc.). I would prefer a thematic organisation that would make it easier to have an overview of the state of the art on each topic and to appreciate the step forward done in T-CREST.</p><p>We have restructured related work to first talk about related projects in general and then continue with subsections for each topic (core, NoC, memory, compiler, and WCET analysis tools).</p><p>This would be the added value of the paper given that the technical propositions have been published in previous papers.</p><p>The evaluation and combining the individual components (e.g., memory tree/controller analysis into WCET analysis of complete application) should now contribute the added value.</p><p>Typo: end of page 29, 'save' ==&gt;'safe'</p><p>The paper gives an overview over the EC project T-CREST (http://www.tcrest.org/) that concerns design of time-predictable systems focusing on timepredictable multi-core design, compiler and applications. The lengthy paper is worth publishing, however, it looks obviously compiled together from the DoW and deliverables (e.g. D8.2). There is a lot to do to bring it in the form of a journal paper. Text should be reviewed and rewritten to present T-CREST with results and not as declaration of intend (e.g. "The T-CREST timwe-predictable system will ..." in abstract). The project has ended, so it will be hard to believe that the intend will in this project further be followed. If that is the case put it in a "conclusions and future work" section.</p><p>True, this shall be a report of a finished project. We went through the text to make sure only completed work is described.</p><p>Abstract is not suitable, it is the abstract of the EC project, too general and not the abstract of the contents and findings in the paper. The "will" should be replaced by real results of the finished project. You should also mention that it presents the results of a collaborative EC project.</p><p>We have written a new abstract that fits better for an article. We also mention in the abstract that it was a collaborative EC project. We used some of the more "popular science" wording from the EC project abstract in the introduction.</p><p>Introduction could be improved into the intro of the paper, not the project.</p><p>1.1 Project contributions should be more specific towards results presented in the paper.</p><p>We have restructured the introduction (see next reply). We added the speedup numbers to the contributions.</p><p>Fig. <ref type="figure">1</ref> with the T-CREST processor should be presented in an own section after the introduction and described in more detail. I would also like to see a justification for the separation of message-passing and memory access via the memory tree. What is the programming model? Message-passing, shared memory, or both.</p><p>We have introduced a subsection within the introduction to present the T-CREST processor. We also describe in this subsection that the main programming model is message passing. Shared memory support is mainly used for bulk data.</p><p>Related work specifies several short descriptions of related EC projects, but also papers on timing-predictable hardware. Missing is the related work on compiler, WCET tools etc. .</p><p>We have restructured related work so it has a section for each subtopic and added material for the compiler and WCET analysis tools.</p><p>Main chapter 3: here it may make sense to separate the processor architecture from its prototype FPGA implementation. Then it maybe clearer if written "All caches are configurable in the size...". Does that mean the FPGA implementation or that there is a single global memory adress space that can be configured and access is then supported by hardware for the respective memory type.</p><p>We have rewritten the sentence so it is clear that the (cache) configuration is before hardware generation.</p><p>"Address of heap-allocations data..." . Heap data is normally not on the stack and typically not supported by time-predictable programs (coding guidelines!).</p><p>Yes, heap data is not allocated on the stack. And we agree that dynamic heap allocation shall be avoided for time-predictable programs. But we support it in hardware and in the standard library.</p><p>We have rewritten to clarify that we are not talking about heap data on a stack. Heap data is routed to the data cache (or bypassed) where stack allocated data goes to the stack cache.</p><p>Direct-mapped cache with write-through to memory sounds not very performant. Aren't there more performant alternatives that are also timing-predictable. Did you make a study to compare predictability of direct-mapped with setassociative?</p><p>Since the paper was submitted we have added a set-associative data cache for Patmos. Set-associative caches with LRU replace policy are predictable and supported by aiT. We have changed the paragraph on the data cache for Patmos accordingly.</p><p>Write through is the best what aiT supports. We have added the comment that a write-back cache would actually increase the WCET compared to write-through.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>p. 14 TYPO inrease</head><p>Appendix A.3. Reviewer #3:</p><p>The paper presents the main outcome of the T-CREST FP7 project: A timepredictable multi-core processor architecture for safety critical systems. Each processor resource has been design with time-predictability in mind, i.e. the core (including ISA features such as predicated execution), the memory hierarchy and the NoC. Moreover, the project has investigated on compiler/WCET analysis interaction to improve WCET estimations.</p><p>The paper is well written and the different processor components are correctly explain. However, the overall T-CREST programming model and execution model is not clear to me.</p><p>We have added into the introduction some words that message passing is the preferred execution/communication model.</p><p>The processor implements two programming models: message passing and shared memory:</p><p>-The message passing uses the SPM and the aelite NoC in which requests are statically scheduled by using a TDM-like approach, guaranteeing no traffic contention.</p><p>Argo NoC is inspired by aelite, but is an independent design. We have clarified this in the restructured related work section.</p><p>-The shared memory is implemented through main memory using a "Bluetree memory tree" interconnection network in which the contention from different requestors can be quantified. Moreover, the DRAM uses an analytical framework to schedule the DRAM commands. As a result, as pointed by the authors, the "actual case for the tree will therefore depend upon the tasks running within it, and thus there will be a distribution of execution times between the case with no contention and the case where the tree is maximally loaded". Authors, also claim that "the tree cannot logically be maximally loaded" and leaves this observation as future work.</p><p>The analysis of the partially loaded tree is still left as future work.</p><p>In the mean time we use the worst case from an assumed fully loaded tree for the WCET analysis in the evaluation section.</p><p>This two designs seems to be contradictory: On one side, TDM-like approach is used to guarantee predictability and time composability; on the other side, TDM-like approach is not used due to overestimation on the timing analysis, and time composability seems not to be considered.</p><p>We have revised the text in the last two paragraphs of the memory section appropriately.</p><p>Moreover, the programming model considered to take benefit of this two architectural features is not explain and a lot of questions arises:</p><p>-In which cases applications should use message passing, and in which shared memory? -The paper claims that T-CREST NoC design reduces the area; how much?</p><p>We added area results to the NoC section and a brief comparison with an aelite instance.</p><p>-How the "clock skew" is considered in the WCET estimation? Does this have an effect on the WCET estimation? for how much? Discussion of skew in relation to WCET for the message passing NoC has been added to the NoC section. As explained the NIs are mesochronous and WCET analysis is a matter of counting clock cycles.</p><p>The WCET estimation is cycle-based and thus not sensitive to clock skew by itself. Any influence of the clock skew on the latency of the memory is taken into account when determining the memory access bounds that are given as parameters to the WCET analyzer.</p><p>-The two priority levels in the NoC design is very confusing, because depending on which core an application executes, it will result in one WCET estimation or another.</p><p>In subsection "WCET of a Memory Transaction" we've noted that WCET estimation must be undertaken after mapping of tasks to cores has occurred.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A.4. Other Changes</head><p>Here we list additional changes in the paper that have not been triggered by any review comment.</p><p>Overall we have improved the writing and fixed grammar errors.</p><p>We updated the Patmos pipeline figure to show the instruction SPM as well.</p><p>We have split former Figure <ref type="figure">3</ref> into two figures and added the FIFOs to the first figure. These improved figures made former Figure <ref type="figure">4</ref>, which shows the routers with and without FIFOs redundant. Therefore, we dropped former Figure <ref type="figure">4</ref>.</p><p>We have removed the URLs and doi links from the references.</p><p>We have corrected a typo in Section 5.3 that states that the data path of the memory controller has a word width of 128 B. This should be 128 bits.</p><p>Wolfgang Puffitsch is currently a postdoc researcher at DTU Compute in Copenhagen, Denmark, working on time-predictable computer architectures in the scope of the RTEMP project. From May 2012 to May 2013, he was a postdoc researcher at the DTIM group of ONERA in Toulouse, France, in the scope of the TOAST project. Before that, since January 2008, he worked as research and teaching assistant at the Institute of Computer Engineering at the Vienna University of Technology in Vienna, Austria, where he defended his PhD thesis on real-time garbage collection in March 2012.</p><p>Peter Puschner is a professor in computer science at the Vienna University of Technology. His main research interest is on hard real-time systems for safety-critical applications, with a focus on the worst-case execution time (WCET) analysis and software/hardware architectures for time-predictable computing systems. He has published more than 100 refereed conference and journal papers, received one patent, and was a guest editor of two special journal issues on WCET analysis. P. Alessandro Tocchi is a software and firmware test/development engineer at Intecs since 2011. He has a masters degree in electronic engineering. With experience in the railway domain technologies, he has worked as an embedded software technician, systems integration specialist, and real time system analyst. He has been involved in several projects, including T-CREST (EC).</p><p>Jens Sparsø is a professor at the Technical University of Denmark (DTU). His research interests include architecture and design of VLSI systems, application specific processors, low power design techniques, design of asynchronous circuits, and networks-on-chip. J. Sparsø has published more than 70 refereed conference and journal papers and is coauthor of the book Principles of Asynchronous Circuit Design -A Systems Perspective (Kluwer, 2001). J. Sparsø received the Radio-Parts Award and the Reinholdt W. Jorck Award in 1992 and 2003, in recognition of his research on integrated circuits and systems, and he received the best paper award at ASYNC 2005. J. Sparsø is a member of the steering committees for the IEEE Intl. Symposium on Asynchronous Circuits and Systems (ASYNC) and the ACM/IEEE Intl. Symposium on Networks-on-Chip (NOCS).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schleuniger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Probst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Karlsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Thorn</surname></persName>
		</author>
		<title level="m">Towards a time-predictable dual-issue microprocessor: The Patmos approach, in: First Workshop on Bringing Theory to Practice: Predictability and Performance in Embedded Systems (PPES 2011)</title>
		<meeting><address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A method cache for Patmos</title>
		<author>
			<persName><forename type="first">P</forename><surname>Degasperi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th IEEE Symposium on Object/Component/Service-oriented Real-time Distributed Computing (ISORC 2014)</title>
		<meeting>the 17th IEEE Symposium on Object/Component/Service-oriented Real-time Distributed Computing (ISORC 2014)<address><addrLine>Reno, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A time-predictable stack cache</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abbaspour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Workshop on Software Technologies for Embedded and Ubiquitous Systems</title>
		<meeting>the 9th Workshop on Software Technologies for Embedded and Ubiquitous Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A statically scheduled time-division-multiplexed network-on-chip for real-time systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sparsø</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kasapaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Symposium on Networks-on-Chip (NOCS)</title>
		<meeting>the 6th International Symposium on Networks-on-Chip (NOCS)<address><addrLine>Lyngby, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="152" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Kasapaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sparso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Sorensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
		<title level="m">Router designs for an asynchronous time-division-multiplexed network-on-chip</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Digital System Design (DSD)</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Argo: A Time-Elastic Time-Division-Multiplexed NOC using Asynchronous Routers</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kasapaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sparsø</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC)</title>
		<meeting>IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="45" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Investigating shared memory tree prefetching within multimedia noc architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Garside</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C</forename><surname>Audsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Memory Architecture and Organisation Workshop</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Predator: a predictable sdram memory controller</title>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ringhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CODES+ISSS &apos;07: Proceedings of the 5th IEEE/ACM international conference on Hardware/software codesign and system synthesis, ACM</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="251" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An SDRAM controller for real-time systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Workshop on Software Technologies for Embedded and Ubiquitous Systems</title>
		<meeting>the 9th Workshop on Software Technologies for Embedded and Ubiquitous Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Architecture and optimal configuration of a real-time multi-channel memory controller</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Gomony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation Test in Europe Conference Exhibition (DATE)</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="1307" to="1312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Lessons learned from the 80-core tera-scale research processor</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dighe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vangal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Borkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intel Technology Journal</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="119" to="130" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The 48-core SCC processor: the programmer&apos;s view</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Van Der Wijngaart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Riepen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lehnig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vangal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ruhl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dighe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference for High Performance Computing, Networking, Storage and Analysis</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The case for message passing on many-core chips</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Der Wijngaart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multiprocessor System-on-chip: Hardware Design and Tool Integration</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Hübner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Becker</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="115" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Patmos reference handbook</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Prokesch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multi-core execution of hard real-time applications supporting analysability</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ungerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cazorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sainrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bernat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Petrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rochange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quiñones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerdes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paolieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Merasa</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="66" to="75" />
			<date type="published" when="2010">2010</date>
			<pubPlace>Micro</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Pyka, parmerasa -multi-core execution of parallelised hard real-time applications supporting analysability</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ungerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bradatsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gerdes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kluge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jahr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mische</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zaykov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Petrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Boddeker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Regler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hugl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rochange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ozaktas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Casse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bonenfant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sainrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Broster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quinones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Panic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cazorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Uhrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rohde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="363" to="370" />
		</imprint>
	</monogr>
	<note>Euromicro Conference on Digital System Design (DSD</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Java processor architecture for embedded real-time systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems Architecture</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="265" to="286" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A real-time Java chip-multiprocessor</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pitter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Embed. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="34" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Design for timing predictability</title>
		<author>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="157" to="177" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ALL-TIMES -a European project on integrating timing technology</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gustafsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lisper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jersak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bernat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third International Symposium on Leveraging Applications of Formal Methods (ISOLA&apos;08)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Margaria</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</editor>
		<meeting>Third International Symposium on Leveraging Applications of Formal Methods (ISOLA&apos;08)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="445" to="459" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Virtual execution platforms for mixed-time-criticality systems: The CompSOC architecture and design flow</title>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Azevedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chandrasekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Gomony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koedam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mirzoyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Molnos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beyranvand Nejad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sinha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGBED Review</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="23" to="34" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The CompSOC design flow for virtual execution platforms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koedam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beyranvand Nejad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th FPGAworld Conference</title>
		<meeting>the 10th FPGAworld Conference<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Time-predictable cache organization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Software Technologies for Future Dependable Distributed Systems (STFSSD 2009)</title>
		<meeting>the First International Workshop on Software Technologies for Future Dependable Distributed Systems (STFSSD 2009)<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="11" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A time predictable instruction cache for a Java processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Java Technologies for Real-Time and Embedded Systems (JTRES 2004)</title>
		<meeting><address><addrLine>Agia Napa, Cyprus</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">3292</biblScope>
			<biblScope unit="page" from="371" to="382" />
		</imprint>
	</monogr>
	<note>On the Move to Meaningful Internet Systems</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Worst-case execution time analysis driven object cache design</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="753" to="771" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Prokesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Knoop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gebhard</surname></persName>
		</author>
		<title level="m">The T-CREST approach of compiler and WCET-analysis integration, in: 9th Workshop on Software Technologies for Future Embedded and Ubiquitious Systems (SEUS 2013</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="33" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Scope-based instruction cache analysis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Workshop on Worst-Case Execution Time Analysis (WCET 2014)</title>
		<meeting>the 14th International Workshop on Worst-Case Execution Time Analysis (WCET 2014)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The case for the precision timed (PRET) machine</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC &apos;07: Proceedings of the 44th annual conference on Design automation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="264" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Predictable programming on a precision timed architecture</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lickly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES 2008)</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Altman</surname></persName>
		</editor>
		<meeting>the International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES 2008)<address><addrLine>Atlanta, GA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A PRET microarchitecture implementation with repeatable timing and competitive performance</title>
		<author>
			<persName><forename type="first">I</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reineke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Broman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Computer Design</title>
		<meeting>IEEE International Conference on Computer Design</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>ICCD 2012</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Precision timed machines</title>
		<author>
			<persName><forename type="first">I</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012-05">May 2012</date>
			<pubPlace>Berkeley</pubPlace>
		</imprint>
		<respStmt>
			<orgName>EECS Department, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A PRET architecture supporting concurrent programs with composable timing properties</title>
		<author>
			<persName><forename type="first">I</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reineke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Signals, Systems and Computers, 2010 Conference Record of the Forty-Four Asilomar Conference on</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">FlexPRET: A processor platform for mixed-criticality systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Broman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th IEEE Real-Time and Embedded Technology and Application Symposium (RTAS)</title>
		<meeting>the 20th IEEE Real-Time and Embedded Technology and Application Symposium (RTAS)<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The risc-v instruction set manual, volume i: Base user-level isa</title>
		<author>
			<persName><forename type="first">A</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
		<idno>UCB/EECS-2011-62</idno>
		<imprint>
			<date type="published" when="2011-05">May 2011</date>
			<pubPlace>Berkeley</pubPlace>
		</imprint>
		<respStmt>
			<orgName>EECS Department, University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Time-predictable computer architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP Journal on Embedded Systems</title>
		<imprint>
			<biblScope unit="volume">758480</biblScope>
			<biblScope unit="page">17</biblScope>
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
	<note>Article ID</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<title level="m">Is time predictability quantifiable?, in: International Conference on Embedded Computer Systems (SAMOS 2012</title>
		<meeting><address><addrLine>Samos, Greece</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Assessing the suitability of the ngmp multi-core processor in the space domain</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gioiosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quiñones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fossati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zulianello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Cazorla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Embedded Software (EMSOFT)</title>
		<meeting><address><addrLine>Tampere, Finland</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="175" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Switched network on chip for hard real time embedded systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wiklund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Socbus</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE International Parallel and Distributed Processing Symposium, IPDPS</title>
		<meeting>IEEE International Parallel and Distributed essing Symposium, IPDPS</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page">78</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An energy-efficient reconfigurable circuit-switched network-on-chip</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wolkotte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rauwerda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Smit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th IEEE International Parallel and Distributed Processing Symposium</title>
		<meeting>19th IEEE International Parallel and Distributed essing Symposium</meeting>
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
			<biblScope unit="page">155</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The AEthereal network on chip: Concepts, architectures, and implementations</title>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dielissen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rȃdulescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design and Test of Computers</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="414" to="421" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">On-chip interconnect with aelite / Composable and predictable systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Guaranteed bandwidth using looped containers in temporally disjoint networks within the nostrum network on chip</title>
		<author>
			<persName><forename type="first">M</forename><surname>Millberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Thid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jantsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design, Automation and Test in Europe (DATE)</title>
		<meeting>Design, Automation and Test in Europe (DATE)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="890" to="895" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<title level="m">International Conference on Field-Programmable Logic and its Applications (FPL 2007)</title>
		<meeting><address><addrLine>Amsterdam, Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="377" to="382" />
		</imprint>
	</monogr>
	<note>A time-triggered network-on-chip</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Concepts of switching in the time-triggered network-on-chip</title>
		<author>
			<persName><forename type="first">C</forename><surname>Paukovits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kopetz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE International Conference on Embedded and Real-Time Computing Systems and Applications (RTCSA)</title>
		<meeting>IEEE International Conference on Embedded and Real-Time Computing Systems and Applications (RTCSA)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="120" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A Scheduling Discipline for Latency and Bandwidth Guarantees in Asynchronous Network-on-chip</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bjerregaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sparsø</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC)</title>
		<meeting>IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="34" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Network on chip with quality of service, uS Patent 8</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Durand</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">Dec. 31 2013</date>
			<biblScope unit="volume">619</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Schedulability analysis for real time on-chip communication with wormhole switching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Indrusiak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Embedded and Real-Time Communication Systems (IJERTCS)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">End-to-end schedulability tests for multiprocessor embedded systems based on networks-on-chip with priority-preemptive arbitration</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Indrusiak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems Architecture</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="553" to="561" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Application of network calculus to guaranteed service networks, Information Theory</title>
		<author>
			<persName><forename type="first">J.-Y. Le</forename><surname>Boudec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1087" to="1096" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Analytical modeling and evaluation of on-chip interconnects using network calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bakhouya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Suboh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gaber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>El-Ghazawi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE International Symposium on Networks-on-Chip</title>
		<meeting>ACM/IEEE International Symposium on Networks-on-Chip</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="74" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A generic, scalable and globally arbitrated memory tree for shared dram access in real-time systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Gomony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Garside</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Audsley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2014 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
		<meeting>2014 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page">p</biblScope>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">MEDEA: a hybrid shared-memory/message-passing multiprocessor NoC-based architecture</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Tota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Casu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Roch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rostagno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zamboni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE 2010)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="45" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">The tile processor : A 64-core multicore for embedded processing markets demanding more performance</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Mesh-of-Trees and Alternative Interconnection Networks for Single-Chip Parallelism</title>
		<author>
			<persName><forename type="first">A</forename><surname>Balkan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Vishkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1419" to="1432" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A fully-synthesizable singlecycle interconnection network for Shared-L1 processor clusters, 2011 Design</title>
		<author>
			<persName><forename type="first">I</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Loi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kakoee</surname></persName>
		</author>
		<author>
			<persName><surname>Benini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automation &amp; Test in Europe</title>
		<imprint>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A time-predictable memory network-on-chip</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sparsø</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Workshop on Worst-Case Execution Time Analysis</title>
		<meeting>the 14th International Workshop on Worst-Case Execution Time Analysis</meeting>
		<imprint>
			<publisher>WCET</publisher>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Self-optimizing memory controllers: A reinforcement learning approach</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ipek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Martínez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Caruana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Architecture, 2008. ISCA&apos;08. 35th International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="39" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Thread cluster memory scheduling: Exploiting differences in memory access behavior</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Papamichael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harchol-Balter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Microarchitecture (MICRO), 2010 43rd Annual IEEE/ACM International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="65" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Memory scheduling for modern microprocessors</title>
		<author>
			<persName><forename type="first">I</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Methodology for designing statically scheduled application-specific sdram controllers using constrained local search</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bayliss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Constantinides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FPT 2009. International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="304" to="307" />
		</imprint>
	</monogr>
	<note>Field-Programmable Technology</note>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Architectures and modeling of predictable memory controllers for improved system integration</title>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Pret dram controller: Bank privatization for predictability and temporal isolation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Reineke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the seventh IEEE/ACM/IFIP international conference on Hardware/software codesign and system synthesis, ACM</title>
		<meeting>the seventh IEEE/ACM/IFIP international conference on Hardware/software codesign and system synthesis, ACM</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Bounding wcet of applications using sdram with priority based budget scheduling in mpsocs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="page" from="665" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Worst case analysis of dram latency in multi-requestor systems</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">P</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Krish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pellizzoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Real-Time Systems Symposium (RTSS)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="372" to="383" />
		</imprint>
	</monogr>
	<note>IEEE 34th</note>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Bounding memory interference delay in cots-based multi-core systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>De Niz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Andersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Rajkumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 20th IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS 2014)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Timing effects of ddr memory systems in hard real-time multicore architectures: Issues and solutions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Paolieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quiñones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Cazorla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Embedded Computing Systems (TECS)</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1s</biblScope>
			<biblScope unit="page">64</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">DRAMsim: a memory system simulator</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tuaycharoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Baynes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="100" to="107" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Design of a wcet-aware c compiler</title>
		<author>
			<persName><forename type="first">H</forename><surname>Falk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lokuciejewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Theiling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th International Workshop on Worst-Case Execution Time Analysis (WCET&apos;06)</title>
		<title level="s">OpenAccess Series in Informatics (OASIcs), Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Mueller</surname></persName>
		</editor>
		<meeting><address><addrLine>Dagstuhl, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">A compiler framework for the reduction of worst-case execution times</title>
		<author>
			<persName><forename type="first">H</forename><surname>Falk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lokuciejewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="page" from="1" to="50" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">LLVM: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Code Generation and Optimization (CGO&apos;04)</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="75" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Transforming flow information during code optimization for timing analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kirner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prantl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="72" to="105" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Simplifying wcet analysis by code transformations</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Negi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Worst-Case Execution-Time Analysis (WCET)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">The single-path approach towards wcet-analysable software</title>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2003 IEEE International Conference on Industrial Technology</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="699" to="704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">A time-predictable vliw processor and its compiler support</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="84" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">The worst-case execution time problem -overview of methods and survey of tools</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Engblom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ermedahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Holsti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thesing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Whalley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bernat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Puaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staschulat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. on Embedded Computing Sys</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="53" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;77: Proceedings of the 4th ACM Symposium on Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<title level="m" type="main">The influence of processor architecture on the design and results of WCET tools, Proceedings of the IEEE</title>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Langenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thesing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="1038" to="1054" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Predictability considerations in the design of multi-core embedded systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cullmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gebhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maiza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reineke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Triquet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Embedded Real Time Software and Systems</title>
		<meeting>Embedded Real Time Software and Systems</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Gebhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cullmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<title level="m">Bringing Theory to Practice: Predictability and Performance in Embedded Systems, DATE Workshop PPES 2011</title>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
		<respStmt>
			<orgName>OASICS, Schloss Dagstuhl -Leibniz-Zentrum fuer Informatik</orgName>
		</respStmt>
	</monogr>
	<note>Software structure and WCET predictability</note>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<title level="m" type="main">A modular tool architecture for worst-case execution time analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ermedahl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Reliable and precise WCET determination for a real-life processor</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Langenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Theiling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thesing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EMSOFT</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2211</biblScope>
			<biblScope unit="page" from="469" to="485" />
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">Worst-case execution time prediction by static program analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-11">November 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. rep., AbsInt Angewandte Informatik GmbH</note>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Worst-case execution time -a tool provider&apos;s perspective</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th IEEE International Symposium on Object/component/service-oriented Real-time distributed Computing ISORC 2008</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="340" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">An abstract interpretation-based timing validation of hard real-time avionics software</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thesing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Souyris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Randimbivololona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Langenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN 2003)</title>
		<meeting>the 2003 International Conference on Dependable Systems and Networks (DSN 2003)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="625" to="632" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Computing the worst case execution time of an avionics program by abstract interpretation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Souyris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Le Pavec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Himbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jégu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Borios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Intl Workshop on Worst-Case Execution Time (WCET) Analysis</title>
		<meeting>the 5th Intl Workshop on Worst-Case Execution Time (WCET) Analysis</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="21" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schlickling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jersak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<title level="m">Timing validation of automotive software, in: 3rd International Symposium on Leveraging Applications of Formal Methods, Verification and Validation (ISOLA)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="93" to="107" />
		</imprint>
		<respStmt>
			<orgName>Computer and Information Science (CCIS)</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">A modular and retargetable framework for tree-based wcet analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Colin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Puaut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Real-Time Systems, 13th Euromicro Conference on</title>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">OTAWA: an open toolbox for adaptive WCET analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ballabriga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cassé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rochange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sainrat</surname></persName>
		</author>
		<idno>13/10/2010-15/10/2010</idno>
	</analytic>
	<monogr>
		<title level="m">IFIP Workshop on Software Technologies for Future Embedded and Ubiquitous Systems (SEUS)</title>
		<meeting><address><addrLine>Waidhofen/Ybbs, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
	<note>regular paper</note>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Worst-case execution time analysis for a Java processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">U</forename><surname>Pedersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="507" to="542" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Systems</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rapitime</forename><surname>Explained</surname></persName>
		</author>
		<author>
			<persName><surname>Whitepaper</surname></persName>
		</author>
		<ptr target="http://www.rapitasystems.com/system/files/RapiTime%" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">WCET driven design space exploration of an object cache</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Puffitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Java Technologies for Real-time and Embedded Systems (JTRES 2010)</title>
		<meeting>the 8th International Workshop on Java Technologies for Real-time and Embedded Systems (JTRES 2010)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="26" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Experiments with WCET-oriented programming and the single-path architecture</title>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th IEEE International Workshop on Object-Oriented Real-Time Dependable Systems</title>
		<meeting>10th IEEE International Workshop on Object-Oriented Real-Time Dependable Systems</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Compiling for time predictability</title>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kirner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Prokesch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Safety, Reliability, and Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Ortmeier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Daniel</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Berlin / Heidelberg</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7613</biblScope>
			<biblScope unit="page" from="382" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Efficient and precise cache behavior prediction for real-time systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="131" to="181" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Static analysis of worst-case stack cache behavior</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Real-Time Networks and Systems (RTNS 2013)</title>
		<meeting>the 21st International Conference on Real-Time Networks and Systems (RTNS 2013)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">The AEthereal network on chip after ten years: Goals, evolution, lessons, and future</title>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hansson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th ACM/IEEE Design Automation Conference (DAC 2010)</title>
		<meeting>the 47th ACM/IEEE Design Automation Conference (DAC 2010)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="306" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Static routing in symmetric real-time networkon-chips</title>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Real-Time and Network Systems (RTNS 2012)</title>
		<meeting>the 20th International Conference on Real-Time and Network Systems (RTNS 2012)<address><addrLine>Pont a Mousson, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Sørensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sparsø</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ruvald Pedersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Højgaard</surname></persName>
		</author>
		<title level="m">A Metaheuristic Scheduler for Time Division Multiplexed Networks-on-Chip, in: IEEE Workshop on Software Technologies for Future Embedded and Ubiquitous Systems (SEUS)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">aelite: a flit-synchronous network on chip with composable and predictable services</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Subburaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Design, Automation and Test in Europe</title>
		<meeting>the Conference on Design, Automation and Test in Europe<address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="250" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">An area-efficient network interface for a TDM-based network-on-chip</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sparsø</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kasapaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Design, Automation and Test in Europe, DATE &apos;13, EDA Consortium</title>
		<meeting>the Conference on Design, Automation and Test in Europe, DATE &apos;13, EDA Consortium<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1044" to="1047" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Poulton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Systems Engineering</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<title level="m" type="main">Principles of asynchronous circuit design -A systems perspective</title>
		<editor>J. Sparsø, S. Furber</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Blueshell : A Platform for Rapid Prototyping of Multiprocessor NoCs and Accelerators</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plumbridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whitham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Audsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings HEART Workshop</title>
		<meeting>HEART Workshop</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>University of York</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<monogr>
		<title level="m" type="main">Multiplexer Design Techniques for Datapath Performance with Minimized Routing Resources</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chapman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Xilinx Application Note</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Prefetching across a shared memory tree within a network-on-chip architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Garside</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C</forename><surname>Audsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">System on Chip (SoC), 2013 International Symposium on</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Improving direct-mapped cache performance by the addition of a small fully-associative cache and prefetch buffers</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Annual International Symposium on Computer Architecture</title>
		<meeting>the 17th Annual International Symposium on Computer Architecture<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="364" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Stride directed prefetching in scalar processors</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W C</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Janssens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMICRO Newsletter</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="102" to="110" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Prefetching using Markov predictors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th annual international symposium on Computer architecture -ISCA &apos;97</title>
		<meeting>the 24th annual international symposium on Computer architecture -ISCA &apos;97<address><addrLine>New York, New York, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="252" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Data Cache Prefetching Using a Global History Buffer</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nesbit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th International Symposium on High Performance Computer Architecture (HPCA&apos;04)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="96" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Memory-map selection for firm real-time sdram controllers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goossens</surname></persName>
			<affiliation>
				<orgName type="collaboration">EDA Consortium</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kouters</surname></persName>
			<affiliation>
				<orgName type="collaboration">EDA Consortium</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
			<affiliation>
				<orgName type="collaboration">EDA Consortium</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
			<affiliation>
				<orgName type="collaboration">EDA Consortium</orgName>
			</affiliation>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Design, Automation and Test in Europe</title>
		<meeting>the Conference on Design, Automation and Test in Europe</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="828" to="831" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Dynamic command scheduling for realtime memory controllers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Akesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Goossens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Euromicro Conference on Real-Time Systems (ECRTS)</title>
		<meeting>Euromicro Conference on Real-Time Systems (ECRTS)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Splitting functions into single-entry regions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 International Conference on Compilers, Architecture and Synthesis for Embedded Systems, CASES &apos;14</title>
		<meeting>the 2014 International Conference on Compilers, Architecture and Synthesis for Embedded Systems, CASES &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">Lazy Spilling for a Time-Predictable Stack Cache: Implementation and Analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abbaspour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OpenAccess Series in Informatics (OASIcs), Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Falk</surname></persName>
		</editor>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="83" to="92" />
		</imprint>
	</monogr>
	<note>14th International Workshop on Worst-Case Execution Time Analysis</note>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Prokesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th International Workshop on Worst-Case Execution Time Analysis</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Falk</surname></persName>
		</editor>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-07-08">2014. July 8, 2014. 2014</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="103" to="112" />
		</imprint>
	</monogr>
	<note>WCET</note>
</biblStruct>

<biblStruct xml:id="b114">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Bernat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Holsti</surname></persName>
		</author>
		<title level="m">Compiler support for WCET analysis: a wish list</title>
		<imprint>
			<publisher>WCET</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="65" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Combined WCET analysis of bitcode and machine code using control-flow relation graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Prokesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM SIGPLAN/SIGBED conference on Languages, compilers and tools for embedded systems (LCTES 2013)</title>
		<meeting>the 14th ACM SIGPLAN/SIGBED conference on Languages, compilers and tools for embedded systems (LCTES 2013)</meeting>
		<imprint>
			<publisher>The Association for Computing Machinery</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="163" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Criticality: static profiling for real-time programs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hepp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="page" from="1" to="34" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<monogr>
		<title level="m" type="main">Integrated modular avionics for space applications: Input/output module, Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Silva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>Instituto Superior Técnico, Universidade Técnica de Lisboa</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Cazorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gioiosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quiñones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">S</forename><surname>Multicore</surname></persName>
		</author>
		<author>
			<persName><surname>Benchmark</surname></persName>
		</author>
		<idno>RFQ-3-13153/10/NL/JK</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ESA) and Barcelona Supercomputing Center</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
