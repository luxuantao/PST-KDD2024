<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Key-Dependent Message Security: Generic Amplification and Completeness</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Benny</forename><surname>Applebaum</surname></persName>
							<email>benny.applebaum@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="department">School of Electrical Engineering</orgName>
								<orgName type="institution">Tel-Aviv University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Key-Dependent Message Security: Generic Amplification and Completeness</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C99D00CFD10A68917D0B8EC4258185E7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:03+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Key-dependent message (KDM) secure encryption schemes provide secrecy even when the attacker sees encryptions of messages related to the secret-key sk. Namely, the scheme should remain secure even when messages of the form f (sk) are encrypted, where f is taken from some function class F. A KDM amplification procedure takes an encryption scheme which satisfies F-KDM security and boost it into a G-KDM secure scheme, where the function class G should be richer than F. It was recently shown by Brakerski et al. (TCC 2011)  and Barak et  al. (EUROCRYPT 2010), that a strong form of amplification is possible, provided that the underlying encryption scheme satisfies some special additional properties.</p><p>In this work, we prove the first generic KDM amplification theorem which relies solely on the KDM security of the underlying scheme without making any other assumptions. Specifically, we show that an elementary form of KDM security against functions in which each output bit either copies or flips a single bit of the key (aka projections) can be amplified into KDM security with respect to any function family that can be computed in arbitrary fixed polynomial-time. Furthermore, our amplification theorem and its proof are insensitive to the exact setting of KDM security, and they hold in the presence of multiple-keys and in the symmetric-key/public-key and the CPA/CCA cases. As a result, we can amplify the security of all known KDM constructions, including ones that could not be amplified before.</p><p>Finally, we study the minimal conditions under which full-KDM security (with respect to all functions) can be achieved. We show that under strong notion of KDM security, the existence of cyclic-secure fullyhomomorphic encryption is not only sufficient for full-KDM security, as shown by Barak et al., but also necessary. On the other hand, we observe that for standard KDM security, this condition can be relaxed by adopting Gentry's bootstrapping technique (STOC 2009)  to the KDM setting.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The study of secure encryption scheme is perhaps the most central subject in cryptography. Since the discovery of semantic security <ref type="bibr" target="#b26">[24]</ref> till the formulation Work done in part a postdoc at the Weizmann Institute of Science, supported by Alon and Koshland Fellowships.</p><p>of CCA-security <ref type="bibr" target="#b35">[31,</ref><ref type="bibr" target="#b37">33,</ref><ref type="bibr" target="#b20">18]</ref>, modern cryptography has successfully developed increasingly stronger notions of security providing secrecy in highly adversarial settings. Still, all these strong notions of security guarantee secrecy only as long as the encrypted messages are independent of the secret key. This limitation dates back to the seminal work of Goldwasser and Micali <ref type="bibr" target="#b26">[24]</ref> who observed that semantic security may not hold if the adversary gets to see an encryption of the secret key. For many years, such usage scenarios were considered as "security bugs" that should be prevented by system designers.</p><p>A decade ago, the assumption of independency between the secret key and the encrypted data was challenged by Camenisch and Lysyanskaya <ref type="bibr" target="#b17">[16]</ref> and Black et al. <ref type="bibr" target="#b12">[11]</ref>. Specifically, Camenisch and Lysyanskaya considered schemes that remain secure under a "key cycle" usage, where we have t keys organized in a cycle and each key is encrypted under its left neighbor. A generalization of this notion, called key-dependent message (KDM) security, was suggested by Black et al. Informally, an encryption is KDM (t) secure with respect to a function class F if security holds even when the adversary can ask for an encryption of the message M = f (sk 1 , . . . , sk t ) under the i-th public-key, where sk 1 , . . . , sk t are the secret keys present in the system and f is an arbitrary function in F . This notion of security implies cyclic-security if F is expressive enough (e.g., contains all "selector" functions), and it becomes strictly stronger when the function class F grows. Hence, one would like to achieve KDM security while making the function class F as large as possible.</p><p>The notion of KDM security was extensively studied in the past few years in several flavors including the symmetric/public-key and the CPA/CCA settings <ref type="bibr" target="#b17">[16,</ref><ref type="bibr" target="#b12">11,</ref><ref type="bibr" target="#b28">26,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b29">27,</ref><ref type="bibr" target="#b27">25,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b14">13]</ref>. These works were motivated by the fundamental nature of the question as well as by concrete applications including encrypted storage systems (e.g., BitLocker <ref type="bibr" target="#b13">[12]</ref>), anonymous credentials <ref type="bibr" target="#b17">[16]</ref>, and realization of security proofs at the framework of axiomatic security <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">11,</ref><ref type="bibr" target="#b2">3]</ref>. (See <ref type="bibr" target="#b13">[12]</ref> for more motivations and details.)</p><p>Although much is known today about KDM security both on the positive and negative sides, it is still unclear whether a standard encryption scheme can be transformed into a scheme which provides KDM (t) security, even with respect to a single key (i.e., t = 1) and simple non-trivial function families (e.g., selectors) <ref type="foot" target="#foot_1">1</ref> . Hence, it is natural to move forward and explore the possibility of building strong KDM security given a weak form of KDM security as a primitive. This makes sense as today, following the seminal work of Boneh et al. <ref type="bibr" target="#b13">[12]</ref> and its followups <ref type="bibr" target="#b16">[15,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">13]</ref>, it is known that a basic form of KDM security (with respect to the family of "affine functions") can be achieved in several settings under various concrete cryptographic assumptions. Therefore, following <ref type="bibr" target="#b15">[14]</ref> we ask: Is there a generic transformation which amplifies KDM security from a weak family of functions F to a larger family of functions G ?</p><p>The two main features of such a procedure are generality -the transformation should work with any scheme which satisfies F -KDM security without relying on any other additional property -and large amplification gap -ideally, F is a very simple function class whereas G is as rich as possible. The question of KDM amplification was recently addressed by Brakerski et al. <ref type="bibr" target="#b15">[14]</ref> and <ref type="bibr">Barak et</ref> al. <ref type="bibr" target="#b10">[10]</ref>, who made an important progress by showing how to amplify the KDM security of several existing schemes. While these works achieve relatively large amplification gap, they fall short of providing full generality as they strongly rely on additional properties of the underlying scheme (i.e., simulatable-KDM security and entropic-KDM security -to be defined later). As a concrete example, it is unknown how to use any of these techniques to amplify the KDM-security of the symmetric-key encryption scheme of <ref type="bibr" target="#b4">[5]</ref> which is based on the Learning Parity With Noise (LPN) assumption. (See Section 1.3 for more details about these works and their relation to our approach).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Results</head><p>We give an affirmative answer to the above question by providing the first generic KDM amplification procedure. In particular, we consider the projection function class of all functions f : (sk 1 , . . . , sk t ) → v in which each output bit depends on (at most) a single bit of the input. Namely, each output bit v j is either fixed to a constant or copies/flips an original bit of one of the keys. We show that this elementary function family is complete in the following sense: Theorem 1 (Completeness of projections, Informal). Let G be any function family which can be computed in some fixed polynomial time. Then, any encryption scheme which satisfies KDM (t) security with respect to projections can be transformed into a new encryption scheme which is KDM (t) -secure with respect to G.</p><p>Generality. Theorem 1 assumes nothing but KDM security regarding the underlying scheme. Furthermore, the theorem (and its surprisingly simple proof) is insensitive to the exact setting of KDM security: it holds for any number of keys (t), and in both symmetric-key/public-key and CPA/CCA settings. In all these cases, the new scheme is proven to be secure exactly in the same setting as the original scheme. This allows us, for example, to amplify the security of the affine-KDM secure scheme of <ref type="bibr" target="#b4">[5]</ref>, and obtain the first symmetric-key encryption scheme with strong KDM security based on the LPN assumption.</p><p>Large gap. Theorem 1 provides a large amplification gap. In fact, this gap can be further expanded as follows. First, we can achieve length-dependent KDM security <ref type="bibr" target="#b10">[10]</ref>, which means that the target family G can be taken to be the family of all polynomial-size circuits whose size grows with their input and output lengths via a fixed polynomial rate (e.g., the circuit size is quadratic in the input and output lengths). This family is very powerful and it was shown to be rich enough for most known applications of KDM security <ref type="bibr" target="#b10">[10]</ref> <ref type="foot" target="#foot_2">2</ref> . (See Section 3 for details.) In addition, in the case of CPA security (both in the public-key and symmetric-key settings), we can weaken the requirement from the underlying scheme and ask for KDM security with respect to projections with a single output : namely, all Boolean functions f (sk 1 , . . . , sk t ) → b which output a single bit of one of the keys, or its negation. This can be extended to the CCA setting via the transformations of <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b16">15]</ref> (though in the public-key setting one has to employ, in addition, non-interactive zero-knowledge proofs).</p><p>The relaxation to single-output projections also enables a liberal interface to which we can easily plug previous constructions. For example, one can instantiate our reduction with schemes that enjoy KDM security with respect to affine functions, while almost ignoring technical details such as the underlying field and its representation. (These details required some effort in previous works. See the appendices in <ref type="bibr" target="#b15">[14,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b14">13]</ref>.) This, together with the simple proof of our main theorem, allows to simplify the proofs of <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b14">13]</ref> for the existence of lengthdependent KDM secure encryption scheme under the Decisional Diffie-Hellman (DDH) assumption <ref type="bibr" target="#b13">[12]</ref>, the Learning With Errors assumptions (LWE) <ref type="bibr" target="#b4">[5]</ref>, and the Quadratic Residuosity (QR) assumption <ref type="bibr" target="#b14">[13]</ref>.</p><p>Given this completeness theorem, the current status of KDM security resembles the status of other "complete" primitives in cryptography such as one-way functions or oblivious transfer <ref type="bibr" target="#b36">[32,</ref><ref type="bibr" target="#b21">19]</ref>: We do not know how to build these primitives from generic weaker assumptions, however, any instantiation of them suffices for an entire world of applications (i.e., all symmetric-key primitives in the case of one-way functions, and generic secure-computation in the case of oblivious transfer, cf. <ref type="bibr" target="#b24">[22,</ref><ref type="bibr" target="#b25">23]</ref>).</p><p>Beyond length-dependent security. Although length-dependent KDM security seems to suffice for most applications, one can strive for an even stronger notion of security in which the KDM function class contains all functions (or equivalently all functions computable by circuits of arbitrary polynomial size). It is somewhat likely that any length-dependent secure scheme actually achieves full-KDM security (see the discussion in <ref type="bibr" target="#b10">[10]</ref>). Still, one may want to construct such a scheme in a provably secure way. As a basic feasibility result, it was shown in <ref type="bibr" target="#b10">[10]</ref> that any fully homomorphic encryption scheme <ref type="bibr" target="#b22">[20]</ref> which allows to encrypt the secret-key (i.e., "cyclic-secure") is also full-KDM secure. In light of the small number of FHE candidates <ref type="bibr" target="#b22">[20,</ref><ref type="bibr">17]</ref>, and our little understanding of this notion, one may ask whether it is possible to relax this requirement and achieve full-KDM security under weaker assumptions.</p><p>We make two simple observations regarding this question. First, we consider the case of simulatable KDM security <ref type="bibr" target="#b10">[10]</ref>, in which it should be possible to simulate an encryption of f (sk) given only the corresponding public-key in a way that remains indistinguishable even to someone who knows the secret-key.</p><p>We show that in this setting the two notions: circular-secure FHE and full-KDM are equivalent. Hence, achieving full-KDM security under a relaxed assumption requires to use non-simulatable constructions.</p><p>Our second observation asserts that the bootstrapping technique of Gentry <ref type="bibr" target="#b22">[20]</ref> can be used in the KDM setting as well (even for the case of nonsimulatable constructions). That is, if one can construct an encryption scheme which guarantees KDM security with respect to circuits whose depth is only slightly larger than the depth of the decryption algorithm, then this scheme is actually fully KDM secure. Unfortunately, all known amplification techniques <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b15">14]</ref> including the ones in this paper, amplify KDM security at the cost of making the decryption algorithm "deeper". Still, we view this observation as an interesting direction for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Techniques</head><p>To formalize the question of KDM amplification, we define the notion of reduction between KDM function families G ≤ KDM F which means that any scheme that provides KDM security with respect to F can be transformed (via a fully blackbox reduction) to a new scheme that satisfies KDM security with respect to G. We describe a novel way to derive such KDM reductions based on the machinery of randomized encoding of functions <ref type="bibr" target="#b32">[29,</ref><ref type="bibr" target="#b6">7]</ref>. Before we explain this notion, let us start with the simpler case of deterministic encoding.</p><p>Say that a function f deterministically encodes a function g if for every x the output of f (x) "encodes" the output of g(x) in the sense that g(x) can be efficiently computed based on f (x) and vice versa. That is, there are two efficiently computable mappings S and R such that S(g(x)) = f (x), and R(f (x)) = g(x). Suppose that we are given a scheme which provides KDM security with respect to the encoding f , and we would like to immunize it against the function g. This can be easily achieved by modifying the encryption scheme as follows: to encrypt a message M we first translate it into the f -encoding by computing S(M ), and then encrypt the result under the original encryption scheme. Decryption is done by applying the original decryption algorithm, and then applying the recovery algorithm R to translate the result back to its original form. Observe that an encryption of g(sk) in the new scheme is the same as an encryption of S(g(sk)) = f (sk) under the original scheme. Hence, the KDM security of the new scheme with respect to g reduces to the KDM security of the original scheme with respect to f . This simple idea provides a direct reduction with very nice structure: any KDM query for the new scheme is translated into a single KDM query for the original scheme. This simple single-query-to-single-query translation leads to high level of generality: the transformation is insensitive to the exact KDM setting (symmetrickey/public-key and CPA/CCA), to the number of keys, and it can be used with respect to large function families G and F as long as every function in G is encoded by some function in F via a pair of universal mappings S and R. On the down side, one may complain that security was not really amplified, as the function g and its encoding f are essentially equivalent. It turns out that this drawback can be easily fixed by letting f be a randomized encoding of g.</p><p>In the case of randomized encoding (RE), the function f (x; r) depends not only on x but also on an additional random input r. For every fixed x, the output of f (x; r) is now viewed as a distribution (induced by a random choice of r) which should encode the value of g(x). Namely, there are two efficiently computable randomized mappings S and R such that for every x: (1) the distribution S(g(x)) is indistinguishable from f (x; r), and (2) with high probability over the choice of r (or even with probability one) R(f (x; r)) = g(x). One can view these conditions as saying that g(x) is encoded by a collection of functions {f r (x)} r , where f r (x) = f (x; r). Now suppose that our scheme is KDM secure with respect to the family {f r (x)} r , then we can apply the above approach and get a scheme which satisfies KDM security with respect to g. The only difference is that now the message preprocessing step is randomized: To encrypt a message M first encode it by the randomized mapping S(M ), and then use the original encryption function. The security reduction is essentially the same except that a KDM query for g in the new scheme is emulated by an old KDM query for a randomly chosen function f r . This idea can be easily extended to the case where all functions in G are encoded by functions in F :</p><formula xml:id="formula_0">Theorem 2 (Informal). If F is an RE of G, then G ≤ KDM F .</formula><p>The crux of this theorem, is that, unlike deterministic encoding, randomized encoding can represent complicated functions by collections of very simple functions <ref type="bibr" target="#b32">[29,</ref><ref type="bibr" target="#b33">30,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b5">6]</ref>. Specifically, by combining the above theorem with the REs of <ref type="bibr" target="#b5">[6]</ref>, which, in turn, are based on Yao's garbled circuit <ref type="bibr" target="#b38">[34]</ref>, we obtain our main results (Thm. 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Comparison with BGK and BHHI</head><p>Our techniques are inspired by both <ref type="bibr" target="#b15">[14]</ref> (BGK) and <ref type="bibr" target="#b10">[10]</ref> (BHHI). We believe that our approach inherits the positive features of each of these works, and sheds new light on the way they relate to each other. Let us review the main ideas behind these constructions and explain how they compare to our solution.</p><p>The BGK reduction. The starting point in <ref type="bibr" target="#b15">[14]</ref> is an encryption scheme which satisfies entropic KDM security with respect to F . Roughly speaking, this means that KDM security should hold not only when sk is chosen uniformly from the key space K = {0, 1} k but also when it is chosen uniformly from a smaller domain K , e.g., K = {0, 1} k ε . By relying on this notion, BGK shows that for every efficiently computable injective mapping α : K → K, one can amplify security from F to the class F • α, i.e., with respect to functions f (α(sk)) for every f ∈ F. The idea is to choose the key sk from K and employ the original scheme with the key sk = α(sk ). This allows to translate a KDM query f (α(sk )) for the new scheme into an entropic-KDM query f (sk) for the old scheme.</p><p>The deterministic encoding (DE) approach is inspired by the BGK approach, and can be seen as a complementary solution. BGK extends a function f : K → M to f • α : K → M by shrinking the key space (from K to K ), whereas in the DE approach f : K → M is extended to R • f : K → M by padding messages which effectively shrinks the message space (from M to M = R(M)).</p><p>As a result BGK enjoys a similar attractive security reduction with singlequery-to-single-query translation. This leads to flexibility with respect to the KDM setting. Indeed, although the BGK approach is not fully general due to its use of entropic-KDM security (a notion which seems stronger than standard KDM security), it immediately generalizes to the CCA and the symmetric-key settings, as long as the underlying scheme provides entropic-KDM security.</p><p>It should be mentioned that in our approach the amplification is achieved by modifying the encryption algorithm, rather than the key-generation algorithm as in BGK. This minor difference turns to have a considerable effect on the amplification-gap. First, it allows to use fresh randomness in every application of the encryption algorithm, and so the linkage between functions in G to functions in F can be randomized. Indeed, this is exactly what allows us to exploit the power of randomized encoding. In contrast, the BGK approach tweaks the keygeneration algorithm and so the relation between G to F is bounded to be deterministic. In addition, since our modification happens in the encryption (and decryption) phases, we can let the function class G grow not only with the security parameter but also with the size of the messages. This leads to the strong notion of length-dependent security, and in addition allows to achieve KDM (t) where the number of keys t grows both with the message length and the security parameter.</p><p>In contrast, the family G of BGK cannot grow with the message length, and it can only contain a polynomial number of functions. This limitation prevents it from being used in applications which require KDM security wrt larger functions classes (e.g., secure realization of symbolic protocols with axiomatic proofs of security). Furthermore, amplification for large number of keys can be achieved only at the expense of putting more restrictions on the underlying scheme (i.e., simulatable KDM security). On the other hand, assuming these additional properties, the BGK approach can get KDM (t) for arbitrary unbounded t with respect to some concrete function families (e.g., constant degree polynomials), whereas in our approach t is always bounded by some fixed polynomial (in the security parameter and message length) <ref type="foot" target="#foot_3">3</ref> . Finally, it is important to mention that the BGK reduction treats G in a black-box way, while the randomized encoding approach treats this class in a non-black-box way.</p><p>The BHHI reduction. The BHHI approach relies on a novel connection between homomorphic encryptions and KDM security. First, it is observed that in order to obtain KDM security with respect to G it suffices to construct a scheme which provides both cyclic-security (i.e., KDM security with respect to the identity function) and homomorphism with respect to a function family G, i.e., it should be possible to convert a ciphertext C = E pk (M ) into C = E pk (g(M )) for every g ∈ G. Indeed, the homomorphism property can be used to convert a ciphertext E pk (sk) into the ciphertext E pk (g(sk)), and so cyclic-security is amplified to G-KDM security.</p><p>BHHI construct such an encryption scheme by combining a two-party secure computation protocol with two messages (i.e., based on Yao's garbled circuit <ref type="bibr" target="#b38">[34]</ref>) with a strong version of oblivious transfer which satisfies an additional cyclicsecurity property. The latter primitive is referred to as targeted encryption (TE). The basic idea is to view the homomorphic property as a secure-computation task in which the first party holds the message M and the second party holds the function g. The cyclic nature of the TE primitive allows to implement this homomorphism even when the input M is the secret-key. Finally, BHHI show that TE can be constructed based on affine-KDM secure encryption scheme which satisfies a strong notion of simulation: There exists a simulator which given the public-key pk can simulate a ciphertext E pk (g(sk)) in a way which is indistinguishable even for someone who holds the secret-key.</p><p>The BHHI construction seems conceptually different from our RE approach (i.e., homomorphism vs. encoding). Moreover, the construction itself is not only syntactically different, but also relies on different building blocks (e.g., TE). Still, the RE construction shares an important idea with BHHI: The use of securecomputation techniques. It is well known that REs are closely related to secure multiparty-computation (MPC) protocols, and, indeed, the role of REs in our reduction resembles the role of MPC in BHHI. In both solutions at some point the security reduction applies the RE/MPC to the function g in G. Furthermore, both works achieve strong KDM security by instantiating the RE/MPC with Yao's garbled circuit (GC) -a tool which leads to both stand-alone RE construction <ref type="bibr" target="#b5">[6]</ref> and, when equipped with an OT, to a two-party secure-computation protocol.</p><p>It should be emphasized, however, that the actual constructions differ in some important aspects. While we essentially encrypt the whole GC-based encoding under the underlying KDM encryption scheme, BHHI tweak the GC protocol with a cyclic-secure OT (i.e., TE). Pictorially, our underlying KDM-secure scheme "wraps" the GC encoding, whereas in BHHI the KDM-secure primitive is "planted inside" the GC protocol. This difference affects both generality and simplicity as follows.</p><p>First, BHHI are forced to implement a KDM-secure OT, a primitive which seems much stronger than standard KDM secure encryption schemes. For example, KDM-secure symmetric-key encryption schemes can be constructed at the presence of a random oracle <ref type="bibr" target="#b12">[11]</ref> while OT protocols cannot <ref type="bibr" target="#b30">[28]</ref> 4 . Moreover, as we already mentioned, although TE can be based on several known affine-secure KDM schemes (i.e., ones which enable strong simulation), the LPN assumption (with constant error-rate) is a concrete example under which symmetric-key encryption scheme with KDM-security wrt affine functions exist, yet OT is not known to exist. Furthermore, since BHHI send the garbled circuit in the clear, it is not hard to show that the resulting scheme is not CCA-secure even if the TE provides CCA security. Finally, the modification of the GC protocol leads to a relatively complicated security proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>For a positive integer n ∈ N, let [n] denote the set {1, . . . , n}, and U n denote the uniform distribution over {0, 1} n . A function ε(n) is negligible if it tends to zero faster than 1/n c for every constant c &gt; 0. The term efficient refers to probabilistic machines that run in polynomial time in the security parameter.</p><p>Efficient functions and randomized functions. A randomized function f : {0, 1} * × {0, 1} * → {0, 1} * is a function whose second input is treated as a random input. We write f (x; r) to denote the evaluation of f on deterministic input x and random input r, and typically assume length regularity and efficient evaluation as follows: there are efficiently computable polynomials m(n) and (n) and an efficiently computable circuit family f n : {0, 1} n × {0, 1} m(n) → {0, 1} (n) which computes the restriction of f to n-bit deterministic inputs. If the function is not length regular, we assume that the circuit family is indexed by a pair of input and output parameters (n, ), and require evaluation in time poly(n, ). Finally, a deterministic function corresponds to the special case where m(n) = 0. Function ensembles. A function ensemble is a collection of functions {f z } z∈Z indexed by an index set Z ⊆ {0, 1} * , where for each z the function f z has a finite domain {0, 1} n(z) and a finite range {0, 1} (z) , where n, : {0, 1} * → N. By default, we assume that ensembles are efficiently computable, that is, the functions n(z), (z), as well as the function F (z, x) = f z (x) are computable in time poly(|z|). Hence n(z), (z) &lt; poly(|z|). We also assume that |z| &lt; poly(n(z), (z)).</p><p>Randomized encoding of functions. Intuitively, a randomized encoding of a function g(x) is a randomized mapping f (x; r) whose output distribution depends only on the output of g. We formalize this intuition via the notion of computationally private randomized encoding of <ref type="bibr" target="#b5">[6]</ref>, while adopting the original definition from a non-uniform adversarial setting to the uniform setting (i.e., adversaries are modeled by probabilistic polynomial-time Turing machines). Consider a function g = g n : {0, 1} n → {0, 1} (n) and a randomized function n) , which are both efficiently computable. We say that f encodes g, if there exist an efficient recovery algorithms Rec and an efficient simulator Sim that satisfy the following:</p><formula xml:id="formula_1">f = f n : {0, 1} n × {0, 1} m(n) → {0, 1} s(</formula><p>-perfect correctness. For every x ∈ {0, 1} n , the error probabilities Pr[Rec(1 n , f(x, U m(n) )) = g(x)] and Pr[Rec(1 n , Sim(1 n , g(x))) = g(x)] are both zero <ref type="foot" target="#foot_5">5</ref> . -computational privacy. For every efficient adversary A we have that</p><formula xml:id="formula_2">Pr[A f (•;U) (1 n ) = 1] -Pr[A Sim(g(•)) (1 n ) = 1] &lt; neg(n),</formula><p>where the oracles are defined as follows: Given x the first oracle returns a sample from f (x; U m(|x|) ) and the second oracle returns a sample from Sim(1 |x| , g(x)).</p><p>This notion is naturally extended to functions g n, which are not length-regular and are indexed by both input and output lengths. However, we always assume that privacy is parameterized only with the input length (i.e., the adversary's running-time/distinguishing-probability should be polynomial/negligible in the input length.) Note that, without loss of generality, we can assume that the relevant output length is always known to the decoder and simulator (i.e., it can be always encoded as part of the output of f n, ). Encryption schemes (syntax). An encryption scheme consists of three efficient algorithms (KG, E, D), where KG is a key generation algorithm which given a security parameter 1 k outputs a pair (sk, pk) of decryption and encryption keys; E is an encryption algorithm that takes a message M ∈ {0, 1} * and an encryption key pk and outputs a ciphertext C; and D is a decryption algorithm that takes a ciphertext C and a decryption key sk and outputs a plaintext M . We also assume that both algorithms take the security parameter 1 k as an additional input, but typically omit this dependency for simplicity. Correctness requires that the decryption error max</p><formula xml:id="formula_3">M∈{0,1} * Pr (sk,pk) R ←KG(1 k ) [D sk (E pk (M )) = M ],</formula><p>should be negligible in k, where the probability is taken over the randomness of KG, E and D. For security parameter k, let K k denote the space from which decryption keys are chosen. Without loss of generality, we always assume that</p><formula xml:id="formula_4">K k = {0, 1} k .</formula><p>Following Goldreich <ref type="bibr" target="#b25">[23]</ref>, we note that the above definition corresponds to both public-key and symmetric-key encryption schemes where the latter correspond to the special case in which the decryption key sk and encryption key pk are equal. As we will see, the difference between the two settings will be part of the security definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">KDM-Security</head><p>Let E = (KG, E, D) be an encryption scheme with key space K = {K k }. Let t : N → N be a function. A t-ary KDM function ensemble is an efficient ensemble of functions</p><formula xml:id="formula_5">F = f k,z : K t(k) k → {0, 1} * (k,z) . We let F k denote the set f k,z : K t(k) k → {0, 1} * z .</formula><p>An F -KDM Chosen-Ciphertext Attack (CCA) in the public-key setting is defined in Fig. <ref type="figure" target="#fig_1">1</ref> as a game that takes place between a challenger and an adversary A. The advantage of A when attacking a scheme E is α(k) = Pr[A wins the KDM game] - 1  2 .</p><p>-Initialization. The challenger randomly chooses a bit b R ← {0, 1} and t = t(k) key-pairs (sk1, pk 1 ) . . . , (skt, pk t ) by invoking KG(1 k ) for t times. The adversary A can send a "public-key" query and get to see all the encryption keys (pk 1 , . . , pk t ).</p><p>-Queries. The adversary A may adaptively make polynomially-many queries of the following types:</p><p>• Encryption queries of the form (i, M ) where i ∈ [t] and M ∈ {0, 1} * .</p><p>The challenger responds with  By restricting the power of the adversary in the KDM game (Fig. <ref type="figure" target="#fig_1">1</ref>) we get other KDM settings. Specifically, the symmetric-key setting corresponds to adversaries of type sym who do not ask public-key queries, and the CPA setting corresponds to adversaries of type CPA who do not make decryption queries. Hence, we can classify KDM adversaries into one of the following four types: (pub, CCA), (pub, CPA), (sym, CCA), and (sym, CPA). An adversary of type T that conducts an F -KDM attack is denoted as (T, F )-adversary.</p><formula xml:id="formula_6">C R ← E(pk i , M) if b = 1, and C R ← E(pk i , 0 |M | ) if b = 0. • KDM queries of the form (i, f ) where i ∈ [t] and f ∈ F k . The challenger computes M = f (sk1, . . . , skt) and responds with C R ← E(pk i , M) if b = 1, and C R ← E(pk i , 0 |M | ) if b = 0. • Decryption</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1. (KDM-secure encryption)</head><p>Let T be a type, and F be a function ensemble. An encryption scheme is (T, F )-KDM secure if every efficient (T, F ) adversary has at most negligible advantage when attacking the scheme.</p><p>Interesting KDM functions ensembles. For every t = t(k) and for every type T we consider the following ensembles:</p><p>-Selectors and projections. If the ensemble F k contains all selector functions {f j : (sk 1 , . . . , sk t ) → sk j } j∈[t] , we get the notion of clique security <ref type="bibr" target="#b13">[12]</ref> (which is stronger than circular security <ref type="bibr" target="#b17">[16]</ref>), that is, the scheme is secure even if the adversary sees encryptions of the form E pk i (sk j ) for every i, j ∈ [t].</p><p>Another elementary class that slightly generalizes the previous ones is the class of all functions f : (sk) → v in which each output bit depends on (at most) a single bit of the input sk = (sk 1 , . . . , sk t ). Namely, the j-th output bit v j is either fixed to a constant or copies/flips an original bit of one of the keys, i.e., v j ∈ {0, 1, sk i,q , 1 -sk i,q }, where sk i,q is the q-th bit of the i-th secret key. We refer to this class as the class of projections and let Π t k, denote the restriction of this class to functions of input length kt and output length (k). Projections is a proper subclass of the class of affine functions L :</p><formula xml:id="formula_7">F kt 2 F (k) 2</formula><p>. -Polynomial-size circuits <ref type="bibr" target="#b10">[10]</ref>. For polynomials p(•) and (•), let C t k, ,p denote the class of all circuits C : {0, 1} kt → {0, 1} (k) of size at most p(k) + p( ). Security with respect to this class is denoted by (p, )-bounded circuit-size KDM security. A slightly stronger notion of security is p-lengthdependent KDM security which means that the scheme is KDM secure with respect to C t k, ,p for every polynomial . While, ultimately one would like to have KDM security with respect to all polynomial-size circuits (for arbitrary polynomial), it seems that p-length-dependent security, say for quadratic p, may be considered to be almost as powerful since it allows the adversary to use larger circuits by encrypting longer messages. In particular, one can represent essentially any polynomial-time computable function via padding. That is, if a function f is not in the class since its circuit is too large, then a "padded" version f of f in which the output is padded with zeroes does fall into the ensemble. Furthermore, in <ref type="bibr" target="#b10">[10]</ref> it was shown that if p is sufficiently large (e.g., the quadratic polynomial) then length-dependent security is sufficient for axiomatic-security applications (i.e., it gives the ability to securely instantiate symbolic protocols with axiomatic proofs of security).</p><p>The above definitions become stronger when the arity t grows. At one extreme, one may consider a single scheme which satisfies any of the above definitions for an arbitrary polynomial t(k), and at the other extreme one may consider the case of t = 1, which is still non-trivial even for projection functions. Reductions among KDM-ensembles. We say that a KDM function ensemble G KDM-reduces to another KDM function ensemble F (in symbols G ≤ KDM F ) if there exists a transformation which converts an encryption scheme E that is F -KDM secure to an encryption scheme E which is G-KDM secure. Formally, such a (black-box) reduction is composed of (1) (construction) an encryption scheme E which is given an oracle access to the scheme E; and (2) (security reduction) an efficient algorithm B such that for any F -adversary A which attacks E with advantage α, the G-adversary B A,E attacks the scheme E with a similar advantage (up to a negligible loss). This definition can be instantiated with respect to all four different types. We say that the reduction is type-preserving if B A,E is always of the same type as A (i.e., B always ask the same type of queries that A asks in the KDM game.) Type preserving reduction extends KDM-security while being insensitive to the concrete setting which is being used. Formally, Lemma 1 (KDM-reductions). Suppose that the KDM function ensemble G KDM-reduces to the ensemble F via a type-preserving reduction ( E, B). For every T ∈ {pub, sym}× {CCA, CPA}, if the encryption scheme E is (T, F )-KDM secure then the scheme E E is (T, G)-KDM secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Reductions and Completeness Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">KDM Reductions via Randomized Encoding</head><p>Let F = {f k,z } and G = {g k,w } be a pair of KDM function ensembles with the same arity t = t(k). We say that F encodes G if every function g(x) in G has a randomized encoding f (x; r) such that for every fixing of the random string r, the resulting function f r (x) is in F . More formally, the evaluation function G k (z, x) of G should have a randomized encoding F k ((z, x); r) such that for every fixing of r and index z, the function F k,z,r (x) = F (k, z, x; r) corresponds to a function f k,w in F , where the mapping from (z, r) to w should be efficiently computable in poly(k) time. Note that this means that the simulator and decoder are universal for all indices z, and depend only on the value of k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 (main theorem). Suppose that the KDM function ensemble F encodes the KDM function ensemble G. Then, G KDM-reduces to F via a typepreserving reduction.</head><p>To prove the theorem we need to describe a construction and a security reduction. From now on, let Sim and Rec be the universal simulator and recovery algorithm which establish the encoding of G by F . Construction 4. Given oracle access to the encryption scheme E = (KG, E, D), we define the scheme E as follows</p><formula xml:id="formula_8">KG(1 k ) = KG(1 k ) E pk (M ) = E pk (Sim(M )) D sk (C) = Rec(D sk (C)),</formula><p>where all algorithms (i.e., encryption, decryption, simulator and recovery) get the security parameter 1 k as an additional input.</p><p>It is not hard to see that the decryption error of the scheme E is the same as the decryption error of E, as an improper decryption of E pk (M ) happens only if E pk (M ) is improperly decrypted where M R ← Sim(M ). We show that the security of E can be based on that of E. Given an oracle access to a (T, G) adversary A that attacks E, we define a (T, F ) adversary B that attacks E by randomly choosing one of two strategies B 0 and B 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reduction 5 (The adversary B</head><formula xml:id="formula_9">A,E ). Toss a coin σ R ← {0, 1}. If σ = 1 invoke the following adversary B 1 :</formula><p>-Initialization: B invokes A. If A asks for the encryption keys then B makes a similar query and passes the answer to A.</p><p>-Encryption query: If A makes an encryption query (i, M ), for i ∈ [t] and M ∈ {0, 1} * , then B samples M = Sim(M ), sends (i, M ) as an encryption query (wrt to E) and passes the answer of the challenger to A. -KDM query: If A makes a KDM query (i, g), for i ∈ [t] and g ∈ G, then the adversary B does the following: She uniformly chooses randomness r for the randomized encoding f (•; r) of g(•), and asks the KDM query (i, f r ) where f r (•) = f (•; r) which, by our assumption, is in F . The answer of the challenger is being sent to A. -Decryption query: If A makes a decryption query (i, C), then B checks that it is legal (by inspecting all previous encryption/KDM queries), and if so, <ref type="bibr" target="#b0">(1)</ref> the same decryption query to the challenger, <ref type="bibr" target="#b1">(2)</ref> applies the recovery algorithm Rec to the result, and (3) sends it back to A. -Termination: B terminates with the same output of A.</p><p>If σ = 0 then invoke the adversary B 0 . This adversary is similar to B 1 except that encryption and KDM queries of A are both translated into encryption queries as follows: given an encryption query of A of the form (i, M ) (resp., KDM query of the form (i, g)), the adversary B 0 samples M = Sim(0 ) and asks for the ciphertext E pk i (M ), where is the length of M (resp., output length of g) <ref type="foot" target="#foot_6">6</ref> . At the end, B 0 flips the output of A and terminates. Note that the above reduction is indeed type-preserving. Let us first focus on the adversary B 1 . If the challenge bit b is 1 (i.e., when the challenger is in the "realmode"), then the difference between the emulated view of A and the view of A in the actual KDM game, is only due to the difference in the way KDM queries are answered. In the real game answers to KDM queries are computed properly as E pk i (g(sk)) = E pk i (Sim(g(sk))), whereas in the emulated game they are computed by E pk i (f (sk; U)). However, this difference should not be noticeable due to the privacy of the randomized encoding. Formally, let α b (k) (resp., β σ,b (k)) denote the probability that A (resp., B σ ) guesses the challenge bit when it takes the value b. Then,</p><formula xml:id="formula_10">Lemma 2. |β 1,1 (k) -α 1 (k)| ≤ neg(k).</formula><p>Proof. We define the following distinguisher D which, given an oracle access to either F (•; U) or to Sim(G(•)), attempts to distinguish between the two. The adversary D emulates the challenger with challenge bit b = 1. It generates a key vector (sk i , pk i ) i∈ <ref type="bibr">[t]</ref> by executing the key-generation algorithm KG(1 k ) for t times. Then D invokes A. If A asks a KDM query (i, g z ) then D calls its oracle with the value G(z, sk 1 , . . . , sk t ). Let M denote the answer of the oracle. The distinguisher computes the ciphertext C = E pk i (M ) and sends the ciphertext C to A. If A asks other types of queries such as public-key queries, encryption queries, and decryption queries, the distinguisher D answers them properly exactly as the real challenger does when it's in the real mode b = 1. (For the case of a decryption query (i, C), the distinguisher checks that it is legal by inspecting all previous KDM/encryption queries, and if so, sends D sk i (C).) The distinguisher halts with output 1 if and only if A outputs 1.</p><p>Note that: (1) If D gets an oracle access to Sim(G(•)) then the view of A is distributed exactly as in the real game and so in this case D outputs 1 with probability α 1 (k); (2) If D gets an oracle access to F (•; U) then the view of A is distributed exactly as in the above reduction when B 1 emulates the game with b = 1, and so in this case D outputs 1 with probability β 1,1 (k). Hence, by the privacy of the encoding, it follows that</p><formula xml:id="formula_11">|β 1,1 (k) -α 1 (k)| ≤ neg(k).</formula><p>We would like to argue now that a similar thing happens in the "fake" mode when b = 0; namely, that β 1,0 is close to α 0 . However, in this case real-game KDM queries are answered with E pk i (0 ) = E pk i (Sim(0 )), whereas in the game emulated by B 1 these queries are answered by E pk i (0 s ), where = |g(sk 1 , . . . , sk t )| and s = |f (sk 1 , . . . , sk t ; U)|. Although the privacy of the encoding ensures that the plaintexts are of the same length, i.e., s = |Sim(0 )|, the actual distributions of the plaintexts may differ, and so it may be the case that the two views are distinguishable. For this reason we need the adversary B 0 which breaks the standard (non-KDM) security of E whenever such a gap exists. Formally, we will show that the average success probability of B 1 and B 0 is roughly half the success probability of A. To this aim we prove the following</p><formula xml:id="formula_12">Lemma 3. β 0,1 (k) = α 0 (k) and β 0,0 (k) + β 1,0 (k) = 1.</formula><p>Proof. First, we note that when the challenge bit b = 1, the view of A as emulated by B 0 is identical to the view of A in the fake mode of the real game (b = 0). Indeed, in both cases a KDM query (i, g) (resp., an encryption query (i, M )) is answered with E pk i (0 | | ) = E pk i (Sim(0 )) where is the output length of g (resp., = |M |). Hence, β 0,1 , the probability that B 0 outputs 1 when the challenger is in the real mode, is exactly the probability that A outputs 0 in the real game when the challenger is in the fake mode. (Recall that B flips the output of A). The first equation follows.</p><p>To prove the second equality we first claim that when the challenge bit b is 0, the view of A when emulated by B 0 is identical to the view of A as emulated by B 1 . Indeed, the only difference is that in the first case KDM queries (i, g) are answered by E(0 |Sim(g(sk))| ), while in the second case the answer is E(0 |f (sk;r)| ). The output lengths of f and Sim(g(•)) are fixed (for any g ∈ G) and therefore should be equal (otherwise the privacy of the encoding is violated), and so the claim follows. The claim implies that β 0,0 (k) + β 1,0 (k) = 1, as B 1 outputs the outcome of A, and B 0 flips it.</p><p>By combining the two lemmas (2 and 3), it follows that the advantage β =</p><formula xml:id="formula_13">(β 1,1 +β 1,0 +β 0,0 +β 0,1 )/4-1 2 of B is at least 1 2 α-neg(k) where α = 1 2 (α 1 +α 0 )-1 2</formula><p>is the advantage of A. Hence, we established the correctness of the reduction.</p><p>Remark 1. Thm. 3 holds even if the encoding itself makes use of the underlying encryption scheme E as long as this usage is done in a fully black-box way (the same holds for any cryptographic primitive which can be based on E via a black-box reduction e.g., one-way function). More precisely, our results hold (i.e., lead to black-box KDM reduction/construction) as long as the security of the encoding reduces to the security of the underlying primitive (i.e., E) via a blackbox reduction, and as long as the simulator and decoder can be implemented given a black-box access to the underlying primitive. Similarly, such a black box access can be given to the algorithm which maps fixed index/randomness pairs (z, r) to the index w of the function g k,w = G k,z,r (x).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Completeness of Projections</head><p>In <ref type="bibr" target="#b5">[6]</ref> it is shown that Yao's garbled circuit technique allows to encode any efficiently computable function by a decomposable encoding in which every bit depends on at most a single bit of the deterministic input. By combining this fact with Thm. 3 we get the following:</p><p>Proposition 1 (Completeness of projections). For every polynomials p(•), t(•) and (•), there exists a polynomial q(•) for which</p><formula xml:id="formula_14">C t k, ,p ≤ KDM Π t k,q , C t k,p ≤ KDM Π t k , (<label>1</label></formula><formula xml:id="formula_15">)</formula><p>where C t k, ,p is the t-ary ensemble of p-bounded circuits of output length , Π t k,q is the t-ary ensemble of projections of output length q, C t k,p = a∈N C t k,k a ,p , and</p><formula xml:id="formula_16">Π t k = a∈N Π t k,k a .</formula><p>Moreover, the reductions are type preserving. Hence, one can upgrade KDM security from (almost) the weakest KDM function ensemble to the very powerful notion of p-length-dependent KDM security.</p><p>Proof. By <ref type="bibr" target="#b5">[6]</ref> any efficiently computable circuit family {g k (x)} of circuit complexity a(k) can be encoded by a uniform computationally-private perfectlycorrect encoding {ĝ k (x; r)} with the following properties: (1) The simulator and decoder use a black-box access to a symmetric encryption (equivalently, to a one-way function); (2) For every fixed randomness r, the resulting function ĝk,r (x) = ĝk (x; r) is a projection function of output length a(k) 1+ε , where ε &gt; 0 is an arbitrary small constant. (3) The mapping from the circuit of g k to the circuit of ĝk,r is efficiently computable given a black-box access to the symmetric encryption scheme.</p><p>Let {F k } be the universal (and uniform) circuit family for the mapping (x, z) → y where x ∈ ({0, 1} k ) t , the string z is a description of a circuit C z : ({0, 1} k ) t → {0, 1} (k) of size p(k)+p( (k)), and the string y ∈ {0, 1} (k) is C z (x). By applying the encoding from <ref type="bibr" target="#b5">[6]</ref> to {F k } it follows that C t k, ,p is encoded by Π t k,q where q is polynomial in the circuit size of F k . The first part of the proposition now follows from Thm. 3.</p><p>The second part follows similarly, except that now we consider the (nonregular) function {G k, } which computes the same mapping of F k but for circuits C z whose output length is given as an additional index, and not as a fixed polynomial in k. Again, by applying the encoding from <ref type="bibr" target="#b5">[6]</ref> to {G k } it follows that C t k,p is encoded by Π t k , and the claim follows from Thm. 3.</p><p>simulatable full-KDM security correspond to the two extreme cases where F contains only the identity function, and F contains all functions. An FHE allows to translate encryptions of a message M into an encryption of a related message h(M ) for any polynomial-size circuit h. More formally, we say that E is fully homomorphic if there exists an efficient algorithm Eval such that for every (sk, pk) ∈ KG(1 k ), every circuit family {h k } of size poly(k), and every sequence of messages M k ∈ {0, 1} poly(k) , the ensemble Eval(pk, h k , E pk (M k )) is computationally indistinguishable from the ensemble E pk (h k (M k )).</p><p>In <ref type="bibr" target="#b10">[10]</ref>, it was shown that if an encryption scheme is both simulatable circularsecure and fully-homomorphic then it is also simulatable fully-KDM secure. We show that the other direction holds as well, and so the two notions are equivalent. Proposition 2. Any simulatable fully-KDM secure encryption scheme is also fully-homomorphic circular-secure.</p><p>Proof. Given a simulatable fully-KDM secure encryption scheme (KG, E, D) with simulator S, we define Eval(pk, h, C) by invoking S on the pair (pk, f h,C ) where f h,C is the mapping sk → h(D sk (C)). Note that the circuit size of f h,C is polynomial in the circuit size of h (since D is efficient). Also, by definition, we have for every (sk, pk) ∈ KG(1 k ), sequence {M k } and sequence {h k },</p><formula xml:id="formula_17">Eval(pk, h k , E pk (M k )) ≡ S(pk, f h k ,E pk (M k ) ) c ≡ E pk (h k (D sk (E pk (M k )))) ≡ E pk (h k (M k )),</formula><p>where ≡ ( c ≡) denotes statistical (computational) indistinguishability.</p><p>Next, we show that if one removes the simultability requirement then any encryption scheme (KG, E, D) which provides KDM security with respect to a function which is slightly stronger than its decryption algorithm D, is actually fully-KDM secure. This is done by observing that Gentry's "bootstrapping technique" can be adapted to the KDM setting. Proof (Sketch). In the CPA setting it suffices to prove full KDM security with respect to all circuits of single output. We show how to convert an attacker which sends arbitrary KDM queries into one which uses only queries from F k . Let h be a circuit of size t, which is wlog composed of NAND gates, and let h i denote the function computed by the i-th gate of h, where gates are ordered under some topological ordering. We translate a KDM query for h into t KDM calls to F k by traversing the circuit from bottom to top in a gate by gate manner preserving the following invariant: The i-th query will be answered by a ciphertext C i such that, if the oracle is in the real mode C i = E pk (h i (sk)) and if it is in the fake mode C i = E pk (0). For an input gate, this can be achieved directly by making a single KDM query with a single-output projection. To do this for an internal gate h whose input wires are connected to h i and h j for some i, j &lt; , we use a KDM query to f Ci,Cj .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>queries of the form (i, C) where i ∈ [t] and the string C was not given as an answer of a previous encryption/KDM query. The challenger responds with M = D sk i (C) regardless of the value of b. -Final phase. The adversary outputs a bit b ∈ {0, 1} and wins if b = b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig.1. The F-KDM game is defined with respect to the function ensemble F = {F k } and is indexed by the security parameter k. The presence (resp., absence) of public-key query captures the public-key (resp., symmetric-key) setting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Proposition 3 .</head><label>3</label><figDesc>Let T ∈ {(pub, CPA), (sym, CPA)}, and let E = (KG, E, D) be T -KDM secure encryption with respect to single-output projections and with respect to the function familyF k = {f C1,C2 : sk → NAND(D sk (C 1 ), D sk (C 2 ))}, where C 1 , C 2 ranges over {0, 1} p(k) and p(k) is the length of an encryption of one-bit message under secret-key of length k. Then, E is fully KDM secure of type T .</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>K.G. Paterson (Ed.): Eurocrypt 2011, LNCS 6632, pp. 527-546, 2011. c International Association for Cryptologic Research 2011</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>It is known that KDM security with respect to sufficiently rich families of functions cannot be based on standard assumptions via fully black-box reductions<ref type="bibr" target="#b27">[25]</ref>. However, this impossibility result (and its extension in<ref type="bibr" target="#b10">[10]</ref>) does not hold for simple function class (e.g., projections).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>Most of the statements in<ref type="bibr" target="#b10">[10]</ref> refer to the slightly weaker notion of Bounded KDM security in which the circuit size grows only as a function of the input via a fixed polynomial rate. However, as observed in<ref type="bibr" target="#b10">[10,</ref> Sec. 6] their construction actually satisfies the stronger definition of length-dependent KDM security.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>In fact, we can achieve a slightly stronger notion. Assuming that the underlying scheme satisfies KDM (t) security for arbitrary t's (as in<ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b4">5]</ref>), we get a KDM (t) secure scheme where there exists an unbounded number of keys in the system, but the arity of the KDM functions available to the adversary is polynomially bounded (in the security parameter and message length). Still, these functions can be applied to arbitrary subsets of the keys.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>It seems that a similar statement holds even for public-key KDM-secure schemes. See<ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b23">21]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>Previous definitions require only that the first quantity is zero, however, all known constructions (of perfectly-correct randomized encoding) satisfy the current (stronger) definition.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Recall that the output length of g ∈ G is given as part of its description.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement. We thank Iftach Haitner, Yuval Ishai, and the anonymous referees for their helpful comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In the case of CPA KDM security, one can actually derive KDM-security with respect to projections of arbitrary output length (i.e., Π t k ) from single-output projections Π t k,1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4 (Completeness of single-output projections for CPA-KDM).</head><p>For every polynomial t(•), we have</p><p>, where the reduction holds for both (sym, CPA) and (pub, CPA) types.</p><p>Proof. The proof follows by simple concatenation: the new encryption/decryption algorithms encrypts/decrypts the message/ciphertext by applying the original encryption/decryption algorithm in a bit by bit manner. Hence, a KDM query in Π t k,k a for the new scheme can be emulated by k a KDM queries in Π t k,1 for the original scheme.</p><p>As shown in <ref type="bibr" target="#b9">[9]</ref>, we can use the standard encrypt-then-MAC transformation to upgrade the security of a scheme that satisfies (sym, CPA)-KDM security into a scheme that satisfies (sym, CCA)-security with respect to the same KDM class. A similar result was proven for the public-key setting by <ref type="bibr" target="#b16">[15]</ref> via the Naor-Yung double-encryption paradigm (which relies on the existence of NIZK). Hence, by Proposition 1 and Lemma 4, we have: Corollary 1 (KDM Collapse). For every polynomials t and p, there exists a Π t k,1 -KDM secure scheme if and only if there exists a t-ary p-length-dependent KDM secure encryption scheme. This holds unconditionally for the KDM types (sym, CPA), (sym, CCA), and (pub, CPA)}, and it holds for (pub, CCA) assuming the existence of non-interactive zero-knowledge proof system for NP.</p><p>We remark that all the known constructions of affine-KDM secure encryption schemes <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">13</ref>] can be adapted to yield KDM security with respect to singleoutput projections (see the Appendix of the full version of this paper <ref type="bibr" target="#b3">[4]</ref>). Hence, we get p-length-dependent (pub, CPA)-KDM (resp., (sym, CCA)) based on the DDH, LWE, or QR assumptions (resp., LPN assumption), which can be boosted into (pub, CCA)}-KDM assuming the existence of NIZK for NP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">On Full KDM Security</head><p>In this section, we study the possibility of constructing a scheme which satisfies KDM security for the class of all functions. In <ref type="bibr" target="#b10">[10]</ref> it was shown that such a scheme can be constructed based on the existence of cyclic-secure fully homomorphic encryption (FHE) <ref type="bibr" target="#b22">[20]</ref>. We show that a similar assumption is inherently required for full KDM security which is also simulatable. For simplicity, we focus on the case of arity t = 1 and single-query adversaries.</p><p>A public-key encryption scheme E = (KG, E, D) is simulatable F -KDM secure if there exists a polynomial-time simulator S such that for every (sk, pk) ∈ KG(1 k ), and every circuit family f k ∈ F k of size poly(k), the ensemble S(pk, f k ) is indistinguishable from E pk (f k (sk)). (Note that this means that the distinguisher holds the secret-key sk.) The notions of simulatable circular-security and</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reconciling two views of cryptography (the computational soundness of formal encryption)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">395</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cryptographic agility and its relation to circular encryption</title>
		<author>
			<persName><forename type="first">T</forename><surname>Acar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Belenkiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="403" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Soundness and completeness of formal encryption: The cases of key cycles and partial information leakage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Adão</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="737" to="797" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Key-dependent message security: Generic amplification and completeness theorems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">513</biblScope>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast cryptographic primitives and circular-secure encryption based on hard learning problems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="595" to="618" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Computationally private randomizing polynomials and their applications</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computional Complexity</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="115" to="162" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Cryptography in NC 0</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="845" to="888" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">OAEP is secure under key-dependent messages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dürmuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Unruh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2008</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="506" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Key-dependent message security under active attacks -BRSIM/UC-soundness of symbolic encryption with key cycles</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CSF</title>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bounded key-dependent message security</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="423" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Encryption-scheme security in the presence of key-dependent messages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2002</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Heys</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2595</biblScope>
			<biblScope unit="page" from="62" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Circular-secure encryption from decision Diffie-Hellman</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="108" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Circular and leakage resilient public-key encryption under subgroup indistinguishability (or: Quadratic residuosity strikes back)</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Circular-secure encryption beyond affine functions</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kalai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2011</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A public key encryption scheme secure against key dependent chosen plaintext and adaptive chosen ciphertext attacks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Chandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="351" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An efficient system for non-transferable anonymous credentials with optional anonymity revocation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2001</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2045</biblScope>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption over the integers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="24" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Non-malleable cryptography (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of STOC</title>
		<meeting>of STOC</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="542" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A randomized protocol for signing contracts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of STOC</title>
		<meeting>of STOC</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The relationship between public key encryption and oblivious transfer</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
		<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundations of Cryptography: Basic Tools</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Foundations of Cryptography: Basic Applications</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On the (Im)Possibility of key dependent encryption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Holenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="202" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Security under key-dependent inputs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<publisher>ACM CCS</publisher>
			<biblScope unit="page" from="466" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Towards key-dependent message security in the standard model</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Unruh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2008</title>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="108" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Limits on the provable consequences of one-way permutations</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1988</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">403</biblScope>
			<biblScope unit="page" from="8" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Randomizing polynomials: A new representation with applications to round-efficient secure computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
		<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="294" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Perfect constant-round secure computation via perfect randomizing polynomials</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2002</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Widmayer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Triguero</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Morales</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Eidenbenz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Conejo</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2380</biblScope>
			<biblScope unit="page" from="244" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems provably secure against chosen ciphertext attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of STOC</title>
		<meeting>of STOC</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="427" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Digitalized signatures and public key functions as intractable as factoring</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LCS</title>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. 212</note>
	<note>MIT</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Non-interactive zero-knowledge proof of knowledge and chosen ciphertext attack</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1991</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="433" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
		<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="162" to="167" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
