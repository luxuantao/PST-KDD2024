<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Short Block-Length Codes for Ultra-Reliable Low Latency Communications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">Short Block-Length Codes for Ultra-Reliable Low Latency Communications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8E34F93ED20A17CD4C0F82B46B356C29</idno>
					<idno type="DOI">10.1109/MCOM.2018.1800181</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This article reviews state of the art channel coding techniques for URLLC. The stringent requirements of URLLC services, such as ultrahigh reliability and low latency, have made it the most challenging feature of 5G of mobile networks. The problem is even more challenging for services beyond the 5G promise, such as tele-surgery and factory automation, which require latencies less than 1ms and packet error rates as low as 10 -9 . This article provides an overview of channel coding techniques for URLLC and compares them in terms of performance and complexity. Several important research directions are identified and discussed in more detail.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IntroductIon</head><p>The third generation partnership project (3GPP) has defined three main service categories in 5G. Enhanced mobile broadband (eMBB) is the service category designed for services that have high requirements for bandwidth such as virtual reality, augmented reality, and high-resolution video streaming. The second category is massive machine-type communication (mMTC) which promises to support the massive number of machine-type devices and ultra-low power consumption to increase the device lifetime. The third service category is ultra-reliable and low latency communication (URLLC) which focuses on delay sensitive applications and services (Fig. <ref type="figure" target="#fig_1">1</ref>). Factory automation and tele-surgery have the strictest reliability requirement of (1-10 -9 ) with an end-to-end latency of less than 1ms. Other services such as smart grids, Tactile Internet, intelligent transportation systems, and process automation have more relaxed reliability requirements of (1-10 -3 ) âˆ¼ (1-10 -6 ) at latencies between 1ms to 100ms <ref type="bibr" target="#b0">[1]</ref>. As shown in Fig. <ref type="figure" target="#fig_1">1</ref>, 5G may not be able to achieve the requirements for some industrial and medical applications with a very strict latency requirement of less than 1ms and block error rate (BLER) of 10 -9 . These systems might need to have their own standards with more rigorous latency and reliability levels. For example, power electronics based industrial control needs the overall network latency to be less than 0.1msec and reliability of (1-10 -9 ) <ref type="bibr" target="#b1">[2]</ref>.</p><p>Physical layer design of URLLC is very challenging because URLLC should satisfy two conflicting requirements: ultra-low latency and ultra-high reliability. One could use short packets to reduce latency which in turn causes a severe loss in coding gain. Alternatively, the system bandwidth should be widened, which is not always possible, especially for some URLLC applications in industrial control that might operate over unlicensed spectrum <ref type="bibr" target="#b1">[2]</ref>. On the other hand, for enhancing reliability, we need to use strong channel codes eventually paired with retransmission techniques which indeed increase the latency.</p><p>For high reliability transmissions of URLLC data, a channel code with low code rates is generally used <ref type="bibr" target="#b2">[3]</ref>. Several candidate channel codes such as low density parity check (LDPC), Polar, tail-biting convolutional code (TB-CC), and Turbo codes, were considered for both eMBB and URLLC data channels. While it was recognized that LDPC, Turbo and Polar codes have similar performance at large block sizes, they could have big performance differences at small block sizes. LDPC has already been selected for eMBB data channel and Polar codes were selected for the eMBB control channel. However, recent investigations showed that there exist some error floors for LDPC codes constructed using base graph (BG) 2, which has been considered for short block low rate scenarios <ref type="bibr" target="#b2">[3]</ref>. Moreover, as shown in <ref type="bibr" target="#b2">[3]</ref>, Polar codes outperform LDPC codes without any sign of error floor. This means that it is not straightforward to extend/modify eMBB channel coding for URLLC with very diverse latency and data rate requirements. It has been clearly specified that channel coding for URLLC should be further studied, especially for information blocks of less than 1000 bits <ref type="bibr" target="#b2">[3]</ref>.</p><p>In this article, we compare the main contender channel codes for URLLC, with the aim to achieve a favorable trade-off between latency and reliability. We mainly focus on short blocks, that is, in the order of a few hundreds bits for URLLC. We review existing short channel codes and compare them in terms of rate efficiency at the reliability of interest for some URLLC applications. We show that existing candidate channel codes for URLLC still show a considerable gap to the normal approximation <ref type="bibr" target="#b3">[4]</ref> benchmark, therefore there is still room for further improve- ments. We highlight several important research directions to improve the performance of URLLC channel codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Key MetrIcs, requIreMents, And PerforMAnce benchMArKs LAtency</head><p>In the physical layer, we mainly focus on user plane latency, which is defined as the time to successfully deliver a data block from the transmitter to the receiver via the radio interface in both uplink and downlink directions. User plane latency consists of four major components: the timeto-transmit latency, the propagation delay, the processing latency, for example, for channel estimation and encoding/decoding, and finally the re-transmission time. Propagation delay is typically defined as the delay of propagation through the transmission medium, and it depends on the distance between the transmitter and receiver. The time-to-transmit latency is required to be in the order of a hundred microseconds, which is much less than the 1ms currently considered in 4G <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>reLIAbILIty</head><p>Reliability is defined as the success probability of transmitting K information bits within the desired user plane latency at a certain channel quality. Sources of failure from a higher layer perspective are when the packet is lost, or it is received late, or it has residual errors. It is essential to maximize the reliability of every packet in order to minimize the error rate, so as to minimize the number of retransmissions. In this article, we use block error rate (BLER) as a metric to compare different channel codes in terms of reliability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>fLexIbILIty</head><p>The flexibility of the channel coding scheme is an important aspect along with the evaluation of the coding performance. Bit-level granularity of the codeword size and code operating rate is desired for URLLC <ref type="bibr" target="#b4">[5]</ref>. The actual coding rate used in transmission could not be restricted and optimized for specified ranges <ref type="bibr" target="#b4">[5]</ref>. The channel codes therefore need to be flexible to enable hybrid automatic repeat request (HARQ). The number of retransmissions, however, needs to be kept as low as possible to minimize latency.</p><p>The general URLLC requirement according to 3GPP is that the reliability of a transmission of one packet of 32 bytes should be (1-10 -5 ), within a user plane latency of 1ms (with or without HARQ) <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PerforMAnce benchMArK</head><p>There are two effects that should be distinguished here to better understand the code design problem for short blocks. The first one is the gap to Shannon's limit, that is if we decrease the block length, the coding gain will be reduced and the gap to Shannon's limit will increase. This is not a problem of code design but is mainly due to the reduction in channel observations that comes with finite block lengths. We will use the normal approximation (NA) <ref type="bibr" target="#b3">[4]</ref>, that incorporates the reduction in channel observations, as the performance benchmark for comparison. Figure <ref type="figure" target="#fig_2">2</ref> shows the normal approximation for different code rates and information block lengths. As can be seen, when the block length increases, the gap to Shannon's limit <ref type="bibr" target="#b3">[4]</ref> decreases. 1  The second effect is the gap to the finite length bounds, that is if we decrease the block length, modern codes, such as LDPC or Turbo codes, show a gap to finite length bounds. This is often due to the suboptimal decoding algorithms. As can be seen in Fig. <ref type="figure" target="#fig_2">2</ref>, long term evolution (LTE) Turbo and TB-CC codes show a considerable gap to the normal approximation at short blocks. However, when the block length of the Turbo code increases, the gap to the normal approximation and Shannon's limit decreases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>cAndIdAte short bLocK Length chAnneL codes for urLLc</head><p>Here we briefly discuss several fixed-rate channel codes, which might be suitable for URLLC. Throughout the article, the information block length and codeword length are respectively denoted by K and N. For convolutional codes, we use n, k, and m to denote the bit input and bit output per time instant and memory order, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>bch codes</head><p>Bose, Chaudhuri, and Hocquenghem (BCH) codes are a class of powerful cyclic error-correcting codes that are constructed using polynomials over finite fields <ref type="bibr" target="#b5">[6]</ref>. The main feature of  1 It is important to note that Shannon's theoretical model breaks down for short codes, as the channel capacity, defined as the maximum possible rate at which reliable communications is possible, is only valid for infinite block length. The normal approximation was shown to be tight for moderate block lengths (&gt;100 bits) <ref type="bibr" target="#b3">[4]</ref>.</p><p>BCH codes is that the number of guaranteed correctable symbols, t, is defined during the code design process. The minimum distance d min of BCH codes is at least 2t + 1 <ref type="bibr" target="#b5">[6]</ref>. The decoding of BCH codes is usually done using a bounded distance decoder, like the Berlekamp-Massey algorithm, that can correct any combination of up to t symbol errors. In order to increase the coding gain, in particular on noisy channels, one may use a soft-input decoder, such as ordered statistics decoder (OSD).</p><p>OSD is a near maximum likelihood (ML) soft decision decoding algorithm for an (N, K) binary linear block code with a given generator matrix. The decoding process consists of three steps. The first step is to reorder the channel output in decreasing reliability order which yields a permutation. The same permutation is applied to the generator matrix. The reordered generator matrix is transformed into a systematic form via Gaussian elimination. The hard decision of the K most reliable values of the channel output are encoded into a codeword via the permuted generator matrix. The reprocessing step consists of generating test error patterns of increasing Hamming weight. This step is repeated until a predefined condition is met and the codeword with the smallest Euclidean distance from the ordered channel output is kept as the best decision. Recent advances in OSD design <ref type="bibr" target="#b6">[7]</ref> significantly reduce decoding complexity, which makes OSD a good choice for the decoding of short bock length codes.</p><p>BCH codes have large minimum distances which avoid flooring the performance at low BLER. However, BCH codes are not flexible as the block length and information length cannot be selected arbitrarily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>convoLutIonAL codes</head><p>Convolutional codes (CC) were first introduced by Elias in 1955 <ref type="bibr" target="#b5">[6]</ref>. They differ from block codes as the encoder contains memory. Generally, a rate R = k/n convolutional encoder with memory order m can be realized as a linear sequential circuit with input memory m, k inputs, and n outputs, where inputs remain in the encoder for m time units after entering. Large minimum distances and low error probabilities for convolutional codes are achieved by not only increasing k and n, but also by increasing the memory order. However, the decoding complexity scales in general exponentially with the memory order in both the Viterbi and the Bahl, Cocke, Jelinek, and Raviv (BCJR) algorithms <ref type="bibr" target="#b5">[6]</ref>.</p><p>When short packets have to be transmitted, terminated convolutional codes represent a promising candidate solution, although the rate loss due to a zero tail termination at short block lengths may be unacceptable. A tail-biting approach <ref type="bibr" target="#b7">[8]</ref> eliminates the rate loss and hence it deserves particular attention when comparing channel codes for short blocks. For these reasons, tail-biting convolutional codes (TB-CCs) are currently considered within the 5G standardization for URLLC. It is worth mentioning that the decoders for TB-CCs are more complex than those for convolutional codes. TB-CC was used in LTE for the broadcast channel and downlink/uplink control information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>turbo codes</head><p>In 1993, Berrou, Glavieux, and Thitimajshima introduced Turbo coding, which combines a parallel concatenation of two convolutional encoders and iterative maximum a-posteriori probability (MAP) decoding <ref type="bibr" target="#b5">[6]</ref>. Turbo codes have been extensively used for the data channel in LTE. For large blocks, Turbo codes are capable of performing within a few tenths of dB from Shannon's limit. Unfortunately, Turbo codes with iterative decoding in short and moderate block lengths show a gap of more than 1 dB to the finite-length performance benchmark. The LTE Turbo code is known to be well designed for medium block length and code rate â‰¥ 1/3. When the code rate and block length are small, LTE-Turbo code performance is degraded. For Turbo codes, 1-bit granularity is feasible for all coding rates and for a full range of block sizes, and the ability of Turbo codes to support both Chase combining and incremental redundancy HARQ is well known <ref type="bibr">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Low densIty PArIty checK (LdPc) codes</head><p>Low-density parity-check (LDPC) codes were originally proposed by Gallager in the early 1960s and later rediscovered in the 1990s, when researchers began to investigate codes-on-graph based  This article has been accepted for inclusion in a future issue of this magazine. Content is final as presented, with the exception of pagination. on Tanner's work in 1981 and iterative decoding <ref type="bibr" target="#b5">[6]</ref>. LDPC codes with iterative belief propagation (BP) decoding have been shown to perform very close to Shannon's limit with only a fraction of a decibel gap. However, binary LDPC codes with iterative BP decoding do not perform well at short to moderate block-lengths, which is mainly due to the existence of many short cycles in the code's bipartite graph. Recently, protograph-based LDPC codes have been shown to perform well under belief propagation decoding at short-to-moderate block length, but their performance is not comparable with BCH codes under OSD or TB-CCs with large memory. However, they favor the very low decoding complexity under iterative decoding algorithms. Non-binary LDPC codes are also shown to perform very close to the finite length performance bound where the decoding complexity is the major drawback.</p><p>There are other advantages for LDPC codes, for example, in parallelization of the decoding algorithm. LDPC codes have been adopted for eMBB data channel and it is a natural extension to apply LDPC codes for URLLC. Two base graphs are considered for LDPC in eMBB. BG 1 is used for high data rate and long block lengths; BG 2 is used for low code rates and short block lengths. Recent investigations demonstrated that there exist some error floors for LDPC codes at certain rates and block lengths <ref type="bibr">[9]</ref>. Moreover, the complexity of LDPC increases with increasing flexibility <ref type="bibr">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PoLAr codes</head><p>Polar codes as introduced in <ref type="bibr" target="#b8">[10]</ref> are binary linear codes that can provably achieve the capacity of a binary-input discrete memoryless channel using low-complexity encoding and decoding as the code length tends to infinity. Channel polarization is a central technique in the construction of these codes, in which the block code translates N independent and identical binary-input discrete memoryless channels into N synthesized channels with capacities either (close to) zero or one. The message is only sent over the set of near-perfect channels, and the unreliable channels are unused; in practice, they are assigned constant inputs a priori known for both the encoder and decoder (frozen symbols).</p><p>Under successive cancellation (SC) decoding, which requires a complexity of O(N log N), and for sufficiently large codeword lengths, the block error probability decays exponentially in the square root of the code length. The recursive nature of the SC decoding may impose a large latency depending on the implementation.</p><p>A major improvement in decoding performance is achieved by using successive cancellation list (SCL) decoding, which keeps a list of most likely decoding paths at all times, unlike the SC decoder, which keeps only one decoding path, that is, it performs a symbol-wise hard decision at each decoding stage. A significant improvement to SCL is cyclic redundancy check (CRC)-aided SCL (CA-SCL), where the message is encoded with a CRC error detection code, and the result is polar coded <ref type="bibr" target="#b9">[11]</ref>. In this way, the CRC checksum is used at the decoder side to pick the right decoding path in the list, even if it is not the most probable path.</p><p>Polar codes have been selected for short blocks for control channels in eMBB <ref type="bibr">[9]</ref>. Recent investigations and proposals submitted to 3GPP also demonstrated that Polar codes outperform LDPC codes in short block lengths and low code rates without any sign of error floor; therefore, they are suitable for URLLC use cases <ref type="bibr">[9]</ref>. In Polar codes, 1-bit granularity can be achieved for all coding rates and for a full range of block sizes. However, the implementation complexity of the list decoder increases with increasing list size, especially with larger block sizes <ref type="bibr">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>coMPArIson between chAnneL codes for urLLc</head><p>In this section, different channel codes for URLLC are compared in terms of reliability, rate performance, and algorithmic complexity. We consider a binary input additive white Gaussian noise (BI-AWGN) channel, where unit power binary antipodal signals are sent over a channel which are subject to the additive white Gaussian noise of variance s 2 . The signal to noise ratio (SNR) is then defined as 1/s 2 . For each SNR point and code rate, the simulation is run to obtain 100 codeword errors at the decoder output. of N = 128 under MLD <ref type="bibr" target="#b10">[12]</ref>. For TB-CC, we used the circular Viterbi algorithm (CVA). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SNR [dB]</head><p>Block error rate Polar Code <ref type="bibr" target="#b10">[12]</ref> Polar Code + CRC-7 <ref type="bibr" target="#b10">[12]</ref> Reed-Muller Code <ref type="bibr" target="#b10">[12]</ref> F16 LDPC Code [12] F256 LDPC Code <ref type="bibr" target="#b10">[12]</ref> Binary LDPC <ref type="bibr" target="#b10">[12]</ref> TB-CC, m = 8 <ref type="bibr" target="#b7">[8]</ref> TB-CC, m = 11 [8] TB-CC, m = 14 <ref type="bibr" target="#b7">[8]</ref> eBCH Code <ref type="bibr" target="#b10">[12]</ref> Normal Approximation <ref type="bibr" target="#b3">[4]</ref> A major improvement in decoding performance is achieved by using successive cancellation list decoding, which keeps a list of most likely decoding paths at all times, unlike the SC decoder, which keeps only one decoding path, that is, it performs a symbol-wise hard decision at each decoding stage.</p><p>This article has been accepted for inclusion in a future issue of this magazine. Content is final as presented, with the exception of pagination. reLIAbILIty Figure <ref type="figure" target="#fig_4">3</ref> shows the BLER versus the SNR for different candidate channel codes at rate R = 1/2 and block length N = 128 under maximum likelihood decoding (MLD) <ref type="bibr" target="#b10">[12]</ref>. By using an optimal decoder in the (ML sense), the plot gives insights into the code performance itself. As can be seen in this figure, the extended BCH code closely approaches the normal approximation benchmark over the whole SNR region and can provide a very low BLER as small as 10 -7 with only 0.1dB gap to the normal approximation. Another competitive code is the TB-CC code with m = 14, which can provide a BLER of 10 -5 with only 0.1dB gap to the NA benchmark <ref type="bibr" target="#b3">[4]</ref>; however, when it goes to a lower BLER of 10 -7 the gap increases to 0.3dB. Decreasing the memory to 11, TB-CC still gives a performance within 0.1dB gap from the normal approximation at a BLER of 10 -5 . Other competitive codes are LDPC codes designed over a large Galois field (here F256), which have almost the same performance as the TB-CC code with m = 14. The circular Viterbi algorithm (CVA) has been used for decoding of TB-CCs <ref type="bibr" target="#b7">[8]</ref>.</p><p>The BCH code outperforms all other existing codes owing to its better distance spectrum. Other codes are mainly designed to provide good performance while maintaining the decoding complexity at a reasonable order. We will discuss the trade-off between complexity and performance in more detail in later sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rAte PerforMAnce</head><p>Figure <ref type="figure" target="#fig_6">4</ref> shows the rate performance of different candidate codes at a BLER of 10 -4 when the codeword length is N = 128. As can be seen, BCH codes perform very close to the normal approximation and outperform other existing codes at all SNRs. The generator polynomials of the used BCH codes were taken from <ref type="bibr" target="#b5">[6]</ref> and OSD was used with a maximum re-factoring order of 5. As in <ref type="bibr" target="#b6">[7]</ref>, we used the probabilistic necessary condition and the probabilistic sufficient condition to reduce the complexity of the OSD decoder.</p><p>Two sets of Polar codes with SA-SCL with list sizes 4 and 32 are also shown in Fig. <ref type="figure" target="#fig_6">4</ref>. Although the decoder with the list size of 32 significantly outperforms the other decoder with list size 4, this comes with a significant increase in the decoding complexity, as the decoder needs to store and list additional candidates. For the sake of comparison, we also show in Fig. <ref type="figure" target="#fig_6">4</ref> the performance of the short block length LDPC codes specifically designed for eMBB. These codes have the advantage of very low complexity iterative BP decoding and have slightly better performance than the CA-Polar code with SCL decoding of list size 4.</p><p>It is important to note that although BCH codes perform very close to the normal approximation benchmark, their decoding is very complex. For lower code rates, usually an OSD with much higher reprocessing order should be used to guarantee the performance. However, this significantly increases the complexity. On the other hand, as seen in Fig. <ref type="figure">5</ref>, Polar and LDPC codes can still offer good performance at low rates with considerably lower decoding complexities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>coMPLexIty vs. PerforMAnce</head><p>Turbo and LDPC codes have been shown to provide near capacity performance at large blocklengths with reasonable complexity due to the iterative nature of the decoders and the fact that most of the calculations can be done in parallel. The complexity of such decoders, for example belief propagation, scale linearly with the blocklength. In fact, in most of the complexity analysis of such codes, the complexity is usually characterized in terms of the block length. However, for short block lengths other code parameters have significant impact on the decoding complexity.</p><p>Here we only focus on the algorithmic complexity which can be represented in terms of the number of binary operations. For example, the decoding complexity of a TB-CC code using the Viterbi decoder is mainly dominated by the memory order, in short block lengths, as the memory order should be usually large to guarantee the performance. Figure <ref type="figure" target="#fig_7">6</ref> shows the complexity versus the performance of different channel codes. As can be seen, Polar codes with the SCL decoder achieve the error rate of 10 -4 at only 0.5dB gap to the normal approximation benchmark with the complexity in the order of 10 3 operations per bit. The complexity can be reduced by reducing the list size, which however degrades the perfor- - mance. TB-CC codes have huge complexity which significantly increases with the memory order. The original OSD decoder has the complexity in the order of K l , with l being the order number.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>recoMMendAtIons And reseArch dIrectIons</head><p>To achieve ultra-high reliability and low latency, we identify three main directions where major improvements are essential. We also provide recommendations in each direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>deveLoPIng Low coMPLexIty osd decoders</head><p>As we show in Fig. <ref type="figure" target="#fig_6">4</ref>, under the OSD, BCH codes outperform other existing channel codes, including Polar codes, Turbo codes, and LDPC codes. The complexity of OSD can be significantly reduced using several approaches such as sufficient conditioning and segmentation <ref type="bibr" target="#b6">[7]</ref>. Recent work <ref type="bibr" target="#b6">[7]</ref> has shown significant complexity reduction for OSD while maintaining rate efficiency similar to the original OSD decoder. Moreover, as shown in Fig. <ref type="figure" target="#fig_7">6</ref> using an OSD with bounded complexity, a trade-off between performance and complexity can be achieved. We identify that to further improve the performance of channel codes for URLLC, more sophisticated ML-like decoders should be designed to allow low complexity decoding of fundamentally better codes in short block lengths, such as BCH codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>seLf-AdAPtIve JoInt codIng And ModuLAtIon scheMes</head><p>Current cellular networks adopt a rate-adaptive scheme, that is, prior to every transmission, the transmitter sends pilot signals to the receiver which enables the latter to estimate the channel state. Then, the receiver feeds back a channel quality indicator (CQI). Based on this CQI, the transmitter selects the best combination of fixed-rate code and modulation scheme from a predetermined set. In case the receiver cannot recover the information (which can be verified with a CRC), it will request a retransmission based on the well known HARQ protocol. This rate adaptive scheme suffers from two main draw-Figure <ref type="figure">5</ref>. Comparison of different channel codes with different rates and information block lengths. Rates R = 1/3, 1/6, and 1/12, are respectively shown with blue, red and black colors. For the deatil of the channel codes refer to <ref type="bibr" target="#b11">[13]</ref>.</p><p>-   backs. The first drawback is due to the choice of channel codes that targets BLERs of 10 -2 making the scheme heavily dependent on retransmissions.</p><p>In the current LTE standard, each retransmission takes about 7âˆ¼8ms, introducing significant delays unacceptable for URLLC. To tackle this, one needs to consider new channel codes more suitable for short blocks and with lower BLERs. Unfortunately, even so, the rate adaptive scheme still suffers from the channel estimation overhead which takes about 5âˆ¼8ms in the current LTE standard. This latency can be very costly for mission critical URLLC applications. Self-adaptive <ref type="bibr" target="#b13">[15]</ref> channel coding is a promising approach to ensure ultra-low latency transmissions. With self-adaptive codes, the code rate is determined on the fly and automatically adapts to channel conditions, without having any CQI at the transmitter side. PBRL-LDPC codes offer a fine granularity over information block size and rate. They have been demonstrated to achieve more than 90 percent of the NA benchmark and BLERs as low as 10 -6 . However, recent investigations show that the performance of PBRL-LDPC codes constructed from a base matrix degrades gradually when more coded symbols are transmitted. For self-adaptive codes, we can identify two main research directions.</p><p>The design of a self-adaptive joint coding and modulation scheme: PBRL LDPC codes are binary codes and the joint design of the code and modulation can significantly improve the performance. As the rateless property of PBRL-LDPC is inspired by Raptor Codes, we propose to replace the Raptor part of the code with rateless codes over real domain, like Analog Fountain Codes (AFC) <ref type="bibr" target="#b13">[15]</ref>. The joint design of PBRL-LDPC and AFC can offer significant performance improvements.</p><p>Reducing pilot sequence length for channel estimation at the receiver side: For any rateless code, the receiver still needs to know the channel to decode the information. This implies that the transmitter needs to insert pilot symbols into each transmitted block which can incur significant performance losses. These performance losses become more noticeable when the information block size is small. Assuming a powerful (128,64,22) extended BCH (eBCH) code over a BI-AWGN channel with SNR 3.5dB and using only seven symbols for pilot transmission, our initial results see 5 percent loss in the spectral efficiency at BLER 10 -5 . The loss increases to 9.8 percent and 18 percent when QPSK and 16QAM modulations are considered, respectively. A solution would be to design near ML decoding using OSD without requiring the accurate CSI at the receiver using iterative approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>sPAce-frequency chAnneL codIng</head><p>In current cellular systems, the spatial domain was mainly used to provide multiplexing gain rather than diversity as the main objective was to improve the throughput for moderate reliability order, that is, BLER of 10 -2 as in LTE. In order to increase reliability, one can use the available transmit and receive antennas to provide spatial diversity rather than spatial multiplexing. In 4G and 5G, orthogonal frequency division multiple access (OFDMA) is the major multiple access technology, in which each resource block consists of a number of OFDM symbols. Reducing the number of OFDM symbols per resource block has been identified as an effective approach to reduce the latency. The design of the channel code in these systems is then challenging when considering different diversity sources, including space or frequency. So far, there is no universal framework to design space-frequency channel codes to provide different level of reliability for low latency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>concLusIons</head><p>This article reviewed the most recent progress in the design and implementation of short block length channel codes for ultra-reliable low latency communications (URLLC). Several candidate channel codes, including Polar codes, Turbo codes, LDPC codes, Convolutional codes, and BCH codes, were considered and compared in terms of block error rate under optimal decoder, rate performance under practical decoders, and algorithmic complexity of decoding algorithms. BCH codes the highest reliability under optimal decoding, since they have the highest minimum Hamming distance. Polar codes with successive cancellation list decoding provide a reliability of (1-10 -4 ) with only 0.5dB gap to the normal approximation with reasonable complexity. However, better results might be achieved with reduced complexity OSD and BCH codes with the same level of complexity. We also identified several major research directions for channel coding for URLLC. alekSandar Minja [S] (sale.telekom@gmail.com) received the B.S.c (summa cum laude) and the M.S.c (summa cum laude) degrees in electrical engineering and computer science-telecommunications engineering and signal processing from the University of Novi Sad, Faculty of Engineering, where he is currently working as a teaching assistant and pursuing his Ph.D.</p><p>Chentao yue [S] (cyue8516@uni.sydney.edu.au) received his bachelor's degree in information engineering from Southeast University, China, in 2017. He is currently pursuing a Ph.D. degree at the University of Sydney. His major research interests are error control coding and information theory.</p><p>balazS Matuz [M] (balazs.matuz@dlr.de) received his diploma degree in electrical engineering and information technology from Technische UniversitÃ¤t MÃ¼nchen (  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Latency and reliability requirements for different URLLC services.End-to-End Latency</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Comparison of error performance of LTE channel codes with different information block lengths, K.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>NA<ref type="bibr" target="#b3">[4]</ref>, K = 40 NA<ref type="bibr" target="#b3">[4]</ref>, K = 1000The LTE Turbo code is known to be well designed for medium block length and code rate â‰¥ 1/3. When the code rate and block length are small, LTE-Turbo code performance is degraded. For Turbo codes, 1-bit granularity is feasible for all coding rates and for a full range of block sizes, and the ability of Turbo codes to support both Chase combining and incremental redundancy HARQ is well known.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Comparison of error performance of different rate R = 1/2 channel codes with codeword lengthof N = 128 under MLD<ref type="bibr" target="#b10">[12]</ref>. For TB-CC, we used the circular Viterbi algorithm (CVA).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Comparison of different channel codes with codeword length of N = 128 with different rates at BLER=10 -4 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Algorithmic complexity versus performance for different rate-1/2 channel codes with block length N = 128 at BLER = 10 -4 . The algorithmic complexity for different decoders are obtained from [14].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>14 F256</head><label>14</label><figDesc>LDPC Code (log-BP) F256 LDPC Code (FFT-BP) eMBB LDPC BP (50 Iterations) Turbo Code,m=4 (Max-log-MAP) eBCH (OSD order 5 with bounded complexity) Number of binary operations per inf. bit Gap to the normal approximation [dB]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>rana abbaS [M] (rana.abbas@sydney.edu.au) received the M.E. in 2013 and the Ph.D. degree in 2018, both in electrical engineering, from The University of Sydney. She is currently a researcher at the Centre of IoT and Telecommunications, at The University of Sydney. Her research interests include channel coding, random access, machine type communications and IIoT. She is the recipient of the Australian Postgraduate Awards Scholarship and the Norman I. Price scholarship from the Centre of Excellence in Telecommunications, School of Electrical and Information Engineering, The University of Sydney. She is also the winner of the Best Paper Award at IEEE PIMRC, 2018.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>yonghui li [F] (yonghui.li@sydney.edu.au) received his Ph.D. degree in November 2002 from Beijing University of Aeronautics and Astronautics. Since 2003, he has been with the Centre of Excellence in Telecommunications, the University of Sydney, Australia. He is now a professor in the School of Electrical and Information Engineering, University of Sydney. He was the recipient of the Australian Queen Elizabeth II Fellowship in 2008 and the Australian Future Fellowship in 2012. His current research interests are in the area of wireless communications, with a particular focus on MIMO, millimeter wave communications, machine to machine communications, coding techniques and cooperative communications.Sarah johnSon [SM] (sarah.johnson@newcastle.edu.au) received a Ph.D. degree in electrical engineering from the University of Newcastle, Australia. She then held a postdoctoral position at NICTA, Australia, followed by an Australian Postgraduate Research Fellowship (APD) and Future Fellowship from the Australian Research Council. She is currently a professor at the University of Newcastle, Australia. Her research interests include error correction codes and wireless communication networks.branka vuCetiC [F] (branka.vucetic@sydney.edu.au) is an ARC Laureate Fellow and professor of telecommunications, and Director of the Centre of Excellence in Telecommunications at the University of Sydney. During her career, she has held research and academic positions in Yugoslavia, Australia, UK and China. Her research interests include coding, communication theory and signal processing and their applications in wireless networks and industrial Internet of Things. She has co-authored four books and more than 400 papers in telecommunications journals and conference proceedings. She is a Fellow of the Australian Academy of Technological Sciences and Engineering and a Fellow of the IEEE. provide different level of reliability for low latency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Mahyar Shirvanimoghaddam, Mohammad Sadegh Mohammadi, Rana Abbas, Aleksandar Minja, Chentao Yue, Balazs Matuz, Guojun Han, Zihuai Lin, Wanchun Liu, Yonghui Li, Sarah Johnson, and Branka Vucetic</figDesc><table><row><cell>ACCEPTED FROM OPEN CALL</cell></row><row><cell>This article reviews the</cell></row><row><cell>state of the art channel</cell></row><row><cell>coding techniques for</cell></row><row><cell>URLLC. The stringent</cell></row><row><cell>requirements of URLLC</cell></row><row><cell>services, such as ultra-</cell></row><row><cell>high reliability and low</cell></row><row><cell>latency, have made it the</cell></row><row><cell>most challenging feature</cell></row><row><cell>of the 5G of mobile</cell></row><row><cell>networks. The problem</cell></row><row><cell>is even more challenging</cell></row><row><cell>for the services beyond</cell></row><row><cell>the 5G promise, such as</cell></row><row><cell>tele-surgery and factory</cell></row><row><cell>automation.</cell></row></table><note><p><p>Mahyar Shirvanimoghaddam (corresponding author), Mohammad</p>Sadegh Mohammadi, Rana Abbas, Chentao Yue, Zihuai Lin, Wanchun Liu, Yonghui Li, and Branka Vucetic are with The University of Sydney; Aleksandar Minja is with the University of Novi Sad; Balazs Matuz is with the German Aerospace Center (DLR); Goujun Han is with Guangdong University of Technology; Sarah Johnson is with the University of Newcastle.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>TUM) in 2007 and obtained his Ph.D. degree from Technische UniversitÃ¤t Hamburg-Harburg (TUHH) in 2013. Since 2007 he has been an associate researcher at the German Aerospace Center (DLR) in Oberpfaffenhofen. His research interests include novel forward error correcting schemes for satellite and space communication systems. goujun han [M] (gjhan@gdut.edu.cn) received his Ph.D. from Sun Yat-sen University, Guangzhou, China, and the M.E. degree from South China University of Technology, Guangzhou, China. From March 2011 to August 2013, he was a research fellow at the School of Electrical and Electronic Engineering, Nanyang Technological University, Singapore. From October 2013 to April 2014, he was a research associate in the Department of Electrical and Electronic Engineering, Hong Kong University of Science and Technology. He is now a full professor and Vice Dean of the School of Information Engineering, Guangdong University of Technology, Guangzhou, China. His research interests include wireless communications, coding and signal processing for data storage. zihuai lin [SM] (zihuai.lin@sydney.edu.au) received the Ph.D. degree in electrical engineering from Chalmers University of Technology, Sweden, in 2006. Prior to this he held positions at Ericsson Research, Stockholm, Sweden. Following Ph.D. graduation, he worked at Aalborg University, Denmark and currently is a senior lecturer at the School of Electrical and Information Engineering, the University of Sydney, Australia. His research interests include source/channel coding, small-cell networks, 5G systems, IoT and Ghost imaging, and so on. WanChun liu [M] (wanchun.liu@sydney.edu.au) received her Ph.D. degree at The Australian National University, Australia, in 2017. Currently, she is a postdoctoral research associate at The University of Sydney. Her research interests include ultra-reliable low-latency communications for industrial IoT and energy-constrained communications for consumer IoT.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>This article has been accepted for inclusion in a future issue of this magazine. Content is final as presented, with the exception of pagination.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AcKnowLedgMent</head><p>This work is supported in part by the Australian Research Council under Discovery Project grant DP180100606; the Laureate Fellowship FL160100032; and the European Union Horizon 2020 research and innovation programme under the Marie Sklodowska-Curie grant 734331. references</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">3GPP TS 22.261 service requirements for the 5G system; Stage 1 (Release 16)</title>
	</analytic>
	<monogr>
		<title level="s">Technical Specification Group Services and System Aspects</title>
		<imprint>
			<date type="published" when="2018-03">Mar. 2018</date>
		</imprint>
	</monogr>
	<note>3rd Generation Partnership Project</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">New Trends in the Practical Deployment of Industrial Wireless: From Noncritical to Critical Use Cases</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K L</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Industrial Electronics Mag</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="50" to="58" />
			<date type="published" when="2018-06">June 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">3rd Generation Partnership Project, 3GPP TSG RAN WG1 Meeting #92bis-Discussion and Decision</title>
		<imprint>
			<date type="published" when="2018-04">Apr. 2018</date>
		</imprint>
	</monogr>
	<note>R1-1804849-Remaining Issues on URLLC data channel coding</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Coding in the Finite-Blocklength Regime: Bounds Based on Laplace Integrals and Their Asymptotic Approximations</title>
		<author>
			<persName><forename type="first">T</forename><surname>Erseghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="6854" to="6883" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">3rd Generation Partnership Project, 3GPP TSG RAN WG1 Meeting #86-Discussion and Decision</title>
		<imprint>
			<date type="published" when="2016-10">Oct. 2016</date>
		</imprint>
	</monogr>
	<note>R1-1608770-Flexibility evaluation of channel coding schemes for NR</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Costello</surname></persName>
		</author>
		<title level="m">Error Control Coding: Fundamentals and Applications</title>
		<imprint>
			<publisher>Pearson-Prentice Hall</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On Performance and Complexity of OSD for Short Error Correcting Codes in 5G-NR</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Wonterghem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. BalkanCom</title>
		<meeting>BalkanCom</meeting>
		<imprint>
			<date type="published" when="2017-06">2017. June 2017</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the Performance of Short Tail-Biting Convolutional Codes for Ultra-Reliable Communications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gaudio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SCC 2017 11th Int&apos;l. ITG Conf. Systems, Communications and Coding</title>
		<meeting>SCC 2017 11th Int&apos;l. ITG Conf. Systems, Communications and Coding</meeting>
		<imprint>
			<publisher>VDE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels</title>
		<author>
			<persName><forename type="first">E</forename><surname>Arikan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="3051" to="3073" />
			<date type="published" when="2009-07">July 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">CRC-Aided Decoding of Polar Codes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Niu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Lett</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1668" to="1671" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Database of Channel Codes and ML Simulation Results</title>
		<author>
			<persName><forename type="first">M</forename><surname>Helmling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">U</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<date type="published" when="2018-01-14">14 Jan. 2018</date>
		</imprint>
	</monogr>
	<note>30TUwww.uni-kl.de/channel-codes</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">3rd Generation Partnership Project, 3GPP TSG RAN WG1 Meeting #87-Discussion</title>
		<imprint>
			<date type="published" when="2016-11">Nov. 2016</date>
		</imprint>
	</monogr>
	<note>R1-1611108-Evaluation on Channel Coding Candidates for uRLLC and mMTC</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Channel Coding for Ultra-Reliable Low-Latency Communication in 5G Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sybis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Vehicular Technology Conf. (VTC-Fall)</title>
		<meeting>Vehicular Technology Conf. (VTC-Fall)</meeting>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Near-Capacity Adaptive Analog Fountain Codes for Wireless Channels</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shirvanimoghaddam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vucetic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Lett</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2241" to="2244" />
			<date type="published" when="2013-12">Dec. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Mahyar ShirvaniMoghaddaM [M] (mahyar.shm@sydney</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m">School of Electrical Engineering and Computing at the University of Newcastle, Australia. He is currently an academic fellow at the School of Electrical and Information Engineering, The University of Sydney, Australia. His general research interests include channel coding techniques</title>
		<imprint>
			<date type="published" when="2015-01">January 2015</date>
		</imprint>
		<respStmt>
			<orgName>University of Tehran, Iran ; Sharif University of Technology, Iran</orgName>
		</respStmt>
	</monogr>
	<note>October 2010, and the Ph.D. degree from The University of Sydney, Australia. multiple access techniques, and machine-to-machine communications</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">He then worked as a post-doctoral research fellow at the University of Sydney, Australia, and then joined the semiconductor industry to design and develop innovative IoT solutions. He has worked with industry and academia, and has several years of experience in research on subjects in statistical signal processing, wireless communications, and efficient transmission protocols for next-generation systems</title>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Sadegh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammadi</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">m.s.mohammadi@gmail. com) received the M.Sc</title>
		<imprint/>
		<respStmt>
			<orgName>University of Tehran, Iran, and the Ph.D. jointly from Aarhus University, Denmark and Macquarie University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
