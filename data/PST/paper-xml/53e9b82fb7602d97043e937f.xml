<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Progressive Compression for Lossless Transmission of Triangle Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Alliez</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Southern California</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mathieu</forename><surname>Desbrun</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Southern California</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Progressive Compression for Lossless Transmission of Triangle Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D61668862710242416F2F87ABF1A5B68</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Triangle Mesh Compression</term>
					<term>Progressive Transmission</term>
					<term>Connectivity Encoding</term>
					<term>Geometry Encoding</term>
					<term>Levels of Details</term>
					<term>Mesh Decimation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Lossless transmission of 3D meshes is a very challenging and timely problem for many applications, ranging from collaborative design to engineering. Additionally, frequent delays in transmissions call for progressive transmission in order for the end user to receive useful successive refinements of the final mesh. In this paper, we present a novel, fully progressive encoding approach for lossless transmission of triangle meshes with a very fine granularity. A new valence-driven decimating conquest, combined with patch tiling and an original strategic retriangulation is used to maintain the regularity of valence. We demonstrate that this technique leads to good mesh quality, near-optimal connectivity encoding, and therefore a good rate-distortion ratio throughout the transmission. We also improve upon previous lossless geometry encoding by decorrelating the normal and tangential components of the surface. For typical meshes, our method compresses connectivity down to less than 3.7 bits per vertex, 40% better in average than the best methods previously reported <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18]</ref>; we further reduce the usual geometry bit rates by 20% in average by exploiting the smoothness of meshes. Concretely, our technique can reduce an ascii VRML 3D model down to 1.7% of its size for a 10-bit quantization (2.3% for a 12-bit quantization) while providing a very progressive reconstruction.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With the growth of e-commerce and entertainment over the internet, the rapid transmission of 3D computer models becomes essential. Both virtual shopping malls and virtual worlds require massive transmissions of triangulated 3D geometric data over the network. In this paradigm, geometry is bound to become as commonplace as text, sound, pictures, or videos. Turning a geometric object into a bit stream is therefore a very timely and relevant problem. However, signals such as sounds, pictures, or movies can rely on Fourier analysis to determine their theoretical entropy, indicating what compression ratio can be achieved. Unfortunately, in the case of a 2-manifold in 3D, we do not have any theoretical results to measure how close to the theoretical compression limit we are: surfaces are almost impossible to analyze with the current mathematical tools due to irregular valences, non-uniform sampling, and the added notion of topology. Designing a new compression algorithm is therefore all the more fundamental as it gives a better understanding of what is the real information content of a surface.</p><p>£ alliez@usc.edu † desbrun@usc.edu</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1: Our compression technique progressively transmits an arbitrary triangle mesh vertex by vertex. With (bottom) or without (top) the use of a metrics to drive the vertex ordering, we maintain good mesh quality and good rate-distortion ratio all along the transmission.</head><p>Since data transmission is a transaction between a client and a server, we must take the user's needs into account to judge the optimality of a compression algorithm, and not only the pure information theory side of it. An end user may not be very concerned about technical aspects like the bit rate, instead she is likely interested in getting a perceptually good geometric quality in the best time possible. If the server provides data using a single-rate coding, i.e., sending serially vertex after vertex, the user cannot judge the pertinence and quality of the information sent until the full transmission is achieved. This leads to a loss of time (and patience) on the user side, and a loss of network bandwidth for the server. The key idea to address this issue is to use progressive coding, where data are sent in a coarse-to-fine way. Optimizing the quality now equates to an optimization of the rate/distortion ratio.</p><p>Concretely, progressive compression requires the transmission of a very coarse approximation first, followed by subsequent bits that allow the progressive addition of more and more details. This process will allow the user to get an early grasp of the geometry. An ideal progressive lossless coder should reach the same rate as a single-rate one when the transmission is over, with a minimal granularity so that each new bit received by the decoder may be used to refine the current decoded mesh. Thus, progressive coding can be seen (again, ideally) as a simple reshuffling of the data. As recovering original connectivity and vertex position is very important for engineers, scientists, and for interactive collaborative design among other industrial applications, we focus on the design of a novel approach to progressive, lossless encoding of arbitrary meshes to try to narrow the current significant gap in bit ratio between single-rate and progressive encoding methods.</p><p>A mesh compression algorithm must compress two kinds of information: the connectivity (adjacency graph of triangles) and the geometry (positions of the vertices). These two types of data are not totally independent, since the Gauss-Bonnet theorem for instance states a necessary condition between geometry and topology of a surface. However, since this condition is global, it is safe and convenient to consider them separately. In order to present how we can optimize the compression ratios of both geometry and connectivity, we first review the previous work in this domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Previous Work</head><p>We first briefly mention some of the single-rate coding techniques currently known, since they offer insight into compression of 3D objects. The reader can find a more detailed overview in <ref type="bibr" target="#b26">[27]</ref>.</p><p>Most of the initial mesh compression techniques use triangle strips as their encoding strategy <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b25">26]</ref>, and/or vertex buffers <ref type="bibr" target="#b9">[10]</ref>. The EdgeBreaker algorithm <ref type="bibr" target="#b19">[20]</ref>, however, uses a different strategy: it turns a mesh into a sequence of five-symbol strings using an edge conquest. Using this method a guaranteed 3.67 bit/vertex rate for connectivity is presented in <ref type="bibr" target="#b13">[14]</ref>. A very efficient decompression of an EdgeBreaker code is introduced in <ref type="bibr" target="#b20">[21]</ref>, while a better rate for regular models is proposed in <ref type="bibr" target="#b23">[24]</ref>.</p><p>For the last three years, most papers refer (and use) the Touma and Gotsman algorithm <ref type="bibr" target="#b27">[28]</ref> as the best single-rate encoder in terms of compression ratio, especially for regular meshes. This technique defines an edge-centered conquest, creating one valence code per vertex, and some additional, yet significantly less frequent codes: dummy for boundaries, split whose frequency is closely related to mesh irregularity, and merge for genus greater than 0. The ordered list of all valences and codes generated during the conquest are then processed by entropy encoding. The decoder simply reproduces the conquest according to the flow of valences sent. This technique results in amazingly low bit rates on very regular meshes (valence 6 almost everywhere), since the list is basically a string of sixes, containing almost zero entropy. Recently in <ref type="bibr" target="#b0">[1]</ref>, the same valence-driven approach is improved upon; more importantly, encoding only valences is proven to lead to the optimal bit rate per vertex for arbitrary connectivity, explaining the success of the valencebased techniques.</p><p>As for the progressive encoders, Hoppe introduces in <ref type="bibr" target="#b10">[11]</ref> an algorithm for progressive transmission, starting from a coarse mesh and inserting vertices one at a time. It uses the edge collapse topological operator in order to decimate and record a sequence of vertex split encodings. The granularity is optimal, but encoding each split requires log 2 ´#vµ bits both to localize the vertex to split and several bits to still locate its two incident edges to cut. A method called Progressive Forest Split Compression is proposed by Taubin et al.in <ref type="bibr" target="#b24">[25]</ref>, using a base mesh and a forest of vertex splits. Pajarola and Rossignac <ref type="bibr" target="#b17">[18]</ref> group vertex-split operations into batches, then traverse the mesh and specify splits by marking each vertex using one bit, leading to an amortized cost of less than three bits per vertex for the marking process. They encode the inverse edge collapse operation by indicating the two edges cut during the vertex split. The geometry is encoded using a butterfly-like prediction approach, but the faster version of that method <ref type="bibr" target="#b18">[19]</ref> returns to a simpler predictor for geometry. The connectivity of typical meshes is compressed down to approximately 7.2 bits per vertex.</p><p>Leading to an even better bit rate, Cohen-Or et al. <ref type="bibr" target="#b4">[5]</ref> propose to alternate between a 2-and 4-coloring technique to decimate the mesh. The choice of the coloring is driven by the distribution of valences in a given level of detail. The authors use vertex removal and a deterministic (or geometric) angle-driven retriangulation. Unfortunately, the inside Z-triangulation leads to degenerate meshes, i.e. with long thin triangles. The authors try to compensate for the degeneracy through an immediate 2-coloring pass. However, compared to <ref type="bibr" target="#b17">[18]</ref>, the geometric quality of the progressive mesh remains worse. On the other hand, they achieve up to 15% better compression rates. Here again, these results cannot compete with single rate methods <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b19">20]</ref> since their techniques basically increase the dispersion of valence due to the retriangulation.</p><p>For encoding the geometry, most papers use prediction, quantization and arithmetic coding. Khodakovsky et al. <ref type="bibr" target="#b12">[13]</ref> point out the great importance of normal versus tangent decomposition of the relative position for bit allocation in geometry. Devillers and Gandoin <ref type="bibr" target="#b7">[8]</ref> totally suppress the order of the vertices, assuming that a geometry-centered triangulation <ref type="bibr" target="#b2">[3]</ref> is later able to progressively rebuild the connectivity from the regularity of the point cloud transmitted. Snoyeink et al. <ref type="bibr" target="#b22">[23]</ref> and Denny and Solher <ref type="bibr" target="#b6">[7]</ref> stress that any data already transmitted have defined an implicit order which can be used to save significant entropy.</p><p>Since compression ratios and geometry quality are intricately related, King and Rossignac <ref type="bibr" target="#b14">[15]</ref> and Khodakovsky et al. <ref type="bibr" target="#b12">[13]</ref> really look at 3D compression as a rate/distortion problem, rather than from a pure rate viewpoint. Note that <ref type="bibr" target="#b12">[13]</ref> obtains the best geometry compression ratios by far, but through a complete remeshing of the 3D surface, which is definitely the best thing to do if only the visual aspect of a surface needs to be transmitted. On the other hand, we propose in this paper a lossless encoder, that will transmit an arbitrary mesh in full, yet in a progressive way.</p><p>Figure <ref type="figure">2</ref>: Left: an optimal independent set of patches, tiling the mesh. Right: a non-optimal independent set of patches with white-colored null patches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview</head><p>From the exploration of previous encoders, we make the following simple observations. 1) A deterministic conquest avoids an explicit transmission of order over the vertices. It implicitly builds an order that the coder and the decoder will agree on. If we want the geometry to also be progressive, this conquest must depend uniquely on connectivity. 2) An optimal progressive connectivity encoder should generate one valence code per vertex of the original mesh, in any order. This will achieve "minimal" entropy as we know it from <ref type="bibr" target="#b0">[1]</ref>. 3) Decimation quality and compression ratio do not seem to be mutually optimizable. Although a perfect decimation is not crucial, care needs to be taken in order to avoid any mesh degeneracies.</p><p>Our contributions are built upon these observations. We propose a novel method for the progressive, lossless encoding of meshes, aiming at getting as close as possible to the single-rate compression ratios. We use the minimal granularity for both connectivity and geometry, i.e., we decimate (resp. insert) only one vertex at a time during the encoding (resp. decoding) phase. In a nutshell, the encoding algorithm can be roughly described in two stages:</p><p>¯A valence-driven decimating conquest constructs an independent set of patches <ref type="bibr">(1-rings)</ref>, alternating between two very simple strategies. Each patch center vertex is then removed, and the patch gets strategically re-triangulated to promote a balanced valence everywhere. We refer to this 2-step decimation as the 3-to-1 (or inverse Ô</p><p>3) simplification for reasons that will be made clear in Section 3.5 (see Figure <ref type="figure" target="#fig_7">11</ref>). ¯The list of valences of the removed vertices (plus some "cosmetic" codes) is then compressed by a code simplification method that simulates the decoding process to suppress redundancies and a subsequent adaptive arithmetic encoder.</p><p>The remainder of this paper details this algorithm, and is articulated as follows: in Section 2, we give conventions and definitions of terms we will use during the description of our algorithm in Section 3, which details the decimation strategy, the patch conquest, and the patch retriangulation. Section 4 will explain how the end user can easily and efficiently decode the bit stream previously encoded. We detail geometry encoding in Section 5, and give multiple results in Section 6 to show both the quality of the hierarchy transmitted and the rate achieved, between 30% and 40% better than previous progressive encoders. We finally give conclusions in Section 7.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definitions</head><p>In this section, we briefly describe some relevant definitions we will use throughout this paper. When necessary, we define a graphics convention for each of these definitions to enhance the clarity of the figures.</p><p>-Patch: a degree-d patch is a set of faces incident to valence-d vertex (Figure <ref type="figure">4</ref>.A).</p><p>-Vertex removal: operation consisting in removing a vertex and its incident triangles, and subsequently remeshing the remaining hole (Figures 4.B and 4.C).</p><p>-Independent set: a set of patches on a mesh where each face belongs to at most one patch. An optimal independent set is achieved when each face of the mesh belongs to exactly one patch (Figure <ref type="figure">2</ref>.A): the patches then tile the mesh completely.</p><p>-Null patch: a face that does not belong to any patch. This occurs when a mesh is not completely tiled by the patches. Null patches are colored in white on Figure <ref type="figure">2</ref>.B.</p><p>-Gate: an oriented edge, storing a reference to its front face (see Figure <ref type="figure" target="#fig_0">3</ref>). A gate allows us to go from one patch to an adjacent one during a mesh traversal.</p><p>-State flags: each face and vertex can be tagged free, conquered or to be removed, depending on their current state.</p><p>-Retriangulation tags: each vertex can be assigned a minus © or a plus ¨according to whether one wants to strategically minimize their valence or to maximize it respectively during a retriangulation. These tags are displayed on our figures when it is required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A B C</head><p>Figure <ref type="figure">4</ref>: A: a degree-5 patch. B: removal of the middle vertex. C: retriangulation of subsequent hole.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Progressive Connectivity Encoding</head><p>In this section, we detail the core of our progressive encoding algorithm. We explain how a valence-driven conquest, similar in spirit to <ref type="bibr" target="#b0">[1]</ref>, allows us to decimate a mesh layer by layer using vertex removals, while both maintaining a good mesh quality throughout the simplification and guaranteeing near-optimal compression ratios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Decimation/Coding Trade-off</head><p>Progressive transmission implies model simplification. We therefore have to define a decimation strategy that will drive our encoder. Decimation techniques usually need an atomic decimation operator, an error metric, and a set of topological constraints. In our case, the most appropriate decimation operator is vertex removal, since it corresponds to the finest granularity of the mesh, therefore inducing the most progressive decimation. Unfortunately, the use of error metrics in reliable decimation algorithms (for instance <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17]</ref>) leads to almost random vertex removals on the mesh. Coding the random access of such a decimation would be extremely costly compared to a single-resolution conquest <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b0">1]</ref>, since it requires the coding of a localization in a large set of vertices. Moreover, we would prefer not to rely heavily on geometrycentered decisions during the decoding process since we seek independence between connectivity and geometry encoding. It thus seems that one cannot have an optimal decimation and an optimal connectivity encoding at the same time. Our goal to obtain the best rate/distortion ratio at any time during the transmission presents us with a delicate tradeoff. This naturally led us to investigate whether a valence-driven decimation would be more appropriate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Valence-driven Decimation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Importance of Low Valence Vertices</head><p>We first make the following simple observation: removing a vertex with a valence greater than six (resp., lower than 6) from a triangle mesh and remeshing the subsequent hole leads to an increase (resp., a decrease) in the sum of the valences of the remaining vertices. This is a direct consequence of the Euler formula. If we write V ¼ the new sum of valences after one valence-v vertex removal and a local remeshing, and V the original sum of all valences excluding this vertex, we have:</p><formula xml:id="formula_0">V ¼ V • v 6µ</formula><p>. Therefore, a vertex removal leads to a systematic change in valence distribution, as shown in Figure <ref type="figure" target="#fig_1">5</ref>. Using the connectivity entropy analysis described in Section 1.1, we thus claim that removing a vertex of valence more than six increases entropy: the data excursion of the list of valences globally increases, resulting eventually in a lower compression rate. It is therefore a bad strategy in a compression algorithm seeking the lowest bit cost. Additionally, our experiments have shown that removing a high valence vertex often leads to two major inconveniences, independent of the error metrics chosen. First, it creates badly shaped triangles (even using a Z-triangulation as in <ref type="bibr" target="#b4">[5]</ref>) if no local geometry adjustment is done after the removal, while low valence vertex removals are much safer. Second, a large valence vertex removal is more likely to violate the manifold property or to change the topology of the surface. We thus strongly advocate, as already done in <ref type="bibr" target="#b6">[7]</ref>, for the removal of the vertices of valence 6 ( 4 on boundaries) since it maintains a low statistical valence dispersion around the average value 6. Such a simple decimation strategy provides an appropriate trade-off between mesh quality and valence excursion. However, we need to deal with a few topology and geometry constraints to ensure good decimation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Safety Conditions for Vertex Removal</head><p>A vertex removal can safely be performed only if it does not violate the manifold property of the surface. However, to make our method more flexible, we let the user select other types of conditions that may be desirable. Among the vertices of valence 6 encountered during the conquest and potentially removable, we forbid: ¯vertices whose removal leads to violation of the manifold property of the mesh, i.e. when the corresponding remeshing process would create already existing edges.</p><p>¯vertices whose removal leads to a normal flipping locally; we let the user enable or disable this option according to the desired tradeoff between quality and compression rates, since the normal flipping is not an issue for the encoder, but may be one for the user.</p><p>¯vertices violating any metrics-related decision designed by the user; simply put, one can decide at any point if a vertex can be removed or not in order to tune the quality of the progressivity.</p><p>In essence, the decimation algorithm is open to any metrics that would make a better rate/distortion tradeoff for a given application. As mentioned before, this flexibility in quality will obviously result in an additional bit cost.</p><p>This valence-driven decimation is very flexible, since any or no error metrics can be used. To prove that using only the valence is safe even without error metrics, all the examples in this paper (except for the fandisk on Figure <ref type="figure">1</ref>, bottom) do not use any other error metric other than a decimation purely driven by valence. Figure <ref type="figure">1</ref> (top) illustrates such a decimation down to an eight-vertex polyhedron.</p><p>For objects with specific geometric characteristics like sharp edges, a geometry-driven decimation can substantially improve the perceptual rate-distortion dramatically. As we mentioned, one can skip some important vertices by just sending null patch codes if these particular vertices may better remain present at this stage. We designed a very simple metrics-based decimation mode where each vertex is first checked for validity. We experimented with two metrics-based tests: one based on a vertex-to-patch distance, and one based on the volume embedded between a patch and its retriangulated version (and the area change for boundaries) as depicted in Figure <ref type="figure" target="#fig_2">6</ref>. The latter is similar in spirit to <ref type="bibr" target="#b16">[17]</ref>, except that we use a binary decision for each vertex removal. We normalize the volume error as following: error 3 Ô ´volumeµ ´perimeter degreeµ so that the same threshold can be used for all the scales. Figure <ref type="figure">1</ref> (bottom) shows an example of the fandisk mesh decimation using the volume-based metric and a threshold parameter set to 0 25. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Overview of the Algorithm</head><p>Now that our notion of decimation is selected, we can describe the outline of the encoding algorithm. The key idea is that in an orientable manifold, faces incident to a vertex can be ordered. Considering an arbitrary set of patches, any vertex removal followed by a local retriangulation of the patch leaves the patch borders unchanged (see Figure <ref type="figure">4</ref>). Therefore, these borders can be known by both the encoder (that has the original patch) and the decoder (that has the patch now retriangulated, but with the same borders). As a logical consequence of what we have presented, we can create a decimating conquest that decimates vertices of valence less than six encountered along the way, while isolating them in patches to leave the borders intact. For reasons that will become obvious the two following sections, we alternate such a decimating conquest with a cleaning conquest, targeting valence-3 vertices only. This will guarantee an overall nice 3-to-1 decimation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Decimating Conquest</head><p>Our decimating conquest uses the notion of a gate described in Section 2 as the base tool in order to traverse the mesh and collect adjacent patches. We start with an initial seed gate arbitrarily chosen among the edges of the original mesh. This gate (g 1 in Figure <ref type="figure">7</ref>), is pushed onto a first-in-first-out (fifo) queue after we flag its two vertices as conquered. We then pop the gate out of the queue, and consider the three following cases:</p><p>1. if its front face is tagged conquered or to be removed: There is nothing to do, since the patch we enter has already been or cannot be conquered. We discard the current gate, and proceed to the next gate available on the fifo queue.</p><p>2. else, if its front vertex is free and has a valence 6: The corresponding patch will be decimated and retriangulated. The front vertex is flagged to be removed, its neighboring vertices are flagged conquered and its incident faces are flagged to be removed. The symbol v corresponding to the valence of the removed vertex (or equivalently, the degree of the patch's boundary polygon) is output, and the v 1 output gates are generated and pushed to the fifo queue. We discard the current gate, and proceed to the next gate available on the fifo queue. Figure <ref type="figure" target="#fig_6">10</ref>(a) and Figure <ref type="figure">7</ref> illustrate this general behavior of the conquest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">else, (if its front vertex is free and has a valence 6) or (if its front vertex is tagged conquered):</head><p>The front face must be a null patch; we declare it conquered, a code null patch is generated and the two other output gates of the triangle are pushed onto the fifo queue (see Figure <ref type="figure" target="#fig_3">8</ref>). We discard the current gate, and proceed to the next gate available on the fifo queue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Patch Retriangulation</head><p>We must now provide a completely deterministic remeshing strategy to fill up the patches after each vertex removal, since the decoder must be able to still find the original borders of the patches. To guarantee a nice remeshing, we designed an adaptive patch retriangulation process driven by a vertex-tagging procedure that allows us to maintain, at no extra cost, a good mesh quality during the decimation while keeping the deterministic behavior. The underlying Figure <ref type="figure">7</ref>: Standard conquest -A: g 1 denotes the first seed gate pushed into the fifo queue. This gate can conquer the patch of its free front vertex. This valence-5 vertex and its adjacent faces are flagged to be removed. Every patch border vertex becomes conquered, four gates are pushed in counterclockwise order into the gate queue and a code 5 is output. B: g 2 becomes active, its valence-6 front vertex becomes to be removed, the patch's vertices are flagged conquered, five gates are pushed into the queue and a code 6 is output. C: code 6 patch; D,E: Same behavior, two successive codes 6 being output. F: Eventually, all vertices become either to be removed (center of patches) or conquered (borders of patches), colored respectively yellow and grey. The queue is now empty.</p><p>idea is to keep the valence distribution as compact as possible: as we will show, our patch retriangulation leads to a perfect 3-to-1 (or " Ô 3 1 ") simplification if the mesh is regular, and to a good triangulation otherwise.</p><p>Each vertex is tagged either © or ¨during the conquest, depending on whether it is desirable to locally minimize or maximize its valence during the remeshing of its adjacent patches. At the beginning of the conquest, the right and the left vertex of the seed gate are flagged ¨and © respectively. Then, using the tag table shown in Figure <ref type="figure" target="#fig_5">9</ref>, we retriangulate the patch and tag its vertices accordingly. We will see during the description of the decoder (see Section 4) that it will allow us to find the borders of a retriangulated patch automatically as soon as the valence of the decimated middle vertex is known. Now, for the subsequent gates, their two vertices will already be tagged, and just a quick look at the table according to the tags on the gate allows us to tag the rest of the new patch entered.  There may be clashes between tags as we conquer more and more patches: if most of the vertices of a patch have already been tagged, we may not be able to have a configuration similar to our table. In this case, we keep the tagged vertices with their original tag, but we triangulate the patch according to the table anyway, and assign the vertices still untagged with the tags from the table. Since the decoder is able to do the same operations (see Section 4 and Figure <ref type="figure" target="#fig_5">9</ref>), we keep the deterministic behavior of our retriangulation and suppress any further ambiguities.</p><p>The previous remeshing strategy has encouraged on average one out of two vertices on a patch border to be of low valence. As a consequence, our mesh will be now be littered with valence-3 vertices. Our remeshing strategy may therefore seem to be counter-intuitive since we sought to reduce the statistical valence dispersion around the value 6. However, it turns out that a cleaning conquest right after a decimating conquest will in fact improve the mesh considerably, and result in the promised valence balance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Cleaning Conquest</head><p>The cleaning conquest is almost exactly the same as the decimating conquest, previously defined. The main difference lies in the gates we put in the queue. As it can be noticed in Figure <ref type="figure" target="#fig_7">11</ref>.B, the valence-3 patches are now separated by a triangle in the regular case. Therefore, we modify the conquest to put some gates not directly on the border of the current patch, but on the two edges of every face adjacent to the border, and we flag those faces as conquered (see Figure <ref type="figure" target="#fig_6">10(b)</ref>). The only other difference with the previous decimating conquest is that we restrain our conquest to valence-3 vertices. Figure <ref type="figure" target="#fig_7">11</ref> demonstrates that applied on a locally regular mesh, our coupled conquests will perform a 3-to-1 simplification, which corresponds to an inverse " Ô 3 subdivision" <ref type="bibr" target="#b15">[16]</ref>. Therefore, a decimation conquest followed by a cleaning conquest will suppress two faces out of three : we obtain near-optimal valence encoding and good mesh decimation (see also Figure <ref type="figure">1</ref>).</p><p>The conquest is terminated when the gate queue is empty. We are then done with the first layer of decimation; we now may begin the next layer of conquest, starting with a decimating one again. We will stop when we reach the final number of vertices requested by the user, or, very rarely, when we cannot suppress any vertices in a layer without violating topology or metric constraints. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Arithmetic Coding</head><p>The code sequence generated by a decimating conquest is composed of valence codes between 3 and 6, plus some null patch codes, while the sequence generated by a cleaning conquest is only composed of codes 3 and null patch. The decoder, knowing that we alternate between decimating and cleaning conquests, can systematically replace a 3 code by a 6 code for cleaning odd layers. Indeed, during the decimating conquest, we try to minimize the valence of every other vertex (tagged ©) on a patch in order to get a significant number of valence-3 vertices, which are easy to remove safely during the cleaning conquest. However, these valence-3 vertices are created only temporarily to keep our retriangulation deterministic, but they were vertices of valence 6, hence the substitution we perform. Since an arithmetic encoder is very sensitive to the occurrence of codes, it allows us to keep the peak of occurrence at valence 6 to optimize the compression. Note also that our technique of cleaning decimation is related to the 2/4-coloring alternation in <ref type="bibr" target="#b4">[5]</ref>, since we alternate between two different conquests that, conceptually, always go by pairs too.</p><p>Since we must also reorder these codes for the decoder, we proceed as follows: Let A 1 be the first sequence generated by a decimating conquest, followed by a sequence B 1 resulting from cleaning, then A 2 is the second decimating conquest followed by B 2 , ..., and A n and B n being the two final sequences. We first substitute all the 3s by 6s in B 1</p><p>B n , then we feed the sequence</p><formula xml:id="formula_1">B n ¡ A n ¡ B n 1 ¡ A n 1 ...A 2 ¡ B 1 ¡ A 1</formula><p>to an order-0 adaptive arithmetic encoder <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b21">22]</ref>. We point out that valence codes have not been reordered within a layer, only the layers themselves has been reshuffled. We will see in Section 4 that the decoder will then be able to decode this sequence layer by layer in the same order of conquest than the coder did, guaranteeing synchronization and correct decoding. Notice that for a very irregular mesh, numerous null patch codes may impede the compression ratio. We thus naturally tried to remove every unnecessary code null patch, and found that simulating a decoding stage removes on average one tenth of these accident codes. Since this tasks is achieved by the decoder, we describe it further in Section 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Discussion</head><p>With our valence-driven decimating conquest, we generate one valence code per vertex optimally, as in <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b0">1]</ref>. Indeed, if the mesh was very regular to start with, our global strategy will only generate codes six (one per vertex) and the mesh after conquest will remain regular: we will obtain extremely high compression ratios, just like <ref type="bibr" target="#b0">[1]</ref> since we encoded exactly the same zero-entropy sequence, just reordered to create progressivity. We therefore achieved the optimality sought for very regular meshes. Although a perfectly regular mesh is not at all representative of typical meshes, any local regularity of a mesh will generate a 3-to-1 simplification, while the other regions will have more null patch codes. Roughly, we found our coder to be always 25% to 40% better in compression ratio than other progressive connectivity coders on very irregular meshes, and easily up to 200% better on more regular meshes. We postponed the discussion of the different results with measured rates to Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Progressive Connectivity Decoding</head><p>The decoder receives sequences of valence or null patch codes. For a given layer, it refines the mesh in the same order as the conquest decimated the vertices during the encoding process. However, we receive the layers in reverse order, so we will start with a "un"cleaning conquest (we call 3-patch discovery), followed, by a "un"decimating conquest (called patch discovery), and we repeat. The discovery and the vertex insertions are synchronized through the state of the fifo queue; thus, the decoder will also know which layer needs to be processed, and will be able to toggle between the twogates/one-gate modes for the patch/3-patch discovery (as was described in Section 3.5). We now detail how the patch discovery and the vertex insertions are done from the transmitted valences or null patch codes, and explain the principle of code packing used in our encoder.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Patch Discovery and Vertex Insertion</head><p>The decoder uses exactly the same strategy defined in the coder (see Section 3), except for the significant difference that we now have to find the border of a patch each time we cross a gate. Aside from this particular problem, the implementation is perfectly similar, with the same flags, tags, and the same fifo queue. We therefore refer the reader to the section on coding (Section 3), and we only address the patch border discovery. When we cross a gate at any time during the discovery, its front face is the seed face of a retriangulated patch that we seek. Now, from the valence we receive through the order-0 adaptive arithmetic decoder <ref type="bibr" target="#b21">[22]</ref>, we must find a deterministic way to find the borders of this patch. It turns out that the decoder can deduce the way to incrementally walk on the faces using the current vertex tagging and the same tag tables. Indeed, since we perform the same propagation of tags and flags in the same order, and since the coder had retriangulated the patch according the current tags using the tag table, we know exactly how these retriangulation faces are connected. A few cases are possible, depending on the tags read on the two vertices of the gate, as illustrated in Figure <ref type="figure" target="#fig_8">12</ref>. For a valence v code, the discovery must be achieved successfully by walking on ´v 2µ free faces (remember this remark for the code packing section). The vertices are then flagged conquered and tagged to minimize or to maximize according to the vertex tagging table: we are then ready to add a vertex of the correct valence inside the patch, and we can proceed to the rest of the discovery. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Code Packing for Redundancy Elimination</head><p>We described in the previous section the basic decoding algorithm that makes the assumption that a valence v code must lead to a "discovery" walk onto ´v 2µ free faces. We can further reduce the bit rate significantly by eliminating some null patch codes due to the fact that this walk is sometimes not possible because of neighboring already-conquered faces. Let's suppose the decoder gets a code of valence v. If it is not possible to walk on the ´v 2µ adjacent faces as defined by the tag table, it must be that the gate being currently treated is actually a null patch, and the vertex valence we received is for later. The decoder can, in that case, resume its discovery after tagging this face as null patch. At the next gate where the ´v 2µwalk is possible, we know that the valence code was meant for this very gate. This naturally defines a very simple code packing idea for the coder, as we mentioned in Section 3: at the end of the encoding process, we give the current sequence of valence codes to the decoder, which typically removes one tenth of the null patch codes, then we feed the arithmetic encoder with the packed code sequence. To our knowledge, using a simulated decoder to further eliminate redundancies in a code sequence is a novel idea. Due to its extreme simplicity, we believe it could be useful for conquestcentered existing coding techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Geometry encoding</head><p>Now that we have defined a connectivity encoding method, we must also encode the geometry of the mesh, i.e., the positions of the vertices. Like the vast majority of previous work, we first apply a global quantization step to the mesh vertices, typically using 8 to 12 bits. Then, we can send the geometry information right after each vertex's valence code, to use the implicit order defined by our conquests. Local prediction, using the probable smoothness and regularity of the mesh, are used in order to further compress these generated geometrical values. Inspired by <ref type="bibr" target="#b12">[13]</ref>, we also separate normal and tangential components to further reduce the bit rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Barycentric Prediction</head><p>Each vertex transmitted in our algorithm is added in the middle of a patch, where all the neighbors are perfectly known both by the coder and the decoder (up to the desired quantization). The coder and the decoder can therefore use the barycenter of all the vertices of the patch as a first approximation for the position of the newly created vertex. More sophisticated methods such as butterfly or Loop stencil for prediction turn out to behave badly for irregular meshes; in the absence of smoothness assumption on the mesh, the barycentric prediction is as good as another in practice, as already noticed for instance in <ref type="bibr" target="#b18">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximate Frenet Coordinate Frame</head><p>The coder or the decoder can also approximate the normal of the mesh locally by a area-weighted sum of the normals of each triangle present in the patch processed. The normal n and the barycenter b now define the approximate tangent plane of the surface. We can proceed to compute an approximate Frenet frame, in order to reduce the excursion of the offset vector for smooth surfaces.</p><p>To compute the first tangent vector t 1 , we simply project the gate onto the normal plane, and normalize the result. The second tangent vector t 2 is obtained through a cross product of n and t 1 : this completes the coordinate frame. Figure <ref type="figure" target="#fig_9">13</ref> illustrates the construction for a set of vertices v 1 v 2 v n defining a patch and its faces. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantization of Frenet Frame Coordinates</head><p>We denote v r the vertex position we now want to encode/decode. With the Frenet frame we built, the coder finds the new Frenet coordinate of this point by projection on our basis vectors (see Fig-</p><formula xml:id="formula_2">ure 13): v r b • α ¡ t 1 • β ¡ t 2 • γ ¡ n Furthermore,</formula><p>we can round each Frenet coordinate (α β γ) to a signed integer value so that the decoder is able to restore the position of v r to the same quantized value using a post-quantization. We process all the decimated vertices of a layer as indicated, and find both the range and the offset of each set of tangential and normal coordinates. We communicate this information to the decoder before sending the t and n values of all the vertices of the coming layer. With this two-pass technique, we help the arithmetic coder to adapt the number of bits to the range of the geometry. The decoder will just have to add the Frenet coordinates to the barycenter to find the final position of the vertex inserted.</p><p>Our experiments showed that this local Frenet quantization allows the adaptive arithmetic coder to achieve a better adaptation to normal and tangential distributions of each layer: as noted in <ref type="bibr" target="#b12">[13]</ref>, most fine meshes contain much more information in the normal direction that in the tangential directions. Our encoder can therefore adapt to the smoothness (preponderance of normal) and/or the uniformity (very little tangential components) of the mesh encoded. As demonstrated in the next section, this way to deal with geometry is always 15% better than previous approaches, and can potentially be much more for very uniform, smooth meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>We tested our method on many different meshes, more or less regular, more or less uniform, to fully evaluate our coder performances. On a typical mesh like the horse (see Figure <ref type="figure">14</ref>), we can reduce the original ascii VRML file to only 2.33% of its initial size for a 12-bit quantization (and only 1.67% for a 10-bit quantization). Note that this is respectively only 1 11 and 1 08 times more than the same mesh encoded by an efficient single-rate encoder <ref type="bibr" target="#b27">[28]</ref>, but with added benefit of a fully progressive transmission. Figure <ref type="figure">14</ref> and Table <ref type="table" target="#tab_1">1</ref> sum up our compression results obtained from some typical meshes; the rate/distortion curve, obtained from Metro <ref type="bibr" target="#b3">[4]</ref>, proves the scalable behavior of the algorithm. Our current implementation encodes and decodes 5,000 faces/s on a regular PIII PC, handling arbitrary genus and arbitrary number of holes.</p><p>The average rate for arbitrary meshes of our progressive connectivity encoding is measured at 3.69 bits per vertex, not including the optimally regular torus (only shown here to confirm the excellent asymptotic behavior of the algorithm) or the fandisk using an error metric. We obtain a gain of 30% to 45% for the connectivity encoding ratios compared with the best progressive coders published so far <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18]</ref>. Indeed, Cohen-Or et al. <ref type="bibr" target="#b4">[5]</ref> and Pajarola et al. <ref type="bibr" target="#b17">[18]</ref> obtain in average 5.98 b/v and 7.0 b/v respectively on their similar examples. We need to emphasize that our technique allows for a fully progressive transmission, since we use our decimating technique down to less than 1 thousandth of the vertices of the original mesh (see Table <ref type="table" target="#tab_1">1</ref>), and often down to the minimum triangulated mesh of equivalent genus. Some previous work remains unclear on their decimation limits, while some others stop at about 20%, significantly loosing a part of the purpose of progressivity encoding.</p><p>The horse mesh mentioned above is encoded using 5.72 and 20 b/v by Cohen-Or et al. <ref type="bibr" target="#b4">[5]</ref> for the connectivity and the geometry respectively. In comparison, we achieve 4.61 and 16.24 b/v for the same geometry quantization. The fandisk is encoded using 6.8 and 15 b/v by Pajarola et al. <ref type="bibr" target="#b17">[18]</ref> respectively. We achieve 4.99 and 12.34 b/v for the same quantization (see Table <ref type="table" target="#tab_1">1</ref>) when using a volume-based metric (see Figure <ref type="figure">1</ref>, bottom). These examples are characteristic of our gains for arbitrary meshes. Highly regular and/or highly uniform meshes can be coded much more compactly, since our method exploits both regularity in valence and uniformity in geometry. Therefore, all our results point to the fact that, even if progressive lossless encoding seems to have an intrinsic additional entropy, our technique minimizes the extra cost and renders progressive coding almost as good as single-rate coding. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Models</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and future work</head><p>We have presented a novel method for progressive, lossless compression of arbitrary triangle meshes. Our contribution is two-fold: we improved significantly upon existing encoders for both connectivity and geometry. We showed that our encoding strategies for Figure <ref type="figure">14</ref>: Top: progressive compression ratios in bits per vertex for models with increasing regularity. Bottom: the venus mesh is progressively transmitted from 20 to 11362 vertices, while its distortion <ref type="bibr" target="#b3">[4]</ref> is rapidly decreasing. Note that the sample points on the curve go by adjacent pairs, as our coupled decimating/cleaning conquests do (see Section 3).</p><p>mesh connectivity and mesh geometry are both more efficient than any comparable previous work on all our tests. We even compete with single-rate connectivity coding techniques for very regular meshes, and take advantage of uniformity for geometry encoding as lossy encoders do <ref type="bibr" target="#b12">[13]</ref>. Our algorithm defines a new decimating conquest that allows us to be very close to the rate of one valence per vertex, the floor for connectivity entropy <ref type="bibr" target="#b0">[1]</ref>. We also described an original inverse Ô 3 simplification process that combines valence-driven decimation and adaptive retriangulation to maintain the regularity of valence along the progressive encoding. The method presented is also easy to implement while near optimal in the regular case. Finally, it is very flexible and open to any decimation error metrics if needed. In the irregular case, the null patch codes turn out to be the only impeding factor to better the compression ratios. Even if we removed between one tenth and one half of them using an innovative simulation of the decoding process, we believe more work in this area would still increase the benefits of our method. Compression ratio improvements, handling of non-manifold meshes or even polygon soups, and genus reduction/encoding are obvious future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure3: Left: a gate is defined by its oriented edge. Each gate stores a reference to its front face and its front vertex. Right: the gate item allows the conquest to achieve the mesh traversal through ordinary or null patches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Influence of a vertex removal on the sum of the valences of remaining vertices: only removals of vertices with valence less than six decrease the sum of remaining valences.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Left: the vertex-to-patch distance, normalized by the patch perimeter, is a possible error metric. Middle: Better results can be achieved by an error metric defined by the volume included between the original patch and the retriangulated one, still normalized by the patch perimeter. Right: the area change error metric is computed for a boundary vertex.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Null patch during conquest -A: the conquest cannot reach an optimalindependent set (null patches are colored in white). B: this null patch has been created when the red gate is popped out from the queue. Its front vertex is already conquered, a code null patch(N) is therefore output, its front face becomes conquered, and subsequently its two adjacent gates are pushed onto the queue. C: same behavior when the (newly popped) red gate becomes active.</figDesc><graphic coords="4,318.84,54.16,238.30,78.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Adaptive retriangulation process from degrees 3 to 6. The input gates are colored in red, the remeshing decision being only taken from the tags of their two vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: (a) Mode used during the decimating conquest. Each edge from the patch boundary (but the input gate) is pushed as a gate to the fifo queue. (b) Mode used during the cleaning conquest (only valence-3 patches). Each exterior face adjacent to an edge of the patch boundary is flagged conquered and two gates per conquered face are pushed to the fifo.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: A: a regular area generates optimal patch tiling. B: remeshing resulting from the vertex tagging process. Formation of extremal valences are encouraged, i.e. valence 3 and 9 in the regular case; the cleaning conquest then targets the valence-3 patches. C: after the cleaning decimation, the simplified mesh is still regular.</figDesc><graphic coords="5,318.84,562.74,238.30,58.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: The polygon discovery is achieved from an active input gate with tagged vertices and one valence code. The tags assigned to the vertices determine how to incrementally walk onto the faces from the current front face of the gate. A valence v 3 transmitted code leads to the discovery of ´v 2µ free faces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Prediction method for geometry encoding. The current input gate is colored in red. Residuals are expressed in terms of both tangential and normal components deduced from the current patch's frontier, known for both the coder and the decoder.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="8,54.84,54.12,238.48,280.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Compression rates for typical meshes. Notice that all these results decimate the meshes down to about 1 thousandth of their original vertex count to be fully progressive.</figDesc><table><row><cell></cell><cell cols="2">Vertices</cell><cell>Quant.</cell><cell>Connect.</cell><cell>Geometry</cell><cell>Total</cell></row><row><cell></cell><cell></cell><cell></cell><cell>#bits</cell><cell>bit/v</cell><cell>bit/v</cell><cell>bit/v</cell></row><row><cell>fandisk</cell><cell>6475</cell><cell>4</cell><cell>10</cell><cell>4.99</cell><cell>12.34</cell><cell>17.39</cell></row><row><cell>horse</cell><cell cols="2">19851 4</cell><cell>12</cell><cell>4.61</cell><cell>16.24</cell><cell>20.87</cell></row><row><cell>nefertiti</cell><cell cols="2">3407 12</cell><cell>10</cell><cell>3.95</cell><cell>11.88</cell><cell>16.01</cell></row><row><cell>mannequin</cell><cell cols="2">11703 4</cell><cell>10</cell><cell>3.58</cell><cell>9.98</cell><cell>13.59</cell></row><row><cell>venus</cell><cell>11217</cell><cell>16</cell><cell>10</cell><cell>3.59</cell><cell>10.15</cell><cell>13.82</cell></row><row><cell>tiger</cell><cell>2738</cell><cell>4</cell><cell>10</cell><cell>2.67</cell><cell>12.67</cell><cell>15.46</cell></row><row><cell>torus</cell><cell>36450</cell><cell>24</cell><cell>10</cell><cell>0.39</cell><cell>3.58</cell><cell>4.02</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors want to thank: Michael Schindler for help with his range encoder, Peter Schröder and Wim Sweldens for initial discussions, Zoë Wood and Mark Meyer for advice and proof-reading, and finally Magali Mazière for her very precious help. This work has been partially supported by the Integrated Media Systems Center, a NSF Engineering Research Center, cooperative agreement number EEC-9529152.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Valence-Driven Connectivity Encoding of 3D Meshes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Alliez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Conference Proceedings</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Time/space Tradeoffs for Polygon Mesh Rendering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bar-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="141" to="152" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Smooth Surface Reconstruction via Natural Neighbour Interpolation of Distance Functions</title>
		<author>
			<persName><forename type="first">J-D</forename><surname>Boissonnat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cazals</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Computational Geometry</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rocchini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
		<author>
			<persName><surname>Metro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Measuring Error on Simplified Surfaces. Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="167" to="174" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Progressive Compression of Arbitrary Triangular Meshes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Remez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 99 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="67" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Geometry Compression</title>
		<author>
			<persName><forename type="first">M</forename><surname>Deering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 95 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Denny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sohler</surname></persName>
		</author>
		<title level="m">Encoding a Triangulation as a Permutation of its Point Set. 9th Canadian Conference on Computational Geometry</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="39" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Geometric Compression for Interactive Transmission</title>
		<author>
			<persName><forename type="first">O</forename><surname>Devillers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P-M</forename><surname>Gandoin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 00 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="319" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Simplifying Surfaces with Color and Texture using Quadric Error Metrics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="263" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Real Time Compression of Triangle Mesh Connectivity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="133" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 96 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">New Quadric Metric for Simpliying Meshes with Apperance Attributes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 99 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="59" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Progressive Geometry Compression</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khodakovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schröder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sweldens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 00 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Guaranteed 3.67v bit Encoding of Planar Triangle Graphs</title>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Canadian Conference on Computational Geometry</title>
		<meeting>the 11th Canadian Conference on Computational Geometry</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="146" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimal Bit Allocation in 3D Compression</title>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="91" to="118" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>Theory and Applications</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ô 3-Subdivision</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 00 Conference Proceedings</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="103" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast and Memory Efficient Polygonal Simplification</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="279" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Compressed Progressive Meshes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="79" to="93" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Squeeze: Fast and Progressive Decompression of Triangle Meshes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pajarola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Computer Graphics International Conference</title>
		<meeting>the Computer Graphics International Conference</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">EdgeBreaker : Connectivity Compression for Triangle Meshes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="page" from="47" to="61" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">WrapZip Decompression of the Connectivity of Triangle Meshes Compressed with Edgebreaker</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="119" to="135" />
			<date type="published" when="1999-11">november 1999</date>
		</imprint>
	</monogr>
	<note>Theory and Applications</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Fast Renormalization for Arithmetic Coding</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schindler</surname></persName>
		</author>
		<ptr target="http://www.compressconsult.com/rangecoder/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Data Compression Conference</title>
		<meeting>IEEE Data Compression Conference<address><addrLine>Snowbird, UT</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">572</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Kerveld</surname></persName>
		</author>
		<title level="m">Good Orders for Incremental (Re)construction. 13th annual ACM Symposium on Comp. Geometry</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="400" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An Edgebreaker-based Efficient Compression Scheme for Regular Meshes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Szymczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Geometry: Theory and Applications</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>To appear in a special issue of</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Progressive Forest Split Compression</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guéziec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Geometry Coding and VRML</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE, Special issue on Multimedia Signal Processing</title>
		<meeting>the IEEE, Special issue on Multimedia Signal Processing</meeting>
		<imprint>
			<date type="published" when="1998-06">june 1998</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="1228" to="1243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">3D Geometry Compression</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH Conference course notes</title>
		<imprint>
			<date type="published" when="1999">1999-2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Triangle Mesh Compression</title>
		<author>
			<persName><forename type="first">C</forename><surname>Touma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gotsman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface 98 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="26" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Arithmetic Coding for Data Compression</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Witten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Neal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Cleary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1987-06">june 1987</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
