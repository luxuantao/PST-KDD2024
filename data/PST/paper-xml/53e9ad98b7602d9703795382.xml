<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Panelrama: Enabling Easy Specification of Cross-Device Web Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jishuo</forename><surname>Yang</surname></persName>
							<email>jishuoyang@dgp.toronto.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Wigdor</surname></persName>
							<email>daniel@dgp.toronto.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Panelrama: Enabling Easy Specification of Cross-Device Web Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3D6896E32D66CF6998C5F317B48AC2B1</idno>
					<idno type="DOI">10.1145/2556288.2557195</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Distributed user interfaces, multi-device environments H</term>
					<term>5</term>
					<term>2</term>
					<term>[Information Interfaces and Presentation]: User Interfaces -Graphical user interfaces</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present Panelrama, a web-based framework for the construction of applications using distributed user interfaces (DUIs). Our implementation provides developers with low migration costs through built-in mechanisms for the synchronization of a UI state, requiring minimal changes to existing languages. Additionally, we describe a solution to categorize device characteristics and dynamically change UI allocation to best-fit devices. We illustrate the use of Panelrama through three sample applications which demonstrate its support for known interaction methods, we also present the results of a developer study, which validates our belief that cross-device application experiences can be easily implemented using our framework.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>With the emergence of new computing form factors such as smartphones and tablets, it is increasingly likely that, at any given moment, a user has two or more computing devices available to them. Currently, the majority of applications on these devices operate independently, with isolated application state and I/O devices. The possibility of sharing state information and I/O resources between devices opens up a wealth of interaction possibilities: a user may retain workflow between devices, annex additional hardware to overcome device limitations, or use additional devices to enrich interactions (such as <ref type="bibr" target="#b24">[25]</ref>). For example, Figure <ref type="figure" target="#fig_0">1</ref> shows a video streaming application that distributes portions of its interface to devices which are ideal for the role: the video stream may be distributed to a TV, video controls to a smartphone for use as a remote, and related videos list to a tablet for easy browsing and selection of the next video.</p><p>Existing works make use of distributed user interfaces (DUIs) to allow applications to take advantage of multiple devices. DUIs enable developers to distribute portions of an application's interface to a number of devices, users, displays, and platforms <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b23">24]</ref>. Previous work has found that a DUI framework should support a number of relationships between its component UI elements, including: 1:1, 1:few, few:few, and many:many <ref type="bibr" target="#b23">[24]</ref>.</p><p>Many existing DUI solutions utilize model-based or schemabased approaches, which have the advantage of being independent of language and platform <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b23">24]</ref>. However, software implementations of these solutions commonly rely on platform-specific native code <ref type="bibr" target="#b0">[1]</ref> or require per-element markup tags to categorize UI division <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>. This makes the tools heavyweight, and time-consuming for developers.</p><p>We believe that with the current level of device ownership, the time is ripe for a simple, cross-platform DUI framework to gain traction where others failed to achieve wide adoption. The growing popularity and cross-platform support of web and hybrid applications <ref type="bibr" target="#b31">[32]</ref> make HTML5 the ideal choice for our framework, Panelrama. Panelrama allows developers to easily create DUIs by making modest modifications to existing tools, rather than formalizing new standards. We observed that, partially due to HTML's document object model, UI elements are commonly arranged in logical groups that should remain together (e.g., the playback controls of video player, or the contents of a menu). We thus provide a new XML element, panel, which may be placed around such groupings of controls. Panelrama facilitates the distribution and synchronization of panels among the connected devices. Once decomposed as a set of panels, an application is next further modified to specify state information which should be synchronized across devices; for example: the position of the scrubber thumb in the playback controls should be synchronized to the playback position of the video control. Panelrama provides mechanisms to automate synchronization of state, as well as the ability for developers to customize how synchronizations should be handled.</p><p>A challenge in DUI framework design is to determine the distribution of the UI across devices. Even in single-user applications, the number of possible combinations of devices can be prohibitive for hand-design of panel arrangements. For example, keeping with our video player application, a developer may want their application to support tablets, smartphones, televisions, public displays, laptops, and desktop computers. A priori designing the allocation of each panel to 2 6 -1=63 possible combinations of devices is prohibitive. It becomes overwhelming when considering how to handle each new connection.</p><p>To address this, Panelrama recognizes that the constituent elements of a given panel may make it more or less suitable for a given device (e.g. a video stream may be more suitable to a television than a mobile phone). Thus, in addition to splitting the interface, our framework lets developers to specify the suitability of panels to different types of devices, given the context of their application behavior. This allows our optimization algorithm to distribute panels to devices that maximize their match for the developer's intent; as devices are added or disconnected, panels are automatically reallocated according to our optimization scheme.</p><p>In the following sections, we present related work, and then describe Panelrama in greater detail, including the concept of panels, its architecture, as well as details on the automatic panel allocation. We then demonstrate how Panelrama can be utilized to support a multitude of multi-device application scenarios through three sample applications: a map browser, a video browser, and a PDF reader. Finally, we validate our claims on Panelrama's features and ease of use through a developer study with experienced industry participants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>Significant efforts have been expended in the HCI community in the design of interfaces for multi-device applications. While we draw inspiration from this work, we have not focused on innovation in this area. We thus refer the reader to <ref type="bibr" target="#b6">[7]</ref> for a thorough survey, and focus our related work on efforts to enable distributed user interfaces.</p><p>Past projects have attempted to provide frameworks to support these sorts of applications. One of the early examples of a DUI framework is Multibrowsing <ref type="bibr" target="#b18">[19]</ref>, allowing users to move web pages between displays. Other works such as WinCuts <ref type="bibr" target="#b28">[29]</ref> allows users to distribute sub-regions of window contents to another device. However, the functionality in these early projects are limited, since they do not provide methods for state synchronization and resource modelling, which are answered in more recent works such as Shared Substance <ref type="bibr" target="#b13">[14]</ref>, VIGO <ref type="bibr" target="#b19">[20]</ref>, XICE <ref type="bibr" target="#b0">[1]</ref>, and works by Melchior et al <ref type="bibr" target="#b20">[21]</ref>. However, this comes at the cost of changes in existing applications as developers modify their applications to support new models: data-oriented paradigm for Shared Substance, the new architecture introduced with VIGO, and heavy use of native code by XICE and Melchior.</p><p>Non-native web frameworks such as WebSplitter <ref type="bibr" target="#b15">[16]</ref>, ondemand UI migration <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>, and automatic partitioning <ref type="bibr" target="#b25">[26]</ref> enhance HTML to offer cross-platform DUI, similar to Panelrama. Among these only WebSplitter attempts low-cost migration. However, WebSplitter only synchronizes a single global state for the entire application, making it more difficult for developers to make applications that could scale with any number of devices, or have each device selectively synchronize states for private interactions. It also takes a binary treatment of device characteristics in terms of whether a device possesses certain hardware, making it unsuitable for differentiating devices with different characteristics that perform the same function (e.g. hard vs. soft keyboard).</p><p>More importantly, in all aforementioned projects, the burden of UI distribution falls to the user. Ideally, a DUI framework should give the users the flexibility of adjusting the interface components but not require them to spend excess time on the adjustments <ref type="bibr" target="#b17">[18]</ref>. Unfortunately, with existing solutions, if the number and variation of devices increases or should the application become more complex, the user can quickly become overwhelmed, resulting in a sub-optimal user experience.</p><p>To reduce this burden on the user, one approach is to automate the UI distribution for an optimal experience. For a DUI framework, this automation exists in two forms: 1) assigning UI elements to best-fit devices, and 2) once assigned, optimize UI appearance for the assigned device. Existing works such as SUPPLE <ref type="bibr" target="#b10">[11]</ref> and other adaptive interfaces <ref type="bibr" target="#b2">[3]</ref> focus on the latter -UI retargeting, by generating UI elements suited to the device on which they are located. Often the new interface is produced through a constrained optimization algorithm. Panelrama does not attempt to replicate these existing solutions, but instead tackles the first problem of assigning UI to devices. Currently we rely on existing HTML5 tools to adapt the contents of a panel to the device it is located on, but we recognize that tools like SUPPLE are superior alternatives for possible future implementations. Instead, currently we draw inspiration from these works in developing our automatic panel distribution mechanism.</p><p>From these existing approaches, we determine that while current distributed UI frameworks are powerful and allow for a degree of control, at the same time they necessitate sweeping changes to existing applications. Existing crossplatform web DUI frameworks do an inadequate job of characterizing devices and state synchronization. Finally, nearly all existing frameworks require users to manually specify UI distribution, which becomes overwhelming for complex applications. We developed Panelrama to answer these shortcomings, providing flexible state synchronization, automatic UI distribution, and a simple cross-platform developer experience.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ARCHITECTURE &amp; DEVELOPER EXPERIENCE</head><p>We built Panelrama to allow the building of applications in HTML5, enabling truly cross-platform distribution of interfaces. It provides three main features for developers: easy division of UI into panels, panel state synchronization across multiple devices, and automatic distribution of panels to best-fit devices. A guiding principle was to avoid significant changes to traditional application development, ensuring that experienced developers would quickly become facile with Panelrama, and that porting of existing applications would be straightforward. In contrast to earlier works, Panelrama is object-oriented and does not require developers to re-learn and rewrite applications in new paradigms. Instead, Panelrama is designed to use existing technology and facilitate code reuse. To convert an existing application to use Panelrama, a developer needs only to: Post-migration, the application gains multi-device support while retaining existing functionality, allowing it to function identically on a single device as it did prior to the conversion. This frees developers from the need to maintain codebases for both single-device and multi-device versions of the application, since the multi-device version can be trivially made single-device by disabling the panel distribution.</p><p>We now describe the development experience of Panelrama, as well as the high level architecture of the framework enabling its function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Panel Creation &amp; Shared State Information</head><p>The code assets for defining a panel are divided into three categories: HTML/CSS, JavaScript, and a Panelramaspecific panel definition. This design makes it convenient for developers to port existing applications to take advantage of Panelrama, since pre-existing assets in HTML/CSS and JavaScript can be reused with only minor changes.</p><p>To define a new type of panel, the developer wraps groups of existing HTML within "panel" tags. Since the id and class properties of the HTML elements are unaltered, this also allows developers to reuse existing JavaScript code that refer to these HTML elements. HTML hierarchy also allows the developer to choose the granularity of UI distribution in Panelrama at any DOM level. This HTML-based division is similar to DOM segmentation, an automatic segmentation algorithm for webpage partition, explored by Romero and Berger <ref type="bibr" target="#b25">[26]</ref>. In contrast, Panelrama provides full control to the developer in the allocation of UI components to panels. An example of a divided HTML page is shown in Figure <ref type="figure" target="#fig_3">2</ref>.</p><p>After dividing the HTML into templates, the developer creates a short Panelrama-specific panel definition by programmatically extending Panelrama's default panel object. A complete definition includes naming the new panel type, setting default state information for new panels of this type, and setting this type of panel's allocation weight for different device characteristics (e.g., Figure <ref type="figure" target="#fig_2">3</ref>).</p><p>The panel's state information represents the portions of the application's model mapped to the panel's view. This enables Panelrama to update the HTML view of panels to reflect any change in the state information of the overarching crossdevice application model. Each state variable contains both its value and a boolean flag indicating whether the variable is to be synchronized with the global state. This provides a built-in solution for synchronizing panel states between devices and is explained in greater detail in the next section.</p><p>By defining a new panel type through extending the default panel object, the panel gains access to Panelrama's built-in panel allocation functions, these include: With the business logic's state information now encapsulated in a shared panel instead of stored in the local device, it is necessary to modify the Javascript business logic to access the panel states. Additionally, Javascript code dependent on the DOM elements and event listeners need to be relocated under the rendered event of the parent panel, similar to a HTML Body onload event, as seen in Figure <ref type="figure" target="#fig_5">4</ref>.  A key to enabling applications to easily span devices is to provide a mechanism to distribute the global state of the application. In Panelrama, the state information of individual panels is defined in the panel definition shown in Figure <ref type="figure" target="#fig_2">3</ref>.</p><p>A Panelrama session includes a list of all connected devices and a list of all available panels. Each device is assigned a certain number of panels, we refer to these panels as local panels. Additionally, for every type of panel, we create a shared global panel that is not assigned to any device. The developer is given the freedom to choose which state variables a given local panel should sync with the global version using the sync flag (see Figure <ref type="figure" target="#fig_2">3</ref>). When a panel's state variable is synchronized, any updates to that state automatically change the associated global state (and vice versa), while an unsynchronized state variable does not propagate its changes to the global panel, nor does it receive updates when the global panel is changed. Developers have the flexibility to change the sync value at runtime to determine when and how state variables are synchronized.</p><p>This solution provides developers the ability to adopt multidevice interaction techniques immediately. For example, a developer of a map application may choose to sync the location of a map panel but not its displayed layers (satellite vs. map view). When a user runs this application on two tablets, scrolling one of the maps will cause the other to scroll, keeping the same area in view. Similarly, changing the sync value on runtime allows developers to build a slide presenter app where audience members may "unsync" with the presenter and preview future slides, while being able to resume with following the presenter by "resyncing".</p><p>Developers are also free to sync certain variables ondemand. Panelrama provides three methods: An example application making use of this feature is a video player application. For the best experience, a synchronized video panel is shown on the largest screen (e.g., a TV) for group viewing, but uses private unsynchronized video panels to preview videos on tablets or phones. The developer can provide a 'show on TV' button which acts only to initiate a push synchronization to the global state, which immediately causes the TV to show the video seen on the tablet. The developer could also elect to sync the 'location' field of the tablet and TV videos, allowing the tablet to act as a remote control, or, if so desired, block such control except from a 'master' remote by setting the "sync" flag for one device only, if the application was intended for use in a curated entertainment experience.</p><formula xml:id="formula_0">//</formula><p>The behavior of the merge synchronization is based on application logic. For instance, in a multi-user calendar application, a developer might use merge to produce a shared calendar showing common available times for all users. This is done by overriding merge in the base class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Panelrama Architecture</head><p>Panelrama achieves state synchronization through a clientserver architecture. The frontend reactivity of Panelrama is made possible through HTML templating technologies. The HTML contents of a panel are wrapped up in individual templates, which are rendered on-demand in the user's browser. In our implementation of Panelrama, we utilized the Handlebars <ref type="bibr" target="#b16">[17]</ref> templating framework, although this could be replaced with any other templating framework, including the new HTML5 template tag as it becomes standardized.</p><p>The backend system of Panelrama uses a MongoDB <ref type="bibr" target="#b21">[22]</ref> server to synchronize the panel state. WebSocket technology is used for propagating updates from the server to the clients whenever the state information in a panel changes. An example of the interactions is shown in Figure <ref type="figure" target="#fig_4">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Connection Handling</head><p>While it is normal for web application developers to manage user accounts, we found early-on that it would be useful for Panelrama to provide a utility to facilitate connecting new devices in order to save the user from having to manually enter a URL and log-in to a web application. We thus included a utility that may be called at any time to generate a QR code on the screen of a device. Application developers may use this utility to share a URL encoding a unique ID, which is captured with another device's camera. Once connected, an application may then take advantage of our automatic panel distribution functionality to distribute the UI across connected devices.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Framework Limitations</head><p>Using existing web technologies is one of Panelrama's strengths; however, using them also imposes constraints on the framework. Panelrama's use of templating allows a web application to be split down to individual HTML elements. However, it is unable to split an application further without developer input. For instance, Panelrama does not natively support splitting a single video stream element into three vertical slices to be played on three devices. Achieving this would require the developer to split the video manually, whether by dividing up the video data or hiding the other slices from view.</p><p>In order to simplify the developer experience, Panelrama uses a flat panel hierarchy. This covers most common cases and offers developers a single, intuitive division of existing UI. This hierarchy makes the application distribution easily testable using a small test suite for most common devices.</p><p>Simultaneously, this means a loss of flexibility for advanced users, since nested panels are not supported. This becomes a problem in applications where it makes sense for UI to be combined in some cases and separate in others, such as with color palettes that stick together when devices are few, but split apart when there are many. The trade-off lies in the developer's test suite complexity, which increases quickly with each additional nested layer. We decided against implementing nesting for the initial version of Panelrama, but recognize it as an important addition for future versions.</p><p>Finally, migration of an existing application to Panelrama can be made more difficult when the application is tightly coupled between the model and the view. If scripts in one panel references elements in a different panel, the developer needs to manually change the script so that this is no longer the case. However, this difficulty is not unique to Panelrama, existing frameworks which rely on UI division would also suffer from the same issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AUTOMATIC PANEL DISTRIBUTION</head><p>In addition to synchronizing states between panels, Panelrama enables developers to automatically distribute panels to best-fit devices, in effect, automatically annexing the most suitable device for a given panel <ref type="bibr" target="#b24">[25]</ref>. Our optimizer relies on two pieces of information. First, various device characteristics, such as the screen size or presence of a touch sensor. Second, a score from the developer on the relative importance of each device characteristic to the usability of a panel, which we term panel affinity score. For example, in a video application, the size of the screen has a bigger impact on the usability of a video stream panel than of a playback control panel. Therefore a developer would assign a higher value to the screen size affinity score on the former panel compared to the latter. Affinity scores are ranked on a standard scale with a minimum score of 0 and a maximum score decided by the developer.</p><p>Similar to the approach used in SUPPLE <ref type="bibr" target="#b9">[10]</ref> to adapt singledevice interfaces, we cast our distribution algorithm as a linear optimization problem, intended to match the needs of panels to the capabilities of available devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Device and Panel Modeling</head><p>With the latest generation of computing devices, it becomes apparent that one cannot simply model devices by category or form factor. Devices such as the Microsoft Surface <ref type="bibr" target="#b27">[28]</ref> or Asus Fonepad <ref type="bibr" target="#b1">[2]</ref> combine characteristics from multiple device categories, and even devices within the same category tend to vary in capability. We designed Panelrama to abstract device characteristics away from existing categories for our panel distribution model. We model characteristics of a device D and affinity values of a panel P as tuples:</p><p>ùê∑ ‚â° (ùëÜ, ùê∂ ùëë ), ùëÉ ‚â° (ùê∂ ùëù )</p><p>where S is panel capacity of the device, and Cd represents the set of device-specific characteristics. A device may not be allocated panels exceeding the number specified by S. S is an abstraction of the capacity of the device resulting from a combination of resolution, pixel density, physical screen size, and panel UI size. Since currently it is not possible to correctly detect physical size or pixel density of a device, S is currently hand-coded. Finally, a panel's Cp is a set identical in size to Cd, representing the panel's affinity values. This representation is similar to one used by Vandervelpen et al. <ref type="bibr" target="#b29">[30]</ref>, but several key differences become apparent in implementation.</p><p>In Panelrama, both Cd and Cp are represented as a set of integer scores ranked on a standardized scale determined by the developer. By default, Panelrama supports allocation based on four device characteristics: physical size, keyboard quality, touch quality, and mouse quality. A developer may choose to extend this list to include additional characteristics as needed, such as presence of GPS sensors or a 3G radio.</p><p>Ideally, a DUI framework should detect and assign the default Cd scores programmatically, while the application developer needs only to define panel Cp scores. However, the current web standard does not support query on certain characteristics, such as physical screen size or presence of a physical keyboard, but device description repositories like WURFL <ref type="bibr" target="#b30">[31]</ref> give us hope that soon such automatic scoring may be possible. At the moment, however, it is necessary for Cd scores in our sample application to be hand-coded. Our code for sample Cd and Cp scores can be seen in Figure <ref type="figure">6</ref>.  Whenever a panel or device is added or removed, Panelrama computes the optimization problem using the GNU Linear Programming Kit <ref type="bibr" target="#b14">[15]</ref> and updates the panel allocations on each device. Performance testing showed that optimal solutions were always found within 200ms for extreme examples of up to 50 panels distributed across 50 devices.</p><p>Naturally, there exist scenarios where users could find the automatic redistribution of panels disruptive. Each panel features a lock flag that when set, adds an additional constraint to the optimization problem to retain the panel on its current device. This flag may be exposed by the developer to the users through a toggled button.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimization Development Tool</head><p>In the ideal case, developers should need only assign the affinity values of panels based on the importance of each characteristic alone. However, some developers requested a tool to help them test their parameters. We therefore built a tool that allows developers to enter values and preview the results of the optimization in a GUI. This allows simulation of various device configurations for testing. The tool displays the current affinity values for each defined type of panel, as well as the cost matrix entry of the type of panel to each device connected to the application. Developers can make changes to the affinity scores within the tool, allowing them to preview the panel allocation results prior to assigning final affinity values in the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SAMPLE APPLICATIONS</head><p>In order to demonstrate the capabilities of Panelrama, we provide three sample applications developed using the framework: a distributed digital map, a video streaming application, and a PDF reader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distributed Map</head><p>The distributed map is intended, in part, as an exploration of user-initiated distribution of panels. In this application, the user is given full control over panel allocation and reassignment; our allocation algorithm is not used. The distributed map was developed using the Panelrama framework and the Google Maps API. The application's UI includes five panels: a map, a map navigation, a map layer, a street view, and a street view directional panels. The application's first function is to allow the user to navigate a digital roadmap. This is represented using a map panel containing the following states: the map's geographic coordinates, zoom level, and the type of map being displayed. When the user loads the application on a single device, it appears as a traditional mapping application, including controls for both navigating through the map and changing the current layer being displayed.</p><p>When the user connects a second device to the application, differences quickly come to light: each panel may be added, removed, or transferred to a different device. This enables users to move panels between devices, such as from a smartphone to a projector in order to give directions to a group. The panel can then be controlled remotely through the map navigation panel, or by keeping another instance of the map panel fully synchronized on the original device.  When multiple map panels are created on multiple devices, their state information can be synchronized in any combination to produce, for example: displays of different information on the same location, different locations at once, or different granularities. This example of Panelrama's state synchronization allows users to compare maps on multiple devices to gain access to different information, as seen in Figure <ref type="figure" target="#fig_8">7</ref>.</p><p>The map application's second functionality enabled by Panelrama is that of the panoramic street navigation, demonstrated in Figure <ref type="figure">8</ref>. By synchronizing the location of Google's street navigation service but allowing for an offset in view angle, users are able to use three devices to provide a 270 degree view of a street. This functionality is difficult to replicate on a single device and is a wonderful example of a potentially new interaction enabled by the synchronization behavior in Panelrama.</p><p>Panelrama may also be used to enable distribution of panels across other types of devices. Forlines and his colleagues demonstrated a modification of Google Earth that enabled a multi-touch table to control the location of cameras in 3D views on nearby vertical displays <ref type="bibr" target="#b8">[9]</ref>. We connected a Microsoft Surface -Samsung SUR40, 40" multi-touch table to our mapping application allowing us to recreate much of the experience offered by the application described by Forlines' et al, without having to write any additional code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Video Streaming Application</head><p>The second application was developed using Panelrama and the Google YouTube API. Our shared YouTube browser includes four panels: a video stream panel, a playback controls panel, a search panel, and a related videos panel.</p><p>The video panel holds state information such as the current playtime, the playback status (playing, paused, stopped), and the video's unique YouTube identifier. These states are controlled and changed by the three remaining panels. Panelrama's synchronization mechanism allows the distribution of a synchronized video panel to a television, and multiple users to interact with the global video panel using controls on personal phones or tablets. The user also has an option to add a personal video panel that is not synced to the group video, allowing the user to search for and preview videos without interrupting the group. When the user has selected an appropriate personal video, she may choose to use the video panel's "push" functionality to share the new video with the group.</p><p>The video streaming application is also designed to take advantage of Panelrama's automatic panel allocation feature.</p><p>As mentioned in the previous section, the developer defines how important each device characteristic is for a panel (e.g., physical size is important for a video panel, and ready to hand is important for playback controls), and Panelrama assigns panels dynamically to a user's devices as each device or panel is added or removed.</p><p>For instance, a user who begins with all panels on a desktop computer may have the video panel automatically distributed to a newly connected television, followed by playback controls to a connected smartphone, leaving only search functions on the desktop. When a tablet is connected, all the playback and search controls migrate to the tablet, minimizing the number of devices a user needs to reach to interact with the video on the television. An example interaction sequenced is shown in Figure <ref type="figure" target="#fig_10">11</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distributed PDF Reader</head><p>The third sample application is a distributed PDF reader, inspired by the multi-slate reading environment described by Chen et al. <ref type="bibr" target="#b3">[4]</ref>. Our application uses additional tablets to increase its screen real estate. It is unique from the previous two applications in that it takes advantage of all additional devices, while the other applications could only utilize as many devices as there are types of panels before duplicating functionality. This application's interface uses only one panel: the page panel. As each device is added, the new device is allocated a new instance of the panel, which is set to display the next page of the document. When any tablet scrolls to a new page, all synchronized tablets also scroll to the successive page.</p><p>The user may also lock any panel to a certain page. This allows the user to assign pages permanently to a panel for ease of reference, such as diagrams and reference lists. When a user chooses to lock a page to a tablet, the synchronized tablets displaying a successive page all scroll up by one to fill in the void left by the locked tablet. Figure <ref type="figure" target="#fig_13">12</ref> shows an interaction example. These sample applications have demonstrated the various functionalities of our toolkit. In particular, we have demonstrated how recent DUI user experience explorations may be implemented using the framework. To validate our belief Panelrama is easy to use, we conducted a study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEVELOPER STUDY</head><p>We conducted a study of Panelrama to evaluate its usability for developers. Specifically, we wanted to learn whether Panelrama's two features of synchronization and panel allocation are easy to use, and, in general, if Panelrama provides easy development of cross-device applications, with a focus on porting of existing applications. Finally, we wanted to solicit professional developer feedback on Panelrama, including opinions on the panel concept and its suitability for industry projects.</p><p>There exist several proposed methods for evaluating a development framework, including user studies <ref type="bibr" target="#b26">[27]</ref>, formal API reviews <ref type="bibr" target="#b7">[8]</ref>, and usability metrics such as the cognitive dimensions framework <ref type="bibr" target="#b4">[5]</ref>. The latter two methods tend to focus on usability issues that occur in larger frameworks, such as "learning style, penetrability, consistency, and role expressiveness" <ref type="bibr" target="#b7">[8]</ref>. Owing to the small size of Panelrama, where developers call upon only one class, these are less suitable. Consequently we decided to use the first methodthe user study, to evaluate our framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Participants</head><p>We recruited eight professional web developers between the ages of 21 and 33 each with 2 to 14 years of industry experience. As an indicator for frequency of adopting new tools, we asked participants to indicate the number of new API libraries / frameworks learned in the last year; their responses were: 1-3 tools: 4, 4-6: 2, 7-9: 2. Participants were paid $150 for a 2-hour session.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tasks</head><p>Participants were first asked to write a simple finger-painting application for a single device, without yet being introduced to Panelrama. This provided a common task for all developers and would allow them to work with their own application during the conversion process. Finger painting was chosen to have sufficient complexity to allow the developers to later experience all of the features of Panelrama yet simple enough to complete in the time allotted. Figure <ref type="figure" target="#fig_12">13</ref> is a participant's implementation.</p><p>Once complete, developers were then asked to alter their application so that it would split across devices, with the panel on the larger screen, and the palette on a screen that is touch-enabled. This provided developers the opportunity to work with Panelrama to divide their application into panels, as well as to work with property synchronization.</p><p>Once completed, they were asked to further subdivide the palette so that each color would present on a different device, if available, so that their application would then span up to four screens. This task forced developers to work with Panelrama's panel affinity and automatic allocation mechanisms to achieve the desired allocations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Procedure</head><p>Participants first completed a consent form and a pre-study questionnaire. They were then provided with instructions for completing the three tasks, and online documentation about the Panelrama framework for their reference. The documentation included sample code for a Youtube application implemented in Panelrama. In addition, participants were free to use the Internet to look up resources  for completing the first task. Finally, participants were permitted to ask clarifying questions regarding the task instructions and the Panelrama documentation.</p><p>We measured the time required for participants to finish each task. In addition, we took source code snapshots of the web application at the end of each of the three tasks. This allows us to determine the number of lines of code (LOC) that needed to be changed for the conversion, as well as the lines of code that developers could reuse. Upon completion of the three tasks, participants were given a post-study questionnaire, where they rated their impressions of Panelrama using a number of metrics</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantitative Results and Code Analysis</head><p>Quantitatively, developers on average took 83.4 minutes to complete all three tasks. Individually: Task 1: 30. All participants were able to complete the three tasks within the 2 hour time limit and correctly Panelrama. The quantitative results suggest that Panelrama strongly facilitates code reuse since more of the code was reused than added or modified. Due to the simplicity of the sample application, it is safe to assume that the ratio of reused to changed code would rise in a real-world scenario.</p><p>While most participants took longer to convert the application to Panelrama in Task 2 than to create the application in Task 1, Task 2 included participants learning the framework. During the study we observed that, after defining their first panel, participants defined subsequent ones much more quickly, and we would expect the time to continue to decrease as a project grows. The participants share our opinion, as indicated in their feedback in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Qualitative Developer Feedback</head><p>Developers were asked to provide feedback in the form of Likert-scale questions, as well as in oral discussion. In addition to a focus on usability of the framework, we asked the developers to professionally assess Panelrama for its suitability to the task of cross-device enabling their existing web applications. Developers were enthusiastic about using Panelrama for multi-device application building. They reported that Panelrama was easy to learn (median score of 4 on a 5-point Likert scale) and enabled easy conversion of existing applications (median = 4). They also believed that once learned, Panelrama would be easy to use in the future (median = 4.5).</p><p>Conceptually, participants indicated that they strongly preferred using panels over developing separate applications (or websites) for different devices (median = 5), and believed that automatic allocation of panels is a necessary feature (median = 5). In the hypothetical case that they were asked to develop a multi-device application, all participants were strongly in favor of choosing Panelrama for development (median = 5).</p><p>Developers did provide some critical feedback. The first participant (P1) commented that Panelrama's design "might have a hard time supporting use cases where developers want to split nested UI elements", a limitation that we plan to address in future. P2 raised concerns with each panel requiring three pieces of information, since it introduces three points of failure when the names might be misspelled. P3 and P6 were worried about excess boilerplate code since the three button panels were identical except in color choice and shared large chunks of code. To resolve this, P3 suggested allowing developers to define a generic panel that could be inherited. Lastly, P6 expressed concerns with the degree of abstraction of affinity scores in automatic allocation and suggested that a labeled scale or enumeration be used to identify them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DISCUSSION AND FUTURE WORK</head><p>Panelrama was designed to facilitate easy conversion of existing web applications to enable cross-device interaction, allowing users to leverage the many devices which surround them every day. Feedback from professional developers indicates we have largely hit the mark, and that they would be highly likely to use Panelrama given the goal of creating such an experience. Nonetheless, some issues remain which will be the focus of our ongoing development of the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adaptive UI and Device Identification</head><p>The current implementation of Panelrama is unable to take full advantage of its panel allocation properties due to the inability to detect device characteristics using existing software frameworks. As an improvement, we would like to explore formal specifications to provide developers with the complete list of a device's characteristics, such as physical size and sensor suites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multi-User and Security</head><p>At present, Panelrama does not provide an identity service to differentiate between devices belonging to different users. This allows developers to be flexible in selecting services of their choice (e.g. Facebook, Google ID) for the application without replication from Panelrama. In the future, we intend to explore multi-user applications with automatic user identification and identity-aware panel access privileges.</p><p>We also intend to improve Panelrama by tackling security concerns since the allocation of panels to potentially compromised systems poses a security risk <ref type="bibr" target="#b24">[25]</ref>. Our solution involves allowing developers to define content restrictions for public and private devices. Panels containing sensitive information would only remain on private devices or the sensitive content would be censored when moved to an untrusted device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Opportunistic Annexing and Dynamic Linking</head><p>More ambitiously, our long term goal for Panelrama is to provide the ability for opportunistic annexing of public devices. We will investigate hardware and software solutions to dynamically establish direct links between multiple devices to improve latency. We will also implement adaptive interface designs to not only allocate the ideal panels for a device, but also modify the panels to use UI elements considered most usable on the device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSION</head><p>In this paper, we presented Panelrama, an HTML5-based DUI framework. Through the combination of UI distribution, automatic panel allocation based on device characteristics, and support for developer extensibility, Panelrama provides a solution for allowing users to interact with a single application from multiple devices. We have also demonstrated three sample applications, a map browser, YouTube browser, and distributed electronic reader, which demonstrate the various functionalities of the Panelrama framework. We believe that HTML-based frameworks, which minimize the additions required for distribution of user interfaces, show great promise for the realization of DUIs as a viable interaction paradigm.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. A YouTube browser which automatically annexes connected devices using Panelrama. Application state is maintained on the server, and UI panels are automatically distributed to suitable devices.</figDesc><graphic coords="1,317.64,524.64,242.28,147.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Panel.createPanel(panel, destDeviceId) Panel.removePanel(panelId) &lt;panel instance&gt;.move(destDeviceId) &lt;panel instance&gt;.clone(destDeviceId) &lt;panel instance&gt;.getData(variableName) &lt;panel instance&gt;.setData(variableName, value)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. A panel definition of a video streaming panel.</figDesc><graphic coords="3,318.36,559.32,242.52,135.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Sample HTML templates of a video streaming application</figDesc><graphic coords="3,49.44,569.16,250.44,120.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Sequence diagram of state synchronization between global and local panels in a video streaming application.</figDesc><graphic coords="4,317.64,61.44,242.28,125.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Rendered event of a video streaming panel with event listener and panel state access.</figDesc><graphic coords="4,56.64,64.80,235.44,96.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>To calculate the cost function, we treat each Cd and Cp as a vector. For every combination of Cd and Cp, we calculate the dot product of the vectors as a usability score, which we use to populate a cost matrix. Given P panels and D devices, we get a cost matrix C of size D √ó P, where Cdp is the usability score of panel p on device d. For example, the usability score of a VideoPanel on the Tablet1 in Figure6computes to 20. These scores form the basis of the objective function used to solve the linear optimization problem of panel allocation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 .Equation 1 .</head><label>61</label><figDesc>Figure 6. Sample device characteristics for a connected tablet and panel affinity values for the video stream panel.</figDesc><graphic coords="5,317.28,625.44,242.28,66.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Different combinations of state synchronization between panels: (a) different information, (b) different locations, (c) different zoom levels.</figDesc><graphic coords="6,320.64,464.04,229.32,84.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 .Figure 9 .</head><label>89</label><figDesc>Figure 8. Panoramic street view across three tablets. Geo-location is synchronized between the devices, but direction is programmatically offset by 90 o .</figDesc><graphic coords="6,321.48,580.56,231.96,122.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Example of automatic panel distribution in our sample application. The handling of additional devices of the same type may be customized by the developer (eg: allow multiple search and related videos panels for additional users).</figDesc><graphic coords="7,93.24,531.36,436.32,163.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Multiple users using the YouTube application.</figDesc><graphic coords="7,314.76,63.96,237.60,148.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. An example of the application, pre-conversion, a participant developed in the first phase of the study. Bottom: color palette. Top: 'painted' canvas.</figDesc><graphic coords="8,353.52,516.96,167.16,164.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. The reader application displaying 4 pages of a paper. Top tablet locked with a helpful diagram, another, outside the frame, is locked to a reference list.</figDesc><graphic coords="8,71.04,58.32,213.00,85.56" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Peter Hamilton, Steven Sanders, Katie Barker for their ideas and support, the DGP Lab members for their advice, and the study participants for their kind feedback.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">XICE windowing toolkit: Seamless display annexation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Arthur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Olsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput.-Hum. Interact. ACM Press</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Asus</forename><surname>Fonepad</surname></persName>
		</author>
		<ptr target="http://www.asus.com/Tablets_Mobile/ASUS_Fonepad/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A unifying reference framework for multi-target UI</title>
		<author>
			<persName><forename type="first">G</forename><surname>Calvary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Interact. Comput</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="289" to="308" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Designing a multi-slate reading environment to support active reading activities</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Guimbretiere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sellen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. CHI</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Using the Cognitive Dimensions Framework to evaluate the usability of a class library</title>
		<author>
			<persName><forename type="first">S</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Becker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Joint Conf. EASE &amp; PPIG 2003</title>
		<meeting>Joint Conf. EASE &amp; PPIG 2003</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="359" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A reference model for distributed user interfaces</title>
		<author>
			<persName><forename type="first">A</forename><surname>Demeure</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Calvary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sottet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vanderdonkt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TAMODIA 2005</title>
		<meeting>TAMODIA 2005</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Distributed User Interfaces: State of the Art</title>
		<author>
			<persName><forename type="first">N</forename><surname>Elmqvist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DUI 2011</title>
		<meeting>DUI 2011</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">API usability peer reviews: a method for evaluating the usability of application programming interfaces</title>
		<author>
			<persName><forename type="first">U</forename><surname>Farooq</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="page" from="2327" to="2336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Multi-user, multidisplay interaction with a single-user, single-display geospatial application. UIST &apos;06</title>
		<author>
			<persName><forename type="first">C</forename><surname>Forlines</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Esenther</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="273" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Gajos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
		<title level="m">Preference elicitation for interface optimization. UIST &apos;05</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SUPPLE: automatically generating user interfaces</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gajos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IUI</title>
		<imprint>
			<biblScope unit="page" from="93" to="100" />
			<date type="published" when="2004">2004. 2004</date>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">On-demand cross-device interface components migration</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ghiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Patern√≤</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Santoro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="page" from="299" to="308" />
			<pubPlace>MobileHCI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Push and pull of web user interfaces in multi-device environments</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ghiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Patern√≤</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Santoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AVI 2012</title>
		<meeting>AVI 2012</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="10" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Shared substance: developing flexible multi-surface applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gjerlufsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 2011</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="3383" to="3392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><surname>Glpk</surname></persName>
		</author>
		<author>
			<persName><surname>Js</surname></persName>
		</author>
		<ptr target="http://hgourvest.github.com/glpk.js/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">WebSplitter: a unified XML framework for multi-device collaborative Web browsing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Perret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naghshineh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CSCW 2000</title>
		<meeting>CSCW 2000</meeting>
		<imprint>
			<biblScope unit="page" from="221" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><surname>Handlebars</surname></persName>
		</author>
		<author>
			<persName><surname>Js</surname></persName>
		</author>
		<ptr target="http://handlebarsjs.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">DIAMOND: A Framework for Dividing Interfaces Across Multiple Opportunistically Annexed Devices</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Hutchings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Pierce</surname></persName>
		</author>
		<idno>GIT-GVU-05-21</idno>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note type="report_type">GVU Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multibrowsing: Moving Web Content across Multiple Displays</title>
		<author>
			<persName><forename type="first">B</forename><surname>Johanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ponnekanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UbiComp</title>
		<meeting>UbiComp</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="346" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">VIGO: instrumental interaction in multi-surface environments</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Klokmose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Beaudouin-Lafon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI &apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="869" to="878" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Toolkit for Peer-to-Peer Distributed User Interfaces: Concepts, Implementation, and Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Melchior</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EICS 2009</title>
		<meeting>EICS 2009</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="69" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<ptr target="http://www.mongodb.org/" />
		<title level="m">MongoDB</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Tool support for designing nomadic applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Mori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Patern√≤</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Santoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IUI</title>
		<imprint>
			<biblScope unit="page" from="141" to="148" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A. Schema driven distributed user interface generation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pe√±alver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lazcorreta</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>INTERACCION 2012. Article 1, 8 pages</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mahaney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Abowd</surname></persName>
		</author>
		<idno>GIT-GVU-03-31</idno>
		<title level="m">Opportunistic Annexing for Handheld Devices: Opportunities and Challenges</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>GVU Tech</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Automatic Partitioning of Web Pages Using Clustering. Mobile HCI</title>
		<author>
			<persName><forename type="first">R</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3160</biblScope>
			<biblScope unit="page" from="388" to="393" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Case Study of API Redesign for Improved Usability</title>
		<author>
			<persName><forename type="first">J</forename><surname>Stylos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Graf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLHCC</title>
		<imprint>
			<biblScope unit="page" from="189" to="192" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="http://www.microsoft.com/surface/" />
		<title level="m">Surface by Microsoft</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">WinCuts: manipulating arbitrary window regions for more effective use of screen space. CHI EA &apos;04</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Tan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1525" to="1528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Light-Weight distributed web interfaces: preparing the web for heterogeneous environments</title>
		<author>
			<persName><forename type="first">C</forename><surname>Vandervelpen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vanderhulst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICWE</title>
		<imprint>
			<biblScope unit="page" from="197" to="202" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<ptr target="http://wurfl.sourceforge.net/" />
		<title level="m">WURFL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A comparative analysis of cross-platform development approaches for mobile applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Xanthopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Xinogalos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BCI</title>
		<imprint>
			<biblScope unit="volume">2013</biblScope>
			<biblScope unit="page" from="213" to="220" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
