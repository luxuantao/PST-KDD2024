<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Annals of Pure and Applied Logic</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-12-05">5 December 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Willem</forename><surname>Conradie</surname></persName>
							<email>wconradie@uj.ac.za</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics</orgName>
								<orgName type="institution">University of Johannesburg</orgName>
								<address>
									<country key="ZA">South Africa</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alessandra</forename><surname>Palmigiano</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">ILLC</orgName>
								<orgName type="institution" key="instit2">University of Amsterdam</orgName>
								<address>
									<country key="NL">Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<postCode>03B45 06D50 06D10 03G10</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Annals of Pure and Applied Logic</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-12-05">5 December 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">10EBEFBFC71F2EF2FD10779220DA6E16</idno>
					<idno type="DOI">10.1016/j.apal.2011.10.004</idno>
					<note type="submission">Received 13 September 2010 Received in revised form 9 September 2011 Accepted 20 October 2011</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Modal logic Sahlqvist correspondence Algorithmic correspondence Canonicity Distributive lattices</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We define the algorithm ALBA for the language of the same distributive modal logic (DML) for which a Sahlqvist theorem was proved by Gehrke, Nagahashi, and Venema. Successful executions of ALBA compute the local first-order correspondents of input DML inequalities, and also guarantee their canonicity. The class of inequalities on which ALBA is successful is strictly larger than the newly introduced class of inductive inequalities, which in its turn properly extends the Sahlqvist inequalities of Gehrke et al. Evidence is given to the effect that, as their name suggests, inductive inequalities are the distributive counterparts of the inductive formulas of Goranko and Vakarelov in the classical setting.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Sahlqvist theory: the model-theoretic setting. Sahlqvist theory is among the most celebrated and useful results of the classical theory of modal logic, and one of the hallmarks of its success. Traditionally developed in a model-theoretic setting (cf. <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b25">26]</ref>), it provides an algorithmic, syntactic identification of a class of modal formulas whose associated normal modal logics are strongly complete with respect to elementary (i.e. first-order definable) classes of frames. The whole theory consists of two parts: canonicity and correspondence. The canonicity 1 of a modal formula ϕ (or equivalently of the corresponding identity ϕ ≈ ⊤) guarantees the strong completeness of K ϕ (i.e. the minimal normal modal logic containing ϕ) w.r.t. the class F(ϕ) of frames defined by ϕ. The fact that ϕ corresponds to a first-order formula α (i.e. that for every frame F , F ϕ iff F α) guarantees that F(ϕ) is elementary. Sahlqvist theory only provides sufficient but not necessary conditions for canonicity and correspondence of modal formulas. In fact, it was shown <ref type="bibr" target="#b2">[3]</ref> that the class of elementary modal formulas is undecidable, so any class of elementary formulas described in purely syntactic terms can only be an approximation. Over the years the 'Sahlqvist class' has been generalized and extended in various ways, including extensions within the basic modal language like those to the inductive <ref type="bibr" target="#b17">[18]</ref> and complex <ref type="bibr" target="#b24">[25]</ref> classes, generalizations to extended modal languages such as hybrid logic <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b4">5]</ref>, and generalizations of the correspondence language to e.g. first-order logic with least fix-points <ref type="bibr" target="#b27">[28]</ref>. 'Algorithmic approaches' include the SQEMA algorithm introduced in <ref type="bibr" target="#b5">[6]</ref>, which properly covers all the inductive formulas.</p><p>Sahlqvist theory: the algebraic setting. Parallel to this line of investigation, Sahlqvist theory has also been developed in the algebraic setting of canonical extensions. This was recognized to be useful both for simplifying proofs of existing results <ref type="bibr" target="#b18">[19]</ref> and for uniformly extending the theory itself from Boolean to distributive lattice-based logics <ref type="bibr" target="#b13">[14]</ref>. Recent developments in the theory of canonical extensions <ref type="bibr" target="#b9">[10]</ref> have made available many aspects and benefits of the theory of relational semantics for modal logics -including Sahlqvist theory -even to logics whose associated classes of algebras are based on lattices that do not need to be distributive, such as substructural logics <ref type="bibr" target="#b22">[23]</ref>. As observed already in <ref type="bibr" target="#b13">[14]</ref>, the algebraic approach has the advantage of being modular in nature. This modular quality makes it possible, for instance, to prove canonicity independently of correspondence (as is done, e.g., in <ref type="bibr" target="#b14">[15]</ref>) and to explain the syntactic identification of the Sahlqvist fragment in terms of favourable interaction between certain order-theoretic properties of the logical connectives/algebraic operations. Interestingly, the order-theoretic properties that underlie the characterization of the Sahlqvist class remain inherently unchanged when moving from the classical to more general settings.</p><p>Our contribution. In this paper, we define the algorithm ALBA for the language of the same distributive modal logic (DML) for which a Sahlqvist theorem was proved in <ref type="bibr" target="#b13">[14]</ref>. Successful executions of ALBA compute the local first-order correspondents of input DML inequalities, which are then shown to be canonical. Both in its design and in its performances, ALBA can be regarded as the distributive counterpart of SQEMA: indeed ALBA's core consists of two mutually dual versions of the Ackermann lemma. The class of inequalities on which ALBA is successful is strictly larger than the class of inductive inequalities, which we also define in this paper. In its turn, this class is strictly larger than the Sahlqvist inequalities of <ref type="bibr" target="#b13">[14]</ref>, and evidence is given to the effect that, as their name suggests, inductive inequalities are the distributive counterparts of inductive formulas in the classical setting <ref type="bibr" target="#b5">[6]</ref>.</p><p>The methodology. Our background framework is the dual equivalence between posets and perfect distributive lattices (cf. Subsection 2.4), expanded so as to account for additional (modal) operations on the lattice side. This duality makes it possible to present our algorithmic correspondence treatment in purely algebraic terms: for instance the proof of correctness of ALBA is set in the complex algebras rather than in the frames.</p><p>The structure of the paper. In Section 2, we recall syntax, 2.1, and algebraic and frame semantics of distributive modal logic, 2.2, both discrete and topological, 2.3; we recall the notion of perfect distributive modal algebras (DMA's) as the algebraic duals of the frames for DML, 2.4, define the expanded language of perfect DMA's, 2.5, and state the necessary facts for the development of correspondence. In Section 3, we introduce the inductive inequalities, 3.1, recall the notion of Sahlqvist inequalities, 3.2, show that inductive inequalities both project to the inductive formulas of <ref type="bibr" target="#b17">[18]</ref> and semantically extend the Sahlqvist inequalities, 3.3, and discuss the extensions of these classes to different signatures, 3.4. Section 3 does not contain preliminaries, so the reader only interested in the algorithm can skip it. In Section 4 we state and prove the left and right Ackermann's lemmas for distributive modal logic. In Section 5 we give an informal presentation of how ALBA works, by carrying out the reduction of an example. Then in Section 6 we proceed to give a formal description of ALBA. Section 7 presents examples of successful applications of ALBA to Sahlqvist, inductive and non-inductive inequalities. In Section 8, we prove the correctness of ALBA, i.e. we show that whenever the reduction is successful, the output first-order formula locally corresponds on DML frames to the input DML inequality. In Section 9, we give a uniform proof that every DML inequality on which ALBA succeeds is canonical. In Section 10, we prove that ALBA succeeds on inductive inequalities. This, together with the results in Sections 8 and 3, immediately implies that the Sahlqvist inequalities admit local correspondents, which improves the correspondence result of <ref type="bibr" target="#b13">[14]</ref>. Finally, the Appendix collects some of the technical facts on which the proof of canonicity is based.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Distributive modal logic: the general framework</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Syntax and axioms</head><p>Distributive modal logic (DML for short) was introduced in <ref type="bibr" target="#b13">[14]</ref> as a basic modal formalism, closely related with e.g. Dunn's positive modal logic <ref type="bibr" target="#b8">[9]</ref>. DML adds four unary modalities ✸, ✷, ✁, ✄ to the propositional language of distributive lattices. The intuitive meanings of ✸ϕ, ✷ϕ, ✁ϕ and ✄ϕ respectively are: 'ϕ is possible, is necessary, might not be the case, is impossible'. All of the four modalities can classically be syntactically defined in terms of just one of them (for instance, ✷ϕ ≡ ¬✸¬ϕ, ✁ϕ ≡ ✸¬ϕ, ✄ϕ ≡ ¬✸ϕ), but because of the absence of negation, this is no longer possible in the distributive setting, so the four of them have to be taken as primitive. And for the sake of generality, they will be semantically interpreted using four (different) accessibility relations. (The semantics will be given formally in the next subsection.)</p><p>Let PROP be a denumerably infinite set of propositional variables. The elements of PROP will be denoted with letters, p, q, r, possibly indexed. The formulas of L term are given by the following recursive definition:</p><formula xml:id="formula_0">ϕ ::= ⊥ | ⊤ | p ∈ PROP | ϕ ∨ ψ | ϕ ∧ ψ | ✸ϕ | ✷ϕ | ✁ϕ | ✄ϕ.</formula><p>Typically, lattice-based logics of this kind are not expressive enough to allow an implication-like term to be defined out of the primitive connectives. Therefore, the entailment relation cannot be recovered from the set of tautologies, and so the deducibility has to be defined in terms of sequents. This motivates the following:</p><p>Definition 2.1 (cf. <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">Def. 2.1]</ref>). A distributive modal logic Λ is a set of sequents ϕ ⇒ ψ with ϕ, ψ ∈ L term , which contains the following sequents:</p><p>p ⇒ p ⊥ ⇒ p p ⇒ ⊤ p ⇒ p ∨ q q ⇒ p ∨ q p ∧ q ⇒ p p ∧ q ⇒ q p ∧ (q ∨ r) ⇒ (p ∧ q) ∨ (p ∧ r)</p><formula xml:id="formula_1">✸(p ∨ q) ⇒ ✸p ∨ ✸q ✸⊥ ⇒ ⊥ ✷p ∧ ✷q ⇒ ✷(p ∧ q) ⊤ ⇒ ✷⊤ ✁(p ∧ q) ⇒ ✁p ∨ ✁q ✁⊤ ⇒ ⊥ ✄p ∧ ✄q ⇒ ✄(p ∨ q) ⊤ ⇒ ✄⊥</formula><p>and is closed under the following inference rules:</p><formula xml:id="formula_2">ϕ ⇒ δ δ ⇒ ψ ϕ ⇒ ψ ϕ ⇒ ψ ϕ(δ/p) ⇒ ψ(δ/p) δ ⇒ ϕ δ ⇒ ψ δ ⇒ ϕ ∧ ψ ϕ ⇒ δ ψ ⇒ δ ϕ ∨ ψ ⇒ δ ϕ ⇒ ψ ✸ϕ ⇒ ✸ψ ϕ ⇒ ψ ✷ϕ ⇒ ✷ψ ϕ ⇒ ψ ✁ψ ⇒ ✁ϕ ϕ ⇒ ψ ✄ψ ⇒ ✄ϕ.</formula><p>Recall that a quasi-identity is an expression of the form (ϕ</p><formula xml:id="formula_3">1 = ψ 1 &amp; • • • &amp; ϕ n = ψ n ) ⇒ ϕ = ψ,</formula><p>where the ϕ's and ψ's are terms. We will find it convenient to work with quasi-inequalities, i.e. expressions of the form (ϕ</p><formula xml:id="formula_4">1 ≤ ψ 1 &amp; • • • &amp; ϕ n ≤ ψ n ) ⇒ ϕ ≤ ψ,</formula><p>where the ϕ's and ψ's are terms from L term . Of course, quasi-inequalities can be equivalently rewritten as quasi-identities, by replacing e.g. ϕ ≤ ψ with ϕ ∧ ψ = ϕ. The sets of quasi-inequalities built from L term -inequalities will be L quasi .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">DM-algebras, DML frames, their complex algebras, and prime filter frames</head><p>Definition 2.2. A distributive modal algebra (DMA) (cf. [14, Def. 2.9]) is an algebra A = (A, ∨, ∧, ⊥, ⊤, ✸, ✷, ✁, ✄) such that (A, ∨, ∧, ⊥, ⊤) is a bounded distributive lattice and the additional operations satisfy the following identities:</p><formula xml:id="formula_5">✸(x ∨ y) = ✸x ∨ ✸y ✸⊥ = ⊥ ✷x ∧ ✷y = ✷(x ∧ y) ⊤ = ✷⊤ ✁(x ∧ y) = ✁x ∨ ✁y ✁⊤ = ⊥ ✄x ∧ ✄y = ✄(x ∨ y) ⊤ = ✄⊥.</formula><p>The main difference between the distributive and the Boolean setting is that there are not enough ultrafilters to guarantee that every proper filter of a distributive lattice is the intersection of all the ultrafilters extending it. However, every proper filter of a distributive lattice is the intersection of all the prime filters extending it. This makes it possible to extend classical constructions and results, like the Stone duality, to this setting. In particular, analogously to the case for the ultrafilter frame of a BAO, every DMA A can be associated with its prime filter frame, whose points will be the prime filters of A. Unlike the case for ultrafilters, which always form an antichain by definition, the inclusion ordering between prime filters is non-trivial, and needs to be recorded in the associated frame. This explains why DML frames are based on posets, rather than on sets.</p><p>Given a poset (W , ≤), we will use the notation P ↑ (W ) for the set of all up-sets 2 of (W , ≤). Definition 2.3 (DML Frame). A DML frame (cf. <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">Def. 2.4]</ref>) is a structure</p><formula xml:id="formula_6">F = (W , ≤, R ✸ , R ✷ , R ✁ , R ✄ ) such that (W , ≤) is a nonempty poset, R ✸ , R ✷ , R ✁ , R ✄ are binary relations on W and ≥ • R ✸ • ≥ ⊆ R ✸ ≤ • R ✄ • ≥ ⊆ R ✄ ≤ • R ✷ • ≤ ⊆ R ✷ ≥ • R ✁ • ≤ ⊆ R ✁ .</formula><p>A model based on a DML frame F is a pair M = (F , V ), where V is a persistent valuation on F , i.e., a map V : PROP → P ↑ (W ), assigning an up-set to every propositional variable. Given a model M = (F , V ) based on a DML frame F = (W , ≤, R ✸ , R ✷ , R ✁ , R ✄ ), and a state w ∈ W , the semantics of our language L term is formally given by M, w ⊥, never M, w ⊤, always M, w p, iff w ∈ V (p) M, w ϕ ∨ ψ, iff M, w ϕ or M, w ψ M, w ϕ ∧ ψ, iff M, w ϕ and M, w ψ M, w ✸ϕ iff ∃v(wR</p><formula xml:id="formula_7">✸ v &amp; M, v ϕ) M, w ✷ϕ iff ∀v(wR ✷ v ⇒ M, v ϕ) M, w ✁ϕ iff ∃v(wR ✁ v &amp; M, v ̸ ϕ) M, w ✄ϕ iff ∀v(wR ✄ v ⇒ M, v ̸ ϕ).</formula><p>2 For every poset (W , ≤), a subset X ⊆ W is an up-set (resp. down-set) if for all x, y ∈ W , if X ∋ x ≤ y (resp. X ∋ x ≥ y), then y ∈ X .</p><p>As usual, a formula ϕ is true on a model (denoted as M ϕ) if M, w ϕ for every state w ∈ M; ϕ is valid at a state w in the frame F (denoted as F , w ϕ) if (F , V ), w ϕ for every persistent valuation V on F ; ϕ is valid on F if it is valid at every state in F .</p><p>Two formulas are semantically equivalent if they are true at the same states in models. They are said to be (locally) frame equivalent if the are valid on the same (states in) frames.</p><p>For every model M and every ϕ ∈ L term , <ref type="bibr">[[ϕ]</ref>] denotes as usual the set of states at which ϕ is satisfied. Definition 2.4 (Complex Algebra of a DML Frame). For every DML frame F = (W , ≤, R ✸ , R ✷ , R ✁ , R ✄ ), the complex algebra of F (cf. <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">Sec. 2.3]</ref>) is</p><formula xml:id="formula_8">F + = (P ↑ (W ), ∪, ∩, ∅, W , ⟨R ✸ ⟩, [R ✷ ], ⟨R ✁ ], [R ✄ ⟩), where, for every X ⊆ W , [R ✷ ]X := {w ∈ W | R ✷ [w] ⊆ X } = (R -1 ✷ [X c ]) c ⟨R ✸ ⟩X := {w ∈ W | R ✸ [w] ∩ X ̸ = ∅} = R -1 ✸ [X] [R ✄ ⟩X := {w ∈ W | R ✄ [w] ⊆ X c } = (R -1 ✄ [X]) c ⟨R ✁ ]X := {w ∈ W | R ✁ [w] ∩ X c ̸ = ∅} = R -1 ✁ [X c</formula><p>]. Here (•) c denotes the complement relative to W , while R[x] = {w | w ∈ W and xRw} and R -1  [x] = {w | w ∈ W and wRx}.</p><formula xml:id="formula_9">Moreover, R[X ] =  {R[x] | x ∈ X } and R -1 [X] =  {R -1 [x] | x ∈ X }.</formula><p>For each ⊙ ∈ {✸, ✷, ✁, ✄}, let (R ⊙ ) be the corresponding operation on subsets of W as defined above. The conditions determining the interaction between ≤ and R ⊙ guarantee that (R ⊙ ) is well defined on P ↑ (W ), i.e., that, when applied to an up-set, (R ⊙ ) produces an up-set. <ref type="foot" target="#foot_0">3</ref> Moreover, it is easy to see that (R ⊙ )[[ϕ]] = [[⊙ϕ]] for every ϕ ∈ L term and for every model M. Hence, valuations V : PROP → P ↑ (W ) can be identified with homomorphisms from the term algebra L term into the complex algebra F + . We leave it to the reader to verify: Proposition 2.5. For every DML frame F , F + is a DMA. Definition 2.6. For every DMA A, the prime filter frame of A is</p><formula xml:id="formula_10">A • = (Pr(A), ⊆, R ✸ , R ✷ , R ✁ , R ✄ ),</formula><p>where (Pr(A), ⊆) is the poset of prime filters of A, and for every P, Q ∈ Pr(A),</p><formula xml:id="formula_11">PR ✸ Q iff Q ⊆ ✸ -1 [P] PR ✷ Q iff ✷ -1 [P] ⊆ Q PR ✁ Q iff Q c ⊆ ✁ -1 [P] PR ✄ Q iff ✄ -1 [P] ⊆ Q c .</formula><p>With this definition, it is straightforward to verify that Proposition 2.7. For every DMA A, A • is a DML frame.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Descriptive general frames</head><p>Just like in the classical case, DML frames can be topologized so as to yield a category that can be shown to be dually equivalent to the category of DMA's and their homomorphisms. Just in the same way as the duality between BAO's and descriptive general frames is based on the Stone duality for Boolean algebras, the duality for DMA can be based on the Priestley duality between bounded distributive lattices and Priestley spaces (which are defined in the Appendix). We are not going to report on this duality, which is a slight generalization of the duality for positive modal logic given in <ref type="bibr" target="#b1">[2]</ref>, here; but we will need the following:</p><formula xml:id="formula_12">Definition 2.8. A descriptive general frame is a structure G = (W , ≤, R ✸ , R ✷ , R ✁ , R ✄ , τ ) such that its underlying frame G ♯ = (W , ≤, R ✸ , R ✷ , R ✁ , R ✄ ) is a DML</formula><p>frame, and moreover: DG1. The structure X G = (W , ≤, τ ) is a Priestley space (see the Appendix), i.e., it is a compact and totally orderdisconnected ordered topological space. DG2. For every ⊙ ∈ {✷, ✸, ✄, ✁} and every</p><formula xml:id="formula_13">x ∈ W , R ⊙ [x] is τ -closed. DG3. If A is the collection of the clopen up-sets of X G , then A = (A, ∪, ∩, ∅, W , ⟨R ✸ ⟩, [R ✷ ], ⟨R ✁ ], [R ✄ ⟩) is a subalgebra of G + ♯ .</formula><p>A is the algebra of admissible sets of G. An admissible valuation on G is a valuation V : PROP → A sending propositional variables to admissible sets.</p><p>We will sometimes refer to descriptive general frames as descriptive frames.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Perfect algebras and their correspondence with frames</head><p>In the Boolean setting, the complex algebras of Kripke frames are characterized in purely algebraic terms as perfect BAO's, whose Boolean reducts are complete atomic Boolean algebras. Perfect BAO's are dually equivalent to Kripke frames: in particular, their correspondence on objects is defined in one direction by associating a Kripke frame with its complex algebra, and conversely by associating a perfect BAO A with its atom structure, i.e. a Kripke frame whose states are the atoms of A. These facts can all be extended to the DML setting: the complex algebras of DML frames are abstractly characterized as perfect DMA's. Before introducing them we need some preliminary definitions.</p><p>For every complete lattice C, an element c ∈ C \ {⊥} is completely join-irreducible iff c =  S implies c ∈ S for every S ⊆ C; moreover, c is completely join-prime if, for every S ⊆ C, if c ≤  S, then c ≤ s for some s ∈ S. If c is completely join-prime, then c is completely join-irreducible, and if C is frame distributive (i.e. finite meets distribute over arbitrary joins in each coordinate) then the completely join-irreducible elements are completely join-prime. The collection of completely join-irreducible elements of C is denoted by J ∞ (C). The completely meet-irreducible/prime elements are defined order dually, and the set that they form is M ∞ (C).</p><p>Definition 2.9.</p><formula xml:id="formula_14">A complete lattice C is perfect (cf. [10, Def. 2.9]) if J ∞ (C) is join-dense in C and M ∞ (C) is meet-dense in C, i.e. if for every u ∈ C, u =  {r ∈ J ∞ (C) | r ≤ u} and u =  {z ∈ M ∞ (C) | u ≤ z}.</formula><p>A perfect distributive lattice is a perfect lattice that is also completely distributive (i.e. arbitrary meets distribute over arbitrary joins). Perfect distributive lattices are also characterized (cf. [14, Def. 2.14]) as those lattices that are isomorphic to the lattice P ↑ (X) for some poset X . A useful fact about any perfect distributive lattice C is that the map κ :</p><formula xml:id="formula_15">J ∞ (C) → M ∞ (C) defined by j  →  {u ∈ C | j ̸ ≤ u} is an order isomorphism (cf. [14, Sec. 2.3]), when considering J ∞ (C) and M ∞ (C) as subposets of C. The inverse of κ is λ : M ∞ (C) → J ∞ (C), given by the assignment m  →  {u ∈ C | u ̸ ≤ m}.</formula><p>From the definitions of κ and λ it immediately follows that for every u ∈ C, every j ∈ J ∞ (C) and every m ∈ M ∞ (C),</p><formula xml:id="formula_16">j ̸ ≤ u iff u ≤ κ(j). (1) u ̸ ≤ m iff λ(m) ≤ u.</formula><p>(2) Definition 2.10 (Perfect DMA). (cf. [14, Def. 2.20]) A DMA A is perfect if its lattice reduct is a perfect distributive lattice and for every S ⊆ A,</p><formula xml:id="formula_17">✸(  S) =  {✸s | s ∈ S} ✷(  S) =  {✷s | s ∈ S} ✁(  S) =  {✁s | s ∈ S} ✄(  S) =  {✄s | s ∈ S}.</formula><p>It can be easily verified that Proposition 2.11. For every DML frame F , F + is a perfect DMA.</p><p>The main difference between perfect DL's and perfect BA's is that, in general, the atoms of a perfect DL form a proper subset of its completely join-prime elements and, moreover, there are generally not enough atoms to join-generate the perfect DL. However, the definition of the atom structure of a perfect BAO can be extended to any perfect DMA C by basing the frame on the poset (J ∞ (C), ≥), where ≥ is the converse of the order that J ∞ (C) inherits from C. This definition restricts naturally to the familiar definition in the Boolean setting: indeed, unlike the case for atoms, which always form an antichain by definition, the lattice ordering between completely join-prime elements is non-trivial, and needs to be recorded in the associated frame.</p><p>Definition 2.12 (cf. Atom Structures in <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">Sec. 2.3]</ref>). For every perfect DMA C, its associated prime structure is the following frame:</p><formula xml:id="formula_18">C + = (J ∞ (C), ≥, R ✸ , R ✷ , R ✁ , R ✄ )</formula><p>, where (J ∞ (C), ≥) is the dualized subposet of the completely join-prime elements of C, and for every i, j ∈ J ∞ (C), </p><formula xml:id="formula_19">jR ✸ i iff j ≤ ✸i jR ✷ i iff ✷κ(i) ≤ κ(j) jR ✁ i iff j ≤ ✁κ(i) jR ✄ i iff ✄i ≤ κ(j). Let us verify that C + is indeed a DML frame. If j ≥ C + j ′ R ✸ i ′ ≥ C + i, then, in C,</formula><formula xml:id="formula_20">(C + ) + ∼ = C and (F + ) + ∼ = F .</formula><p>The proposition above states that the same correspondence holds between perfect DMA's and DML frames as between perfect BAO's and Kripke frames. We will be able to prove our correspondence result in the setting of perfect DMA's, precisely because of this strong relationship with DML frames.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">The expanded language of perfect DMA's</head><p>A crucial role for algebraic correspondence will be played by an expansion of the language of DML. This expansion is meant to capture two aspects of the enhanced algebraic environment provided by perfect DMA's, that will be described in what follows.</p><p>The first aspect. It is well known (cf. <ref type="bibr" target="#b12">[13]</ref>) that, for any complete lattice C, an n-ary map s : C n → C is completely joinpreserving in its ith coordinate iff it has a right adjoint in that same coordinate, i.e. iff there exists a map t :</p><formula xml:id="formula_21">C n → C such that, for all u 1 , . . . , u n , v ∈ C, s(u 1 , . . . , u i , . . . , u n ) ≤ v iff u i ≤ t(u 1 , . . . , v, . . . , u n ).</formula><p>Order-dually, t : C n → C is completely meet-preserving in its ith coordinate iff it has a left adjoint in that coordinate, i.e. iff there exists a map s : C n → C such that the clause above is satisfied for all u 1 , . . . , u n , v ∈ C. Moreover, if s and t form an adjoint pair in their ith coordinate, then s is order-preserving in its jth coordinate iff t is order-reversing in that same coordinate, for every j ̸ = i.</p><p>Since any perfect DMA is a complete lattice, and, by definition, each operation of a perfect DMA (including ∧ and ∨) is either completely join-or meet-preserving or join-or meet-reversing in each coordinate <ref type="foot" target="#foot_1">4</ref> (see the second table below), then each operation of a perfect DMA has a coordinatewise adjoint, or residual, introduced in the table below. <ref type="foot" target="#foot_2">5</ref> Each operation in the lower row is the (coordinatewise) adjoint of the corresponding operation in the upper row:</p><formula xml:id="formula_22">∧ ∨ ✸ ✷ ✁ ✄ → -</formula><p>The choice of notation for each new operation is by no means a random one: → being the right residual of ∧ andbeing the left residual of ∨ respectively mean that for every u, v, w ∈ C,</p><formula xml:id="formula_23">u ∧ v ≤ w iff u ≤ v → w and u -v ≤ w iff u ≤ v ∨ w.</formula><p>Hence, → is the Heyting implication, -is the Heyting implication of the dual lattice C ∂ , and every perfect distributive lattice is the lattice reduct of a complete (bi-)Heyting algebra. Moreover, one member of an adjoint pair completely determines the other: for instance for every u, v ∈ C,</p><formula xml:id="formula_24">u → v =  {w : u ∧ w ≤ v} u -v =  {w : u ≤ v ∨ w}</formula><p>, so in a powerset algebra, the operationis then the relative complementation. As for the remaining operations, for every</p><formula xml:id="formula_25">u, v ∈ C, ✸u ≤ v iff u ≤ v u ≤ ✷v iff u ≤ v ✁u ≤ v iff v ≤ u u ≤ ✄v iff v ≤ u,</formula><p>and hence, the right adjoint of ✸ is completely meet-preserving, i.e. it is a 'box', the right adjoint of ✁ turns meets into joins, i.e. it is a 'left triangle', and so on. Summing up:</p><p>Complete operators</p><formula xml:id="formula_26">∧ : C × C → C ✸ : C → C ✁ : C ∂ → C Right adjoints →: C ∂ × C → C : C → C : C → C ∂ Complete dual operators ∨ : C × C → C ✷ : C → C ✄ : C ∂ → C Left adjoints -: C × C ∂ → C : C → C : C → C ∂ The second aspect.</formula><p>In a perfect DMA C, the poset J ∞ (C) plays the same crucial role as the set of atoms in a perfect BAO: its elements join-generate C and form the set of states of the associated prime structure C + . Order dually, M ∞ (C) meetgenerates C and its elements can be thought of as the co-states of C + . In the distributive setting that we are in, bringing the completely meet-prime elements explicitly into the account is not essential, for, as we remarked earlier, M ∞ (C) is orderisomorphic to J ∞ (C); however their presence makes the treatment of correspondence much smoother, and allows for a more natural generalization to the setting of non-distributive lattices, where their role is essential.</p><p>The expanded language of perfect DMA's will include the connectives corresponding to all the adjoint operations, as well as a denumerably infinite set of sorted variables NOM called nominals, ranging over the completely join-prime elements of perfect DMA's, and a denumerably infinite set of sorted variables CO-NOM, called co-nominals, <ref type="foot" target="#foot_3">6</ref> ranging over the completely meet-prime elements of perfect DMA's. The elements of NOM will be denoted with i, j, possibly indexed, and those of CO-NOM with m, n, possibly indexed. Let us introduce the expanded language formally: Definition 2.14. The formulas of L + term are given by the following recursive definition:</p><formula xml:id="formula_27">ϕ ::= ⊥ | ⊤ | p | j | m | ϕ ∨ ψ | ϕ ∧ ψ | ϕ -ψ | ϕ → ψ | ✸ϕ | ✷ϕ | ✁ϕ | ✄ϕ | ϕ | ϕ | ϕ | ϕ,</formula><p>where p ∈ PROP, j ∈ NOM and m ∈ CO-NOM.</p><p>Like we did for L term , we can form inequalities and quasi-inequalities based on L + term . The symbols L + and L + quasi respectively denote the set of inequalities between terms in L + term , and the set of quasi-inequalities formed out of L + . Members of L + , L + quasi , and L term not containing any propositional variables (but possibly containing nominals and conominals) will be called pure.</p><p>Summing up, we will be working with six sets of syntactic objects, as reported in the following table : 

Base language Expanded Language Formulas / terms</p><formula xml:id="formula_28">L term L + term Inequalities L L + Quasi-inequalities L quasi L + quasi 2.5.1.</formula><p>Frame semantics for the expanded language Adjoint pairs of modal operators are best known to modal logicians from tense logic: indeed the well-known tense axioms</p><formula xml:id="formula_29">ϕ → ✷ F ✸ P ϕ ✸ P ✷ F ϕ → ϕ ϕ → ✷ P ✸ F ϕ ✸ F ✷ P ϕ → ϕ</formula><p>imply that in every tense BAO (A, ✸ F , ✷ F , ✸ P , ✷ P ), the forward-looking diamond ✸ F is the left adjoint of the backwardlooking box ✷ P and the forward-looking box ✷ F is the right adjoint of the backward-looking diamond ✸ P . On the frame side, the adjointness relationship between modal operators is captured by the fact that their respective accessibility relations are converses of one another:</p><formula xml:id="formula_30">R ✷ P = (R ✸ F ) -1 R ✷ F = (R ✸ P ) -1 .</formula><p>This is exactly what happens in the setting of perfect DMA's and their associated prime structures: indeed, every • ∈ { , , , } dually corresponds to a binary relation R • on J ∞ (C), each of which is defined analogously to the way in which the relations corresponding to the 'white' operations were introduced in Definition 2.12: for instance, jR i iff κ(i) ≤ κ(j), and so on.</p><p>Proposition 2.15. For every perfect DMA C,</p><formula xml:id="formula_31">R = (R ✷ ) -1 R = (R ✸ ) -1 R = (R ✁ ) -1 R = (R ✄ ) -1 .</formula><p>Proof. 1. Using (1), we get</p><formula xml:id="formula_32">jR ✷ i ⇔ ✷κ(i) ≤ κ(j) ⇔ j ̸ ≤ ✷κ(i) ⇔ j ̸ ≤ κ(i) ⇔ i ≤ j ⇔ iR j.</formula><p>The remaining identities can be proved in a similar way.</p><p>A valuation for L + term on a DML frame F is any map V from the set PROP ∪ NOM ∪ CNOM of propositional variables, nominals, and co-nominals into the set P ↑ (W ) of the up-sets of (W , ≤), such that V (p) ∈ P ↑ (W ) for each p ∈ PROP, V (i) = x↑ for some x ∈ W for each i ∈ NOM, and, for each m ∈ CNOM, it is the case that</p><formula xml:id="formula_33">V (m) = (x↓) c = κ(x↑) for some x ∈ W . A model for L + is a tuple M = (F , V</formula><p>) such that F is a DML frame and V is a valuation for L + . For any such model, the satisfaction relation for formulas in L + is recursively defined as follows (here we report only the new connectives):</p><formula xml:id="formula_34">M, w i iff V (i) = w↑ M, w m iff V (m) = (w↓) c M, w ϕ iff ∃v(vR ✷ w &amp; M, v ϕ) M, w ϕ iff ∀v(vR ✸ w ⇒ M, v ϕ) M, w ϕ iff ∃v(vR ✁ w &amp; M, v ̸ ϕ) M, w ϕ iff ∀v(vR ✄ w ⇒ M, v ̸ ϕ), M, w ϕ → ψ iff ∀v[(w ≤ v &amp; M, v ϕ) ⇒ M, v ψ], M, w ϕ -ψ iff ∃v[v ≤ w &amp; M, v ϕ &amp; M, v ̸ ψ].</formula><p>The local satisfaction relation extends to L + and L + quasi as follows:</p><formula xml:id="formula_35">M, w ϕ ≤ ψ iff if M, w ϕ then M, w ψ, M, w (&amp; n i=1 ϕ i ≤ ψ i ) ⇒ ϕ ≤ ψ iff if M, w ϕ i ≤ ψ i for i = 1, . . . , n then M, w ϕ ≤ ψ.</formula><p>From the clauses above, the global satisfaction relation for L + and L + quasi is defined in the usual way, by universally quantifying over w.</p><p>For every model M and every ϕ ∈ L + term , <ref type="bibr">[[ϕ]</ref>] denotes as usual the set of states at which ϕ is satisfied. It is easy to see that</p><formula xml:id="formula_36">[[ϕ → ψ]] = (([[ϕ]] ∩ [[ψ]] c )↓) c [[ϕ -ψ]] = ([[ϕ]] ∩ [[ψ]] c</formula><p>)↑, and moreover, for each ⊙ ∈ {✸, ✷, ✁, ✄, , , , }, denoting by (R ⊙ ) the corresponding operation on subsets of W defined as in Definition 2.4, we get (R ⊙ )[[ϕ]] = <ref type="bibr">[[⊙ϕ]</ref>]. Hence, a valuation V for L + term can be identified with a homomorphism (or just an assignment) V + from the term algebra L + term into the complex algebra F + expanded with the adjoints, such</p><formula xml:id="formula_37">that V + [NOM] ⊆ J ∞ (F + ) and V + [CNOM] ⊆ M ∞ (F + ).</formula><p>Conversely, an assignment v on a perfect DMA C can be identified with a valuation v + on the prime structure</p><formula xml:id="formula_38">C + such that v + (x) is the ≤ C + -up-set {j ∈ J ∞ | j ≤ v(x)}, for all x ∈ PROP ∪ NOM ∪ CNOM.</formula><p>There are two equivalent ways in which the local satisfaction of formulas can be encoded as a special case of the global satisfaction of inequalities, as reported in the following proposition: Proposition 2.16. For every perfect DMA C, every DML frame F , every L + term -valuation V on F and L + term -assignment v on C, and every ϕ ∈ L + term , 1. the following are equivalent:</p><formula xml:id="formula_39">(a) F , V , w ϕ; (b) F + , V ′+ |= j ≤ ϕ, where j is a new nominal not occurring in ϕ and V ′ is the j-variant of V such that V ′ (j) = {w}↑; (c) F + , V ′+ ̸ |= ϕ ≤ m, where m is a new co-nominal not occurring in ϕ and V ′ is the m-variant of V such that V ′ (m) = ({w}↓) c . 2. C, v |= j ≤ ϕ iff C + , v + , v(j) |= ϕ. 3. C, v |= ϕ ≤ m iff C + , v + , λ(v(m)) ̸ |= ϕ.</formula><p>Admissible valuations for the expanded language. Let G be a descriptive general frame. An admissible valuation for L + term on G is a valuation for L + term on the underlying DML frame G ♯ (see Definition 2.8), such that V (p) ∈ A for each p ∈ PROP. In other words, thinking of V as a triple of maps into the complex algebra G + ♯ , V sends propositional variables to elements of the subalgebra A, while nominals and co-nominals get sent to join-prime and meet-prime elements of G + ♯ , respectively.</p><p>For any formula ϕ ∈ L + term and valuation V , we write ϕ(V ) to denote the extension of ϕ in G under the valuation V . Note that if ϕ is in the basic signature and V is admissible, it follows from the closure conditions (DG3) on A that ϕ(V ) ∈ A.</p><p>This, however, is not the case for formulas from the expanded signature or for non-admissible valuations. Suppose p is a propositional variable occurring in ϕ and V a valuation. For X ∈ P ↑ (W ), let V [p := X ] be the valuation which is identical to V except that it sends p to X . Then ϕ(V [p := X ]) can be seen as defining an operation from P ↑ (W ) into P ↑ (W ), which we will denote as ϕ V p (X).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2.">Standard translation</head><p>Let L 1 be the first-order language with equality with binary relation symbols ≤, R ✸ , R ✷ , R ✁ , R ✄ , and unary predicate symbols P, Q , . . . corresponding to the propositional variables p, q, . . . ∈ PROP. As usual, we let L 1 contain a denumerable infinity of individual variables. We will further assume that L 1 contains denumerably infinite individual variables i, j, . . . corresponding to the nominals i, j, . . . ∈ NOM and n, m, . . . corresponding to the co-nominals n, m ∈ CO-NOM. Let L 0 be the sublanguage which does not contain the unary predicate symbols P, Q , . . . corresponding to the propositional variables.</p><p>Let us now define the standard translation of L + term into L 1 recursively:</p><formula xml:id="formula_40">ST x (⊥) := x ̸ = x ST x (⊤) := x = x ST x (p) := P(x) ST x (j) := j ≤ x ST x (m) := x m ST x (ϕ ∨ ψ) := ST x (ϕ) ∨ ST x (ψ) ST x (ϕ ∧ ψ) := ST x (ϕ) ∧ ST x (ψ) ST x (ϕ -ψ) := ∃y(ST y (ϕ) ∧ ¬ST y (ψ) ∧ y ≤ x) ST x (ϕ → ψ) := ∀y((ST y (ϕ) ∧ ¬ST y (ψ)) → x y) ST x (✸ϕ) := ∃y(R ✸ xy ∧ ST y (ϕ)) ST x (✷ϕ) := ∀y(R ✷ xy → ST y (ϕ)) ST x (✁ϕ) := ∃y(R ✁ xy ∧ ¬ST y (ϕ)) ST x (✄ϕ) := ∀y(R ✄ xy → ¬ST y (ϕ)) ST x ( ϕ) := ∃y(R ✷ yx ∧ ST y (ϕ)) ST x ( ϕ) := ∀y(R ✸ yx → ST y (ϕ)) ST x ( ϕ) := ∃y(R ✁ yx ∧ ¬ST y (ϕ)) ST x ( ϕ) := ∀y(R ✄ yx → ¬ST y (ϕ)).</formula><p>ST x extends to L + and L + quasi as follows: for inequalities, ST x (ϕ ≤ ψ) := ST x (ϕ) → ST x (ψ), and for quasi-inequalities,</p><formula xml:id="formula_41">ST x (ϕ 1 ≤ ψ 1 &amp; • • • &amp; ϕ n ≤ ψ n ⇒ ϕ ≤ ψ) := [ST x (ϕ 1 ≤ ψ 1 ) ∧ • • • ∧ ST x (ϕ n ≤ ψ n )] → ST x (ϕ ≤ ψ).</formula><p>We also extend ST x to finite sets of inequalities by setting ST x ({ϕ</p><formula xml:id="formula_42">1 ≤ ψ 1 , . . . , ϕ n ≤ ψ n }) equal to  1≤i≤n ST x (ϕ i ≤ ψ i ).</formula><p>Observe that if ST x is applied to pure terms, inequalities, or quasi-inequalities (recall Definition 2.14), it produces formulas in the sublanguage L 0 . This will be most important for our purposes. The following lemma is proved by a routine induction.  </p><formula xml:id="formula_43">+ ∨ + ✸ + ✁ - ∧ - ✷ - ✄ + ✷ + ✄ - ✸ - ✁</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Inductive inequalities</head><p>In this section, we will introduce the distributive modal logic analogue of the inductive formulas of Goranko and Vakarelov <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref>. This class, consisting of inequalities which we will call the inductive inequalities, extends the class of Sahlqvist inequalities of <ref type="bibr" target="#b13">[14]</ref> in the same way as the inductive formulas extend the Sahlqvist formulas. This extension is proper, in the sense that there are properties of states in frames definable by inductive inequalities and not definable by any Sahlqvist inequality (more of this in Subsubsection 3.3.4). We will not give a direct proof that all inductive inequalities are elementary and canonical, but this will follow later as corollaries from the facts that they are all reducible by the ALBA algorithm and that all inequalities so reducible are elementary and canonical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Inductive inequalities: definition and examples</head><p>We begin by introducing the following auxiliary definitions and notation: exactly like in <ref type="bibr" target="#b13">[14]</ref>, the two signed generation trees associated with any s ∈ L term are denoted as +s and -s respectively and are obtained by assigning signs (+ and -) to the nodes of the generation tree of s, as follows:</p><p>• the root node of +s (resp. -s) is the root node of the generation tree of s, signed with + (resp. -); • if a node is ∨, ∧, ✸, ✷, then assign the same sign to its immediate successors;</p><p>• if a node is ✁, ✄, then assign the opposite sign to its immediate successor.</p><p>It will sometimes be convenient to think of the label of a node in a signed generation tree as including the sign, and sometimes as not including the sign. This slight ambiguity will cause no problems in practice. We will use ≺ to indicate the 'signed subtree' relation.</p><p>In a signed generation tree of a term, we will regard certain types of node as universal nodes and others as choice nodes. This classification is exactly the same as in <ref type="bibr" target="#b13">[14]</ref>, and is given in Table <ref type="table" target="#tab_2">1</ref>. Note that choice and universal are disjoint, but not exhaustive categories, since +∧ and -∨ are neither choice nor universal.</p><p>An order type over n ∈ N is an n-tuple ϵ ∈ {1, ∂} n . For every order type ϵ, let ϵ ∂ be its opposite order type, i.e., for every i = 1, . . . , n, ϵ ∂ i = 1 iff ϵ i = ∂. For any term s(p 1 , . . . , p n ), any order type ϵ over n, and any i = 1, . . . , n, an ϵ-critical node in the signed generation tree of s is a (leaf) node +p i with ϵ i = 1, or -p i with ϵ i = ∂. An ϵ-critical branch in the tree is a branch terminating in an ϵ-critical node. The intuition, which will be built upon later, is that variable occurrences corresponding to ϵ-critical nodes are to be solved for, according to ϵ.</p><p>For every term s(p 1 , . . . , p n ), and every order type ϵ, we say that +s (resp. -s) agrees with ϵ, and write ϵ(+s) (resp. ϵ(-s)), if every leaf in the signed generation tree of +s (resp. -s) is ϵ-critical. In other words, ϵ(+s) (resp. ϵ(-s)) means that all variable occurrences corresponding to leaves of +s (resp. -s) are to be solved for according to ϵ. Definition 3.1. Given an order type ϵ, and an irreflexive and transitive relation Ω on the variables p 1 , . . . , p n , the (negative or positive) generation tree * s, * ∈ {-, +}, of a term s(p 1 , . . . , p n ) is (Ω, ϵ)-inductive if, on every ϵ-critical branch with leaf labelled p i , for 1 ≤ i ≤ n, every choice node c with a universal node as ancestor is binary, and hence labelled with ⋆(α • β), where ⋆ ∈ {+, -}, and moreover:</p><p>1. ϵ ∂ (⋆α), and 2. p j &lt; Ω p i for every p j occurring in α.</p><p>Clearly, the conditions above imply that the ϵ-critical branch runs through β. We will refer to Ω as the dependency order on the variables. An inequality s ≤ t is (Ω, ϵ)-inductive if the trees +s and -t are both (Ω, ϵ)-inductive. An inequality s ≤ t is inductive if it is (Ω, ϵ)-inductive for some Ω and ϵ. 1. The node c can be either +∨ or -∧, and hence, the corresponding subtree of * s rooted at c is either +(α ∨β) or -(α ∧β).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">An earlier version of the definition was modelled more closely on the Gehrke et al. definition of Sahlqvist inequalities</head><p>in <ref type="bibr" target="#b13">[14]</ref>, and made use of the notion of left and right inductive terms. Since we will occasionally find it useful to think in terms of these notions, we include the formulation here: Given Ω and ϵ, a term s(p 1 , . . . , p n ) is (Ω, ϵ)-left inductive (resp. (Ω, ϵ)-right inductive) if in the positive (resp., negative) generation tree of s, on every ϵ-critical branch with leaf labelled p i , 1 ≤ i ≤ n, every choice node with a universal node as ancestor satisfies either (a) it is labelled with +∨, and the corresponding subtree of +s (resp. -s) rooted at this node is +(α∨β), with p i occurring in β, ϵ ∂ (+α), and p j &lt; Ω p i for every p j occurring in α, or (b) it is labelled with -∧, and the corresponding subtree of +s (resp. -s) rooted at this node is -(α∧β), with p i occurring in β, ϵ ∂ (-α), and p j &lt; Ω p i for every p j occurring in α. It should be clear that an inequality s ≤ t is then (Ω, ϵ)-inductive precisely when s is (Ω, ϵ)-left inductive and t is (Ω, ϵ)-right inductive.</p><p>3. In its current form, Definition 3.1 is a reformulation of the earlier definition, inspired by van Gool's version of that definition given in <ref type="bibr" target="#b28">[29]</ref>.</p><p>4. Note that no unary choice node on a critical path in an (Ω, ϵ)-inductive term can have a universal ancestor.</p><p>Example 3.3. The inequality ✷(✸q ∨ p) ∧ ✁✷p ≤ ✷✸q is (Ω, ϵ)-inductive for q &lt; Ω p, ϵ p = 1 and ϵ q = ∂. It is also (Ω ′ , ϵ ′ )-inductive for q &lt; Ω p, ϵ p = ∂ and ϵ q = ∂.</p><p>The inequality ✷(✁q ∨ p) ∧ ✷q ≤ ✸(p ∧ q) is (Ω, ϵ)-inductive with q &lt; Ω p, ϵ p = 1 and ϵ q = 1. Note that it is not (Ω, ϵ)-inductive for any ϵ and Ω such that p &lt; Ω q.</p><p>Next, the inequality ✷✁(q ∧ r) ∧ ✷(p ∨ ✷q) ≤ ✁✷(p ∧ r) ∨ ✸p is (Ω, ϵ)-inductive with p &lt; Ω q &lt; Ω r, and ϵ p = ∂, ϵ q = ϵ r = 1.</p><p>Example 3.4. The inequality ✷(✁✄(q ∨ p) ∧ ✄(p ∧ q)) ≤ ✸✷p is not inductive. Indeed, in the positive generation tree of the left-hand side there is a leaf +p from which, going up to the root, one meets a -✄-node (unary choice) before one meets a +✷-node (universal). Also, in the negative generation tree of the right-hand side, there is a -✷-node (unary choice) before a -✸-node (universal) on the path up from the leaf -p. It follows that, no matter whether an order type ϵ assigns 1 or ∂ to p, either condition 1 or condition 2 of Definition 3.1 will be violated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">The special subclass of Sahlqvist inequalities</head><p>Definition 3.5 (cf. <ref type="bibr" target="#b13">[14]</ref>). Given an order type ϵ ∈ ({1, ∂}) n , the signed generation tree * s, * ∈ {-, +}, of a term s(p 1 , . . . , p n ) is ϵ-Sahlqvist if on no ϵ-critical branch is there a choice node with a universal node as ancestor. An inequality s ≤ t is ϵ-Sahlqvist if both the trees +s and -t are ϵ-Sahlqvist. An inequality s ≤ t is Sahlqvist if it is ϵ-Sahlqvist for some order type ϵ.</p><p>In keeping with the terminology of <ref type="bibr" target="#b13">[14]</ref>, a term S will be called ϵ-left Sahlqvist if +s is ϵ-Sahlqvist, and ϵ-right Sahlqvist if -s is ϵ-Sahlqvist.</p><p>Clearly, these Sahlqvist inequalities are special inductive inequalities, since Sahlqvist inequalities exclude every occurrence of choice nodes in the scope of universal nodes along critical paths in the signed generation trees, whereas inductive formulas allow such occurrences under certain conditions. Specifically, if s ≤ t is an ϵ-Sahlqvist inequality, then it is an (Ω, ϵ)-inductive inequality for every irreflexive transitive relation Ω on its variables (and hence in particular, also for the empty one). The exact relationship between the Sahlqvist and inductive inequalities will be further explored in the ensuing subsections.</p><p>In <ref type="bibr" target="#b13">[14]</ref>, Sahlqvist inequalities are shown to be elementary and canonical. Their being elementary is shown by reducing the Sahlqvist inequalities to classical Sahlqvist-van Benthem formulas via Gödel translation. It is also argued that the Sahlqvist inequalities project onto the Sahlqvist-van Benthem formulas, in the classical case.</p><p>Example 3.6. The inequality s(p, q) ≤ t(p, q) := ✸(p ∧ ✷q ∧ ✄q) ≤ ✷(✁p ∨ ✷q) is Sahlqvist. Indeed, notice that in both the generation trees +s and -t, no choice node occurs in the scope of a universal node, so this inequality is ϵ-Sahlqvist for every order type ϵ ∈ {1, ∂} 2 .</p><p>The inequality</p><formula xml:id="formula_44">✷(✸p ∧ ✄✸p ∧ ✁(⊤ ∨ q)) ≤ ✸(p ∨ ✁q) is (∂, 1)-Sahlqvist,</formula><p>and not ϵ-Sahlqvist for any other order type ϵ ∈ {1, ∂} 2 .</p><p>Lastly, the inequality ✷(✁q ∨ p) ∧ ✷q ≤ ✸(p ∧ q) from Example 3.3 is not Sahlqvist, since in the positive generation tree of the left-hand side there is an occurrence of +p in the scope of a choice node which is in the scope of a universal node, and similarly for -p on the right-hand side. Hence, this inequality cannot be ϵ-Sahlqvist for any order type ϵ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Comparison with the classical inductive formulas</head><p>In this subsection we are going to compare the inductive and Sahlqvist inequalities with the inductive and Sahlqvistvan Benthem formulas, respectively. To facilitate this comparison we need two things: firstly, a more suitable equivalent reformulation of the definition of the inductive formulas. This is given in Subsection 3.3.1, where the normalized inductive formulas are introduced. Secondly, we have to peg out the common ground upon which the comparison is to take place (Subsection 3.3.2). This will be the class of classical DML frames, i.e., those DML frames which are essentially Kripke frames, and hence, upon which both the basic modal language (hereafter denoted as ML) and L are interpretable and expressively equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">Inductive formulas and normalized inductive formulas</head><p>We begin by recalling the definition of the inductive formulas. Note however, that what we will here call inductive formulas are actually the monadic inductive formulas, namely the projection of the full class of inductive formulas, defined for polyadic multi-modal languages, onto ML. Definition 3.7 <ref type="bibr">([18]</ref>). Let ♯ be a symbol not belonging to ML. Then a box-form of ♯ in ML is defined recursively as follows:</p><formula xml:id="formula_45">1. ♯ is a box-form of ♯. 2. If B(♯) is a box-form of ♯, then ✷B(♯) is a box-form of ♯. 3. If B(♯) is a box-form of ♯, and A is a positive formula, then A → B(♯) is a box-form of ♯.</formula><p>Thus, box-forms of ♯ are, up to semantic equivalence, of the type</p><formula xml:id="formula_46">A 0 → ✷(A 1 → • • • ✷(A n → #) • • • ).</formula><p>By substituting a propositional variable p for ♯ in a box-form B(♯), we obtain a box-formula of p, namely B(p). The last occurrence of the variable p is the head of B(p), and every other occurrence of a variable in B(p) is called inessential there.</p><p>A regular formula is any ML-formula built up from ⊤, ⊥, positive formulas and negated box-formulas, by applying conjunctions, disjunctions and boxes.</p><p>The</p><formula xml:id="formula_47">dependency digraph of a set of box-formulas B = {B 1 (p 1 ), . . . , B n (p n )} is a digraph G B = ⟨V , E⟩, where V = {p 1 , . . . , p n</formula><p>} is the set of heads in B, and edge set E, such that p i Ep j iff p i occurs as an inessential variable in some boxformula B(p j ) ∈ B. A digraph is acyclic if it does not contain oriented cycles (including loops). The dependency digraph of a formula is the dependency digraph of the set of box-formulas that occur as subformulas of that formula.</p><p>An inductive formula is a regular formula with an acyclic dependency digraph.</p><p>Example 3.8. The formula ¬p ∨ ¬✷(✸p → ✷q) ∨ ✸✷✷q is an inductive formula. Indeed, ¬p and ¬✷(✸p → ✷q) are the negated box-formulas occurring as subformulas, and the dependency digraph has one arc, namely from p to q. It was shown in <ref type="bibr" target="#b17">[18]</ref> that this formula is not equivalent on frames to any Sahlqvist formula.</p><p>Definition 3.7 is constructive, in the sense that it describes recursively how inductive formulas are built. For the sake of comparison with the Sahlqvist-van Benthem formulas, we need a ''forbidden combination''-style definition also for the inductive inequalities. Some elements of the following definition may seem somewhat counter-intuitive. For example, the requirements are formulated in terms of negative occurrences of p i for ϵ i = 1, which seems the opposite of what is required by Definition 3.1. This is explained by the fact that the formulas here will correspond to right inductive terms, and that we choose to work with the formula as it stands, rather than with its negative generation tree. Definition 3.9 (Normalized Inductive Formulas). Let (p 1 , . . . , p n ) be a vector of propositional variables, ϵ = (ϵ 1 , . . . , ϵ n ) be an order type, and Ω be an irreflexive transitive relation on {p 1 , . . . , p n }. An ML-formula ϕ, with PROP(ϕ) ⊆ {p 1 , . . . , p n }, is an (Ω, ϵ)-inductive formula if 1. it is in negation normal form, 2. no negative (positive) occurrence of a variable p i with ϵ i = 1 (ϵ i = ∂) is in the scope of a ✷ which is in the scope of a ✸, and 3. if a negative (positive) occurrence of a variable p i with ϵ i = 1 (ϵ i = ∂) is in the scope of a ∧ which is a scope of a ✸, then the subformula with this ∧ as main connective is in the form α ∧ β with (a) the p-occurrence in β, (b) ϵ(+α), and (c) for every variable p j ∈ PROP(α), p j &lt; Ω p i .</p><p>An ML-formula ϕ is a normalized inductive formula if it is an (Ω, ϵ)-inductive formula for some order type ϵ and irreflexive transitive relation Ω.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.10. Every inductive formula is locally equivalent on frames to a normalized inductive formula and vice versa.</head><p>Proof. Let ϕ be an inductive formula, and ϕ ′ be its negation normal form. Let (p 1 , . . . , p n ) be the vector of all variables occurring in ϕ, let Ω be the irreflexive transitive relation on {p 1 , . . . , p n } obtained as the transitive closure of the dependency digraph of ϕ, and let ϵ = (1, 1, . . . , 1). We will now proceed to show that ϕ ′ is an (Ω, ϵ)-inductive formula.</p><p>To begin with, the negation normal forms of negated box-formulas are, up to equivalence, of the form</p><formula xml:id="formula_48">✸(A 1 ∧ ✸(A 2 ∧ • • • ✸¬p) • • • ),</formula><p>where the A i are positive formulas. Let us call such a formula a diamond formula with head p. Then, ϕ ′ is built up from positive formulas and diamond formulas, using ∧, ∨ and ✷.</p><p>Since ϵ = (1, . . . , 1), in checking that ϕ ′ is (Ω, ϵ)-normalized inductive, the only variable occurrences that we need to worry about are the negative ones, and all of these are the heads of diamond formulas. Thus, consider any diamond</p><formula xml:id="formula_49">subformula A = ✸(A 1 ∧ ✸(A 2 ∧ • • • ✸¬p) • • • ) of ϕ ′ with head p.</formula><p>The only diamonds in ϕ ′ in the scope of which this poccurrence occurs are those within A. From this it is clear that:</p><p>1. p is not in the scope of any ✷ which is in the scope of some ✸, i.e. condition 2 of Definition 3.9 is satisfied, and 2. all the occurrences of other variables within A are positive and strictly less than p in the Ω-ordering (as Ω is the transitive closure of the dependency digraph, which is acyclic by assumption), so condition 3 of Definition 3.9 is also satisfied.</p><p>Thus, we have proved that every inductive formula is (semantically, in fact) equivalent to a normalized inductive formula. Now suppose that ϕ is an (Ω, ϵ)-inductive formula, with PROP(ϕ) = {p 1 , . . . , p n }. Let ϕ 1 be obtained from ϕ by uniformly substituting ¬p i for each variable p i with ϵ i = ∂, and eliminating any resulting double negations. Then ϕ 1 is an (Ω, ϵ ′ )-inductive formula, where ϵ ′ = (1, 1, . . . , 1). Next, let ϕ 2 be obtained from ϕ 1 by distributing ✸ and ∧ over ∨ as much as possible. Note that ϕ 2 is still an (Ω, ϵ ′ )-inductive formula.</p><p>As for showing that ϕ 2 is equivalent to a regular formula, we now claim that ϕ 2 is built up from positive formulas and diamond formulas</p><formula xml:id="formula_50">✸(A 1 ∧ ✸(A 2 ∧ • • • ✸¬p) • • • ) (as</formula><p>defined above in this proof), using ∧, ∨ and ✷. Indeed, consider any negative variable occurrence ¬p i , and let A = ✸A ′ be the maximal subformula with ✸ as main connective containing this occurrence of ¬p i . In following the path from ¬p up to the root of the generation tree of ✸A ′ , it is impossible to encounter a ✷, as this would entail a violation of condition 2 of Definition 3.9. Combining this with the fact that ✸'s and ∧'s have been exhaustively distributed over ∨'s, it follows that there can be no ∨ on the path from ¬p i up to the root. Thus, the only connectives encountered on this path are ∧ and ✸; hence, by condition 3 of Definition 3.9, all other variable occurrences are positive and &lt; Ω p i . The claim follows.</p><p>The proof is complete once we note that every diamond formula</p><formula xml:id="formula_51">✸(A 1 ∧✸(A 2 ∧• • • ✸¬p) • • • ) is equivalent to the negated box-formula ¬✷(A 1 → ✷(A 2 → • • • ✷p) • • • ).</formula><p>Example 3.11. Transforming the inductive formula from Example 3.8 into negation normal form yields ¬p∨✸(✸p∧✸¬q)∨ ✸✷✷q. This is an (Ω, ϵ)-normalized inductive formula for Ω = {(p, q)} and ϵ = (1, 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">Classical DML frames</head><formula xml:id="formula_52">A DML frame F = (W , ≤, R ✷ , R ✸ , R ✄ , R ✁ ) is classical if ≤ = R ✄ = R ✁ = {(w, w) | w ∈ W } and R ✷ = R ✸ . Note that</formula><p>every subset of a classical DML frame is an up-set, and hence, for these frames every valuation is persistent. A classical model is pair (F , V ) consisting of a classical DML frame F and a valuation V .</p><p>Two remarks about classical DML frames and models: firstly, on classical models, the semantics of ✁ and ✄ becomes the same as that of ¬; secondly, we may naturally view any classical DML frame (W ,</p><formula xml:id="formula_53">≤, R ✷ , R ✸ , R ✄ , R ✁ ) as a Kripke frame (W , R) where R = R ✷ = R ✸ ,</formula><p>and hence, in this way interpret ML on classical DML frames and models. These two observations inspire the following definitions.</p><p>We define a translation Class(•) from L term into ML as follows: Class(ϕ) is obtained from ϕ by simply replacing each occurrence of ✁ and ✄ in ϕ with ¬, for any ϕ ∈ L term . We extend Class to L by specifying that Class(ϕ ≤ ψ) = ¬Class(ϕ) ∨ Class(ψ ).</p><p>The translation Dist(•) is essentially the inverse of Class(•): for any ϕ ∈ ML in negation normal form, Dist(ϕ) is obtained from ϕ by replacing each occurrence of ¬ in ϕ with ✁. An equivalent option would have been to replace ¬ with ✄. Proposition 3.12. Let (F , V ) be a classical DML model. Then, for every w ∈ F and all ϕ, ψ ∈ L term and γ ∈ ML, it holds that</p><formula xml:id="formula_54">1. (F , V ), w ϕ iff (F , V ), w Class(ϕ), 2. (F , V ), w ϕ ≤ ψ iff (F , V ), w Class(ϕ ≤ ψ), and 3. (F , V ), w γ iff (F , V ), w Dist(γ ).</formula><p>Proof. (2) is a direct consequence of (1), while (1) can be proven by straightforward structural induction on ϕ. We only check the case when ϕ is ✁ϕ ′ . Indeed (F , V ), w ✁ϕ ′ iff there exists some v ∈ W such that wR ✁ v and (F ,</p><formula xml:id="formula_55">V ), v ̸ ϕ ′ , iff (F , V ), w ̸ ϕ ′ (since R ✁ is the diagonal), iff (F , V ), w ̸ Class(ϕ ′ ) (by the inductive hypothesis), iff (F , V ), w ¬Class(ϕ ′ ), iff (F , V ), w Class(✁ϕ ′ ).</formula><p>(3) follows by a similar induction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3.">Inductive inequalities compared to normalized inductive formulas</head><p>In the light of Proposition 3.12, the following lemma says that, over the classical frames, the Sahlqvist and inductive inequalities project onto the Sahlqvist-van Benthem and normalized inductive formulas, respectively.</p><formula xml:id="formula_56">Proposition 3.13. 1. If ϕ ≤ ψ is a Sahlqvist inequality, then the negation normal form of Class(ϕ ≤ ψ) is a Sahlqvist-van Benthem formula. 2. If ϕ is a Sahlqvist-van Benthem formula, then ⊤ ≤ Dist(ϕ) is a Sahlqvist inequality. 3. If ϕ ≤ ψ is an inductive inequality, then the negation normal form of Class(ϕ ≤ ψ) is a normalized inductive formula. 4. If ϕ is a normalized inductive formula, then ⊤ ≤ Dist(ϕ) is an inductive inequality.</formula><p>Proof. We prove items 3 and 4, the proofs of 1 and 2 being analogous and simpler. To prove 3, we proceed contrapositively and suppose that ϕ ≤ ψ is an inequality, ϵ an order type and Ω an irreflexive transitive relation on the variables of ϕ ≤ ψ such that the negation normal form ϕ ′ ∨ ψ ′ of Class(ϕ ≤ ψ) is not an (Ω, ϵ)-inductive formula. Hence, ϕ ′ ∨ ψ ′ violates condition 2 or 3 of Definition 3.9. Suppose it is condition 2 that is violated. Specifically, suppose that there is some occurrence of ¬p i with ϵ i = 1 in ϕ ′ ∨ ψ ′ which is in the scope of a ✷ which in turn is in the scope of a ✸. (The case when the offending occurrence is a p i with ϵ i = δ) is symmetric.) There are now two cases to consider: Case 1: The offending occurrence is in ϕ ′ , i.e., in the negation normal form of ¬Class(ϕ). But then there is a path in the generation tree +ϕ starting at a +p i from which, proceeding up to the root, one encounters a +✸ or -✷ before a +✷ or -✸. Either way, ϕ is not (Ω, ϵ)-left inductive. Case 2: The offending occurrence is in ψ ′ . The argument is similar to that in case 1.</p><p>Next, suppose that it is condition 3 that is violated. Then ϕ ′ ∨ ψ ′ has a subformula ✸γ (α ′ ∧ β ′ ) such that ¬p i with ϵ i = 1 occurs in β ′ , but either it is not the case that ϵ(+α ′ ) or there is an occurrence of p j in α ′ such that p j ̸ &lt; Ω p i . (The case when the offending occurrence is a p i with ϵ i = δ is once again symmetric.) If this subformula is in ϕ ′ , then there is a path in the generation tree +ϕ starting at a +p i from which, proceeding up to the root, one encounters either (a) a +∨ node with a +✷ or -✸ node as ancestor, and such that the corresponding subtree +(α ∨ β) violates condition 1(a) of Definition 3.1; or (b) a -∧ node with a +✷ or -✸ node as ancestor, and such that the corresponding subtree -(α ∧ β) violates condition 1(b) of Definition 3.1.</p><p>If the offending subformula is in ψ ′ , the argument is similar. To consider item 4, suppose that ϕ is an (Ω, ϵ)-inductive formula. The fact that ⊤ ≤ Dist(ϕ) is (Ω, ϵ)-inductive (and hence the claim) follows easily from this assumption, the definition of the translation Dist(•), and the following observations. (i) In Dist(ϕ), the operation ✄ does not occur and, since ϕ is in negation normal form, ✁ occurs only directly before variables.</p><p>Hence, (ii) in the negative generation tree of Dist(ϕ), all occurrences of ✁ are signed negative, and are parents of leaves, and hence, (iii) the only universal nodes which can have choice nodes as descendants are labelled -✸. Now the definition of normalized inductive formulas guarantees that the only possible choice node in the scope of this universal is -∧, and moreover that conditions 1 and 2 of Definition 3.1 are verified.</p><p>Example 3.14. Consider the normalized inductive formula ¬p ∨ ✸(✸p ∧ ✸¬q) ∨ ✸✷✷q from Example 3.11. Applying the translation Dist to this formula yields ✁p ∨ ✸(✸p ∧ ✸ ✁ q) ∨ ✸✷✷q which, if we turn it into an inequality, becomes ⊤ ≤ ✁p ∨ ✸(✸p ∧ ✸ ✁ q) ∨ ✸✷✷q. This is an (Ω, ϵ)-inductive inequality with p &lt; Ω q and ϵ(p) = ϵ(q) = 1.</p><p>As expected, applying Class reverses this process:</p><formula xml:id="formula_57">Class (⊤ ≤ ✁p ∨ ✸(✸p ∧ ✸ ✁ q) ∨ ✸✷✷q) = ¬⊤ ∨ (¬p ∨ ✸(✸p ∧ ✸¬q) ∨ ✸✷✷q).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4.">The inductive inequalities essentially extend the Sahlqvist inequalities</head><p>The following lemma shows that the inductive inequalities represent an essential enlargement of the class of Sahlqvist inequalities, in the sense that there exist inductive inequalities which are not equivalent on frames to any Sahlqvist inequality.</p><p>Lemma 3.15. The inductive inequality ⊤ ≤ ✁p ∨ ✸(✸p ∧ ✸ ✁ q) ∨ ✸✷✷q (Example 3.14) is not equivalent on frames to any Sahlqvist inequality.</p><p>Proof. Recall from Examples 3.8, 3.11 and 3.14 that on classical models (and hence, classical frames) this inequality is equivalent to an inductive formula which is not equivalent on frames to any Sahlqvist-van Benthem formula. Now, if it were equivalent (on frames) to a Sahlqvist inequality ϕ ≤ ψ, it would also be equivalent to it on all classical frames. But, by Propositions 3.12 and 3.13, this would mean that the normalized inductive formula Class(⊤ ≤ ✁p ∨ ✸(✸p ∧ ✸ ✁ q) ∨ ✸✷✷q) is equivalent on frames to the Sahlqvist-van Benthem formula Class(ϕ ≤ ψ), which is a contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Recognizing inductive inequalities in different signatures</head><p>We conclude this section on inductive inequalities by discussing some unresolved issues, which include the pros and cons of the choice of the algebraic signature of DML (an issue which we only now have the prerequisites to properly evaluate), and the identification of the order-theoretic principles underlying the definition of Sahlqvist and inductive inequalities; moreover, we show how these principles uniformly apply to different signatures; finally, this discussion enables us to draw some positive conclusions on the adequacy of inductive inequalities for the correspondence theory of intuitionistic logic and its expansions. Let us start with the pros of developing our theory on DML. Firstly, as already mentioned early on, DML is a natural choice from a ''historical'' viewpoint, since the Sahlqvist theory has already been developed for this signature <ref type="bibr" target="#b13">[14]</ref>, and therefore it provides a good test case for improvement. But there are also intrinsic reasons justifying this choice: indeed, the signature of DML:</p><p>(1) is exhaustive in the unary modal signature, in the sense that it samples all the different order-theoretic behaviours of unary operations that guarantee the application of the correspondence mechanism;</p><p>(2) is so general as to lack any deduction detachment theorem, and hence inequalities, and not formulas, encode deduction; but still the mechanism of correspondence generalizes very naturally to inequalities without losing any crucial feature. So in a sense, the case study of DML makes the point that inequalities and not formulas are at the right level of generality when correspondence is concerned;</p><p>(3) is expressive enough to guarantee that it projects adequately onto the whole basic classical signature; (4) encompasses well-known nonclassical modal logics, such as positive modal logic. On the other hand, DML does not encompass intuitionistic modal logic <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22]</ref> (although the two logics are akin, so adapting the theory requires only minimal additional work, as we will see next).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2</head><p>Universal and choice nodes for the signature of IML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Choice</head><p>Universal</p><formula xml:id="formula_58">+ ∨ + ✸ + ✁ + → - ∧ - ✷ - ✄ - → + ✷ + ✄ + → - ✸ - ✁</formula><p>A more serious disadvantage of DML is methodological: although possible, it is not straightforward to extract a general modus operandi from the theory developed so far when it comes to extending the definition of inductive and Sahlqvist inequalities to general, polyadic signatures. The present subsection is intended to remedy this at least partially, and a more thorough discussion will appear in the forthcoming paper <ref type="bibr" target="#b6">[7]</ref>. There are two reasons for this difficulty: firstly, the only binary operations which could help for a comparison are join and meet, which are quite special; secondly, two order-theoretic properties collapse when applied to unary operations, which are quite distinct in the binary case: one property is being a right or a left adjoint (like the box or the diamond, respectively); the other property is being a right or a left residual (like the Heyting implication and the meet, respectively, or the join and the subtraction, respectively). The first definition of course also applies to the binary (or n-ary) operations (just understanding them as maps having the product algebra as their domains), and it turns out that the meet and the join respectively are the right and the left adjoint of the diagonal map ∆ : C → C × C defined by the assignment x  → (x, x): indeed, denoting the product order on C × C by ≤ × , the definition of supremum and infimum implies that, for all x, y, z ∈ C,</p><formula xml:id="formula_59">x ≤ y ∧ z iff x ≤ y and x ≤ z iff ∆(x) ≤ × (y, z) y ∨ z ≤ x iff y ≤ x and z ≤ x iff (y, z) ≤ × ∆(x).</formula><p>For n-ary operations with n &gt; 1, the global form of adjunction is strictly stronger than the coordinatewise adjunction (which from now on will be referred to as residuation). Summing up:</p><p>∧ is both a left residual and a right adjoint (and hence a right residual), but is not a left adjoint; ∨ is both a right residual and a left adjoint (and hence a left residual), but is not a right adjoint;</p><p>✷ is a right adjoint (i.e., a right residual), but is not a left adjoint (i.e., not a left residual); ✸ is left adjoint (i.e., a left residual), but is not a right adjoint (i.e., not a right residual).</p><p>The order-theoretic analysis of classical correspondence appearing in <ref type="bibr" target="#b7">[8]</ref> and the way ALBA works provide enough evidence that the notions of ''choice'' and ''universal'' nodes reported in Table <ref type="table" target="#tab_2">1</ref> identify the lack of some order-theoretic properties. Let us adopt the convention that a positively signed operation has a property if the unsigned connective, seen as an operation on C, has that property, and that a negatively signed connective has a property if and only if the unsigned connective, seen as an operation on C ∂ , has that property. Now, reading Table <ref type="table" target="#tab_2">1</ref> against the facts above should convince the reader that Choice = Not a right adjoint Universal = Not a left residual.</p><p>For instance, +∧ is neither choice (indeed, ∧ is a right adjoint) nor universal (indeed, ∧ is a left residual, although is not a left adjoint); moreover, -∧ is choice (indeed ∧ is not a left adjoint) but it is not universal (indeed, ∧ is a right adjoint, and hence is a right residual).</p><p>Having made the order-theoretic content of the choice/universal classification explicit makes it possible to extend this classification to different signatures, which is the basic preliminary needed to recognize Sahlqvist and inductive formulas/inequalities in each given signature. Notice also that the order-theoretic content of the classification reveals the existence of an asymmetry between the two classes, given by the fact that adjunction is stronger than residuation, which cannot be detected by unary operations, due to the fact that adjunction and residuation collapse in that case; this brings us to a third reason why the DML signature is too special to be paradigmatic: each operator (modulo taking the order dual of the domain in the case of the triangles) happens to be either a left residual or a right adjoint. Thus, the choice/universal classification is mutually exclusive for the connectives in the DML signature, something which, in general, need not be the case. For instance, since the Heyting implication → is a right residual but not a left residual and is neither a left nor a right adjoint, we have that + → is both choice and universal and -→ is only choice. The classification for the DML signature expanded with intuitionistic implication is described in Table <ref type="table">2</ref>. Given these preliminaries, Definitions 3.1 and 3.5 can now be applied to this expanded signature, which, for the purpose of this subsection, we will refer to as the signature of intuitionistic modal logic (IML). Moreover, since IML inequalities s ≤ t can be equivalently rewritten as ⊤ ≤ s → t, Sahlqvist and inductive formulas can be defined for this signature in the obvious way and these definitions can be taken as basic, just as in the Boolean case.</p><p>However, if we apply Definitions 3.1 and 3.5 ceteris paribus, we incur another problem; namely, inequalities such as p → ✷p ≤ ✸✷p, which cannot be solved, would be Sahlqvist according to Definition 3.5. The easiest way to fix this problem (without changing Definitions 3.1 and 3.5) is to adopt the convention that the ancestor (or 'scope of') a relation in termgeneration trees be reflexive. Thus, the presence of a choice-and-universal node on critical branches would constitute an occurrence of a choice node in the scope of a universal. Notice that adopting this convention or not is of no consequence for the DML signature, thanks again to the fact that the choice/universal classification is mutually exclusive for the connectives in DML. In the next example we look at the Sahlqvist/inductive status of some important axioms for the basic intuitionistic modal logic IK if we adopt this convention.</p><p>Example 3.16. The Fischer-Servi axioms <ref type="bibr" target="#b11">[12]</ref> ✸(p → q) → (✷p</p><formula xml:id="formula_60">→ ✸q) (✸p → ✷q) → ✷(p → q),</formula><p>are ϵ-Sahlqvist for ϵ p = 1 and ϵ q = ∂. The well-known Frege axiom of intuitionistic logic,</p><formula xml:id="formula_61">(p → (q → r)) → ((p → q) → (p → r)),</formula><p>is not Sahlqvist, but properly inductive. Indeed, in the generation trees +(p → (q → r)) and -((p → q) → (p → r)), there is both a negative and a positive occurrence of q in the scope of a + → which is both choice and universal, and hence this formula/inequality cannot be ϵ-Sahlqvist for any ϵ. However it is easy to see that the formula/inequality is (Ω, ϵ)-inductive, taking p &lt; Ω q &lt; Ω r and ϵ p = ϵ q = ϵ r = 1. Lastly consider the IML inequality ✷((✷p → q) ∧ (q → ✷p)) ≤ p. To see that this is not inductive, consider the case where ϵ q = 1; we have an occurrence of +q in the subtree +(✷p → q), and + → is both choice and universal. So it would have to be the case that ϵ p = 1 and p &lt; Ω q. But then we also have an occurrence of +p in the subtree +(q → ✷p), which in order to be legal would require q &lt; Ω p, which is a contradiction. And likewise, assuming that ϵ q = ∂ also leads to contradiction.</p><p>The fact that (p → (q → r)) → ((p → q) → (p → r)) is properly inductive is very interesting, since, as far as the authors are aware, no properly inductive axioms crop up in the axiomatic definitions of the standard Boolean-based modal logics. Indeed, it seems that all well-known classical axioms which have first-order correspondents and are not Sahlqvist, such as the conjunction of the transitivity and McKinsey axioms (which is clearly not inductive), lie beyond the reach of the correspondence mechanisms underlying the Sahlqvist and inductive classes.</p><p>Finally, the convention of taking the ancestor relation as reflexive is a bit contrived, and we do not believe that is the optimal solution. A more natural solution is in fact given by dropping the choice/universal classification (based, as we have seen, on the lack of order-theoretic properties, which prevents the correspondence mechanism from going through), in favour of a classification positively based on the satisfaction of the properties which enable the same correspondence mechanism to succeed. Such an alternative classification is introduced and discussed in <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The Ackermann lemmas</head><p>The following two lemmas facilitate the elimination of propositional variables from inequalities and will be key to the correspondence results developed in this paper. They are DML analogues of a lemma proved by Ackermann in <ref type="bibr" target="#b0">[1]</ref> in the context of second-order logic.</p><p>First some terminology. Two valuations V and V ′ on a frame F are called p-variants for p ∈ PROP (notation:</p><formula xml:id="formula_62">V ∼ p V ′ ) if V (a) = V ′ (a) for all a ∈ (PROP -{p}) ∪ NOM ∪ CO-NOM. Definition 4.1. A formula ϕ ∈ L +</formula><p>term is positive (resp., negative) in a propositional variable p if in its positive generation tree all p-nodes are signed + (resp., -). An inequality ϕ ≤ ψ ∈ L + is positive (resp., negative) in a propositional variable p if ϕ is negative (resp., positive) in p and ψ is positive (resp., negative) in p.</p><p>A standard inductive argument shows that, if ϕ is positive in p, then its induced semantic operation ϕ V p (X) (defined on page 345) is monotone (or order-preserving) and antitone (order-reversing) if ϕ is negative in p. We will often say that ϕ(p)</p><formula xml:id="formula_63">is monotone (antitone) in p if ϕ V p (X) is monotone (antitone). Lemma 4.2 (Right Ackermann Lemma). Let α 1 , . . . , α n ∈ L + with p ̸ ∈ PROP(α i ), 1 ≤ i ≤ n, let β 1 (p), .</formula><p>. . , β m (p) ∈ L + be positive in p, and let γ 1 (p), . . . , γ m (p) ∈ L + be negative in p. Let V be any valuation on a frame F . Then,</p><formula xml:id="formula_64">F , V β j (α 1 ∨ • • • ∨ α n /p) ≤ γ j (α 1 ∨ • • • ∨ α n /p), for all 1 ≤ j ≤ m iff there exists some V ′ ∼ p V such that F , V ′ α i ≤ p for all 1 ≤ i ≤ n, and F , V ′ β j (p) ≤ γ j (p), for all 1 ≤ j ≤ m.</formula><p>Proof. For the implication from top to bottom, let</p><formula xml:id="formula_65">V ′ (p) = V (  n i=1 α i ). Since the α i do not contain p, we have V (α i ) = V ′ (α i ), and hence, V ′ (α i ) ⊆  n i=1 V (α i ) = V (  n i=1 α i ) = V ′ (p).</formula><p>Moreover, by assumption we get, for 1</p><formula xml:id="formula_66">≤ j ≤ m, V ′ (β j (p)) = V  β j  n  i=1 α i /p  ⊆ V  γ j  n  i=1 α i /p  = V ′ (γ j (p)).</formula><p>For the implication from bottom to top, we make use of the fact that the β j are monotone (since they are positive) in p, while the γ j are antitone (since they are negative) in p.</p><formula xml:id="formula_67">Since V (α i ) = V ′ (α i ) ⊆ V ′ (p) for all 1 ≤ i ≤ n, we have V (  n i=1 α i ) ⊆ V ′ (p),</formula><p>and hence,</p><formula xml:id="formula_68">V  β j  n  i=1 α i /p  ⊆ V ′ (β j (p)) ⊆ V ′ (γ j (p)) ⊆ V  γ j  n  i=1 α i /p</formula><p> .</p><p>The proof of the following version of the lemma is similar.</p><formula xml:id="formula_69">Lemma 4.3 (Left Ackermann Lemma). Let α 1 , . . . , α n ∈ L + with p ̸ ∈ PROP(α i ), 1 ≤ i ≤ n, let β 1 (p), .</formula><p>. . , β m (p) ∈ L + be negative in p, and let γ 1 (p), . . . , γ m (p) ∈ L + be positive in p. Let V be any valuation on a frame F . Then,</p><formula xml:id="formula_70">F , V β j (α 1 ∧ • • • ∧ α n /p) ≤ γ j (α 1 ∧ • • • ∧ α n /p), for all 1 ≤ j ≤ m iff there exists a V ′ ∼ p V such that F , V ′ p ≤ α i for all 1 ≤ i ≤ n, and F , V ′ β j (p) ≤ γ j (p), for all 1 ≤ j ≤ m.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The algorithm, informally</head><p>When applied from bottom to top, Lemmas 4.2 and 4.3 provide a way to eliminate occurrences of propositional variables from sets of inequalities. It is the presence of these propositional variables which gives rise to the second-order quantification in the corresponding frame conditions. Hence, if one can eliminate the propositional variables from an inequality, hence transforming it into an equivalent pure (recall Definition 2.14) inequality (or set of pure inequalities), this would yield a first-order frame correspondent for it. Consider the inductive inequality</p><formula xml:id="formula_71">✷(✸q ∨ p) ∧ ✁✷p ≤ ✷✸q,<label>(3)</label></formula><p>from Example 3.3. We would like to see how we can use Lemmas 4.2 and 4.3 to eliminate the propositional variables p and q from it, and in so doing determine a first-order frame correspondent for it. To this end, let F be any frame and F + be its complex algebra. As it stands, it is not clear how (3) could be equivalently rewritten into a form which makes one of the Ackermann lemmas applicable. To overcome this, we make use of one of the two characterizing properties of perfect algebras (cf. Subsection 2.5), namely, the fact that every element in a perfect algebra is both the join of the completely join-prime elements below it and the meet of the completely meet-prime elements above it. This property enables us to express the validity of (3) in F + in terms of two simultaneous ''approximations'', from below and above. Indeed,</p><formula xml:id="formula_72">F + |= ✷(✸q ∨ p) ∧ ✁✷p ≤ ✷✸q iff F + |= ∀i 0 ∀m 0 [(i 0 ≤ ✷(✸q ∨ p) ∧ ✁✷p &amp; ✷✸q ≤ m 0 ) ⇒ i 0 ≤ m 0 ],<label>(4)</label></formula><p>where i 0 and m 0 are a nominal and co-nominal which, as indicated in Subsection 2.5, range over the completely join-prime and completely meet-prime elements of F + , respectively. The variable q is minimal with respect to the ordering Ω (see Example 3.3), so we will try to eliminate it first. To this end, let us focus on ✷✸q ≤ m 0 . Next, we are going to make use of the second characterizing property of perfect algebras, namely, that the operations preserve or reverse arbitrary joins or meets, and are therefore adjoints. The inequality above is equivalent to </p><formula xml:id="formula_73">✷  {b ∈ M ∞ | ✸q ≤ b} ≤ m 0 ,</formula><formula xml:id="formula_74"> {✷b | ✸q ≤ b ∈ M ∞ } ≤ m 0 .</formula><p>Now, since m 0 denotes a completely meet-prime element, the latter inequality is the case iff there exists a m 1 ∈ M ∞ , 7 such that ✸q ≤ m 1 and ✷m 1 ≤ m 0 . Next, applying the adjunction property for ✸, we have ✸q ≤ m 1 iff q ≤ m 1 . Moreover, since m 1 does not occur in the consequent of the implication, we can equivalently pull ∃m 1 into the prefix as ∀m 1 . Thus, (4) is equivalent to</p><formula xml:id="formula_75">F + |= ∀i 0 ∀m 0 ∀m 1 [(i 0 ≤ ✷(✸q ∨ p) ∧ ✁✷p &amp; q ≤ m 1 &amp; ✷m 1 ≤ m 0 ) ⇒ i 0 ≤ m 0 ].<label>(5)</label></formula><p>Noting that, in the inequalities i 0 ≤ ✷(✸q ∨ p) ∧ ✁✷p and ✷m 1 ≤ m 0 , the left-hand sides are antitone and the right-hand sides are monotone in q, we see that Lemma 4.3 is now applicable to the antecedent in <ref type="bibr" target="#b4">(5)</ref>, which transforms it onto</p><formula xml:id="formula_76">F + |= ∀i 0 ∀m 0 ∀m 1 [(i 0 ≤ ✷(✸ m 1 ∨ p) ∧ ✁✷p &amp; ✷m 1 ≤ m 0 ) ⇒ i 0 ≤ m 0 ].<label>(6)</label></formula><p>7 For the sake of this informal discussion we will be a bit sloppy, and confuse propositional variable and (co-)nominals with the elements of the algebra interpreting them.</p><p>Thus, it remains to eliminate p. To this end, we focus on the inequality i 0 ≤ ✷(✸ m 1 ∨ p) ∧ ✁✷p. This is equivalent to the pair of inequalities i 0 ≤ ✷(✸ m 1 ∨ p) and i 0 ≤ ✁✷p. The first of these can be rewritten as i 0 ≤ ✸ m 1 ∨ p through the application of adjunction for ✷. Next, applying adjunction for ∨ we get i 0 -✸ m 1 ≤ p. Thus, ( <ref type="formula" target="#formula_76">6</ref>) is transformed into</p><formula xml:id="formula_77">F + |= ∀i 0 ∀m 0 ∀m 1 [( i 0 -✸ m 1 ≤ p &amp; i 0 ≤ ✁✷p &amp; ✷m 1 ≤ m 0 ) ⇒ i 0 ≤ m 0 ]. (7)</formula><p>Since, in the inequalities i 0 ≤ ✁✷p and ✷m 1 ≤ m 0 , the left-hand sides are monotone and the right-hand sides are antitone in p, Lemma 4.2 can be applied to transform <ref type="bibr" target="#b6">(7)</ref> into</p><formula xml:id="formula_78">F + |= ∀i 0 ∀m 0 ∀m 1 [(i 0 ≤ ✁✷( i 0 -✸ m 1 ) &amp; ✷m 1 ≤ m 0 ) ⇒ i 0 ≤ m 0 ].<label>(8)</label></formula><p>Thus, we have eliminated all propositional variables from ( <ref type="formula" target="#formula_72">4</ref>), but the result does still contain nominals and co-nominals.</p><p>Note that, when interpreted in F + , nominals and co-nominals range over sets of the form x↑ and (x↓) c for x ∈ W , which are first-order definable. It follows that <ref type="bibr" target="#b7">(8)</ref> translates into a first-order condition on the frame F : indeed, it is equivalent to</p><formula xml:id="formula_79">F |= ∀x 0 ∀y 0 ∀y 1     x 0 ↑ ⊆ ⟨R ✁ ][R ✷ ](⟨R -1 ✷ ⟩x 0 ↑ ∩ (⟨R ✸ ⟩[R -1 ✸ ](y 1 ↓) c ) c )↑ &amp; [R ✷ ](y 1 ↓) c ⊆ (y 0 ↓) c   ⇒ x 0 ↑ ⊆ (y 0 ↓) c  <label>(9)</label></formula><p>which can be easily, if rather tediously, translated into the first-order frame correspondence language L 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">The algorithm ALBA, formally</head><p>We will now formalize the procedure illustrated in the previous section into an algorithm which we will call 'ALBA'. The name is an acronym for ''Ackermann-lemma-based algorithm''. We do not pretend that the following is a complete specification of an implementable algorithm. Many issues, like the choice of rules to apply, the order in which variables are eliminated, and backtracking will not be addressed. Our aim is rather to provide a set of rules together with an outline of how these can be applied in order to derive frame correspondents of DML inequalities. As will be shown in Section 9, any inequality for which such a correspondent can be successfully derived using ALBA is also guaranteed to be canonical.</p><p>ALBA proceeds in three stages. The first one takes a DML inequality, or a set of DML inequalities, and preprocesses these.</p><p>To each inequality ϕ j ≤ ψ j resulting from this preprocessing, the first approximation rule is applied, producing the pair of inequalities i 0 ≤ ϕ and ψ ≤ m 0 . Here the processing branches, with the second stage (called the reduction stage) proceeding separately on each of these pairs. The aim of the reduction stage is to eliminate all occurring propositional variables from the set of inequalities, by applying the residuation, approximation and Ackermann rules. If this succeeds on every branch, we proceed to the third stage; if not, ALBA reports failure and terminates. The third stage is the output stage, which returns a frame correspondent for the input inequality (or set of inequalities). This frame correspondent can be either a pure L + quasiformula or the (first-order) frame translation thereof, depending upon the user's preference. We will now proceed to specify these stages and the rules used by each.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Phase 1: input, preprocessing and first approximation</head><p>ALBA receives an L-inequality ϕ ≤ ψ as input, and preprocesses it by performing the following steps exhaustively: 1. in the positive generation tree of ϕ (resp. negative generation tree of ψ), (a) push down, towards variables, occurrences of +✸, +∧ and -✄, by distributing them only over occurrences of +∨ which are not below universal nodes, and (b) push down, towards variables, occurrences of -✷, -∨ and +✁, by distributing them only over occurrences of -∧ which are not below universal nodes; 2. apply the splitting rules:</p><formula xml:id="formula_80">α ≤ β ∧ γ α ≤ β α ≤ γ α ∨ β ≤ γ α ≤ γ β ≤ γ 3.</formula><p>apply the monotone and antitone variable elimination rules: Denote by Preprocess(ϕ ≤ ψ) the finite set {ϕ i ≤ ψ i } i∈I of inequalities obtained in this way. Thus, Preprocess(ϕ ≤ ψ) contains only inequalities to which none of the preprocessing steps is applicable any more. To each ϕ i ≤ ψ i ∈ Preprocess(ϕ ≤ ψ), the following first approximation rule is applied only once:</p><formula xml:id="formula_81">α(p) ≤ β(p) α(⊥) ≤ β(⊥) γ (p) ≤ δ(p) γ (⊤) ≤ δ(⊤)</formula><formula xml:id="formula_82">ϕ i ≤ ψ i i 0 ≤ ϕ i ψ i ≤ m 0</formula><p>Here, i 0 and m 0 are special reserved nominals and co-nominals, respectively. The first approximation step gives rise to systems of inequalities {i 0 ≤ ϕ, ψ ≤ m 0 }. Each such system is called an initial system, and is now passed on to the reduction-elimination cycle (phase 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Phase 2: the reduction-elimination cycle</head><p>The goal of the reduction-elimination cycle is to eliminate all propositional variables from the systems which it receives from the preprocessing phase. The elimination of each variable is effected by an application of one of the Ackermann rules given below. In order to apply an Ackermann rule, the system must have a specific shape; the residuation, approximation, and splitting rules are used to transform systems into this shape. The rules of the reduction-elimination cycle, namely the residuation, approximation, splitting, and Ackermann rules, will be collectively called the reduction rules.</p><p>Residuation rules. The fact that all the operations in our signature are either right or left adjoints provides us with the third batch of invertible rules for our algorithm, the residuation rules:</p><formula xml:id="formula_83">α ∧ β ≤ γ α ≤ β → γ α ≤ β ∨ γ α -β ≤ γ ✸α ≤ β α ≤ β α ≤ ✷β α ≤ β ✁α ≤ β β ≤ α α ≤ ✄β β ≤ α</formula><p>Approximation rules. The second batch consists of the approximation rules. These rules are based on the fact that in perfect DMA's each element is the join of join-primes and the meet of meet-primes, on the infinitary distribution properties of DMA operations, and on the defining property of completely join-prime and meet-prime elements, respectively.</p><formula xml:id="formula_84">i ≤ ✸α j ≤ α i ≤ ✸j ✷α ≤ m α ≤ n ✷n ≤ m i ≤ ✁α α ≤ m i ≤ ✁m ✄α ≤ m i ≤ α ✄ i ≤ m</formula><p>The nominals and co-nominals introduced in the conclusions of the approximation rules must be fresh, in the sense that they may not occur anywhere in the system before the rule is applied. Remark 6.1. As regards the rules, we note the following:</p><p>1. The application of a rule replaces in the system the premise with the conclusion(s). 2. Although the rules are invertible, for the sake of reducing the Sahlqvist and inductive inequalities in DML we will only ever need to apply them from top to bottom (Theorem 10.11). 3. In all rules that deal with the order-preserving operations, the displayed subformula does not change sides in the inequality, whereas it does change sides in all the rules dealing with the order-reversing operations. 4. The monotone and antitone variable elimination rules are applied only during preprocessing. This is sufficient because, thanks to what was observed in the item 3 above, the polarities of variable occurrences stay constant during the reduction-elimination phase, and hence no new monotone or antitone variables can be created during this phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>As observed in Subsection 3.4, the lattice operations ∨ and ∧ respectively are the left and the right adjoint of the diagonal map. Hence, the splitting rules are in fact 'adjunction rules', i.e. enhanced residuation rules. The enhanced power that they have is that, by splitting, they break dependencies between variables caused by co-occurrences within the same inequality.</p><p>Remark 6.2. In signatures containing operations and their residuals as primitives, the (invertible) residuation rules will generally need to be applied in both directions, even for reducing inductive inequalities (see <ref type="bibr">Example 7.5</ref>). This would be the case for example in IML, containing ∧ and →, and in tense logic containing ✷ F and ✸ P .</p><p>In the case of IML we would also need to add approximation rules for →,</p><formula xml:id="formula_85">namely α → β ≤ m j ≤ α j → β ≤ m α → β ≤ m β ≤ n α → n ≤ m</formula><p>where j and n are a fresh nominal and co-nominal, respectively. The Ackermann rules. These two rules are responsible for the elimination of propositional variables, and as such they form the heart of ALBA. Unlike that of the residuation and approximation rules, which apply to single inequalities, the applicability of Ackermann rules is determined by the shape of the whole system, and multiple inequalities are removed or transformed by a single application.</p><p>The right-handed Ackermann rule works as follows:</p><p>The system</p><formula xml:id="formula_86">             α 1 ≤ p . . . α n ≤ p β 1 ≤ γ 1 . . . β m ≤ γ m is replaced by        β 1 ((α 1 ∨ • • • ∨ α n )/p) ≤ γ 1 ((α 1 ∨ • • • ∨ α n )/p) . . . β m ((α 1 ∨ • • • ∨ α n )/p) ≤ γ m ((α 1 ∨ • • • ∨ α n )/p)</formula><p>where:</p><p>1. p does not occur in α 1 , . . . , α n ; 2. each β i is positive, and each γ i negative in p, 1 ≤ i ≤ m.</p><p>The left-handed Ackermann rule works as follows:</p><p>The system</p><formula xml:id="formula_87">             p ≤ α 1 . . . p ≤ α n β 1 ≤ γ 1 . . . β m ≤ γ m is replaced by        β 1 ((α 1 ∧ • • • ∧ α n )/p) ≤ γ 1 ((α 1 ∧ • • • ∧ α n )/p) . . . β m ((α 1 ∧ • • • ∧ α n )/p) ≤ γ m ((α 1 ∧ • • • ∧ α n )/p)</formula><p>where:</p><p>1. p does not occur in α 1 , . . . , α n ; 2. each β i is negative, and each γ i positive in p, 1 ≤ i ≤ m. Remark 6.3. It is interesting to note that the monotone and antitone variable elimination rules can be seen as encoding special instances of the Ackermann rules. Indeed, adding the tautological inequalities ⊥ ≤ p or p ≤ ⊤ to any system always preserves equivalence. Thus if {s i ≤ t i } is positive in p we can equivalently replace it with {s i ≤ t i } ∪ {⊥ ≤ p} obtaining a system to which the right Ackermann rule is applicable to eliminate p. Likewise systems which are negative in p can be brought into a shape to which the left Ackermann rule is applicable by adding p ≤ ⊤.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Phase 3: success, failure, translation, and output</head><p>If there was some system in phase 2 from which all occurring propositional variables could not be eliminated through the application of the reduction rules, then ALBA reports failure and terminates. Otherwise, each system {i 0 ≤ ϕ i , ψ i ≤ m 0 } obtained from ψ i ≤ ψ i ∈ Preprocess(ϕ ≤ ψ) has been reduced to a system, which we will indicate with Reduce(ϕ i ≤ ψ i ), containing no propositional variables.</p><p>Let ALBA(ϕ ≤ ψ) be the set of quasi-inequalities 8 &amp;Reduce(</p><formula xml:id="formula_88">ϕ i ≤ ψ i ) ⇒ i 0 ≤ m 0 for ϕ i ≤ ψ i ∈ Preprocess(ϕ ≤ ψ)</formula><p>. Since all members of ALBA(ϕ ≤ ψ) are free of propositional variables, applying the standard frame translation to them produces first-order formulas. Hence, let</p><formula xml:id="formula_89">ALBA FO (ϕ ≤ ψ) :=  i∈I ∀m 0 ∀j∀m (∀xST x (Reduce(ϕ i ≤ ψ i )) → ∀xST x (i 0 ≤ m 0 )) ,</formula><p>where j and m are the vectors of all variables corresponding to the nominals and co-nominals, respectively, occurring in</p><p>Reduce(ϕ i ≤ ψ i ), other than the reserved nominal and co-nominal i 0 and m 0 . Note that the variable m 0 corresponding to m 0 is quantified over but that i 0 corresponding to i 0 is left free -this is done since we want to produce a local correspondent.</p><p>That ALBA FO (ϕ ≤ ψ) is indeed a local frame correspondent for ϕ ≤ ψ is the content of Theorem 8.1 which will be proven in Section 8.</p><p>ALBA returns ALBA FO (ϕ ≤ ψ) or ALBA(ϕ ≤ ψ), depending on the user's preference, and terminates. An inequality ϕ ≤ ψ on which ALBA succeeds will be called an ALBA inequality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Examples</head><p>We will now illustrate how ALBA computes frame equivalents for inequalities by means of a few examples.</p><p>Example 7.1. Consider the Sahlqvist inequality ✸✷p ≤ ✷✸p. Steps 1, 2 and 3 of the preprocessing phase are trivial for this inequality as the inequality is neither positive nor negative in p, and no distribution or splitting is possible. Hence, the first approximation rule is applied and one initial system (10) is produced:</p><formula xml:id="formula_90"> j 0 ≤ ✸✷p, ✷✸p ≤ m 0  .<label>(10)</label></formula><p>The reduction-elimination cycle now starts. Applying the approximation for ✸ to j 0 ≤ ✸✷p produces the system (11), from which ( <ref type="formula" target="#formula_92">12</ref>) is obtained by the application of the residuation rule for ✷.</p><formula xml:id="formula_91"> j 0 ≤ ✸j 1 , ✷✸p ≤ m 0 j 1 ≤ ✷p  .<label>(11)</label></formula><formula xml:id="formula_92"> j 0 ≤ ✸j 1 , ✷✸p ≤ m 0 j 1 ≤ p  . (<label>12</label></formula><formula xml:id="formula_93">)</formula><p>8 For the definition, see the paragraph right before Subsection 2.2, and the paragraph right before Subsubsection 2.5.1.</p><p>System <ref type="bibr" target="#b11">(12)</ref>) is now in a shape which makes the right-handed Ackermann rule applicable. This application eliminates p and yields the following:</p><formula xml:id="formula_94"> j 0 ≤ ✸j 1 , ✷✸ j 1 ≤ m 0  .<label>(13)</label></formula><p>As all propositional variables have been eliminated, this marks the end of the reduction-elimination phase. We now have</p><formula xml:id="formula_95">Reduce(✸✷p ≤ ✷✸p) = {j 0 ≤ ✸j 1 , ✷✸ j 1 ≤ m 0 } and, hence, ALBA(✸✷p ≤ ✷✸p) = {((j 0 ≤ ✸j 1 ) &amp; (✷✸ j 1 ≤ m 0 )) ⇒ j 0 ≤ m 0 }. Further, ALBA FO (✸✷p ≤ ✷✸p)<label>(14)</label></formula><p>=∀m 0 ∀j 1  ∀x</p><formula xml:id="formula_96"> j 0 ≤ x → ∃y(R ✸ xy ∧ j 1 ≤ y) ∧ ∀z(R ✷ xz → ∃u(R ✸ zu ∧ ∃v(R ✷ vu ∧ j 1 ≤ v))) → x m 0  → ∀x(j 0 ≤ x → x m 0 ).<label>(15)</label></formula><p>Now, on classical frames, where the ≤-relation is the identity and R ✸ = R ✷ = R, (15) can be simplified as follows:</p><formula xml:id="formula_97">∀m 0 ∀j 1 (∀x[∃y(Rj 0 y ∧ j 1 = y) ∧ (∀z(Rxz → ∃u(Rzu ∧ Rj 1 u)) → x ̸ = m 0 )] → j 0 ̸ = m 0 ) (<label>16</label></formula><formula xml:id="formula_98">)</formula><formula xml:id="formula_99">≡∀m 0 ∀j 1 ∃x(Rj 0 j 1 → (j 0 = m 0 → ∀z(Rxz → ∃u(Rzu ∧ Rj 1 u)) ∧ x = m 0 )) (17) ≡∀j 1 (Rj 0 j 1 → ∀z(Rj 0 z → ∃u(Rzu ∧ Rj 1 u))),<label>(18)</label></formula><p>which defines the Church-Rosser confluence property, as expected.</p><p>Example 7.2. Consider the inductive inequality ✷(✁q ∨ p) ∧ ✷q ≤ ✸(p ∧ q) from Example 3.3. Recall also from Example 3.6 that this is not a Sahlqvist inequality. As in the previous example, no distribution, splitting or variable elimination rules are applicable during preprocessing. The preprocessing phase produces one initial system, namely,</p><formula xml:id="formula_100"> j 0 ≤ ✷(✁q ∨ p) ∧ ✷q, ✸(p ∧ q) ≤ m 0  .</formula><p>Applying the ∧-splitting rule produces</p><formula xml:id="formula_101"> j 0 ≤ ✷(✁q ∨ p), ✸(p ∧ q) ≤ m 0 j 0 ≤ ✷q  ,</formula><p>and the ✷-residuation rule transforms this into</p><formula xml:id="formula_102"> j 0 ≤ ✁q ∨ p, ✸(p ∧ q) ≤ m 0 j 0 ≤ q  .</formula><p>Applying the ∨-residuation rule yields</p><formula xml:id="formula_103"> j 0 -✁q ≤ p, ✸(p ∧ q) ≤ m 0 j 0 ≤ q  ,</formula><p>to which the right-handed Ackermann rule is now applicable to eliminate (e.g.) p, giving</p><formula xml:id="formula_104"> j 0 ≤ q, ✸(( j 0 -✁q) ∧ q) ≤ m 0  .</formula><p>Applying again the right-handed Ackermann rule to eliminate q yields  ✸(( j 0 -✁( j 0 )) ∧ ( j 0 )) ≤ m 0  .</p><p>Thus, as all propositional variables have been eliminated, the reduction-elimination cycle terminates successfully, yielding</p><formula xml:id="formula_105">Reduce(✷(✁q ∨ p) ∧ ✷q ≤ ✸(p ∧ q)) = {✸(( j 0 -✁( j 0 )) ∧ ( j 0 )) ≤ m 0 }. Hence, ALBA(✷(✁q ∨ p) ∧ ✷q ≤ ✸(p ∧ q)) = {(✸(( j 0 -✁( j 0 )) ∧ ( j 0 )) ≤ m 0 ) ⇒ j 0 ≤ m 0 }, from which ALBA FO (✷(✁q ∨ p) ∧ ✷q ≤ ✸(p ∧ q)</formula><p>) can be straightforwardly, if somewhat laboriously, computed.</p><p>Example 7.3. Consider the inequality ✷(✁q ∨ p) ≤ ✸p, which is positive in q; by applying the monotone-antitone variable elimination rule it transforms into ✷(✁⊥ ∨ p) ≤ ✸p. The first approximation rule now yields</p><formula xml:id="formula_106"> j 0 ≤ ✷(✁⊥ ∨ p), ✸p ≤ m 0  ;</formula><p>on applying the appropriate residuation rules, this system is rewritten as</p><formula xml:id="formula_107"> j 0 -✁⊥ ≤ p, p ≤ m 0  ,</formula><p>to which either Ackermann rule can be applied to eliminate p, giving { j 0 -✁⊥ ≤ m 0 } . Alternatively q could also have been eliminated from the system by adding the tautological inequality ⊥ ≤ q and applying the right Ackermann rule, as discussed in Remark 6.3.</p><p>Example 7.4. As specified, ALBA is amenable to various enhancements extending its range, through the addition of extra reduction rules. In the present example we will show how ALBA can be made to successfully compute a frame correspondent for the non-inductive IML inequality ✷((✷p → q) ∧ (q → ✷p)) ≤ p from Example 3.16. Indeed, the preprocessing phase produces one initial system</p><formula xml:id="formula_108"> j 0 ≤ ✷((✷p → q) ∧ (q → ✷p)), p ≤ m 0  .</formula><p>It is not difficult to see that solving first for p would lead to failure, so let us first solve for q. Applying the ✷-residuation and ∧-splitting rules turns it into</p><formula xml:id="formula_109"> j 0 ≤ ✷p → q, p ≤ m 0 j 0 ≤ q → ✷p  ,</formula><p>to which the ∧-residuation rule is applicable (in the reversed direction), which produces</p><formula xml:id="formula_110"> j 0 ∧ ✷p ≤ q, p ≤ m 0 j 0 ≤ q → ✷p  ,</formula><p>to which the right-hand Ackermann rule is applicable, yielding</p><formula xml:id="formula_111"> j 0 ≤ (( j 0 ∧ ✷p) → ✷p), p ≤ m 0  .</formula><p>Now, ( j 0 ∧ ✷p) → ✷p = ⊤ is a Heyting tautology. Allowing a rule that would implement this would change the above system into</p><formula xml:id="formula_112"> j 0 ≤ ⊤, p ≤ m 0  .</formula><p>The resulting inequalities are both negative (see Definition 4.1), and hence monotone, in p. A rule legislating the substitution of ⊤ for p in such cases (and ⊥ in cases where all inequalities are positive in p) is sound, and would yield</p><formula xml:id="formula_113"> j 0 ≤ ⊤, ⊤ ≤ m 0  .</formula><p>Notice that, by definition, completely meet-irreducible elements are never equal to ⊤. Hence, the second inequality above is always false. So, in accordance with what happens in the Boolean case for the classical projection of this example, the whole system and the input inequality are also always false, and hence canonical, x ̸ = x being their first-order frame correspondent.</p><p>Example 7.5. Consider Frege inequality p → (q → r) ≤ (p → q) → (p → r) from Example 3.16, which is an intuitionistic tautology. The preprocessing phase produces one initial system</p><formula xml:id="formula_114"> j 0 ≤ p → (q → r), (p → q) → (p → r) ≤ m 0  .</formula><p>We apply the →-approximation rule in the second coordinate to the second inequality to obtain</p><formula xml:id="formula_115"> j 0 ≤ p → (q → r), (p → q) → n ≤ m 0 p → r ≤ n  .</formula><p>We apply the →-approximation rule in the first coordinate to p → r ≤ n to obtain</p><formula xml:id="formula_116"> j 0 ≤ p → (q → r), (p → q) → n ≤ m 0 i ≤ p i → r ≤ n  .</formula><p>Now we can apply the right Ackermann rule to eliminate p:</p><formula xml:id="formula_117"> j 0 ≤ i → (q → r), (i → q) → n ≤ m 0 i → r ≤ n  .</formula><p>Another application of the →-approximation rule in the first coordinate, this time to (i → q) → n ≤ m 0 , yields</p><formula xml:id="formula_118"> j 0 ≤ i → (q → r), k → n ≤ m 0 k ≤ i → q i → r ≤ n  .</formula><p>Applying the ∧-residuation rule from bottom to top to k ≤ i → q gives</p><formula xml:id="formula_119"> j 0 ≤ i → (q → r), k → n ≤ m 0 k ∧ i ≤ q i → r ≤ n  ,</formula><p>to which the right Ackermann rule can be applied, eliminating q:</p><formula xml:id="formula_120"> j 0 ≤ i → ((k ∧ i) → r), k → n ≤ m 0 i → r ≤ n  .</formula><p>Applying the ∧-residuation rule from bottom to top twice to j 0 ≤ i → ((k ∧ i) → r) gives (after applying properties of ∧ for readability)</p><formula xml:id="formula_121"> j 0 ∧ k ∧ i ≤ r, k → n ≤ m 0 i → r ≤ n  .</formula><p>A last application of the right Ackermann rule yields the pure system</p><formula xml:id="formula_122"> k → n ≤ m 0 i → (j 0 ∧ k ∧ i) ≤ n  .</formula><p>Thus,</p><formula xml:id="formula_123">ALBA(p → (q → r) ≤ (p → q) → (p → r)) = ∀j 0 ∀m 0 ∀k∀n∀i[(k → n ≤ m 0 &amp; i → (j 0 ∧ k ∧ i) ≤ n) ⇒ j 0 ≤ m 0 ] ≡ ∀j 0 ∀k∀n∀i[i → (j 0 ∧ k ∧ i) ≤ n ⇒ ∀m 0 [k → n ≤ m 0 ⇒ j 0 ≤ m 0 ]] ≡ ∀j 0 ∀k∀n∀i[i → (j 0 ∧ k ∧ i) ≤ n ⇒ j 0 ≤ k → n] ≡ ∀j 0 ∀k∀n∀i[i → (j 0 ∧ k ∧ i) ≤ n ⇒ j 0 ∧ k ≤ n] ≡ ∀j 0 ∀k∀i[j 0 ∧ k ≤ i → (j 0 ∧ k ∧ i)] ≡ ∀j 0 ∀k∀i[j 0 ∧ k ∧ i ≤ j 0 ∧ k ∧ i] ≡ ⊤.</formula><p>Example 7.6. Consider the inequality ✷(✁q ∨ p) ≤ ✸(✄q ∧ p). No distribution, splitting or variable elimination rules are applicable during preprocessing. The preprocessing phase produces one initial system, namely</p><formula xml:id="formula_124"> j 0 ≤ ✷(✁q ∨ p), ✸(✄q ∧ p) ≤ m 0  .</formula><p>It is not difficult to see that the system can not be brought into a shape to which one of the Ackermann rules is applicable with respect to q -notice that no occurrence of q can be 'surfaced' by applying reduction rules. However, it can be transformed into the following Ackermann form:</p><formula xml:id="formula_125"> j 0 -✁q ≤ p, p ≤ ✄q → m 0  ,</formula><p>to which either Ackermann rule can be applied to eliminate p, giving { j 0 -✁q ≤ ✄q → m 0 } , which leads to failure.</p><p>Example 7.7. Early on (cf. Subsection 3.4 and Remark 6.2), we discussed how ALBA can be modified and adapted syntactically to different logics; we conclude this section with an example illustrating how to adapt ALBA to different semantic contexts. Some aspects of the discussion which will follow are relevant to the open questions raised in [27, <ref type="bibr">Section 3]</ref>, where analogous developments are discussed from a model-theoretic viewpoint. In particular, in [27, Section 3.2] correspondence is considered for some formulas belonging to the implicative fragment of intuitionistic logic, including Pierce's law ((p → q) → p) → p, and for relevant implication interpreted on ternary frames. The implicit assumption of that discussion is that correspondence theory should be developed from scratch in each of these contexts. In fact, the algebraic approach of this paper makes possible a unification of what would otherwise be different correspondence theories. Indeed, the ALBA reduction/elimination steps are sound in the setting of perfect distributive lattice expansions, which can be characterized in purely algebraic terms and independently of their dual concrete incarnations as relational structures; the outcome of the reduction/elimination process can be then further translated so as to fit different relational environments. To illustrate this concretely, let us consider Pierce's law: as the reader can easily check, feeding</p><formula xml:id="formula_126">(p → q) → p ≤ p to ALBA produces ∀j∀m[j ≤ (m → ⊥) → m ⇒ j ≤ m], which can be further reduced to ∀m[(m → ⊥) → m ≤ m].</formula><p>Let us now interpret it on partial orders (with up-sets interpreting formulas):</p><formula xml:id="formula_127">∀m[(m → ⊥) → m ≤ m] iff ∀w[((w↓ c ∩ ∅ c )↓ c ∩ w↓ cc )↓ c ⊆ w↓ c ] iff ∀w[w↓ ⊆ ((w↓ c ∩ ∅ c )↓ c ∩ w↓)↓] iff ∀w[w↓ ⊆ ((w↓ c )↓ c ∩ w↓)↓] iff ∀w[w ∈ ((w↓ c )↓ c ∩ w↓)↓] iff ∀w∃u[w ≤ u &amp; u ∈ (w↓ c )↓ c ∩ w↓)] iff ∀w∃u[w ≤ u &amp; u ≤ w &amp; u ∈ (w↓ c )↓ c ] iff ∀w[w ∈ (w↓ c )↓ c ] iff ∀w[w / ∈ (w↓ c )↓] iff ∀w∀v[v / ∈ w↓ ⇒ w ̸ ≤ v] iff ∀w∀v[v ̸ ≤ w ⇒ w ̸ ≤ v] iff ∀w∀v[w ≤ v ⇒ v ≤ w].</formula><p>Thus, as discussed in <ref type="bibr">[27,</ref> Example 78], we see that Pierce's law takes us to classical propositional logic, by constraining the ordering on intuitionistic frames to be discrete. Pierce's law (as well as any other axiom in the implicative fragment of intuitionistic logic) can be alternatively interpreted on ternary frames, as they are defined e.g. in <ref type="bibr" target="#b19">[20]</ref>, where a Kripkean semantics is employed for the non-associative Lambek calculus, and a restricted Sahlqvist theorem is proven. A suitably modified version of ALBA can be applied to the Lambek calculus as well, so as to greatly improve the Sahlqvist theorem in <ref type="bibr" target="#b19">[20]</ref>, but this is discussed in <ref type="bibr" target="#b6">[7]</ref>. Here, we limit ourselves to discussing the correspondence of the Pierce's axiom on ternary frames. A ternary frame (cf. [20, <ref type="bibr">Definition 1]</ref>) is a structure</p><formula xml:id="formula_128">(W , R) such that W is a nonempty set and R is a ternary relation on W . For all X , Y ⊆ W , let R[Y , X ] = {z | ∃x∃y[x ∈ Y &amp; y ∈ X &amp; R(xyz)]}.</formula><p>Implication can be interpreted on ternary frames as follows: for all X , Y ⊆ W ,</p><formula xml:id="formula_129">X =⇒ Y = {z | ∀x∀y[(R(xyz) &amp; y ∈ X ) ⇒ x ∈ Y ]} = R[Y c , X ] c .</formula><p>Valuations send proposition letters to arbitrary subsets of the universe of ternary frames. Thus, for the purpose of this example we let the complex algebra of the ternary frame (W , R) be the perfect implicative algebra (P (W ), ∅, =⇒). As to the expanded language, =⇒ is the right adjoint in its second coordinate to the binary connective • (fusion), defined by</p><formula xml:id="formula_130">Y • Z := {x | ∃y∃z[y ∈ Y &amp; z ∈ Z &amp; R(x,</formula><p>y, z)]}; nominals and co-nominals range as usual in the set of the completely join-prime and meet-prime elements of the complex algebra, which in this case coincide with the sets of its atoms and of its co-atoms respectively. Now let us consider Pierce's law, interpreted with this semantics. As before, ALBA reduces it to ∀m[(m → ⊥) → m ≤ m], and up to this point, the reduction proceeds in exactly the same way as in the previous case; this is sound because complex algebras both of this interpretation and of the previous one are based on perfect distributive lattices. Let us abuse notation and write w c for {w}</p><formula xml:id="formula_131">c = W \ {w}. Now, ∀m[(m → ⊥) → m ≤ m] iff ∀w[R[w cc , R[∅ c , w c ] c ] c ⊆ w c ] iff ∀w[w ∈ R[{w}, R[W , w c ] c ]] iff ∀w∃x∃y[R(xyw) &amp; y ∈ R[W , w c ] c &amp; x = w] iff ∀w∃y[R(wyw) &amp; y ∈ R[W , w c ] c ] iff ∀w∃y[R(wyw) &amp; ∀x∀z[R(xzy) ⇒ z = w]].</formula><p>Notice that, in the more familiar case in which fusion coincides with meet, the ternary relation which dually represents the binary map given by (U,</p><formula xml:id="formula_132">V )  → U ∩ V is R = {(x, x, x) | x ∈ W }; in this case, X =⇒ Y reduces to the classical X c</formula><p>∪ Y and the first-order clause above is always true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Correctness of ALBA</head><p>In this section we prove that ALBA is correct, in the sense that whenever it succeeds in eliminating all propositional variables from an inequality ϕ ≤ ψ, the first-order formula returned is locally equivalent on DML frames to ϕ ≤ ψ.</p><formula xml:id="formula_133">Fix a DML frame F = (W , ≤, R ✸ , R ✷ , R ✁ , R ✄ , ) and a state w ∈ W . For any ξ ∈ L + term ∪ L + ∪ L +</formula><p>quasi , we use the notation F (j 0 := w↑) ξ to indicate that F , V ξ for all valuations V which send the nominal variable j 0 to w↑ -a type of parametrized validity. For two valuations V and V ′ , we will also write</p><formula xml:id="formula_134">V = {j 0 ,m 0 } V ′ to indicate that V (j 0 ) = V ′ (j 0 ) and V (m 0 ) = V ′ (m 0 )</formula><p>. We first give the statement of the correctness theorem and its proof, and subsequently prove the two lemmas needed in the proof. Proof. Consider the chain of statements <ref type="bibr" target="#b18">(19)</ref> to <ref type="bibr" target="#b23">(24)</ref> below. Note that <ref type="bibr" target="#b21">(22)</ref> is by definition equivalent to F , w ALBA(ϕ ≤ ψ). The proof will be complete if we can show that <ref type="bibr" target="#b18">(19)</ref> to <ref type="bibr" target="#b23">(24)</ref> are equivalent.</p><formula xml:id="formula_135">F , w ϕ ≤ ψ (19) F , w Preprocess(ϕ ≤ ψ) (20) F (j 0 := w↑) (j 0 ≤ ϕ ′ &amp; ψ ′ ≤ m 0 ) ⇒ j 0 ≤ m 0 for all ϕ ′ ≤ ψ ′ ∈ Preprocess(ϕ ≤ ψ)<label>(21)</label></formula><formula xml:id="formula_136">F (j 0 := w↑) Reduce(ϕ ′ ≤ ψ ′ ) ⇒ j 0 ≤ m 0 for all ϕ ′ ≤ ψ ′ ∈ Preprocess(ϕ ≤ ψ)<label>(22)</label></formula><formula xml:id="formula_137">F |= ∀m 0 ∀j∀m  ∀xST x (Reduce(ϕ ′ ≤ ψ ′ )) → ∀xST x (j 0 ≤ m 0 )  [j 0 := w]<label>(23)</label></formula><p>for all ϕ ′ ≤ ψ ′ ∈ Preprocess(ϕ ≤ ψ), and where j and m are the vectors of all nominals and co-nominals, respectively, occurring in Reduce(ϕ</p><formula xml:id="formula_138">′ ≤ ψ ′ ) F |= ALBA FO (ϕ ≤ ψ)[j 0 := w]. (<label>24</label></formula><formula xml:id="formula_139">)</formula><p>The equivalence between ( <ref type="formula">19</ref>) and ( <ref type="formula">20</ref>) is given by Lemma 8.3. The implication from ( <ref type="formula">20</ref>) to ( <ref type="formula" target="#formula_135">21</ref>) is immediate, while for the converse we may argue as follows: Suppose that for some inequality ϕ ′ ≤ ψ ′ ∈ Preprocess(ϕ ≤ ψ) and some valuation</p><formula xml:id="formula_140">V on F , (F , V ), w ̸ ϕ ′ ≤ ψ ′ . Then w ∈ V (ϕ ′ ) but w ̸ ∈ V (ψ ′ ), i.e., w↑ ⊆ V (ϕ ′ ) but w↑ ̸ ⊆ V (ψ ′ ). But then w↑ ̸ ≤  {b ∈ M ∞ | V (ψ ′ ) ≤ b}. But this is the case iff there exists b 0 ∈ {b ∈ M ∞ | V (ψ ′ ) ≤ b} such that w↑ ̸ ≤ b 0 .</formula><p>Then the valuation V ′ obtained as the {j 0 , m 0 }-variant of V which sends j 0 to w↑ and m 0 to b 0 falsifies (j 0 ≤ ϕ ′ &amp;ψ ′ ≤ m 0 ) → j 0 ≤ m 0 on F (j 0 := w↑).</p><p>Now for the bi-implication between ( <ref type="formula" target="#formula_135">21</ref>) and <ref type="bibr" target="#b21">(22)</ref>. Assume <ref type="bibr" target="#b20">(21)</ref>, and let V be any valuation such that V (j 0 ) = w↑ and F , V</p><formula xml:id="formula_141">Reduce(ϕ ′ ≤ ψ ′ ). Since Reduce(ϕ ′ ≤ ψ ′ ) is obtained from {j 0 ≤ ϕ ′ , ψ ′</formula><p>≤ m 0 } by the application of reduction rules, it follows from Lemma 8.4.2 that there is a valuation</p><formula xml:id="formula_142">V ′ = {j 0 ,m 0 } V such that F , V ′ {j 0 ≤ ϕ ′ , ψ ′</formula><p>≤ m 0 } and hence, by <ref type="bibr" target="#b20">(21)</ref>, that F , V ′ j 0 ≤ m 0 . Lastly, since V ′ = {j 0 ,m 0 } V we have F , V j 0 ≤ m 0 . The proof of the implication from <ref type="bibr" target="#b21">(22)</ref> to ( <ref type="formula" target="#formula_135">21</ref>) is symmetric if one uses Lemma 8.4.1.</p><p>Lastly, the bi-implication between ( <ref type="formula" target="#formula_136">22</ref>) and ( <ref type="formula" target="#formula_137">23</ref>) follows by Lemma 2.17, while that between ( <ref type="formula" target="#formula_137">23</ref>) and ( <ref type="formula" target="#formula_138">24</ref>) follows by the definition of ALBA FO (ϕ ≤ ψ).</p><p>Remark 8.2. It must be pointed out that the proof of the equivalence of ( <ref type="formula">19</ref>) to <ref type="bibr" target="#b21">(22)</ref> given in the proof of Theorem 8.1 goes through almost unaltered for descriptive frames G (and hence admissible valuations) instead of frames F . Indeed, as far as the lemmas used in the proof are concerned, Lemma 8.3 holds for all DMA's and hence for all descriptive frames, while cases treated for the residuation and approximation rules in Lemma 8.4 go through unchanged. The only problem is the case for the justification for the Ackermann rule. This rule is clearly sound on descriptive frames, but it is in general not invertible. We will need special restricted versions of the Ackermann lemmas for this rule (Lemmas 9.3 and 9.4, below).</p><p>Lemma 8.3. Assume that a set of L-inequalities S ′ is obtained from a set S by the application of preprocessing rules. Then</p><formula xml:id="formula_143">F , w S iff F , w S ′ .</formula><p>Proof. It is sufficient to check that validity is invariant under the application of each preprocessing rule. For the distribution and splitting rules this is immediate by the semantics of L. As for the monotone variable elimination rule, suppose α(p) ≤ β(p) is positive (cf. Definition 4.1) in p. Given a valuation V on F , let V 0 ∼ p V be the p-variant of V sending p to ∅. Then, by the monotonicity of α(p) ≤ β(p) in p, we have that (F ,</p><formula xml:id="formula_144">V 0 ), w α(p) ≤ β(p) implies (F , V ), w α(p) ≤ β(p). Also, (F , V 0 ), w α(p) ≤ β(p) iff (F , V ), w α(⊥) ≤ β(⊥). Hence, F , w α(⊥) ≤ β(⊥) implies F , w α(p) ≤ β(p). Conversely, F , w α(p) ≤ β(p) clearly implies (F , V 0 ), w α(p) ≤ β(p), which is equivalent to (F , V ), w α(⊥) ≤ β(⊥).</formula><p>The case of the antitone variable elimination rule is dual.</p><p>Lemma 8.4. Let S be a finite system of inequalities and S ′ a system of inequalities obtained from S through the application of reduction rules, and let V be any valuation. Then</p><formula xml:id="formula_145">1. if F , V S then F , V ′ S ′ for some valuation V ′ = {j 0 ,m 0 } V , and 2. if F , V S ′ then F , V ′ S for some valuation V ′ = {j 0 ,m 0 } V . Proof.</formula><p>By the transitivity of the = {j 0 ,m 0 } -relation, it suffices to check that the claim holds in the special case in which S ′ is obtained from S by a single application of a rule.</p><p>The cases for the residuation rules follow from the fact that, for any inequality ϕ ′ ≤ ψ ′ obtained from ϕ ≤ ψ by the application of a residuation rule, F , V ϕ ≤ ψ iff F , V ϕ ′ ≤ ψ ′ , for any valuation V , as justified in Subsection 2.5.</p><p>As for the approximation rules, the quickest way to verify that these rules preserve the desired equivalence is to think of them in the setting of the complex algebra F + . Recall that this is a perfect DMA with sets J ∞ and M ∞ of join-prime and meet-prime elements, respectively.</p><p>✸-approximation rule: we have that</p><formula xml:id="formula_146">V (i) ≤ ⟨R ✸ ⟩V (ϕ) iff V (i) ≤ ⟨R ✸ ⟩  {a ∈ J ∞ | a ≤ V (ϕ)} iff V (i) ≤  {⟨R ✸ ⟩(a) | a ∈ J ∞ , a ≤ V (ϕ)}. Since V (i) is join-prime, the latter is the case iff V (i) ≤ ⟨R ✸ ⟩(a 0 ) for some a 0 ∈ {a ∈ J ∞ | a ≤ V (ϕ)}.</formula><p>We can thus take V ′ to be the j-variant of V such that V ′ (j) = a 0 . Since the nominal j introduced by the rule must be new, j is different from j 0 (and from the co-nominal m 0 ), and hence, V = {j 0 ,m 0 } V ′ .</p><p>To prove the second item, suppose that V (j) ≤ V (ϕ) and V (i) ≤ ⟨R ✸ ⟩V (j). But then, by the monotonicity of ⟨R ✸ ⟩, we have V (i) ≤ ⟨R ✸ ⟩V (ϕ). Hence, we can take V ′ = V .</p><p>✷-approximation rule: the proof is order dual to the proof of the ✸-approximation rule.</p><p>✁-approximation rule: let us abbreviate ⟨R ✁ ] as ✁. We have that</p><formula xml:id="formula_147">V (i) ≤ ✁V (ϕ) iff V (i) ≤ ✁  {b ∈ M ∞ | V (ϕ) ≤ b}. The latter is the case iff V (i) ≤  {✁b | b ∈ M ∞ , V (ϕ) ≤ b}. Now since V (i)</formula><p>is join-prime, the latter is the case iff there exists b 0 ∈ M ∞ such that V (ϕ) ≤ b 0 and V (i) ≤ ✁b 0 . The desired valuation V ′ can then be taken to be the m-variant of V which sends m to (the up-set corresponding to) b 0 .</p><p>To prove the second item, suppose that V is such that V (ϕ) ≤ V (m) and V (i) ≤ V (✁m). Then, by the antitonicity of ✁, it follows that V (i) ≤ V (✁ϕ). V ′ can thus be taken to be V .</p><p>✄-approximation rule: the proof is order dual to the proof of the ✁-approximation rule.</p><p>The cases for the Ackermann rules are given by Lemmas 4.2 and 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Canonicity</head><p>In this section, we will show that every L-inequality ϕ ≤ ψ on which ALBA succeeds is locally d-persistent, and hence canonical. For the rest of this section, fix a descriptive general frame G = (F , τ ), and with A the DML algebra of clopen upsets of τ (Definition 2.8). Our strategy will be to prove ''canonicity via correspondence'', and can be summarized as follows: we know from Theorem 8.1 that G ♯ , w ϕ ≤ ψ iff G ♯ (j 0 := w↑)</p><formula xml:id="formula_148">Reduce(ϕ ′ ≤ ψ ′ ) ⇒ j 0 ≤ m 0 for all ϕ ′ ≤ ψ ′ ∈ Preprocess(ϕ ≤ ψ)</formula><p>. By the assumption of success, the (ϕ ′ ≤ ψ ′ )'s are pure, and because, as far as pure formulas are concerned, there is no difference between admissible and arbitrary valuations, this transfers to G, yielding</p><formula xml:id="formula_149">G(j 0 := w↑) Reduce(ϕ ′ ≤ ψ ′ ) ⇒ j 0 ≤ m 0 .</formula><p>Hence, if we could prove the equivalence of ( <ref type="formula">19</ref>) to ( <ref type="formula" target="#formula_136">22</ref>), but replacing F with G, we would be done. As already indicated in Remark 8.2, the proof of Theorem 8.1 would serve almost unchanged, except Ackermann's lemmas. Indeed, consider for instance the proof of the right Ackermann's lemma. While the implication from bottom to top stands as it is when relativized to admissible valuations, for the implication from top to bottom we are in trouble: indeed we are not able to guarantee that V ′ (p) := V (  n i=1 α i ) gives an admissible valuation. This is because the α i are terms in the expanded language L + , and therefore may contain nominals, co-nominals, or adjoint operations, under which the subalgebra A of the admissible sets is not in general closed. So, in order for the proof to go through, we would need</p><formula xml:id="formula_150">s ω + 1 ☛ s ω ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✸ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✸ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✑ ✸ R ✁ s 2 ✁ ✁ ✁ ✁ ✁ ✁ ✕ ✁ ✁ ✁ ✁ ✁ ✁ ✕ R ✁ s 1 ❆ ❆ ❆ ❆ ❆ ❆ ❑ ❆ ❆ ❆ ❆ ❆ ❆ ❑ R ✁ s 0 ◗ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ❦ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ❦ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ◗ ❦ R ✁ ' &amp; $ % transitive • • • ✲ ✲ ■ Fig. 1. Unlabelled arrows belong to both R ✸ and R ✁ .</formula><p>to be able to produce a suitable admissible subset P ∈ A, large enough to contain V (  n i=1 α i ), but approximating V (  n i=1 α i ) accurately enough so as not to destroy the satisfaction of the inequality β(α) ≤ γ (α), when the term α is 'collapsed' to the variable p, and evaluated as P. This is a non-trivial demand, and it is not always possible to meet it, as is illustrated in the following example.</p><p>Example 9.1. Let α := q, β(p) = p and γ (p) = p and consider the descriptive general frame G = (F , τ ) where</p><formula xml:id="formula_151">F = (W , =, R ✸ , R ✁ ) is the frame pictured in Fig. 1. Here W = N ∪ {ω, ω + 1}; R ✸ is {(ω + 1, ω), (ω, ω)} ∪ {(ω, n) | n ∈ N} ∪ {(n, m) | n, m ∈ N, n ≥ m}; R ✁ = R ✸ ∪ {(n, ω + 1) | n ∈ N} ∪ {(ω, ω + 1)}. Let τ be the topology with a basis of clopens A, where A = {X 1 ∪ X 2 ∪ X 3 | X i ∈ X i , i = 1, 2, 3}</formula><p>, where X 1 contains all finite (possibly empty) sets of natural numbers, X 2 contains ∅ and all sets of the form {x ∈ N | n ≤ x ≤ ω} for all n ∈ ω, and X 3 = {∅, {ω + 1}}. 9 Thus A is the set of admissible sets. It is not difficult to check that G is a descriptive general frame.</p><formula xml:id="formula_152">Let V (q) = N ∪ {ω}, which is admissible. Then V (α) = V ( q) = {x | ∀y(yR ✸ x ⇒ y q)} = W \ {ω} / ∈ A, and V ( q) = {x | ∀y(yR ✸ x ⇒ y ∈ V ( q))} = {ω + 1}. Also V ( q) = {x | ∃y(yR ▹ x &amp; y ̸ ∈ V ( q))} = {x | ωR ▹ x} = W , which implies that G, V β(α/p) ≤ γ (α/p). On the other hand, the only admissible p-variant V ′ of V such that G, V ′ α ≤ p, i.e., such that V ′ (α) = V (α) = W \ {ω} ⊆ V ′ (p), is the one which sends p to W = ⊤. For this valuation, we have V ′ (β(p)) = ⊤ = ⊤, and V (γ (p)) = ⊤ = ⊥, and hence G, V ′ ̸ β(p) ≤ γ (p).</formula><p>Example 9.1 shows that the right Ackermann lemma does not hold, as stated, on descriptive general frames. Analogous considerations apply to the left Ackermann lemma. On the other hand, as we will see, restricted versions of the Ackermann lemmas do hold for descriptive general frames, which require restrictive assumptions on the syntactic shape of the α's, β's, and γ 's. These restrictions are designed to make crucial use of the topo-algebraic notion of compactness so as to guarantee the existence of a suitable admissible approximating subset as outlined in the discussion above. The technical details of this will become clear later; to set the stage, we need to introduce the following notions: Definition 9.2. An L + term -formula is syntactically closed if, in it, all occurrences of nominals, , andare positive, while all occurrences of co-nominals, , , and → are negative.</p><p>Similarly, an L + term -formula is syntactically open if, in it, all occurrences of nominals, , , andare negative, while all occurrences of co-nominals, , , and → are positive. Note that ϕ is syntactically closed iff ✁ϕ, ✄ϕ, and ϕ are syntactically open. Also, ϕ is syntactically open iff ✁ϕ, ✄ϕ, and ϕ are syntactically closed. Considering the binary operationsand →, the formula ϕ → ψ is syntactically open iff ϕ is syntactically closed and ψ is syntactically open; ϕ-ψ is syntactically closed iff ϕ is syntactically closed and ψ is syntactically open.</p><p>The notions of syntactic openness and closedness enable us to formulate the following versions of the Ackermann lemmas that hold on descriptive frames. The proofs are highly technical and have been relegated to the appendix. The gist of the proof is that, under any admissible valuation, the extension of any syntactically closed (open) formula is a closed (open) subset. Thus, e.g., inequality <ref type="bibr" target="#b24">(25)</ref> in Lemma 9.3 is interpreted as an inclusion of an intersection of admissible sets into a union of admissible sets, to which inclusion compactness can be applied to obtain the admissible witness, as in the discussion above. The notation used was introduced at the end of Section 2.5.1. </p><formula xml:id="formula_153">β i V p (α(V )) ≤ γ i V p (α(V )), for all 1 ≤ i ≤ n (25)</formula><p>iff there exists P ∈ A such that α(V ) ≤ P and</p><formula xml:id="formula_154">β i V p (P) ≤ γ i V p (P), for all 1 ≤ i ≤ n.</formula><p>9 G is a variation of a (Boolean) general frame given in example 8.52 in <ref type="bibr" target="#b3">[4]</ref>. </p><formula xml:id="formula_155">β i V p (α(V )) ≤ γ i V p (α(V )</formula><p>), for all 1 ≤ i ≤ n iff there exists P ∈ A such that P ≤ α(V ) and β i V p (P) ≤ γ i V p (P), for all 1 ≤ i ≤ n. Lemma 9.5. In every non-pure inequality ϕ ′ ≤ ψ ′ obtained when ALBA is run on an inequality ϕ ≤ ψ ∈ L, the left-hand side ϕ ′ is always syntactically closed while the right-hand side ψ ′ is always syntactically open.</p><p>Proof. Since ϕ ≤ ψ comes from the base language L, it is immediate that ϕ and ψ are both syntactically open and closed. Since preprocessing does not introduce any symbols not in L, the formulas ϕ ′ and ψ ′ are both syntactically open and closed, for each inequality ϕ ′ ≤ ψ ′ ∈ Preprocess(ϕ ≤ ψ). Applying the first approximation rule yields j 0 ≤ ϕ ′ and ψ ′ ≤ m 0 , which clearly satisfy the requirements of the lemma. In order to complete the proof, it now remains to check that each reduction rule preserves the desired syntactic shape. Since this is straightforward, we will only consider explicitly, by way of illustration, the case for the right-hand Ackermann rule. This rule transforms a system</p><formula xml:id="formula_156">{α 1 ≤ p, . . . , α n ≤ p, β 1 ≤ γ 1 , . . . , β m ≤ γ m } into {β 1 (α/p) ≤ γ 1 (α/p), . . . , β m (α/p) ≤ γ m (α/p)}, where α = α 1 ∨ • • • ∨ α n .</formula><p>Firstly, note that all the pure inequalities among the β i ≤ γ i remain unaffected by the rule, and hence remain pure. For non-pure β i ≤ γ i , we have by assumption that β i is syntactically closed and positive in p while γ i is syntactically open and negative in p. Thus, in β i (α/p) each occurrence of a symbol within any occurrence of the subformula α has the same polarity as it had in α before substitution. Hence, since α is syntactically closed, β i (α/p) is syntactically closed. Similarly, in γ i (α/p) any occurrence of a symbol within each occurrence of the subformula α has the polarity opposite to that which it had in α before substitution. Hence, γ i (α/p) is syntactically open.</p><p>Remark 9.6. Note that the restriction to non-pure inequalities in Lemma 9.5 is essential, since none of the pure inequalities i ≤ ✸j, ✷n ≤ m, i ≤ ✁m, and ✄i ≤ m introduced by the approximation rules satisfies the requirement of the lemma.</p><p>For the rest of this subsection, also fix a state w in the descriptive frame G.</p><p>Theorem 9.7 (Correctness of ALBA on Descriptive Frames). If ALBA succeeds in reducing an inequality ϕ ≤ ψ ∈ L and yields ALBA(ϕ ≤ ψ), then G, w ϕ ≤ ψ iff G(j 0 := w↑) ALBA(ϕ ≤ ψ).</p><p>Proof. It has already been indicated in Remark 8.2 that the proof is essentially the same as that of Theorem 8.1. It was also indicated that the only difficulty that arises in the case of descriptive frames is that the Ackermann rules are generally not invertible on descriptive frames (Example 9.1). However, by Lemmas 9.3 and 9.4, in the special case where the left-and right-hand sides of all inequalities involved in the application of an Ackermann rule are, respectively, syntactically closed and open, the rule is sound and invertible on descriptive frames. But by Lemma 9.5 this requirement on the syntactic shape is always satisfied when the rule is applied.</p><p>Theorem 9.8. All ALBA inequalities are (locally) d-persistent, and hence canonical.</p><p>Proof. Let ϕ ≤ ψ be an ALBA inequality. Let Val and AdVal be the sets of all valuations and admissible valuation on G ♯ and G, respectively, and let Val(j 0 := w) and AdVal(j 0 := w) be the sets of all valuations and admissible valuation on G ♯ and G which send j 0 to w↑, respectively. The proof is then summarized in the following U-shaped diagram:</p><formula xml:id="formula_157">G, w ϕ ≤ ψ G ♯ , w ϕ ≤ ψ ⇕ ⇕ G, V ′ , w ϕ ≤ ψ G ♯ , V , w ϕ ≤ ψ for all V ′ ∈ AdVal for all V ∈ Val ⇕ ⇕ G, V ′ ALBA(ϕ ≤ ψ), ⇔ G ♯ , V ALBA(ϕ ≤ ψ), for all V ′ ∈ AdVal(j 0 := w) for all V ∈ Val(j 0 := w)</formula><p>The bi-implications on the level are given by the definitions of validity on descriptive frames and frames. Those appearing one level down are given by Theorems 8.1 and 9.7. The horizontal bi-implication follows from the facts that, by assumption, ALBA(ϕ ≤ ψ) is pure, and that, when restricted to pure formulas, the ranges of admissible and arbitrary valuations coincide. Case 1 A subformula α ∧ (β ∨ γ ) was replaced by (α ∧ β) ∨ (α ∧ γ ). The effect of this on the generation tree is graphically illustrated in Fig. <ref type="figure" target="#fig_5">2</ref>(a). We claim that this could not have created any bad paths. Indeed, the subtrees corresponding to α, β and γ remain unchanged. After distribution, all variable nodes in β and γ have the same ancestors in the tree and in the same order, except for the fact that the order of a +∨-node and +∧-node has been swapped, which cannot change a good path into a bad one. On all paths from variable nodes in α, a new choice node, namely +∨, has been introduced. But by the assumptions on the application of distribution, this +∨-node was not, and hence in the resulting tree is not, in the scope of any universal node. We conclude that no bad path from a variable node in α could have been created by the distribution. Case 2 A subformula ✸(α ∨ β) was replaced by ✸α ∨ ✸β. The corresponding generation trees are given in Fig. <ref type="figure" target="#fig_5">2(b)</ref>. The only paths from variable nodes to the root of the distribution tree affected by this are those from variable nodes in α and β. But on these paths all that has happened is that two consecutive choice nodes have been swapped. This cannot introduce any bad paths.</p><p>Case 3 A subformula ✄(α ∨ β) was replaced by ✄α ∧ ✄β. These generation trees are given in Fig. <ref type="figure" target="#fig_5">2(c</ref>). Apart from the fact that +∨ changes into -∧ the argument is the same as for case 2. It should also be clear that none of the monotone/antitone variable elimination rules can destroy ϵ-inductiveness, since, by eliminating variables, potential bad paths are eliminated, and certainly not introduced. Thus, having established that s i ≤ t i is an (Ω, ϵ)-inductive inequality, it only remains to show that it is definite. In the generation tree of +s i , let us consider any ϵ-critical branch and let c be the binary choice node closest to the root on this branch -if there are no binary choice nodes on the branch there is nothing to prove. We claim that c satisfies condition 2 of Definition 10.2. If c is the root, it must be +∨ -it cannot be -∧ since we are considering the positive generation tree. But this cannot be the case, because otherwise the ∨-splitting rule would have been applied during the preprocessing to eliminate c. Thus, c cannot be the root. Therefore, c must have a parent node in the tree. Since +s i is (Ω, ϵ)-inductive, in order to prove our claim, it is enough to show that c (being a binary choice node) is in the scope of some universal node. Suppose, to the contrary, that c is not in the scope of any universal node; then the parent node of c must be either of the type +✸, -✄, or +∧ (in the case where c is +∨), or of the type -✷, +✁, or -∨ (in the case where c is -∧). But once again this leads to a contradiction with the assumption that preprocessing has been exhaustively performed upon s i ≤ t i . We therefore conclude that c must have a universal node as ancestor. As for the lower binary choice nodes on the same branch, they are already in the scope of universals, since c is (in the scope of some universal); so the assumption of +s i being (Ω, ϵ)-inductive again implies the claim also for these nodes.</p><p>Moreover, no unary choice node on the branch can be in the scope of a binary choice node. Indeed, c is the topmost binary choice node and is in the scope of a universal node, so any such unary choice node would be in the scope of c's universal ancestor, contradicting the fact that +s i is (Ω, ϵ)-inductive.</p><p>The case for the negative generation tree of t i is similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10.5 (Definite Good Shape</head><p>). An inequality s ≤ t ∈ L + is in definite (Ω, ϵ)-good shape if either of the following conditions hold:</p><p>1. s is pure, +t is definite (Ω, ϵ)-inductive and moreover, if +t contains a unary choice node on an ϵ-critical branch, then s is a nominal. <ref type="foot" target="#foot_4">10</ref>2. t is pure, -s is definite (Ω, ϵ)-inductive and moreover, if -s contains a unary choice node on an ϵ-critical branch, then t is a co-nominal.</p><p>Clearly, if an inequality s ≤ t is definite (Ω, ϵ)-inductive, then the two inequalities obtained by applying the first approximation rule to it are in definite (Ω, ϵ)-good shape. Next, we would like to prove a 'good-shape lemma' for definite inductive inequalities. In particular, we would like to show that the application of the reduction rules does not spoil good shape. Actually the application the following rules might spoil good shape:</p><formula xml:id="formula_158">x ∧ y ≤ z x ≤ y → z z ≤ y ∨ x z -y ≤ x</formula><p>This happens, e.g., when z is pure and y is not. A solution to this is provided by allowing only applications of the rules above which are restricted to the cases in which the term y that switches sides is pure. Lemma 10.6. If s ≤ t is in definite (Ω, ϵ)-good shape, then any inequality s ′ ≤ t ′ obtained from s ≤ t, by either the application of a splitting rule, of an approximation rule, or of a residuation rule for a unary connective from top to bottom, or of the restricted application of a residuation rule for a binary connective from top to bottom, is again in definite (Ω, ϵ)-good shape.</p><p>Proof. We will only treat the case in which s ≤ t is such that s is pure and t is definite (Ω, ϵ)-left inductive, the other, in which t is pure and s is definite (Ω, ϵ)-right inductive, being perfectly symmetric. We may assume that the positive generation tree of t contains 'critical' nodes, i.e., nodes +p i such that ϵ i = 1 or -p i such that ϵ i = ∂. If not, the proof becomes trivial.</p><p>Which rule is applicable is determined by the root of the positive generation tree of t. If the root is universal, it must be either +✷ or +✄, i.e., t is either of the form ✷t ′ or ✄t ′ . In the first case, the ✷-residuation rule is the only applicable rule and yields s ≤ t ′ . Now clearly s contains no propositional variables and t ′ is definite (Ω, ϵ)-left inductive. Since s is not a nominal, to prove that s ≤ t ′ is in definite (Ω, ϵ)-good shape, it remains to show that +t ′ contains no unary choice node on an ϵ-critical branch. Indeed, if +t ′ contained such a node, that would imply the existence of a unary choice node on an ϵ-critical branch in +t with a +✷-node as ancestor, contradicting the assumption that +t is (Ω, ϵ)-inductive. Hence, s ≤ t ′ is in definite (Ω, ϵ)-good shape.</p><p>In the second case, the inequality is of the form s ≤ ✄t ′ , and the ✄-residuation rule is applicable and yields t ′ ≤ s.</p><p>Clearly s is pure. Note that the negative generation tree of t ′ is obtained by simply removing the root from the positive generation tree of ✄t ′ . Hence, -t ′ is definite (Ω, ϵ)-inductive. Further, as above, we can prove that -t cannot contain any unary choice node on an ϵ-critical branch. Hence, we conclude that t ′ ≤ s is in definite (Ω, ϵ)-good shape. Next, consider the case where the root of +t is a choice node, i.e., it is either +∨, +✸, or +✁. If it is +∨, then +t = +t 1 ∨t 2 . Moreover, if the ∨-residuation is applicable in its restricted form, then (we can assume w.l.o.g. that) t 1 is pure. So the rule yields st 1 ≤ t 2 . Clearly st 1 is pure and t 2 is definite (Ω, ϵ)-left inductive. Moreover, +t 2 cannot contain a unary choice node on an ϵ-critical branch, for in +t that unary choice node would have the binary choice node +∨ as an ancestor, contradicting the fact that +t is definite (Ω, ϵ)-inductive.</p><p>If the root of +t is +✸ or +✁, then, because s ≤ t is in (Ω, ϵ)-good shape, we have that s = j for some nominal j. So s ≤ t is either j ≤ ✸t ′ or j ≤ ✁t ′ .</p><p>In the first case, application of the ✸-approximation rule replaces j ≤ ✸t ′ with the inequalities j ≤ ✸k and k ≤ t ′ . It is immediate that these equations are in definite (Ω, ϵ)-good shape.</p><p>In the second case, application of the ✁-approximation rule replaces j ≤ ✁t ′ with the inequalities t ′ ≤ m and j ≤ ✁m. The latter, being pure, is trivially in (Ω, ϵ)-good shape. As above, the fact that -t ′ is definite (Ω, ϵ)-inductive follows from the facts that +✁t ′ is definite (Ω, ϵ)-inductive and that -t ′ is obtained by deleting the root of +✁t ′ . Hence, t ′ ≤ m is in definite (Ω, ϵ)-good shape.</p><p>Lastly, s ≤ t can be of the form s ≤ t 1 ∧ t 2 , to which the ∧-splitting rule applies, producing s ≤ t 1 and s ≤ t 2 , for which it is immediate that they are in definite (Ω, ϵ)-good shape. Definition 10.7 ((Ω, ϵ)-Ackermann Form). A set of L + -inequalities {s i ≤ t i } i∈I is in reduced 1-Ackermann form with respect to a variable p if, for every i ∈ I, either 1. s i is pure and t i = p, or 2. s i is positive in p and t i is negative in p.</p><p>Similarly, the set {s i ≤ t i } i∈I is in reduced ∂-Ackermann form with respect to a variable p if, for every i ∈ I, either 1. s i = p and t i is pure, or 2. s i is negative in p and t i is positive in p.</p><p>Given an irreflexive, transitive ordering Ω on the variables p 1 , . . . , p n and an order type ϵ = (ϵ 1 , . . . , ϵ n ), a set {s i ≤ t i } i∈I of inequalities is in reduced (Ω, ϵ)-Ackermann form if it is in reduced ϵ k -Ackermann form w.r.t. every Ω-minimal variable p k .</p><p>The following two lemmas explore the consequences of a set of inequalities which are in definite (Ω, ϵ)-good shape not being in (Ω, ϵ)-Ackermann form. </p><formula xml:id="formula_159">C: = s i is not positive in p. D:= t i is not negative in p. Hence, (A ∧ C ) ∨ (A ∧ D) ∨ (B ∧ C ) ∨ (B ∧ D).</formula><p>So it is enough to show that each of the disjuncts implies either (a) or (b). Notice that if s i is not positive in p, then s i is not pure, so</p><formula xml:id="formula_160">A ∧ C is equivalent to C , which is (a). B ∧ C implies C , which is (a). B ∧ D is (b).</formula><p>Finally, if t i is not negative in p, then t i is not pure, so the assumption that s i ≤ t i is in (Ω, ϵ)-good shape implies that s i is pure. Hence, A ∧ D cannot occur.</p><p>The proof of item 2 is similar.</p><p>Corollary 10.9. If a system {s i ≤ t i } i∈I of L + -inequalities in (Ω, ϵ)-good shape is not in reduced (Ω, ϵ)-Ackermann form, then one of the following conditions holds for some i ∈ I and some Ω-minimal propositional variable p j :</p><p>1. s i is pure and t i contains a positive (negative) occurrence of p j where ϵ j = 1 (ϵ j = ∂), and t i ̸ = p j , or 2. t i is pure and s i contains a negative (positive) occurrence of p j where ϵ j = 1 (ϵ j = ∂), and s i ̸ = p j .</p><p>Proof. If {s i ≤ t i } i∈I is not in reduced (Ω, ϵ)-Ackermann form, then either it is not in reduced 1-Ackermann form for some Ω-minimal variable p j with ϵ j = 1 or it is not in reduced ∂-Ackermann form for some Ω-minimal variable p j with ϵ j = ∂.</p><p>In the first case, Lemma 10.8 tells us that there exists an i ∈ I such that (a) s i is not positive in p j , or (b) t i ̸ = p j and t i is not negative in p j . If (a), then s i must contain a negative occurrence of p j , and hence, s i ̸ = p j . Further, since s i is not pure, it follows from the good shape of s i ≤ t i that t i must be pure. Hence, we have shown <ref type="bibr" target="#b1">(2)</ref>. On the other hand, if (b), we have that t i must contain a positive occurrence of p j and t i ̸ = p j . Moreover, t i is not pure; hence, it follows from the good shape of s i ≤ t i that s i must be pure. Hence, we have shown <ref type="bibr" target="#b0">(1)</ref>.</p><p>In the second case, Lemma 10.8 tells us that (c) t i is not positive in p j , or (d) s i ̸ = p j and s i is not negative in p j . If (c), then t i contains a negative occurrence of p j , and hence, t i ̸ = p j . Moreover, since t i is not pure, it follows from the good shape of s i ≤ t i that s i must be pure. Hence, we have shown <ref type="bibr" target="#b0">(1)</ref>. If (d), then s i contains a positive occurrence of p j and s i ̸ = p j , and since s i is not pure, it follows from the good shape of s i ≤ t i that t i must be pure. Hence, we have shown <ref type="bibr" target="#b1">(2)</ref>. Proposition 10.10. Any finite set {s i ≤ t i } i∈I of inequalities which are in definite (Ω, ϵ)-good shape can be transformed into a set {s ′ i ≤ t ′ i } i∈I ′ which is in reduced (Ω, ϵ)-Ackermann form, through the exhaustive application, only to non-pure inequalities, of the ∧-splitting, ∨-splitting, approximation, and unary residuation rules top to bottom, as well as the restricted application of the binary residuation rules top to bottom.</p><p>Proof. We first claim that the process of applying the above mentioned rules to non-pure inequalities will eventually terminate. Indeed, by the definition of definite (Ω, ϵ)-good shape, each inequality s i ≤ t i in the initial set {s i ≤ t i } i∈I has at most one non-pure side, and by Lemma 10.6 the application of the rules does not change this situation. Next, note that each rule application replaces an inequality with one or two inequalities in which the generation tree of the non-pure side is of strictly smaller height. For instance, each residuation rule is always applied top to bottom, and therefore results in a 'black' operation being introduced on the pure side and a 'white' operation being stripped off the non-pure side of the inequality to which it is applied. Hence, the process must eventually terminate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let {s ′</head><p>i ≤ t ′ i } i∈I ′ be the set of inequalities obtained when the process terminates; suppose, for the sake of contradiction, that it is not in reduced (Ω, ϵ)-Ackermann form. Hence, by Corollary 10.9, one of the following is the case for some Ω-minimal variable p j and some i ∈ I ′ : Case 1: s i is pure and t i contains a positive (negative) occurrence of p j where ϵ j = 1 (ϵ j = ∂), and t i ̸ = p j , or Case 2: t i is pure and s i contains a negative (positive) occurrence of p j where ϵ j = 1 (ϵ j = ∂), and s i ̸ = p j . Suppose we are in case 1. The root of the positive generation tree of t ′ i can be one of the following: +∧, +∨, +✸, +✄, +✷ or +✁. We will now show that each of these options leads to a contradiction with our assumptions. If the root were +∧, +✷ or +✄, then the ∧-splitting rule, the ✷-residuation rule or the ✁-residuation rule, respectively, would still be applicable to the inequality, contrary to the assumption that the rules have been exhaustively applied.</p><p>If the root of +t i is +∨, then the shape of the offending inequality is s ′</p><formula xml:id="formula_161">i ≤ t ′ 1 ∨t ′ 2 .</formula><p>Then if p j occurs in t ′ 2 , the assumption that p j is Ω-minimal and t ′ i is in definite (Ω, ϵ)-good shape imply that t ′ 1 is pure. Then a restricted application of ∨-residuation would still be possible, contrary to the assumption that the rules have been exhaustively applied. Thus, the only remaining options for the root of t ′ i are +✸ and +✁. In both cases it is a choice node, and since the positive generation tree of +t ′ i contains a node +p j (-p j ) with ϵ j = 1 (ϵ j = ∂), it follows from the fact that s</p><formula xml:id="formula_162">′ i ≤ t ′ i is in definite</formula><p>(Ω, ϵ)-good shape that s ′ i must be a nominal. But then the ✸ or ✁-approximation rules would be applicable, once again contradicting the assumption that these rules have been exhaustively applied.</p><p>Case 2 is symmetric. (Ω, ϵ)-good shape. Hence, by Proposition 10.10, the system {i ≤ s, t ≤ m} can be transformed, through the application of the rules of the algorithm, into a set of inequalities in reduced (Ω, ϵ)-Ackermann form. To this set the Ackermann rule can then be applied to eliminate all Ω-minimal propositional variables. The Ackermann rule, applied to a set of inequalities in reduced (Ω, ϵ)-Ackermann form, replaces propositional variables with pure terms; therefore the resulting set of inequalities is in definite (Ω ′ , ϵ)-good shape, where Ω ′ is the restriction of Ω to the non-Ω-minimal variables. Indeed, the application of an Ackermann rule turns all ϵ-critical branches corresponding to Ω-minimal variables into non-critical branches, and leaves the critical branches corresponding to the other variables unaffected.</p><p>Now another cycle of reduction rule applications will lead to a new set of inequalities in reduced (Ω ′ , ϵ)-Ackermann form, from which an application of the Ackermann rule will eliminate all the Ω ′ -minimal variables, and so on. Since the number of variables in s 0 ≤ t 0 is finite, after a finite number of cycles the algorithm will output a set of pure inequalities.</p><p>As a corollary of Theorems 8.1, 9.8 and 10.11 we obtain: Theorem 10.12. All inductive and Sahlqvist inequalities are elementary and canonical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2.">ALBA succeeds on all Sahlqvist inequalities</head><p>In outline and also in large parts of the detail, proving that ALBA succeeds on Sahlqvist formulas is the same as proving that it succeeds on inductive inequalities. We will therefore be brief in this section, giving details of proofs only where they differ from the inductive case. Definition 10.13 (ϵ-Sahlqvist L + Terms and Inequalities). Given an order type ϵ, the generation tree * s, * ∈ {-, +}, of a term s(p 1 , . . . ,</p><formula xml:id="formula_163">p n ) ∈ L + term is ϵ-Sahlqvist if 1.</formula><p>it is ϵ-conservative (cf. Definition 10.1), and 2. on every ϵ-critical branch no choice node has a universal node as ancestor.</p><p>An inequality s ≤ t ∈ L + is ϵ-Sahlqvist if the trees +s and -t are both ϵ-Sahlqvist.</p><p>Definition 10.14 (Definite ϵ-Sahlqvist L + Terms and Inequalities). Given an order type ϵ, a signed generation tree * s, * ∈ {-, +}, of a term s(p 1 , . . . , p n ) ∈ L + term , is definite ϵ-Sahlqvist if 1. it is ϵ-Sahlqvist, 2. there are no binary choice nodes on any ϵ-critical branch.</p><p>An inequality s ≤ t ∈ L is definite ϵ-Sahlqvist if the trees +s and -t are both definite ϵ-Sahlqvist.</p><p>Lemma 10.15. Let {s i ≤ t i } be the set of inequalities obtained by preprocessing an ϵ-Sahlqvist inequality s ≤ t ∈ L. Then each s i ≤ t i is a definite ϵ-Sahlqvist inequality.</p><p>Proof. Proving that s i ≤ t i is an ϵ-Sahlqvist inequality is almost verbatim the same as in the proof of Lemma 10.4 -simply replace '(Ω, ϵ)-inductive' everywhere with 'ϵ-Sahlqvist'.</p><p>It remains to show that s i ≤ t i is definite. Suppose, to the contrary, that in the positive generation tree of s i there is a critical path on which there is a binary choice node, and let n be the closest such node to the root. (Note that since s i is ϵconservative, this critical path contains only labels from L.) If n is the root it must be +∨. Indeed, it cannot be -∧ since we are considering the positive generation tree. But this cannot be the case, because then the ∨-splitting rule would have been applied during the preprocessing to eliminate n. Thus, since n is not the root, it must have a parent in the tree, and since s i is ϵ-left Sahlqvist, the parent of the node n (which is a choice node, being +∨ or -∧) must be either the type +✸ or -✄ (in the case where n is +∨), or of the type -✷ or +✁ (in the case where n is -∧). But once again this leads to a contradiction with the assumption that pre-preprocessing has been exhaustively performed upon s i ≤ t i .</p><p>The case for the negative generation tree of t i is similar. Definition 10.16 (Definite Good Shape). An inequality s ≤ t ∈ L + is in definite ϵ-good shape if either of the following conditions hold:</p><p>1. s is pure, +t is definite ϵ-Sahlqvist and moreover, if +t contains a choice node on an ϵ-critical branch, then s is a nominal. 11   2. t is pure, -s is definite ϵ-Sahlqvist and moreover, if -s contains a choice node on an ϵ-critical branch, then t is a conominal.</p><p>Since for inequalities s ≤ t in definite ϵ-good shape -s and +t do not contain binary choice nodes on critical branches, Lemma 10.17 differs from its analogue Lemma 10.6 only in that the case for binary residuation rules does not appear since these rules are not needed. Lemma 10.17. If s ≤ t is in definite ϵ-good shape, then any inequality s ′ ≤ t ′ obtained from s ≤ t by the application of a splitting rule, or of an approximation or unary residuation rule top to bottom, is again in definite ϵ-good shape.</p><p>Proof. We will only treat the case in which s ≤ t is such that s contains no propositional variables and +t is definite ϵ-Sahlqvist, the other, in which t contains no propositional variables and -s is definite ϵ-Sahlqvist, being perfectly symmetric.</p><p>Which rule is applicable is determined by the root of the positive generation tree of t. If the root is universal, it must be either +✷ or +✄, i.e. t has the form ✷t ′ or ✄t ′ . In the first case the ✷-residuation rule is applicable and yields s ≤ t ′ . Now clearly s contains no propositional variables and +t ′ is definite ϵ-Sahlqvist. Since s is not a nominal, to prove that s ≤ t ′ is in definite ϵ-good shape, it remains to show that +t ′ contains no unary choice node on an ϵ-critical branch. Indeed, if +t ′ contained such a node, it would imply the existence of a unary choice node on an ϵ-critical branch in +t with a +✷-node as ancestor, contradicting the assumption that +t is ϵ-Sahlqvist. Hence, s ≤ t ′ is in definite ϵ-good shape.</p><p>In the second case, the inequality has the shape s ≤ ✄t ′ , and the ✄-residuation rule is applicable and yields t ′ ≤ s. Clearly s contains no propositional variables. Note that the generation tree of -t ′ is obtained by simply removing the root from the generation tree of +✄t ′ . Hence, -t ′ is definite ϵ-Sahlqvist. Further, as above, we can prove that -t cannot contain any unary choice node on an ϵ-critical branch. Hence, we conclude that t ′ ≤ s is in definite ϵ-good shape. Next, consider the case where the root of +t is a choice node, i.e., it is +∨, +✸ or +✁. Moreover, since s ≤ t is in ϵ-good shape we must have that s is j for some nominal j. By the assumption of definiteness, the case +∨ cannot occur, and we have that s ≤ t is either j ≤ ✸t ′ or j ≤ ✁t ′ .</p><p>In the first case, application of the ✸-approximation rule replaces j ≤ ✸t ′ with the inequalities j ≤ ✸k and k ≤ t ′ . It is immediate that these inequalities are in ϵ-good shape.</p><p>In the second case, application of the ✁-approximation rule replaces j ≤ ✁t ′ with the inequalities t ′ ≤ m and j ≤ ✁m. The latter is trivially in ϵ-good shape. As above, the fact that -t ′ is definite ϵ-Sahlqvist follows from the facts that +✁t ′ is definite ϵ-Sahlqvist and that the generation tree of -t ′ is obtained by deleting the root of the generation tree of +✁t ′ . Hence, t ′ ≤ m is in ϵ-good shape. Lastly, s ≤ t can be of the form s ≤ t 1 ∧ t 2 , to which the ∧-splitting rule applies producing s ≤ t 1 and s ≤ t 2 , for which it immediate that they are in definite ϵ-good shape. Definition 10.18 (ϵ-Ackermann Form). Given a sequence (p 1 , . . . , p n ) of variables and an order type ϵ = (ϵ 1 , . . . , ϵ n ), we will say that a set {s i ≤ t i } i∈I of inequalities is in reduced ϵ-Ackermann form if it is in reduced ϵ i -Ackermann form with respect to p i for each 1 ≤ i ≤ n. (Recall Definition 10.7 where reduced 1-Ackermann form and reduced ∂-Ackermann form are defined.)</p><p>The key difference between Lemma 10.19 below and its analogue Proposition 10.10 is that here no binary residuation rules are needed. This is why we are able to claim that a strictly weaker version of ALBA is sufficient for handling the Sahlqvist formulas.</p><p>Lemma 10.19. Any finite set {s i ≤ t i } i∈I of inequalities which are in definite ϵ-good shape can be transformed into a set {s ′ i ≤ t ′ i } i∈I ′ which is in reduced ϵ-Ackermann form through the exhaustive application of the splitting, approximation, and unary residuation rules top to bottom, and only to non-pure inequalities.</p><p>11 As in the case of (Ω, ϵ)-good shape, the sides have been swapped around.</p><p>Proof. The proof is the same as that of Proposition 10.10, except for the fact that, since the inequalities in {s i ≤ t i } i∈I are in definite ϵ-good shape (rather that definite (Ω, ϵ)-good shape), there are no binary choice nodes on ϵ-critical paths in the +t's or -s's, and hence, no binary residuation rules need to be applied. or equivalently, if x ̸ ≤ y then x / ∈ U and y ∈ U for some clopen down-set U ⊆ X .</p><p>For every Priestley space X, let L X be the collection of the clopen up-sets of X and let D X be the collection of the clopen down-sets. Let π i : X × X -→ X be the canonical projection over the ith coordinate. Recall that canonical projections are surjective, continuous and open maps, and, since X × X is compact and X is Hausdorff (see below), they are also closed. Proposition A.1. For every Priestley space X = (X, ≤, τ ),</p><p>1. X is Hausdorff, and hence every singleton is closed.</p><p>2. The relations ≤ and ≥ are closed sets in the product space X × X. 3. For every x ∈ X , x↑ and x↓ are closed sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">For every</head><formula xml:id="formula_164">C ⊆ X , if C is closed, then C ↑ =  {U ∈ L X | C ⊆ U} and C ↓ =  {V ∈ D X | C ⊆ V }. Hence, C ↑ and C ↓ are closed. 5. For every O ⊆ X , if O is an open up-set, then O =  {U ∈ L X | U ⊆ O}. 6. For every O ⊆ X , if O is an open down-set, then O =  {V ∈ D X | V ⊆ O}. Proof. 1. If x ̸ = y, then either x ̸ ≤ y or y ̸ ≤ x.</formula><p>In either case, by total order-disconnectedness, there is a disjoint clopen up-set/clopen down-set pair separating them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">If ⟨x, y⟩ /</head><p>∈ ≤, i.e., x ̸ ≤ y, then x ∈ U and y / ∈ U for some U ∈ L X , so take</p><formula xml:id="formula_165">U × U c ∈ τ X ×X : ⟨x, y⟩ ∈ U × U c and (U × U c ) ∩ ≤ = ∅. Similarly ≥. 3. Since {x} is closed and π 1 is continuous, π -1 1 [{x}] is closed. Hence, by item 2 above, π -1 1 [{x}] ∩ ≤ is closed. Therefore, since π 2 is a closed map, x↑ = π 2 [π -1 1 [{x}]∩ ≤] is closed. 4. If x /</formula><p>∈ C ↑, then y ̸ ≤ x for every y ∈ C ; hence, by total order-disconnectedness, x ∈ V y and y / ∈ V y for some</p><formula xml:id="formula_166">V y ∈ D X . Therefore, x ∈  y∈C V y and C ∩  y∈C V y = ∅. By compactness, C ∩  n i=1 V y i = ∅ for some y i ∈ C , 1 ≤ i ≤ n. Let V =  n i=1 V y i . Clearly, V ∈ D X ; hence, V is a down-set, so C ∩ V = ∅ implies that C ↑ ∩ V = ∅. Hence, V c ∈ L X , x / ∈ V c and C ↑ ⊆ V c ,</formula><p>which proves the inclusion from right to left of the first equality. The converse inclusion is immediate. The second equality is proven in a similar way. The last part of the statement follows from the fact that intersections of clopens are closed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">If</head><p>O is an open up-set, then O c is a closed down-set, i.e., it is of the form C ↓ for C = O c . Hence, the statement follows from item 4.</p><p>6. Similar to 5, using 4.</p><p>The following lemma will also be useful, e.g. in the proof of Lemma A.10.</p><p>Lemma A.2. For any Priestley space X = (X, ≤, τ ), and any downwards-directed family {C i } i∈I of closed subsets of X ,</p><formula xml:id="formula_167">1. (  i∈I C i )↑ =  i∈I (C i ↑) and 2. (  i∈I C i )↓ =  i∈I (C i ↓). Proof.</formula><p>We only prove the first claim, the proof of the second one being similar.</p><formula xml:id="formula_168">If x ∈ (  i∈I C i )↑, then y ≤ x for some y ∈  i∈I C i . But then x ∈ C i ↑ for each i ∈ I; hence, x ∈  i∈I (C i ↑). For the converse implication, assume that x ̸ ∈ (  i∈I C i )↑. This is the case iff x↓ ∩  i∈I C i = ∅.</formula><p>Since x↓ is closed by Proposition A.1(3), we may appeal to compactness and down-directedness to find a</p><formula xml:id="formula_169">C 0 ∈ {C i } i∈I such that x↓ ∩ C 0 = ∅, i.e., such that x ̸ ∈ C 0 ↑; hence, x ̸ ∈  i∈I (C i ↑).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2. Topological properties of the modalities and their adjoints</head><p>Let us introduce some notation: when the set-theoretic universe is unambiguous, e.g. in a descriptive general frame G, we will denote the complement of any Y ⊆ W as Y c rather than W \ Y . We will also denote the collection of clopen up-sets of X G by A; we will also abuse notation and let</p><formula xml:id="formula_170">A c = {U c | U ∈ A}.</formula><p>To simplify notation, we will also write ✷, ✸, ✄, and ✁, respectively, for [R ✷ ], ⟨R ✸ ⟩, [R ✄ ⟩, ⟨R ✁ ], and similarly denote the adjoints of these operations with , , , , although we will use their respective semantic definitions as ⟨R</p><formula xml:id="formula_171">-1 ✷ ⟩, [R -1 ✸ ], [R -1 ✄ ⟩, ⟨R -1 ✁ ]. Lemma A.3.</formula><p>For every nonempty set W , every binary relation R on W and every Y ⊆ P (W ),</p><formula xml:id="formula_172">1. [R](  Y) =  {[R]Y | Y ∈ Y}. 2. ⟨R⟩(  Y) =  {⟨R⟩Y | Y ∈ Y}. 3. [R⟩(  Y) =  {[R⟩Y | Y ∈ Y}. 4. ⟨R](  Y) =  {⟨R]Y | Y ∈ Y}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Straightforward.</head><p>Corollary A.4. For every descriptive general frame G = (F , τ ), </p><formula xml:id="formula_173">= ✷  {U ∈ L X G | C ⊆ U} =  {✷U | U ∈ L X G and C ⊆ U}.</formula><p>But by DG3, the collection A = L X G is closed under applications of ✷; hence, ✷C is a closed up-set.</p><p>The following lemmas are essentially variations on the original Esakia's lemma <ref type="bibr" target="#b10">[11]</ref>.</p><p>Lemma A.5. For every compact topological space X = (W , τ ) and every binary relation R on W such that R[x] is closed for every x ∈ W , every up-directed collection U of opens and every down-directed collection D of closed subsets, (  4. The case for is similar to <ref type="bibr" target="#b2">(3)</ref>.</p><formula xml:id="formula_174">1. [R](  U) =  {[R]O | O ∈ U}. 2. ⟨R⟩(  D) =  {⟨R⟩C | C ∈ D}. 3. [R⟩(  D) =  {[R⟩C | C ∈ D}.</formula><formula xml:id="formula_175"> U) =  { O | O ∈ U}. 2. (  D) =  { C | C ∈ D}. 3. (  D) =  { C | C ∈ D}. 4. (  U) =  { O | O ∈ U}.</formula><p>Notice that in general, the 'white operations' are part of a residuated pair only in the perfect extension. Therefore, as operations, the 'black operations' are defined only on P ↑ (W ) and not on A. As a consequence of this, an argument similar to the one that we gave for Corollary A.6, using Lemma A.7, fails to prove the following proposition, and we need to resort to a different argument, which -as was the case for Corollary A.6 -rests on Lemma A.5. • the base cases are those when ϕ is of the form ⊤, ⊥, q (for propositional variables q different from p) or i, and when ψ is of the form ⊤, ⊥, p, q (for propositional variables q different from p), or m, and Proof. We prove (1) by simultaneous induction on ϕ and ψ. The base cases of the induction on ϕ are those when ϕ is of the form ⊤, ⊥, p, a propositional variable q other than p, or i; the base cases for ψ are those when ψ is of the form ⊤, ⊥, a propositional variable q other than p, or m. In each of these cases the claim is trivial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition</head><p>For the remainder of the proof, we will omit reference to the valuation V , and simply write ϕ and ψ for ϕ V p and ψ V p , respectively.</p><p>In the cases where ϕ(p) = ϕ </p><formula xml:id="formula_176">C i  = ϕ 1   i∈I C i  ∪ ϕ 2   i∈I C i  =  i∈I ϕ 1 (C i ) ∪  i∈I ϕ 2 (C i ).</formula><p>We thus have to show that</p><formula xml:id="formula_177"> i∈I ϕ 1 (C i )∪  i∈I ϕ 2 (C i ) =  i∈I (ϕ 1 (C i )∪ϕ 2 (C i ))</formula><p>. The inclusion from left to right is immediate. To consider the converse, let x ̸ ∈  i∈I ϕ 1 (C i )∪  i∈I ϕ 2 (C i ). Thus, there exist C 1 , C 2 ∈ {C i } i∈I such that x ̸ ∈ ϕ 1 (C 1 ) and x ̸ ∈ ϕ 2 (C 2 ). By the downward-directedness of {C i } i∈I , we have that C 0 ⊆ C 1 ∩ C 2 for some C 0 ∈ {C i } i∈I ; hence, by the monotonicity of ϕ 1 and ϕ 2 , we get that x ̸ ∈ ϕ 1 (C 0 ) and x ̸ ∈ ϕ 2 (C 0 ). Therefore, x ̸ ∈ ϕ 1 (C 0 ) ∪ ϕ 2 (C 0 ), and consequently, x ̸ ∈  i∈I (ϕ 1 (C i ) ∪ ϕ 2 (C i )). Next, if ψ(p) = ψ 1 (p) ∧ ψ 2 (p), then, by the inductive hypothesis,</p><formula xml:id="formula_178">ψ   i∈I C i  = ψ 1   i∈I C i  ∩ ψ 2   i∈I C i  =  i∈I ψ 1 (C i ) ∩  i∈I ψ 2 (C i ).</formula><p>We thus have to show that</p><formula xml:id="formula_179"> i∈I ψ 1 (C i ) ∩  i∈I ψ 2 (C i ) =  i∈I (ψ 1 (C i ) ∩ ψ 2 (C i ))</formula><p>. The inclusion from right to left is immediate. To prove the converse, let x ∈  i∈I ψ 1 (C i ) ∩  i∈I ψ 2 (C i ). Thus, there exist C 1 , C 2 ∈ {C i } i∈I such that x ∈ ψ 1 (C 1 ) and x ∈ ψ 2 (C 2 ). By the downward-directedness of {C i } i∈I , we have that C 0 ⊆ C 1 ∩ C 2 for some C 0 ∈ {C i } i∈I . Hence, by the antitonicity of ψ 1 and ψ 2 , we get that x ∈ ψ 1 (C 0 ) and x ∈ ψ 2 (C 0 ). Therefore, x ∈ ψ 1 (C 0 ) ∩ ψ 2 (C 0 ), and consequently, x ∈  i∈I (ψ 1 (C i ) ∩ ψ 2 (C i )). If ϕ(p) = ϕ 1 (p) -ϕ 2 (p), then ϕ 1 (p) is syntactically closed and positive in p, while ϕ 2 (p) is syntactically open and negative in p. Thus, by the inductive hypothesis, ϕ 1 (</p><formula xml:id="formula_180"> i∈I C i ) -ϕ 2 (  i∈I C i ) =  i∈I ϕ 1 (C i ) -  i∈I ϕ 2 (C i ). The latter is equal to [  i∈I ϕ 1 (C i ) ∩ (  i∈I ϕ 2 (C i )) c</formula><p>]↑, which is the same as [</p><formula xml:id="formula_181"> i∈I ϕ 1 (C i ) ∩  i∈I (ϕ 2 (C i )) c</formula><p>]↑. By the associativity and commutativity of ∩, the latter set can be rewritten as [</p><formula xml:id="formula_182"> {ϕ 1 (C i ) ∩ (ϕ 2 (C i )) c | i ∈ I}]↑. Since ϕ 1 (p) ∩ (ϕ 2 (p)) c is monotone in p, it follows from the downward-directedness of {C i } i∈I that {ϕ 1 (C i ) ∩ (ϕ 2 (C i )) c</formula><p>| i ∈ I} is a downward-directed family of (by Lemma A.9) closed sets. Finally, by Lemma A.2.1, we have that [ </p><formula xml:id="formula_183"> {ϕ 1 (C i ) ∩ (ϕ 2 (C i )) c | i ∈ I}]↑ is equal to  {[ϕ 1 (C i ) ∩ (ϕ 2 (C i )) c ]↑ | i ∈ I} =  {ϕ 1 (C i ) -ϕ 2 (C i ) | i ∈ I}. If ψ(p) = ψ 1 (p) → ψ 2 (p),</formula><formula xml:id="formula_184">(C i ) ∩ (ψ 2 (C i )) c | i ∈ I}]↓ c is equal to [  {(ψ 1 (C i )∩(ψ 2 (C i )) c )↓ | i ∈ I}] c , which is again equal to  {(ψ 1 (C i )∩(ψ 2 (C i )) c )↓ c | i ∈ I} =  {ψ 1 (C i ) → ψ 2 (C i ) | i ∈ I}. If ϕ(p</formula><p>) is of the form ⊙ϕ 1 (p) for ⊙ ∈ {✷, ✸, }, then ϕ 1 (p) must be syntactically closed and positive in p. Then, by the inductive hypothesis, ϕ 1 (  i∈I C i ) =  i∈I ϕ 1 (C i ). By Lemma A.9, ϕ 1 (C i ) is a closed up-set for each i ∈ I. Moreover, by the monotonicity of ϕ 1 and the downward-directedness of {C i } i∈I , the family {ϕ 1 (C i )} i∈I is downward-directed. We may hence apply Lemma A. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Remark 3 . 2 .</head><label>32</label><figDesc>A few remarks about Definition 3.1 are in order:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>for α(p) ≤ β(p) positive (recall Definition 4.1) and γ (p) ≤ δ(p) negative in p, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 8 . 1 (</head><label>81</label><figDesc>Correctness). If ALBA succeeds in reducing an inequality ϕ ≤ ψ and yields ALBA(ϕ ≤ ψ), then F , w ϕ ≤ ψ iff F (j 0 := w↑) ALBA(ϕ ≤ ψ) iff F |= ALBA FO (ϕ ≤ ψ)[j 0 := w].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Lemma 9 . 3 (</head><label>93</label><figDesc>Right-handed Ackermann Lemma for Descriptive Frames). Let α be syntactically closed, p ̸ ∈ PROP(α), let β 1 (p), . . . , β n (p) be syntactically closed and positive in p, and let γ 1 (p), . . . , γ n (p) be syntactically open and negative in p. Let V be any admissible valuation on G.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Lemma 9 . 4 (</head><label>94</label><figDesc>Left-handed Ackermann Lemma for Descriptive Frames). Let α be syntactically open, p ̸ ∈ PROP(α), let β 1 (p), . . . , β n (p) be syntactically closed and negative in p, and let γ 1 (p), . . . , γ n (p) be syntactically open and positive in p. Let V be any admissible valuation on G. Then,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Distribution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4 .Corollary A. 6 . 1 .Lemma A. 7 .</head><label>4617</label><figDesc>⟨R](  U) =  {⟨R]O | O ∈ U}. Proof.<ref type="bibr" target="#b0">1</ref>. The '⊇' inclusion easily follows from the monotonicity of[R].Conversely, if x ∈ [R](  U), then R[x] ⊆  U, so by compactness, R[x] ⊆  n i=1 O i for some O 1 , . . . , O n ∈ U. Since U is up-directed,  n i=1 O i ⊆ O for some O ∈ U. Hence, x ∈ [R]O ⊆  {[R]O | O ∈ U}. 2.The '⊆' inclusion easily follows from the monotonicity of ⟨R⟩.Conversely, if x / ∈ ⟨R⟩(  D), then R[x] ∩  D = ∅, so by compactness, R[x] ∩  n i=1 C i = ∅ for some C 1 , . . . , C n ∈ D. Since D is down-directed, C ⊆  n i=1 C i for some C ∈ D. Hence, x / ∈ ⟨R⟩C ⊇  {⟨R⟩C | C ∈ D}.3. The '⊇' inclusion easily follows from the antitonicity of [R⟩. Conversely, assume thatx ∈ [R⟩(  D), which is equivalent to R[x] ⊆ (  D) c =  {C c | C ∈ D}. By compactness, R[x] ⊆  n i=1 C c i for some C 1 , . . . , C n ∈ D. Since D is down-directed,  n i=1 C c i ⊆ C c for some C ∈ D. Hence, x ∈ [R⟩C ⊆  {[R⟩C | C ∈ D}. 4.The '⊆' inclusion easily follows from the antitonicity of ⟨R]. Conversely, assume that x /∈ ⟨R](  U), which is equivalentto ∅ = R[x] ∩ (  U) c = R[x] ∩  {O c | O ∈ U}. Then, by compactness, R[x] ∩  n i=1 O c i = ∅ for some O 1 , . . . , O n ∈ U. Since U is up-directed, O c ⊆  n i=1 O c i for some O ∈ U. Hence, x / ∈  {⟨R]O | O ∈ U}.For every descriptive general frame G, ✷O is an open up-set for every open up-set O. 2. ✸C is a closed up-set for every closed up-set C . 3. ✄C is an open up-set for every closed up-set C . 4. ✁O is a closed up-set for every open up-set O. Proof. 1. By DG1 and Proposition A.1.5, we have O =  {U ∈ A | U ⊆ O}. Since the collection U = {U ∈ A | U ⊆ O} is clearly up-directed, by Lemma A.5.1 we have ✷O = ✷(  {U ∈ A | U ⊆ O}) =  {✷U | U ∈ A and U ⊆ O}, which, by DG3, proves the statement. The proof of the remaining items is similar, using Proposition A.1.4 and Lemma A.5. For every descriptive general frame G, every up-directed collection U of X G -open up-sets and every down-directed collection D of X G -closed up-sets, 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>D ⊆ ✷(x↓ c ). By Proposition A.1.3, x↓ is a closed down-set, so by Corollary A.6.1, ✷(x↓ c ) is an open up-set. So by compactness, n i=1 C i ⊆ ✷(x↓ c ) for some C 1 , . . . , C n ∈ D. Since D is downdirected, C ⊆  n i=1 C i for some C ∈ D. Hence, C ⊆ ✷(x↓ c), which, again by adjunction and C being an up-set, is equivalentto x / ∈ C ⊇  { C | C ∈ D}.3. The '⊇' inclusion easily follows from the antitonicity of . Conversely, assume that x ∈ (  D). Since  D is an upset, so is (  D); hence, x ∈ (  D) is equivalent to x↑ ⊆ (  D). By adjunction, the latter inclusion is equivalent to  D ⊆ ✄(x↑). By Proposition A.1.3, x↑ is a closed up-set, so by Corollary A.6.3, ✄(x↑) is an open (up-set). So, by compactness,  n i=1 C i ⊆ ✄(x↑) for some C 1 , . . . , C n ∈ D. Since D is down-directed, C ⊆  n i=1 C i for some C ∈ D. Hence, C ⊆ ✄(x↑), which, again by adjunction and C being an up-set, is equivalent to x ∈ C ⊆  { C | C ∈ D}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>1 (p) ∧ ϕ 2 (p), ϕ(p) = ϕ 1 (p) ∨ ϕ 2 (p), ψ(p) = ψ 1 (p) ∨ ψ 2 (p) and ψ(p) = ψ 1 (p) ∧ ψ 2 (p),we have that ϕ 1 and ϕ 2 are syntactically closed and positive in p and that ψ 1 and ψ 2 are syntactically open and negative in p. Hence, when ϕ(p) = ϕ 1 (p) ∧ ϕ 2 (p) and when ψ(p) = ψ 1 (p) ∨ ψ 2 (p) the claim follows by the inductive hypothesis and the associativity of, respectively, intersection and union of sets. If ϕ(p) = ϕ 1 (p) ∨ ϕ 2 (p), then, by the inductive hypothesis,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>by the monotonicity of ✸, we have j ≤ j ′ ≤ ✸i ′ ≤ ✸i, which yields jR ✸ i. The remaining conditions can be verified similarly.</figDesc><table /><note><p><p><p>Proposition 2.</p>13 (cf. [14, Prop. 2.25, 2.26]</p>). For every perfect DMA C and every DML frame F ,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Lemma 2.17. For</head><label></label><figDesc>any state w in a DML frame F and for every formula, inequality or quasi-inequality ξ ∈ L + term ∪ L + ∪ L +</figDesc><table /><note><p>quasi , 1. F , w ξ iff F |= ∀P∀j∀mST x (ξ )[x := w], and 2. F ξ iff F |= ∀x∀P∀j∀mST x (ξ ), where P, j, and m are, respectively, the vectors of all predicate symbols corresponding to propositional variables, individual variables corresponding to nominals, and individual variables corresponding to co-nominals, occurring in ST x (ξ ).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc>Universal and choice nodes.</figDesc><table><row><cell>Choice</cell><cell>Universal</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Lemma 10.8. 1. If a system {s i ≤ t i } i∈I of L + -inequalities in (Ω, ϵ)-good shape is not in reduced 1-Ackermann form w.r.t. some variable p, then one of the following condition holds for some i ∈ I:(a) s i is not positive in p, or (b) t i ̸ = pand t i is not negative in p. 2. If a system {s i ≤ t i } i∈I of L + -inequalities in (Ω, ϵ)-good shape is not in reduced ∂-Ackermann form w.r.t. some variable p, then one of the following condition holds for some i ∈ I: (c) t i is not positive in p, or (d) s i ̸ = p and s i is not negative in p. Proof. 1. It readily follows from Definition 10.7 that if {s i ≤ t i } i∈I is not in reduced 1-Ackermann form w.r.t. p, then there exists some i ∈ I such that (A ∨ B) ∧ (C ∨ D), where A: = s i is not pure.</figDesc><table /><note><p>B: = t i ̸ = p.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Theorem 10.11. ALBA succeeds on all inductive inequalities. Proof. Let s 0 ≤ t 0 be an (Ω, ϵ)-inductive inequality. By Lemma 10.4, preprocessing s 0 ≤ t 0 will yield a finite set {s i ≤ t i } i∈I of definite (Ω, ϵ)-inductive inequalities. The execution of the algorithm now branches and proceeds separately on each of these inequalities. Each s ≤ t ∈ {s i ≤ t i } i∈I is replaced with {i ≤ s, t ≤ m}. Notice that i ≤ s and t ≤ m are in definite</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Theorem 10.20. The ALBA succeeds on all Sahlqvist inequalities. Proof. Let s 0 ≤ t 0 be an ϵ-Sahlqvist inequality. By Lemma 10.15, preprocessing s 0 ≤ t 0 will yield a finite set {s i ≤ t i } i∈I of definite ϵ-Sahlqvist inequalities. The execution of the algorithm now branches and proceeds separately on each of these inequalities. Let s ≤ t ∈ {s i ≤ t i } i∈I . Firstly, the system {s ≤ t} is replaced with {i ≤ s, t ≤ m}. Notice that i ≤ s and t ≤ m are in definite ϵ-good shape. Hence, by Lemma 10.19, the set {i ≤ s, t ≤ m} can be transformed, through the application of the rules of the algorithm, into a set of inequalities in reduced ϵ-Ackermann form. To this set, the Ackermann rule can then be applied to eliminate all occurring propositional variables simultaneously, which guarantees a successful termination.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>Proof. 1. The '⊇' inclusion easily follows from the monotonicity of . Conversely, assume that x ∈ (  U). Since is anoperation in P ↑ (W ) and  U is an up-set, so is (  U); hence, x ∈ (  U) is equivalent to x↑ ⊆ (  U).By adjunction, the latter inclusion is equivalent to ✸(x↑) ⊆  U. By Proposition A.1.3, x↑ is a closed up-set, so by Corollary A.6.2, ✸(x↑) is a closed up-set. So by compactness, ✸(x↑) ⊆  n i=1 O i for some O 1 , . . . , O n ∈ U. Since U is up-directed,  n i=1 O i ⊆ O for some O ∈ U. Hence, ✸(x↑) ⊆ O, which, again by adjunction and O being an up-set, is equivalent to x ∈ O ⊆  { O | O ∈ U}. 2. The '⊆' inclusion easily follows from the monotonicity of . Conversely, assume that x / ∈ ( </figDesc><table><row><cell></cell><cell></cell><cell>D). Since</cell><cell></cell><cell>D is an</cell></row><row><cell>up-set, so is ( </cell><cell>D); hence, x / ∈ (</cell><cell></cell></row></table><note><p><p>D) is equivalent to x↓ ∩ (  D) = ∅, which is equivalent to (  D) ⊆ x↓ c .</p>By adjunction, the latter inclusion is equivalent to</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>A.8. For every descriptive general frame G and every A ⊆ W , 1. O is an open up-set for every open up-set O. 2. C is a closed up-set for every closed up-set C . 3. C is an open up-set for every closed up-set C . 4. O is a closed up-set for every open up-set O.Proof. 1. Clearly, O ⊇  {U ∈ A | U ⊆ O};since O is an up-set and is an operation in P ↑ (W ), we have that O is an up-set. So to prove the statement it is enough to show the converse inclusion to the one above, i.e., that ifx ∈ O, then x ∈ U for some U ∈ A such that U ⊆ O. Since O is an up-set, x ∈ O is equivalent to x↑ ⊆ O,which by adjunction is equivalent to ✸(x↑) ⊆ O. By Proposition A.1.3, x↑ is a closed up-set; hence, by Proposition A.1.4 and Lemma A.5.2, ✸(x↑) =  {✸U | U ∈ A and x↑ ⊆ U}. Now observe that ✸U ∈ A, so in particular ✸U is a closed (up-set), and O is an open up-set; hence we may apply compactness and get that n i=1 ✸U i ⊆ O for some U i ∈ A s.t. x↑ ⊆ U i , 1 ≤ i ≤ n. Let U =  n i=1 U i .Clearly, x↑ ⊆ U, i.e., x ∈ U; moreover, by the monotonicity of ✸, we have ✸U ⊆  n i=1 ✸U i ⊆ O, and hence, by adjunction, U ⊆ O. 2. Clearly, C ⊆  {U ∈ A | C ⊆ U}; since C is an up-set and is an operation in P ↑ (W ), we have that C is an up-set. So to prove the statement it is enough to show the converse inclusion to the one above, i.e., that if x/ ∈ C , then x / ∈ U for some U ∈ A such that C ⊆ U. Since C is an up-set, x / ∈ C is equivalent to x↓ ∩ C = ∅, which is equivalent to C ⊆ x↓ c ,which, by adjunction, is equivalent to C ⊆ ✷(x↓ c ). By Proposition A.1.3, x↓ c is an open up-set; hence, by Proposition A.1.5 and Lemma A.5.1, ✷(x↓ c ) =  {✷U | U ∈ A and U ⊆ x↓ c }. Now observe that ✷U ∈ A, so in particular ✷U is an open (up-set), and C is a closed up-set; hence we may apply compactness and get that C ⊆  n i=1 ✷U i for some Item (2) can similarly be proved by simultaneous induction on negative ϕ and positive ψ. In fact, the induction is almost verbatim the same, except that</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>• C is uniformly replaced with O. Lemma A.10. Let ϕ(p) be syntactically closed, ψ(p) be syntactically open, V be an admissible valuation, {C i } i∈I be a downwarddirected family of closed up-sets, and {O i } i∈I be a upward-directed family of open up-sets. Then, 1. (a) if ϕ(p) is positive in p, then ϕ V</figDesc><table><row><cell cols="3">p ( </cell><cell cols="2">i∈I C i ) =</cell><cell></cell><cell>i∈I ϕ V p (C i ), and</cell></row><row><cell cols="2">(b) if ψ(p) is negative in p, then ψ V p (</cell><cell cols="3"> i∈I C i ) =</cell><cell> i∈I ψ V p (C i );</cell></row><row><cell cols="4">2. (a) if ϕ(p) is negative in p, then ϕ V p ( </cell><cell>i∈I O i ) =</cell><cell> i∈I ϕ V p (O i ), and</cell></row><row><cell>(b) if ψ(p) is positive in p, then ψ V p (</cell><cell cols="4"> i∈I O i ) =</cell><cell> i∈I ψ V p (O</cell></row></table><note><p>i ).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>then ψ 1 (p) is syntactically closed and positive in p, while ψ 2 (p) is syntactically open and negative in p. Thus, by the inductive hypothesis, ψ 1 ( i∈I C i ) → ψ 2 (  i∈I C i ) =  i∈I ψ 1 (C i ) →  i∈I ψ 2 (C i ). The latter is equal to [  i∈I ψ 1 (C i ) ∩ (  i∈I ψ 2 (C i )) c ]↓ c , which in turn is equal to [  i∈I ψ 1 (C i ) ∩  i∈I (ψ 2 (C i )) c ]↓ c. By the associativity and commutativity of ∩, the latter is equal to[  {ψ 1 (C i ) ∩ (ψ 2 (C i )) c | i ∈ I}]↓ c . As in the previous case, since ψ 1 (p) ∩ (ψ 2 (p)) c is monotone in p, it follows from the downward-directedness of {C i } i∈I that {ψ 1 (C i ) ∩ (ψ 2 (C i )) c| i ∈ I} is a downwarddirected family of (by Lemma A.9) closed sets. Now, by Lemma A.2.2, [  {ψ 1</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>3.1, A.5.2, and A.7.2, respectively, to conclude that ⊙( i∈I ϕ 1 (C i )) =  i∈I ⊙ϕ 1 (C i ) for all ⊙ ∈ {✷, ✸, }. If ψ(p) is of the form ⊙ψ 1 (p) for ⊙ ∈ {✷, ✸, }, then ψ 1 (p) mustbe syntactically open and negative in p. Then, by the inductive hypothesis, ψ 1 ( </figDesc><table /><note><p><p>i∈I C i ) =  i∈I ψ 1 (C i ). By Lemma A.9, ψ 1 (C i</p>) is an open up-set for each i ∈ I. Moreover, by the</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>In fact, these conditions guarantee more: they guarantee that the restrictions of the adjoints of these maps are also well defined on P ↑ (W ) (more in Subsection 2.5).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>In other words, each of them is either a complete operator or a complete dual operator w.r.t. some order type: the operations ✁ and ✄ are respectively completely join-preserving and completely meet-preserving if they are taken as maps from the order dual C ∂ to C.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Of course, in principle the binary connectives ∧ and ∨ should each have two residuals, one for each coordinate; however, because ∧ and ∨ are commutative, the two residuals of each connective end up coinciding.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>This terminology is coherent with the terminology used in<ref type="bibr" target="#b5">[6]</ref> and is inspired from analogous terminology used in hybrid logic.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_4"><p>Note that the sides have been swapped around: we require that the right-hand side of the inequality must be left inductive. This is so because the first approximation rule swaps the sides of inequalities.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The research of the first author was supported by grant number 70554 of the National Research Foundation of South Africa. The research of the second author was supported by the VENI grant 639.031.726 of the Netherlands Organization for Scientific Research (NWO). We would also like to thank the anonymous reviewer for a very thorough reading and insightful comments which led to improvement of the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">ALBA succeeds on inductive and Sahlqvist inequalities</head><p>In the present section we shall prove that all inductive and Sahlqvist inequalities are ALBA inequalities, and hence, in the light of Theorems 8.1 and 9.8, that they are all elementary and canonical. Of course, it is sufficient to prove this result only for the inductive inequalities, since they have the Sahlqvist inequalities as a proper subclass. However, since the Sahlqvist inequalities are better known to most readers, and since they can be handled by a weaker version of ALBA, which uses only a restricted subset of rules, we have decided to include a separate proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1.">ALBA succeeds on all inductive inequalities</head><p>We will start with some preliminary definitions and lemmas which will be needed. Definition 10.1. Given an order type ϵ ∈ {0, ∂} n , a signed generation tree * ϕ of a term ϕ(p 1 , . . . , p n ) ∈ L + is called ϵconservative if all connectives occurring on ϵ-critical branches of * ϕ are from the base language L. In other words none of , , , or may occur on ϵ-critical branches.</p><p>The next definition extends the notion of inductive terms and inequalities to L + term and L + , essentially by keeping Definition 3.1 intact and simply forbidding connectives belonging properly to the extended language on critical branches. Nevertheless, since this definition will be used extensively, we write it out in full here.</p><p>Definition 10.2 ((Ω, ϵ)-inductive L + terms and inequalities). Given an order type ϵ and an irreflexive and transitive relation Ω on the variables p 1 , . . . , p n , the generation tree * s, * ∈ {-, +}, of a term s(p 1 , . . . ,</p><p>it is ϵ-conservative, and 2. for each 1 ≤ i ≤ n, on every ϵ-critical branch with leaf labelled p i , every choice node c with a universal node as ancestor is binary, and hence is labelled with ⋆(α • β) where ⋆ ∈ {+, -}, and moreover: (a) ϵ ∂ (⋆α), and (b) p j &lt; Ω p i for every p j occurring in α.</p><p>An inequality s ≤ t ∈ L + is (Ω, ϵ)-inductive if the trees +s and -t are both (Ω, ϵ)-inductive. The definition of definite inductive inequalities is primarily meant to capture the syntactic shape of inductive inequalities after preprocessing (see Lemma 10.4 below). Since exhaustive applications of the splitting rules are part of the preprocessing, we could have then strengthened the definition above by also excluding binary choice nodes (+∨ and -∧) as roots of generation trees. But we also want definiteness to capture a syntactic shape that results from preprocessing and which then remains stable during the subsequent applications of the reduction rules (see <ref type="bibr">Lemma 10.6)</ref>. Since +∨ and -∧ nodes in inductive formulas can occur in the scope of some universal nodes, they might 'surface' to the root of the generation tree after some reduction rule applications, so by excluding this case we would lose the desired stability of definiteness under reduction rules. Lemma 10.4. Let {s i ≤ t i } be the set of inequalities obtained by preprocessing an (Ω, ϵ)-inductive inequality s ≤ t ∈ L. Then each s i ≤ t i is a definite (Ω, ϵ)-inductive inequality.</p><p>Proof. We first prove that s i ≤ t i is an (Ω, ϵ)-inductive inequality. It is sufficient to check that the application of a distribution rule, splitting rule, monotone/antitone variable elimination rule to an (Ω, ϵ)-inductive inequality again produces an (Ω, ϵ)-inductive inequality. To that end, suppose that s 0 ≤ t 0 is an (Ω, ϵ)-inductive inequality. If s 0 ≤ t 0 is of the form s 1 ∨ s 2 ≤ t 0 , the ∨-splitting rule is applicable and yields s 1 ≤ t 0 and s 2 ≤ t 0 . We need to check that s 1 and s 2 are (Ω, ϵ)-left inductive. But any 'bad' path in the positive generation tree of s 1 or s 2 would also be bad in that of s 1 ∨ s 2 ; hence, since s 0 = s 1 ∨s 2 is (Ω, ϵ)-left inductive, we conclude that so are s 1 and s 2 . The case for s 0 ≤ t 0 of the form s 0 ≤ t 1 ∧t 2 and the ∧-splitting rule is similar.</p><p>Suppose next that a distribution rule was applied to a subformula of s 0 (respectively, t 0 ), with result s 1 (respectively, t 1 ). There are six cases, corresponding to the different distribution rules, of which we will treat cases corresponding to distribution over +∨, those for distribution over -∧ being similar:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>This self-contained appendix is aimed at proving the restricted version of Ackermann lemmas which hold on descriptive general frames. It is divided into three sections: the first one collects some well-known but useful facts on Priestley spaces that are applied in the next two sections; the results contained in the second and third ones could have been developed in a purely algebraic setting but we chose not to do so because these results are then applied in the frame-theoretic setting of canonicity via correspondence developed in Section 9. However the presentation and proofs of these facts are stated in such a way that they readily generalize to the purely algebraic setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1. Priestley spaces</head><p>A Priestley space is an ordered topological space X = (X, ≤, τ ) that is compact and totally order-disconnected, i.e., such that, for every x, y ∈ X , if x ̸ ≤ y then x ∈ U and y / ∈ U for some clopen up-set U ⊆ X ,   The base cases of the induction are those when ϕ is of the form ⊤, ⊥, p, q (for propositional variables q different from p), or i, and when ψ is of the form ⊤, ⊥, q (for propositional variables q different from p), or m. (Note that the ϕ cannot be a co-nominal m, since it is syntactically closed. Also, ψ cannot be p or a nominal i, since is negative in p and syntactically open, respectively.) These cases follow on noting (1) that</p><p>is an open up-set.</p><p>For the remainder of the proof, we will not need to refer to the valuation V and will hence omit reference to it. We will accordingly write ϕ and ψ for ϕ V p and ψ V p , respectively.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and, by Proposition</head><p>Thus, only the cases for the unary connectives remain. Notice that the cases when ϕ is of the form ϕ 1 or ϕ 1 do not occur, since these formulas are not syntactically closed. Nor do the cases when ψ is of the form ψ 1 or ψ 1 occur, since antitonicity of ψ 1 and the downward-directedness of {C i } i∈I , the family {ϕ 1 (C i )} i∈I is upward-directed. We may hence apply Lemma A.5.1, A.3.2, and A.7.1, respectively, to conclude that ⊙(</p><p>is of the form ⊙ϕ 1 (p) for ⊙ ∈ {✁, ✄, }, then ϕ 1 (p) must be syntactically open and negative in p. Then, by the inductive hypothesis, ϕ 1 (</p><p>) is a open up-set for each i ∈ I. Moreover, by the antitonicity of ϕ 1 and the downward-directedness of {C i } i∈I , the family {ϕ 1 (C i )} i∈I is upward-directed. We may hence apply Lemma A. <ref type="bibr">5.4, A.3.3, and A.7.4</ref>, respectively, to conclude that ⊙(</p><p>is of the form ⊙ψ 1 (p) for ⊙ ∈ {✁, ✄, }, then ψ 1 (p) must be syntactically closed and positive in p. Then, by the inductive hypothesis, ψ 1 (</p><p>. By Lemma A.9, ψ 1 (C i ) is a closed up-set for each i ∈ I. Moreover, by the monotonicity of ψ 1 and the downward-directedness of {C i } i∈I , the family {ϕ 1 (C i )} i∈I is downward-directed. We may hence apply Lemma A.3.4, A.5.3, and A.7.3, respectively, to conclude that ⊙(</p><p>for all ⊙ ∈ {✁, ✄, }. Thus, the proof of item (1) is concluded. Items (2) can be proved similarly by simultaneous induction on ϕ negative in p and ψ positive in p.</p><p>Proof of Lemma 9.3. To keep the notation uncluttered, we will simply write β i and γ i for β i V p and γ i V p , respectively. The implication from bottom to top follows from the monotonicity of the β i and the antitonicity of the γ i in p. Indeed, if α(V ) ≤ P,</p><p>To consider the converse implication, assume that</p><p>⊆ U}, making it the intersection of a down-directed family of closed up-sets. Thus, for any 1 ≤ i ≤ n, we have</p><p>Since β i is syntactically closed and positive in p, and γ i is syntactically open and negative in p, we may apply Lemma A.10 to obtain</p><p>for some U 1 , . . . , U m ∈ A with α(V ) ⊆ U j for 1 ≤ j ≤ m, and some U ′ 1 , . . . , U ′ m ′ ∈ A such that α(V )</p><p>Then α(V ) ⊆ B i ∈ A. By the monotonicity of β i , the antitonicity of γ i , and (26), it follows that β i (B i ) ≤ γ i (B i ). </p><p>, we get that β i (P) ≤ γ i (P) for all 1 ≤ i ≤ n.</p><p>Proof of Lemma 9.4. As before, we will write β i and γ i for β i V p and γ i V p , respectively. The implication from bottom to top follows from the antitonicity of the β i and the monotonicity of the γ i .</p><p>To prove the converse implication, assume that β i V p (α(V )) ≤ γ i V p (α(V )) for all 1 ≤ i ≤ n. But α is syntactically open and (trivially) negative in p; hence, by Lemma A.9.2, α(V ) is an open up-set, i.e., α(V ) =  {U ∈ A | U ⊆ α(V )}. Thus, for any 1 ≤ i ≤ n, it is the case that</p><p>Hence, by Lemma A.10,</p><p>The proof now proceeds like that of Lemma 9.3.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">W</forename><surname>Ackermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Untersuchung über das Eliminationsproblem der mathematischen Logic</title>
		<imprint>
			<date type="published" when="1935">1935</date>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page" from="390" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Priestley duality, a Sahlqvist theorem and a Goldblatt-Thomason theorem for positive modal logic</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Celani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jansana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic Journal of the IGPL</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="683" to="715" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The truth about algorithmic problems in correspondence theory</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chagrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Chagrova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Modal Logic</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Governatori</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Hodkinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Venema</surname></persName>
		</editor>
		<imprint>
			<publisher>College Publications</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="121" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Chagrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Modal Logic</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Completeness and correspondence in hybrid logic via an extension of SQEMA</title>
		<author>
			<persName><forename type="first">W</forename><surname>Conradie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Workshop on Methods for Modalities</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting>the 5th Workshop on Methods for Modalities</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">231</biblScope>
			<biblScope unit="page" from="175" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Algorithmic correspondence and completeness in modal logic I: the core algorithm SQEMA</title>
		<author>
			<persName><forename type="first">W</forename><surname>Conradie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Goranko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vakarelov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1:5</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Algorithmic correspondence and canonicity for non-distributive logics</title>
		<author>
			<persName><forename type="first">W</forename><surname>Conradie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palmigiano</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>in preparation</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Algebraic modal correspondence: Sahlqvist and beyond</title>
		<author>
			<persName><forename type="first">W</forename><surname>Conradie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palmigiano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sourabh</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Positive modal logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Studia Logica</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="301" to="317" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Canonical extensions and relational completeness of some substructural logics</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palmigiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="713" to="740" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Esakia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topological Kripke models</title>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="147" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Axiomatizations for some intuitionistic modal logics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Fischer-Servi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Rendiconti del Seminario Matematico. Università e Politecnico Torino</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="179" to="194" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Galatos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jipsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ono</surname></persName>
		</author>
		<title level="m">Residuated Lattices: An Algebraic Glimpse at Substructural Logics</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Sahlqvist theorem for distributive modal logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nagahashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Venema</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page" from="65" to="102" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Constructive canonicity in non-classical logics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ghilardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Meloni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="1" to="32" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Sahlqvist formulae in hybrid polyadic modal languages</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goranko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vakarelov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="737" to="254" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sahlqvist formulas unleashed in polyadic modal languages</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goranko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vakarelov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Modal Logic</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Wansing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>De Rijke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</editor>
		<meeting><address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="221" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Elementary canonical formulae: extending Sahlqvist theorem</title>
		<author>
			<persName><forename type="first">V</forename><surname>Goranko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vakarelov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">141</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="180" to="217" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the canonicity of Sahlqvist identities</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jónsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Studia Logica</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="473" to="491" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Categorical Inference and Modal Logic</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kurtonina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic, Language, and Information</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="399" to="411" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Correspondence and completeness in the first and second-order semantics for modal logic</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sahlqvist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Scandinavian Logic Symposium</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kanger</surname></persName>
		</editor>
		<meeting>the 3rd Scandinavian Logic Symposium<address><addrLine>Uppsala; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1973">1973. 1975</date>
			<biblScope unit="page" from="110" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Simpson</surname></persName>
		</author>
		<title level="m">The Proof Theory and Semantics of Intuitionistic Modal Logic</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Canonicity results of substructural and lattice-based logics</title>
		<author>
			<persName><forename type="first">T</forename><surname>Suzuki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Review of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="42" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Hybrid logics with Sahlqvist axioms</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Viana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic Journal of the IGPL</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="300" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Modal definability in languages with a finite number of propositional variables, and a new extension of the Sahlqvist class</title>
		<author>
			<persName><forename type="first">D</forename><surname>Vakarelov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Modal Logic</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Balbiani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N.-Y</forename><surname>Suzuki</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</editor>
		<imprint>
			<publisher>Kings College Publications</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="495" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F A K</forename><surname>Van Benthem</surname></persName>
		</author>
		<title level="m">Modal Logic and Classical Logic</title>
		<meeting><address><addrLine>Bibliopolis</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F A K</forename><surname>Van Benthem</surname></persName>
		</author>
		<title level="m">Handbook of Philosophical Logic</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Guenthner</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="325" to="408" />
		</imprint>
	</monogr>
	<note>Correspondence theory</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Modal frame correspondence and fixed-points</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F A K</forename><surname>Van Benthem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Studia Logica</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="133" to="155" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Methods for Canonicity</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Van Gool</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Institute for Logic, Language and Computation, Universiteit van Amsterdam</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s Thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
