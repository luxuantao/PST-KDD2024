<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Creol: A type-safe object-oriented model for distributed concurrent systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Einar</forename><surname>Broch Johnsen</surname></persName>
							<email>einarj@ifi.uio.no</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Oslo</orgName>
								<address>
									<postCode>N-0316</postCode>
									<settlement>Oslo</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Olaf</forename><surname>Owe</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Oslo</orgName>
								<address>
									<postCode>N-0316</postCode>
									<settlement>Oslo</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ingrid</forename><forename type="middle">Chieh</forename><surname>Yu</surname></persName>
							<email>ingridcy@ifi.uio.no</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Oslo</orgName>
								<address>
									<postCode>N-0316</postCode>
									<settlement>Oslo</settlement>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Creol: A type-safe object-oriented model for distributed concurrent systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2EFBB55E90A7DAC8A2EF70DFA595BA09</idno>
					<idno type="DOI">10.1016/j.tcs.2006.07.031</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Distributed object-oriented systems</term>
					<term>Type and effect system</term>
					<term>Type soundness</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Object-oriented distributed computing is becoming increasingly important for critical infrastructure in society. In standard objectoriented models, objects synchronize on method calls. These models may be criticized in the distributed setting for their tight coupling of communication and synchronization; network delays and instabilities may locally result in much waiting and even deadlock. The Creol model targets distributed objects by a looser coupling of method calls and synchronization. Asynchronous method calls and high-level local control structures allow local computation to adapt to network instability. Object variables are typed by interfaces, so communication with remote objects is independent from their implementation. The inheritance and subtyping relations are distinct in Creol. Interfaces form a subtype hierarchy, whereas multiple inheritance is used for code reuse at the class level. This paper presents the Creol syntax, operational semantics, and type system. It is shown that runtime type errors do not occur for well-typed programs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The importance of distributed computing is increasing in society with the emergence of applications for electronic banking, electronic police, medical journaling systems, electronic government, etc. All these applications are critical in the sense that system breakdown may have disastrous consequences. Furthermore, as these distributed applications are non-terminating, they are therefore best understood in terms of non-functional or structural properties. In order to reason about the non-functional properties of distributed applications, high-level formal models are needed.</p><p>It is often claimed that object orientation and distributed systems form a natural match. Object orientation is the leading paradigm for open distributed systems, recommended by the RM-ODP <ref type="bibr" target="#b41">[42]</ref>. However, standard object-oriented models do not address the specific challenges of distributed computation. In particular, object interaction by means of (remote) method calls is usually synchronous. In a distributed setting, synchronous communication gives rise to undesired and uncontrolled waiting, and possibly deadlock. In addition, separating execution threads from distributed objects breaks the modularity and encapsulation of object orientation, and leads to a very low-level style of programming. Consequently, we believe that distribution should not be transparent to the programmer as in the RPC model, rather communication in the distributed setting should be explicitly asynchronous. Asynchronous message passing gives better control and efficiency, but does not provide the structure and discipline inherent in method declarations and calls. In particular, it is unclear how to combine message passing with standard notions of inheritance. It is unsettled how asynchronous communication and object orientation should be combined. Intuitive high-level programming constructs are needed to unite object orientation and distribution in a natural way. We propose a model of distributed systems based on concurrent objects communicating by asynchronous method calls.</p><p>This paper presents the high-level object-oriented modeling language Creol <ref type="bibr" target="#b45">[46]</ref><ref type="bibr" target="#b46">[47]</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref>, which addresses distributed systems. The language is based on concurrent objects typed by behavioral interfaces, communication by asynchronous method calls, and so-called processor release points. Processor release points support a notion of non-blocking method calls, and allow objects to dynamically change between active and reactive behavior. The model integrates asynchronous communication and multiple inheritance, including method overloading and redefinition. In order to allow flexible reuse of behavior as well as of code, behavior is declared in interfaces while code is declared in classes. Both interfaces and classes are structured by multiple inheritance, but inheritance of code is separated from inheritance of behavior. Consequently, the implementation code of a class may be reused without inheriting the external behavior of the class. Creol has an operational semantics defined in rewriting logic (RL) <ref type="bibr" target="#b56">[57]</ref>, which is executable with Maude <ref type="bibr" target="#b19">[20]</ref> and provides an interpreter and analysis platform for system models.</p><p>This paper extends previous work on Creol by introducing a nominal type system for Creol programs. It is shown that the execution in objects typed by behavioral interfaces and communicating by means of asynchronous method calls is type-safe. In particular, method binding always succeeds for well-typed programs. Behavioral interfaces make all external method calls virtually bound. The typing of mutually dependent interfaces is controlled by a notion of contract. Furthermore, it is shown that the language extended with high-level constructs for local control, allowing objects to better adapt to the external non-determinism of the distributed environment at runtime, remains type-safe. Finally, the full Creol language is considered, with multiple inheritance at the class level and a pruned binding strategy for late bound internal method calls. It is shown that executing programs in the full language is type-safe.</p><p>Paper overview: The rest of this paper is structured as follows. Section 2 presents behavioral interfaces used to type object variables. Section 3 presents an executable language with asynchronous method calls, its type system, and its operational semantics. The language, type system, and operational semantics are extended in Section 4 with local control structures, and in Section 5 with multiple inheritance and the pruned binding strategy. Section 6 discusses related work and Section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Behavioral object interfaces</head><p>In object-oriented viewpoint modeling <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b77">78]</ref>, an object may assume different roles or views, depending on the context of interaction. These roles may be captured by specifications of certain parts of the externally observable behavior of objects. The specification of a role will naturally include both syntactic and semantic information about objects. A behavioral interface consists of a set of method names with signatures and semantic constraints on the use of these methods. Interface inheritance is restricted to a form of behavioral subtyping. An interface may inherit several interfaces, in which case it is extended with their syntactic and semantic requirements.</p><p>Object variables (references) are typed by behavioral interfaces. Object variables typed by different interfaces may refer to the same object identifier, corresponding to the different roles the object may assume in different contexts. An object supports an interface I if it complies with the role specified in I , in which case it may be referred to by an object variable typed by I . A class implements an interface if its object instances support the behavior described by the interface. A class may implement several interfaces. Objects of different classes may support the same interface, corresponding to different implementations of the same behavior. Reasoning control is ensured by substitutability at the level of interfaces: an object supporting an interface I may be replaced by another object supporting I or a subinterface of I in a context depending on I , although the latter object may be of another class. This substitutability is reflected in the executable language by the fact that virtual (or late) binding applies to all external method calls, as the runtime class of the called object is not statically known.</p><p>For active objects we may want to restrict access to the methods provided in an interface, to calling objects of a particular interface. This way, the active object may invoke methods of the caller and not only complete invocations of its own methods. Thus callback is supported in the run of a protocol between distributed objects. For this purpose, an interface has a semantic constraint in the form of a so-called cointerface <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b44">45]</ref>. The communication environment of an object, as considered through the interface, is restricted to external objects supporting the given cointerface. For some objects no such knowledge is required. In this case the cointerface is Any, the superinterface of all interfaces. Mutual dependency is specified if two interfaces have each other as cointerface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Syntax</head><p>A syntax for behavioral interfaces is now introduced. Let Mtd denote the set of method names, v a program variable, and T a type. The type T may be either an interface or a data type. Definition 1. A method is represented by a term method (Name, Co, Inpar, Outpar, Body),</p><p>where Name ∈ Mtd is a method name, Co is an interface, Inpar and Outpar are lists of parameter declarations of the form v : T , and Body is a pair Var, Code consisting of a list Vdecl of variable declarations (with initial expressions) and a list Code of program statements. If Mtd is a set of methods, denote the subset of Mtd with methods of a given name by Mtd(Name) = {method (Name, Co, Inpar, Outpar, Body) ∈ Mtd }.</p><p>Let M denote the set of method terms, and M the set of method names with typical element m. For convenience, the elements of a method tuple may be accessed by dot notation. The symbol denotes the empty sequence (or list). To conveniently organize object viewpoints, interfaces are structured in an inheritance hierarchy. Definition 2. An interface is represented by a term interface (Inh, Mtd) of type I, where Inh is a list of interfaces, defining inheritance, and Mtd is a set of methods such that m. Body = , for all m ∈ Mtd.</p><p>Let I denote the set of interface names, with typical elements I and J . Names are bound to interface terms in the typing environment. If I inherits J , the methods declared in both I and J must be available in any class that implements I . Dot notation may be used to refer to the different elements of an interface; e.g., interface (Is, M).Mtd = M. The name Any ∈ I is reserved for interface( , ∅), and the name ∈ I is reserved for type checking purposes. An abstract representation of an interface may be given following the syntax of Fig. <ref type="figure" target="#fig_0">1</ref>. In the abstract representation all methods of an interface have the same cointerface, declared in a with-clause, encouraging an aspect-oriented specification style <ref type="bibr" target="#b49">[50]</ref>.</p><p>Even if two interfaces have the same set of methods, it may be undesirable to (accidentally) identify them. Consequently, we use a nominal subtype relation <ref type="bibr" target="#b66">[67]</ref>. An interface is a subtype of its inherited interfaces. The subtype relation may also be explicitly extended by subtype declarations. The extension of this notion of interface with semantic constraints on the observable communication history and the refinement of such interfaces is studied in <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b44">45]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Example</head><p>In order to illustrate the interface notion and pave the way for future examples, we consider the interfaces of a node in a peer-to-peer file sharing network. A Client interface captures the client end of the node, available to any user of the system. It offers methods to list all files available in the network and to request the download of a given file from a given server. A Server interface offers a method for obtaining a list of files available from the node and a method for downloading packets, i.e., parts of a target file. The Server interface is only available to other servers in the network. Due to the cointerface, type soundness <ref type="bibr" target="#b66">[67]</ref> will guarantee that any caller of a server request understands the enquire and getPacket methods. The two interfaces may be inherited by a third interface Peer which describes nodes that are able to act according to both the client role and the server role. In the Peer interface, the cointerface requirement of each superinterface restricts the use of the methods inherited from that superinterface. For simplicity method signatures are omitted here, these are discussed in Section 3. <ref type="bibr" target="#b2">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Object interaction by asynchronous method calls</head><p>Interprocess communication is becoming increasingly important with the development of distributed computing, both over the Internet and over local networks. While object orientation is the leading framework for distributed and concurrent systems, standard models of object interaction seem less appropriate for distributed concurrent objects. To motivate Creol's asynchronous method calls, we give a brief review of the basic interaction models for concurrent processes with respect to distributed interaction.</p><p>The three basic interaction models for concurrent processes are shared variables, remote method calls, and message passing <ref type="bibr" target="#b5">[6]</ref>. Shared memory models do not generalize well to distributed environments, so shared variables are discarded as inappropriate to capture object interaction in the distributed setting. With the remote method invocation (RMI) model, an object is activated by a method call. The thread of control is transferred with the call so there is a master-slave relationship between the caller and the callee. Caller activity is blocked until the return values from the method call have been received. A similar approach is taken with the execution threads of, e.g., Hybrid <ref type="bibr" target="#b63">[64]</ref> and Java <ref type="bibr" target="#b35">[36]</ref>, where concurrency is achieved through multithreading. The interference problem related to shared variables reemerges when threads operate concurrently in the same object, which happens with non-synchronized methods in Java. Reasoning about programs in this setting is a highly complex matter <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">18]</ref>: safety is by convention rather than by language design <ref type="bibr" target="#b10">[11]</ref>. Verification considerations therefore suggest that all methods should be synchronized, which is the approach taken in, e.g., Hybrid. However, when the language is restricted to synchronized methods, an object making a remote method call must wait for the return of the call before it can proceed with its activity. Consequently, any other activity in the object is prohibited while waiting. In a distributed setting this limitation is severe; delays and instabilities may cause much unnecessary waiting. A non-terminating method will even block the evaluation of other method activations, which makes it difficult to combine active and passive behavior in the same object.</p><p>In contrast to remote method calls, message passing is a communication form without any transfer of control between concurrent objects. A method call can here be modeled by an invocation and a reply message. Message passing may be synchronous, as in Ada's rendezvous mechanism, in which case both the sender and receiver process must be ready before communication can occur. Hence, objects synchronize on message transmission. RMIs may be captured in this model if the calling object blocks between the two synchronized messages representing the call <ref type="bibr" target="#b5">[6]</ref>. If the calling object is allowed to proceed for a while before resynchronizing on the reply message we obtain a different model of method calls which from the caller perspective resembles future variables <ref type="bibr" target="#b79">[80]</ref> (or eager invocation <ref type="bibr" target="#b27">[28]</ref>). For distributed systems, even such synchronization must necessarily result in much waiting.</p><p>Message passing may also be asynchronous. In the asynchronous setting message emission is always possible, regardless of when the receiver accepts a message. Communication by asynchronous message passing is well-known from, e.g., the actor model <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>. Languages with notions of future variables are usually based on asynchronous message passing. In this case, the caller's activity is synchronized with the arrival of the reply message rather than with its emission, and the activities of the caller and the callee need not directly synchronize <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b78">79,</ref><ref type="bibr" target="#b79">80]</ref>. This approach seems well-suited to model communication in distributed environments, reflecting the fact that communication in a network is not instantaneous. Asynchronous message passing, without synchronization and transfer of the thread of control, avoids unnecessary waiting in the distributed setting by providing better control and efficiency. Generative communication in, e.g., Linda <ref type="bibr" target="#b16">[17]</ref> and Klaim <ref type="bibr" target="#b8">[9]</ref> is an approach between shared variables and asynchronous message passing, where messages without an explicit destination address are shared on a possibly distributed blackboard. However, method calls imply an ordering on communication not easily captured in these models. Actors do not distinguish replies from invocations, so capturing method calls with actors quickly becomes unwieldy <ref type="bibr" target="#b2">[3]</ref>. Asynchronous message passing does not provide the structure and discipline inherent in method calls. The integration of the message concept in the object-oriented setting is unsettled, especially with respect to inheritance and redefinition. A satisfactory notion of method call for the distributed setting should be asynchronous, combining the advantages of asynchronous message passing with the structuring mechanism provided by the method concept. Such a notion is proposed in Creol's communication model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Syntax</head><p>A simple language for concurrent objects is now presented, which combines so-called processor release points and asynchronous method calls. Processor release points influence the internal control flow in objects. This reduces time spent waiting for replies to method calls in the distributed setting and allows objects to dynamically change between active and reactive behavior.</p><p>At the imperative level, attributes and method declarations are organized in classes. Classes may have parameters <ref type="bibr" target="#b24">[25]</ref> which can be data values or objects. Class parameters are similar to constructor parameters in Java <ref type="bibr" target="#b11">[12]</ref>, except that they form part of the state, making the assignment of parameter values to object attributes redundant. Objects are dynamically created instances of classes, their persistent state consists of declared class parameters and attributes. The state of an object is encapsulated and can only be accessed via the object's methods. Among the declared methods, we distinguish the method run, which is given a special treatment operationally. After initialization the run method, if provided, is started. Apart from run, declared methods may be invoked internally and by other objects supporting the appropriate interfaces. When called from other objects, these methods reflect reactive (or passive) behavior in the object, whereas run initiates active behavior. Methods need not terminate and all method activations may be temporarily suspended. The activation of a method results in a process executed in a Creol object. In fact, execution in a Creol object is organized around an unordered queue of processes competing for the object's processor.</p><p>In order to focus on the communication aspects of concurrent objects, we assume given a functional language for defining local data structures by means of data types and functions performing local computations on terms of such data types. Data types are built from basic data types by type constructors. Definition 3. Let B be a set of basic data types and I a set of interface names, such that B ∩ I = ∅. Let denote the set of all types including the basic and interface types; i.e., B ⊆ and I ⊆ .</p><p>Let T B and T be typical elements of B and . The nominal subtype relation is a reflexive partial ordering on types, including interfaces. We let ⊥ represent an undefined (and illegal) type; thus for any type T we have ¬(⊥ T ) and ¬(T ⊥). We denote by Data the supertype of both data and interface types. Apart from Data, a data type may only be a subtype of a data type and an interface only of an interface. Every interface is a subtype of Any, except which is only related to itself (i.e.,</p><p>). Nominal constraints restrict a structural subtype relation which ensures substitutability: if T T then any value of T may masquerade as a value of T <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b53">54]</ref>. For product types R and R , R R is the point-wise extension of the subtype relation; i.e., R and R have the same length l and T i T i for every i (0 i l) and types T i and T i in position i in R and R , respectively. To explain the typing and binding of methods, is extended to function spaces A → B, where A and B are (possibly empty) product types:</p><formula xml:id="formula_0">A → B A → B ⇔ A A ∧ B B .</formula><p>For types U and V , the intersection T = U ∩ V is such that T U , T V , and T T for all T such that T U and T V . (If no such T exists, U ∩ V = ⊥.) For every type T , we let d T denote the default value of T (e.g., d I is called null for I ∈ I , d Nat may be zero, etc). Type schemes such as parameterized data types may be applied to types in to form new types in . It is assumed in the examples of the sequel that B includes standard types such as Fig. <ref type="figure">2</ref>. A syntax outline for the abstract representation of classes, excluding expressions e, expression lists E, and statement lists S (which are defined in Fig. <ref type="figure" target="#fig_2">3</ref>).</p><p>the Booleans Bool, the natural numbers Nat, and the strings Str, and that the type schemes include Set[T ] and List[T ]. Expressions without side effects are given by a functional language F defined as follows: Definition 4. Let F be a type sound functional language which consists of expressions e ∈ Expr constructed from • constants of the types in B ,</p><p>• variables of the types in , and • functions defined over terms of the types of .</p><p>In particular, ObjExpr and BoolExpr are subsets of Expr typed by interfaces and Booleans, respectively. There are no constructors or field access functions for terms of interface types, but object references may be compared by equality.</p><p>Assume given a typing environment F which provides the type information for the constants and functions in F, and let extend F with type information for variables. If d is a variable, constant, or function in F, then (d) denotes the type of d in . In particular, (d T ) = T . For e ∈ Expr, ٛ f e : T denotes that e is type-correct and has type T in (i.e., T = ⊥). If e is type-correct in and v is a variable occurring in e, then (v) = ⊥. Let Var be the type of variable names. Variable names are bound to actual values in a state.</p><formula xml:id="formula_1">Definition 5. Let : Var → Data be a state with domain {v 1 , . . . , v n }. If ( (v i )) (v i ) for every i (1 i n), then the state is well-typed.</formula><p>The evaluation of an expression e ∈ Expr, relative to a state , is denoted eval(e, ). It is assumed in Definition 4 that F is type sound <ref type="bibr" target="#b66">[67]</ref>: well-typed expressions remain well-typed during evaluation. Technically, the type soundness of F is given as follows: Let v be the variables in an expression e ∈ Expr and assume that is a well-typed state defined for all v ∈ v. If ٛ f e : T then ٛ f eval(e, ) : T such that T T . The assumption of type soundness for F leads to a restricted use of partial functions. For instance, one may adapt the order-sorted approach <ref type="bibr" target="#b33">[34]</ref> where partial functions are allowed by identifying the subdomains in which they give defined values, and require that each application of a partial function is defined. In this approach, the head of an empty list would not be type-correct, but the head of a list suffixed by an element would be type-correct.</p><p>Classes and objects: An object-oriented language is now constructed, extending the functional language F. Classes are defined in a traditional way, including declarations of persistent state variables and method definitions. Each method is equipped with an element Co specifying the cointerface associated with the method (Definition 1). For purely internal methods, the cointerface element contains the special name . Notice that Impl represents interfaces implemented by the class, whereas Contract represents interfaces implemented by the class and all subclasses. Thus, Contract claims are inherited by subclasses, but Impl claims are not. A class C is said to contract an interface I if a subinterface of I appears in the Contract clause of C or of a superclass of C. The typing of remote method calls in a class C relies on the fact that the calling object supports the contracted interfaces of C, and these are used to check the cointerface requirements of the calls. is the name of the attribute, T its type, and e an optional expression providing an initial value for v. This expression may depend on the actual values of the class parameters. A statement v : T without an initial expression is initialized to the default value d T . Overloading of methods is allowed. The pseudo-variable self is used for self reference in the language; its value cannot be modified. Issues related to inheritance are considered in Section 5; until then, we consider classes without explicit inheritance.</p><p>An object offers methods to its environment, specified through a number of interfaces. All interactions between objects happen through method calls. In the asynchronous setting method calls can always be emitted, because the receiving object cannot block communication. Method overtaking is allowed: if methods offered by an object are invoked in one order, the object may evaluate the corresponding method activations in another order. A method activation is, roughly speaking, a list s of program statements evaluated in the context of a state. Due to the possible interleavings of different method executions, the values of an object's program variables are not entirely controlled by a method activation which suspends itself before completion. However, a method may have local variables supplementing the object attributes. In particular, the values of formal parameters are stored locally, but other local variables may also be created. Among the local variables of a method, certain variables are used to organize interobject communication; there is read-only access to caller and label. Assignment to local and object variables is expressed as v := e for (the same number of) program variables v and expressions e. In the object creation statement v := new C(e), v must be a variable declared of an interface implemented by C and e are actual values for the class parameters. We refer to C(e) as the instantiated class name. The syntax for program statements is given in Fig. <ref type="figure" target="#fig_2">3</ref>.</p><p>Let Label denote the type of method call identifiers, partially ordered by &lt; and with least element 1, and let the operation next : Label → Label be such that ∀x ∈ Label . x &lt; next(x). A method is asynchronously invoked with the statement t!x.m(e), where t ∈ Label provides a locally unique reference to the call, x is an object expression, m a method name, and e an expression list with the actual in-parameters supplied to the method. The call is internal when x is omitted, otherwise the call is external. A method with as cointerface may only be called internally. Labels are used to identify replies and may be omitted if a reply is not explicitly requested. As no synchronization is involved, process execution can proceed after calling a method until the return value from the method is actually needed by the process.</p><p>To fetch the return values from a call v, say in a variable list v, we may ask for the reply to our call: t?(v). This statement treats v as a list of future variables. If the reply to the call has arrived, return values may be assigned to v and the execution continues without delay. If the reply has not arrived, process execution is blocked at this statement. In order to avoid blocking in the asynchronous case, processor release points are introduced by means of reply guards. In this case, process execution is suspended rather than blocked.</p><p>Any method may be invoked in a synchronous as well as an asynchronous manner. Synchronous (RMI) method calls are given the syntax x.m(e; v), which is defined by t!x.m(e); t?(v) for some fresh label t, immediately blocking the processor while waiting for the reply. This way the call is perceived as synchronous by the caller, although the interaction with the callee is in fact asynchronous. The callee does not distinguish synchronous and asynchronous invocations of its methods. It is clear that in order to reply to local calls, the calling method must eventually suspend its own execution. A local call may be either internal, or external if the callee is equal to self . Therefore, the reply statement t?(v) enables execution of the call identified by t when this call is local. The language does not otherwise support monitor reentrance; mutual or cyclic synchronous calls between objects may therefore lead to deadlock.</p><p>Potential suspension is expressed through processor release points, a basic programming construct in the language, using guard statements <ref type="bibr" target="#b28">[29]</ref>. In Creol, guards influence the control flow between processes inside concurrent objects. A guard g is used to explicitly declare a potential release point for the object's processor with the statement await g. Guard statements can be nested within a method body, corresponding to a series of potential suspension points. Let s 1 and s 2 denote statement lists; in s 1 ; await g; s 2 the guard g corresponds to an inner release point. A guard statement is enabled if its guard evaluates to true. When an inner guard which is not enabled is encountered during process execution, the process is suspended and the processor released. The wait guard is a construct for explicit release of the processor. The reply guard t? is enabled if the reply to the method invocation with label t has arrived. Guards may be composed: g 1 ∧ g 2 is enabled if both g 1 and g 2 are enabled. The evaluation of guard statements is atomic. After process suspension, the object's suspended processes compete for the free processor: any suspended and enabled process may be selected for execution. For convenience, we introduce the following abbreviations: await t?(v) = await t? ; t?(v) await r(e; v) = t!r(e) ; await t?(v) where t is a fresh label.</p><p>Using reply guards, the object processor need not block while waiting for replies. This approach is more flexible than future variables: suspended processes or new method activations may be evaluated while waiting for a reply. If the called object does not eventually reply, deadlock is avoided in the sense that other activity in the object is possible although the process itself will a priori remain suspended. However, when a reply arrives, the continuation of the original process must compete with other enabled suspended processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Virtual binding</head><p>Due to the interface typing of object variables, the actual class of the receiver of an external call is not statically known. Consequently, external calls are virtually bound.</p><p>Let the function Sig give the signature of a method, defined by Sig(m) = type(m.Inpar) → type(m.Outpar) where type returns the product of the types in a parameter declaration. The static analysis of a synchronous internal call m(e; v) assigns unique types to the in-and out-parameter depending on the textual context, say that the parameters are textually declared as e : T e and v : T v . The call is type-correct if there is a method declaration m :</p><formula xml:id="formula_2">T 1 → T 2 in the class C such that T 1 → T 2</formula><p>T e → T v . A synchronous external call o.m(e; v) to an object o of interface I is type-correct if it can be bound to a method declaration in I in a similar way. The static analysis of a class verifies that it implements the methods declared in its interfaces. Assuming that any object variable typed by an interface I points to an instance of a class implementing I , method binding will succeed regardless of the actual class of the object. At runtime, the class of the object is dynamically identified and the method is virtually bound. Remark that if the method is overloaded, i.e., there are several methods with the same name in the class, the types of the actual parameter values, including the out-parameter, and the actual cointerface are used to correctly bind the call (see <ref type="bibr">Section 5)</ref>.</p><p>Asynchronous calls may be bound in the same way, provided that the type of the actual parameter values and cointerface can be determined. In the operational semantics of Creol, it is assumed that this type information is included at compile-time in both synchronous and asynchronous method invocations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Example</head><p>A peer-to-peer file sharing system consists of nodes distributed across a network. Peers are equal: each node plays both the role of a server and of a client. In the network, nodes may appear and disappear dynamically. As a client, a node requests a file from a server in the network and downloads it as a series of packet transmissions until the file download is complete. The connection to the server may be blocked, in which case the download automatically resumes if the connection is reestablished. A client may run several downloads concurrently, at different speeds. We assume that every node in the network has an associated database with shared files. Downloaded files are stored in the database, which Here, getFile returns a list of packets; i.e., a sequence of sequences of data, for transmission over the network, getLength returns the number of such sequences, listFiles returns the list of available files, and storeFile adds a file to the database, possibly overwriting an existing file.</p><p>Nodes in the peer-to-peer network which implement the Peer interface can be modeled by a class Node, given in Fig. <ref type="figure" target="#fig_3">4</ref>. Node objects can have several interleaved activities: several downloads may be processed simultaneously as well as uploads to other servers, etc. All method calls are asynchronous: if a server temporarily becomes unavailable, the transaction is suspended and may resume at any time after the server becomes available again. Processor release points ensure that the processor will not be blocked and transactions with other servers not affected. In the class, the method availFiles returns a list of pairs where each pair contains a file identifier fId and the server identifier sId where fId may be found, reqFile the file associated with fId, enquire the list of files available from the server, and getPacket a particular packet in the transmission of a file. The list constructor is represented by semicolon. For x : T and s : List[T ], we let hd(x; s) = x, tl(x; s) = s, and s[i] denote the i'th element of s, provided i length(s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Typing</head><p>The type analysis of statements and declarations is formalized by a deductive system for judgments of the form</p><formula xml:id="formula_3">ٛ i D ,</formula><p>where is the typing environment, i ∈ {s, v} specifies the syntactic category (Stm or Var, respectively), D is a Creol construct (statement or declaration), and is the update of the typing environment. The typing judgment means that D contains no type errors when checked with the environment . The typing environment resulting from the type analysis of D becomes overridden by , denoted by + . The rule for sequential composition seq is captured by</p><formula xml:id="formula_4">(SEQ) ٛ i D + ٛ i D ٛ i D; D +</formula><p>where + is an associative operator on mappings with the identity element ∅. We abbreviate ٛ i D ∅ to ٛ i D.</p><p>For our purpose, the typing environment is given as a family of mappings: F describes the constants and operators of F, I the binding of interface names to interface terms, C the binding of class names to class terms, v the binding of program variable names to types, the mapping P is related to the binding of asynchronous internal and external method calls, and Sig stores derived actual signatures for asynchronous method invocations. Remark that I and C correspond to static tables. Declarations may only update v and program statements may not update v . Mapping families are now formally defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7.</head><p>Let n be a name, d a declaration, i ∈ {I, C, V , P, Sig} a mapping index, and [n i → d] the binding of n to d indexed by i. A mapping family is built from the empty mapping family ∅ and indexed bindings by the constructor +. The mapping with index i is extracted from as follows:</p><formula xml:id="formula_5">∅ i = ( + [n i → d]) i = if i = i then i + [n i → d] else i .</formula><p>For an indexed mapping i , mapping application is defined by</p><formula xml:id="formula_6">(n) = ⊥ ( i + [n i → d])(n ) = if n = n then d else i (n ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1.">Typing of programs</head><p>A class or interface declaration binds a name to a class or interface term, respectively. Class and interface names need not be distinct. A program consists of interface and class declarations, represented by the mappings I : I → I and C : C → C, and an initial object creation message new C(e). In a nominal type system, each interface and class of a program is type checked in the context of the mappings F , I , and C .</p><p>(PROG)</p><formula xml:id="formula_7">∀ I ∈ I • I ٛ I (I ) F + C ٛ s new C(e) ∀ C ∈ C • F + I + C + [self v → C] ٛ C (C) c F ٛ I , C , new C(e) C∈ C c Sig .</formula><p>When type checking a class, self is bound to the class name. Type checking a program succeeds if all interfaces are well-formed, all classes are type-correct, and the initial object creation message is type-correct in the context of the program's class declarations. In order to focus on the type checking of classes, the method set Mtd of interface terms here includes both locally declared and inherited methods. The rule for type checking interface declarations may now be given as follows:</p><formula xml:id="formula_8">(INTERFACE) ∀ m ∈ Mtd • ٛ v m.Inpar ; m.Outpar ٛ interface (Inh, Mtd) .</formula><p>The type checking of classes is now considered in detail. The rule for type checking class declarations is given as follows:  A class may implement a number of interfaces. For each interface, the class must provide methods with signatures that are correct with respect to the method signatures of the interface. The class' variable declarations are type checked after extending the typing environment with the class parameters, because the variable declarations may include initial expressions that use these parameters. Before type checking the methods, the typing environment is extended with the declared parameters and variables of the class. Method bodies are type checked in the typing environment updated after type checking method parameters and local attributes, including caller. At this point P is empty, since no asynchronous method invocation has been encountered. In order to use self-reference in expressions inside classes, we introduce qualified self-references by the keyword qua, which uniquely controls the typing in case the class has many contracts.</p><formula xml:id="formula_9">(CLASS) ٛ v Param; Var ∀ m ∈ Mtd • + ٛ m m ∀ I ∈ (Impl; Contract) • ∀m ∈ I (I ).Mtd • ∃m ∈ Mtd• m.Name = m .Name ∧ Sig(m) Sig(m ) ∧ m .Co m.Co ٛ class (Param, Impl, Contract, , Var, Mtd) m∈Mtd m Sig .</formula><p>(SELF-REF)</p><formula xml:id="formula_10">∃ I ∈ ( C ( v (self )).Contract; Any) • I I ٛ f self qua I : I .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2.">Typing of parameter and variable declarations</head><p>A method may have local variable declarations preceding the program statements. Thus, both class and local variable declarations may extend the typing environment provided that these are not previously declared in the typing environment. The typing rules for variable and parameter declarations are given in Fig. <ref type="figure" target="#fig_4">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3.">Typing of basic statements</head><p>The typing of basic statements is given in Fig. <ref type="figure" target="#fig_1">6</ref>, as well as a statement for object creation. The typing system for F is used to type check expressions. The last premise of new ensures that the new object implements an interface which is a subtype of the declared interface of the variable v, extending rule new2 for initial object creation messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.4.">Typing of asynchronous calls</head><p>In order to successfully bind method calls, the types of the formal parameters and cointerface of the declared method must correspond to the types of the actual parameters and cointerface of the call. This is verified by a predicate match, defined as follows: Definition 8. Let T and U be types, I an interface, m a method name, and m a set of methods. Define match :</p><formula xml:id="formula_11">M × × I × Set[M] → Bool by match(m, T → U, I, ∅) = false match(m, T → U, I, {m } ∪ m) = (m = m .Name ∧ I m .Co ∧ Sig(m ) T → U).</formula><p>If a call has a match in an interface or class, we say that the call is covered: Definition 9. An external method call is covered in an interface if there is a method declaration in the interface which may be type-correctly bound to the call, including the actual parameter types of output variables. An internal method call is covered in a class if there is a method declaration in the class, or a superclass, which may be type-correctly bound to the call, including the actual parameter types of output variables.</p><p>For synchronous calls, it is straightforward to check whether a call is covered, since the types of the actual inand out-parameters can be derived directly from the textual invocation. In contrast, checking whether asynchronous calls are covered is more involved, since the type information provided by the textual invocation is not sufficient: the correspondence between in-and out-parameters is controlled by label values. The increased freedom in the language gained from using labels requires a more sophisticated type analysis. In order to use the type system to derive signatures for asynchronous method invocations, it is assumed in method bodies that every asynchronous invocation using a label t is uniquely indexed; e.g., t!r(e) is transformed by the parser into t i !r(e) for a fresh index i. The mappings P : Label → Set[Nat] and Sig : Label Nat → I × M × I × are used as an effect system <ref type="bibr" target="#b54">[55,</ref><ref type="bibr" target="#b73">74]</ref> for type checking asynchronous calls. The mapping P maps labels to sets of indices, uniquely identifying the occurrences of calls corresponding to a label. The mapping Sig maps indexed labels to tuples containing the information needed to later refine the type analysis of the method calls associated with the indexed labels. For a label t and any i ∈ P (t), t is the label associated with the ith internal or external asynchronous pending call for which the types of the out-parameters have yet to be resolved. After the out-parameters have been resolved, Sig (t i ) is updated with the refined actual signature of the call associated with the indexed label t i . Hence, Sig provides the interface of the callee and the actual signature for the asynchronous calls in the code. Both mappings P and Sig are part of the typing environment used for type checking method bodies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.4.1.">External and internal invocations and replies.</head><p>The typing rules for external and internal invocations and replies are given in Fig. <ref type="figure" target="#fig_7">7</ref>. As the types of the actual in-and out-parameters of every synchronous call can be derived immediately, the type system can directly decide if the call is type-correct. Asynchronous calls without labels can also be type checked directly, as the reply values cannot subsequently be requested. Consequently, the type of any formal out-parameter is type checked against the supertype Data. For an external asynchronous invocation with indexed label t i , the type of the return values is yet unknown. Type checking with the exact type of the out-variables must be postponed until the corresponding reply statement for t is eventually analyzed. Therefore, i is added to the set of pending calls P (t) and the invocation is recorded in Sig with a mapping from t i to the callee's interface, the method name, the caller's interface, and a preliminary actual signature for the call. Some erroneous invocations may already be eliminated by type checking against this preliminary signature.</p><p>For internal calls, the method must have cointerface . For external calls x.m, the interface of x must offer a method m with a cointerface contracted by the current class (and thereby supported by the actual calling object). This implies that remote calls to self are allowed when the class itself contracts an interface allowed as cointerface for the method.</p><p>A reply is requested through a reply statement or a guard, if there are pending invocations with the same label. For a reply statement t?(v), the matching invocations must be type checked again as the types of the out-parameters v are now known. If the reply rule succeeds, all pending calls on t have been type checked against the actual type of v. This type checking depends on the interface of the callee for external calls and the class of self for internal calls. The pending calls on t are removed from P and the stored signatures for these calls in Sig are replaced by the refined signatures. Note that the type-correctness of pending calls without a corresponding reply statement is given directly by the typing rules for method invocations, i.e., the preliminary signature was sufficiently precise.</p><p>Example. Typing with labeled invocation and reply statements, where the binding depends on out-parameters, is illustrated by the following example Here type checking succeeds, binding the call to m in run to interface B. Let t 1 be the (first) invocation with label t. The result of the type analysis is that Sig (t 1 ) = AB, m, AB, → Nat . This information is passed on to the runtime system to ensure proper binding of the call. At runtime the call is then bound to the last declaration of m in C (see Section 3.5). In contrast, if the reply statement were removed from run, the result of the type analysis would be Sig (t 1 ) = AB, m, AB, → Data and the call may be bound to either m. Some initial properties of the type system are now presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1. No type checked list of program variable declarations dereference undeclared program variables.</head><p>Proof. The proof is by induction over the length of a type checked list Var of program variable declarations. If Var = , no variables are dereferenced and the lemma holds. We now assume that no undeclared program variables are dereferenced in Var and show that this is also the case for Var; v : T = e by considering the variables in e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let</head><p>= + such that ٛ v Var . Rule var requires that ٛ f e : T . It follows from the type system for F that T = ⊥, so all variables in e have been declared in .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. No type checked methods assign to or dereference undeclared program variables.</head><p>Proof. We consider a method term method (Name, Co, Inpar, Outpar, Body) type checked in the context of some class. The in-and out-parameters Inpar and Outpar, label, and caller do not have initial expressions, so they do not dereference any program variables. The method body Body consists of a list of local variable declarations Var and a list of program statements Code. It follows from Lemma 1 that Var does not dereference undeclared program variables. The proof proceeds by induction over the length of Code. Recall that if ٛ f e : T for some expression e, then T = ⊥, so for all variables v in e, (v) = ⊥ and v is declared in .</p><p>If Code = , the lemma trivially holds. For the induction step, we now assume that no undeclared program variables are assigned to or dereferenced in Code and show that this also holds for Code; s by case analysis of s. Let = + such that ٛ s Code . • No program variables are assigned to or dereferenced by skip.</p><p>• For v := e, the assign rule asserts that ٛ f e : T and T</p><formula xml:id="formula_12">v (v). Since T v (v), v (v) = ⊥ and v is declared.</formula><p>• For x := new C(e), the new rule asserts that ٛ f e : T and that there exists an interface I ∈ C (C).Impl; C (C).</p><p>Contract such that I v (x). Consequently, v (x) = ⊥ and x is declared. • For x.m(e; v), rule ext-sync asserts that ٛ f x : I , ٛ f e : T and there is a cointerface</p><formula xml:id="formula_13">Co ∈ C ( v (self )).Contract such that match(m, T → v (v), Co, I (I ).Mtd).</formula><p>The match is impossible unless v (v) = ⊥. • For !x.m(e), rule ext-async asserts that ٛ f x : I and ٛ f e : T . • For t!x.m(e), the additional condition v (t) = Label of rule ext-async-l asserts that also t has been declared.</p><p>• For m(e; v), rule int-sync gives us the judgment ٛ f e : T such that match(m,</p><formula xml:id="formula_14">T → v (v), , C ( v (self )).Mtd).</formula><p>It follows that v (v) = ⊥. • For !m(e), rule int-async asserts that ٛ f e : T . • For t!m(e), the additional condition v (t) = Label of rule int-async-l asserts that also t has been declared. • For t?(v), rule reply asserts that P (t) = ∅, so there are pending calls on label t. Consequently there must be an invocation on t in Code which has been type checked by either ext-async-l or int-async-l. In both cases, the condition v (t) = Label guarantees that t has been declared. The matches for the pending calls on t imply that v (v) = ⊥. • For await g, induction over the construction of g shows that all variables are declared. The base cases are handled by await-b and await-t?. • s 1 ; s 2 follows by the induction hypothesis. It follows from Lemma 3 that a minimal requirement for successful binding is that an invocation can be bound with Data as the type of the actual out-parameter. This is reflected in the typing rules. This minimal requirement is sufficient to show that the call may be bound correctly unless the return values from the asynchronous call are assigned to program variables. Lemma 4. Let be a mapping family such that P = . For any statement list s with a type judgment ٛ s s , the set P contains exactly the labeled method invocations for which the return values may still be assigned to program variables after s.</p><p>Proof. The proof is by induction over the length of s. If s = , we get P = . Assume as induction hypothesis that for ٛ s s , P contains the invocations for which the return values may still be assigned to program variables after s. For the induction step, we prove that for ٛ s s; s + , ( + ) P contains the method invocations for which the return values may still be assigned to program variables after s; s, by case analysis of s.</p><p>• For skip, v := e, x := new C(e), and await g, there are no new method calls, so P = and ( + ) P contains exactly the method invocations that may need further analysis by the induction hypothesis.</p><p>• For e.m(e; v), m(e; v), !e.m(e), and !m(e), the type system allows the type-correctness of these statements to be verified directly. Consequently, P = and ( + ) P contains the method invocations for which the return values may still be assigned to program variables by the induction hypothesis. • For t i !e.m(e), an eventual reply statement may later impose a restriction on the type of the out-values. Note that previous calls pending on t are no longer accessible to such a reply statement. The effect of the ext-async-l rule records only the new call as pending on t, yielding P = [t P → {i}]. It follows that ( + ) P contains exactly the method invocations for which the return values may still be assigned to program variables after s; t i !e.m(e).</p><p>• For t i !m(e), the case is similar. The effect of the int-async-l rule yields P = [t P → {i}]. It follows that ( + ) P contains exactly the method invocations for which the return values may still be assigned to program variables after s; t i !m(e). • For t?(v) the reply rule states that P (t) = ∅ and P (t) =⊥, so there are pending calls to t in P which are type checked with the new out-parameter type and removed from P . The effect of reply is P = [t P → ∅] and it follows from the induction hypothesis that ( + ) P contains exactly the invocations for which the return values may be assigned to program variables after s; t?(v).</p><p>• s 1 ; s 2 follows from the induction hypothesis.</p><p>It follows that all asynchronous invocations can be precisely type checked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5. In a well-typed program, all method invocations have been verified as type-correct by the type analysis.</head><p>Proof. We consider method invocations in the code s of an arbitrary method body in a class of the program, with the type judgment ٛ s s</p><p>. As P = , Lemma 4 states that P contains exactly the method invocations that may need further type checking. As the entire method body s has been type checked, the invocations in P may be safely bound with the weakest possible type for actual out-variables, which has already been checked.</p><p>Note that for any typing environment used in type checking a well-typed program of Section 3 and for any label t in this program, # P (t) 1 and there can be at most one reply statement in the program corresponding to any label t. Consequently, the following lemma holds for the language and type system considered in this section: Lemma 6. In a well-typed method, a signature and cointerface can be derived for every method invocation in the body, such that the invocation is covered. Proof. Let s be the code in a well-typed method such that ٛ s s . The proof is by induction over s. For s = , the lemma holds trivially. Now let s = s 0 ; s; s 1 and assume as induction hypothesis that well-typed signatures and cointerfaces have been derived for every invocation in s 0 , we now show that this is also the case for s 0 ; s.</p><formula xml:id="formula_15">Let ٛ s s o ; s</formula><p>. The proof is by case analysis of s; only statements that invoke methods are discussed. (The remaining cases follow directly from the induction hypothesis.) • For o.m(e; v), rule ext-sync provides the signature T → v (v), where ٛ f e : T , and cointerface Co, such that the invocation is covered. • For !o.m(e), rule ext-async provides the signature T → Data, where ٛ f e : T , and cointerface Co, such that the invocation is covered. • For t i !o.m(e), rule ext-async-l provides the signature T → Data, where ٛ f e : T , and cointerface Co, for which the rule gives a match. This signature and cointerface Co are stored in Sig (t i ). If there is a reply statement t?(v) in s 1 before an invocation labeled t j (i = j ), the return values from the call t i !o.m(e) will be assigned to v. Hence, the reply rule refines the signature to T → v (v) in Sig (t i ), such that the invocation is covered by the new signature and Co. Otherwise, the return values from the call are not accessible and Sig (t i ) = Sig (t i ). In both cases, Sig (t i ) provides a signature and cointerface such that the invocation is covered. • For m(e; v), the int-sync rule provides the signature T → v (v), where ٛ f e : T , and cointerface Co.</p><p>• For !m(e), the int-async rule provides the signature and cointerface.</p><p>• For t i !m(e), the int-async rule provides a signature and cointerface. The signature may be refined by a reply statement as for t i !o.m(e). The call is covered by the signature and cointerface provided by ( + ) Sig (t i ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Operational semantics</head><p>The operational semantics of the language is defined in RL <ref type="bibr" target="#b56">[57]</ref>. A rewrite theory is a 4-tuple R = ( , E, L, R), where the signature defines the function symbols of the language, E defines equations between terms, L is a set of labels, and R is a set of labeled rewrite rules. From a computational viewpoint, a rewrite rule t -→ t may be interpreted as a local transition rule allowing an instance of the pattern t to evolve into the corresponding instance of the pattern t . Each rewrite rule describes how a part of a configuration can evolve in one transition step. If rewrite rules may be applied to non-overlapping subconfigurations, the transitions may be performed in parallel. Consequently, concurrency is implicit in RL. A number of concurrency models have been successfully represented in RL <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b56">57]</ref>, including Petri nets, CCS, actors, and unity, as well as the ODP computational model <ref type="bibr" target="#b62">[63]</ref>. RL also offers its own model of object orientation <ref type="bibr" target="#b19">[20]</ref>.</p><p>Informally, a state configuration in RL is a multiset of terms of given types. Types are specified in (membership) equational logic ( , E), the functional sublanguage of RL which supports algebraic specification in the OBJ <ref type="bibr" target="#b33">[34]</ref> style. When modeling computational systems, configurations may include the local system states. Different parts of the system are modeled by terms of the different types defined in the equational logic.</p><p>RL extends algebraic specification techniques with transition rules: the dynamic behavior of a system is captured by rewrite rules, supplementing the equations which define the term language. Assuming that all terms can be reduced to normal form, rewrite rules transform terms modulo the equations in E. Conditional rewrite rules are allowed, where the condition is formulated as a conjunction of rewrites and equations which must hold for the main rule to apply:</p><formula xml:id="formula_16">subconfiguration -→ subconfiguration if condition.</formula><p>Rules in RL may be formulated at a high level of abstraction, closely resembling a structural operational semantics. In fact, structural operational semantics can be uniformly mapped into RL specifications <ref type="bibr" target="#b57">[58]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1.">System configurations</head><p>Synchronous and asynchronous method calls are given a uniform representation in the operational semantics: objects communicate by sending messages. Messages have the general form message to dest where dest is a single object or class, or a list of classes. The actual signature and cointerface of a method call, as derived during type checking (Lemma 6), are now assumed to be included as arguments to the method invocations of the runtime system. (After the signatures and cointerfaces of invocations have been included, the label indices for asynchronous method invocations are erased.) If an object o 1 calls a method m of an object o 2 , with actual type Sig, cointerface Co, and actual parameters e, and the execution of m(Sig, Co, e) results in the return values e , the call is reflected by two messages invoc(m, Sig, Co, (n o 1 e)) to o 2 and comp(n, e ) to o 1 , which represent the invocation and completion of the call, respectively. In the asynchronous setting invocation messages will include the caller's identity, which ensures that completions can be transmitted to the correct destination. Objects may have several pending calls to another object, so the completion message includes a locally unique label value n, generated by the caller. Object activity is organized around a message queue which contains incoming messages and a process queue which contains suspended processes; i.e., remaining parts of method activations.</p><p>A state configuration is a multiset combining Creol objects, classes, and messages. (In order to increase the parallelism in the model, message queues could be external to object bodies <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b46">47]</ref>.) In RL, objects are commonly represented by terms of the type O : C |a 1 : v 1 , . . . , a n : v n where O is the object's identifier, C is its class, the a i 's are the names of the object's attributes, and the v i 's are the corresponding values <ref type="bibr" target="#b19">[20]</ref>. We adopt this form of presentation and define Creol objects and classes as RL objects. Let a process be a pair consisting of a sequence of program statements and a local state, given by a mapping which binds program variables to values of their declared types. Omitting RL types, a Creol object is represented by an RL object Ob | Cl, Att, Pr, PrQ, EvQ, Lab , where Ob is the object identifier, Cl the class name, Att the object state, Pr the active process, PrQ a multiset of suspended processes, EvQ a multiset of unprocessed messages, and Lab of type Label is the method call identifier, respectively. Thus, the object identifier Ob and the generated local label value provide a globally unique identifier for each method call.</p><p>At runtime, classes are represented by RL objects Cl | Par, Att, Mtds, Tok , where Cl is the class name, Par and Att are lists of parameter and attribute declarations, Mtds is a multiset of methods, and Tok is an arbitrary term of sort Label. A method has a name, signature, cointerface, in-parameter, and body. When an object needs a method, it is bound to a definition in the Mtds multiset of the appropriate class. In RL's object model <ref type="bibr" target="#b19">[20]</ref>, classes are not represented explicitly in the system configuration. This leads to ad hoc mechanisms to handle object creation, which we avoid with explicit class representations. The Creol construct new C(e) creates a new object with a unique object identifier, attributes as listed in the class parameter list and in Att, and places the code from the run method in Pr. An initial (state) configuration consists of class representations and an initial new message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2.">Executions</head><p>An execution of a program P is a sequence of state configurations such that there is a rewrite step in the operational semantics between every two consecutive configurations. The operational semantics is given in Fig. <ref type="figure" target="#fig_9">8</ref>. There are three main kinds of rewrite rules:</p><p>• Rules that execute code from the active process: For every program statement there is at least one rule. For example, the assignment rule R1 for the statement v := e binds the values of the expression list e to the list v of local and object variables. • Rule R5 suspends the active process: When an active process guard evaluates to false, the process and its local variables are suspended, leaving Pr empty. • Rule R6 activates a suspended process: If Pr is empty, suspended processes may be activated. The rule selects an arbitrary suspended and enabled process for activation. In addition, transport rules (R11 and R17) move messages into the message queues, representing network flow. The rules are now briefly presented. Auxiliary functions are defined in equational logic and are therefore evaluated in between the state transitions <ref type="bibr" target="#b56">[57]</ref>; e.g., the equation ( := ) = removes empty assignments. Irrelevant attributes are ignored in the style of Full Maude <ref type="bibr" target="#b19">[20]</ref>. A detailed discussion may be found in <ref type="bibr" target="#b46">[47]</ref>.</p><p>Whitespace is used as the constructor of multisets, such as PrQ and EvQ, as well as variable and expression lists, whereas semicolon (with as left and right identity) is used as the constructor of lists of statements in order to improve readability. The skip statement is understood as . As before, + is the constructor for mappings. In the assignment rule R1, a list of expressions is evaluated and bound to a list of program variables. The auxiliary function eval evaluates an expression in a given state; the equations for the functional language F extend state lookup, given by</p><formula xml:id="formula_17">eval( , l) = eval(v, l + [v → d]) = if v = v then d else eval(v, l) fi eval(v v, l) = (eval(v, l) eval(v, l)).</formula><p>In the object creation rules R2 and R3, an object state is constructed from the class parameters and attribute list, an object identifier for the new object is constructed, and the run method is synchronously invoked. Let self of type Any be the self reference in a runtime object. The object identifier (C; n) is, by the typing rule new, typed by an interface I such that I Any. The parameter is represented as a typed list of variables to accommodate the assignment rule. In order to apply R1 to the initialization of the object state, a type erasure function on attribute lists is introduced, defined recursively by ( ) ↓= and (v: T = e; s) ↓= v := e; (s) ↓. New object identifiers are created by concatenating tokens n from the unbounded set Tok to the class name. The identifier is returned to the object which initiated the object creation. Before the new object can be activated, its state must be initialized. This is done by assigning actual values to class parameters and then evaluating the attribute list. The rules R4, R5, and R6 for guards depend on an enabledness function. Let d denote a state and let the infix function in check whether a completion message corresponding to a given label value is in a message queue q. The enabledness function is defined by induction over the construction of guards:</p><formula xml:id="formula_18">enabled(t?, d, q) = eval(t, d) in q enabled(b, d, q) = eval(b, d) enabled(wait, d, q) = false enabled(g ∨ g , d, q) = enabled(g, d, q)∨enabled(g , d, q) enabled(g ∧ g , d, q) = enabled(g, d, q)∧enabled(g , d, q).</formula><p>When a non-enabled guard is encountered in R5, the active process is suspended on the process queue. In this rule, the auxiliary function clear removes occurrences of wait from any leading guards. The enabledness predicate is extended to statements as follows (where s may match an empty statement list):</p><formula xml:id="formula_19">enabled(s; s ; s, d, q) = enabled(s, d, q) enabled(await g, d, q) = enabled(g, d, q) enabled(s, d, q) = true [ otherwise ].</formula><p>The otherwise attribute of the last equation states that this equation is taken when no other equation matches.</p><p>In R7, a synchronous call r(Sig, Co, e; v), where v is a list of variables and r is either m or x.m, is translated into an asynchronous call, !r(Sig, Co, e), followed by a blocking reply statement, n?(v), where n is the label value uniquely identifying the call. In R8 a labeled asynchronous call is translated into a label assignment and an unlabeled asynchronous call, which results in an invocation message in R9. Internal calls are treated as external calls to self in R10. Guarded calls are expanded to asynchronous calls and guarded replies, as defined in Section 3.1.</p><p>When an object calls a method, a message is emitted into the configuration (R9 or R10) and delivered to the callee (R11) where msg ranges over invocations and completions. Message overtaking is captured by the non-determinism inherent in RL: invocation and completion messages sent by an object to another object in one order may arrive in any order. The call is bound by sending a bind message to the class of the object (R12). Note that for external calls, the class of the callee is first identified in this rule; consequently external method calls are virtually bound.</p><p>The bind message is handled by R16, which identifies the method m in the method multiset m of the class. The auxiliary predicate match(m, Sig, Co, m) evaluates to true if m is declared in m with a signature Sig and cointerface Co such that Sig Sig, Co Co . Note that a method-not-understood error is represented by a bind message sent to an empty list of classes. Furthermore, the auxiliary function get returns a process with the method's code and local state (instantiating the method's in-parameters with the call's actual parameters e and binding local variable declarations to initial expressions) from the method multiset m of the class, and ensures that a completion message is emitted upon method termination, by appending a special construct return(v) to the method code. The values of the actual inparameters, the caller, and the label value n are stored locally; the caller and label value are stored in the local variables caller and label. The special construct return(v) is used in R18 to return a uniquely labeled completion message to the caller. The process w resulting from the binding is loaded into the internal process queue in R17.</p><p>The reply statement fetches the return values corresponding to v from the completion message in the object's queue (R13). In the model, EvQ is a multiset; thus the rule matches any occurrence of comp(n, e) in the queue. The use of rewrite rules rather than equations mimics distributed and concurrent processing of method lookup. Note the special construct cont (n) in R14 and R15, which is used to control local calls in order to avoid deadlock in the case of self-reentrance and impose a LIFO ordering of local calls <ref type="bibr" target="#b46">[47]</ref>.</p><p>Example. We consider an execution sequence inspired by the example of Section 3.  after the type analysis. This call causes an invocation to the C object, of the method m with Nat output, which again causes a completion with the value 0. The object of class C assigns 0 to its local variable x and the execution terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Type soundness</head><p>The soundness of the type system is established in this section. First, we define well-typed runtime objects, configurations, and executions. Then, we show that when applying rewrite rules to the final state of a well-typed execution, the execution remains well-typed. In particular, method-not-understood errors do not occur. Say that a runtime object is of a program P if it is an instance of a class defined in P . Definition 10. Let o : Ob | Att : a, Pr : s, l , PrQ : s 1 , l 1 . . . s n , l n represent a runtime object of a program P . If a, l, l 1 , . . . , l n are well-typed states in the typing environment of P , then the runtime object is well-typed.</p><p>An object has been initialized when the object state has been constructed and the object is ready to call run. Recall that method-not-understood errors are captured technically by bind messages with no destination address. Say that a configuration is of a program P if all objects in the configuration are of P . Definition 11. In a well-typed configuration of a program P , there are no method-not-understood errors and every object in the configuration is a well-typed runtime object of P with a unique identity. A well-typed initial configuration of a program P is an initial configuration of a well-typed program P . A well-typed execution of a program P is an execution that starts in an initial configuration and in which every configuration is well-typed.</p><p>Note that all objects in a configuration of a well-typed execution follow the naming convention of the object creation rules R2 and R3. Furthermore, all messages in a configuration of a well-typed execution are generated directly or indirectly by a method call in a well-typed object; i.e., all invocation messages are generated from the asynchronous call statement (R9 and R10), all bind messages are generated from these invocation messages (R12), all bound messages result from bind messages (R16), and all completion messages result from method termination (R18).  which is well-typed. All object identifiers in i have been constructed by applications of R2 and R3, as pairs consisting of a class identifier and an element of type Label. In particular, no identifiers for instances of other classes than C contain the class identifier C, all instances of class C may be ordered by the relation &lt; on Label, and for any instance (C; n ) of C in i we have n &lt; n. Consequently, (C; n) is an unused identifier in i . As the application of R3 locks the class in the rewrite step from i to i+1 , (C; n) is a unique identifier in i+1 . Assuming that other concurrent activity in the configuration preserves well-typedness, i+1 is well-typed. We now show that object initialization preserves well-typedness; i.e., for some well-typed state the object reduces to For Var = , we have F (self ) = Any and F ((C; n)) = I so I Any and rule new asserts that ٛ f e : T with T T . Since e is well-typed, we have ٛ f e : T such that T T . Since T T T , the assignment (v: T = e ) ↓ is type-correct. By induction over the length k of Par, we show that a well-typed state is built by the multiple assignment (v: T = e ) ↓. For k = 0, there are no parameters and = is well-typed (as is i+1 ). For the induction step, assume that i+k-1 is a well-typed configuration in which k-1 (1 &lt; k n) is the well-typed state of (C; n) constructed by assigning values to the variables v 1 , . . . , v k-1 . Rule par asserts that the variable name v k of type T k is new, so an assignment to v k does not override a previous variable in k-1 . By rule new, the assignment v k := e k is type-correct, so the application of R1 results in a well-typed state k-1 ∪ {v k → e k }. It follows that the object state = n is well-typed and defined for the variables v, and that i+k is a well-typed configuration.</p><p>For the induction step, assume ٛ v Param; Var such that the assignment list (a) ↓ is type-correct, resulting in a well-typed state , defined for self and the variables declared in Param; Var.</p><formula xml:id="formula_20">If + ٛ v v: T = e</formula><p>for some type T , then (a; v: T = e) ↓ is also a type-correct assignment list, resulting in a well-typed state defined for self , the variables declared in Param; Var, and for v. Since + ٛ v v: T = e , the variable name v is new, + ٛ f e: T such that T T , and e reduces to a value e such that + ٛ f e : T and T T T . It follows that applying R1 results in a well-typed state = ∪ {v → e }. There are no other processes with local state in (C; n), so the initialized runtime representation of (C; n) is well-typed. Assuming that other concurrent rewrites in the transition from i to i+j preserve well-typedness, i+1 , . . . , i+j are well-typed configurations.</p><p>Using the same argument, we can show that a new message in a well-typed initial configuration of a program P creates a well-typed configuration of P (by R2). It follows by Lemma 7 that any program variable typed by an interface I will, if not null, point to an object of a class which implements I . Lemma 8. Let P be an arbitrary program. If F ٛ P , then every method invocation !x.m(T in → T out , Co, e) or !m(T in → T out , Co, e) in a well-typed configuration of P can be type-correctly bound at runtime to a method such that the return values from the method are of type T out and T out T out , provided that x is not a null pointer.</p><p>Proof. By Lemma 6, the signature Sig = T in → T out and cointerface Co of every invocation is derived by the type system. The proof considers the evaluation rule R9 for !x.m(Sig, Co, e) and R10 for !m(Sig, Co, e). Let e, x evaluate to e , x such that (e ) (e) and (x ) (x). For an external method call !x.m(Sig, Co, e), rule R9 creates an invocation message in the following rewrite step: All invocations in Creol are expanded into asynchronous invocations at runtime and all bind messages in a welltyped execution are generated from these invocations. Consequently, Lemma 8 implies that for every bind message bind(m, T 1 → T 2 , Co, e, o) to C in a well-typed execution, v (e) T 1 and the matching of T 1 → T 2 and Co with the formal declaration of m in C succeeds. Since v (e) T 1 , the instantiation of local variables for the new process results in a well-typed state. Thus, loading a new process into the process queue of a well-typed object by R17 results in a well-typed runtime object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 9. Given an arbitrary</head><p>Creol program P such that F ٛ P and a well-typed execution of P . The execution of a statement t?(v) in the final configuration of results in a well-typed configuration of P .</p><p>Proof. We consider an object executing the (enabled) statement t?(v) by applying R13 on the final configuration of a well-typed execution of P . Rule reply asserts that there is a pending method invocation with label t, say t i !o.m(e) for some index i, object o, method name m, and data e (where ٛ f e : T ). We need to show that the runtime method lookup selects a method body such that the return values are of a subtype of the type v (v), in order to ensure that the object remains well-typed after applying R13.</p><p>By Lemma 6, the signature derived by the type analysis for every call is such that the call is covered. This signature Sig = T → v (v) and cointerface Co are used by the runtime system, yielding t i !o.m(Sig, Co, e). By Lemma 8 the signature Sig = T in → T out of the method selected at runtime is such that Sig Sig, so T out v (v). Since is well-typed, the return values e assigned to the out-parameters of the call by R18 are such that (e ) T out . Consequently, (e ) v (v) and the result of applying R13 is a well-typed configuration of P .</p><p>Theorem 10 (Type soundness). All executions of programs starting in a well-typed initial configuration, are well-typed.</p><p>Proof. We consider a well-typed execution of a program P . The proof is by induction over the length of = 0 , 1 , . . . . By assumption, 0 is a well-typed initial configuration of P ; i.e., 0 consists of class representations and a new message. Only R2 is applicable to 0 and, by Lemma 7, 1 is well-typed.</p><p>For the induction step we show that, for any well-typed configuration i , the successor configuration i+1 is welltyped by case analysis over the rewrite rules of the operational semantics. We first consider the reduction of an object o : Ob | Att : a, Pr : s; s, l to o : Ob | Att : a , Pr : s ; s, l and then the remaining rewrite rules:</p><p>• For s = (v v := e e) and the application of R1, the execution of (v v := e e) reduces the statement to v := e. Since the program is well-typed, we can assume that v (v) = T v , ٛ f e : T , T T v , and the functional expression e reduces to e with type ٛ f e : T such that T T . By transitivity T T v and i+1 is well-typed. • Consider s = new C(e) and the application of R3. Lemma 7 guarantees that the evaluation of object creation statements does not result in object representations which are not well-typed, so i+1 and the successor configurations from the initialization of the new object are well-typed. • For s = await g, either R4 or R5 may be applied, depending on the enabledness of g. If g is enabled and R4 is applied, the state variables do not change and i+1 is well-typed. If g is not enabled and R5 is applied, the active process with the well-typed state l is moved to PrQ without modifying the state variables. The state of the active process is and hence also well-typed. Consequently, i+1 is well-typed. • For s = r(Sig, Co, e; v) and the application of R7, the state variables are not changed and i+1 is well-typed.</p><p>• For s = t!r(Sig, Co, e) and the application of R8, the statement reduces to t := n; !r(Sig, Co, e). As n is of type Label, ٛ s t := n. The state variables are not changed and i+1 is well-typed.</p><p>• For s =!r(Sig, Co, e) and the application of R9 and R10, the state variables are not changed and i+1 is well-typed.</p><p>• For s = t?(v) and the application of R13, there is a message comp(n e) in EvQ such that t is bound to n in o.</p><p>It follows from Lemma 9 that (e) v (v). Consequently, i+1 is well-typed and the assignment of values e to variables v will preserve well-typedness.</p><p>• For s = t?(v) and the application of R14, the active process with state l is suspended and a suspended process with state l is activated. Since i is well-typed both l and l are well-typed, and consequently i+1 is well-typed. • For s = cont(n) and the application of R15, a process with state l is activated. Since i is well-typed, l is well-typed, and i+1 is well-typed. • For s = return(e) and the application of R18, the state variables do not change and i+1 is well-typed.</p><p>• For sequential composition s = s 1 ; s 1 , all cases are covered except ; s 1 , which trivially reduces to s 1 by the left identity of sequential composition without modifying state variables. Consequently i+1 is well-typed. We now consider the remaining rewrite rules:</p><p>• The application of R6 activates a suspended process with a state l. Since i is well-typed, l is well-typed and, consequently, i+1 is well-typed. In a well-typed execution, objects only communicate by method calls. When a new C(e) statement is evaluated in a well-typed configuration, no other objects of class C can be created in the same rewrite step, Consequently, the above theorem also applies to concurrent processes; i.e., the parallel reduction of a well-typed configuration i results in a well-typed configuration i+1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Flexible high-level control structures for local computation</head><p>Asynchronous method calls, as introduced in Section 3, add flexibility to method calls in the distributed setting because waiting activities may yield processor control to suspended and enabled processes. Further, this allows active and reactive behavior in a concurrent object to be naturally combined. However a more fine-grained control may be desirable, in order to allow different tasks within the same process to be selected depending on the order in which communication with other objects actually occur. For this purpose, additional composition operators between program statements are introduced: conditionals, while-loops, non-deterministic choice, and non-deterministic merge. The latter operators introduce high-level branching structures which allow the local computation in a concurrent object to take advantage of non-deterministic delays in the environment in a flexible way. By means of these operators, the local computation adapts itself to the distributed environment without yielding control to competing processes. For example, non-deterministic choice may be used to encode interrupts for process suspension such as timeout and race conditions between competing asynchronous calls <ref type="bibr" target="#b46">[47]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Syntax</head><p>Statements can be composed in different ways, reflecting the requirements to the internal control flow in the objects. Recall that unguarded statements are always enabled, and that reply statements t?(v) may block. Let s 1 and s 2 be statements. Non-deterministic choice between statements s 1 and s 2 , written s 1 s 2 , may compute s 1 once s 1 is ready or s 2 once s 2 is ready, and suspends if neither branch is enabled. (Remark that to avoid deadlock the semantics additionally will not commit to a branch which starts with a blocking reply statement.) Non-deterministic merge, written s 1 |||s 2 , evaluates the statements s 1 and s 2 in some interleaved and enabled order, and suspends if neither branch is enabled. Control flow without potential processor release uses if and while constructs. The conditional if g then s 1 else s 2 fi selects s 1 if g evaluates to true and otherwise s 2 , and the loop while g do s 1 od repeats s 1 until g is not true. Fig. <ref type="figure" target="#fig_16">10</ref> gives the extended language syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Typing</head><p>The type system introduced in Section 3 is now extended to account for choice, merge, conditional, and while statements. It is non-deterministic for choice statements which branch will be executed at runtime, and for merge statements the order in which the statements of the different branches are executed. Consequently, the branches must be type checked in the same typing environment. The typing environment resulting from a non-deterministic statement depends on the calls introduced and removed in each branch. The additional rules are given in Fig. <ref type="figure" target="#fig_17">11</ref>. We now define a union operator for typing environments (recall that I , C , and F are static tables and that v is not modified by the type checking of program statements).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 12.</head><p>Let and be typing environments and let N and M be sets. The commutative union of typing environments ∪ is defined as F + I + C + v + ( Sig ∪ Sig ) + ( P ∪ P ). The union of signature mappings, Sig ∪ Sig , is defined as follows:</p><formula xml:id="formula_21">( Sig + [t i Sig → m, Co, T 1 → T 2 ] + Sig ) ∪ ( Sig + [t i Sig → m, Co, T 1 → T 2 ] + Sig ) = ( Sig + Sig ∪ Sig + Sig ) + [t i Sig → m, Co, T 1 → T 2 ][t i Sig → m, Co, T 1 → T 2 ] if t i / ∈ Dom( Sig + Sig ), ( Sig + [t i Sig → m, Co, T 1 → T 2 ] + Sig ) ∪ Sig = ( Sig + Sig ∪ Sig ) + [t i Sig → m, Co, T 1 → T 2 ] if Sig (t i ) = ⊥, ∅ Sig ∪ Sig = Sig .</formula><p>Let ⊥ + Sig = ⊥. The operator on signature mappings is defined as</p><formula xml:id="formula_22">[t i Sig → m, Co, T 1 → T 2 ] [t i Sig → m, Co, T 1 → T 2 ] = [t i Sig → m, Co, T 1 → (T 2 ∩ T 2 ) ] if T 2 ∩ T 2 = ⊥, ⊥ [otherwise ].</formula><p>The union of pending mappings, P ∪ P , is defined as follows:  The operator ⊗ on pending mappings is defined as</p><formula xml:id="formula_23">( P + [t P → N] + p ) ∪ ( p +</formula><formula xml:id="formula_24">[t P → N] ⊗ [t P → M] = [t P → N ∪ M] if N = ∅ ∧ M = ∅, [t P → ∅] [ otherwise ].</formula><p>In a merge statement s 1 |||s 2 , both statement lists will be evaluated. The merge rule ensures that reply statements in the two branches do not correspond to the same pending call. Furthermore, all asynchronous invocations introduced in a merge statement must have unique labels to avoid interference between calls in the two branches, caused by the interleaved execution of s 1 and s 2 . We then have that for each labeled invocation, the invocation cannot be matched by a reply statement in another branch of the merge. For this purpose, the merge rule ensures that Dom( P ) ∩ Dom( P ) = ∅.</p><p>For non-deterministic choice, at most one of the two branches is evaluated. If only one branch has a reply statement which corresponds to a pending call in then a reply statement corresponding to the same call is not allowed in statements succeeding the non-deterministic choice, although the branch with the reply statement need not be chosen at runtime. Moreover, if there is a reply statement in each branch that corresponds to the same pending call in , say t?(v) and t?(v ), the choice rule asserts that the types of the out-parameters have a common subtype (i.e., v (v) ∩ v (v ) = ⊥) in order to ensure a deterministic signature for the invocation. This property is ensured by Sig ∪ Sig = ⊥, which compares the types of the actual out-parameters of the reply statements in the branches when they correspond to the same pending call in . The subtype v (v) ∩ v (v ) is then selected as the type of the out-parameter of the call. Note that if a label is reused in a new asynchronous invocation, the reply statement in this branch will refer to the new invocation and Data is used as the type for the out-parameters of the previous call in this branch. Furthermore, given two branches s and s in a non-deterministic choice, the type system ensures that a reply statement with label t can occur after the non-deterministic choice statement only if a call with label t is pending after the evaluation of either s or s . Consequently, each reply statement corresponds to a call independent of the branch selection.</p><p>The while rule ensures that reply statements in the body s of the while-loop must correspond to invocations in the same traversal of s. Similarly, calls initiated in s must have their corresponding reply statements within the same traversal of s. This is guaranteed by the fact that the while rule does not update the pending mapping p . Lemma 11. Let be a mapping family such that P = . For any statement list s in the code of an arbitrary method body with a type judgment ٛ s s , the set P contains exactly the labeled method invocations for which the return value may still be assigned to program variables after s.</p><p>Proof. The proof is by induction over the length of s, similar to the proof of Lemma 4. For the old cases, the signatures and cointerfaces in a single branch of a statement list follow from Lemma 6. The new cases are now considered for the induction step. We assume given ٛ s s where P contains the labeled method invocations for which the return values may still be assigned to program variables after s. We prove that for a judgment ٛ s s; s + , where s is a non-deterministic choice, merge, conditional, or while statement, ( + ) P contains the labeled method invocations for which the return values may still be assigned to program variables after s; s.</p><p>• For the while statement while do s od, the type system does not allow any updates on the pending mapping p , so ( + ) P = P . • For non-deterministic choice s 1 s 2 , the induction hypothesis gives us + ٛ s s 1 1 and + ٛ s s 2 2 such that the lemma holds. There are two cases: Case 1: s 1 contains a reply statement t?(v 1 ) with a label t corresponding to a call on t i such that i ∈ P (t). There are two possibilities. First, a reply statement with label t does not occur in s 2 . The pending call is type checked with the new out-parameter type in s 1 , and the update of the typing environment removes the pending calls; i.e., ( 1 ∪ 2 ) P (t) = ∅. Signature and cointerface uniqueness is here immediate. Second, a reply statement t?(v 2 ) occurs in s 2 . We must check that the reply statements yield a unique signature and cointerface. By the induction hypothesis, there is a unique signature candidate in each branch. ( 1 ∪ 2 ) Sig = ⊥ evaluates to true if a compatible minimal type can be given for the two reply statements, which gives us a unique signature and cointerface. Note that if the reply statement in one branch refers to a new method invocation with the same label t in that branch, Data is used as the out-parameter type for the first call in that branch. The update of the typing environment removes the pending calls.</p><p>Case 2: s 1 introduces a new invocation with label t. The effect of the choice rule records the pending call if there is also a pending call to t if s 2 is chosen. (This pending call after s 2 may either correspond to an invocation in s 2 or a pending call in which has been overwritten in s 1 .) The invocations from both branches are captured in the effect of the choice rule ( + 1 ) ∪ ( + 2 ). It follows from the induction hypothesis that + ( + 1 ) P ∪ ( + 2 ) P contains the labeled invocations for which the return values may be assigned to program variables after s; s 1 s 2 .</p><p>• The conditional statement follows from the case for non-deterministic choice.</p><p>• For non-deterministic merge s 1 |||s 2 the induction hypothesis is that for + ٛ s s 1 1 and + ٛ s s 2 2 , ( 1 ) P and ( 2 ) P contain exactly the labeled method invocations for which the return value may still be assigned to program variables after s 1 and s 2 . The condition Dom(( 1 ) P ) ∩ Dom(( 2 ) P ) = ∅ ensures that labels used in branches s 1 and s 2 of the merge statement are non-overlapping, so a call with label t cannot be matched by a reply statement in another branch. Consequently, 1 and 2 are disjoint, so 1 + 2 = 2 + 1 and the order in which the updates are applied to is insignificant. It then follows directly from the induction hypothesis that ( + 1 + 2 ) P contains exactly the labeled method invocations for which the return value may still be assigned to program variables after s; s 1 |||s 2 .</p><p>We show that every call is covered for the derived signature and cointerface. Lemma 12. In a well-typed method, a signature and cointerface can be derived for every method invocation in the body, such that the invocation is covered.</p><p>Proof. The proof extends the proof of Lemma 6. Let s be the code of an arbitrary well-typed method, such that ٛ s s . The proof is by induction over the length of s. Let s = s 0 ; s and assume as induction hypothesis that welltyped signatures and cointerfaces have been derived for every invocation in ٛ s s 0 s 0 . We show that well-typed signatures and cointerfaces have been derived for every invocation in ٛ s s 0 ; s . Here, only the cases for choice, merge, conditional, and while statements are considered.</p><p>• For s = while do s od, by the induction hypotheses every invocation introduced in s 0 and s has a well-typed signature and cointerface. Traversing s does not modify the pending mapping, signatures in ( s 0 ) Sig are not refined after s 0 ; s. Well-typed signatures and cointerfaces for invocations in s 0 ; s follow from the induction hypotheses and the invocations are covered. • For s = s 1 s 2 , by the induction hypothesis, the signature and cointerface of every invocation in s 1 and s 2 are derived. By rule choice, if one of the two branches contains a reply statement to an invocation in s 0 , the signature of the invocation in ( s 0 ) Sig will be refined in Sig . If both branches contain such reply statements, then the signature is refined in Sig with a common subtype, such that the invocation is covered with the new signature and the cointerface, independent of the branch being evaluated. • The conditional statement follows from the case for non-deterministic choice.</p><p>• For s = s 1 |||s 2 , the signature and cointerface for every invocation in s 1 and s 2 is derived by the induction hypothesis.</p><p>The signatures in ( s 0 ) Sig may be refined if the corresponding reply statement is contained in the merge statement. By rule merge, reply statements in the two branches do not correspond to the same pending call, so the sets of labels used in the two branches are disjoint. Consequently, the signature can only be refined once in Sig , and the invocation is covered by the new signature. Regardless of the order of the evaluation of branches, every call in s 0 ; s is covered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Operational semantics</head><p>The operational semantics of Section 3.5 is extended with rules for the local control structures in Fig. <ref type="figure" target="#fig_18">12</ref>. The selection of a branch s 1 in a non-deterministic choice statement s 1 s 2 is modeled by R19. Combined with the associativity and commutativity of the operator, this rule covers the selection of any branch in a compound nondeterministic choice statement. Here, the ready predicate tests if a process is ready to execute; i.e., the process does not immediately need to wait for a guard to become true or for a completion message. The ready predicate is defined as follows: ready(s; s, d, q) = ready(s, d, q) ready(t?(v), d, q) = eval(t, d) in q ready(s, d, q) = enabled(s, d, q)</p><p>[ otherwise ].</p><p>As long as neither s 1 nor s 2 is ready, the active process is blocked if enabled and suspended if not enabled. Consequently, selecting a branch which immediately blocks or suspends execution is avoided if possible.</p><p>The merge statement s 1 ||| s 2 interleaves the execution of two statement lists s 1 and s 2 . A naive approach is to define merge in terms of the non-deterministic choice s 1 ; s 2 s 2 ; s 1 . To improve efficiency, a more fine-grained interleaving is preferred. However, in order to comply with the suspension technique of the language, interleaving is only allowed at processor release points in the branches. An associative but not commutative auxiliary operator / / / is introduced in R20 and R21. The latter rule has the following property: whenever evaluation of the selected (left) branch leads to non-enabledness, execution has arrived at a suspension point and it is safe to pass control back to the ||| operator. Rule R20 for merge decides whether to block or select a branch. (Suspension is handled by R5.) The ||| operator is associative, commutative, and has identity element (i.e., |||s = s). The operational semantics for conditionals (R22) and while-loops (R23) are as expected. Finally, the enabledness predicate is extended to non-deterministic choice and merge as follows: enabled(s s , d, q) = enabled(s, d, q)∨enabled(s , d, q) enabled(s|||s , d, q) = enabled(s, d, q)∨enabled(s , d, q).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Type soundness</head><p>The soundness of the type system for the extended language is established in this section. By Lemma 12, the signature and cointerface of every method invocation is deterministically given by the extended type system. Consequently, Lemmas 8 and 9 hold for the extended language. We first show a property of the execution sequences of non-deterministic merge.</p><p>Lemma 13. Let s 1 |||s 2 be well-typed in a typing environment and let s be an interleaving of s 1 and s 2 . Then s is well-typed in .</p><p>Proof. Let ٛ s s 1 1 and ٛ s s 2 2 such that ٛ s s 1 |||s 2 1 + 2 . The proof is by induction over the length of s. For s = , s is trivially well-typed. For the induction step, let s; s i ; . . . ; s 1 be an interleaving of s 1 and s 2 such that ٛ s s; s i ; . . . ; s 1</p><p>. We prove that s; s; s i ; . . . ; s 1 is well-typed if (s 1 ; s)|||s 2 is well-typed. Let ٛ s s 1 ; s 1 such that ٛ s (s 1 ; s)|||s 2 1 + 2 . (The case for s 2 ; s is similar.) The proof proceeds by induction over i and by case analysis over s. Observe that s i ; . . . ; s 1 (i 0) is a tail sequence from s 2 and that for well-typedness, only the statements t!p(e), t?(v), and await t? actually depend on the dynamically decided typing environment. We consider s = t?(v).</p><p>• For i = 0, we have the interleaving s; s. Since ٛ s s 1 ; s 1 , it follows that ( + 1 ) v (v) = ⊥ and ( + 1 ) P (t) = ∅, and hence ( + 1 ) v (t) = Label. Since ( + 1 ) v = ( + ) v , it follows that t and v are declared variables in + . Since ٛ s s 1 |||s 2 1 + 2 , Dom(( 1 ) P )∩Dom(( 2 ) P ) = ∅. Consequently, ( + 1 ) P (t) = ( + 1 + 2 ) P (t) = ( + ) P (t) and s; s is well-typed in .</p><p>• For i + 1, the induction hypothesis is that s; s i+1 ; s; s i ; . . . ; s 1 is a well-typed interleaving and s i+1 is a statement from s 2 . Since s i+1 is a statement from s 2 , Dom(( 1 ) P )(t) = ⊥, and Dom(( 1 ) P ) ∩ Dom(( 2 ) P ) = ∅, exchanging s and s i+1 does not affect well-typedness and s; s; s i+1 ; s i ; . . . ; s 1 is well-typed. The cases for t!p(e) and await t? are similar, the other cases are straightforward.</p><p>It follows from Lemma 13 that if (s 1 ; s 2 )|||s 3 is well-typed in a typing environment , then so is s 1 ; (s 2 |||s 3 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 14 (Type soundness). All executions of programs starting in a well-typed initial configuration are well-typed.</head><p>Proof. We consider a well-typed execution of a program P . The proof is by the induction over the length of = 0 , 1 , . . . and extends the proof of Theorem 10. We show that for any well-typed configuration i , the successor configuration i+1 is also well-typed, by case analysis over the rewrite rules. Here, only the new rewrite rules are considered, i.e., the reduction of a well-typed runtime object o : Ob | Att : a, Pr : s; s, l to o : Ob | Att : a , Pr : s ; s, l where s is a non-deterministic choice, merge, conditional, or while statement. (The remaining cases are covered by the proof of Theorem 10.) For the induction hypothesis, we assume that the type soundness property holds for well-typed branches s 1 and s 2 of s.</p><p>• For s = s 1 s 2 , the application of R19 reduces s to either s 1 or s 2 . As the program is well-typed, ٛ s s 1 and ٛ s s 2 .</p><p>The state variables do not change and i+1 is well-typed.</p><formula xml:id="formula_25">• Consider s = s 1 |||s 2 . If s 1 = then s 1 |||s 2 = s 2 ,</formula><p>for which type soundness holds by assumption. Now assume that s 1 is non-empty. By R20, s 1 |||s 2 reduces to s 1 / / /s 2 , so i+1 is well-typed since state variables do not change.</p><p>• For s 1 / / /s 2 , we proceed by induction over the number n of rewrite steps using R21 immediately preceding i . If n = 0, i must have been obtained by application of R20. Let s 1 = s 1 ; s 1 . By the induction hypothesis s 1 |||s 2 is well-typed and by Lemma 13 any s 1 ; (s 1 |||s 2 ) is well-typed. For the induction step, observe that the repeated application of R21 must eventually result in a statement s 1 |||s 2 in a state i+n (n n) after executing s 1 . It follows from the induction hypothesis and Lemma 13 that all states i , . . . , i+n are well-typed.</p><p>• For s = if then s 1 else s 2 fi, the application of R22 reduces s to either s 1 or s 2 . Since the program is welltyped, we know that ٛ f : Bool, ٛ s s 1 , and ٛ s s 2 . The functional expression will be successfully reduced to a Boolean value, as expected by the conditional test. The state variables do not change and i+1 is well-typed. • For s = while e do s 1 od, the application of R23 reduces s to s = if e then (s 1 ; while e do s 1 od) else fi. The typing rule while ensures that a traversal of s 1 does not modify the pending mapping p . Consequently, s 1 ; while e do s 1 od is well-typed. Moreover, since there is no interference between the different traversals of s 1 , the conditions of rule choice are satisfied and s is also well-typed. The state variables do not change and i+1 is well-typed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">An extension with multiple inheritance</head><p>Many languages identify the subclass and subtype relations, in particular for parameter passing, although several authors argue that inheritance relations for code and for behavior should be distinct <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b71">72]</ref>. From a pragmatic point of view, combining these relations leads to severe restrictions on code reuse which seem unattractive to programmers. From a reasoning perspective, the separation of these relations allows greater expressiveness while providing type-safety. In order to solve the conflict between unrestricted code reuse in subclasses, and behavioral subtyping and incremental reasoning control <ref type="bibr" target="#b53">[54,</ref><ref type="bibr" target="#b71">72]</ref>, we use interfaces to type object variables and external calls. Multiple inheritance is allowed for both interfaces and classes. Whereas subinterfacing is restricted to a form of behavioral subtyping, subclassing is unrestricted in the sense that implementation claims (and class invariants) are not in general inherited. However, the mutual dependencies introduced by cointerfaces makes the inheritance of contracts necessary in subclasses.</p><p>A class describes a collection of objects with similar internal structure; i.e., attributes and method definitions. Class inheritance is a powerful mechanism for defining, specializing, and understanding the imperative class structures through code reuse and modification. Class extension and method redefinition are convenient both for the development and understanding of code. Calling superclass methods in a subclass method enables reuse in redefined methods, while method redefinition allows specialization in subclasses.</p><p>With distinct inheritance and subtyping hierarchies, class inheritance could allow a subset of the attributes and methods of a class to be inherited. However, this would require considerable work establishing invariants for parts of the superclass that appear desirable for inheritance, either anticipating future needs or while designing subclasses. The encapsulation principle for class inheritance states that it should suffice to work at the subclass level to ensure that the subclass is well-behaved when inheriting from a superclass: code design as well as new proof obligations should occur in the subclass only. Situations that break this principle are called inheritance anomalies <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b60">61]</ref> (see also the fragile base class problem <ref type="bibr" target="#b59">[60]</ref>). Reasoning considerations therefore suggest that all attributes and methods of a superclass are inherited, but method redefinition may violate the requirements of the interfaces of the superclass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Syntax</head><p>A mechanism for multiple inheritance at the class level is now considered, where all attributes and methods of a superclass are inherited by the subclass, and where superclass methods may be redefined. In the syntax the keyword inherits is introduced followed by a list of instantiated class names C(e), where e provides the actual class parameters.</p><p>Let a class hierarchy be a directed acyclic graph of classes. Each class consists of lists of class parameters and instantiated class names (for superclasses), a set of attributes, and method definitions. Let a class C be below a class</p><formula xml:id="formula_26">C if C is C , or if C is a direct or indirect subclass of C and above C if C is C , or if C is a direct or indirect superclass of C .</formula><p>The encapsulation provided by interfaces suggests that external calls to an object of class C are virtually bound to the closest method definition above C. However, the object may internally invoke methods of its superclasses. In the setting of multiple inheritance and overloading, ambiguities may occur when attributes or methods are accessed. A name conflict is vertical if a name occurs in a class and in one of its ancestors, and horizontal if the name occurs in distinct branches of the graph. Vertical name conflicts for method names are resolved in a standard way: the first definition matching the types of the actual parameters is chosen while ascending a branch of the inheritance tree. Horizontal name conflicts are resolved dynamically depending on the class of the object and the context of the call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1.">Qualified names</head><p>Qualified names may be used to internally refer to an attribute or method in a class in a unique way. For this purpose, we adapt the qua construct of Simula <ref type="bibr" target="#b24">[25]</ref> to the setting of multiple inheritance with virtual binding. For an attribute v or a method m declared in a class C, we denote by v@C and m@C the qualified names which provide static references to v and m. By extension, if v or m is not declared in C, but inherited from the superclasses of C, the qualified reference m@C binds as an unqualified reference m above C. Attribute names are not visible through an object's external interfaces. Consequently, attribute names should not be merged if inheritance leads to name conflicts and attributes of the same name should be allowed in different classes of the inheritance hierarchy <ref type="bibr" target="#b70">[71]</ref>. In order to allow the reuse of attribute names, these are always expanded into qualified names. This is desirable in order to avoid runtime errors that may occur if methods of superclasses assign to overloaded attributes. This convention has the following consequence: unlike C++, there is no duplication of attributes when branches in the inheritance graph have a common superclass. Consequently, if multiple copies of the superclass' attributes are needed, one has to rely on delegation techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2.">Instantiation of attributes</head><p>At object creation time, attributes are collected from the object's class and superclasses. Recall that an attribute in a class C is declared by x : T = e, where x is the name of the attribute, T its type, and e its initial value. The expression e may refer to the values of inherited attributes by means of qualified references, in addition to the values of the class parameter variables v. The initial state values of an object of class C then depend on the actual parameter values bound to v. These may be passed as actual class parameter values to inherited classes in order to derive values for the inherited attributes, which in turn may be used to instantiate the locally declared attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3.">Accessing inherited attributes and methods</head><p>If C is a superclass of C we introduce the syntax m@C(e; v) for synchronous internal invocation of a method above C in the inheritance graph, and similarly for external and asynchronous invocations. These calls may be bound without knowing the exact class of self, so they are called static, in contrast to calls without @, called virtual. We assume that attributes have unique names in the inheritance graph; this may be enforced at compile-time by extending each attribute name x with the name of the class C in which it is declared, which implies that attributes are bound statically. Consequently, a method declared in a class C may only access attributes declared above C. In a subclass, an attribute x of a superclass C is accessed by the qualified reference x@C. The extended language syntax is given in Fig. <ref type="figure" target="#fig_19">13</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Virtual binding</head><p>When multiple inheritance is included in the language, it is necessary to reconsider the mechanism for virtual binding. A method declaration in a class C is constrained by C if C is required to be below C . The virtual binding of method calls is now explained. At runtime, a call to a method of an object o is always bound above the class of o. Let m be a method declared in an interface I and let o be an instance of a class C implementing I . There are two cases:</p><p>(1) m is called externally, in which case C is not statically known. In this case, C is dynamically identified as the class of o.</p><p>(2) m is called internally from C , a class above the actual class C of o. In this case static analysis identifies the call with a declaration of m above C , say in C . Consequently we let the call be constrained by C , and compilation replaces the reference to m with a reference to m &lt; C . The dynamically decided context of a call may eliminate parts of the inheritance graph above the actual class of the callee with respect to the binding of a specific call. If a method name is ambiguous within the dynamic constraint, we assume that any solution is acceptable. For a natural and simple model of priority, the call is bound to the first matching method definition above C, in a left-first depth-first order as given by the textual declarations of the instantiated class names. (An arbitrary order may be obtained by replacing the list of instantiated class names by a multiset.) The three forms of method binding are illustrated in Fig. <ref type="figure" target="#fig_20">14</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Example: combining authorization policies</head><p>In a database containing sensitive information and different authorization policies, the information returned for a request depends on the clearance level of the agent making the request. Let Agent denote the interface of arbitrary agents and Auth an authorization interface with methods grant (x), revoke(x), and auth(x) for agents x. The two classes SAuth and MAuth, which both implement Auth, provide single and multiple authorization policies, respectively. SAuth authorizes one agent at a time and MAuth authorizes multiple agents. The method grant (x) returns when x becomes authorized, and authorization is removed by revoke(x). The method auth(x) suspends until x is authorized, and delay returns once no agent is authorized. The code given here uses asynchronous calls whenever an internal deadlock would be possible. Thus, objects of the four classes above may respond to new requests even when used improperly, for instance when agent access is not initiated by open.</p><p>The database itself has no interface containing access, therefore all database access is through the High and Low interfaces. Notice also that objects of the HAuth and LAuth classes may not be used through the Auth interface. This would have been harmful for the authorization provided in the example. For instance, an external call to the grant method of a HAuth object could result in high access without clearance of the calling agent! This supports the approach not to inherit implementation clauses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2.">Combining authorization levels</head><p>High-and low-authorization policies may be combined in a subclass HLAuth which implements both interfaces, inheriting LAuth and HAuth. class HLAuth implements High, Low inherits LAuth, HAuth begin with Agent op access(in k:Key out y:Data) == if caller =gr@SAuth then access@HAuth(caller,k; y) else access@LAuth(caller,k; y) fi end Although the DB class is inherited twice, for both High and Low interaction, HLAuth gets only one copy (see Section 5.1.1).</p><p>The example demonstrates natural usage of classes and multiple inheritance. Nevertheless, it reveals problems with the combination of inheritance and statically ordered virtual binding: objects of the classes LAuth and HAuth work well, in the sense that agents opening access through the Low and High interfaces get the appropriate access, but the addition of the common subclass HLAuth is detrimental: when used through the High interface, this class allows multiple high access to data! Calls to the High operations of HLAuth trigger calls to the HAuth methods. From these methods the virtual internal calls to grant, revoke, and auth now binds to those of the MAuth class, if selected in a left-first depth-first traversal of the inheritance tree of the actual class HLAuth. If the inheritance ordering in HLAuth was reversed, similar problems occur with the binding of Low interaction.</p><p>The pruned virtual binding strategy ensures that the virtual internal calls constrained by classes HAuth and LAuth are bound in classes SAuth and MAuth, respectively, regardless of the actual class of the caller (HAuth, LAuth, or HLAuth), and of the inheritance ordering in HLAuth. In an object of class HLAuth, the local calls to grant, revoke, and auth in code from class HAuth is understood as grant&lt;SAuth, revoke&lt;SAuth, and Auth&lt;SAuth. These may not be bound in the MAuth class since MAuth is not a subclass of SAuth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Typing</head><p>In order to extend the type system to classes with inheritance we revise the rules for classes, internal calls, and replies, and add rules for the new method notations m@C and m &lt; C. These are given in Fig. <ref type="figure" target="#fig_22">15</ref> For a class C, the formal parameters of C may be instantiated with values passed to C from its subclasses. Thus, to ensure type-correct instantiations of superclasses, the type of the actual parameters of the instantiated superclass names must be type checked with respect to the type of the formal parameters of the superclasses. This is done by the auxiliary function matchparam in the typing rule class-inh, which takes the typing environment and a list of instantiated class names, and compares the actual and formal parameters.</p><p>The initial expressions in variable declarations and the program statements in method bodies of a class C may refer to variables declared in its superclasses. Consequently, the typing environment must be extended with inherited attributes before type checking variables and methods of class C. This extension is obtained by traversing the instantiated class names Inh of C depth first and using the mapping C to gather Param and Var from each superclass. The function InhAttr in the typing rule for classes returns the list of all typed variables inherited from the classes above C. (It follows that Lemma 2 holds for the extended language.) Furthermore, for each interface that C implements C must provide at least one type-correct method body for each method in the interface, either by inheritance or by local declaration.</p><p>Method calls: The typing of external calls is controlled by interfaces and is not affected by class inheritance. The rules for internal invocations resemble those in Section 3.4.4, but the analysis may now depend on the inheritance tree above self. The typing of internal calls inspects the inheritance graph, choosing a class such that the invocation is covered. As before, the signature of a call may be refined by a reply statement, but the signature is fixed to a class which need not be the class of self. For static calls m@C the match starts from C, and not from the class of self. For bounded calls m &lt; C, the match must be found below C in the inheritance tree above the class of self.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Operational semantics</head><p>The operational semantics is adapted to incorporate multiple inheritance in Fig. <ref type="figure" target="#fig_23">16</ref>. Creol classes are extended to include the instantiated class names of inherited classes and are given as RL objects Cl | Par, Inh, Att, Mtds, Tok , where Cl is the class name, Par a list of parameters, Inh is a list of instantiated class names, Att a list of attributes, Mtds a multiset of methods, and Tok is an arbitrary term of sort Label. When an object needs a method, it is bound to a definition in the Mtds multiset of its class or of a superclass. Previous class definitions (without inheritance) can be extended with an empty list of instantiated class names to be valid in the extended semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.1.">Virtual and static binding of method calls</head><p>Qualified external method invocations are syntactically excluded; external invocations cannot access the internal structure of the callee. Internal calls give rise to invocation messages, but in R10 the qualified method name mq may be of the form m@C or m &lt; C, where the constraint C is used in the binding. In order to allow concurrent and dynamic execution, the inheritance graph is not statically given. Rather, the binding mechanism dynamically inspects the class hierarchy in the configuration. Our approach to virtual binding uses a bind message, which is sent from a class to its superclasses, resulting in a bound message returned to the object requesting the method binding. This way, the inheritance graph is explored dynamically and only as far as necessary. When the external invocation of a method m is found in the message queue of an object o, a message bind(m, Sig, Co, e, o) to C is sent in R12, after retrieving the class C of the object. For internal static calls m@C, the bind message is sent by R24 without inspecting the actual class of the callee, thus surpassing local definitions. If a suitable m is defined locally in C, a process with the method code and local state is returned in a bound message. Otherwise, the bind message is retransmitted to the superclasses of C in a left-first depth-first order by application of R16 . In order to facilitate the traversal of the inheritance graph, a list of instantiated class names is used as the destination of the bind message. The process resulting from the binding is loaded into the internal process queue of the callee as before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.2.">Pruned virtual binding</head><p>The binding of an internal virtual call m &lt; C is more involved. When a match in a class C is found in the application of R26, the inheritance graph of C is inspected to ensure that C C , otherwise the binding must resume. Note the  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.3.">Object creation and attribute instantiation</head><p>The object creation rules R2 and R3 are redefined to address the dynamic inheritance graph (see R2 and R3 ). In order to initialize the state of the new object the inheritance graph is traversed and inherited state variables collected, using the equations given in Fig. <ref type="figure" target="#fig_24">17</ref>. Recall that using equations enables object creation and attribute collection in one rewrite step. The equations convert class parameters and actual parameter values to attribute declarations which textually precede the attribute list of each class. Inherited parameters and attribute lists textually precede the attribute list of a subclass. The collected attribute declarations are evaluated in the new object in order to initialize the object state. Class parameters and inherited attributes provide a mechanism to pass values to the initial expressions of the inheritance list in a class. The order in which parameters are collected (Fig. <ref type="figure" target="#fig_24">17</ref>) ensures that multi-inheritance of the same class is the same as inheriting the class once, keeping the leftmost instantiation of the state variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.">Type soundness</head><p>The soundness of the full language is established in this section. We first show that the class hierarchy is correctly unfolded when initializing the object state. Proof. Let s = v 0 : T 0 = e 0 ; . . . ; v n : T n = e n be an attribute list and let i v be a mapping such that i v (v j ) = T j for 1 j &lt; i. We show that F + n v ٛ f e n . The proof is by induction over n. For n = 0, s = self : Any = (C; n), F (self ) = Any, and F ((C; n)) = I , so I Any and F ٛ v s . For n = 1, the message must have been caused by application of R2 or R3 . By Lemma 2, the evaluation of an expression in a well-typed method successfully dereferences all program variables in the expression. Since e 1 is an expression which has been evaluated either in R2 or R3 , e 1 does not refer to program variables and consequently F ٛ f e 1 . For the induction step we assume that the lemma holds for n + 1 and show that it also holds for n + 2, in which case v n+2 is a class parameter to some class C which is inherited by a class C such that v i (i n + 1) is the class parameter of C. Since C is well-typed, class-inh asserts that F + i v ٛ f e n+2 through the matchparam predicate. It follows that F ٛ v s . which is well-typed. Let e be the result of evaluating e in o . We need to show that the object remains well-typed while the assignment list (a 0 ) ↓ is executed and that the assignment list instantiates all program variables in the object state. This is done by showing that the attribute list a 0 is well-typed, so that object instantiation (by the repeated application of R1) results in well-typed configurations. The proof is by induction over the depth of the inheritance tree above C. At each step of the induction we assume that the parameter and attribute lists are type-correctly collected from the inheritance tree above the currently considered class, and show that when type checking the parameter and attribute list from left to right, all variables occurring in the initial expressions have been instantiated. For the basis step, let C be a leaf above C with formal class parameters v of type T and let In be the actual parameter values passed to C . For well-typed programs, we know that ٛ f In : T such that T ≺ T (this is checked by the matchparam function). Consequently, In can be type-correctly assigned to v. Let s and a be accumulated class parameter and class attribute assignments, and i be a list of superclasses of C. It is immediate that s; v : T = In; a contains all state variables declared in C . Note that the attribute assignments of C precede the accumulated attribute assignment list a, so initial expressions in a may safely refer to variables in s; v : T = In; a .</p><p>For the induction step, we consider a class C and assume that the assignment list from each of its superclasses is well-typed (with respect to the accumulated parameter assignment list) and contains all state variables declared in the superclasses of C . Due to the qualified name convention, the concatenation of these assignments lists is also well-typed with respect to the accumulated parameter assignment list. The following equation applies: Finally, if C is the actual class C of the object, the actual class parameters passed to C come from the statement new C(e). Lemma 15 asserts that e can be type-correctly assigned to the formal parameters of C , s = self : Any = (C; n), and a = . It follows that the attribute list self : Any = (C; n); v: T = e; s ; a ; a is well-typed and declares all state variables of C . Since the attribute list is well-typed, every application of R1 to (a 0 ) ↓ will result in a well-typed object. Consequently, the evaluation of (a 0 ) ↓ constructs a well-typed state containing all object variables, and the object reduces to o : Ob | Cl : C, Att : , Pr : run, , PrQ : , EvQ : , Lab : 1 .</p><p>Object initialization preserves well-typedness. Lemma 17. Let P be an arbitrary Creol program. If F ٛ P , then every method invocation !x.m(T in → T out , Co, e), !m@C(T in → T out , Co, e), or !m &lt; C(T in → T out , Co, e) in a well-typed configuration of P can be type-correctly bound at runtime to a method such that the return values from the method are of type T out and T out T out , provided that x is not a null pointer.</p><p>Proof. We consider how the invocation message is bound in the evaluation rules for !x.m(Sig, Co, e), !m@C(Sig, Co, e), and !m &lt; C(Sig, Co, e). The proof is similar to the proof of Lemma 8, but accounts for the dynamic traversal of the inheritance graph. As the call to m is well-typed, we may assume that x is typed by an interface I and that x is an instance of a class C which implements I . Consequently, there is at least a class C above C in which m is declared with an appropriate signature and cointerface. Let e evaluate to e such that (e ) (e). Applying R9 to an external method call !x.m(Sig, Co, e) creates a message bind(m, Sig, Co, e , x) to C, if C is the dynamically identified class of x. Method lookup proceeds by R16 : Sig and Co Co , so T out T out . The type analysis guarantees that C inherits a method m with a matching signature and cointerface. Consequently, the bind message succeeds in binding the call to a method declared above C when traversing the inheritance tree above C, by repeated applications of R16 .</p><formula xml:id="formula_27">(bind(m, Sig, Co, e , x) to C i ) C : Cl | Inh : i, Mtds : m -→ if match(m,</formula><p>Let o be an object of class C . An internal bounded call m &lt; C(Sig, Co, e) in o results in the message invoc(m &lt; C, Sig, Co, e ) to o, which by R25 generates a message bind(m &lt; C, Sig, Co, e , o) to C . The (repeated) application of R26 inspects the inheritance graph above C , searching for a matching method declaration located below C. For every match in the inheritance graph, say in a class C , a message find(n, C, C ) to C is generated, which means that the class C is a candidate for binding m. By application of rules R28-R30 this message returns true with token n if C is above C and false otherwise, and the token identifies the corresponding stopbind message. If the result is false, rule R27 continues the search. Well-typedness guarantees that there is at least one match in a class below C with signature T in → T out and Co such that T out T out , so the search eventually succeeds.</p><p>Theorem 18 (Type soundness). All executions of Creol programs starting in a well-typed initial configuration are well-typed.</p><p>Proof. We consider a well-typed execution of a program P . The proof is by the induction over the length of = 0 , 1 , . . . and extends the proofs of Theorems 10 and 14. By assumption, 0 is a well-typed initial configuration of P . As only R2 is applicable to 0 , it follows from Lemma 16 that object creation results in a well-typed successor configuration. For the induction step we show that for any well-typed configuration i , the successor configuration i+1 is also well-typed, by case analysis of the rewrite rules. Only the new rules of Fig. <ref type="figure" target="#fig_23">16</ref> are discussed, the other rules are covered by the proofs of Theorems 10 and 14. We first consider object reductions; i.e., rules that reduce an object o : Ob | Att : a, Pr : s; s, l to o : Ob | Att : a , Pr : s ; s, l , and then the remaining rewrite rules:</p><p>• Consider s = v := new C(e) and the application of R3 . By Lemma 16, the evaluation of an object creation statement gives a well-typed successor configuration i+1 . Moreover, the successor configurations from the initialization of the new object are also well-typed. • For s = mq(Sig, Co, e) and the application of R10 , the state variables are not changed and i+1 is well-typed.</p><p>• Applying R24 and R25 does not modify the state, so i+1 is well-typed. We now consider the remaining new rewrite rules: will eventually succeed before i = , resulting in a bound or a find message, and method-not-understood errors cannot occur in i+1 . It follows that i+1 is well-typed. • Rule R27. As is well-typed, the found and stopbind messages are originated from the application of R26 to a message bind(m &lt; C , Sig, Co, e, o) to i, in a well-typed configuration. By Lemma 17, the invocation can be bound by traversing the inheritance tree above C and below C . Consequently, the binding will succeed before i = generating a bound message. It follows that method-not-understood errors do not occur in i+1 , so i+1 is well-typed. • Rules R28-R30 do not modify the state, so i+1 is well-typed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work</head><p>Many object-oriented languages offer constructs for concurrency; a survey is given in <ref type="bibr" target="#b65">[66]</ref>. A common approach is to rely on the tight synchronization of RPC, separating activity (threads) and objects, as done in Hybrid <ref type="bibr" target="#b63">[64]</ref> and Java <ref type="bibr" target="#b35">[36]</ref>, or on the rendezvous concept in concurrent objects languages such as Ada and POOL <ref type="bibr" target="#b4">[5]</ref>. These approaches seem less desirable for distributed systems, with potential delays and communication loss. Hybrid offers delegation to (temporarily) branch an activity thread. Asynchronous method calls may be seen as a form of delegation and can be implemented in, e.g., Java by explicitly creating new threads to handle calls <ref type="bibr" target="#b22">[23]</ref>. In Creol, polling for replies to asynchronous calls is handled by the operational semantics: no new threads and active loops are needed to poll for replies to delegated activity. UML offers asynchronous event communication and synchronous method invocation but does not integrate these, resulting in significantly more complex formalizations <ref type="bibr" target="#b25">[26]</ref> than ours. To facilitate the programmer's task and reduce the risk of errors, implicit control structures based on asynchronous method calls seem more attractive, allowing a higher level of abstraction in the language.</p><p>The internal concurrency model of concurrent objects in Creol may be compared to monitors <ref type="bibr" target="#b37">[38]</ref> or to thread pools executing on a single processor, with a shared state space given by the object attributes. In contrast to monitors, explicit signaling is avoided. Sufficient signaling is ensured by the semantics, which significantly simplifies reasoning <ref type="bibr" target="#b23">[24]</ref>. However, general monitors may be encoded in the language <ref type="bibr" target="#b46">[47]</ref>. In contrast to thread pools, processor release is explicit. In Creol, the activation of suspended processes is non-deterministically handled by an unspecified scheduler. Consequently, intraobject concurrency is similar to the interleaving semantics of concurrent process languages <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b28">29]</ref>, where each Creol process resembles a series of guarded atomic actions (discarding local process variables). Internal reasoning control is facilitated by the explicit declaration of release points, at which class invariants should hold <ref type="bibr" target="#b30">[31]</ref>.</p><p>Languages based on the actor model <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> take asynchronous messages as the communication primitive, focussing on loosely coupled processes with less synchronization. This makes actor languages conceptually attractive for distributed programming. The interpretation of method calls as asynchronous messages has lead to the notion of future variables which may be found in languages such as ABCL <ref type="bibr" target="#b79">[80]</ref>, Argus <ref type="bibr" target="#b52">[53]</ref>, ConcurrentSmalltalk <ref type="bibr" target="#b78">[79]</ref>, Eiffel// <ref type="bibr" target="#b15">[16]</ref>, CJava <ref type="bibr" target="#b22">[23]</ref>, and in the Join-calculus <ref type="bibr" target="#b32">[33]</ref> based languages Polyphonic C <ref type="bibr" target="#b7">[8]</ref> and Join Java <ref type="bibr" target="#b42">[43]</ref>. Our communication model is also based on asynchronous messages and the proposed asynchronous method calls resemble programming with future variables, but Creol's processor release points further extend this approach to asynchrony with additional flexibility.</p><p>Languages supporting asynchronous methods generally either disallow inheritance <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b79">80]</ref> or impose redefinition of asynchronous methods <ref type="bibr" target="#b15">[16]</ref>. Multiple inheritance is supported in languages such as C++ <ref type="bibr" target="#b72">[73]</ref>, CLOS <ref type="bibr" target="#b26">[27]</ref>, Eiffel <ref type="bibr" target="#b58">[59]</ref>, POOL <ref type="bibr" target="#b4">[5]</ref>, and Self <ref type="bibr" target="#b18">[19]</ref>. Horizontal name conflicts in C++, POOL, and Eiffel are removed by explicit resolution, after which the inheritance graph may be linearized. A natural semantics for virtual binding in Eiffel is proposed in <ref type="bibr" target="#b6">[7]</ref>. This work is similar in spirit to ours and models the binding mechanism at the abstraction level of the program, capturing Eiffel's renaming mechanism. Mixin-based inheritance <ref type="bibr" target="#b9">[10]</ref> and traits <ref type="bibr" target="#b64">[65,</ref><ref type="bibr" target="#b69">70]</ref> depend upon linearization to be merged correctly into the single inheritance chain. Linearization changes the parent-child relationship between classes in the inheritance hierarchy <ref type="bibr" target="#b70">[71]</ref>, and understanding method binding quickly becomes difficult.</p><p>Maude's inherent object concept <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b56">57]</ref> represents an object's state as a subconfiguration, as we have done here, but in contrast to our approach object behavior is captured directly by rewrite rules. Both actor-style asynchronous messages and synchronous transitions (rewrite rules involving several objects) are allowed, which makes Maude's object model very flexible. However, asynchronous method calls and processor release points as proposed in this paper are hard to represent within this model. Both Maude and the Join-calculus capture multiple inheritance by this disjoint union of methods. Name ambiguity lets method definitions compete for selection. The definition selected when an ambiguously named method is called is non-deterministically chosen. In Polyphonic C this non-determinism is supplemented by a substitution mechanism for inherited code. CJava, restricted to outer guards and single inheritance, allows separate redefinition of synchronization code and bodies in subclasses. Programmer control may be improved if inherited classes are ordered <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b26">27]</ref>, resulting in deterministic binding. However, the ordering of superclasses may result in surprising but "correct" behavior. The example of Section 5.3 displays such surprising behavior regardless of how the inherited classes are ordered.</p><p>The statements for high-level control of local computation in Creol are inspired by notions from process algebra <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b61">62]</ref>. Process algebra is usually based on synchronous communication. In contrast to, e.g., the asynchronous -calculus <ref type="bibr" target="#b39">[40]</ref>, which encodes asynchronous communication in a synchronous framework by dummy processes, our communication model is truly asynchronous and without channels: message overtaking may occur. Further, Creol differs from process algebra in its integration of processes in an object-oriented setting using methods, including active and passive object behavior, and self reference rather than channels. In formalisms based on process algebra the operation of returning a result is not directly supported, but typically encoded as sending a message on a return channel <ref type="bibr" target="#b67">[68,</ref><ref type="bibr" target="#b75">76,</ref><ref type="bibr" target="#b76">77]</ref>. Finally, Creol's high-level integration of asynchronous and synchronous communication and the organization of pending processes and interleaving at release points within class objects seem hard to capture naturally in process algebra.</p><p>Formal models clarify the intricacies of object orientation and may thus contribute to better programming languages in the future, making programs easier to understand, maintain, and analyze. Object calculi such as the -calculus <ref type="bibr" target="#b0">[1]</ref> and its concurrent extension <ref type="bibr" target="#b34">[35]</ref> aim at a direct expression of object-oriented features such as self-reference, encapsulation, and method calls, but asynchronous invocation of methods is not addressed. This also applies to Obliq <ref type="bibr" target="#b14">[15]</ref>, a programming language based on similar primitives which targets distributed concurrent objects. The concurrent object calculus of Di Blasio and Fisher <ref type="bibr" target="#b27">[28]</ref> provides both synchronous and asynchronous invocation of methods. In contrast to Creol, return values are discarded when methods are invoked asynchronously and the two ways of invoking a method have different semantics. Class inheritance is not addressed in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b34">35]</ref>.</p><p>In the concurrent object calculus with single inheritance studied by Laneve <ref type="bibr" target="#b51">[52]</ref>, methods of superclasses are accessible and virtual binding is addressed by a careful renaming discipline. A denotational semantics for single inheritance with similar features is studied by Cook and Palsberg <ref type="bibr" target="#b20">[21]</ref>. Multiple inheritance is not addressed in these works. Formalizations of multiple inheritance are usually based on the objects-as-records paradigm and focusses on subtyping issues related to subclassing. Issues related to method binding are not easily captured in this approach: even access to superclass' methods is not addressed in Cardelli's denotational semantics of multiple inheritance <ref type="bibr" target="#b13">[14]</ref>. Rossi et al. <ref type="bibr" target="#b68">[69]</ref> propose a formalization of multiple inheritance based on subobjects, a runtime data structure used for virtual pointer tables <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b72">73]</ref>. Their work focusses on compile-time issues and does not clarify multiple inheritance at the abstraction level of the programming language.</p><p>The dynamically typed prototype-based language Self <ref type="bibr" target="#b18">[19]</ref> proposes an elegant prioritized binding strategy to solve horizontal name conflicts, although a formal semantics is not given. The strategy is based on combining ordered and unordered multiple inheritance. Each superclass is annotated with a priority, and many superclasses may have the same priority. A name is only ambiguous if it occurs in two superclasses with the same priority, in which case a class related to the actual class is preferred. However, explicit class priorities may have surprising effects in large class hierarchies: names may become ambiguous through inheritance. If neither class is related to the caller the binding does not succeed, resulting in a method-not-understood error.</p><p>The pruned binding strategy proposed in this paper solves these issues without the need for manually declaring (equal) class priorities and without the possibility of method-not-understood errors: calls are only bound to intended method redefinitions. This binding strategy seems particularly useful during system maintenance to avoid introducing unintentional errors in evolving class hierarchies, supported in Creol <ref type="bibr" target="#b48">[49]</ref>. In particular, Creol's operational semantics is based on the dynamic and distributed traversal of the class hierarchy, rather than on virtual pointer tables. Our approach may therefore be combined with dynamic constructs for changing the class inheritance structure, such as adding a class C and enriching an existing class with C as a new superclass.</p><p>The type system presented in this paper resembles that of Featherweight Java <ref type="bibr" target="#b40">[41]</ref>, a core calculus for Java, because of its nominal approach. Featherweight Java is class-based and uses a class table to represent class information in its type system. Subtyping is the reflexive and transitive closure of the subclass relation. In contrast the type system of Creol cleanly distinguishes classes and types, which results in both a class and an interface table. Furthermore, Featherweight Java does not address issues related to assignment, overloading, and interfaces. A subtype discipline is required for method overriding, which allows significantly simpler definitions of method lookup (virtual binding is trivial in this setting). Multiple inheritance, interfaces and cointerfaces, nondeterministic merge and choice, and asynchronous method calls are not found in (Featherweight) Java. PolyToil <ref type="bibr" target="#b12">[13]</ref> separates subtyping and (single) inheritance. Object types resemble Creol's interfaces, but there is only one type per class and no notion of cointerface. Scala <ref type="bibr" target="#b64">[65]</ref> uses a nominal type system for mixin-based traits, extending a single inheritance relation. Asynchronous method calls, interfaces, and cointerfaces in Creol necessitate a more refined type system, including an effect system <ref type="bibr" target="#b54">[55]</ref>. A type and effect system provides an elegant way of adding context information to the type analysis <ref type="bibr" target="#b73">[74]</ref>. Type and effect systems have been used to ensure that, e.g., guards controlling method availability do not have side effects <ref type="bibr" target="#b27">[28]</ref> and to estimate the effects of a reclassification primitive <ref type="bibr" target="#b31">[32]</ref>. For Creol, the effect system derives type-correct signatures for asynchronous method calls. The system may be extended to ensure the absence of null pointers, using initialization restrictions <ref type="bibr" target="#b29">[30]</ref> and checks on remote calls guaranteeing that called objects are not null.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>This paper has presented the Creol model of distributed concurrent objects communicating by means of asynchronous method calls. The approach emphasizes flexibility with respect to the possible delays and instabilities of distributed computing but also with respect to code reuse through a liberal notion of multiple inheritance. The model makes a clear distinction between inheritance and subtyping, in particular subtyping is not required for method redefinition. Object variables are typed by interface, abstracting from the actual class of external objects. An object may be typed by many interfaces, expressing different roles of the object. Interfaces may require cointerfaces, expressing dependencies which facilitate protocol sessions in the distributed environment. The concept of contracts is used to statically control the typing of mutually dependent classes in presence of inheritance. Creol is formalized with an operational semantics defined in rewriting logic, providing a detailed account of, e.g., asynchronous method calls, object creation, and late binding. A type system for Creol has been introduced in this paper, distinguishing data types, interfaces, and classes. Type checking asynchronous method calls is based on a type and effect system. It is shown that runtime type errors do not occur for well-typed programs, including asynchronous method calls, non-deterministic choice and merge, multiple inheritance, object creation, and late binding of internal methods using the pruned binding strategy.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A syntax for the abstract representation of interface specifications. Square brackets are used as meta parenthesis, with superscript ? for optional parts, superscript * for repetition zero or more times, whereas [. . .] + d denotes repetition one or more times with d as delimiter. e denotes a list of expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 6 .</head><label>6</label><figDesc>A class is represented by a term class (Param, Impl, Contract, Inh, Var, Mtd), where Param is a list of typed program variables, Contract and Impl are lists of interface names, Inh is a list of instantiated class names, defining class inheritance, Var is a list of typed program variables with initial expressions, and Mtd is a set of methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. An outline of the language syntax for program statements, with typical terms for each syntactic category. Capitalized terms such as v, s, and e denote lists, sets, or multisets of the given syntactic categories, depending on the context.</figDesc><graphic coords="7,132.85,67.68,275.76,70.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A class capturing nodes in a peer-to-peer network.</figDesc><graphic coords="9,127.85,68.04,285.60,231.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Typing of variable and parameter declarations.</figDesc><graphic coords="11,132.85,67.37,276.00,64.37" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Typing of basic statements.</figDesc><graphic coords="11,94.35,176.32,352.92,135.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(METHOD) ٛ v (caller : Co); Inpar; Outpar; Body.Var + ٛ s Body.Code ٛ method (Name, Co, Inpar, Outpar, Body) Sig .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Typing of external and internal invocation and reply statements. For an element F , F denotes C ( v (self )).F , i.e., the corresponding element in the current class term.</figDesc><graphic coords="13,127.85,67.92,285.60,328.82" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Lemma 3 .</head><label>3</label><figDesc>If a synchronous call e.m(e; v) or m(e; v) is type-correct, then the corresponding asynchronous invocation !e.m(e) or !m(e) is also type-correct. Proof. Assume that e.m(e; v) is type-correct. The rule ext-sync asserts that there is an interface I , a cointerface Co ∈ C ( v (self )). Contract, and a type T such that ٛ f e : I , ٛ f e : T , and match(m, T → v (v), Co, I (I ).Mtd). It follows from the match that v (v) =⊥, so we have v (v) Data and consequently match(m, T → Data, Co, I (I ). Mtd) holds. Rule ext-async then asserts that the call !e.m(e) is type-correct. The case for the internal calls m(e; v) and !m(e) is similar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. An operational semantics in rewriting logic.</figDesc><graphic coords="18,104.34,68.68,338.64,576.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>4 . 4 .</head><label>44</label><figDesc>Let C be a class similar to class C, but without an active run method. The runtime representation of class C is given as C : Cl | Par : , Att : , Mtds = { run, → , , , return( ), m, → Bool, B, , (x := true; return(x)), x → d Bool m, → Nat, A, , (x := 0; return(x)), x → d Nat }, Tok : 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9</head><label>9</label><figDesc>Fig.9presents an execution sequence in which an object of class C creates an instance of C and makes an asynchronous call to the new object. The call t!o.m() of the Creol code is expanded to t!o.m( → Nat, AB, ) after the type analysis. This call causes an invocation to the C object, of the method m with Nat output, which again causes a completion with the value 0. The object of class C assigns 0 to its local variable x and the execution terminates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Lemma 7 .</head><label>7</label><figDesc>Given an arbitrary Creol program P and a well-typed execution of P . The execution of a statement x := new C(e) in the final configuration of results in well-typed configurations of P while the new object is initialized.Proof. Let o be a runtime object executing x := new C(e) (by applying rule R3) in the final configuration i of (and let o denote o after executing the statement). Since is well-typed, o is well-typed. Since P is well-typed, Lemma 2 asserts that v (x) has a type J and the typing rule for object creation ensures that there is an interface I ∈ C (C).Impl; C (C).Contract such that I J . Consequently, the new object reference (C; n) may be typed by J and o is well-typed.It remains to show that object creation results in a new well-typed initialized runtime object of class C with a unique identifier. Let e denote e evaluated in o. Given a runtime class representation C : Cl | Par : (v: T ), Att : a, Tok : n in i , the configuration i+1 includes a runtime object (C; n) : Ob | Cl : C, Att : , Pr : ((v : T = e ; a) ↓; run), , PrQ : , EvQ : , Lab : 1 ,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. An example of an execution sequence. The representation of C as well as some intermediary states are omitted, -→ RX denotes the application of rule RX. For convenience, we denote the method multiset of C by m, next (n) by n + 1, and ignore equational reduction.</figDesc><graphic coords="21,56.35,67.88,429.36,575.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>(</head><label></label><figDesc>C; n) : Ob | Cl : C, Att : , Pr : run, , PrQ : , EvQ : , Lab : 1 in a new well-typed configuration i+j . Note that the rewrite steps involved in object initialization, i.e., the repeated application of R1, are internal to (C; n). Consequently, concurrent activity does not influence the initialization and for simplicity we assume that such activity preserves configuration well-typedness. For class C, rule class asserts that ٛ v Param; Var . It follows by induction over the length of Var that the assignment of initial expressions to the program variables in the list (self : Any = (C; n); v : T = e ; a) ↓ is type-correct and results in a well-typed state which is defined for self and the variables declared in Param; Var.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>o</head><label></label><figDesc>: Ob|Pr : (!x.m(Sig, Co, e); s) , Lab : n -→ o : Ob|Pr : s , Lab : next(n) invoc(m, Sig, Co, (o n e )) to x . Let C be the runtime class of x. After invoc(m, Sig, Co, (o n e )) to x eventually arrives at x by application of R11, the application of R12 generates a message bind(m, Sig, Co, (o n e ), x ) to C. Lemma 7 asserts that if v (x ) = I for some interface I , then C implements I . It follows from the type analysis that there must be a signature Sig I and cointerface Co I for m in I and a signature Sig C = T in → T out and cointerface Co C for m in C such that Sig C Sig I Sig and Co Co I Co C , so T out T out . As the subtype relation is transitive the runtime match function succeeds and the application of R16 results in the rewrite step (bind(m, Sig, Co, (o n e ), x ) to C) C : Cl | Mtds : m -→ (bound(get(m, m, (o n e ))) to x ) C : Cl | Mtds : m . For an internal runtime invocation !m(Sig, , e), we get Sig C Sig and directly from rule int-async and the runtime match function succeeds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. The language extended with constructs for local high-level control.</figDesc><graphic coords="25,126.85,67.76,288.00,87.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Typing of local high-level control structures.</figDesc><graphic coords="26,135.84,67.48,276.00,149.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. An operational semantics for local high-level control structures.</figDesc><graphic coords="28,130.84,68.05,285.60,140.69" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. A language extension for static and virtual internal calls.</figDesc><graphic coords="31,126.85,67.82,288.00,88.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Binding calls to m, m@C, and m &lt; C in an object of class D.</figDesc><graphic coords="32,166.84,67.56,213.84,94.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Definition 13 .</head><label>13</label><figDesc>. Let be the reflexive and transitive closure of the subclass relation; C C expresses that C is a direct or indirect subclass of C , or is the same class as C . Let be a typing environment, C be a class name, e a list of expressions, and c a list of instantiated class names. Define matchparam( , ) = true matchparam( , C(e); c) = ٛ f e : T ∧ T type( C (C).Param) ∧ matchparam( , c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Typing of multiple inheritance and bounded method calls. Here sig(m) returns the signature of m. The subscript "_" in the REPLY rule denotes an empty class subscript, representing an external invocation.</figDesc><graphic coords="35,104.35,68.15,333.24,380.59" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 16 .</head><label>16</label><figDesc>Fig.<ref type="bibr" target="#b15">16</ref>. An operational semantics with multiple inheritance. Note that the rules R2 , R3 , R10 , and R16 redefine the previous rules R2, R3, R10, and R16. In R10 , mq denotes either m@C or m &lt; C.</figDesc><graphic coords="36,131.34,67.84,285.48,355.90" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. State instantiation equations for multiple inheritance. additional stopbind message with token n, which suspends binding while checking that C C . This is done by two auxiliary messages, captured in R27-R30: the message find(n, C , C) to I represents that C is asking a list I of instantiated class names (ignoring the actual parameter values for readability) if C may be found in I or further up in the hierarchy. The corresponding message found(n, b, C ) to C returns an answer to C. In this message the Boolean b is true if the request was successful and n matches the token of the stopbind message, identifying the call being bound. This search corresponds to left-first breadth-first traversal of the inheritance graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Lemma 15 .</head><label>15</label><figDesc>If inherit (o, s, a) to i is a message in a configuration of a well-typed execution of a program P , then F ٛ v s .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Lemma 16 .</head><label>16</label><figDesc>Given an arbitrary Creol program P and a well-typed execution of P . The execution of a statement x := new C(e) in the final configuration of results in well-typed configurations of P while the new object is initialized. Proof. Let o be a runtime object executing x := new C(e) (by the application of R3 ) in the final configuration i of . Let o be the new object reference. The well-typedness of o before and after the execution of x := new C(e) and the uniqueness of reference o are covered in the proof of Lemma 7. The configuration i+1 includes a runtime object o : Ob | Cl : C, Att : , Pr : ((a 0 ) ↓; run), , PrQ : , EvQ : , Lab : 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>(If we are instantiating a leaf class directly, s, a, and i are empty.) The operational semantics gives us (inherit(o, s, a) to i C (In)) C : Cl | Par : (v : T ), Inh : nil, Att : a = (inherit(o, (s; v : T = In), (a ; a)) to i) C : Cl | Par : (v : T ), Inh : nil, Att : a . By Lemma 15, ٛ v s; v : T = In . We need to show that ٛ v s; v : T = In; a . Since C is a leaf the function InhAttr (Inh, C ) = and, by the typing rule class-inh, + ٛ v a . It follows that ٛ v s; v : T = In; a .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>inherit(o, s, a) to (i C (In)) C : Cl | Par : (v : T ), Inh : i , Att : a = inherit(o, (s; v : T = In), (a ; a)) to (i i ) C : Cl | Par : (v : T ), Inh : i , Att : a . The message inherit(o, (s; v: T = In), (a ; a)) to (i i ) is further reduced to inherit(o, (s; v: T = In; s ), (a ; a ; a)) to i, where the superclasses of C have been expanded. Here, s and a are the accumulated parameter and attribute assignment lists from the classes in i . By Lemma 15 and the induction hypothesis, ٛ v s; v: T = In; s ; a . We need to show that ٛ v s; v: T = In; s ; a ; a . By typing rule class-inh, + ٛ v a , since contains all class parameters and inherited attributes. It follows that ٛ v s; v: T = In; s ; a ; a and s; v: T = In; s ; a ; a contains all state variables declared above C .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>.</figDesc><table><row><cell>interface Client</cell><cell>interface Server</cell><cell>interface Peer</cell></row><row><cell>begin</cell><cell>begin</cell><cell>inherits Client, Server</cell></row><row><cell>with Any</cell><cell>with Server</cell><cell>begin</cell></row><row><cell>op availFiles</cell><cell>op enquire</cell><cell>end</cell></row><row><cell>op reqFile</cell><cell>op getLength</cell><cell></cell></row><row><cell>end</cell><cell>op getPacket</cell><cell></cell></row><row><cell></cell><cell>end</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>• Applying R11 or R12 does not modify state variables, and i+1 is well-typed.• For R16, observe that since is well-typed a message bind(m, Sig, Co, e, o) must have been generated from a</figDesc><table /><note><p><p>message invoc(m, Sig, Co, e) to o by application of R12 and that the message invoc(m, Sig, Co, e) to o must have been generated by R9 or R10 from a statement !x.m(Sig, Co, e) or !m(Sig, Co, e). Lemma 8 asserts that a call !x.m(Sig, Co, e) or !m(Sig, Co, e) in P can be type-correctly bound at runtime. Consequently, the conditional test match(m, Sig, Co, m) will succeed in R16, resulting in a bound message. It follows that i+1 is well-typed.</p>• For R17, since is well-typed the message bound( s, l ) to o comes from applying R16. Therefore, the function get has instantiated the formal parameters v of some method m with actual values e such that the call is covered. Consequently, (e) v (v) and l is well-typed. It follows that since o was well-typed in i , o is also well-typed in i+1 , and i+1 is well-typed.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>We now consider concurrent access to the database. Low-clearance agents may share access to unclassified data while high-clearance agents have unique access to (classified) data. Proper usage is defined by two interfaces, defining open and close operations at both access levels: Not all agents are entitled to high authorization, so openH returns a Boolean. Let a class DB provide the actual operations on the database. We assume given the following internal operations: access (in k:Key, level:Bool out y:Data), where level defines the access level (high or low), and clear (in x:Agent out b:Bool) to give clearance to sensitive data for agent x. Any agent may get low-access rights, while only agents cleared by the database may be granted exclusive high access. Consequently, the MAuth class authorizes low clearance and SAuth authorizes high clearance. Since the attribute gr in SAuth is implemented as an object identifier, only one agent is authorized full access at a time.</figDesc><table><row><cell>class HAuth implements High</cell><cell></cell></row><row><cell>inherits SAuth, DB</cell><cell>class LAuth implements Low</cell></row><row><cell>begin</cell><cell>inherits MAuth, DB</cell></row><row><cell>op access(in x:Agent ;k:Key out y:Data)</cell><cell>begin</cell></row><row><cell>== auth(x); await access@DB(k,high;y)</cell><cell>op access(in x:Agent ;k:Key out y:Data)</cell></row><row><cell>with Agent</cell><cell>== auth(x); await access@DB(k,low;y)</cell></row><row><cell>op openH(out ok:Bool) ==</cell><cell>with Agent</cell></row><row><cell>await clear(caller ;ok);</cell><cell>op openL == grant(caller )</cell></row><row><cell>if ok then grant(caller ) else skip fi</cell><cell>op access(in k:Key out y:Data) ==</cell></row><row><cell>op access(in k:Key out y:Data) ==</cell><cell>access(caller,k; y)</cell></row><row><cell>access(caller,k; y)</cell><cell>op closeL == revoke(caller )</cell></row><row><cell>op closeH == revoke(caller )</cell><cell>end</cell></row><row><cell>end</cell><cell></cell></row><row><cell>class SAuth implements Auth</cell><cell>class MAuth implements Auth</cell></row><row><cell>begin</cell><cell>begin</cell></row><row><cell>var gr : Agent = null</cell><cell>var gr : Set[Agent ] = ∅</cell></row><row><cell>op delay == await (gr = null)</cell><cell>op delay == await (gr = ∅)</cell></row><row><cell>op grant(in x:Agent )== delay(); gr :=x</cell><cell>op grant(in x:Agent ) == gr :=gr ∪ {x}</cell></row><row><cell>op auth(in x:Agent )== await (gr =x)</cell><cell>op auth(in x:Agent ) == await (x ∈ gr )</cell></row><row><cell>op revoke(in x:Agent ) ==</cell><cell>op revoke(in x:Agent ) == gr :=gr \{x}</cell></row><row><cell>if gr = x then gr :=null else skip fi</cell><cell></cell></row><row><cell>with Agent</cell><cell>with Agent</cell></row><row><cell>op grant == grant(caller )</cell><cell>op grant == grant(caller )</cell></row><row><cell>op revoke == revoke(caller )</cell><cell>op revoke == revoke(caller )</cell></row><row><cell>op auth == auth(caller )</cell><cell>op auth == auth(caller )</cell></row><row><cell>end</cell><cell>end</cell></row><row><cell>5.3.1. Authorization levels</cell><cell></cell></row><row><cell>interface High</cell><cell>interface Low</cell></row><row><cell>begin</cell><cell>begin</cell></row><row><cell>with Agent</cell><cell>with Agent</cell></row><row><cell>op openH(out ok:Bool)</cell><cell>op openL</cell></row><row><cell>op access(in k:Key out y:Data)</cell><cell>op access(in k:Key out y:Data)</cell></row><row><cell>op closeH</cell><cell>op closeL</cell></row><row><cell>end</cell><cell>end</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>where i is initially empty. The method lookup function may potentially traverse the entire inheritance tree above C, including C . Method binding is guaranteed to succeed at C .An internal method call !m@C(Sig, Co, e) in an object o resembles the previous case. By R10 the call results in a message invoc(m@C, Sig, Co, e ) to o which, by applying R24, generates a message bind(m, Sig, Co, e , o) to C where C is the specified class. The call is correctly bound if there is a method m declared above C with signature Sig = T in → T out and cointerface Co such that Sig</figDesc><table /><note><p>Sig, Co, m) then bound(get(m, m, e )) to x else bind(m, Sig, Co, e , x) to (i i ) fi C : Cl | Inh : i, Mtds : m</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>• Rules R16 and R26: Let i be a list of instantiated class names. As i is a configuration of the well-typed execution , a</figDesc><table /><note><p>message bind(m, Sig, Co, e, o) to i must have been generated from a message invoc(m@C, Sig, Co, e) by application of R24 or from a message invoc(m, Sig, Co, e) by application of R12 for external calls. Similarly, a message bind(m &lt; C , Sig, Co, e, o) to i must have been generated from a message invoc(m &lt; C , Sig, Co, e) by application of R25. These invoc messages must have been generated by applying R10 to a statement !mq(Sig, Co, e) or R9 to a statement !x.m(Sig, Co, e) for external calls. By Lemma 17, any such call m@C(Sig, Co, e), m &lt; C (Sig, Co, e), or !x.m(Sig, Co, e) in P can be type-correctly bound at runtime. Consequently, the match function in R16 and R26</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We are grateful to Dave Clarke for interesting discussions and to the anonymous referees for excellent feedback, significantly improving the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A theory of objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Monographs in Computer Science</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><surname>Ábrahám-Mumm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">S</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-P</forename><surname>De Roever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Verification for Java&apos;s reentrant multithreading concept, Internat. Conf. on Foundations of Software Science and Computation Structures (FOSSACS&apos;02)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-04">April 2002</date>
			<biblScope unit="volume">2303</biblScope>
			<biblScope unit="page" from="5" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Abstracting interaction patterns: A programming paradigm for open distributed systems</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First IFIP Internat. Conf. on Formal Methods for Open Object-based Distributed Systems (FMOODS&apos;96)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Najm</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-B</forename><surname>Stefani</surname></persName>
		</editor>
		<meeting>First IFIP Internat. Conf. on Formal Methods for Open Object-based Distributed Systems (FMOODS&apos;96)<address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Chapman &amp; Hall</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="135" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A foundation for actor computation</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Agha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Programming</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="72" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A parallel object-oriented language with inheritance and subtyping</title>
		<author>
			<persName><forename type="first">P</forename><surname>America</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Der Linden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Meyrowitz</surname></persName>
		</editor>
		<meeting>Conf. on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990-10">October 1990</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="161" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Andrews</surname></persName>
		</author>
		<title level="m">Foundations of Multithreaded, Parallel, and Distributed Programming</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A natural semantics for Eiffel dynamic binding</title>
		<author>
			<persName><forename type="first">I</forename><surname>Attali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Caromel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Ehmety</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Program. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="711" to="729" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Modern concurrency abstractions for C</title>
		<author>
			<persName><forename type="first">N</forename><surname>Benton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Program. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="769" to="804" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Klaim project: theory and practice</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Loreti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tuosto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Venneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Global Computing, Programming Environments, Languages, Security, and Analysis of Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Priami</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2874</biblScope>
			<biblScope unit="page" from="88" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Mixin-based inheritance</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. on Object-Oriented Programming: Systems, Languages, and Applications/European, Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Meyrowitz</surname></persName>
		</editor>
		<meeting>Conf. on Object-Oriented Programming: Systems, Languages, and Applications/European, Conference on Object-Oriented Programming<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="303" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Java&apos;s insecure parallelism</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Brinch</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="38" to="45" />
			<date type="published" when="1999-04">April 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Foundations of Object-Oriented Languages: Types and Semantics</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Bruce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">PolyTOIL: a type-safe polymorphic object-oriented language</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schuett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Gent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fiech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Program. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="225" to="290" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A semantics of multiple inheritance</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="138" to="164" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A language with distributed scope</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="59" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Caromel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Roudier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. on Object-Based Parallel and Distributed Computation</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J.-P</forename><surname>Briot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Geib</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</editor>
		<meeting>Conf. on Object-Based Parallel and Distributed Computation<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1107</biblScope>
			<biblScope unit="page" from="125" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Linda in context</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="444" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An event-based structural operational semantics of multi-threaded Java</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cenciarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Knapp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Syntax and Semantics of Java</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Alves-Foss</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1523</biblScope>
			<biblScope unit="page" from="157" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Parents are shared parts of objects: inheritance and encapsulation in SELF</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ungar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hölzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lisp and Symbolic Comput</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="207" to="222" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Specification and programming in rewriting logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Durán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Eker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Quesada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maude</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">285</biblScope>
			<biblScope unit="page" from="187" to="243" />
			<date type="published" when="2002-08">August 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A denotational semantics of inheritance and its correctness</title>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">114</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="329" to="350" />
			<date type="published" when="1994-11">November 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Inheritance is not subtyping</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Canning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th ACM Symp. on Principles of Programming Languages (POPL&apos;90)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990-01">January 1990</date>
			<biblScope unit="page" from="125" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Introducing concurrent objects in Java</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cugola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cjava</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth Internat. Conf. on Object Oriented Information Systems (OOIS&apos;97)</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Orlowska</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Zicari</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="504" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Essays in Honour of</title>
		<author>
			<persName><forename type="first">O.-J</forename><surname>Dahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Classical Mind</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</editor>
		<imprint>
			<publisher>Engle Wood Cliffs</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="93" to="103" />
		</imprint>
	</monogr>
	<note>Monitors revisited</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Common base language</title>
		<author>
			<persName><forename type="first">O.-J</forename><surname>Dahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Myrhaug</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nygaard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968-05">May 1968</date>
			<publisher>Norwegian Computing Center</publisher>
			<pubPlace>Oslo, Norway</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical report S-2, Norsk Regnesentral</note>
	<note>Simula 67</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Understanding UML: a formal semantics of concurrency and communication in real-time UML</title>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Josko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Votintseva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First Internat. Symp. Formal Methods for Components and Objects</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">S</forename><surname>De Boer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Bonsangue</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002. 2003</date>
			<biblScope unit="volume">2852</biblScope>
			<biblScope unit="page" from="71" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The common lisp object system: an overview</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Demichiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Gabriel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conf. on Object-Oriented Programming (ECOOP&apos;87)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Bézivin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-M</forename><surname>Hullot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Cointe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">276</biblScope>
			<biblScope unit="page" from="151" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A calculus for concurrent objects</title>
		<author>
			<persName><forename type="first">P</forename><surname>Di Blasio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seventh Internat. Conf. on Concurrency Theory (CONCUR&apos;96)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Sassone</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996-08">August 1996</date>
			<biblScope unit="volume">1119</biblScope>
			<biblScope unit="page" from="655" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Guarded commands, nondeterminacy and formal derivation of programs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="453" to="457" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<title level="m">A Discipline of Programming</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Verification of concurrent objects with asynchronous method calls</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dovland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Internat. Conf. on Software-Science, Technology &amp; Engineering (SwSTE&apos;05)</title>
		<meeting>IEEE Internat. Conf. on Software-Science, Technology &amp; Engineering (SwSTE&apos;05)<address><addrLine>Silver Spring, MD</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2005-02">February 2005</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">More dynamic object re-classification: Fickle II</title>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Giannini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Program. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="153" to="191" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The reflexive chemical abstract machine and the Join-calculus</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symp. on Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="372" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Software Engineering with OBJ: Algebraic Specification in Action</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Winkler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Futatsugi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Formal Methods</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Malcolm</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="167" />
			<date type="published" when="2000">2000</date>
			<publisher>Kluwer Academic Publishers</publisher>
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
	<note>Introducing OBJ</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A concurrent object calculus: reduction and typing</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Hankin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HLCL &apos;98: High-Level Concurrent Languages</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Nestmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Steele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<title level="m">The Java Language Specification, Java Series</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Extending objects to support multiple interfaces and access control</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hailpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Software Eng</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1247" to="1257" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Monitors: an operating systems structuring concept</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="549" to="557" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Series in Computer Science</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">An object calculus for asynchronous communication</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tokoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Conf. on Object-Oriented Programming (ECOOP&apos;91)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>America</surname></persName>
		</editor>
		<meeting>European Conf. on Object-Oriented Programming (ECOOP&apos;91)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">512</biblScope>
			<biblScope unit="page" from="133" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Featherweight Java: a minimal core calculus for Java and GJ</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="396" to="450" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Open distributed processing-reference model parts 1-4</title>
		<imprint>
			<date type="published" when="1995-07">July 1995</date>
			<publisher>International Telecommunication Union</publisher>
			<pubPlace>Geneva</pubPlace>
		</imprint>
		<respStmt>
			<orgName>ISO/IEC</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Itzstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jasiunas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eighth Asia-Pacific Computer Systems Architecture Conference (ACSAC 2003)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Omondi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Sedukhin</surname></persName>
		</editor>
		<meeting>Eighth Asia-Pacific Computer Systems Architecture Conference (ACSAC 2003)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2823</biblScope>
			<biblScope unit="page" from="151" to="165" />
		</imprint>
	</monogr>
	<note>On implementing high level concurrency in Java</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A compositional formalism for object viewpoints</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fifth Internat. Conf. on Formal Methods for Open Object-Based Distributed Systems (FMOODS&apos;02)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Rensink</surname></persName>
		</editor>
		<meeting>Fifth Internat. Conf. on Formal Methods for Open Object-Based Distributed Systems (FMOODS&apos;02)<address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Klüwer Academic Publishers</publisher>
			<date type="published" when="2002-03">March 2002</date>
			<biblScope unit="page" from="45" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">From Object-Orientation to Formal Methods: Essays in Memory of Ole-Johan Dahl</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Krogdahl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Lyche</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2635</biblScope>
			<biblScope unit="page" from="137" to="164" />
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>Object-oriented specification and open distributed systems</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Owe, Inheritance in the presence of asynchronous method calls</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 38th Hawaii Internat. Conf. System Sciences (HICSS&apos;05)</title>
		<meeting>38th Hawaii Internat. Conf. System Sciences (HICSS&apos;05)<address><addrLine>Silver Spring, MD</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2005-01">January 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10270-006-0011-2</idno>
		<title level="m">An asynchronous communication model for distributed concurrent objects, Software and Systems Model</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A run-time environment for concurrent objects with asynchronous method calls</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Axelsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fifth International Workshop on Rewriting Logic and its Applications (WRLA&apos;04)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</editor>
		<meeting>Fifth International Workshop on Rewriting Logic and its Applications (WRLA&apos;04)<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="2004-03">Mar. 2004. January 2005</date>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="375" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A dynamic class construct for asynchronous concurrent objects</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Johnsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Owe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Simplot-Ryl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Seventh Internat. Conf. on Formal Methods for Open Object-Based Distributed Systems (FMOODS&apos;05)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Steffen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</editor>
		<meeting>Seventh Internat. Conf. on Formal Methods for Open Object-Based Distributed Systems (FMOODS&apos;05)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="volume">3535</biblScope>
			<biblScope unit="page" from="15" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menhdhekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Loingtier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th European Conf. on Object-Oriented Programming (ECOOP&apos;97)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Akşit</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</editor>
		<meeting>11th European Conf. on Object-Oriented Programming (ECOOP&apos;97)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="volume">1241</biblScope>
			<biblScope unit="page" from="220" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Multiple inheritance in Simula-like languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Krogdahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BIT</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="318" to="326" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<title level="m">Formal Methods for Distributed Processing-A Survey of Object-Oriented Approaches</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Bowman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Derrick</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="326" to="353" />
		</imprint>
	</monogr>
	<note>Inheritance in concurrent objects</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Promises: linguistic support for efficient asynchronous procedure calls in distributed systems</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shrira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGPLAN Conf. on Programming Language Design and Implementation (PLDI&apos;88)</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wise</surname></persName>
		</editor>
		<meeting>SIGPLAN Conf. on Programming Language Design and Implementation (PLDI&apos;88)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1988-06">June 1988</date>
			<biblScope unit="page" from="260" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A behavioral notion of subtyping</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1811" to="1841" />
			<date type="published" when="1994-11">November 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Polymorphic effect systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Lucassen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Symp. Principles of Programming Languages (POPL&apos;88)</title>
		<meeting>15th Symp. Principles of Programming Languages (POPL&apos;88)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Analysis of inheritance anomaly in object-oriented concurrent programming languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research Directions in Concurrent Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Wegner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge MA</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="107" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conditional rewriting logic as a unified model of concurrency</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="73" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Rewriting logic semantics: from language specifications to formal analysis tools</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Internat. Joint Conf. Automated Reasoning (IJCAR 2004)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Basin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</editor>
		<meeting>Second Internat. Joint Conf. Automated Reasoning (IJCAR 2004)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3097</biblScope>
			<biblScope unit="page" from="1" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Object-Oriented Software Construction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A study of the fragile base class problem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Mikhajlov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sekerinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th European Conference on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Jul</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1445</biblScope>
			<biblScope unit="page" from="355" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">The inheritance anomaly: ten years after</title>
		<author>
			<persName><forename type="first">G</forename><surname>Milicia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sassone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2004 ACM Symp. on Applied Computing</title>
		<meeting>2004 ACM Symp. on Applied Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1267" to="1274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communicating and Mobile Systems: the -Calculus</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A formal semantics for the ODP computational model</title>
		<author>
			<persName><forename type="first">E</forename><surname>Najm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-B</forename><surname>Stefani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Networks and ISDN Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1305" to="1329" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A tour of Hybrid-A language for programming with active objects</title>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Object-Oriented Software Engineering</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Mandrioli</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="167" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A nominal theory of objects with dependent types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cremet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Röckl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th European Conf. on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</editor>
		<meeting>17th European Conf. on Object-Oriented Programming<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="volume">2743</biblScope>
			<biblScope unit="page" from="201" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">A survey on concurrent object-oriented languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Philippsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency: Pract. and Experience</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="917" to="980" />
			<date type="published" when="2000-08">August 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Pict: a programming language based on the pi-calculus</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proof, Language and Interaction: Essays in Honour of Robin Milner</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Stirling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge MA</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Modeling subobject-based inheritance</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Rossie</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th European Conference on Object-Oriented Programming (ECOOP&apos;96)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Cointe</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1098</biblScope>
			<biblScope unit="page" from="248" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Traits: composable units of behaviour</title>
		<author>
			<persName><forename type="first">N</forename><surname>Schärli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Black</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th European Conf. on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</editor>
		<meeting>17th European Conf. on Object-Oriented Programming<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="volume">2743</biblScope>
			<biblScope unit="page" from="248" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Inheritance and the development of encapsulated software systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research Directions in Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Shriver</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Wegner</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="165" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Inheritance: from code reuse to reasoning reuse</title>
		<author>
			<persName><forename type="first">N</forename><surname>Soundarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fridella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fifth Internat. Conf. on Software Reuse (ICSR5)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Poulin</surname></persName>
		</editor>
		<meeting>Fifth Internat. Conf. on Software Reuse (ICSR5)<address><addrLine>Silver Spring, MD</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="206" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Multiple inheritance for C++</title>
		<author>
			<persName><forename type="first">B</forename><surname>Stroustrup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="367" to="395" />
			<date type="published" when="1989-12">December 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Polymorphic type, region and effect inference</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jouvelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="271" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Using role components to implement collaboration-based designs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vanhilst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA&apos;96)</title>
		<meeting>Conf. on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA&apos;96)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="359" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Typed concurrent objects</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Vasconcelos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Eighth European Conf. on Object-Oriented Programming (ECOOP&apos;94)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Tokoro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Pareschi</surname></persName>
		</editor>
		<meeting>of the Eighth European Conf. on Object-Oriented Programming (ECOOP&apos;94)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">821</biblScope>
			<biblScope unit="page" from="100" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Objects in the -calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">116</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="271" />
			<date type="published" when="1995-02">February 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Surveying current research in object-oriented design</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Wirfs-Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="104" to="124" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Concurrent programming in ConcurrentSmalltalk</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yokote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tokoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Concurrent Programming</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Tokoro</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="129" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">ABCL: an Object-Oriented Concurrent System</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Series in Computer Systems</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
