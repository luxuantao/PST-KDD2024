<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Melange: A Meta-language for Modular and Reusable Development of DSLs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Degueule</surname></persName>
							<email>thomas.degueule@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">INRIA</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benoit</forename><surname>Combemale</surname></persName>
							<email>benoit.combemale@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">INRIA</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arnaud</forename><surname>Blouin</surname></persName>
							<email>arnaud.blouin@irisa.fr</email>
							<affiliation key="aff2">
								<orgName type="institution">INSA Rennes</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Barais</surname></persName>
							<email>olivier.barais@irisa.fr</email>
							<affiliation key="aff3">
								<orgName type="institution">University of Rennes 1</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jean-Marc</forename><surname>Jézéquel</surname></persName>
							<email>jezequel@irisa.fr</email>
							<affiliation key="aff4">
								<orgName type="institution">University of Rennes 1</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Melange: A Meta-language for Modular and Reusable Development of DSLs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AFA4AE5E283AECB4C686FEA244A3F5E2</idno>
					<idno type="DOI">10.1145/2814251.2814252</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.2 [Language Classifications]: Specialized application languages Domain-specific languages</term>
					<term>language reuse</term>
					<term>language composition</term>
					<term>model typing</term>
					<term>melange</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Domain-Specific Languages (DSLs) are now developed for a wide variety of domains to address specific concerns in the development of complex systems. When engineering new DSLs, it is likely that previous efforts spent on the development of other languages could be leveraged, especially when their domains overlap. However, legacy DSLs may not fit exactly the end user requirements and thus require further extension, restriction, or specialization. While current language workbenches provide import mechanisms, they usually lack an explicit support for such customizations of imported artifacts. In this paper, we propose an approach for building DSLs by safely assembling and customizing legacy DSLs artifacts. This approach is based on typing relations that provide a reasoning layer for manipulating DSLs while ensuring type safety. On top of this reasoning layer, we provide an algebra of operators for extending, restricting, and assembling separate DSL artifacts. We implemented the typing relations and algebra into the Melange meta-language. We illustrate Melange through the modular definition of an executable modeling language for the Internet Of Things domain. We show how it eases the definition of new DSLs by maximizing the reuse of legacy artifacts without introducing issues in terms of performance, technical ecosystem compatibility, or generated code volume.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Extending the time-honored practice of separation of concerns, Domain-Specific Languages (DSLs) are increasingly used to handle different, complex concerns in softwareintensive system development. However, the definition of a DSL and the associated tools (i.e. checkers, simulators, generators) require significant development efforts for, by definition, a limited audience and a DSL that is doomed to evolve as the concepts in the domain and the expert understanding of the domain evolve.</p><p>Despite the wide range of domains in which DSLs are used and their constant evolution, many of them are close and share commonalities such as a particular action language or a common paradigm (e.g. the family of DSLs for statecharts <ref type="bibr" target="#b5">[6]</ref>). Recent work in the community of Software Language Engineering focused on language workbenches that support the modular design of DSLs, and the possible reuse of such modules (usually using a scattered clause import linking separate artifacts) <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b42">43]</ref>. Besides, particular composition operators have been proposed for unifying or extending existing languages <ref type="bibr" target="#b32">[33]</ref>. However, while most of the approaches propose either a diffuse way to reuse language modules, or to reuse as is complete languages, there is still little support for easily assembling language modules with customization facilities (e.g. restriction) in order to finely tune the resulting DSL according to the language designer's requirements.</p><p>In this paper, we present Melange, a tool-supported metalanguage in which legacy DSLs are assembled and customized to produce new ones. Melange provides specific constructs to assemble various abstract syntax and operational semantics artifacts into a DSL. DSLs can then be used as firstclass entities to be reused, extended, restricted or adapted into other DSLs. Melange relies on typing relations that statically ensure the structural correctness of the produced DSLs, and subtyping relations between DSLs to reason about their substitutability. Newly produced DSLs are correct by construction, ready for production (i.e. the result can be deployed and used as is), and reusable in a new assembly.</p><p>We illustrate the benefits of the proposed language operators and type system by designing a new executable modeling language for the Internet Of Things domain. We show how the proposed approach eases the definition of new DSLs by maximizing the reuse of legacy artifacts without introducing issues in terms of performance, technical ecosystem compatibility, or generated code volume.</p><p>The remainder of this paper is organized as follows. Section 2 gives an overview of the approach, further detailed with the algebra for DSL assembly and customization (Section 3) and its support in the dedicated meta-language Melange (Section 4). Then we illustrate our approach with a significant case study in Section 5. Finally, Section 6 discusses related work, and Section 7 concludes and discusses several perspectives of our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Approach Overview</head><p>Domain-specific languages are typically defined through three main concerns: abstract syntax, concrete syntax(es) and semantics. Various approaches may be employed to specify each of them, usually using dedicated meta-languages <ref type="bibr" target="#b43">[44]</ref>. The abstract syntax specifies the domain concepts and their relations and is defined by a metamodel or a grammar. This choice often depends on the language designer's background and culture. Examples of meta-languages for specifying the abstract syntax of a DSL include EMOF <ref type="bibr" target="#b0">[1]</ref> and SDF <ref type="bibr" target="#b18">[19]</ref>. The semantics of a DSL can be defined using various approaches including axiomatic semantics, denotational semantics, operational semantics, and their variants <ref type="bibr" target="#b35">[36]</ref>. Concrete syntaxes are usually specified as a mapping from the abstract syntax to textual or graphical representations, e.g. through the definition of a parser or a projectional editor <ref type="bibr" target="#b45">[46]</ref>. In this paper, we focus on DSLs whose abstract syntaxes are defined with metamodels and whose semantics are defined in an operational way through the definition of computational steps designed following the interpreter pattern <ref type="bibr" target="#b16">[17]</ref>. Computational steps may be defined in different ways, e.g. using aspect-oriented modeling <ref type="bibr" target="#b22">[23]</ref> or endogenous transformations <ref type="bibr" target="#b4">[5]</ref>. In this paper, however, we only focus on the weaving of computational steps in an object-oriented (OO) fashion with the interpreter pattern. In such a case, specifying the operational semantics of a DSL involves the use of an action language to define methods that are statically introduced directly in the concepts of its abstract syntax <ref type="bibr" target="#b23">[24]</ref>. It is worth noting that the proposed approach can easily be adapted to other kinds of operational semantics specification mechanisms, such as endogenous transformations in a functional way. We do not address in this paper the problem of concrete syntax composition and customization.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> gives a high-level overview of our approach. On the right side are legacy language artifacts that must be reused and assembled to build new DSLs. Imported artifacts include abstract syntax and semantics, possibly with their corresponding tools and services (e.g. checkers, or transformations). These tools consist in manipulating models conforming to a particular metamodel. Similarly, semantic definitions directly access and manipulate model elements for execution or compilation purposes. Hence, abstract syntax and semantics are related one another through binding relations: semantics artifacts require a particular shape of abstract syntax, which is provided by a given metamodel. On the left side of Figure <ref type="figure" target="#fig_0">1</ref> are the newly built languages. Assembly operators (merge S , weave) realize the transition from legacy artifacts to new DSLs. They import and connect disparate language artifacts, e.g. by merging different abstract syntaxes or by binding a given semantics to a new syntax. Naturally, the same artifacts can be reused in different assemblies. The output of assembly operators is encapsulated in a language definition. Once new assemblies are created, customization operators (slice, merge L , inherits) offer the possibility to refine the newly built DSLs so as to meet additional requirements or to fit a specialized context. Both assembly and customization operators are captured in an algebra (cf. Section 3). Assembling and customizing DSLs is a complex task that requires checking the composability of heterogeneous parts and the validity of the result. For example, based on Figure <ref type="figure" target="#fig_0">1</ref>, it is clear that Sem1 can be woven on L4 only if it can be bound to its syntax MM2. Similarly, the intuitive meaning of inheritance, as found in most OO languages, implies the compatibility between the super-and sub-elements. It follows that the compatibility between L1 and L3 in Figure <ref type="figure" target="#fig_0">1</ref> must be ensured to guarantee that L1's tooling can be reused for L3. What is missing here to guarantee these properties is an abstraction layer that would support reasoning about the compatibility between different languages artifacts. In our approach, we rely on the notion of model typing as introduced by Steel et al. <ref type="bibr" target="#b41">[42]</ref> and further refined by Guy et al. <ref type="bibr" target="#b17">[18]</ref>. Model types are structural interfaces over the abstract syntax of a language, defined by a metamodel. As such, they also take the form of a metamodel. They are linked one another by subtyping relations that specify if a model We further extend the concept of model typing by explicitly separating implementations of languages (i.e. abstract syntax, semantics, and tools) from their structural interfaces (i.e. model types exposing part of their features) as canonical representation of languages. As depicted in Figure <ref type="figure">2</ref>, each language has at least one model type that captures its structural interface. Then, the associated type system enables reasoning about compatibility between different artifacts, e.g. to check whether a given semantics can be applied on a given abstract syntax, or to ensure that within an inheritance relation the sub-language remains compatible with the super-language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">An Algebra for DSL Assembly and Customization</head><p>In this section, we introduce an abstract algebraic specification of operators for language assembly and customization. This specification is mainly intended to serve as a reference for the implementation of a concrete meta-language that would support the aforementioned approach. We first provide the definitions and concepts required to define the algebra (Section 3.1). Then, we introduce the operators for language assembly (Section 3.2) and customization (Section 3.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Language Definition</head><p>Based on the informal conceptual model of Section 2, we define a language L as a 3-tuple of its abstract syntax, semantics, and exact model type:</p><formula xml:id="formula_0">L AS, Sem, M T</formula><p>Including the exact model type of a language into the tuple allows to directly specify the impact of each of the operators of the algebra on the typing layer. As explained in Section 3.1.3, model types also indirectly support the reuse of languages tooling. In the following, for any language L, we denote AS(L) its abstract syntax, Sem(L) its semantics, and M T (L) its exact model type. On non-ambiguous cases, we simply refer to them as AS, Sem, and M T . The next sub-sections detail each of them.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Syntax and Syntax Merging</head><p>In our algebra, the abstract syntax AS of a language L is specified using a metamodel, i.e. a multigraph of classes and their relations. When assembling several abstract syntaxes, their concepts must be merged together so that the resulting abstract syntax is no less capable than its ancestors. Informally, this means that the abstract syntax resulting from the merge must incorporate concepts from all languages and merge the definitions of shared elements. In our specific case, merging several abstract syntaxes boils down to the problem of metamodel composition <ref type="bibr" target="#b9">[10]</ref>. Figure <ref type="figure" target="#fig_3">3</ref> illustrates the syntax merging operator on a simple example. We use the terms receiving metamodel, merged metamodel, and resulting metamodel to refer to the three metamodels involved in the merging operation. Similarly, the terms receiving language and resulting language will be used throughout this section.</p><p>Depending on the meta-language used for defining metamodels, different merging operators may be employed with different policies for matching and merging rules, conflicts management, etc.. The choice of the concrete semantics of the syntax merging operator is left to the implementer of the algebra, and a concrete implementation is described in Section 4.3. In the remainder of this section, we denote • the abstract syntax merging operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Semantics and Semantics Merging</head><p>The semantics Sem of a language L is defined by a sequence of aspect definitions A t i , where A is a class, t is a pointcut and i is the index of A in the sequence. In this case, the pointcut t specifies the concept of the language's abstract syntax (a meta-class) on which the aspect must be ultimately woven.</p><p>The advice is the class A itself, consisting of attributes and methods. When a joinpoint is found, i.e. when a matching concept is found in the language, elements of the advice are inserted in the target meta-class. Since aspects are defined using classes in an OO manner, they may inherit from each other. To cope with possible specialization and redefinition of methods, aspects are ordered by hierarchy in a sequence:</p><formula xml:id="formula_1">Sem(L) (A t i ∈ Aspects) where ∀A t i ∈ Sem(L), ∃c ∈ AS(L) : c match t ∀A t i , A t j ∈ Sem(L) : A t i A t j =⇒ i &gt; j</formula><p>where match denotes the joinpoint matching relation and denotes the class inheritance operator. For a language to be well-formed, each of its aspects must have a matching meta-class in its abstract syntax; this is what the first property ensures. Ordering the aspects that compose a semantics in a sequence lets the choice of linearization and/or disambiguation opened to the implementer when several aspects are in conflicts (e.g. insert the same method on the same target t). The merging of two semantics, denoted Sem • Sem , consists in producing a new semantics structure. As the definition shows, merging two semantics is equivalent to concatenating their sequences of aspects. As a result, this operator is not commutative and any redefinition of an aspect or method in Sem overrides the previous definition in Sem:</p><formula xml:id="formula_2">Sem • Sem ≡ Sem Sem</formula><p>where denotes the sequence concatenation operator. We also denote sig the signature of an aspect A. The signature of an aspect is a metamodel that exposes all the features (i.e. properties and methods) defined in an aspect and its dependencies, omitting the concrete method bodies. The signature of a semantic specification Sem is thus defined as the structural merge (through •) of the signature of the aspects that compose it:</p><formula xml:id="formula_3">sig(Sem) • A t i ∈Sem sig(A t i )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Model Typing</head><p>Each language L has one exact model type M T . Like abstract syntaxes, model types are described with a metamodel. The exact model type of a language is its most precise structural interface, i.e. the model type that exposes all its features. Thus, the exact model type of a language exposes both its concepts and their relations (i.e. its metamodel) and the signature of its semantics (newly inserted features and methods). Hence, the exact type M T of a language L is defined as the structural merge of its abstract syntax and the signature of its semantics:</p><formula xml:id="formula_4">M T (L) AS(L) • sig(Sem(L))</formula><p>Any change in either the abstract syntax or the signature of the semantics of a language will result in a different type. The issue of tooling is indirectly addressed through the reasoning capabilities provided by the model typing layer: if the result of the application of operators leads to a language L whose model type M T is a subtype of the model type M T of another language L , then tools defined for L can be reused as is for L. In the following, we denote &lt;: the subtyping relation between model types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Operators for Language Assembly</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Syntax Merging</head><p>When building new languages, it is likely that previously defined language abstract syntax fragments may be reused as is. For instance, the syntactic constructs of a simple action language (e.g. with expressions, object manipulation, basic I/O) may be shared by any language encompassing the expression of queries or actions. This first scenario of language assembly thus consists in importing a fragment of abstract syntax from another language to reuse its definition.</p><p>In such a case, the language resulting from the merge of the receiving language and the merged abstract syntax must incorporate all the concepts of both, while preserving the semantics of the receiving language. Also, its model type must be updated accordingly to incorporate the new syntactic constructs. Hence, we specify the merging of an abstract syntax into a language, denoted m ← -, as follows:</p><formula xml:id="formula_5">L m ← -AS = AS • AS , Sem, M T • AS</formula><p>In most cases, the resulting model type M T = M T • AS is a subtype of both AS and M T since it incorporates the features of both. It is however worth noting that new elements introduced in a model type with the • operator may break the compatibility with the super model type in some cases (e.g. the introduction of a new mandatory feature <ref type="bibr" target="#b17">[18]</ref>).</p><p>In the former case, when the compatibility can be ensured through subtyping, tooling defined over AS and/or L (e.g. transformations, checkers) can be reused as is on the resulting language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Semantics Weaving</head><p>Another scenario of language assembly consists in importing predefined semantics elements in a language. When different languages share some close abstract syntax, such as different flavors of an action language, their semantics are likely to be similar, at least for the common subparts (e.g. the semantics of integer addition is likely to remain unchanged). When the case arises, one would like to import the semantics definition of addition from one action language to another. We denote w ←the semantics weaving operator, which consists in weaving a semantics Sem on a language L. In such a case, the two semantics are merged and the exact type of L is updated to incorporate the syntactic signature of the new semantics:</p><formula xml:id="formula_6">L w ← -Sem = AS, Sem • Sem , M T • sig(Sem )</formula><p>Following the previous definitions, this operator can be successfully applied only if there is a matching meta-class in AS for each aspect in Sem . Since the two semantics are concatenated, Sem may override any previous definition of Sem, meaning that the semantics merge operator may be employed either to augment or to override part of the semantics of the receiving language L. The semantics weaving operator is thus particularly relevant for incrementally implementing semantic variation points <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Operators for Language Customization</head><p>In the previous subsection, we specified how the syntax merging and semantics weaving operators help to build new languages by assembling predefined fragments of abstract syntax and semantics. However, although the reuse of language artifacts significantly decreases the development costs, the resulting languages may not fit exactly the language designer's expectations. Thus, we introduce in this section an algebra for language customization. Customization may include specialization of the abstract syntax or semantics of a language for a given context, restriction to a subset of its scope or composition with (possibly part of) other language definitions. In a recent paper, Erdweg et al. propose a taxonomy of different composition operators between languages, including language extension, restriction, and unification <ref type="bibr" target="#b10">[11]</ref>. The operators of our algebra closely match their taxonomy: the inheritance operator is similar to language extension, the slicing operator is similar to language restriction, and the merging operator is similar to language unification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Language Merging</head><p>Situations arise where two independent languages must be composed to form a more powerful one. For instance, a finite-state machine language may be defined as a basic language of states and labeled transitions combined to an action language for expressing complex guards and actions. The resulting language may in turn be merged with a language for expressing classifiers where the state machines would describe their behavior. To support this kind of scenario, we introduce the language merging operator, denoted . The output of this operator is a new language that incorporates both the syntactic and semantic definitions of its two operands. In this case, the receiving language is augmented with the merged language to produce the resulting language. Since the merged language can override part of the semantics of the receiving language, order matters and commutativity can not be ensured.</p><formula xml:id="formula_7">L L = AS • AS , Sem • Sem , M T • M T</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Language Inheritance</head><p>In essence, the language inheritance operator is similar to the language merging operator, as both aims to combine the definitions of two languages. The language inheritance operator, denoted ⊕, differs from the language merging operator in that it does not consider the two languages on equal terms: a sub-language inherits from a super-language. Moreover, the language inheritance operator ensures that the sub-language remains compatible with its super-language. Whatever the subsequent operators applied to the sub-language, it must remain compatible with the super-language, otherwise an error is reported. Concretely, it means that the exact model type of the sub-language must remain a subtype of the exact model type of the super-language: the M T &lt;:M T property is conservative, meaning that any operators apply on L must not violate it. In a sense, the language inheritance operator supports a form of language design-by-contract, as the language designer is assured that tools defined over L will be reused untouched on L.</p><formula xml:id="formula_8">L ⊕ L = AS • AS , Sem • Sem, M T where M T = M T • M T and M T &lt;:M T</formula><p>Note that in this case, the semantics Sem and Sem are concatenated in reverse order Sem •Sem. The sub-language first inherits the abstract syntax and semantics of its superlanguage, and may then override part of the inherited artifacts to refine its definition further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Language Slicing</head><p>Model slicing <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b40">41]</ref> is a model comprehension technique inspired by program slicing <ref type="bibr" target="#b47">[48]</ref>. The process of model slicing involves extracting from an input model a subset of model elements that represent a model slice. Slicing criteria are model elements from the input model that provide entry points for producing a model slice. The slicing process starts by slicing the input model from model elements given as input (the slicing criteria). Then, each model element linked (e.g. by inheritance or reference) to a slicing criterion is sliced, and so on until no more model elements can be sliced. For instance, model slicing can be used to extract the static metamodel footprint M M of a model operation defined over a metamodel M M , i.e. extracting the elements of M M used by the operation <ref type="bibr" target="#b21">[22]</ref>. Model slicing can be positive or negative. Positive model slicing consists of slicing models according to structural criteria. These criteria are the required model elements from which the slice is built. For instance, based on the simple metamodels of Figure <ref type="figure" target="#fig_3">3</ref>, one may want to slice the M M 1 metamodel using as slicing criterion the reference a of the class A. This slicing consists of statically extracting all the elements of M M 1 in relation with a (a included). The result of this slicing is depicted by Figure <ref type="figure" target="#fig_4">4a</ref>: the class A that contains a is sliced; the super class of A (F ) is sliced; the A's references with a lower cardinality greater than 0 are sliced (only the mandatory references and attributes are sliced); the target classes of these references (e.g. D) are sliced. This slicing process continues recursively until no more elements can be sliced. We extended the model slicing principles proposed by Blouin et al. <ref type="bibr" target="#b2">[3]</ref> to support For instance, a negative slicing of M M 1 with the class D as slicing criterion produces the slice depicted by Figure <ref type="figure" target="#fig_4">4b</ref>: a clone, that will be the output slice, of M M 1 is created;</p><p>The class D is removed from this clone; all the classes that have a mandatory reference to D are removed (class A); subclasses of the removed classes are also removed (classes B and C). This slicing process continues recursively until no more elements can be removed.</p><p>Model slicing can be used to perform language restriction. For instance, a language designer may want to shrink a legacy metamodel to its sub-set used by a set of model operations of interest <ref type="bibr" target="#b21">[22]</ref>. This consists of a positive slicing from a set of operations. A language designer may also want to restrict the features of a language (e.g. removing specific features of a programming language) for education purposes or to reduce its expressiveness <ref type="bibr" target="#b10">[11]</ref>. This consists of a negative slicing from unwanted elements.</p><p>In the context of language engineering, we leverage the slicing operation to permit language designer to slice a language according to some slicing criteria, as formalized as follows. Given a language L 1 (AS 1 , Sem 1 , M T 1 ). Slicing L 1 using slicing criteria c consists of slicing positively or negatively (resp. denoted Λ + and Λ -, or Λ + -when considering both operators) its abstract syntax AS 1 using c to produce a new abstract syntax AS 2 , such that AS 2 ⊆ AS 1 . Then, the aspects A t i , that compose Sem 1 , that only refer to elements defined in AS 2 are extracted to form Sem 2 , as formalized as follows:</p><formula xml:id="formula_9">Λ + -(L 1 , c) = AS 2 , Sem 2 , M T 2</formula><p>, where:</p><formula xml:id="formula_10">AS 2 λ + -(AS 1 , c), AS 2 ⊆ AS 1 , Sem 2 A t i ∈ Sem 1 , f p(A t i , AS 1 ) ⊆ AS 2 , M T 1 &lt;:M T 2 ,</formula><p>The footprint operation (denoted f p) extracts the metamodel elements of AS 1 used in the aspects a. The choice of applying a positive (Λ+) or negative (Λ-) slicing is made by the language designer during the language design according to her requirements. The abstract syntax slicing operation <ref type="bibr" target="#b2">[3]</ref> (denoted λ + , λ -, or λ + -) slices a given abstract syntax AS 1 according to slicing criteria c to produce an output abstract syntax AS 2 . Because of the strict slicing that extracts metamodel elements by assuring the conformance, the model type M T 1 is a sub-type of the output M T 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Melange: A Meta-Language for DSL Assembly and Customization</head><p>Melange <ref type="foot" target="#foot_0">1</ref> is an open-source meta-language and framework for DSL engineering. Instead of providing its own dedicated meta-languages for the specification of each part of a DSL (abstract syntax, type system, semantics, etc.), Melange relies on other independently-developed components to provide such features. The abstract syntax of DSLs is specified using the Ecore implementation of the EMOF standard provided by the Eclipse Modeling Framework (EMF) <ref type="foot" target="#foot_1">2</ref> . The choice of Ecore is motivated by the success of EMF both in the industry and academic areas. This allows Melange to possibly integrate a wide range of existing DSLs: over 300 Ecore metamodels exists in the "metamodel zoo" <ref type="bibr" target="#b34">[35]</ref>, over 9000 on Github. For semantics specification, Melange relies on the Xtend programming language <ref type="foot" target="#foot_2">3</ref> to express operational semantics with the definition of aspects. The algebra introduced in Section 3 has been implemented within Melange, providing features for assembly and customization of legacy DSLs artifacts. Overall, Melange is tightly integrated with the EMF ecosystem. Newly built DSLs can thus benefit from other EMF-based components such as Xtext <ref type="bibr" target="#b13">[14]</ref> for defining their textual syntax or Sirius <ref type="foot" target="#foot_3">4</ref> for their graphical representation.</p><p>Melange is bundled as a set of Eclipse plug-ins.</p><p>In this section, we present the Melange meta-language through its abstract syntax (Section 4.1), concrete syntax (Section 4.2), implementation choices (Section 4.3) and integration with the EMF ecosystem (Section 4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Abstract Syntax</head><p>The abstract syntax of Melange (the metamodel depicted in Figure <ref type="figure" target="#fig_5">5</ref>) includes the concepts and relations discussed in Section 2. This abstract syntax is supplemented with static semantics rules expressed as OCL constraints not presented here for the sake of conciseness. LanguagesSpec, the root of Melange's abstract syntax, defines a meta-program that (i) specifies an assembly of DSLs (ii) delimits the scope for the inference and checking of model typing relations.</p><p>A Language is defined by its Metamodel and its associated Semantics. A Metamodel is composed of a set of Classes. A Semantics consists of a set of Aspects used to weave behavior into its meta-classes. This mechanism relies on  <ref type="bibr" target="#b23">[24]</ref>. As specified in Section 3, both assembly and customization operators can be applied on languages. The MergeSyn operator is used to import and merge a metamodel into a given language, whereas the Weaving operator is used to weave a given aspect on the abstract syntax of a language. For the customization part, a language can inherit (Inheritance operator) from a "super" language. The MergeLge operator allows language designers to merge one language into another one. Finally, the Slicing operator permits to slice a language given a specific slicing criterion.</p><p>A ModelType defines an interface to manipulate models. It consists of a set of ObjectTypes, thereby defining a group of interrelated types. Model types can be created from scratch, or automatically inferred from a concrete language. In the latter case, the language explicitly references this new model type as its exactT ype. Model types are linked one another by subtyping relations: if M T is a subtype of M T , then there is one and only one Subtyping instance that references M T as its subType and M T as its superType.</p><p>A Transformation defines a model transformation that takes Elements as input and may produce an Element as output. This means that transformations can operate on Metamodels, ModelTypes, or Transformations themselves.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Concrete Syntax</head><p>Melange provides a textual editor that allows designers to import, manipulate, and reason about DSLs. For the sake of conciseness, we do not detail the whole grammar of the concrete syntax of Melange. Instead, we illustrate its typical use through the mere examples introduced in Section 3 to illustrate the proposed language operators. In a single Melange file, multiple languages can be designed. For instance, the L1 and L2 languages are designed by importing respectively the MM1.ecore and MM2.ecore metamodels (Lines 1 to 6). The L3 language (Lines 7 to 9) is equivalent to the merging result depicted by Figure <ref type="figure" target="#fig_3">3c</ref>. L3 inherits from L1, i.e. L3 reuses the abstract syntax MM1.ecore. This abstract syntax is then merged with the L2 language to form L3 (Line 8). The L4 language (Lines 10 to 12) is designed by performing a positive slicing on the L1 using as input the reference a of the class A. Similarly, L5 is designed (Lines 13 to 15) by performing a negative slicing on L1 using as input the class D. Finally, L6 (Lines 16 to 18) inherits from L5. The aspect ExecuteAspect is then woven into L6. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Implementation Choices</head><p>The algebra introduced in Section 3 can be implemented in various ways. We report here on additional choices we made in its concrete implementation within Melange. The algebra does not require a particular formalism for expressing metamodels. In our implementation, we rely on the Ecore implementation of the EMOF standard provided by EMF to specify the abstract syntax of DSLs. Different operators for metamodel merging have been proposed in the literature (e.g. <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b27">28]</ref>). Interestingly, the UML2.0 specification introduces the notion of PackageMerge that specifies "how the contents of one package are extended by the contents of another package" <ref type="bibr" target="#b36">[37]</ref>. Informally, the UML specification states that "a resulting element will not be any less capable than it was prior to the merge". Matching of elements of both sides mostly occurs based on name equality. When a match is found between two elements, the resulting package incorporates both sides of its definition. We choose to use a slightly improved version of the PackageMerge operator as defined in the UML specification and refined by Dingel et al. <ref type="bibr" target="#b8">[9]</ref>. To meet our requirements, we adapt the PackageMerge operator by trading its UML specificities with EMOF specificities, while preserving its general spirit. For example, we do not consider the concept of Profile and adapt the concept of UML Association to the concept of EMOF Reference. The Pack-ageMerge operator specifies a set of constraints that must be ensured for the merge to succeed. If one of the constraints is violated, the merge is ill-formed and an error is reported. It follows that operators of the algebra that relies on the abstract syntax merging operator share the same property: if the constraints are violated the operation is invalid and an error is reported to the user, otherwise the result is guaranteed to be well-formed. On the semantics part, we choose to use the Xtend programming language supplemented with annotations we developed to specify the operational semantics of DSLs through the definition of aspects. Xtend compiles directly to Java code, providing a seamless integration with other artifacts generated using the EMF framework. A simple example of aspect used to weave executability in the State meta-class of a FSM language is given in Listing 2. The _self variable refers to the element on which the aspect is ultimately woven (a State object in this case) and allows the aspect to access all its features (outgoingTransitions in this case). Here, the ExecutableState aspect inserts a step method in the State meta-class to fire the appropriate transition given an input character c. Note that aspects may also declare new attributes that are introduced in the target meta-classes. The @Aspect annotation specifies the pointcut of the aspect, while the rest of the class definition defines its advice (new methods and attributes to be inserted). Since pointcuts and advices are not clearly separated, the process of rebinding a set of aspects to a new abstract syntax consists in copying the aspects while updating their pointcuts to target the appropriate concepts of the new abstract syntax.</p><p>We also made the following choices in the priorities given to each operator. The inheritance operator has the highest priority, followed by the merge and slice operator (in order of appearance), ending with the aspect weaving operator. First, languages may inherit part of their definition from a superlanguage. As a consequence, the type system ensures that the sub-typing relation between the two languages is kept, otherwise an error is reported. Then, other artifacts may be assembled, merged or sliced on top of the inherited definition. Finally, aspect weaving comes last to support both the redefinition of imported parts and the addition of "glue code" to make the different parts fit together. As an example, when two merged languages exhibit no common subparts, a new aspect can be woven to connect them in a meaningful way by adding structural references between their abstract syntax, or by inserting some additional code to make their respective interpreters cooperate, e.g. through context translation. Finally, for each language declaration, Melange infers its corresponding exact model type. The embedded model-oriented type system automatically infers the subtyping hierarchy through structural typing. This hierarchy is used to ensure the subtyping relation when inheritance is involved and is displayed to the user in a dedicated Eclipse view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Compilation Scheme and Integration with EMF</head><p>From a Melange program, such as the one depicted in Listing 1, the Melange compiler first reads and imports the external definitions and assembles them according to the rules of the algebra. Once the new DSLs are assembled, customization operators are applied. Then, the compiler completes the resulting model by inferring the subtyping hierarchy among the model types inferred for each language. The implementation relations between metamodels and model types are also inferred in this phase, leading to a complete Melange model conforming to the metamodel of Figure <ref type="figure" target="#fig_5">5</ref>. Then, it generates a set of artifacts for each declared language: (i) an Ecore file describing its abstract syntax (ii) a set of aspects describing its semantics attached to the concepts of its abstract syntax (iii) an Ecore file describing its exact model type and (iv) an Eclipse plug-in that can be deployed as is in a new Eclipse instance to support the creation and manipulation of models conforming to it. To generate the runtime code for the new artifacts, Melange relies on the EMF compiler (a genmodel generating Java code from an Ecore file), and the Xtend compiler (generating Java code from the aspects file). For each language definition, the Java code generated by both compilers is associated to a plug-in. Since Melange reuse the formalism for language definition of EMF, along with its compilation chain, it is fully interoperable with the EMF ecosystem. Newly created DSLs may thus benefit from other tools of the EMF ecosystem such as Xtext for the definition of a textual editor or Sirius for a graphical representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Case Study</head><p>In this section, we illustrate how the proposed algebra implemented within Melange can be used by language designers to assemble legacy DSLs. We then discuss the results, the integration of the proposed operators in an existing language workbench, and the development overhead. All the materials of the case study are available on the companion webpage<ref type="foot" target="#foot_4">5</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Language Requirements</head><p>To illustrate Melange, we design an executable modeling language for the Internet of Things (IoT) domain, i.e. for embedded and distributed systems. This language is inspired by general-purpose executable modeling languages (e.g. Executable UML <ref type="bibr" target="#b31">[32]</ref> or fUML <ref type="bibr" target="#b39">[40]</ref>) and IoT modeling languages (e.g. ThingML <ref type="bibr" target="#b14">[15]</ref>). This language enables the modeling of the behavior of communicating sensors built on top of resource-constrained embedded systems, such as low-power sensor and micro-controller devices (Arduino 6 , Raspberry Pi 7 , etc.). Such a language aims at providing appropriate abstractions and dedicated simulators, interpreters, or compilers depending on the targeted platforms. To illustrate the ben-efits of Melange, the resulting language will be built as an assembly of other popular languages. We consider the three following requirements while designing this language:</p><p>i) The language has to provide an IDL (Interface Definition Language) to model the sensor interfaces in terms of provided services. Examples of popular languages that provide the appropriate abstractions include the class diagram of (f)UML, the SysML block definition diagram <ref type="bibr" target="#b15">[16]</ref>, or MOF, as they all provide an OO interface definition language.</p><p>ii) The language must support the modeling of concurrent sensor activities. Various languages may be employed to model this concern. For instance, process modeling languages such as the (f)UML/SysML activity diagram or BPEL/BPMN are good candidates.</p><p>iii) The primitive actions that can be invoked within the activities must be expressed with a popular language IoT developers are familiar with. Such a language can be shared by the community and embedded on a set of devices used in the IoT domain. Even though the C language is the common base language of most embedded platforms, its lack of abstraction hinders its exploitation in a modeling environment. Instead, we choose the Lua language 8 . Lua is a dynamicallytyped language commonly used as an extension or scripting language. Lua is notably popular in the IoT domain since it is compact enough to fit on a variety of host platforms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Language Design using Melange</head><p>With the aim of validating Melange, the experimental protocol consists in selecting three publicly-available implementations of existing EMF-based languages to support these three requirements. For the structural part, we use the Ecore language itself as an implementation of EMOF. EMOF provides structural modeling capabilities similar to the UML class diagram. For the activity modeling part, we reuse materials from the Model Execution Case of the TTC'15 tool contest 9 . The case foresees the specification of the operational semantics of a subset of the UML activity diagram language with transformation languages. For the action language part, we reuse an existing implementation of the Lua language developed using Xtext. We provide an operational semantics of the Lua language using Xtend and a set of active annotations.</p><p>The new language has to provide three perspectives: i) Capturing the services offered by IoT devices, ii) Defining the behavior of these services through a model of an internal process describing the workflow of activities, and iii) Modeling activity implementations. Each activity can execute an action defined using the Lua language. This action language is extended to integrate a new primitive to send messages containing data. These messages are used to invoke services on other devices. The resulting language is built using the Melange assembly definition depicted in Listing 3. The definition is decomposed in multiple languages to ease the de- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The new language</head><p>LuaExtensionLang is designed to supplement Lua with message sending capabilities to support synchronization between several complex objects (Lines 33 to 36).</p><p>6. A new language FinalLang, which inherits from Activi-tyELuaLang, is then created (Lines 38 to 41). ActivityELu-aLang is merged with the LuaExtensionLang and provides a specific glue linking the ActivityELuaLang semantics with the LuaExtension semantics.</p><p>Besides, each language is implicitly associated with its automatically-inferred exact model type. The type checking algorithm of Melange can thus infer the subtyping hierarchy among the different languages. For instance, in this case, the resulting FinalLang language subtypes all the other languages because it incorporates all their features <ref type="bibr" target="#b17">[18]</ref>. Consequently, tools and transformation defined on e.g. the Ecore language can be reused to manipulate models created with the FinalLang language. In the end, we obtain a new executable modeling language for IoT resulting from the composition of three legacy languages for which reuse was unforeseen. Additionally, most of the previously defined tools can be reused as is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Discussion</head><p>A critical point concerns the ability of Melange to be integrated into an existing ecosystem. The integration using Melange of three existing EMF languages allows a language designer to obtain a new EMF language. If we do not consider the imposed methodology for defining the language semantics (the use of the interpreter pattern <ref type="bibr" target="#b16">[17]</ref>), no modification of these languages was required to support that composition. This illustrates how Melange can be integrated into an existing language workbench without any change in the legacy abstract syntaxes. All the Melange operators are used for this case study. Although this does not guarantee that these operators are sufficient, it highlights that all of them are required when a language designer needs to compose existing languages.</p><p>Another major point is the possible overhead in term of performance and lines of code that stem from the use of Melange. Compared to a top-down approach where the IoT language is built from scratch by an expert in language design, we observe no additional concepts integrated into the abstract syntax definition. At the semantics level, glue code is injected for the implicit conversion of the interpreter pattern context resulting from the composition of the various contexts stemming from various operational semantics. At runtime, no additional cost in terms of performance were observed to the use of the language resulting from the composition. Table <ref type="table" target="#tab_3">1</ref> sums up the results. Performance comparison is obtained by loading and executing a model with 10 objects that contains one operation with a workflow with 1000 basic actions that do mainly 10 numeric operations. The comparison was done on the same laptop designed with an Intel i7 with 16Gb of memory, a Linux 64bit operating system and an Oracle Java 8 virtual machine.</p><p>Nevertheless, these results may be moderated by the following threats to validity. First, all the languages must be designed in the same technical ecosystem. Melange does not provide any support for integrating heterogeneous languages in terms of technical ecosystem. Second, Melange can not compose any language semantics. The composition can be done if and only if the semantics is operational and defined following the interpreter pattern (e.g. through static introduction or a visitor). Third, concepts with different names in different languages may represent the same concept. In such a case, adaptation mechanisms are required to align them before composition. Melange provides a simple renaming mechanism that allows to rename concepts, but lacks a powerful mechanism for realizing complex adaptations. Finally, the same person implemented the language using Melange and using a traditional top-down approach. This person is an expert in language design and modeling technologies. Besides, the top-down language design has been reviewed by three experts in language design and is publicly available on the companion webpage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>A DSL allows developing software for a particular application domain quickly and effectively, yielding programs that are easy to understand, reason about, and maintain <ref type="bibr" target="#b20">[21]</ref>. There may be, however, a significant overhead in creating the infrastructure needed to support a DSL. Numerous works proposed to create reusable and composable language units to tackle this issue. Methodologies have been proposed for building DSLs embedded within an existing, higher-order, and typed programming language <ref type="bibr" target="#b19">[20]</ref>. Techniques have been then designed for building modular interpreters and tools for such embedded DSLs. Different techniques have been studied for addressing the challenge of language extension and composition, such as projectional editing <ref type="bibr" target="#b44">[45]</ref>. Spoofax, however, relies on meta-languages for defining syntaxes and semantics, which are inherently modular and composable <ref type="bibr" target="#b46">[47]</ref>. Although basic import mechanisms are supported, they usually lack a powerful support for customization. More recently, an overview of the support provided by language workbenches has been provided <ref type="bibr" target="#b11">[12]</ref>. In the grammar world, several techniques demonstrated the possibility to create language units using attribute grammars <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b38">39]</ref>. MontiCore applied modularity concepts for designing new DSLs by extending an existing one, or by composing other DSLs <ref type="bibr" target="#b28">[29]</ref>. MontiCore reifies as a first-class object the concept of language inheritance to allow language feature reuse. Other works propose to leverage concepts from the component-based software engineering community to modularly develop DSLs <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b49">50]</ref>.</p><p>In the MDE domain, several meta-tooling platforms propose mechanisms for improving language design modularity. <ref type="bibr">Ledeczi et al.</ref> propose to compose domain-specific design environments using MDE technologies <ref type="bibr" target="#b30">[31]</ref>. Melusine <ref type="bibr" target="#b12">[13]</ref>, Xtext <ref type="bibr" target="#b13">[14]</ref>, or MPS <ref type="bibr" target="#b1">[2]</ref> are frameworks supplemented with IDEs for building textual DSLs. In both the MDE and grammar domains, the increasing trend to create new DSLs, from scratch or by adapting existing ones, causes the emergence of families of DSLs. A family of DSLs is a set of DSLs sharing common aspects but specialized for a particular purpose. The emergence of a family of DSLs raises the need to reuse common tools among a given family <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b29">30]</ref> and the need to create language composable units. To ease the language unit composition, Steel et al. <ref type="bibr" target="#b41">[42]</ref> and De Lara et al. <ref type="bibr" target="#b7">[8]</ref> propose to define a clear contract and a typing system that can be used for composing language units. De Lara et al. present the concept mechanism, along with model templates and mixin layers leveraged from generic programming to MDE <ref type="bibr" target="#b6">[7]</ref>. Concepts are close to model types <ref type="bibr" target="#b41">[42]</ref> as they define the requirements a metamodel must fulfill for its models to be processed by a transformation, under the form of a set of classes. Sánchez, Wimmer et al. go further than strict structural mapping by renaming, mapping, and filtering metamodel elements <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b48">49]</ref>. Erdweg et al. proposed a taxonomy to ease the positioning of approach related to language composition <ref type="bibr" target="#b10">[11]</ref>. According to this classification, our algebra supports the language extension, restriction, and unification operators. Additionally, we do not consider that restriction is only a matter of additional validation rules. Instead, we prune the language from the unwanted parts so that only the necessary concepts are kept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion and Future Work</head><p>While current language workbenches provide import mechanisms, they usually lack an explicit support for customization and safe composition of imported artifacts. This paper proposes an approach for building DSLs by safely assembling and customizing legacy DSLs artifacts. We propose different operators for assembling (merge S /weave), restricting (slice), extending (inherits), and merging (merge l ) DSLs. The use of typing and subtyping relations that provides a reasoning layer for DSLs manipulation is also promoted. The approach is implemented in Melange, an EMF-based meta-language. We illustrate and discuss this work by designing a new executable modeling language for IoT showing that: all the proposed operators are relevant for designing a new language based on the composition and the specialization of three legacy DSLs; the use of Melange does not introduce specific technical issue compared to a traditional top-down approach.</p><p>In our future work, we will investigate to what extent Melange can be used to provide agile modeling for DSL users, i.e. the safe reuse of model transformations that can work across several DSLs, and the specification of viewpoints.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: DSLs Assembly and Customization</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Syntax Merging Operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Slice Examples</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Excerpt of the Abstract Syntax of Melange</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1</head><label></label><figDesc>l a n g u a g e L1 { 2 s y n t a x "MM1. e c o r e " 3 } 4 l a n g u a g e L2 { 5 s y n t a x "MM2. e c o r e " 6 } 7 l a n g u a g e L3 i n h e r i t s L1 { 8 merge L2 9 } 10 l a n g u a g e L4 { 11 s l i c e + L1 u s i n g [MM1. A . a ] 12 } 13 l a n g u a g e L5 { 14 s l i c e -L1 u s i n g [MM1. D] 15 } 16 l a n g u a g e L6 i n h e r i t s L5 { 17 w i t h E x e c u t a b l e A s p e c t 18 } Listing 1: Concrete Syntax of Melange</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>ActivitySlice and EcoreLang are merged (Lines 21 to 25). The EOperationAspect then binds EOperation and Activity (Line 24). This step creates a language ActivityEcore-Lang that enables the modeling of objects. Such objects can be for example a temperature sensor in a specific room instance with an operation getTemperature. The implementations of the operations are defined through activity diagram definitions.4. ActivityEcoreLang andLuaLang are then merged to form a new language ActivityELuaLang (Lines 27 to 31). The Expression classes from both languages are linked one another by a new aspect (Line 30).</figDesc><table><row><cell cols="2">1 l a n g u a g e A c t i v i t y L a n g {</cell></row><row><cell>2</cell><cell>s y n t a x " p l a t f o r m : / r e s o u r c e / A c t i v i t y . e c o r e "</cell></row><row><cell>3</cell><cell>w i t h O p e r a t i o n a l S e m a n t i c s A c t i v i t y A s p e c t</cell></row><row><cell>4 }</cell><cell></cell></row><row><cell>5</cell><cell></cell></row><row><cell cols="2">6 l a n g u a g e LuaLang {</cell></row><row><cell>7</cell><cell>s y n t a x " p l a t f o r m : / r e s o u r c e / x t e x t / Lua . e c o r e "</cell></row><row><cell>8</cell><cell>w i t h o r g . k3 . l u a . O p e r a t i o n a l S e m a n t i c s A s p e c t</cell></row><row><cell>9 }</cell><cell></cell></row><row><cell>10</cell><cell></cell></row><row><cell cols="2">11 l a n g u a g e E c o r e L a n g {</cell></row><row><cell>12</cell><cell>s y n t a x " p l a t f o r m : / r e s o u r c e / E c o r e . e c o r e "</cell></row><row><cell>13 }</cell><cell></cell></row><row><cell>14</cell><cell></cell></row><row><cell cols="2">15 l a n g u a g e A c t i v i t y S l i c e {</cell></row><row><cell>16</cell><cell>s l i c e + A c t i v i t y L a n g u s i n g [ ' O p a q u e A c t i o n ' ,</cell></row><row><cell>17</cell><cell>' MergeNode ' , ' D e c i s i o n N o d e ' , ' I n i t i a l N o d e ' ,</cell></row><row><cell>18</cell><cell>' J o i n N o d e ' , ' ForkNode ' , ' A c t i v i t y F i n a l N o d e ' ]</cell></row><row><cell>19 }</cell><cell></cell></row><row><cell>20</cell><cell></cell></row><row><cell cols="2">21 l a n g u a g e A c t i v i t y E c o r e L a n g {</cell></row><row><cell>22</cell><cell>merge A c t i v i t y S l i c e</cell></row><row><cell>23</cell><cell>merge E c o r e L a n g</cell></row><row><cell>24</cell><cell>w i t h f r . i n r i a . d i v e r s e . g l u e . E O p e r a t i o n A s p e c t</cell></row><row><cell>25 }</cell><cell></cell></row><row><cell>26</cell><cell></cell></row><row><cell cols="2">27 l a n g u a g e A c t i v i t y E L u a L a n g {</cell></row><row><cell>28</cell><cell>merge A c t i v i t y E c o r e L a n g</cell></row><row><cell>29</cell><cell>merge LuaLang</cell></row><row><cell>30</cell><cell>w i t h f r . i n r i a . d i v e r s e . g l u e . E x p r e s s i o n A s p e c t</cell></row><row><cell>31 }</cell><cell></cell></row><row><cell>32</cell><cell></cell></row><row><cell cols="2">33 l a n g u a g e L u a E x t e n s i o n L a n g {</cell></row><row><cell>34</cell><cell>s y n t a x " p l a t f o r m : / r e s o u r c e / LuaExt . e c o r e "</cell></row><row><cell>35</cell><cell>w i t h o r g . l u a e x t . O p e r a t i o n a l S e m a n t i c s A s p e c t</cell></row><row><cell>36 }</cell><cell></cell></row><row><cell>37</cell><cell></cell></row><row><cell cols="2">38 l a n g u a g e F i n a l L a n g i n h e r i t s A c t i v i t y E L u a L a n g {</cell></row><row><cell>39</cell><cell>merge L u a E x t e n s i o n L a n g</cell></row><row><cell>40</cell><cell>w i t h f r . i n r i a . d i v e r s e . l u a . E x p r e s s i o n A s p e c t</cell></row><row><cell>41 }</cell><cell></cell></row><row><cell cols="2">Listing 3: Assembling the IoT Language with Melange</cell></row><row><cell cols="2">scription of the process. In a real situation, this definition can</cell></row><row><cell cols="2">be shortened.</cell></row><row><cell cols="2">1. The abstract syntax of the three languages (the activity</cell></row><row><cell cols="2">diagram from TTC15, Lua, and Ecore) are imported into</cell></row><row><cell cols="2">Melange to form languages respectively called Activity-</cell></row><row><cell cols="2">Lang, LuaLang, and EcoreLang (Lines 1 to 13).</cell></row><row><cell cols="2">2. To design the ActivitySlice language, ActivityLang is</cell></row><row><cell cols="2">sliced to preserve only the activity diagram part without</cell></row><row><cell cols="2">the action language concepts (Lines 15 to 19). To do so,</cell></row><row><cell cols="2">we manually identified the classes of interest (Lines 16</cell></row><row><cell cols="2">to 18).</cell></row><row><cell>3.</cell><cell></cell></row><row><cell>8 http://www.lua.org/</cell><cell></cell></row><row><cell>9 http://www.transformation-tool-contest.eu/</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Comparison of Melange and a Top-down Approach for the IoT Language</figDesc><table><row><cell></cell><cell cols="2">Melange Top-down</cell></row><row><cell>Metaclasses (#)</cell><cell>104</cell><cell>104</cell></row><row><cell>LoC for the glue (#)</cell><cell>27</cell><cell>0</cell></row><row><cell>Efficiency (sec)</cell><cell>30,0</cell><cell>25,9</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://melange-lang.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://www.eclipse.org/modeling/emf/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://www.eclipse.org/xtend/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>https://eclipse.org/sirius/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://melange-lang.org/sle15</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>http://www.arduino.cc/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>https://www.raspberrypi.org/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work is partially supported by the ANR INS Project GEMOC (ANR-12-INSE-0011), the ITEA2 Project MERgE, and the French LEOC Project Clarity.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">2.0 core final adopted specification</title>
		<author>
			<persName><surname>Mof</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Language and IDE modularization and composition with MPS</title>
	</analytic>
	<monogr>
		<title level="m">Proc. of GTTSE&apos;13</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Lämmel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Saraiva</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</editor>
		<meeting>of GTTSE&apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="383" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Blouin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Combemale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Baudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Beaudoux</surname></persName>
		</author>
		<title level="m">Kompren: Modeling and generating model slicers. Software and Systems Modeling (SoSyM)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Code generation from UML models with semantic variation points</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chauvel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Driven Engineering Languages and Systems</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="54" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Essay on semantics definition in MDE-an instrumented approach for model verification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Combemale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Crégut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Garoche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Thirioux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Sw</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="943" to="958" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">UML vs. classical vs. Rhapsody statecharts: Not all models are created equal</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Crane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dingel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Driven Engineering Languages and Systems</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="97" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generic meta-modelling with concepts, templates and mixin layers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">De</forename><surname>Lara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Guerra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MODELS&apos;10</title>
		<meeting>of MODELS&apos;10</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Abstracting modelling languages: A reutilization approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Guerra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sánchez-Cuadrado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Information Systems Engineering</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="127" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Understanding and improving UML package merge</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dingel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Diskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SoSym</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="443" to="467" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Techniques for metamodel composition</title>
		<author>
			<persName><forename type="first">M</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sztipanovits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA Workshop on Domain Specific Modeling</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="123" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Language composition untangled</title>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Giarrusso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rendel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Workshop on Language Descriptions, Tools, and Applications</title>
		<meeting>of the Workshop on Language Descriptions, Tools, and Applications</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The state of the art in language workbenches</title>
		<author>
			<persName><forename type="first">S</forename><surname>Erdweg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Van Der Storm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Völter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Boersma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bosman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gerritsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hulshout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Loh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software language engineering</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="197" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Composing domainspecific languages for wide-scope software engineering applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Estublier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ionita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MODELS&apos;05</title>
		<meeting>of MODELS&apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="69" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Xtext: Implement your language faster than the quick and dirty way</title>
		<author>
			<persName><forename type="first">M</forename><surname>Eysholdt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Behrens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of OOPSLA &apos;10 Companion</title>
		<meeting>of OOPSLA &apos;10 Companion</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="307" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">MDE to manage communications with and between resource-constrained systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Fleurey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Morin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Barais</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MODELS&apos;11</title>
		<meeting>of MODELS&apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="349" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Friedenthal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Steiner</surname></persName>
		</author>
		<title level="m">A practical guide to SysML: the systems modeling language</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Design Patterns: Elements of Reusable Object-Oriented Software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Addison-Wesley Professional</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On model subtyping</title>
		<author>
			<persName><forename type="first">C</forename><surname>Guy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Combemale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Derrien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Steel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modelling Foundations and Applications</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="400" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The syntax definition formalism sdf-reference manual</title>
		<author>
			<persName><forename type="first">J</forename><surname>Heering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R H</forename><surname>Hendriks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rekers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="43" to="75" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Modular domain specific languages and tools</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fifth International Conference on Software Reuse</title>
		<meeting>Fifth International Conference on Software Reuse</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="134" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Empirical assessment of MDE in industry</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hutchinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whittle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rouncefield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kristoffersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICSE&apos;11</title>
		<meeting>of ICSE&apos;11</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="471" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Estimating footprints of model operations</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jeanneret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Glinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Baudry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICSE&apos;11</title>
		<meeting>of ICSE&apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Model driven design and aspect weaving</title>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software &amp; Systems Modeling</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="218" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Combemale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Barais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fouquet</surname></persName>
		</author>
		<title level="m">Mashup of metalanguages and its implementation in the kermeta language workbench. Software &amp; Systems Modeling</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Modularity and reusability in attribute grammars</title>
		<author>
			<persName><forename type="first">U</forename><surname>Kastens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Waite</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="601" to="627" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The spoofax language workbench: rules for declarative specification of languages and IDEs</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Kats</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM sigplan notices</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="444" to="463" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A research roadmap towards achieving scalability in model driven engineering</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Matragkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BigMDE&apos;13</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Merging models with the epsilon merging language (EML)</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Kolovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Polack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model driven engineering languages and systems</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="215" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Monticore: a framework for compositional development of domain specific languages</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rumpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Völkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JSTT</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="353" to="372" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Kusel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schönböck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kappel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Retschitzegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schwinger</surname></persName>
		</author>
		<title level="m">Reuse in model-to-model transformation languages: are we there yet? SoSyM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Composing domain-specific design environments</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ledeczi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bakay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maroti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Volgyesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nordstrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sprinkle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="44" to="51" />
			<date type="published" when="2001-11">Nov 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Mellor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Balcer</surname></persName>
		</author>
		<title level="m">Executable UML: A Foundation for Model-Driven Architectures</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">An object-oriented approach to language compositions for software language engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mernik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2451" to="2464" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Reusability of formal specifications in programming language description</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mernik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Zumer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Annual Workshop on Software Reuse</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Metamodel</forename><surname>Zoos</surname></persName>
		</author>
		<ptr target="http://www.emn.fr/z-info/atlanmod/index.php/Zoos" />
		<imprint>
			<date type="published" when="2015-04">april 2015</date>
		</imprint>
	</monogr>
	<note>last access</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The varieties of programming language semantics and their uses</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mosses</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Perspectives of System Informatics</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="165" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Unified Modeling Language 2.0, Infrastructure. OMG</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Generic model transformations: Write once, reuse everywhere</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sánchez Cuadrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Guerra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Lara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICMT&apos;11</title>
		<meeting>of ICMT&apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="62" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Component-based programming for higher-order attribute grammars</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Saraiva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of GPCE</title>
		<meeting>of GPCE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="268" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">UML with meaning: Executable modeling in foundational UML and the Alf action language</title>
		<author>
			<persName><forename type="first">E</forename><surname>Seidewitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ada Lett</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="61" to="68" />
			<date type="published" when="2014-10">Oct. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Meta-model Pruning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Moha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Baudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MODELS&apos;09</title>
		<meeting>of MODELS&apos;09</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On model typing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Steel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Jézéquel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SoSyM</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="401" to="413" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Neverlang: A framework for featureoriented language development</title>
		<author>
			<persName><forename type="first">E</forename><surname>Vacchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cazzola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Languages, Systems &amp; Structures</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A language designer&apos;s workbench: A one-stop-shop for implementation and verification of language designs</title>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wachsmuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tolmach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Neron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vergu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Passalaqua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Konat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPLASH</title>
		<meeting>SPLASH</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="95" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Language and IDE modularization, extension and composition with MPS</title>
		<author>
			<persName><forename type="first">M</forename><surname>Voelter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Generative and Transformational Techniques in Software Engineering</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Voelter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kolb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</author>
		<title level="m">Projecting a modular future</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Language extension and composition with language workbenches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Völter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the OOPSLA companion</title>
		<meeting>of the OOPSLA companion</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="301" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Program slicing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th international conference on Software engineering</title>
		<meeting>the 5th international conference on Software engineering</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="439" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Reusing model transformations across heterogeneous metamodels</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kusel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Retschitzegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schönböck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schwinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cuadrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Guerra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Lara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MPM&apos;11</title>
		<meeting>of MPM&apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Towards metamodelling-inthe-large: Interface-based composition for modular metamodel development</title>
		<author>
			<persName><forename type="first">S</forename><surname>Živković</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karagiannis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Enterprise, Business-Process and Information Systems Modeling</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="413" to="428" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
