<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Novel Register Renaming Technique for Out-of-Order Processors</title>
				<funder ref="#_eEnVp2u">
					<orgName type="full">unknown</orgName>
				</funder>
				<funder ref="#_q5jDU4P">
					<orgName type="full">Spanish State Research Agency</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hamid</forename><surname>Tabani</surname></persName>
							<email>htabani@ac.upc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Architecture</orgName>
								<orgName type="institution">Universitat Polit?cnica de Catalunya</orgName>
								<address>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jose-Maria</forename><surname>Arnau</surname></persName>
							<email>jarnau@ac.upc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Architecture</orgName>
								<orgName type="institution">Universitat Polit?cnica de Catalunya</orgName>
								<address>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jordi</forename><surname>Tubella</surname></persName>
							<email>jordit@ac.upc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Architecture</orgName>
								<orgName type="institution">Universitat Polit?cnica de Catalunya</orgName>
								<address>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Gonz?lez</surname></persName>
							<email>antonio@ac.upc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Architecture</orgName>
								<orgName type="institution">Universitat Polit?cnica de Catalunya</orgName>
								<address>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Novel Register Renaming Technique for Out-of-Order Processors</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/HPCA.2018.00031</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:00+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Register Renaming</term>
					<term>Register File</term>
					<term>Precise Exceptions</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Modern superscalar processors support a large number of in-flight instructions, which requires sizeable register files. Conventional register renaming techniques allocate a new storage location, i.e. physical register, for every instruction whose destination is a logical register in order to remove false dependences. Physical registers are released in a conservative manner when the same logical register is redefined. For this reason, many cycles may happen between the last read and the release of a physical register, leading to suboptimal utilization of the register file.</p><p>We have observed that for more than 50% of the instructions in SPECfp and more than 30% of the instructions in SPECint that have a destination register, the produced value has only a single consumer. In this case, the RAW dependence guarantees that the producer-consumer instructions pair will be executed in program order and, hence, the same physical register can be used to store the value produced by both instructions.</p><p>In this paper, we propose a renaming technique that exploits this property to reduce the pressure on the register file. Our technique leverages physical register sharing by introducing minor changes in the register map table and the issue queue. We also describe how our renaming scheme supports precise exceptions. We evaluated our renaming technique on top of a modern out-of-order processor. Our experimental results show that it provides 6% speedup on average for the SPEC2006 benchmarks. Alternatively, our renaming scheme achieves the same performance while reducing the number of physical registers by 10.5%.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Dynamically-scheduled superscalar processors exploit instruction-level parallelism (ILP) by reordering and overlapping the execution of instructions in an instruction window. The number of instructions that can be executed in parallel is highly dependent on the instruction window size and, thus, wide issue processors require a large instruction window <ref type="bibr" target="#b0">[1]</ref>. However, a large instruction window has some implications in other critical parts of the microarchitecture, such as the size of the physical register file <ref type="bibr" target="#b1">[2]</ref>. In this work, we are concerned with this issue. On the other hand, in spite of being able to execute instructions out-of-order, the amount of ILP that current superscalar processors can exploit is significantly restricted by data dependences. Due to the limited number of architectural registers, at some We distinguish between instructions that redefine the singleuse register and instructions that redefine a different logical register.</p><p>point compilers start reusing them, which may cause name dependences (write-after-read and write-after-write dependences). Dynamic renaming schemes eliminate these name dependences by assigning a new storage location to the destination register of each instruction. This increases the amount of independent instructions that can be executed in parallel, which results in an increase in the ILP.</p><p>Larger instruction windows require a higher number of physical registers. However, increasing the size of the register file is challenging and has important implications in terms of energy consumption, access time and area <ref type="bibr" target="#b1">[2]</ref>.</p><p>This work is motivated by the observation that, in a significant percentage of instructions with a destination register, this register has a single consumer. Figure <ref type="figure" target="#fig_0">1</ref> shows that more than 50% of the instructions in SPECfp and more than 30% in SPECint exhibit this property. In this case, the RAW dependence between producer and consumer will force sequential execution of the two instructions. In addition, since there is only a single consumer then no other instruction will require the value produced by the first instruction. Therefore, producer and consumer can safely use the same physical register as their destination.</p><p>In this paper, we propose a register renaming scheme that implements this reuse of registers in dynamically scheduled processors that implement precise exceptions. We show that identifying single-use registers can be accomplished with simple hardware. To this end, the register map table is extended with one bit per entry indicating whether this register has seen at least one consumer. An instruction that finds a source operand with this bit clear is the first consumer of the value and, hence, there are no older consumers. To detect the absence of younger consumers, two possible cases arise. The simplest case happens when the consumer is also the redefining instruction of the single-use register, in which case it is guaranteed that there are no younger consumers. Note that this is the case for a significant percentage of the instructions, as shown in Figure <ref type="figure" target="#fig_0">1</ref>. In case the consumer is not the redefining instruction, a single-use predictor is employed to speculatively reuse the physical register. We show in Section VI that a simple predictor is able to achieve very high accuracy for SPEC benchmarks.</p><p>To be able to recover the state of the processor in a branch misprediction, interrupt or exception, we propose to use a multi-bank register file with check-pointed register banks using shadow cells <ref type="bibr" target="#b2">[3]</ref>. Check-pointed registers are allocated whenever it is predicted that a register might be reused. Hence, the former value of a register can be recovered in an event of branch misprediction, interrupt or exception. The proposed register renaming scheme does not require any ISA changes nor compiler support.</p><p>In short, the main contributions of this paper are the following:</p><p>? We present an analysis of benchmarks that shows a high opportunity to reuse physical registers, by exploiting the large percentage of single-use values. ? We propose a novel register renaming technique that reduces the pressure on the register file by enabling physical register sharing. ? We use a cost-effective register file design with checkpointed and conventional registers to recover the state of the processor in event of branch mispredictions, interrupts or exceptions. ? We show that for SPEC benchmarks, the proposed register renaming scheme results in 6% speedup for a given register file size, or 10.5% reduction in register file size for the same performance.</p><p>The remainder of the paper is organized as follows. Section II reviews the traditional register renaming techniques. Section III presents the motivation for this work. Section IV describes our register renaming scheme. Section V presents our evaluation methodology, and the experimental results are provided in Section VI. Section VII reviews some related works. Finally, Section VIII summarizes the main conclusions of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. REGISTER RENAMING</head><p>Register renaming is key for the performance of out-oforder processors. Instructions, after being decoded, are kept in the reorder buffer until they commit. The size of the reorder buffer determines the maximum number of in-flight instructions. These instructions are usually called instruction window.</p><p>The goal of renaming is to remove register name dependences, write-after-read and write-after-write dependences for the instructions in the instruction window. This is achieved by allocating a free storage location for the destination register of every new decoded instruction. The most common solution to provide the storage locations is a merged register file <ref type="bibr" target="#b3">[4]</ref>. In this case, there is a physical register file that contains more registers than those defined in the ISA, which are referred to as logical registers. A register map table is used to manage the translations from logical to physical identifiers. When an instruction commits, the physical register allocated by the previous instruction with the same logical destination register is freed. This has become the adopted approach of practically all current microprocessors, due to its energy efficiency, and is the baseline technique assumed in this work. Other schemes such as renaming through the reorder buffer <ref type="bibr" target="#b4">[5]</ref> are much less commonly used nowadays, since they tend to be less energy efficient.</p><p>In the merged register file organization, a number of physical registers close to the number of logical registers plus the window size is required since the majority of the instructions have a destination register. A number of physical registers equal to the number of logical registers is needed to keep the committed state of the processor. In addition, for every instruction whose destination operand is a register, an additional register is allocated when it enters the window at rename stage and a physical register is released when it leaves the window at commit stage.</p><p>Renaming schemes are conservative to guarantee correct execution. In conventional schemes, a physical register is released when the instructions that redefines the corresponding logical register commits. In this manner, it is guaranteed that there is no other potential consumer of this value stored in the physical register being released, since the redefining instruction is no longer speculative. Note that many cycles may happen between the last read of the register and its release, which leads to underutilization of the register file.  This results in an unnecessary increase of the register file pressure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MOTIVATION</head><p>This work is primarily motivated by the observation that, in a significant percentage of instructions, the value stored in a register has only a single consumer (see Figure <ref type="figure" target="#fig_1">2</ref>). In conventional register renaming schemes, the single-consumer instruction allocates a new physical register for the destination register. However, in this case, once the value of the source register is read by the consuming instruction, the same physical location can be used to write the result since no more consumers need the previous content of the register. In other words, the source register can be reused for the destination instead of allocating a new one. As Figure <ref type="figure" target="#fig_0">1</ref> shows, for SPEC2006 benchmarks, this happens for more than 50% and 30% of SPECfp and SPECint instructions respectively. Note that, on average, more than 85% of the instructions require a physical register as a destination. Furthermore, we often find chains of instructions where a given logical register is both the destination operand and a single consumer operand of it. This is the case of instructions I1, I4, I5 and I6 in Figure <ref type="figure">4</ref>. In this case, all the instructions in the chain can share the same physical register as destination, further reducing the pressure on the register file.</p><p>Following this idea of physical register sharing for the instructions in a chain, Figure <ref type="figure">3</ref> shows the percentage of instructions that can avoid allocating a new physical register if each register can be reused up to one, two, three or an unlimited number of times. Note that Figure <ref type="figure">3</ref> only considers instructions with a destination register, i.e. instructions that require an allocation of a physical register at renaming. For this reason, the percentage of One Reuse in Figure <ref type="figure">3</ref> is not equal to the category One use in Figure <ref type="figure" target="#fig_1">2</ref>, as it does not include single-uses performed by stores, comparisons and other instructions without a destination register. However, since the majority of instructions include a destination register, still more than 50% of the instructions in SPECfp and more than 30% of the instructions in SPECint can reuse a physical register multiple times. More specifically, 32.3%, Figure <ref type="figure">3</ref>: Percentage of instructions that can reuse a physical register, if a register can be reused up to one, two, three or an unlimited number of times. Note that we only consider instructions with a destination register.</p><p>12.3% and 5.9% of the instructions in SPECfp can reuse a physical register up to one, two and three times respectively. Two reuses means a chain of three instructions whose only consumer is the next instruction in the chain. Similarly, three reuses means a chain of four instructions sharing the same physical register as destination. On the other hand, only 4.1% of the instructions can reuse a physical register more than three times, i.e. chains of more than four instructions are unusual. Regarding SPECint benchmarks, 22%, 5.2% and 2.3% of the instructions can reuse a physical register up to one, two and three times respectively, while only 1.2% of the instructions can reuse a physical register more than three times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. RENAMING WITH PHYSICAL REGISTER REUSE</head><p>In this section, we present a novel register renaming scheme for out-of-order processors that exploits physical register sharing to reduce the pressure on the register file. First, we illustrate the technique through an example. Second, we provide the implementation details of the technique, describing the changes to the different hardware structures of the processor, such as the register map table or the issue queue. Finally, we extend our renaming scheme to support precise exceptions, describing the required support in the register file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Proposed Register Renaming Technique</head><p>For the sake of clarity, we first explain the proposed register renaming scheme through an example. Figure <ref type="figure">4</ref> presents the assembly code for several instructions of an application. To execute the eight instructions in this example, conventional renaming schemes allocate eight different physical registers, one per instruction, as illustrated in Figure <ref type="figure">4(a)</ref>. The outcome of the register renaming and the step-by-step updates to the register map table are also shown in Figure <ref type="figure">4</ref>(a). As we can see in this example, four different physical registers are employed for the same logical register, r1.</p><p>In this example, instructions I1, I4, I5 and I6 form a chain of read-after-write dependences that guarantees that they will be executed in program order and, therefore, </p><formula xml:id="formula_0">I8: sub r2 ? r5 , r1 dst src1 src2 P1 P2 P3 P5 - - P6 P5 P4 P7 P1 P4 P8 P7 P7 P9 P8 P5 P10 P9 P6 P11 P10 P9 PR r0 - r1 P1 P7 P8 P9 r2 P2 P6 P11 r3 P3 P5 r4 P4 r5 P10</formula><p>Result of Renaming Register Map Table <ref type="table" target="#tab_2">I1</ref>: add r1 ? r2, r3  . In this example, we assume that physical registers P2, P3 and P4 have been previously assigned to r2, r3 and r4 respectively. (a) conventional renaming scheme, (b) the proposed renaming scheme.</p><p>they will write their results in order in the register file.</p><p>In addition, each instruction is the only consumer of the previous one. In this case, the same physical register can be used as the destination for these four instructions, since the RAW dependence guarantees that an instruction produces its value before the next instruction in the chain is issued and, moreover, the single-use condition guarantees that the value is not used by any other instruction. In other words, there is no other instruction reading the value between the producer and the consumer in this chain of instructions that may introduce a WAR hazard. Hence, there is no requirement of keeping the four values alive in different physical registers for correct program execution.</p><p>In this paper, we propose to reuse the same physical register in the aforementioned condition, i.e. when two instructions exhibit a RAW dependence and the second instruction is the only consumer of the value. To leverage physical register sharing, we introduce a new hardware structure: the Physical Register Table (PRT). The PRT contains one entry per physical register, as shown in Figure <ref type="figure">4(b)</ref>. Each PRT entry includes one Read bit and a 2-bit Counter. The Read bit is used to identify the first consumer of a register. If the Read bit is set it indicates that the physical register is the source operand for an in-flight or a committed instruction in the pipeline. On the contrary, if the Read bit is clear, it indicates that no consumer of the value has been found (i.e. fetched and renamed) yet.</p><p>When the first consumer of a register is being renamed, in order to reuse the source register for the destination register, we also have to verify that there will be no future consumers. In case the consumer is also redefining the first-use register, it is guaranteed that there will be no younger consumer of the value. For example, instruction I5 in Figure <ref type="figure">4</ref> satisfies this property, as it is the only consumer of r1 and it also redefines r1. In case the instruction being renamed is not the redefining instruction (see instruction I8 in Figure <ref type="figure">4</ref>), a simple singleuse predictor is employed to decide whether the same register is reused or a new physical register is allocated. Section IV-D provides more details about the single-use predictor and the actions taken in case of misprediction.</p><p>On the other hand, the 2-bit Counter keeps track of the number of instructions sharing the same physical register, and it is used to maintain the true dependences. Due to the sharing of registers, the same name, i.e. the same physical register ID, is used to identify different values produced by different instructions. Therefore, it is not possible to correctly identify which instructions have to be woken up in the issue stage when a value is produced using only this ID. To avoid this ambiguity, we append the 2-bit Counter to the register ID, so the source or destination of an instruction is specified as the N-bits of the physical register ID plus the two bits of the counter. The 2-bit Counter is increased each time the same physical register is reused and it identifies the different versions of this register. In this manner, up to four instructions can share the same physical register but yet RAW dependences can be identified, as different instructions produce or wait for different versions of the register. As shown in Figure <ref type="figure">4</ref>(b), both instructions I5 and I6 take P1 as source operand, but they wait for version one (P1.1) and version two (P1.2) respectively. When instruction I4 produces P1.1 the issue logic only wakes up I5, that is the instruction waiting for version one.</p><p>This scheme can be generalized to employ an N-bit counter to allow up to 2 N instructions to share the same physical register as destination. Note that when the counter is saturated we cannot longer reuse the register, as it would not be possible to differentiate its multiple versions to keep track of the RAW dependences. We found that in SPEC benchmarks it is uncommon to have more than three reuses (see Figure <ref type="figure">3</ref>). Furthermore, additional bits represent larger overheads in the PRT and the issue queue. We found that a 2-bit counter provides a good trade-off between the degree of physical register sharing and cost.</p><p>Figure <ref type="figure">4</ref>(b) shows the proposed renaming technique stepby-step. In this case, instructions I1, I4, I5 and I6 share the same physical register P1. Our renaming scheme only requires four physical registers, instead of the eight employed by the conventional approach. Next sections provide further details on the renaming technique, describing how the processor operates and the changes required to the different hardware structures.</p><p>1) Renaming Source registers: Every time a source operand of an instruction is renamed, the Register Map Table is accessed as in the conventional approach to get the physical register ID that is assigned to the logical register. Next, the physical register ID is used to index the PRT. The Read bit of the corresponding entry is set to indicate that an in-flight instruction will read the value stored in the register. In addition, the 2-bit counter, that indicates the most recent version of the register, is read from the PRT, so the renaming logic provides the physical register ID plus the 2-bit counter.</p><p>2) Renaming Destination Registers: Our renaming scheme tries to reuse some of the source registers as the destination for the instruction being renamed, in order to avoid an allocation of a new physical register. For this purpose, the renaming logic checks first the Read bit of the source registers in the PRT. If this bit is zero for some of the sources, it means the instruction being renamed is the first consumer of the value stored in that register. To identify single-use condition, the renaming logic also checks whether the instruction is the last consumer of the value. To this end, the source register ID is compared with the destination register ID of the instruction. If the source register matches the destination, it is guaranteed that the instruction is the last consumer of the value. On the contrary, the single-use predictor, described in Section IV-D, is triggered to decide whether the instruction is the only consumer of the value.</p><p>On the other hand, the 2-bit counter of the source register is also accessed to verify that it is not saturated, i.e. that there are versions of the register available and, hence, the processor will be able to maintain the RAW dependences for another reuse. If the instruction is identified as the single consumer of the source register and the 2-bit counter is not saturated, the source physical register is reused as the destination of the current instruction being renamed, and no allocation of a physical register is performed. The corresponding entry in the Register Map Table is updated to map the logical register to the physical register being reused. In addition, the Read bit is set to zero and the 2-bit counter is increased in the corresponding PRT entry.</p><p>In case the instruction cannot be identified as the single consumer of a source register or the 2-bit counter is satu-rated, a new physical register is allocated. The Register Map Table entry is updated with the ID of the allocated register, whereas the Read bit and the 2-bit counter are set to zero in the PRT.</p><p>3) Releasing a Physical Register: When a physical register is being reused, no register allocation is required for the new instruction. This technique is equivalent to a releaseon-rename scheme. Although no modification is done to the list of free registers, the result of the technique is identical to releasing the physical register and immediately allocating it to the new instruction.</p><p>In case the physical register cannot be reused, a new one is allocated. The old register is released when the redefining instruction commits. Therefore, if a physical register can be reused the technique mimics the behavior of a releaseon-rename scheme, otherwise it works as the conventional release-on-commit approach.</p><p>4) Lack of Physical Registers: Conventional renaming schemes stall when the list of free registers is empty. In our approach, the renaming will be blocked only when there is no available physical register and there is no possibility of reusing a register as described in Section IV-A2. Our experimental results presented in Section VI show that our scheme is very effective avoiding stalls in the renaming stage due to lack of registers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Mispredictions, Interrupts and Exceptions</head><p>Modern out-of-order processors use dynamic speculation to issue an instruction before it is known whether or not the instruction should be executed. In our renaming scheme, multiple instructions may reuse the same physical register, and each instruction in a chain of reuses overwrites the value produced by the previous instruction. Since values in a shared physical register are speculatively overwritten, it is necessary to recover the previous value of a register in case of a branch misprediction or an exception between two instructions in the chain of reuses.</p><p>In the example of Figure <ref type="figure">4</ref>, assume that instruction I2 causes a TLB miss or raises a page fault exception and, when the exception is triggered, instruction I4 has already written its result in P1. In this case, the previous value of P1, i.e. the value produced by instruction I1, must be recovered before invoking the exception handler to maintain precise exceptions.</p><p>In order to deal with branch mispredictions and support precise exceptions, the different versions of a shared register must be kept. However, this requires extra storage and increases the pressure on the register file, which is exactly what our renaming technique is trying to avoid by using physical register sharing. Shadow bit cells are a costeffective solution to keep previous values of a register in a check-pointed register file <ref type="bibr" target="#b5">[6]</ref>. Shadow copies of a register introduce a small overhead since they are independent of the number of ports, i.e. they are not directly accessible. Previous values of a shared register are only required in the infrequent case of a branch misprediction or exception, whereas only the last version is required for normal execution. Therefore, the most recent version is stored in the normal bits, that are directly accessible, whereas older versions of a shared register are stored in the shadow bits with a small area overhead, and recovered when necessary.</p><p>In event of an interrupt or an exception the entire pipeline is flushed. Before the interrupt or the exception handler can be invoked, all logical registers must reflect their state before the interrupt or the exception. To this end, the processor consults the rename and retirement map tables and any entry that differs indicates a logical register whose correct state needs to be recovered from the shadow cells. Although this recovery process may take a few cycles more than in the baseline, the infrequent nature of interrupts and exceptions makes this cost negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. The Register File</head><p>As described in Section IV-B, our renaming scheme employs a check-pointed register file with shadow bit cells to store the different versions of a shared physical register. With a 2-bit counter in the PRT, our scheme allows up to three reuses of the same physical register, which means that up to three shadow copies must be kept in the register file. Hence, a straightforward implementation would include three shadow cells for each physical register.</p><p>Although each shadow copy represents a minor overhead <ref type="bibr" target="#b5">[6]</ref>, including three shadow copies for each physical register is not cost-effective, since all the copies are not required most of the time. As shown in Figure <ref type="figure">3</ref>, most of the registers require zero or just one shadow copy, whereas chains of two or three reuses are much less common. Therefore, we propose to split the register file in four banks, where each bank includes registers with zero, one, two or three shadow copies respectively. By using this organization, our scheme is able to cover most of the cases while it avoids the extra cost of including three shadow copies in all the registers. In the following sections we provide further details on the implementation of the register file.</p><p>1) The Register File Design And Its Mechanism: To reduce the latency and increase the efficiency in area, register files are implemented in multiple banks <ref type="bibr" target="#b6">[7]</ref>. In this work, we propose to have a multi-bank register file in which some of these banks have registers with one, two or three shadow cells embedded.</p><p>In such registers, each traditional register bit-cell is backed-up by pairs of cross-coupled inverters which are connected to the main bit-cell using a pass transistor. Shadow cells are accessed only through the main SRAM-cell of the register. Therefore, they do not require any additional read or write ports. A single-bit cell with n embedded shadow cells can hold up to n+1 different contents. The processor can simply manage these contents. At the write stage, the value of a register is stored in a shadow cell and a recover command copies back the content of a particular shadow cell to the main storage of the register. A physical register can be reused only if it has free shadow cells to store the previous content of the register.</p><p>Figure <ref type="figure" target="#fig_4">5</ref> shows the structure of four different banks of a register file with j read ports and k write ports. As it can be seen, the first bank in the left has single-bit-cell registers while the other banks have register cells with one, two and three embedded shadow cells. The design of a register bit cell with one shadow cell is shown in Figure <ref type="figure">6</ref>. As this figure shows, the shadow cell is only accessible through the main cell.</p><p>The additional area required by the shadow cells is independent of the number of register ports. Therefore, the area overhead of the shadow bits becomes relatively smaller as the number of ports increases. Furthermore, we have observed that most of the registers do not need to have shadow cells. For this reason, the majority of the registers do not have shadow cells which helps to reduce the overhead significantly. We employ a bank with conventional singlebit-cell registers, which includes the majority of the registers,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Main Bitcell</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Shadow Bitcell</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Checkpoint Recover</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Wordlines</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bitlines</head><p>Figure <ref type="figure">6</ref>: The design of a register bit cell with one shadow cell <ref type="bibr" target="#b5">[6]</ref>. and three banks with registers that have one, two and three embedded shadow cells respectively.</p><p>When a new physical register is allocated, the register type predictor (described in section IV-D) predicts the expected use of it (single-use/multiple use; number of reuses), and allocates it in the corresponding bank according to this prediction. When a single-use register is written, the previous content of the register is stored in the shadow cell according to the 2-bit counter of the register ID. In event of branch mispredictions, exceptions or interrupts, a recover command is issued for each register that needs its previous value to place them back to the main storage of the registers. In order to recover the value from the registers with more than one shadow cells, the added 2-bit to the register ID determines the correct shadow cell to recover the previous content of the register. If the physical register does not have enough shadow cells to store the previous content of the register, the register cannot be reused and a new register is allocated at the renaming stage.</p><p>2) Impact on the Performance: According to our analysis, there is a very small increase, less than 1%, in the access time of the register file with the shadow cells due to longer word select and bit lines, as reported eslewhere (for instance, see <ref type="bibr" target="#b2">[3]</ref>). The reason for the slight delay is that in the design of the registers with shadow cells, no gate capacitance is added.</p><p>Whenever a register is to be written in the write stage, according to its register ID the value of the register is stored in parallel to the appropriate shadow cell, so no extra latency is added to the write operation. In event of branch mispredictions, exceptions and interrupts there may be some registers whose previous values need to be recovered from the shadow cells. Therefore, recovering the state of the processor in such events may take a few cycles more with respect to the baseline. In our experiments, we have taken this into account. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Register Type Predictor</head><p>When an instruction is being renamed, if it needs a new physical register (i.e., the source registers cannot be reused because they do not have shadow cells available or they are not the first use), a hardware predictor determines the type of the register which should be assigned to it. We design a simple 2-bit entry predictor which predicts the type of the register that should be allocated. Using the PC of the instruction, a simple hashing function determines an entry in the register predictor table, as Figure <ref type="figure" target="#fig_5">7</ref> shows. Then, according to the value of the entry, if there is a free register of that type, a new physical register is allocated. In the register predictor table, 00 indicates a normal register (i.e., it implicitly predicts that the register is not single-use) whereas 01, 10 and 11 indicate registers with 1, 2 and 3 shadow cells respectively (i.e., register is predicted to be reused).</p><p>If there are no free registers of the predicted type, a register with the closest number of shadow cells will be allocated. In case there is no free register of any type, renaming will stall as in the conventional scheme.</p><p>Whenever a physical register is released, the entry in the register predictor table that has been used to allocate this register is updated to reflect the actual number of reuses. If not all the allocated shadow copies have been used, the value of the corresponding entry in the register predictor table is decremented.</p><p>On the other hand, if a register that is predicted to be single-use (i.e. has been allocated in a bank with one, two or three shadow copies) is detected to be used more than once, the corresponding entry in the predictor is reset to zero.</p><p>Finally, if a register predicted to be single-use is tried to be reused (i.e. it is the source operand of an instruction and it is the first use) but there are no shadow cells available, the register is not reused and the corresponding entry in the predictor is increased, so that next time it allocates a register with a greater number of shadow copies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Handling Single-Use Mispredictions:</head><p>A register predicted to be single-use may be reused and later encounter that the single-use prediction was wrong because there is an additional use. This is illustrated in Figure <ref type="figure" target="#fig_7">8</ref>. Register r 1 is predicted to be a single-use register. Therefore, its physical register (P 1 ) is assigned to register r x . Later, while renaming instruction 3, it is discovered that r 1 is mispredicted to  be a single-use register. Now, since the physical register P 1 has been assigned to another register, the register r 1 in instruction 3 cannot be renamed to P 1 as it holds the value of r x . Since register r x is renamed to P 1 and there might be instructions before instruction 3 that use r x , it is more cost effective to rename further consumers of r 1 to a new physical register. Therefore, the value of the r 1 which was in physical register P 1 needs to be moved to this new physical register.</p><p>For this purpose, we propose to use two different microoperations, depending on whether instruction 1 has been executed when instruction 3 is being renamed or not, which move the value of r 1 to a new physical register (instructions 2(a) and 2(b) in Figure <ref type="figure" target="#fig_7">8</ref>). If instruction 1 has been executed before the instruction 3 is being renamed, the value of r 1 is check-pointed in a shadow cell of P 1 (P 1.ch ). Hence, as instruction 2(a) in Figure <ref type="figure" target="#fig_7">8</ref> shows, first, the current value of P 1 is stored in an auxiliary register. Then, the checkpointed value in P 1 (P 1.ch ) is being recovered and moved to another auxiliary register. Finally, last step is to move back the correct value of P 1 and move the recovered value of r 1 to the new physical location. If instruction 1 has not been executed before the instruction 3 is being renamed, the value of r 1 is not check-pointed and it only needs to be moved to the new physical register (see the timing for instructions 2(b) in Figure <ref type="figure" target="#fig_7">8</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. METHODOLOGY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Simulation Environment</head><p>In this work, we model an out-of-order ARM processor using the GEM5 <ref type="bibr" target="#b7">[8]</ref> cycle-accurate simulator with the parameters presented in Table <ref type="table" target="#tab_2">I</ref>. This processor uses a merged register file and releases a physical register when the redefining instruction commits. The simulator models in detail both the baseline and our proposed technique. We use CACTI 6.5 <ref type="bibr" target="#b8">[9]</ref> to estimate area of the register files, PRT, issue queue and the predictor. CACTI 6.5 supports different models for SRAMs, DRAMs and register files. We specify different parameters including the number of read/write ports, number of banks, technology, bus width, etc. to estimate the area, power and latency of different configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Benchmarks</head><p>We use SPECfp and SPECint CPU2006 <ref type="bibr" target="#b9">[10]</ref> benchmarks for our experiments. We run the benchmarks using the ref inputs provided in the SPEC software package. All the SPEC benchmarks have been compiled using GCC version 4.8.4 with -O3 -mtune=armv8 optimization flags. For each benchmark 5 billions committed instructions have been simulated. In addition to SPEC2006 CPU benchmarks, we use Mediabench <ref type="bibr" target="#b10">[11]</ref> benchmark suite.</p><p>In recent years, machine learning applications including voice, video and image processing have become very popular. Gaussian Mixture Models (GMMs) <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref> and Deep Neural Networks (DNNs) are among the main kernels commonly used in many of these applications, so we add these two benchmarks in addition to the SPEC2006 and Mediabench.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIMENTAL RESULTS</head><p>In this section, we evaluate the proposed register renaming technique explained in Section IV. In our experiments, we consider the overheads of the proposed renaming technique in order to make a fair comparison with respect to the baseline system, including the area of the PRT, register files, issue queue and the predictor. First, we evaluated the area for these units in the baseline and later we reevaluated the area considering the required changes for our renaming technique. In order to make comparisons with the same area, we consider the area of overheads of our technique, and we adjust the number of registers in the register file for our  renaming scheme in such a way that the total area becomes the same as the baseline.</p><p>The additional area required by the shadow cells is independent of the number of register file ports and it becomes relatively smaller as the number of register file ports increases. Besides, since we use shadow cells only for a small percentage of the registers, their area overhead becomes very small (normally in the order of a few physical registers). Unless stated otherwise, comparisons between our technique and the baseline are performed assuming the same total area for both, including the overheads.</p><p>A. Size of Different Banks in the Register File 1) Overheads of the proposed scheme: In the first place, we calculate the overheads that our scheme adds to the baseline system. Regarding the issue queue and PRT table, we consider the changes in the sizes of these units with respect to the baseline. Furthermore, the register type predictor has a table with the size of 1K bits. Table <ref type="table" target="#tab_3">II</ref> shows the summary of area overheads in different modified units for our scheme. As it is shown, the overheads are small in comparison with the size of the register file.</p><p>2) Adjusting the sizes of each bank in the register file: Considering the aforementioned overheads, we performed a sensitivity analysis to identify the most convenient size of the different banks in the register file. For this study, we assumed an unbounded number of registers with up to three shadow cells. Figure <ref type="figure" target="#fig_8">9</ref> shows different number of physical registers with different number of shadow cells to cover different Register file configuration Register file configuration for the baseline for our scheme 0-sh, 1-sh, 2-sh, <ref type="bibr" target="#b2">3</ref> Table <ref type="table" target="#tab_4">III</ref> shows the equivalent sizes of the register file that we consider. For each particular size of the register file in the baseline system, a hybrid register file configuration of the same area has been considered to evaluate the proposed scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Performance Improvement</head><p>We present the performance results for the proposed register renaming technique in comparison with the baseline system. We assume a register file with four types of banks as shown in Figure <ref type="figure" target="#fig_4">5</ref>. Figure <ref type="figure" target="#fig_0">10</ref> presents the performance improvements with respect to the baseline for different sizes of the register file. Note that the integer and floating-point register files are decoupled. Hence, for integer benchmarks we consider different sizes of the integer register file whereas for floating-point benchmarks we measure performance for different sizes of the floating-point register file.</p><p>As Figure <ref type="figure" target="#fig_0">10a</ref> shows, for SPECfp benchmarks, the proposed technique provides 12.2%, 7.5%, 3.75%, 1.83% and 0.82% performance improvements on average using a register file of equivalent size for our proposed technique. Similarly, for SPECint benchmarks, see Figure <ref type="figure" target="#fig_0">10b</ref>, the proposed technique provides 47%, 6.76%, 2.29%, 0.67% and 0.41% performance improvements on average with respect to the baseline. As the results show, for small register files, the benefits are high. As the register file size increases, the benefits decrease since the register file becomes less critical and a more effective use of it has smaller benefits.</p><p>For Mediabench and cognitive computing benchmarks, the proposed scheme provides significant performace improvements, as Figure <ref type="figure" target="#fig_0">10c</ref> shows.</p><p>Figure <ref type="figure" target="#fig_0">11</ref> shows the average committed instructions per cycle (IPC) for the baseline and the proposed scheme. The X axis represents the number of physical registers in the baseline. For the proposed technique, we assume a register file of equivalent area, taking into account its overheads. As it can be seen, our scheme can achieve the same performance as the baseline with a significantly lower number of registers. For instance, our technique with a floating-point register bits per entry, which is small compared to the information already stored in modern out-of-order processors.</p><p>Regarding the renaming logic, our scheme adds an indirection from Register Map Table to the PRT and it requires an access to the predictor table. Handling dependencies among instructions renamed in the same cycle is not a problem, since out-of-order processors already handle this case and include additional checks and bypasses. Our scheme only requires extra checks to the Read-bit and 2-bit counter. Although this extra complexity in the renaming might impact the total delay of the rename stage, we assume our technique has no impact on cycle time for two reasons. First, some of the latencies can be overlapped, for example Register Map Table and predictor table can be accessed in parallel. Second, renaming is not typically in the critical path of modern out-of-order processors. In the worst case, we can further pipeline the renaming, since adding one stage to the front-end results in negligible impact on the overall IPC as reported elsewhere (see for instance <ref type="bibr" target="#b13">[14]</ref>).</p><p>Finally, all comparisons in this paper are done for configurations with the same area, in order to show that our renaming scheme is better than simply adding more registers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. RELATED WORK</head><p>Using physical registers in a more efficient way has been the goal of many researches in the past. The most similar works to the technique presented in this paper are those that try to delay the allocation of registers or anticipate its release.</p><p>Monreal et al. <ref type="bibr" target="#b14">[15]</ref> proposed a register renaming technique based on virtual-physical registers <ref type="bibr" target="#b15">[16]</ref>. By employing virtual-physical registers, their approach postpones the physical register allocation until the corresponding instruction finishes its execution. Their approach has a significant cost due mainly to the requirement of two separate register map tables, and two mapping operation per each destination register (from logical to virtual-physical, and from virtualphysical to physical).</p><p>Several works have been proposed to early release a register. Moudgill et al. <ref type="bibr" target="#b16">[17]</ref> suggested to release physical registers, as soon as the last instruction that redefines a register commits. The last-use tracking is based on counters which record the number of pending reads for every physical register. This initial proposal did not support precise exceptions since the counters were not correctly recovered when instructions were squashed. Later, Akkary et al. <ref type="bibr" target="#b17">[18]</ref> proposed to improve the Moudgill scheme by adding an unmapped flag for each physical register, which is set when a subsequent instruction redefines that logical register. Then, a physical register can be released once its usage counter is zero and its unmapped flag is set. Moreover, for proper exception recovery of the reference counters, when a check-point is created, the counters of all physical registers belonging to the check-point are incremented. Similarly, when a check-point is released, the counters of all physical registers belonging to the check-point are decremented. In addition to the overheads that these techniques impose, they release a register far later than its actual lifetime.</p><p>Monreal et al. <ref type="bibr" target="#b18">[19]</ref> proposed two different schemes to release a register. The first scheme waits for a redefining instruction to become non-speculative before releasing the previous version of its logical register. The second adds a new queue with multiple levels corresponding to the unconfirmed branches in the reorder buffer (ROB). Registers are released when the redefining instruction becomes nonspeculative and the last instruction using the physical register has committed. On a branch misprediction, the relevant levels in the release queue are squashed. The downside of these techniques is that no recovery mechanism is in place to retain values released early. In the event of an exception or interrupt it would be impossible to reconstruct the precise processor state. They also need to add many large structures to the processor so that the status of redefining and last-use instructions can be maintained, increasing the complexity of the pipeline.</p><p>Ergin et al. <ref type="bibr" target="#b2">[3]</ref> introduced a check-pointed register file to implement early register release. In their approach, a register is being deallocated immediately after the instruction producing the register's value commits itself and all potential consumers of this value have started execution before the redefining instruction is known to be non-speculative. To support branch misprediction, precise exceptions and interrupts, their proposal save the register value into the shadow bit-cells of the register where it can be accessed easily in such events.</p><p>Jones et al. <ref type="bibr" target="#b5">[6]</ref> proposed a compiler-based technique for early register release. The compiler defines the points where registers will no longer be used and can be safely released. To guarantee that the state of the processor can be safely recovered after an interrupt or an exception, they used a check-pointed register file similar to the register file proposed in <ref type="bibr" target="#b2">[3]</ref>. This scheme requires compiler support and changes in the ISA in addition to the overheads of the shadow cells in the entire register file.</p><p>Quinones et al. <ref type="bibr" target="#b19">[20]</ref> proposed two techniques to release registers in out-of-order processors with register windows. The proposed techniques are based on the observation that when none of the instructions of a procedure are currently inflight, all mappings of the procedure context are not needed. Therefore, these mappings and their associated physical registers can be released. Although their approach is beneficial, it is specific for processors with register windows, which are not common nowadays.</p><p>Note that previous work on early register release like <ref type="bibr" target="#b16">[17]</ref> and <ref type="bibr" target="#b18">[19]</ref> do not support precise exceptions. Precise exceptions is a must for modern out-of-order processors and, hence, these previous techniques cannot be implemented on modern CPUs. Work in <ref type="bibr" target="#b19">[20]</ref> is specific to processors with register windows which are very uncommon nowadays. Finally, work in <ref type="bibr" target="#b5">[6]</ref> requires compiler support and changes to the ISA. ISA extensions become legacy and make the technique less attractive. In comparison, our scheme supports precise exceptions and does not require any ISA extension. In short, previous techniques are not suitable for modern processors and, to the best of our knowledge, our technique is the only one that can reuse a physical register as early as the last use of this register is renamed, as opposed to other techniques that need to wait at least until the last use instruction commits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSIONS</head><p>In this paper, we show that the value generated by more than 50% of the floating-point instructions in SPECfp benchmarks and more than 30% of the integer instructions in SPECint benchmarks are consumed only by one instruction.</p><p>Based on this observation, we propose a novel register renaming technique for out-of-order processors that allows to reuse this single-use registers for the destination operand, instead of allocating a new register. To recover the state of the processor in the event of branch mispredictions, exceptions and interrupts, we employ a multi-bank register file in which some banks have registers with integrated shadow cells. A simple register predictor is proposed to allocate the most beneficial type of the register for each instruction. Considering similar costs in hardware, we show that the proposed technique provides 6% speedup on average for the SPEC2006 benchmarks. Alternatively, the same performance as the baseline can be achieved while reducing the area of the register file by 10.5%.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FPFPFigure 1 :</head><label>1</label><figDesc>Figure1: Percentage of instructions with a destination register that are the only consumers of the value of a register. We distinguish between instructions that redefine the singleuse register and instructions that redefine a different logical register.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Percentage of registers consumed one, two, three, four, five and six or more times. Most of the values are consumed just once in SPEC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The structure of a four-bank m-bit register file with j read ports and k write ports. (In order from left to right) A bank with single-bit-cell, one, two and three shadow cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The design of the proposed register type predictor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>? aux1 Rec. P1.ch R. P1 ? aux2 W. aux2?P2 W. aux1?P1 Reads to are served from aux1 Writes to are stored to aux1 If instruction has not been executed yet, there is no need to recover P1.ch R. P1 ? aux1 W. aux1?P2 It is not a problem since it reads from P2. This instruction depends on instruction which is a 2-cycle execution instruction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Timing for the proposed micro-operations to move the value of the check-pointed register.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Number of physical registers with 1, 2 and 3 shadow cells needed to cover different percentages of the SPECfp execution time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table</head><label></label><figDesc>Figure 4: Step-by-step renaming of several instructions, including the changes in the Register MapTable and the Physical Register Table</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Physical Register</cell></row><row><cell></cell><cell></cell><cell>1 new register</cell><cell cols="2">I1: add r1 ? r2, r3</cell><cell>1 new register</cell></row><row><cell>I2: ld</cell><cell>r3 ? m(x1)</cell><cell>1 new register</cell><cell>I2: ld</cell><cell>r3 ? m(x1)</cell><cell>1 new register</cell></row><row><cell cols="2">I3: mul r2 ? r3, r4</cell><cell>1 new register</cell><cell cols="2">I3: mul r2 ? r3, r4</cell><cell>1 new register</cell></row><row><cell cols="2">I4: add r1 ? r1, r4</cell><cell>1 new register</cell><cell cols="2">I4: add r1 ? r1, r4</cell><cell></cell></row><row><cell cols="2">I5: mul r1 ? r1 , r1</cell><cell>1 new register</cell><cell cols="2">I5: mul r1 ? r1 , r1</cell><cell></cell></row><row><cell cols="2">I6: mul r1 ? r1 , r3</cell><cell>1 new register</cell><cell cols="2">I6: mul r1 ? r1 , r3</cell><cell></cell></row><row><cell cols="2">I7: add r5 ? r1 , r2</cell><cell>1 new register</cell><cell cols="2">I7: add r5 ? r1 , r2</cell><cell></cell></row><row><cell cols="2">I8: sub r2 ? r5 , r1</cell><cell>1 new register</cell><cell cols="2">I8: sub r2 ? r5 , r1</cell><cell>1 new register</cell></row><row><cell></cell><cell></cell><cell>8 new registers</cell><cell></cell><cell></cell><cell>4 new registers</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table I :</head><label>I</label><figDesc>System Configuration.</figDesc><table><row><cell>Configuration</cell></row><row><cell>Core ARMv8 ISA, 2.0 GHz, 128-entry ROB</cell></row><row><cell>40-entry Issue Queue, Fully Out-of-Order</cell></row><row><cell>3-Width Decoder, 3-Width Instruction Dispatch</cell></row><row><cell>48 KB, 3-Way TLB</cell></row><row><cell>48-Enrty Fully-Associative L1 TLB</cell></row><row><cell>Caches 32 KB L1-D Cache, 2-Way, 1 Cycle</cell></row><row><cell>48 KB L1-I Cache, 3-Way, 1 Cycle</cell></row><row><cell>1 MB L2 Cache, 16-Way, 12 Cycles</cell></row><row><cell>64 Bytes Cache Line Size</cell></row><row><cell>Prefetcher Stride Prefetcher (Degree 1)</cell></row><row><cell>2K Branch Target Buffer (BTB)</cell></row><row><cell>32-Instruction Fetch Queue</cell></row><row><cell>15 Cycles Misprediction Penalty</cell></row><row><cell>DRAM DDR3 1600 MHz, 2 Ranks/Channel</cell></row><row><cell>8 Banks/Rank, 8 KB Row Size.</cell></row><row><cell>tCAS = tRCD = tRP = CL = 13.75ns</cell></row><row><cell>tREFI = 7.8 us</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table II :</head><label>II</label><figDesc>Area for the register file, register map table, issue queue and the register predictor.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="6">Units Configuration Area (mm 2 )</cell></row><row><cell></cell><cell></cell><cell cols="2">Integer Register File</cell><cell cols="2">128 Registers</cell><cell></cell><cell>0.2834</cell></row><row><cell></cell><cell></cell><cell cols="2">(64-bit registers)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">Floating-point Register File</cell><cell cols="2">128 Registers</cell><cell></cell><cell>0.4988</cell></row><row><cell></cell><cell></cell><cell cols="2">(128-bit registers)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>PRT</cell><cell></cell><cell>Overhead</cell><cell></cell><cell>5.08 E-04</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Issue Queue</cell><cell></cell><cell>Overhead</cell><cell></cell><cell>1.48 E-03</cell></row><row><cell></cell><cell></cell><cell cols="2">Register Predictor</cell><cell></cell><cell>Overhead</cell><cell></cell><cell>3.1 E-03</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Total Overheads</cell><cell></cell><cell></cell><cell cols="2">5.085 E-03</cell></row><row><cell></cell><cell>100</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Percentage of the execution time (%)</cell><cell>40 50 60 70 80 90</cell><cell></cell><cell></cell><cell></cell><cell cols="3">Number of registers with 1 shadow cell Number of registers with 2 shadow cells Number of registers with 3 shadow cells</cell></row><row><cell></cell><cell>1</cell><cell>2</cell><cell>4</cell><cell>8</cell><cell>16</cell><cell>32</cell><cell>64</cell><cell>128</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table III :</head><label>III</label><figDesc>Register File Configuration. percentages of the SPECfp execution time. Hence, based on this study we tune the number of the registers of each bank in the floating-point register file. Similarly, we tune the number of registers in each bank for the integer register file.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>-sh</cell></row><row><cell>48</cell><cell>28</cell><cell>4</cell><cell>4</cell><cell>4</cell></row><row><cell>56</cell><cell>28</cell><cell>6</cell><cell>6</cell><cell>6</cell></row><row><cell>64</cell><cell>36</cell><cell>6</cell><cell>6</cell><cell>6</cell></row><row><cell>72</cell><cell>36</cell><cell>8</cell><cell>8</cell><cell>8</cell></row><row><cell>80</cell><cell>42</cell><cell>8</cell><cell>8</cell><cell>8</cell></row><row><cell>96</cell><cell>58</cell><cell>8</cell><cell>8</cell><cell>8</cell></row><row><cell>112</cell><cell>75</cell><cell>8</cell><cell>8</cell><cell>8</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>2378-203X/18/$31.00 ?2018 IEEE DOI 10.1109/HPCA.2018.00031</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENT</head><p>This work was supported by the <rs type="funder">Spanish State Research Agency</rs> under grants <rs type="grantNumber">TIN2013-44375-R</rs> and <rs type="grantNumber">TIN2016-75344-R (AEI/FEDER, EU</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_q5jDU4P">
					<idno type="grant-number">TIN2013-44375-R</idno>
				</org>
				<org type="funding" xml:id="_eEnVp2u">
					<idno type="grant-number">TIN2016-75344-R (AEI/FEDER, EU</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>file equivalent to 56 registers achieves the same IPC as the baseline with 64, which represents a saving of 13% in area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Analysis on Register Type Predictor</head><p>As described in section IV, the proposed technique uses a simple predictor with 512 entries that predicts the most likely reuse for each register and it is the configuration assumed in the experiments of this work. In case the prediction corresponds with the actual number of reuses, we count it as a hit; otherwise it is counted as a miss.</p><p>As we discussed in section III, more than 85% of the instructions, on average, require a destination register for which in our scheme we use the register predictor. Therefore, a register may be predicted to be reused correctly or incorrectly. On the other hand, the predictor may predict not to reuse a register which again can be a correct or an incorrect prediction. Figure <ref type="figure">12</ref> shows a breakdown for all the instructions of SPECint and SPECfp benchmarks. As this figure shows, despite the instructions that do not have a destination register, the rest will fall into one of these four categories.</p><p>Using the predictor two different kind of misprediction may occur. First, there may be a possibility to reuse a singleuse register, however, due to an incorrect prediction, the register is not reused. In this case, that represents 2.28% of the instructions in SPECfp, an opportunity of reusing a register is lost but no further actions are required. On the other hand, a register may have more than a consumer and it is predicted as a single-use register. In this case, that represents 3.1% of the instructions in SPECfp, as the register is reused incorrectly, the previous value of the register needs to be recovered as discussed in section IV-D1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Complexity of the Proposed Register Renaming Scheme</head><p>Our register renaming technique introduces a small overhead. The new hardware structures included are fairly small: the PRT requires up to 384-bits and the register predictor table contains 1-Kbits. Regarding the register file, shadow copies are much cheaper than regular registers as they are not connected to read/write ports. Furthermore, only a small number of registers include shadow copies as shown in Table <ref type="table">III</ref>. Finally, the issue queue requires 4 additional</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Wall</surname></persName>
		</author>
		<title level="m">Limits of instruction-level parallelism</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Register file design considerations in dynamically scheduled processors</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">I</forename><surname>Farkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High-Performance Computer Architecture, 1996. Proceedings., Second International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Increasing processor performance through early register release</title>
		<author>
			<persName><forename type="first">O</forename><surname>Ergin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Balkan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ponomarev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ghose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Design: VLSI in Computers and Processors</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="480" to="487" />
		</imprint>
	</monogr>
	<note>ICCD 2004.</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Processor microarchitecture: An implementation perspective</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Latorre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Magklis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Computer Architecture</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="116" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Instruction issue logic for high-performance, interruptible, multiple functional unit, pipelined computers</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on computers</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="349" to="359" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Compiler directed early register release</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>O'boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Abella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ergin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Architectures and Compilation Techniques, 2005. PACT 2005. 14th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="110" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multiple-banked register file architectures</title>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz?lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Topham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Symposium on</title>
		<meeting>the 27th International Symposium on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="page" from="316" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The gem5 simulator</title>
		<author>
			<persName><forename type="first">N</forename><surname>Binkert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Reinhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hestness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Hower</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sardashti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Cacti 6.0: A tool to model large caches</title>
		<author>
			<persName><forename type="first">N</forename><surname>Muralimanohar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Balasubramonian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="22" to="31" />
		</imprint>
		<respStmt>
			<orgName>HP Laboratories</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Spec cpu2006 benchmark descriptions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Henning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Mediabench: a tool for evaluating and synthesizing multimedia and communicatons systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Mangione-Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th annual ACM/IEEE international symposium on Microarchitecture</title>
		<meeting>the 30th annual ACM/IEEE international symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="330" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An ultra low-power hardware accelerator for acoustic scoring in speech recognition</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tabani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Arnau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tubella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Architectures and Compilation Techniques (PACT), 2017 26th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="41" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Performance analysis and optimization of automatic speech recognition</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tabani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Arnau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tubella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz?lez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Multi-Scale Computing Systems</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Increasing processor performance by implementing deeper pipelines</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sprangle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carmean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="25" to="34" />
			<date type="published" when="2002">2002</date>
			<publisher>IEEE Computer Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Dynamic register renaming through virtualphysical registers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Monreal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz?lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonz?lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vi?als</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Instruction Level Parallelism</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">in High-Performance Computer Architecture, 1998. Proceedings</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998">1998. 1998</date>
			<biblScope unit="page" from="175" to="184" />
		</imprint>
	</monogr>
	<note>Virtual-physical registers</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Register renaming and dynamic speculation: an alternative approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moudgill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vassiliadis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th annual international symposium on Microarchitecture</title>
		<meeting>the 26th annual international symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="202" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Checkpoint processing and recovery: Towards scalable large instruction window processors</title>
		<author>
			<persName><forename type="first">H</forename><surname>Akkary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 36th Annual IEEE/ACM International Symposium on</title>
		<editor>
			<persName><surname>Microarchitecture</surname></persName>
		</editor>
		<meeting>36th Annual IEEE/ACM International Symposium on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page" from="423" to="434" />
		</imprint>
	</monogr>
	<note type="report_type">MICRO-36</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hardware schemes for early register release</title>
		<author>
			<persName><forename type="first">T</forename><surname>Monreal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vi?als</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz?lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. International Conference on</title>
		<meeting>International Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="5" to="13" />
		</imprint>
	</monogr>
	<note>Parallel Processing</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Early register release for out-of-order processors with register windows</title>
		<author>
			<persName><forename type="first">E</forename><surname>Quinones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Parcerisa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Architecture and Compilation Techniques, 2007. PACT 2007. 16th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="225" to="234" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
