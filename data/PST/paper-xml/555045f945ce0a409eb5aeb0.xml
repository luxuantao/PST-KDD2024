<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Oblivious Data Structures *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xiao</forename><forename type="middle">Shaun</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kartik</forename><surname>Nayak</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chang</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">T-H</forename><forename type="middle">Hubert</forename><surname>Chan</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Emil</forename><surname>Stefanov</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yan</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Hku</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">U</forename><forename type="middle">C</forename><surname>Berkeley</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">I</forename><forename type="middle">U</forename><surname>Bloomington</surname></persName>
							<affiliation key="aff0">
								<address>
									<addrLine>November 3-7</addrLine>
									<postCode>2014</postCode>
									<settlement>Scottsdale</settlement>
									<region>Arizona</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Oblivious Data Structures *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AF3F0E8E83CCC1145FF00162132FFCA5</idno>
					<idno type="DOI">10.1145/2660267.2660314</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.0 [Computer-Communication Networks]: Generalsecurity and protection Security</term>
					<term>Cryptography</term>
					<term>Oblivious Algorithms</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We design novel, asymptotically more efficient data structures and algorithms for programs whose data access patterns exhibit some degree of predictability. To this end, we propose two novel techniques, a pointer-based technique and a locality-based technique. We show that these two techniques are powerful building blocks in making data structures and algorithms oblivious. Specifically, we apply these techniques to a broad range of commonly used data structures, including maps, sets, priority-queues, stacks, deques; and algorithms, including a memory allocator algorithm, max-flow on graphs with low doubling dimension, and shortestpath distance queries on weighted planar graphs. Our oblivious counterparts of the above outperform the best known ORAM scheme both asymptotically and in practice.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>It is known that access patterns, to even encrypted data, can leak sensitive information such as encryption keys <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b56">56]</ref>. Furthermore, this problem of access pattern leakage is prevalent in numerous application scenarios, including cloud data outsourcing <ref type="bibr" target="#b43">[43]</ref>, design of tamper-resistant secure processors <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b45">45,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b56">56]</ref>, as well as secure multi-party computation <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b33">33]</ref>.</p><p>Theoretical approaches for hiding access patterns, referred to as Oblivious RAM (ORAM) algorithms, have existed for two and a half decades thanks to the ground-breaking work of Goldreich and Ostrovsky <ref type="bibr" target="#b17">[17]</ref>. However, the community has started to more seriously investigate the possibility of making ORAMs practical only recently <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr" target="#b44">44,</ref><ref type="bibr" target="#b52">52]</ref>. Encouragingly, recent progress in this area has successfully lowered the bandwidth blowup of ORAM from a factor of tens of thousands to 10X -100X range <ref type="bibr" target="#b42">[42,</ref><ref type="bibr" target="#b44">44,</ref><ref type="bibr" target="#b52">52]</ref>.</p><p>Since generic Oblivious RAM can support arbitrary access pattern, it is powerful and allows the oblivious simulation of any program. However, state-of-the-art ORAM constructions incur moderate bandwidth blowup despite the latest progress in this area. In particular, under constant or polylogarithmic client-side storage, the best known scheme achieves O( log 2 N log log N ) asymptotic blowup <ref type="bibr" target="#b28">[28]</ref>, i.e., for each effective bit read/written, O( log 2 N log log N ) bits must be in reality accessed for achieving obliviousness. We remark that under large block sizes, Path ORAM can achieve O(log N ) bandwidth blowup under poly-logarithmic client-side storage -however, the large block size assumption is often not applicable for data structures or algorithms that operate on integer or floating point values.</p><p>It will be beneficial to have customized, asymptotically more efficient constructions for a set of common algorithms which exhibit some degree of predictability in their access patterns. The access pattern graph for an algorithm has memory cells as nodes, and two cells can be accessed in succession only if there is a directed edge between the corresponding nodes. Hence, for general RAM programs, their access pattern can be a complete graph. Our key insight is that common data structures have a sparser access pattern graph than generic RAM programs that make arbitrary random accesses to data. For example, for a binary search tree or heap, memory accesses can only go from one tree node to an adjacent one. Therefore, we should be able to gain some efficiency (compared to ORAM) by not hiding some publicly known aspects of the access patterns.</p><p>In this work, we are among the first to investigate oblivious data structures (ODS) for sparse access pattern graphs. We achieve asymptotic performance gains in comparison with generic ORAM schemes <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b44">44]</ref> for two different characterizations of sparse access graphs (see Path ORAM <ref type="bibr" target="#b44">[44]</ref> All of the above O(log N ) • ω(1) O( log 2 N +χ log N χ ) for block size χ log N ORAM in <ref type="bibr" target="#b28">[28]</ref> All of the above O(1) O( log 2 N log log N )</p><p>Table <ref type="table" target="#tab_0">1</ref>: Asymptotic performance of our schemes in comparison with generic ORAM baseline. For the localitybased technique and Path ORAM, the bandwidth blowup hold for a slight variant of the standard ORAM model where non-uniform block sizes are allowed.</p><p>A note on the notation g(N ) = O(f (N ))ω(1): throughout this paper, this notation means that for any α(N ) = ω(1), it holds that g(N ) = O(f (N )α(N )).</p><p>• Bounded-degree trees. We show that for access pattern graphs that are rooted trees with bounded degree, we can achieve O(log N ) bandwidth blowup, which is an Õ(log N ) factor improvement in comparison with the best known ORAM.</p><p>• Graphs with low doubling dimensions. Loosely speaking, graphs with low doubling dimension are those whose local neighborhoods grow slowly. Examples of graphs having low doubling dimension include paths and low dimensional grids. Let dim denote the doubling dimension of the access pattern graph. We show how to achieve</p><formula xml:id="formula_0">O(1) dim •O(log 2-1 dim N ) amortized bandwidth blowup while consuming O(1) dim • O(log N ) + O(log 2 N ) • ω(1) client- side storage.</formula><p>As a special case, for a two-dimensional grid, we can achieve O(log 1.5 N ) blowup.</p><p>Applications. These two characterizations of sparse access pattern graphs give rise to numerous applications for commonly encountered tasks:</p><p>1. Commonly-encountered data structures. We derive a suite of efficient oblivious data structure implementations, including the commonly used map/set, priority_queue, stack, queue, and deque.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Oblivious memory allocator. We use our ODS framework to design an efficient oblivious memory allocator Our oblivious memory allocator requires transmitting O(log 3 N ) bits per operation (notice that this is the exact number of bits, not bandwidth blowup). We show that this achieves exponential savings in comparison with the baseline chunk-based method. In particular, in the baseline approach, to hide what fraction of memory is committed, each memory allocation operation needs to scan through O(N ) memory.</p><p>Our oblivious memory allocator algorithm can be adopted on ORAM-capable secure processor <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b34">34]</ref> for allocation of oblivious memory.</p><p>3. Graph algorithms. We achieve asymptotic improvements for operations on graphs with low doubling dimension, including random walk and maximum flow.</p><p>We consider an oblivious variant of the Ford-Fulkerson <ref type="bibr" target="#b14">[14]</ref> maximum flow algorithm in which depth-first-search is used to find an augmenting path in the residual network in each iteration. We also consider shortest-path distance queries on planar graphs. We make use of the planar separator theorem to create a graph data structure and make it oblivious.</p><p>Practical performance savings. We evaluated our oblivious data structures with various application scenarios in mind. For the outsourced cloud storage and secure processor settings, bandwidth blowup is the key metric; whereas for a secure computation setting, we consider the number of AES encryptions necessary to perform each data structure operation. Our simulation shows an order of magnitude speedup under moderate data sizes, in comparison with using generic ORAM. Since the gain is shown to be asymptotic, we expect the speedup to be even greater when the data size is bigger.</p><p>Techniques. We observe two main techniques for constructing oblivious data structures for sparse access pattern graphs.</p><p>• Pointer-based technique. This is applied when the access graph is a rooted tree with bounded degree. The key idea is that each parent keeps pointers for its children and stores children's position tags, such that when one fetches the parent node, one immediately obtains the position tags of its children, thereby eliminating the need to perform position map lookups (hence a logarithmic factor improvement).</p><p>We also make this basic idea work for dynamic data structures such as balanced search trees, where the access pattern structure may change during the life-time of the data structure. Our idea (among others) is to use a cache to store nodes fetched during a data structure operation, and guarantee that for any node we need to fetch from the server, its position tag already resides in the client's cache.</p><p>• Locality-based technique. This is applied when the access pattern graph has low doubling dimension. The nodes in the graph are partitioned into clusters such that each cluster keeps pointers to only O(1) dim neighboring clusters where dim is an upper bound on the doubling dimension. The intuition is that each cluster contains O(log N ) nodes and can support O(log</p><formula xml:id="formula_1">1</formula><p>dim N ) node accesses. As we shall see, each cluster has size Ω(log 2 N ) bits, and hence each cluster can be stored as a block in Path ORAM <ref type="bibr" target="#b44">[44]</ref> with O(log N ) bandwidth blowup.</p><p>Since each cluster only keeps track of O(1) dim neighboring clusters, only local information needs to be updated when the access pattern graph is modified.</p><p>Non-goals, limitations. Like in almost all previous work on oblivious RAM, we do not protect information leakage through the timing channel. Mitigating timing channel leakage has been treated in orthogonal literature <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b54">54,</ref><ref type="bibr" target="#b55">55]</ref>. Additionally, like in (almost) all prior ORAM literature, we assume that there is an a'priori known upper bound N on the total size of the data structure. This seems inevitable since the server must know how much storage to allocate. Similar to the ORAM literature, our oblivious data structures can also be resized on demand at the cost of 1-bit leakage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Oblivious algorithms. Customized oblivious algorithms for specific funtionalities have been considered in the past, and have been referred to by different names (partly due to the fact that the motivations of these works stem from different application settings), such as oblivious algorithms <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b22">22]</ref> or efficient circuit structures <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b53">53]</ref>.</p><p>The work by Zahur and Evans <ref type="bibr" target="#b53">[53]</ref> may be considered as a nascent form of oblivious data structures; however the constructions proposed do not offer the full gamut of common data structure operations. For example, their stacks and queues support special conditional update semantics; and their associative map supports only batched operations but not individual queries (supporting batched operations are significantly easier). Toft <ref type="bibr" target="#b47">[47]</ref> also studied efficient construction of oblivious priority queue. Their construction reveals the type of operations, and thus the size of the data structure. Our proposed construction only reveals number of operations with the same asymptotic bound.</p><p>Mitchell and Zimmerman <ref type="bibr" target="#b36">[36]</ref> observe that Oblivious Turing Machine <ref type="bibr" target="#b39">[39]</ref> can also be leveraged to build oblivious stacks and queues yielding an amortized O(log N ) blowup (but worst-case cost is O(N )); however, the O(log N ) oblivious TM-based approach does not extend to more complex data structures such as maps, sets, etc.</p><p>Blanton, Steele and Alisagari <ref type="bibr" target="#b7">[7]</ref> present oblivious graph algorithms, such as breadth-first search, single-source singledestination (SSSD), minimum spanning tree and maximum flow with nearly optimal complexity on dense graphs. Our work provides asymptotically better algorithms for special types of sparse graphs, and for repeated queries. See Section 5 for details.</p><p>Oblivious program execution. The programming language community has started investigating type systems for memory-trace obliviousness, and automatically compiling programs into their memory-trace oblivious counterparts <ref type="bibr" target="#b30">[30]</ref>. Efficiency improvements may be achieved through static analysis. The main idea is that many memory accesses of a program may not depend on sensitive data, e.g., sequentially scanning through an array to find the maximal element. In such cases, certain arrays may not need to be placed in ORAMs; and it may be possible to partition arrays into multiple ORAMs without losing security. While effective in many applications, these automated compiling techniques currently only leverage ORAM as a blackbox, and cannot automatically generate asymptotically more efficient oblivious data structures.</p><p>Generic oblivious RAM. The relations between oblivious data structures and generic ORAM <ref type="bibr">[9, 11, 15-21, 28, 38, 41, 43, 49-51]</ref> have mostly been addressed earlier. We add that in the secure computation setting involving two or more parties, it is theoretically possible to employ the ORAM scheme by Lu and Ostrovsky <ref type="bibr" target="#b32">[32]</ref> to achieve O(log N ) blowup. However, their ORAM does not work for a cloud outsourcing setting with a single cloud, or a secure processor setting. Further, while asymptotically non-trivial, their scheme will likely incur a large blowup in a practical implementation due to the need to obliviously build Cuckoo hash tables.</p><p>History-independent data structures. Oblivious data structures should not be confused with history-independent data structures (occasionally also referred as oblivious data structures) <ref type="bibr">[8,</ref><ref type="bibr" target="#b35">35]</ref>. History-independent data structures require that the resulting state of the data structure reveals nothing about the histories of operation; and do not hide access patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concurrent work.</head><p>In concurrent work, Keller and Scholl <ref type="bibr" target="#b27">[27]</ref> implemented secure oblivious data structures using both the binary-tree ORAM <ref type="bibr" target="#b41">[41]</ref>, and the Path ORAM <ref type="bibr" target="#b44">[44]</ref>. They leverage the technique suggested by Gentry et al. <ref type="bibr" target="#b15">[15]</ref> in the implementation of the shortest path algorithm, achieving O(log N ) asymptotic saving. They do not generalize this approach for dynamic data structures, nor do they consider other access pattern graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROBLEM DEFINITION</head><p>A data structure D is a collection of data supporting certain types of operations such as insert, del, or lookup. Every operation is parameterized by some operands (e.g., the key to look up). Intuitively, the goal of oblivious data structures is to ensure that for any two sequences each containing k operations, their resulting access patterns must be indistinguishable. This implies that the access patterns, including the number of accesses, should not leak information about both the op-code and the operand.</p><p>Definition 1 (Oblivious data structure). We say that a data structure D is oblivious, if there exists a polynomialtime simulator S, such that for any polynomial-length sequence of data structure operations ops = ((op 1 , arg 1 ), . . . ,</p><formula xml:id="formula_2">(op M , arg M )) addressesD( ops) c ≡ S(L( ops))</formula><p>where addressesD( ops) is the physical addresses generated by the oblivious data structure during a sequence of operations ops; and L( ops) is referred to as the leakage function. Typically we consider that L( ops) = M , i.e., the number of operations is leaked, but nothing else.</p><p>Intuitively, this definition says that the access patterns resulting from a sequence of data structure operations should reveal nothing other than the total number of operations. In other words, a polynomial-time simulator S with knowledge of only the total number of operations, can simulate the physical addresses, such that no polynomial-time distinguisher can distinguish the simulated addresses from the real ones generated by the oblivious data structure.</p><p>Note that directly using standard ORAM may not be able to satisfy our definition, since information may leak through the number of accesses. Specifically, some data structure operations incur more memory accesses than others; e.g., an AVL tree deletion will likely incur rotation operations, and thus incur more memory accesses than a lookup operation. Therefore, even if we were to employ standard ORAM, padding might be needed to hide what data structure operation is being performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Model and Metric</head><p>Bandwidth blowup. In order to achieve obliviousness, we need to access more data than we need. Roughly speaking, the bandwidth blowup is defined as the ratio of the number of bytes transferred in the oblivious case over the non-oblivious baseline.</p><p>Since we hide the type of the data structure operation, the number of bytes transferred in the oblivious case is the same across all operations of the same data structure instance. However, the number of bytes transferred in the non-oblivious case may vary across operation. For most of the cases we consider, the number of bytes transferred for each operation are asymptotically the same. Further, the average-case cost and worst-case cost in the non-oblivious case are also asymptotically the same. In these cases, we do not specify which individual operation is considered when we mention bandwidth blowup.</p><p>Model. Results using our pointer-based techniques apply to the standard RAM model with uniform block sizes. Results relying on our locality-based techniques apply to a slight variant of the standard RAM model, where blocks may be of non-uniform size. This assumption is the same as in previous work such as Path ORAM <ref type="bibr" target="#b44">[44]</ref>, which relied on a "big data block, little metadata block" trick to parameterize the recursions on the position map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ROOTED TREES WITH BOUNDED DE-GREE</head><p>Numerous commonly used data structures (e.g., stacks, map/set, priority-queue, B-trees, etc.) can be expressed as a rooted tree with bounded degree. Each data access would start at the root node, and traverse the nodes along the tree edges. In these cases, the access pattern graph would naturally be a bounded-degree tree as well. In this section, we describe a pointer-based technique that allows us to achieve O(log N ) blowup for such access pattern graphs. In comparison, the best known ORAM scheme has O( log 2 N log log N ) blowup. Our ideas are inspired by those of Gentry et al. <ref type="bibr" target="#b15">[15]</ref> who showed how to leverage a position-based ORAM to perform binary search more efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Building Block: Non-Recursive Positionbased ORAM</head><p>To construct oblivious data structures, an underlying primitive we rely on is a position-based ORAM. Several ORAM schemes have been proposed in the recent past that rely on the client having a position map <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b44">44]</ref> that stores a location label for each block. By recursive, we mean the position map is (recursively) stored on the server, as opposed to non-recursive, where the position map is entirely stored by the client. So far, Path ORAM <ref type="bibr" target="#b44">[44]</ref> achieves the least A logical binary search tree is on the left, and on the right-hand side is how these nodes are stored in a (non-recursive) positionbased ORAM. Every position tag specifies a path to a leaf node on the tree. Every parent points to the position tags of its children such that we can eliminate the need for position map lookups, thus saving an O(log N ) factor in comparison with generic ORAM. This is a generalization of the techniques described by Gentry et al. <ref type="bibr" target="#b15">[15]</ref> for performing binary search with ORAM. blowup of O(log N ) for the non-recursive case, or the recursive case when the data block size is Ω(log 2 N ) bits. We shall use Path ORAM by default.</p><p>For a client to look up a block with identifier id, the client must first look up its locally stored position map to obtain a location pos for block id. This pos records the rough location (e.g., either a tree path <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b44">44]</ref>, or a partition <ref type="bibr" target="#b43">[43]</ref>) of block id. Knowing pos, the client will then know from which physical addresses on the server to fetch blocks.</p><p>When a data block is read, it will be removed from the ORAM and assigned a new location denoted pos . The block is then written back to the server attached with its new location tag, i.e., data||pos . If this is a read operation, data is simply a re-encryption of the fetched block itself; if this is a write operation, data will be the newly written block.</p><p>We use the following abstraction for a position-based ORAM scheme. Although any (non-recursive) position-based ORAM <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b44">44]</ref> will work for our construction (potentially resulting in different performance); for simplicity, we often assume that Path ORAM is the underlying position-based ORAM.</p><p>ReadAndRemove(id, pos): fetches and removes from server a block identified by id. pos is the position tag of the block, indicating a set of physical addresses where the block might be.</p><p>Add(id, pos, data): writes a block denoted data, identified by id, to some location among a set of locations indicated by pos.</p><p>In standard ORAM constructions, to reduce the client storage required to store the position map, a recursion technique has been suggested <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b43">43]</ref> to recursively store the position map in smaller ORAMs on the server. However, this will lead to a blowup of O(log 2 N ).</p><p>Inspired by the binary search technique proposed by Gentry et al. <ref type="bibr" target="#b15">[15]</ref> in the context of RAM-model secure computation, we propose a technique that allows us to eliminate the need to perform recursive position map lookups, thus saving an O(log N ) cost for a variety of data structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Oblivious Data Structure</head><p>We first explain our data representation and how oblivious AVL tree can be implemented securely. We show that a factor of O(log N ) can be saved by eliminating the need to recursively store the position map. The detailed general framework with dynamic access algorithms can be found in <ref type="bibr" target="#b48">[48]</ref>.</p><p>Node format. In an oblivious data structure, every node is tagged with some payload denoted data. If there is an edge from vertex v to vertex w in the access pattern graph, then it means that one can go from v to w during some data structure operation.</p><p>In the oblivious data structure, every node is identified by some identifier id along with its position tag pos. The node also stores the position tags of all of its children. Therefore, the format of every node will be node := (data, id, pos, childrenPos)</p><p>In particular, childrenPos is a mapping from every child id to its position tag. We write childrenPos <ref type="bibr">[idc]</ref> to denote the position tag of a child identified by idc. In the rest of the paper, unless otherwise specified, a node will be the basic unit of storage.</p><p>All nodes will be (encrypted and) stored in a (non-recursive) position-based ORAM on the server. The client stores only the position tag and identifier of the root of the tree.</p><p>Oblivious map insertion example. To illustrate dynamic data structures, we rely on AVL tree (used to implement oblivious map) insertion as a concrete example. Figure <ref type="figure" target="#fig_1">2</ref> illustrates this example. The insertion proceeds as follows: first, find the node at which the insertion will be made; second, perform the insertion; and third, perform rotation operations to keep the tree balanced.</p><p>During this operation O(log N ) nodes will be accessed, and some nodes may be accessed twice due to the rotation that happens after the insertion is completed. Further, among the nodes accessed, the graph structure will change as a result of the rotation.</p><p>Notice that once a node is fetched from the server, its position tag is revealed to the server, and thus we need to generate a new position tag for the node. At the same time, this position tag should also be updated in its parent's children position list. Our key idea is to rely on an O(log N )-sized client-side cache, such that all nodes relevant for this operation are fetched only once during this entire insertion operation. After these nodes are fetched and removed from the server, they will be stored in the client-side cache, such that the client can make updates to these nodes locally before writing them back. These updates may include insertions, removals, and modifying graph structures (such as rotations in the AVL tree example). Finally, at the end of the operation, all nodes cached locally will be written back to the server. Prior to the write-back, all fetched nodes must be assigned random new position tags, and their parent nodes must be appropriately modified to point to the new position tags of the children.</p><p>This approach gives us O(log N ) blowup at the cost of a client-side cache of size O(log N ). Since the client-side cache allows us to read and write this O(log N )-length path only once for the entire insertion operation, and each node requires O(log N ) cost using (non-recursive) Path ORAM as the underlying position-based ORAM, the bandwidth overhead is O(log N ) -since in the oblivious case, the total I/O Padding. During a data structure operation, cache misses will generate requests to the server. The number of accesses to the server can leak information. Therefore, we pad the operation with dummy ReadAndRemove and Add accesses to the maximum number required by any data structure operation. For example, in the case of an AVL tree, the maximum number of ReadAndRemove operations and the maximum number of Add operations is 3× 1.45 log(N +2) .</p><p>It should be noted that ReadAndRemove is padded before a real Add happens and hence all ReadAndRemove calls in an operation happen before the first Add.</p><p>A generalized framework for oblivious data structures. We make the following observations from the above example:</p><p>• The algorithm accesses a path from the root down to leaves. By storing the position tag for the root, all positions can be recovered from the nodes fetched. This eliminates the need to store a position map for all identifiers.</p><p>• After the position tags are regenerated, the tag in every node's childrenPos must also be updated. So we require that every node has only one parent, i.e., the access pattern graph is a bounded-degree tree.</p><p>The above technique can be generalized to provide a framework for designing dynamic oblivious data structures whose access pattern graphs are bounded-degree trees. Based on this framework for constructing oblivious data structures, we derive algorithms for oblivious map, queue, stack, and heap. Due to space constraints, we defer the detailed algorithms, implementations of different oblivious data structures as well as some practical consideration to the online full version of this paper <ref type="bibr" target="#b48">[48]</ref>.</p><p>Cluster (4,1) (0,0) Proof can be found in the online version. <ref type="bibr" target="#b48">[48]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ACCESS PATTERN GRAPHS WITH LOW DOUBLING DIMENSION</head><p>As seen in Section 3, we can achieve O(log N ) blowup when the access pattern graph is a rooted tree where edges are directed towards children. In this section, we consider another class of access pattern graphs whose locality property will be exploited. Recall that the access pattern graph is directed, and we consider the underlying undirected graph G = (V, E), which we assume to be static. Intuition. The key insight is that if the block size is Ω(log 2 N ) bits, then (recursive) Path ORAM can achieve O(log N ) blowup <ref type="bibr" target="#b44">[44]</ref>. Hence, we shall partition V into clusters, each of which contains at most log N nodes. To make the data structure oblivious, we need to pad a cluster with dummy nodes such that each cluster contains exactly log N nodes. Assuming that each node has size Ω(log N ) bits, each cluster corresponds to Ω(log 2 N ) bits of data and will be stored as a generic ORAM block.</p><p>Hence, by accessing one cluster, we are storing the data of log N nodes in the client cache, each with a bandwidth blowup of O(log N ). If these nodes are useful for the next T iterations, then the amortized blowup is O( log 2 N T ). To understand how these clusters can be helpful, consider the following special cases of access pattern graphs.</p><p>• For doubly-linked list and deque, the access pattern graph is a (1-dimensional) path. In this case, each cluster is a contiguous sub-path of log N nodes. Observe that starting at any node u, after log N iterations, we might end up at a node v that might not be in the same cluster as u. However, node v must be in a neighboring cluster to the left or the right of u. This suggests that we should pre-fetch the data from the 2 neighboring clusters, in addition to the cluster of the current node. This will make sure that in the next log N iterations, the cache will already contain the data for the accessed nodes.</p><p>• If the access pattern graph is a 2-dimensional grid, then each cluster is a sub-grid of dimensions √ log N by √ log N as shown in Figure <ref type="figure">3</ref>. Observe that by pre-fetching the 8 neighboring clusters surrounding the cluster containing the current node, we can make sure that the cache contains data of the accessed nodes in the next √ log N iterations. Therefore, the blowup for those</p><formula xml:id="formula_3">√ log N iterations is 9 • ( √ log N • √ log N ) • O(log N</formula><p>), which gives an amortized blowup of O(log 1.5 N ). It is not difficult to see that for the d-dimensional grid, each cluster can be a hypercube with log The d-dimensional grid is a special case of a wider class of graphs with bounded doubling dimension <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b24">24]</ref>. Doubling dimension. We consider the underlying undirected graph G = (V, E) of the access pattern graph in which we assign each edge with unit length. We use dG(u, v) to denote the shortest path distance between u and v. A ball centered at node u with radius r is the set B(u, r) := {v ∈ V : dG(u, v) ≤ r}. We say that graph G has doubling dimension at most dim if every ball is contained in the union of at most 2 dim balls of half its radius. A subset S ⊂ V is an r-packing if for any pair of distinct nodes u, u ∈ S, d(u, u ) &gt; r. We shall use the following property of doubling dimension.</p><p>Fact 1 (Packings Have Small Size <ref type="bibr" target="#b24">[24]</ref>). Let R ≥ r &gt; 0 and let S ⊆ V be an r-packing contained in a ball of radius R. Then, |S| ≤ ( 4R r ) dim .</p><p>Blowup analysis sketch. We shall see that Fact 1 implies that pre-fetching O(1) dim clusters is enough to support Θ(log</p><formula xml:id="formula_4">1</formula><p>dim N ) node accesses. Hence, the amortized blowup for each access is O(1) dim • O(log 2-1 dim N ). Setting up oblivious data structure on server. We describe how the nodes in V are clustered, and what information needs to be stored in each cluster.</p><p>• Greedy Partition. Initially, the set U of uncovered nodes contains every node in V . In each iteration, pick an arbitrary uncovered node v ∈ U , and form a cluster Cv := {u ∈ U : dG(u, v) ≤ ρ} with radius ρ := 1 4 log 1 dim N ; remove nodes in Cv from U , and repeat until U becomes empty. From Fact 1, the number of clusters is at most O(∆) dim log N , where ∆ := maxu,v dG(u, v).</p><p>• Padding. By Fact 1, each cluster contains at most log N nodes. If a cluster contains less than log N nodes, we pad with dummy nodes to achieve exactly log N nodes.</p><p>• Cluster Map. We need a generic ORAM to look up in which cluster a node is contained. However, this is required only for the very first node access, so its cost can be amortized by the subsequent accesses. As we shall see, all necessary information will be in the client cache after the initial access.</p><p>• Neighboring Clusters. Each cluster corresponds to an ORAM block, which stores the data of its nodes. In addition, each cluster also stores a list of all clusters whose centers are within 3ρ from its center. We say that two clusters are neighbors if the distance between their cluster centers is at most 3ρ. From Fact 1, each cluster has at most 12 dim neighboring clusters.</p><p>Algorithm for node accesses. We describe the algorithm for node accesses in Figure <ref type="figure" target="#fig_5">4</ref>. An important invariant is that the node to be accessed in each iteration is already stored in cache when needed.</p><p>Lemma 1 (Cache Invariant). In each iteration i, the ORAM block corresponding to the cluster containing ui is already stored in cache in lines 13 to 17.</p><p>Theorem 2. Algorithm in Figure <ref type="figure" target="#fig_5">4</ref> realizes oblivious data structures that are secure by Definition 1. When the number of node accesses is at least ρ = Θ(log</p><formula xml:id="formula_5">1 dim N ), it achieves amortized O(12 dim log 2-1 dim N ) bandwidth blowup. Moreover, the client memory stores the data of O(12 dim log N )+O(log 2 N )• ω(1) nodes.</formula><p>Proof. The proofs can be found in Appendix A.</p><p>Dynamic access pattern graph. Our data structure can support limited insertion or deletion of nodes in the access pattern graph, as long as the doubling dimension of the resulting graph does not exceed a preset upper bound dim and some more detailed conditions are satisfied. We defer details to the online version <ref type="bibr" target="#b48">[48]</ref>.</p><p>Finally, note that Ren et al. <ref type="bibr" target="#b40">[40]</ref> proposed a new technique to reduce the block size assumption to Ω( log 2 N log log N ). Their technique is also applicable here to slightly improve our bounds -however, due to the use of PRFs, we would now achieve computational rather than statistical security. Further, this technique would be expensive in the secure computation context due to the need to evaluate the PRF over a secure computation protocol such as garbled circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CASE STUDIES</head><p>Oblivious dynamic memory allocator. We apply our pointer-based technique for ODS to an important operating system task: memory management. A memory management task consists of two operations: dynamically allocating a portion of memory to programs at their request, and freeing it for reuse. In C convention, these two operations are denoted by malloc(l) and free(p). The security requirement of the oblivious memory allocator is that the physical addresses accessed to the allocator's working memory should not reveal any information about the opcode (i.e., malloc or free) or the operand (i.e., how many bytes to allocate and which address to free).</p><p>Since the total number of memory accesses may still leak information, naive extensions to existing memory management algorithms using ORAM are not secure. Padding in this case results in a secure but inefficient solution. We develop a new memory management algorithm which stores metadata in a tree-like structure, which can be implemented as an ODS, so that each memory allocation operation can be executed in the same time as one ORAM operation.</p><p>We develop a new oblivious memory allocator to achieve O(log  For simplicity, imagine that both the program and the oblivious memory allocator reside in the secure processor's instruction cache. Securely executing programs (or a memory allocator) that reside in insecure memory is discussed in orthogonal work <ref type="bibr" target="#b30">[30]</ref> and outside the scope here. stored separately from the data ORAM. Figure <ref type="figure" target="#fig_4">5</ref> illustrates this architecture <ref type="foot" target="#foot_0">1</ref> .</p><p>The intuition is that if we treat the memory as a segment of size N , then the malloc and free functionalities are extracting a segment of a given size from the memory, and inserting a segment into the memory respectively. We construct a tree structure with nodes corresponding to segments, which is also called segment tree <ref type="bibr" target="#b6">[6]</ref>. The root of the tree corresponds to the segment [0, N ). Each node corresponding to [a, b) where a + 1 &lt; b has two children corresponding to [a, a+b 2 ) and [ a+b 2 , b) respectively. Nodes corresponding to [a, a + 1) are leaf nodes. It is easy to see that the height of a segment tree of size N is O(log N ). The metadata memory is stored with these segments respectively. For each access, we will travel along one or two paths from the root to leaf, which can fit into our ODS framework. We state our result and include the details in the full version <ref type="bibr" target="#b48">[48]</ref>.</p><p>Theorem 3. The oblivious memory allocator described above requires transmitting O(log 3 N ) bits per operation.</p><p>Shortest path on planar graph. We consider shortest distance queries on a weighted undirected planar graph. A naive approach is to build an all-pairs shortest distance matrix offline, so that each online query can be performed by a matrix lookup. On storing the matrix in an ORAM, the query can be computed within O(log 2 N ) runtime, where N is the number of vertices in the graph. Recall that a planar graph is sparse and has O(N ) edges. By using Dijkstra's algorithm to compute the shortest distances from each single source, the total runtime for the offline process is within O(N 2 log N ), while the space is O(N 2 ). We notice on a large graph, i.e. N ≥ 2 20 , the space and offline runtime is impractical.</p><p>We present an alternative approach using the planar separator theorem <ref type="bibr" target="#b29">[29]</ref>. Using our locality-based approach, we can achieve oblivious versions of the construction with O(N 1.5 log 3 N ) offline processing time, O(N 1.5 ) space complexity, at the cost of O( √ N log N ) online query time.</p><p>In iteration i, Access(ui, op, data) is performed, where node ui is accessed, op is either Read or Write, and data is written in the latter case. We maintain the invariant that cache contains the cluster containing ui.</p><p>1: ρ = 1 4 log 1 dim N 2: i = 0 3: Look up cluster C0 containing u0 from the cluster map. 4: Read the ORAM block corresponding to C0 from the server into cache. 5: for i from 0 do 6:</p><p>Access(ui, op, data): 7:</p><p>if i mod ρ = 0 then 8:</p><p>Ci is the cluster containing ui, which is currently stored in cache by the invariant. 9:</p><p>Li is the list of neighboring clusters of Ci. 10:</p><p>Read clusters in Li from the ORAM server into cache; perform dummy reads to ensure exactly 12 dim clusters are read.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>Write back non-neighboring clusters of Ci from cache to ORAM server; perform dummy writes to ensure exactly 12 dim clusters are written back. 12:</p><p>end if 13:</p><p>if op = Read then 14:</p><p>Read data of node ui from cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15:</head><p>else if op = Write then 16:</p><p>Update data of node ui in cache. 17:</p><p>end if 18:</p><p>return data 19: end for Max flow on sparse graphs. We apply our oblivious data structure to solve the problem of maximum flow, and compare our approach with that of Blanton et al. <ref type="bibr" target="#b7">[7]</ref>, which focuses on the case when the graph is dense. We assume that the underlying undirected graph G = (V, E) is fixed, and has doubling dimension at most dim. Since the degree of each node is at most 2 dim , the graph is sparse, and we assume that each block stores information concerning a node and its incident edges. A one-time setup phase is performed to construct the oblivious data structure in the ORAM server with respect to the graph G. This can support different instances of maximum flow in which the source, the sink, and the capacities of edges (in each direction) can be modified.</p><p>Similar to <ref type="bibr" target="#b7">[7]</ref>, we consider the standard framework by Ford and Fulkerson <ref type="bibr" target="#b14">[14]</ref> in which an augmenting path is found in the residual network in each iteration. There is a strongly polynomial-time algorithm that takes O(|E| • |V |) path augmentations, in which each augmenting path is found by BFS. In <ref type="bibr" target="#b7">[7]</ref>, the adjacency matrix is permuted for every BFS, which takes time</p><formula xml:id="formula_6">O(|V | 2 log |V |); hence, their running time is O(|V | 3 • |E| log |V |).</formula><p>However, we can perform only DFS using our localitybased technique. Hence, we consider a capacity scaling version of the algorithm in which the capacities are assumed to be integers and at most C. Hence, the running time of the (non-oblivious) algorithm is O(|E| 2 log C), which is also an upper bound on the number of node accesses. By Theorem 2, our running time is O(12 dim • |E| 2 log C log 2-1 dim |V |); in particular, our algorithm is better than <ref type="bibr" target="#b7">[7]</ref>, for sparse graphs, even when C = 2 |V | .</p><p>Random walk on graphs with bounded doubling dimension. In many computer science applications (e.g., <ref type="bibr" target="#b4">[4]</ref>), random walk is used as a sub-routine. Since a random walk on a graph with bounded doubling dimension only needs to keep local information, our locality-based tech-niques in Theorem 2 is applicable to achieve a blowup of O(12 dim log 2-1 dim |V |) for every step of the random walk.</p><p>6. EVALUATION</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Methodology and Metrics</head><p>We evaluate the bandwidth blowup for our oblivious data structures with various application scenarios in mind, including cloud outsourcing <ref type="bibr" target="#b43">[43]</ref>, secure processors <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b34">34]</ref>, and secure computation <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b23">23,</ref><ref type="bibr" target="#b31">31]</ref>. Below we explain the metrics we focus on, and our methodology in obtaining the performance benchmarks.</p><p>Bandwidth blowup. Recall that bandwidth blowup is defined as the ratio of the number of bytes transferred in the oblivious case over the non-oblivious baseline. Bandwidth blowup is the most important metric for the secure processor and the outsourced cloud storage applications, since bandwidth will be the bottleneck in these scenarios.</p><p>For our evaluation of bandwidth blowup, we use Path ORAM <ref type="bibr" target="#b44">[44]</ref> to be our underlying position-based ORAM. We parameterize Path ORAM with a bucket size of 4, and the height of the tree is set to be log N where N is the maximum number of nodes in the tree.</p><p>We compare our oblivious data structures against Path ORAM (with a bucket size of 4 and tree height log N ), where the position map is recursively stored. For recursion of position map levels, we store 32 position tags in each block. We note while parameters of the Path ORAM can potentially be further tuned to give better performance, it is outside the scope of the paper to figure out the optimal parameters for Path ORAM.</p><p>Number of encryptions for secure computation. We also consider a secure computation application. This part of the evaluation focuses on an encrypted database query  We use the semi-honest, RAM-model secure computation implementation described in <ref type="bibr" target="#b31">[31]</ref>, which further builds on the FastGC garbled circuit implementation by Huang. et al. <ref type="bibr" target="#b25">[25]</ref>, incorporating frameworks by Bellareet al. <ref type="bibr" target="#b5">[5]</ref>. We use the binary-tree ORAM by Shi et al. <ref type="bibr" target="#b41">[41]</ref> in our ODS implementation as the position-based ORAM backend. Similarly, we compare with an implementation of the binary-tree ORAM <ref type="bibr" target="#b41">[41]</ref>. For the general ORAM baseline, the position map recursion levels store 8 position tags per block, until the client stores 1, 000 position tags (i.e., roughly 1KB of position tags). We follow the ORAM encryption technique proposed by Gordon et al. <ref type="bibr" target="#b23">[23]</ref> for implementing the binary-tree ORAM: every block is xor-shared while the client's share is always an output of client's secret cipher. This adds 1 additional cipher operation per block (when the length of an ORAM block is less than the width of the cipher). We note specific choices of ORAM parameters in related discussion of each application.</p><p>In secure computation, the bottleneck is the cost of generating and evaluating garbled circuits (a metric that is related to bandwidth blowup but not solely determined by bandwidth blowup). We therefore focus on evaluating the cost of generating and evaluating garbled circuits for the secure computation setting.</p><p>We use the number of symmetric encryptions (AES) as performance metric. Measuring the performance by the number of symmetric encryptions (instead of wall clock time) makes it easier to compare with other systems since the numbers can be independent of the underlying hardware and ciphering algorithms. Additionally, in our experiments these encryption numbers also represent the bandwidth consumption since every ciphertext will be sent over the network in a Garbled Circuit backend. Modern processors with AES support can compute 10 8 AES-128 operations per second <ref type="bibr" target="#b1">[1]</ref>.</p><p>We assume that the oblivious data structure is setup once at the beginning, whose cost hence can be amortized to later queries. Therefore, our evaluation focuses on the online part. The online cost involves three parts: i) the cost of preparing input, which involves Oblivious Transfer (OT) for input data; ii) the cost of securely computing the functionality of the position-based ORAM; and iii) securely evaluating the computation steps in data structure operations (e.g., comparisons of lookup keys).</p><p>Methodology for determining security parameters. We apply the standard methodology for determining security parameters for tree-based ORAMs <ref type="bibr" target="#b44">[44]</ref> for our oblivious data structures. Specifically, we warm-up our underlying position-based ORAM with 16 million accesses. Then, due to the observation that time average is equal to ensemble average for regenerative processes, we simulate a long run of 1 billion accesses, and plot the stash size against the security parameter λ. Since we cannot simulate "secure enough" values of λ, we simulate for smaller ranges of λ, and extrapolate to the desired security parameter, e.g., λ = 80.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Oblivious Data Structures</head><p>Bandwidth blowup results. Figure <ref type="figure" target="#fig_7">6</ref> shows the bandwidth blowup for different data structures when payload is 64 Bytes. Note that because of the similarity in the implementation of Oblivious Stack and Oblivious Queue, their bandwidth blowup is the same; and therefore they share the same curve.</p><p>As shown in the Figure <ref type="figure" target="#fig_7">6</ref>, the blowup for our ODS grows linear with log N , which confirms the result shown in Table 1. The red curves show the blowup of naively building data structures over recursive ORAM. The graphs show that our oblivious data structure constructions achieve 4×-16× speedup in comparison with Path ORAM, for a data structure containing N = 2 30 nodes.</p><p>The aforementioned bandwidth blowup results are obtained while consuming a small amount of client-side storage. We evaluated the client size storage with maximum 2 20 nodes and payload 64 Bytes for different oblivious data structures, and the results are shown in Figure <ref type="figure">7</ref>. The clientside storage is split between 1) the cache consumed by the ODS client (dark grey part in the bar plot); and 2) the overflow stash required by the underlying Path ORAM (light grey part in the bar plot), which depends on the security parameter. In Figure <ref type="figure">7</ref>, we present client storage needed with security parameter of 80, 128 and 256. For each value, we plot the space needed for oblivious data structure and naively building over recursive ORAM side by side. Result for other data structures can be found in online full version <ref type="bibr" target="#b48">[48]</ref>.</p><p>Secure computation results. Figure <ref type="figure" target="#fig_9">8</ref> shows the result for our secure computation setting. In these experiments, the payload is 32-bit integers, and for applicable data struc-   tures, the key is also 32-bit integers. The results show that our oblivious data structures achieve 12×-15× speedup in comparison with a general ORAM-based approach. We also compare the amount of data transmitted in secure computation for our oblivious AVL tree and AVL tree built over ORAM directly in Figure <ref type="figure">9</ref>. For log N = 20, the amount of data transmitted is reduced by 9×.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Evaluation Results for Case Studies</head><p>In this section, we provide results for additional case studies. In Section 5, we have explained the algorithms for these case studies, and their asymptotic performance gains.</p><p>Evaluation for dynamic memory allocation. We empirically compare the cost of our dynamic memory alloca-tor with the baseline chunk-based approach. As explained in Section 5, our construction achieves exponential savings asymptotically, in comparison with the naive approach.</p><p>Figure <ref type="figure" target="#fig_13">10a</ref> plots the amount of data transferred per memory allocation operation. We observe that our oblivious memory allocator is 1000 times faster than the baseline approach at memory size 2 30 (i.e., 1 GB).</p><p>Evaluation for random walk. For the random walk problem, we generate a grid of size N × N , where N goes from 2 10 to 2 20 . Each edge weight is a 16-bit integer.</p><p>Figure <ref type="figure" target="#fig_13">10b</ref> plots the bandwidth blowup versus log N . We observe a speedup from 1× to 2× as N varies from 2 10 to 2 28 . The irregularity at log N = 16, 25 is due to the roundingup for computing √ log N . At log N = 16, 25, √ log N is an integer, i.e., no rounding.</p><p>Evaluation for shortest path queries on planar graphs. We evaluate the shortest path query answering problem over a grid, which is a planar graph. The grid is of size N × N , where N + 1 is a power of 2. As described in Section 5, we build a separation tree for the planar graph graph, and each tree node corresponding to a subgraph. By choosing N such that N + 1 is a power of 2, it is easy to build the separation tree so that all subgraphs corresponding to nodes at the same height in the tree have the same size, which are either rectangles or squares. We build the tree recursively until the leaf nodes correspond to squares of size smaller than log 2 (N + 1).</p><p>We compare our optimized approach as described in Section 5 with the baseline approach which uses Path ORAM directly. Figure <ref type="figure" target="#fig_13">10c</ref> illustrates the bandwidth blowup for the two approaches as well as the speedup for log (N + 1) ranging from 5 to 19. We can observe a speedup from 2× to 14×.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION AND FUTURE WORK</head><p>We propose oblivious data structures and algorithms for commonly encountered tasks. Our approach outperforms generic ORAM both asymptotically and empirically. Our key observation is that real-world program has predictability in its access patterns that can be exploited in designing the oblivious counterparts. In our future work, we plan to implement the algorithms proposed in this paper. In particular, we wish to offer an oblivious data structure library for a secure multi-party computation.   knowledge the anonymous reviewers for their insightful comments and suggestions. This work is supported by several funding agencies acknowledged separately on the front page.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure1: Static oblivious binary search tree. A logical binary search tree is on the left, and on the right-hand side is how these nodes are stored in a (non-recursive) positionbased ORAM. Every position tag specifies a path to a leaf node on the tree. Every parent points to the position tags of its children such that we can eliminate the need for position map lookups, thus saving an O(log N ) factor in comparison with generic ORAM. This is a generalization of the techniques described by Gentry et al.<ref type="bibr" target="#b15">[15]</ref> for performing binary search with ORAM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Operations generated for insertion in an AVL Tree. Cache hit/miss behavior does not leak information due to the padding we perform to ensure that every operation, regardless of the opcode and operands, has an equal amount of ReadAndRemove and Add calls to the position-based ORAM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Theorem 1 .</head><label>31</label><figDesc>Figure 3: Accesses for 2 dimensional structure exhibiting locality. The red arrows indicate the path of the random walk for one set of √ log N accesses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 d</head><label>1</label><figDesc>N nodes on a side, and the number of neighboring clusters (including itself) is 3 d . Hence, the amortized blowup is O(3 d log 2-1 d N ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure5: Oblivious dynamic memory allocation. For simplicity, imagine that both the program and the oblivious memory allocator reside in the secure processor's instruction cache. Securely executing programs (or a memory allocator) that reside in insecure memory is discussed in orthogonal work<ref type="bibr" target="#b30">[30]</ref> and outside the scope here.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Algorithm for node accesses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Bandwidth blowup for various oblivious data structures in comparison with general ORAM. Payload = 64Bytes. The speedup curve has the y-axis label on the right-hand side.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Secure Computation over ODS vs. ORAM Payload = 32 bits. The speedup curve has the y-axis label on the right-hand side.</figDesc><graphic coords="10,89.66,218.19,167.37,104.71" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :Figure 9 :</head><label>79</label><figDesc>Figure 7: Client storage for our oblivious map/set and the general ORAM-based approach. N = 2 20 , payload = 64Bytes. 85%-95% of the client-side storage in our ODS is due to the overflow stash of the underlying position-based ORAM.</figDesc><graphic coords="10,89.66,218.19,167.37,104.71" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Data transferred in for dynamic memory allocation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Bandwidth blowup for shortest path queries on planar graphs. Payload size is 64 bits</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Applications of oblivious data structures in comparison with general ORAM. The y-axis of speedup curve is on right side. Figures evaluate the bandwidth consumption for a secure processor or cloud outsourcing application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>):</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>2 N ) memory accesses per operation. The oblivious memory allocator's working memory consists of metadata</figDesc><table><row><cell cols="2">Oblivious Dynamic Data Allocation</cell></row><row><cell cols="2">Secure Processor</cell></row><row><cell>Program</cell><cell>Oblivious Memory Allocator</cell></row><row><cell>ORAM</cell><cell>ODS</cell></row><row><cell>Protocol</cell><cell>Protocol</cell></row><row><cell>Data Memory</cell><cell>Meta Data Memory</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For simplicity, we assume the program fits in the instruction cache which resides in the secure processor</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We would like to thank Jonathan Katz for numerous helpful discussions. We gratefully ac-</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research is partially funded by the National Science Foundation under grant CNS-1314857, a Sloan Research Fellowship, Google Faculty Research Awards, Defense Advanced Research Projects Agency (DARPA) under contract FA8750-14-C-0057, as well as a grant from Hong Kong RGC under the contract HKU719312E. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the US government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. PROOFS</head><p>Proof of Lemma 1. We prove by induction on i. The initialization in lines 3 and 4 ensures that it holds for i = 0.</p><p>Suppose that the invariant holds for some i mod ρ = 0. It suffices to show that the invariant holds for all iterations j ∈ [i, i + ρ]. Lines 8 to 11 ensure that all neighboring clusters of Ci are stored in the cache. Recall that these are the clusters whose centers are at distance at most 3ρ from the center of Ci. Hence, it suffices to show that for each j ∈ [i, i + ρ], the center of the cluster containing j is at distance at most 3ρ from the center of Ci. This follows from the triangle inequality readily, because each node is at distance at most ρ from its cluster center, and dG(ui, uj) ≤ j -i ≤ ρ.</p><p>Proof of Theorem 2. Observe that exactly 12 dim ORAM blocks are read from and written to the server at iteration i mod ρ = 0. Hence, the security of the algorithm reduces to the security of the underlying ORAM.</p><p>Since we assume that each node contains at least Ω(log N ) bits, each cluster contains Ω(log 2 N ) bits. Since Path ORAM <ref type="bibr" target="#b44">[44]</ref> has O(log N ) blowup when the block size is at least Ω(log 2 N ) bits, it follows that the bandwidth blowup for our algorithm over ρ = Θ(log</p><p>Observe that the O(log 2 N ) initialization blowup in lines 3 and 4 can also be in this term. Therefore, the amortized blowup per access is O(12 dim log 2-1 dim N ), and from the algorithm description, cache stores at most 2 • 12 dim clusters, which correspond to at most O(12 dim log N ) nodes. An additional client memory to store O(log 2 N ) • ω(1) nodes is required for the stash in the underlying Path ORAM <ref type="bibr" target="#b44">[44]</ref>.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://grantmcwilliams.com/tech/technology/item/532-hardware-aes-showdown-via-padlock-vs-intel-aes-ni-vs-amd-hexacore" />
		<title level="m">Hardware AES showdown -via padlock vs intel AES-NI vs AMD hexacore</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Predictive black-box mitigation of timing channels</title>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="297" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Plongements lipschitziens dans R n</title>
		<author>
			<persName><forename type="first">P</forename><surname>Assouad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. Soc. Math. France</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="page" from="429" to="448" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Random sampling from a search engine&apos;s index</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gurevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Efficient garbling from a fixed-key blockcipher</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Keelveedhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<editor>S &amp; P</editor>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Cheong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Kreveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Overmars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry: Algorithms and Applications</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data-oblivious graph algorithms for secure computation and outsourcing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Steele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aliasgari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ASIACCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Strongly history-independent hashing with applications</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Golovin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Statistically-secure oram with</title>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1307.3699" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Nearest neighbor queries in metric spaces</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clarkson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Comput. Geom</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="63" to="93" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Perfectly secure oblivious RAM without random oracles</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Meldgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Privacy-preserving data-oblivious geometric algorithms for geographic data</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GIS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A secure processor architecture for encrypted computation on untrusted programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Maximal flow through a network</title>
		<author>
			<persName><forename type="first">Jr</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Fulkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Canadian Journal of Mathematics</title>
		<imprint>
			<date type="published" when="1956">1956</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimizing ORAM and using it efficiently for secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In PETS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards a theory of software protection and simulation by oblivious RAMs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Software protection and simulation on oblivious RAMs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Privacy-preserving access of outsourced data via oblivious RAM simulation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICALP</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Oblivious RAM simulation with efficient worst-case access overhead</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CCSW</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Practical oblivious storage</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In CODASPY</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Privacy-preserving group data access via stateless oblivious RAM simulation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Data-oblivious graph drawing model and algorithms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<idno>CoRR abs/1209.0756</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Secure two-party computation in sublinear (amortized) time</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Krell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Vahlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Bounded geometries, fractals, and low-distortion embeddings</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krauthgamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="534" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Faster Secure Two-Party Computation Using Garbled Circuits</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Malka</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Access pattern disclosure on searchable encryption: Ramification, attack and mitigation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuzu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kantarcioglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient, oblivious data structures for mpc</title>
		<author>
			<persName><forename type="first">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scholl</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/137. 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the (in)security of hash-based oblivious RAM and a new balancing scheme</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A Separator Theorem for Planar Graphs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Applied Mathematics</title>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Memory trace oblivious program execution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSF</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Automating efficient RAM-model secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<editor>IEEE S &amp; P</editor>
		<imprint>
			<date type="published" when="2014-05">May 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Distributed oblivious RAM for secure two-party computation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">How to garble ram programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Phantom: Practical oblivious computation in a secure processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Oblivious data structures: applications to cryptography</title>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Data-Oblivious Data Structures</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zimmerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Privacy-preserving matrix factorization</title>
		<author>
			<persName><forename type="first">V</forename><surname>Nikolaenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Weinsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Taft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Private information storage (extended abstract)</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Relations among complexity measures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<editor>J. ACM</editor>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Unified oblivious-ram: Improving recursive oram with locality and pseudorandomness</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/205. 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Oblivious RAM with O((log N ) 3 ) worst-case cost</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Oblivistore: High performance oblivious cloud storage</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Towards practical oblivious RAM</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Path ORAM -an extremely simple oblivious ram protocol</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Aegis: architecture for tamper-evident and tamper-resistant processing</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gassend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Architectural support for copy and tamper resistant software</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L C</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Secure data structures based on multi-party computation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Toft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="291" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Oblivious data structures</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/185. 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pir</forename><surname>Usable</surname></persName>
		</author>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Round-optimal access privacy on outsourced storage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Building castles out of mud: practical access pattern privacy and correctness on untrusted storage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Carbunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Privatefs: A parallel oblivious file system</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tomescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Circuit structures for improving efficiency of security and privacy tools</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zahur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<editor>S &amp; P</editor>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Predictive mitigation of timing channels in interactive systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="563" to="574" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Language-based control and mitigation of timing channels</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="99" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Hide: an infrastructure for efficiently protecting information leakage on the address bus</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="72" to="84" />
			<date type="published" when="2004-10">Oct. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
