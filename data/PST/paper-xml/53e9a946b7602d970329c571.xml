<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Failure-Friendly Design Principle for Hash Functions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stefan</forename><surname>Lucks</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Mannheim</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Failure-Friendly Design Principle for Hash Functions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">33DBA17388633DFEE3A0AC64684EC11E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>hash function</term>
					<term>provable security</term>
					<term>multi-collision</term>
					<term>failure-friendliness</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper reconsiders the established Merkle-Damgård design principle for iterated hash functions. The internal state size w of an iterated n-bit hash function is treated as a security parameter of its own right. In a formal model, we show that increasing w quantifiably improves security against certain attacks, even if the compression function fails to be collision resistant. We propose the wide-pipe hash, internally using a w-bit compression function, and the double-pipe hash, with w = 2n and an n-bit compression function used twice in parallel.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A cryptographic hash function H : {0, 1} * → {0, 1} n maps an infinite set of inputs to the finite set of n-bit hash values. While collisions (inputs X = Y with H(X) = H(Y )) necessarily exist, a hash function should be collision resistant: given H, it should be infeasible for an adversary to actually find any collisions. But what if a hash function fails to be collision resistant? This paper deals with failure-friendly hash functions providing some security even if collision resistance has failed. It has been inspired by recent advances in collision finding <ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b0">1]</ref>.</p><p>The design of today's cryptographic hash functions ubiquitously follows the Merkle/Damgård (MD) structure <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b5">6]</ref>, iterating some underlying compression function. The hash function is collision resistant, if the compression function is. However, if computing a compression function collision is somehow feasible, the hash function may fail worse than expected. E.g., finding multiple collisions should be way more expensive than finding plain (2-)collisions -but Joux <ref type="bibr" target="#b10">[11]</ref> disproved this for the MD design. Also, MD hash functions completely fail to defend against 2nd collision attacks: If H(M ) = H(N ) for any two messages M , N , then H(M ||S) = H(N ||S) for all S ∈ {0, 1} n . (Technically, this assumes M and N to be "extended messages", see below.) In other words, given a single collision, an adversary can easily construct many more collisions. This has long been known, but recently been exploited to turn "random" collisions (as, e.g., for MD5 <ref type="bibr" target="#b25">[26]</ref>) into "meaningful" ones <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>. Even a 2nd preimage like scenario is possible <ref type="bibr" target="#b6">[7]</ref>: given any two texts T 1 and T 2 , Daum and Lucks presented two corresponding PostScript files with identical MD5 hashes.</p><p>Our Contributions. This paper describes and analyses failure-friendly iterated hash functions. The goal is to defend against certain classes of attacks even if collision resistance fails. We propose and analyse variants of the Merkle-Damgård design, increasing the internal state to w &gt; n bits. The wide-pipe hash is quite similar to the Merkle-Damgård hash, except for using a "largish" w-bit compression function to finally generate n &lt; w bits of output. The double-pipe hash sets w = 2n and employs one single n-bit compression function, used twice in parallel for each message block. In random and standard model settings, we prove the security of our schemes against K-collision attacks (for K ≥ w), and K-way preimage and 2nd preimage attacks (for K ≥ 1). Additionally, we discuss and semi-formally verify the resistance against 2nd collision attacks. Related Proposals. The double-pipe hash may remind the readers of the RIPEMD-family of hash functions <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b7">8]</ref>, also calling two compression functions in parallel. The hash functions specified in <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b7">8]</ref> combine both n-bit compression values into a single n-bit state, strictly following the Merkle-Damgård design principle, thus being as failure-unfriendly as any Merkle-Damgård hash function. But <ref type="bibr" target="#b7">[8]</ref> also outlines some double-width variants of RIPEMD-128 and -160, which we refer to as RIPEMD-256 and -320. RIPEMD-256 and -320 can almost be viewed as instantiation of our design principle -except for the following:</p><p>-By outputting both compression values at the end, RIPEMD-256 and -320 use the two n-bit compression functions like a single 2n-bit compression function -again following the Merkle-Damgård design, thus, e.g., being entirely vulnerable to 2nd collision attacks. -RIPEMD-256 and -320 were proposed as a a convenience feature for applications requiring a 2n-bit hash "without needing a larger security level" <ref type="bibr" target="#b7">[8]</ref>. On the other hand, our double-pipe construction has been designed to improve the security against certain attacks.</p><p>We propose a generic and failure-friendly design principle providing provable security under reasonable assumptions. Assuming a "good" n-bit compression function, <ref type="foot" target="#foot_0">1</ref> our analysis would justify the usage of, say, a failure-friendly variant of RIPEMD-320 with 2n = 320 internal state bits and n = 160 output bits. Recently, Coron et al. <ref type="bibr" target="#b4">[5]</ref> also analysed variants of the Merkle-Damgård design in a fashion similar to the current paper. One of the proposals in <ref type="bibr" target="#b4">[5]</ref> is rather similar to our wide-pipe design. However, <ref type="bibr" target="#b4">[5]</ref> aims for variably-sized random oracles, based on an (extremely strong) ideal compression function (i.e., a fixed-size random oracle). This is orthogonal to our approach of taking possible compression function weaknesses into account. Nandi et. al. <ref type="bibr" target="#b17">[18]</ref> proposed and analysed a rather different "2/3 rate double length compression function". Both <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b17">[18]</ref> restrict their analysis to the random and Shannon oracle, while the current paper also provides some analyses in the standard model. Also, none of the constructions in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18]</ref> resemble the current paper's double-pipe hash design.</p><p>Road map. We first describe Merkle-Damgård hashing and introduce notations, abstractions, and attacks. Section 2 describes and analyses the wide-pipe hash, a modified Merkle-Damgård design with an extended internal state size. Section 3 modifies the wide-pipe hash, introducing and analysing the double-pipe hash. Section 4 investigates the security of a "weakened" double-pipe hash, based on a common construction for compression functions; see Appendix A for the proofs. Section 5 deals with extension attacks and Section 6 discusses our results and their implications. Appendix B provides examples for our hash constructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The Merkle-Damgård (MD) Principle for Iterated Hashing</head><p>A hash function H takes a message M ∈ {0, 1} * to compute H(M ) ∈ {0, 1} n . (In practice, the length |M | of M may be bounded by some huge constant.) An iterated hash H is based on a compression function C with a fixed number of input bits and splits M into fixed-sized chunks M 1 , M 2 , . . . , M L ∈ {0, 1} m . The final chunk M L may contain additional information, such as |M |. (M 1 , . . . M L ) is the "expanded message". Assume a compression function C : {0, 1} n ×{0, 1} m → {0, 1} n and a fixed initial value H 0 . Given M ∈ {0, 1} * , one computes the MD hash as follows:</p><formula xml:id="formula_0">-Expand M to (M 1 , . . . , M L ) ∈ {0, 1} mL . (MD strengthening: The last block M L takes the length |M | in bits. Thus, if |M | = |M |, then M L = M L .) -For i ∈ {1, . . . , L}: compute H i := C(H i-1 , M i ). -Finally: output H L . H[0] H[1] H[2] M[2] C C H[L] H[L-1] M[L] C M[1]</formula><p>Fig. <ref type="figure" target="#fig_3">1</ref>. The Merkle-Damgård (MD) Hash Note that the MD hash function does not provide any resistance against 2nd collision attacks: </p><formula xml:id="formula_1">consider messages M = M with expansions (M [1], . . . , M [L]) and (M [1], . . . , M [L]). If M and M collide, then H[L] = H [L] for H[L] = C(•, M [L]) and H [L] = C(•, M [L]),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Notation, Abstractions, and Attacks</head><p>Random Oracles. A fixed-size random oracle is a function f : {0, 1} a → {0, 1} b , chosen uniformly at random. For interesting sizes a and b, it is infeasible to implement f , or to store its truth table. Thus, we assume a public oracle which, given x ∈ {0, 1} a , computes y = f (x) ∈ {0, 1} b . A variably-sized random oracle is a random function g : {0, 1} * → {0, 1} b , accessible by a public oracle.</p><p>Equivalently, g is an infinite set of fixed-size random oracles g a : {0, 1} a → {0, 1} b for a ∈ {0, 1, 2 . . .}. We view a fixed-size random oracle as an ideal compression function, and a variably-sized random oracle as an ideal hash function. Shannon Oracle. An ideal block cipher is some invertible random oracle E : {0, 1} n × {0, 1} m → {0, 1} n , such that for each M ∈ {0, 1} m , for the function E(•, M ) = E M (•) an inverse E -1 (•, M ) exists. Apart from that, E is uniformly chosen at random. Given x and M , one can ask a Shannon oracle for y = E(x, M ), and, given y and M , one can ask the oracle for x = E -1 (y, M ). Adversary. As usual in the context of the Shannon and random oracle models, we consider a computationally unbounded adversary with access to either a Shannon or a random oracle. The adversary's "running time" is determined by her number of oracle queries. Our adversaries are probabilistic algorithms, and we concentrate on the expected running time (i.e., the expected number of oracle queries). We will describe the running time asymptotically. When necessary for clarity, we use the symbols O ("big-Oh", for "the expected running time is asymptotically at most") and Ω ("big-Omega", for ". . . at least"). <ref type="foot" target="#foot_1">2</ref>Classes of Attacks. Informally, a real hash function H should behave like an ideal one (i.e., like a random oracle). This would not be useful for a formal definition, though (see <ref type="bibr" target="#b3">[4]</ref>). Instead, one considers somewhat simpler security goals for H : {0, 1} * → {0, 1} n . We consider the following classes of attacks: The first two classes include "traditional" 2-collisions, 1-way preimages and 1-way 2nd preimages. Some applications need protection against the large-Kvariants, e.g., <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b2">3]</ref>. The third class deals with a very natural assumption for "good" hash functions: even if the adversary somehow -with a great deal of luck, by doing much computational work, or by a mixture of both -has found one collision, it should still be hard to find another one. The poor defence of established hash functions against such attacks has been elaborated above. Facts. Our analysis uses the following facts:</p><formula xml:id="formula_2">K-collision for K ≥ 2: Find K different M i , with H(M 1 ) = • • • = H(M K ). K-way (2nd) preimage for K ≥ 1: Given Y (or M with H(M ) = Y ), find K different messages M i , with H(M i ) = Y (and M i = M ).</formula><p>1. Fact: Finding a K-collision for a fixed size random oracle C : {0, 1} n+m → {0, 1} n or for a variably-sized random oracle Model H : {0, 1} * → {0, 1} n takes time Ω(2 (K-1)n/K ), and finding a K-way preimage or a K-way 2nd preimage for H or C takes time Ω(K2 n ). Initial Values. Like the MD hash, our hash functions depend on the compression function(s) and an initial value (IV). One can set the IV to some fixed ("random") constant. But for our analysis, we will even allow the adversary to actually choose the IV. 3 This makes our results all the more meaningful.</p><p>Standard Model Formalism. For a fixed hash function H : {0, 1} * → {0, 1} n , trivial algorithms to "find" collisions exist: given any M = M with H(M ) = H(M ), output M and M . Collision resistance implies the non-existence of algorithms to "find" collisions. Thus, for a standard model proof of collision resistance, we must refine our formalism. Instead of a fixed hash function, we actually consider a hash function family H : I × {0, 1} * → {0, 1} n . Here, I is a finite nonempty set of indices (or "keys"). We assume an index i * ∈ I being chosen uniformly at random, write H(•) instead of H(i * , •) and consider the fixed hash function H : {0, 1} * → {0, 1} n as a random member of its family. Fix some RAM model of computation. In any attack game, the adversary is given i * as its first input. We measure the adversary's expected running time over uniformly distributed random i * (and the adversary's internal coin flips, if applicable). To capture a trivial adversary using huge tables, the running time of any program is assumed to be at least linear in the program size.</p><p>We formalise compression functions C exactly like hash functions: assume a family C :</p><formula xml:id="formula_3">I C × {0, 1} α → {0, 1} β and an index i C ∈ I C chosen uniformly at random, write C(•) instead of C(i C , •)</formula><p>, and consider the fixed compression function C : {0, 1} α → {0, 1} β as a random member of its family. An adversary's running time is taken over random i C . If H is defined by iterating C, a random member of the hash family H is defined by i C and some random initial value H 0 , i.e., i * = (i C , H 0 ). Similarly, if H is constructed by applying C and C , then i * = (i C , i C , H 0 ). Recall that in our attacks we even allow the adversary to choose H 0 . The adversary can make this choice after being given i C or (i C , i C ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Wide-Pipe Hash: A Modified MD Hash</head><p>Constructing a collision-resistant compression function with w &gt; n output bits may be simpler than constructing an n-bit compression function with the same level of collision resistance. The wide-pipe hash uses such a w-bit compression function to generate an n-bit hash value at the end. 4 This approach defeats Joux' attack -and even provides security against all generic K-collision attacks (which treat the compression function as a random oracle). Let H 0 ∈ {0, 1} w be a (random) initial value. Using two compression functions</p><formula xml:id="formula_4">C : {0, 1} w × {0, 1} m → {0, 1} w and C : {0, 1} w → {0, 1} n ,</formula><p>we compute the wide-pipe hash H:</p><formula xml:id="formula_5">-For i ∈ {1, . . . , L}: compute H i := C (H i-1 , M i ). -Finally: set H(M ) = C (H L ). H[1] M[2] C' C' H[2] M[1] H[L] M[L] C'' C' H[L-1] H[0] f''</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. The Wide-Pipe Hash</head><p>For technical reasons, we need to distinguish between different kinds of collisions. Consider M = N with H(M ) = H(N ). M and N are expanded to sequences (M 1 , . . . , M L ) = (N 1 , . . . , N L ). Denote H M i and H N j for the internal hash values when computing H(M ) and H(N ). We define</p><formula xml:id="formula_6">Final collisions: H M L = H N L but C (H M L ) = C (H N L ). Internal collisions: H M L = H N L .</formula><p>(Note that an internal collision implies a collision for C , i.e., (</p><formula xml:id="formula_7">H M i , M i ) = (H N i , N i ) with C (H M i , M i ) = C (H N i , N i ).) Final K-collisions: Any K-collision M 1 , . . . , M K (with H(M 1 ) = • • • = H(M K )) is final, if all 2-collisions (M i , M j ) (with i = j) are final.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Resistance Against K-Collision Attacks</head><p>Observe that Joux finds 2 k -collisions in time min{k * 2 w/2 , 2 n(2 k -1)/2 k }. This tightly describes the security of H, up to the (logarithmic) factor k. Define the composition f :</p><formula xml:id="formula_8">{0, 1} w × {0, 1} m → {0, 1} n of C and C by f (H, M ) = C (C (H, M</formula><p>)), as indicated in Figure <ref type="figure" target="#fig_2">2</ref>. Make the following two assumptions:</p><p>1. C is collision resistant, and 2. f is K-collision resistant.</p><p>Under these assumptions, we prove the K-collision resistance of H. <ref type="foot" target="#foot_4">5</ref> For the concrete security analysis, we assume that finding a collision for C takes at least time T , and finding a K-collision for f at least time T (K).</p><p>Lemma 1 An adversary needs Ω(min{T , T (K)}) units of time to find a Kcollision for the wide-pipe Hash H, even if she can choose H 0 .</p><p>Proof. Any final K-collision is equivalent to a K-collision for f . On the other hand, if a K-collision for H is not a final K-collision, then an internal collision has been found. For all H 0 , finding an internal collision is equivalent to finding a collision for C . Thus, finding a K-collision for H is at least as hard as finding either a K-collision for f , or a collision for C.</p><p>In the random oracle model, H is as secure against multi-collision attacks as an ideal hash for w ≥ 2n.</p><p>Theorem 2. Consider the wide-pipe hash H. Allow the adversary to choose H 0 .</p><p>1. Model C and C as independent random oracles. The adversary needs time Ω(min{2 w/2 , 2 n(K-1)/K }) to find a K-collision for H. 2. Define C : {0, 1} w → {0, 1} n , C (x 1 , . . . , x w ) = (x 1 , . . . , x n ) as the n-bit truncation of its w-bit input. Model C as a random oracle. The adversary needs time Ω(min{2 w/2 , 2 n(K-1)/K }) to find a K-collision for H.</p><p>Proof. Due to Lemma 1, finding a K-collision takes time Ω(min{T , T (K)}). By Fact 1, T = Ω(2 w/2 ). If C is an independent random oracle, then T (K) = Ω(2 n(K-1)/K ). If C just truncates, then f can be viewed as a random oracle with n output bits. Again, this gives T (K) = Ω(2 n(K-1)/K ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Resistance Against K-way (2nd) Preimage Attacks</head><p>Joux' (2nd) preimage attack also works for the wide-pipe hash. Its time O(k * 2 w/2 + 2 n ) tightly bounds the security of H, up to the (logarithmic) k. Let T be a lower bound for finding collisions for C (as before) and assume that finding K-way preimages for f takes at least time P (K).</p><p>Lemma 3 Consider the wide-pipe hash H. Allow the adversary to choose H 0 .</p><p>1. The adversary needs time Ω(P (1)) to find a single preimage for H. 2. She needs time Ω(min{T , P (K)}) to find a K-way preimage for H.</p><p>Proof. Finding a preimage for H implies finding a preimage for f . Finding a K-way preimage for H either implies finding at least one internal collision -and thus a collision for C -or a K-way preimage for f .</p><p>In the random oracle model, we also consider 2nd preimage attacks.</p><p>Theorem 4. Consider the wide-pipe hash H. Model C and C as independent random oracles. An adversary allowed to choose H 0 needs 1. time Ω(2 n ) to find a single preimage for H, 2. time Ω(min{2 w/2 }) to find a K-way preimage for H, and 3. time Ω(min{2 w/2 , K2 n }) to find a K-way 2nd preimage for H.</p><p>Proof. The first two bounds are direct consequences of Lemma 3 and Fact 1. Now consider 2nd preimages: given a random X ∈ {0, 1} w , we are searching for one or more different</p><formula xml:id="formula_9">X i ∈ {0, 1} w with C (X) = C (X i ).</formula><p>We choose an arbitrary message M with the expansion M 1 , . . . , M L , query the C -oracle for the internal hash values H 1 , . . . , H L , and define</p><formula xml:id="formula_10">C : {0, 1} w → {0, 1} n :    C (H L ) = C (X), C (X) = C (H L ), C (Z) = C (Z) if Z ∈ {X, H L }.</formula><p>Note that with overwhelming probability X = H L . Now we run the adversary to find single or multiple 2nd preimages for M , replacing C by C . Observe that X is a random value, and, since C is a random oracle, H L is random, too. Thus, C is a uniformly distributed random function just like C -the adversary can't distinguish between C and C . Our little manipulation (replacing C by C for the adversary) does not affect the adversary's probability of success or running time. We write H for the wide-pipe hash function using C and C . If the adversary succeeds, she finds 2nd preimage(s) M i with H (M ) = H (M i ). We write L i for the length of the expansion of M i (in chunks). Consider the inputs</p><formula xml:id="formula_11">H i L i for C . If H i L i = H L , we have found a collision for C . Else, H i L i is a 2nd preimage for C .</formula><p>Increasing w improves the security of H against multiple (2nd) preimage attacks. But an adversary whose running time exceeds 2 w/2 can still run Joux' attack and benefit from the iterated structure of H. In fact, no hash function with some fixed internal state size w can be as secure against multiple (2nd) preimage attacks as an ideal hash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Double-Pipe Hash</head><p>There is one drawback for the wide-pipe design: its compression function C needs a larger output and finding collisions for C must be much harder than finding collisions for the hash function itself. It would be interesting to use a compression function which only has to satisfy essentially the same security requirements as the hash. For instance, if we assume the internal compression function of, SHA-1, RIPEMD-160, or SHA-256 to be as secure as an ideal 160-bit (256-bit for SHA-256) compression function, can we construct some variant to improve security? Note that the SHA-1 and RIPEMD-160 compression functions can be written as C : {0, 1} 160 ×{0, 1} 512 → {0, 1} 160 , their SHA-256 counterpart as C : {0, 1} 256 × {0, 1} 512 → {0, 1} 256 . Thus, the following construction would be applicable to all of them: Using one single narrow-pipe compression function C : {0, 1} n × {0, 1} n+m → {0, 1} n , with m ≥ n and two distinct (random) initial values H 0 = H 0 ∈ {0, 1} n , we compute the double-pipe hash H d :</p><formula xml:id="formula_12">-For i ∈ {1, . . . , L -1}: compute • H i := C(H i-1 , H i-1 ||M i ) and • H i := C(H i-1 , H i-1 ||M i ) -Finally: H d (M ) := C(H L-1 , H L-1 ||M L )</formula><p>So in H d (M ), we have replaced the wide-pipe chaining values</p><formula xml:id="formula_13">H i-1 ∈ {0, 1} w by pairs (H i-1 , H i-1 ) ∈ ({0, 1} n ) 2 . In each iteration, the value H i = C(H i-1 , H i-1 ||M i ) -</formula><p>one half of the new chaining value -functionally depends on both halfs H i-1 and H i-1 of the old chaining value (similarly for H i ). This is vital for the security of the double-pipe hash. Otherwise, H d (M ) would degenerate into the cascade of two hash functions, thus being vulnerable to Joux' attack.</p><formula xml:id="formula_14">H''[2] H''[0] H'[2] H''[1] M[1] H'[1] H'[0] M[2] H'[L-1] H''[L-1] M[L] H'[L-2] H''[L-2] M[L-1]</formula><p>Hash Fig. <ref type="figure">3</ref>. The Double-Pipe Hash</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Security Against Multiple Collision Attacks</head><p>In principle, the double-pipe hash is a special case of the wide-pipe hash with w = 2n and</p><formula xml:id="formula_15">C (H , H ||M ) = ( C(H i-1 , H i-1 ||M i ), C(H i-1 , H i-1 ||M i ) )</formula><p>, where C (H , H ) = H simply truncates 2n input bits to n output bits. (Thus, we do not need to compute the value H L := C(H L-1 , H L-1 ||M L ), as indicated in Figure <ref type="figure">3</ref>.) Similarly to our analysis of the wide-pipe design, we distinguish internal collisions from final ones. The improved security of the wide-pipe hash over the plain MD hash depends on internal collision resistance being much stronger than final collision resistance. Unfortunately, this reasoning does not hold for the double-pipe construction. Finding internal collisions with H = H and G = G may be as "easy" as finding collisions for C, i.e., as finding final collisions. To deal with this, we define two special cases of internal collisions, in addition to considering K-collisions, and make the following three assumptions: We will prove H d to be secure under the above three assumptions. While dealing with strict or cross collisions is unusual in cryptography, these assumptions appear to be natural and reasonable. We analyse the feasibility of finding strict or cross collisions for a random oracle C. For the concrete security analysis, we assume that finding strict collisions takes at least time T s , finding cross collisions at least time T x , and finding K-collisions at least time T (K). If the adversary chooses q different triples (G , G , M ) and makes q queries to the C-oracle, then her probability to succeed is 0≤j&lt;q j/2 2n = Ω(q 2 /2 2n ). Thus, we expect to make T s = q = Ω(2 n ) oracle queries to find a strict collision.</p><p>Lemma 6 Consider H d . Allow the adversary to choose H 0 = H 0 .</p><p>1. Any internal collision for H d reduces to a strict or to a cross collision. 2. The adversary needs time Ω(min{T s , T x , T (K)}) to find a K-collision.</p><p>Proof. For the first claim, observe that the initial values H 0 and H 0 are different.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Any non-strict internal collision implies a triple (H</head><formula xml:id="formula_16">i-1 , H i-1 , M i ) with H i-1 = H i-1 .</formula><p>This implies the existence of a cross-colliding triple (H j , H j , M j+1 ), with j ≤ i-2, H j = H j , and</p><formula xml:id="formula_17">H j+1 = C(H j , H j ||M j+1 ) = C(H j , H j ||M j+1 ) = H j+1 .</formula><p>Thus, any non-strict internal collision implies a cross collision.</p><p>For claim 2, we argue as in the proof of Lemma 1. A K-collision for H d either reduces to a final K-collision (taking time T (K)), or to an internal collision. By the first claim, an internal collision is either strict (taking time T s ), or is a cross collision (taking time T x ).</p><p>Theorem 7. Consider H d , and model C as a random oracle. An adversary who can choose H 0 = H 0 needs time Ω(2 n(K-1)/K ) to find K-collisions.</p><p>Proof. The result follows from Theorem 5, Lemma 6, and Fact 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Resistance Against K-way (2nd) Preimage Attacks</head><p>Our treatment of K-way (2nd) preimage attacks is quite similar to Section 2.2. Let T s and T x be defined as above and assume finding preimages for C to take at least time P (1).</p><p>Lemma 8 Consider H d . Allow the adversary to choose H 0 = H 0 . 1. To find a single preimage, the adversary needs time Ω(P (1)). 2. To find K-way preimages, the adversary needs time Ω(min{T s , T x , T (K)}).</p><formula xml:id="formula_18">Proof. Claim 1: See proof of Lemma 3 with f (•, •||•) := C(•, •||•).</formula><p>Claim 2 follows from claim 1 of Lemma 6. Note that a K-way preimage also is a K-collision. Theorem 9. Consider the double-pipe hash H d . Model the compression function C as a random oracle. An adversary who can choose H 0 needs time Ω(2 n ) for finding a single or K-way preimage or a single or K-way 2nd preimage.</p><p>The proof of Theorem 9 is quite similar to the proof of Theorem 12 below.</p><p>Our results indicate that in the random oracle model, the double-pipe hash H d is asymptotically as secure as the wide-pipe hash with w = 2n.</p><p>If we trust an existing MD-hash to meet its security goal, it seems reasonable to use its compression function as the building-block C for the double-pipe hash. But most practical hash (or rather, compression) functions (including the SHAfamily of hash functions, see Table <ref type="table">1</ref>) suffer from a specific structural weakness: They use a block cipher like function E : {0, 1} n+m ×{0, 1} n → {0, 1} n , i.e., that for each "key" K ∈ {0, 1} n+m the function E(K, •) permutates over {0, 1} n , and both E(M, •) and its inverse can efficiently be computed. A DM compression function C : {0, 1} n × {0, 1} n+m → {0, 1} n is defined as follows:</p><formula xml:id="formula_19">C(H i-1 , M i ) = E(M i , H i-1 ) + H i-1 .</formula><p>(Here "+" is any group operation over {0, 1} n .) The ability to efficiently compute E -1 M (•) can be useful for the adversary, see e.g. Kelsey and Schneier <ref type="bibr" target="#b12">[13]</ref> for examples. Thus, we have to extend our formalism for the security proofs accordingly -by considering a Shannon oracle, instead of a random oracle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Double-Pipe Hash with DM Compression Function</head><p>Some generic attacks against hash functions don't apply in the random oracle model, but are feasible in the Shannon model <ref type="bibr" target="#b12">[13]</ref>. Fortunately, this does not pose a problem for the double-pipe hash. Those parts of our analysis of the doublepipe hash which do not assume random oracles are still relevant and applicable. <ref type="foot" target="#foot_5">6</ref>However, trusting those parts of our analysis which treat C as a random oracle would be risky. For this reason, we additionally analyse the double-pipe hash in the Shannon-model. See Appendix A for the proofs of the Theorems below. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Resistance Against 2nd Collision Attacks</head><p>Note that our definition of a 2nd collision attack assumes the adversary to be given the first collision essentially "for free". This is difficult to handle in the standard model. Thus, we concentrate on the random oracle model.</p><p>In general, our hash designs do not protect against 2nd collision attacks: given an internal collision, attacking the wide-pipe or double-pipe hash is as easy as attacking the MD hash. Our design rationale, however, has been to defend against internal collisions, leaving final collisions as the "dotted line", where the hash function is likely to break (if it breaks at all). This is the foundation for the security proofs in the previous sections. In the remainder of this section, we thus focus on the specific case that the adversary is only given a final collision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Wide-Pipe Hash: 2nd Collision Resistance</head><p>Consider the following attack: fix H 0 , choose two incomplete expanded messages (M 1 , . . . , M L-1 ) and (N 1 , . . . , N L -1 ), defining some pre-final internal states H M L-1 and H N L -1 , receive a first collision and finally provide a 2nd collision. The first collision is defined by M L , N L such that the hash collides, but C does not:</p><formula xml:id="formula_20">f (H M L-1 , M L ) = f (H N L -1 , N L -1 ) but C (H M L-1 , M L ) = C (H N L -1 , N L -1 )</formula><p>In this section, we consider an attack game giving the adversary even more freedom: choose any H M L-1 and H N L -1 , receive M L , N L for a first collision as above, and provide any four messages</p><formula xml:id="formula_21">A, B, C, D ∈ {0, 1} * , A = B, C = D, H(A) = H(B), H(C) = H(D), with C ∈ {A, B, D}.</formula><p>Theorem 13. Consider the wide-pipe hash H. Model C as a random oracle. If C either is an independent random oracle, or the n-bit truncation of its w-bit input, the adversary needs time Ω(2 n/2 ) to win the 2nd collision game for H. Proof (Sketch). Recall that we have got a first collision for f , but no collision for C . Finding messages A, B, C, D ∈ {0, 1} * as required implies finding an internal collision (a collision for C ), taking time Ω(2 w/2 ) &gt; Ω(2 n/2 ), or a 2nd collision for f , namely intermediate hashes H A , H B , H C , H D ∈ {0, 1} w , and final message blocks</p><formula xml:id="formula_22">M A , M B , M C , M D ∈ {0, 1} m with (H A , M A ) = (H B , M B ), (H C , M C ) ∈ {(H A , M A ), (H B , M B ), (H D , M D )}, f (H A , M A ) = f (H B , M B ), and f (H C , M C ) = f (H D , M D ).</formula><p>We argue that finding a 2nd collision for f would take time Ω(2 n ). If the 2nd collision for f includes a collision for C , then we need time time Ω(2 w/2 ) to find it. Else, the 2nd collision is still as hard to find as a 2nd collision for any n-bit random oracle -both when C is an independent random oracle and when C plainly truncates -, thus taking time Ω(2 n/2 ), see Fact 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The Double-Pipe Hash: 2nd Collision Resistance</head><p>We adapt the attack game from above to the double-pipe hash: choose four arbitrary pairs </p><formula xml:id="formula_23">G = G , H = H ∈ {0, 1} n , receive M, N ∈ {0, 1} m with C(G , G ||M ) = C(H ,</formula><formula xml:id="formula_24">-or intermediate hashes H A , H A , H B , H B , H C , H C , H D , H D ∈ {0, 1} n and final message blocks M A , M B , M C , M D ∈ {0, 1} m with (H A , H A ||M A ) = (H B , H B ||M B ), (H C , H C ||M C ) ∈ { (H A , H A ||M A ), (H B , H B ||M B ), (H D , H D ||M D ) }, C(H A , H A ||M A ) = C(H B , H B ||M B ), and C(H C , H C ||M C ) = C(H D , H D ||M D ).</formula><p>The intermediate hashes and message blocks constitute a 2nd preimage for C. According to Fact 2, finding such a 2nd preimage takes time Ω(2 n/2 ). See Appendix A for a sketch of the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>A Variant of the double-pipe hash. To reduce the set of cryptographic assumptions, Preneel <ref type="bibr" target="#b20">[21]</ref> proposed to use C : {0, 1} × {0, 1} n × {0, 1} n+m → {0, 1} n with one extra bit of input. Set</p><formula xml:id="formula_25">H i := C(0, H i-1 , H i-1 ||M i ), H i := C(1, H i-1 , H i-1 ||M i )</formula><p>, and finally Hash(M ) := C(0, H L-1 , H L-1 ||M L ). Proofs of security for this variant of the double-pipe hash are very similar to the proofs for H d itself, but without the need to assume finding cross collisions to be infeasible. Two Independent Security Parameters. The main lesson from <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b12">13]</ref> and the current paper is that the internal state size w of an iterated hash function should be seen as a security parameter of its own right.</p><p>Any security architect choosing parameters for a cryptographic hash should choose both w and n according to her specific security requirements. For an application where even a single hash collision would be the ultimate disaster, w = n suffices. If, on the other hand, additional multi-collisions or (multiple or single) preimages or 2nd preimages or feasible 2nd collisions would turn things from bad to worse, w n is recommendable, due to an improved failure mode. 2nd Collision Resistance. For applications such as digital signatures, 2nd collision resistance can have a huge impact on practical security. Our constructions are reasonably 2nd collision resistant. E.g., a double-pipe hash using the MD5 compression function would fail collision resistance due to <ref type="bibr" target="#b25">[26]</ref>, but for the double-pipe hash, this attack could only be used to generate final collisions. Accordingly, this double-pipe hash still defeats known exploits that make collisions "meaningful" <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>Cascading. The idea to improve the security of hash functions by cascading has been discussed for a long time, see, e.g., <ref type="bibr" target="#b19">[20]</ref>. Cascading looks like an obvious technique to improve the security of hash functions -but due to Joux' attack, cascading iterated hash functions is not that useful. On the other hand, the double-pipe construction can be seen as a cascade of compression functions. To this end, our double-pipe construction provides a theoretically sound technique to cascade compression functions instead of the complete hash functions. Summary. This paper takes an abstract and proof-centric look at the design of hash functions. Similarly to <ref type="bibr" target="#b1">[2]</ref>, we consider our work a "feasible and useful step for understanding the security" of iterated hash functions, thereby complementing the attack-centric approach <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b12">13]</ref>. In the spirit of Merkle <ref type="bibr" target="#b15">[16]</ref> and Damgård <ref type="bibr" target="#b5">[6]</ref>, this paper shows how to compose "good" hash functions, given "good" compression functions. We provide standard model explanations, what it means for the compression function to be "good". Additionally, we analyse the security of our constructions in the random oracle and Shannon model. This is without loss of generality: any adversary not following the first two conventions can easily be transformed into an equivalent one following them. And an adversary following the first two conventions cannot distinguish the simulator from a "true" Shannon oracle. Proof. For the proof, we assume that the adversary does not make more than q ≤ 2 n-1 queries. This is technically correct, since 2 n-1 = Ω(2 n ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Internal Collisions</head><p>Time T x to find cross collisions: a cross collision is described by</p><formula xml:id="formula_26">H i-1 = H i-1 , Mi with C(H i-1 , H i-1 ||Mi) = H i = H i = C(H i-1 , H i-1 ||Mi).<label>(1)</label></formula><p>In time q, we can check at most q/2 such triples (H i-1 , H i-1 , Mi) for cross collisions. Now we argue that for q ≤ 2 n-1 , for each such triple the probability px to satisfy Equation 1 is at most 1/2 n-1 . This implies that the expected number of oracle queries we need to make before we get the first cross collision is T x = Ω(2 n ), as claimed. We still have to show px ≤ 2 n-1 . If the adversary's answer involves a cross collision, then, by the above conventions, the simulator's logbook contains two triples (xa, ka, ya) and (x b , k b , y b ) with a = b, (</p><formula xml:id="formula_27">xa = H i-1 , ka = (H i-1 ||Mi), ya = E ka (xa), x b = H i-1 , k b = (H i-1 ||Mi),</formula><p>A strict collision consists of such a triple (G , G , M ) and another triple (F , F , N ) = (G , G , M ) with</p><formula xml:id="formula_29">C(F , F ||N ) = H and C(F , F ||N ) = H .<label>(4)</label></formula><p>After q oracle queries, there are Ω(q 2 ) pairs ((G , G , M ),(F , F , N )) of triples. We claim that for q ≤ 2 n-1 , the probability ps to satisfy Equation 4 is ps ≤ 1/2 2(n-1) . Hence, the expected number of oracle queries to get a strict collision is T s = Ω( <ref type="formula">2</ref> A strict collision implies another triple (F , F , N ) to satisfy Equation <ref type="formula" target="#formula_29">4</ref>. This corresponds to two more triples (xc, kc, yc) and (x d , k d , y d ) on the server's logfile with</p><formula xml:id="formula_30">H = ya + xa = yc + xc<label>(5)</label></formula><formula xml:id="formula_31">H = y b + x b = y d + x d .<label>(6)</label></formula><p>Both equations are of the same type as Equation <ref type="formula">2</ref>. As in that context, we argue that due to q ≤ 2 n-1 the probability for Eq. 5 to hold is no more than 1/2 n-1 ; similarly for Eq. 6. More importantly, the conditional probability to satisfy Eq. 6, assuming Eq. 5 is at most 1/2 n-1 . Thus, the joint probability ps for both Eq. 5 and Eq. 6 is ps ≤ 1/2 2(n-1) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Resistance Against K-Collision Attacks</head><p>Theorem 11. Consider H d with a DM compression function C. If we model E by a Shannon oracle, then finding K-collisions takes time Ω(2 (n-1)(K-1)/K ).</p><p>Proof. Due to the first claim of Lemma 6 and Theorem 10, we know that an internal collision would take time Ω(2 n ). Thus, in time Ω(2 (n-1)(K-1)/K ) we cannot expect to find any internal collision. The only chance to find a K-way collision for H is finding a final K-collision, which takes time T (K). In the remainder of this proof, we show T (K) = Ω(2 (n-1)(K-1)/K ). As in the proof of Theorem 10, we assume q ≤ 2 n-1 = Ω(2 n ).</p><p>A final K-collision consists of K different triples with (G i , H i , M i ) with</p><formula xml:id="formula_32">C(G 1 , H 1 ||M 1 ) = • • • = C(G K , H K ||M K ).</formula><p>By the above conventions, this implies that there are K triples (x1, k1, y1), . . . , (xK , kK , yK ) in the simulator's logbook with</p><formula xml:id="formula_33">y 1 E k 1 (x1) +x1 = • • • = y K E k K (xK ) +xK .</formula><p>These are K sums xi + yi, and similarly to the proof of Theorem 10, for each such sum either xi or yi has been chosen from a huge subset {0, 1} n . Since q ≤ 2 n-1 , the size of this subset exceeds 2 n -q ≥ 2 n-1 . For this reason, we expect to make T (K) = Ω(2 (n-1)(K-1)/K ) Shannon oracle queries for a K-collision.</p><p>A. Proof. As in some of the proofs above, we assume q ≤ 2 n-1 . Finding K-way (2nd) preimages isn't faster than finding single (2nd) preimages. Thus, we concentrate on single ones.</p><p>First, we start with singe preimages. Due to Lemma 8, finding a single preimage for the hash H d takes time Ω(P (1)), i.e., is asymptotically not faster than finding a preimage for the compression function C(K, X) = EK (X)+X. Let a target Z be given, and an adversary is trying to find K and X with C(K, X) = EK (X) + X = Z. By the above conventions, this corresponds to an entry (xi, ki, yi) in the simulator's logbook with xi + yi = Z, and either xi or yi has been chosen from a huge subset of {0, 1} n of size &gt; 2 n -q ≥ 2 n-1 . Thus, for each query to the Shannon oracle, the probability to find a preimage for Z is at most 2 n-1 , and we expect to make P (1) = Ω(2 n ) such queries to find such a preimage. Now consider 2nd preimages: assume an algorithm to find 2nd preimages for H d . Consider we are given (K, N ) and searching for some 2nd preimage (K</p><formula xml:id="formula_34">, N ) = (K, N ) with C(K , N ) = E K (N ) + N = EK (N ) + N = C(K, N ).</formula><p>The following technique resembles the proof of Theorem 4. We choose some message M , expand it to (M1, . . . , ML) and accordingly compute the internal hashes</p><formula xml:id="formula_35">H 1 , H 1 , . . . , H L-1 , H L-1 . Assume (K, N ) ∈ {(H i , H i ||Mi), (H i ||H i ||Mi) | 1 ≤ i &lt; L} (this holds with overwhelming probability). Set N -1 := E -1 K (Z -N ) and define the function E : {0, 1} n ×{0, 1} n+m → {0, 1} n : E K (N ) = Z -N E K (N -1 ) = EK (N ) E Q (R) = EQ(R) for (Q, R) ∈ {(K, N ), (K, N -1 )}.</formula><p>Now we run the adversary, replacing the (Shannon-) oracle for E and E -1 by an oracle for E and its inverse. Observe that for the adversary H d (M ) = Z holds. Further, both E and E are random permutations over {0, 1} n , so the adversary's chances of success are not affected by the change from E to E . Assume the adversary succeeds in finding a 2nd preimage M for M . Write (M1, . . . , M L ) for the expansion of M and H</p><formula xml:id="formula_36">1 , H 1 , . . . , H L-1 , H L-1</formula><p>for the internal hashes.</p><p>-</p><formula xml:id="formula_37">If (H L-1 , H L-1 , M L ) = (H L-1 , H L-1 ,</formula><p>ML), then the adversary has found an internal collision. From above, we know that this needs time min{T x , T s } = Ω(2 n ).</p><p>-Otherwise, (H</p><formula xml:id="formula_38">L-1 , H L-1</formula><p>, M L ) is a preimage for Z. From above, we know that this takes time P (1) = Ω(2 n ). Thus, in order to find a 2nd preimage for H, the adversary either has to find an internal collision, or a 2nd preimage for C, and solving either problem takes time Ω(2 n ). Proof (Sketch). Recall the proof of Theorem 14. A 2nd collision for H d either implies an internal collision or a 2nd preimage for C. Finding an internal collision reduces to strict or internal collisions, thus taking time Ω(2 n ) (→ Theorem 10).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.5 2nd Collision Resistance</head><p>We still have to show that finding 2nd collisions for C takes time Ω(2 n/2 ). From Theorem 11, we know that finding (first) collisions (i.e., K-collisions with K = 2) takes time Ω(2 n/2 ). In the proof of Theorem 11, finding such collisions for C is shown equivalent to the following task: </p><formula xml:id="formula_39">find x1, k1, x2, k2 with E k 1 (x1) + x1 = E k 2 (x2) + x2,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Examples</head><p>The SHA standard. Two of the five SHA- * hash functions <ref type="bibr" target="#b18">[19]</ref>, namely SHA-224 and -384, have already been designed according to this paper's "wide-pipe" paradigm, see Table <ref type="table">1</ref>. Of course, the authors of SHA-224 and -384 where to reuse existing compression functions, but they could have done so -improving the hash function's performance -by truncating the internal hash values to 224 or 348 bit and extending the message chunk size by 256-224=32 or 512-348=128 bit. Our results provides some formal ("after the fact") justification for the design of SHA-224 and -348.  <ref type="table">1</ref>. SHA standard hash functions and their parameters <ref type="bibr" target="#b18">[19]</ref>.</p><formula xml:id="formula_40">final</formula><p>A natural choice for the parameters w and n would, however, be w = 2n. As an example for the wide-pipe hash, we could set C := (SHA-512 compression function) and C := (SHA-256 compression function) to define a 256-bit hash with an internal hash size of w = 512. For large messages, this 256-bit hash would be about as fast as SHA-512. As an example for a 256-bit double-pipe hash, consider C := (SHA-256 compression function). The size of a SHA-256 message chunk is m+n = 512, so the size of a double-pipe message chunk would be m = 512 -n = 256 bit. For large messages, double-piped SHA-256 would be about four times slower than plain SHA-256. Similarly, a double-piped SHA-1 hash would be about three times slower than plain SHA-1. <ref type="foot" target="#foot_6">7</ref>AES-based example for the double-pipe hash. Consider an AES-based MD hash H md aes , using the AES block cipher in Davies-Meyer mode. The block size of H md aes is the AES block size: 128 bit. For applications which do not require collision resistance, it may be fine to use a 128-bit hash. But resistance against multi-collision attacks or 2nd preimage attacks could be a concern for these applications -and from the Joux and the Kelsey-Schneier attacks, we know that H md aes is much less resistant against these attacks than we would expect from a 128-bit hash. For a well funded and motivated adversary, it is possible to find, say, a 2 16 -collision for H md aes . This weakness does not much depend on the AES key size (either 128 bit, 192 bit, or 256 bit).</p><p>In contrast to H md aes , its double-pipe counterpart (only defined for the AES key size of 256 bit) provides much better protection against these attacks, assuming the AES itself does not suffer from some still unknown cryptanalytic weaknesses. Even finding a 3-collision for a double-pipe 128-bit hash would take more than 2 80 units of running time and therefore seems to be infeasible today. The price for the improved security is a performance penalty by a factor of four, similarly to double-piped SHA-256.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>and therefore all expanded messages (M [1], . . . , M [L], S[1], . . . , S[T ]) and (M [1], . . . , M [L], S[1], . . . , S[T ]) also collide.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>2nd collision: Given any collision A = B with H(A) = H(B), find C, D with C ∈ {A, B, D} and H(C) = H(D).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 .</head><label>2</label><figDesc>Fact: Given a collision A = B with C(A) = C(B) for a fixed size random oracle C{0, 1} n+m → {0, 1} n (or H(A) = H(B) for a variably-sized random oracle H{0, 1} * → {0, 1} n ), finding a 2nd collision C = D, C ∈ {A, B} for C (or H) takes time Ω(2 n/2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 .</head><label>1</label><figDesc>It is infeasible to find a strict (internal) collision for C, i.e., two triples (H , H , M ) = (G , G , N ) with H = H and G = G , but C(H , H ||M ) = C(G , G ||N ) and C(H , H ||M ) = C(G , G ||N ). 2. It is infeasible to find an (internal) cross collision for C: a triple (H , H , M ), with H = H but C(H , H ||M ) = C(H , H ||M i ). 3. It is infeasible to find K-collisions for C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 5 .</head><label>5</label><figDesc>If we model the compression function C as a random oracle, then finding cross collisions for C needs time T x = Ω(2 n ), and finding strict collisions for C needs time T s = Ω(2 n ), Proof. First, consider T x . Any triple (H , H , M ) can only be part of a cross collision, if H = H and C(H , H ||M ) = C(H , H ||M ), i.e., with a probability of 2 -n (for H = H ). Thus, we expect to make T x = Ω(2 n ) oracle queries to find a cross collision. Now consider T s . For any triple (G , G , M ) with G = G , the pair (H , H ) ∈ {0, 1} 2n with H = C(G , G ||M ) and H = C(G , G ||M ) is a uniformly distributed 2n-bit random value, chosen independently from all the other C(•, •||•)values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 10 .</head><label>10</label><figDesc>Consider a DM compression function C. If we model E by a Shannon oracle, then T x = Ω(2 n ) and T s = Ω(2 n ). Theorem 11. Consider H d with a DM compression function C. If we model E by a Shannon oracle, then finding K-collisions takes time Ω(2 (n-1)(K-1)/K ). Theorem 12. Consider H d with a DM compression function C. If we model E by a Shannon oracle, then finding a single or K-way preimage or a single or K-way 2nd preimage takes time P (1) = Ω(2 n ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 14 .</head><label>14</label><figDesc>H ||N ), and provide A, B, C, D ∈ {0, 1} * , with A = B, C = D, H d (A) = H d (B), H d (C) = H d (D), and C ∈ {A, B, D}. Consider the double-pipe hash H d . Model C as a random oracle. The adversary needs time Ω(2 n/2 ) to win the 2nd collision game for H d . Proof (Sketch). As above, finding such A, B, C, D ∈ {0, 1} * with A = B and C ∈ {A, B, D}, implies finding either an internal collision, taking time Ω(2 n ) (→ Lemma 6, Theorem 5)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Theorem 15 .</head><label>15</label><figDesc>Consider H d with a DM compression function C. Model E by a Shannon oracle. Winning the 2nd collision game takes time Ω(2 n/2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Theorem 10 .</head><label>10</label><figDesc>Consider a DM compression function C. If we model E by a Shannon oracle, then T x = Ω(2 n ) and T s = Ω(2 n ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>-</head><label></label><figDesc>and y b = E k b (x b ). Thus, we can rewrite Equation 1 as ya E ka (xa) +xa = y b E k b (x b ) +x b , which corresponds to ya + xa = y b + x b . (2) If (w.l.o.g.) a &lt; b, then either y b or x b is a uniformly distributed random value from a huge subset of {0, 1} n : If the b-th oracle query has been E k b (x b ), then y b is a random value from range(E k b ). -Else x b is a random value from domain(E k b ). Since |range(E k b )| = |domain(E k b )| = 2 n -b + 1 ≥ 2 n -q, and due to q ≤ 2 n-1 , we get px ≤ 1/2 n-1 , as claimed. Time T s to find strict collisions: for triples (G , G , M ) with G = G , we consider pairs (H , H ) ∈ {0, 1} 2n , where H = C(G , G ||M ) and H = C(G , G ||M ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>n ). It remains to prove ps ≤ 1/2 2(n-1) . Consider a triple (xa, ka, ya) with xa = G , ka = (G ||M ), and ya = E ka (xa) from the simulator's logfile. We only have a chance for a strict collision if the logfile contains another triple (x b , k b , y b ) with x b = G , k b = (G ||M ), and y b = E k b (x b ). Note that x b and k b are uniquely determined by xa and ka, and vice versa. Equation 3 can then be rewritten as H = E ka (xa) + xa = ya + xa and H = E k b (x b ) + x b = y b + x b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Theorem 15 .</head><label>15</label><figDesc>Consider H d with a DM compression function C. Model E by a Shannon oracle. Winning the 2nd collision game takes time Ω(2 n/2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>-</head><label></label><figDesc>and (x1, k1) = (x2, k2). Similarly, finding 2nd collisions for C is equivalent to the task: given xa, ka, x b , k b with E ka (xa) + xa = E k b (x b ) + x b with (x1, k1) = (x2, k2), find xc, kc, x d , k d with E kc (xc) + xc = E k d (x d ) + x d , and (xa, ka) = (x b , k b ), and (xc, kc) ∈ { (xa, ka), (x b , k b ), (xc, kc) }. Regarding the second task, we replace the family E of permutations by a modified family E : Randomly choose xa, ka, x b , k b . Assume ka = k b (this is overwhelmingly probable). -Compute y * := E k b (x b ) + x b -xa and x * := E ka (y * ). -Set E ka (xa) := y * and E ka (x * ) := E ka (xa). Otherwise, E behaves identical to E. -Observe E ka (xa)+xa = E k b (y b ). Given such xa, ka, x b , k b , solve the second collision task for E instead of E. The solution is xc, kc, x d , k d as above.With significant probability, we have {(xc, kc), (x d , k d )} ∩ {(xa, ka), (x * , ka)} = {}. In this case, our 2nd collision for E is a first collision for E. Thus, our proof reveals a technique to efficiently find collisions for C, if one can find 2nd collisions. Due to Theorem 11, finding such collisions takes time Ω(2 n/2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>4 Resistance Against K-way (2nd) Preimage Attacks Theorem 12. Consider H d with a DM compression function C. If we model E by a Shannon oracle, then finding a single or K-way preimage or a single or K-way 2nd preimage takes time P (1) = Ω(2 n ).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>hash internal hash message chunk uses compression size n [bit] size w [bit]</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>size [bit]</cell><cell>function from</cell></row><row><cell>SHA-1</cell><cell>160</cell><cell>160</cell><cell>512</cell><cell>(own)</cell></row><row><cell>SHA-224</cell><cell>224</cell><cell>256</cell><cell>512</cell><cell>SHA-256</cell></row><row><cell>SHA-256</cell><cell>256</cell><cell>256</cell><cell>512</cell><cell>(own)</cell></row><row><cell>SHA-384</cell><cell>384</cell><cell>512</cell><cell>1024</cell><cell>SHA-512</cell></row><row><cell>SHA-512</cell><cell>512</cell><cell>512</cell><cell>1024</cell><cell>(own)</cell></row><row><cell>Table</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that<ref type="bibr" target="#b7">[8]</ref> took great care to ensure that both compression functions behave "differently enough". Somewhat surprisingly, our results indicate that it would even be OK to use the same compression function twice, instead of two different functions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Recall f = O(g), if a constant c exists, such that f (n) ≤ cg(n) holds for all large enough n, and f = Ω(g), if a c exists such that f (n) ≥ cg(n) for all large enough n.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This is similar to the "aSec" and "aPre" notions of hash function security from<ref type="bibr" target="#b23">[24]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This idea has independently been proposed by Finney in a mailing list<ref type="bibr" target="#b8">[9]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>It would seem natural to assume the K-collision resistance of C . Indeed, f is Kcollision resistant if C is collision resistant and C is K-collision resistant. But even if C is K-collision vulnerable, f can still be K-collision resistant. E.g., model C as a random oracle and set C to be the plain truncation of w-bit inputs to n-bit outputs. For log 2 (K) ≤ w -n, C is trivially K-collision weak, but f is not.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Observe that the "DM compression function" is the function C with some specific non-random property. Given such C, the definition of H d is the same.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Note that sharing initial values between different hash functions is never recommendable. Thus, H 0 and H 0 should not be taken from<ref type="bibr" target="#b18">[19]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement. The author thanks Frederik Armknecht, John Kelsey, Ulrich Kühn, Arjen Lenstra, Bart Preneel, and the anonymous reviewers for their suggestions, discussions, and inspirations.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>A Security of Double-Pipe Hash with Davies-Meyer</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Conventions</head><p>In this section, we analyse the security of the double-pipe hash with a Davies-Meyer compression function. The adversary A has access to a Shannon oracle for E and E -1 . Similarly to <ref type="bibr" target="#b1">[2]</ref>, we assume:</p><p>-A never asks a query for which the response is already known. Namely, if A asks for E k (x) and receives y, she neither asks for E -1 k (y), nor for E k (x) again. Similarly, if she has asked for E -1 k (y) and received x. -Recall that for the type of attacks we consider, a successful adversary always outputs one or more messages M i , which either collide or constitute some (2nd) preimages. Before finishing, the adversary makes all the oracle calls to compute all hash values H(M i ). -We define a simulator, to respond to A's oracle queries:</p><p>• Initially:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Collisions of SHA-0 and reduced SHA-1</title>
		<author>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Carribault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lemuet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jalby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt 2005</title>
		<imprint>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="36" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Black-box analysis of the block-cipher based hash-function construction from PGV</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto 02</title>
		<imprint>
			<biblScope unit="volume">2442</biblScope>
			<biblScope unit="page" from="320" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Design validation for discrete logarithm based signature schemes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2000</title>
		<imprint>
			<biblScope unit="volume">1751</biblScope>
			<biblScope unit="page" from="276" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The random oracle methodology, revisited. 30th STOC</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Merkle-Damgård revisited: how to construct a hash function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Malinaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Punyia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Accepted for Crypto</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A design principle for hash functions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Crypto</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="416" to="427" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The story of Alice and her boss</title>
		<author>
			<persName><forename type="first">M</forename><surname>Daum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lucks</surname></persName>
		</author>
		<ptr target="http://th.informatik.uni-mannheim.de/people/lucks/HashCollisions/" />
	</analytic>
	<monogr>
		<title level="m">Eurocrypt 05 rump session</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">RIPEMD-160, a strengthened version of RIPEMD</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dobbertin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bosselaers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
		<ptr target="http://www.esat.kuleuven.ac.be/˜bosselae/ripemd160.html" />
	</analytic>
	<monogr>
		<title level="m">FSE 1996</title>
		<imprint>
			<biblScope unit="volume">1039</biblScope>
			<biblScope unit="page" from="71" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">More problems with hash functions. The cryptography mailing list</title>
		<author>
			<persName><forename type="first">H</forename><surname>Finney</surname></persName>
		</author>
		<ptr target="http://lists.virus.org/cryptography-0408/msg00124.html" />
		<imprint>
			<date type="published" when="2004-08-24">24 Aug 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the length of cryptographic hash-values used in identification schemes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Girault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Crypto</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="202" to="215" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multicollisions in iterated hash functions, application to cascaded constructions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto 04</title>
		<imprint>
			<biblScope unit="volume">3152</biblScope>
			<biblScope unit="page" from="306" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">MD5 to be considered harmful someday</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kaminski</surname></persName>
		</author>
		<ptr target="http://www.doxpara.com/md5someday.pdf" />
		<imprint>
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Second preimages on n-bit hash functions in much less than 2 n work</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Kelsey</surname></persName>
		</author>
		<author>
			<persName><surname>Schneier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt 2005</title>
		<imprint>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="474" to="490" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the possibility of constructing meaningful hash collisions for public keys</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Weger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACISP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>To appear at</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Weger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2005/067/" />
		<title level="m">Colliding X.509 certificates. Cryptology eprint archive report 2005/067</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">One-way hash functions and DES</title>
		<author>
			<persName><forename type="first">R</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Crypto</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="428" to="446" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Practical attacks on digital signatures using MD5 message digest</title>
		<author>
			<persName><forename type="first">O</forename><surname>Mikle</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2004/356/" />
	</analytic>
	<monogr>
		<title level="m">Cryptology eprint archive report 2004/356</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Security analysis of a 2/3-rate double length compression function in the black box model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakurai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2005</title>
		<imprint>
			<biblScope unit="volume">3557</biblScope>
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Secure hash standard</title>
	</analytic>
	<monogr>
		<title level="j">FIPS</title>
		<imprint>
			<biblScope unit="volume">180</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2002-08">August 2002</date>
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology (NIST</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Analysis and design of cryptographic hash functions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Katholieke Universiteit Leuven</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Private communication. Hash Function Workshop</title>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>Krakow</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">RIPE integrity primitives for secure information systems</title>
	</analytic>
	<monogr>
		<title level="m">Final report of RACE integrity primitives evaluation (RIPE RACE 1040)</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1007</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">PayWord and MicroMint -two simple micropayment schemes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CryptoBytes</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="11" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Cryptographic Hash-Function Basics: Definitions, Implications, and Separations for Preimage Resistance, Second-Preimage Resistance, and Collision-Resistance</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2004</title>
		<imprint>
			<biblScope unit="volume">3017</biblScope>
			<biblScope unit="page" from="371" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cryptoanalyisis of the hash functions MD4 and RIPEMD</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt 2005</title>
		<imprint>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">How to break MD5 and other hash functions</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt 2005</title>
		<imprint>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Efficient collision search attacks on SHA0. Accepted for Crypto</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Yin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Finding collisions in the full SHA1. Accepted for Crypto</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
