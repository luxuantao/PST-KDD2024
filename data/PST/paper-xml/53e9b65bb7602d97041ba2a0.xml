<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Monotonicity in Markov Reward and Decision Chains: Theory and Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ger</forename><surname>Koole</surname></persName>
							<email>koole@few.vu.nl</email>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Yao</surname></persName>
							<email>yao@columbia.edu</email>
						</author>
						<author>
							<persName><forename type="first">Venkat</forename><surname>Ananthamram</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics</orgName>
								<orgName type="institution">VU University</orgName>
								<address>
									<addrLine>Amsterdam De Boelelaan 1081a</addrLine>
									<postCode>1081</postCode>
									<settlement>Amsterdam, HV</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">now Publishers Inc</orgName>
								<address>
									<postBox>PO Box 1024</postBox>
									<postCode>02339</postCode>
									<settlement>Hanover</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">now Publishers Inc</orgName>
								<address>
									<postBox>PO Box 179</postBox>
									<postCode>2600 AD</postCode>
									<settlement>Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<postBox>PO Box 1024</postBox>
									<postCode>02339</postCode>
									<settlement>Hanover</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">IEOR Department</orgName>
								<orgName type="institution">Columbia University</orgName>
								<address>
									<postCode>10027-6699</postCode>
									<settlement>New York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Soren Asmussen (Lund University/ Aarhus University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">Cambridge University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="department">Department of Mathematics</orgName>
								<orgName type="institution">VU University Amsterdam</orgName>
								<address>
									<addrLine>De Boelelaan 1081a, The Netherlands</addrLine>
									<postCode>1081 HV</postCode>
									<settlement>Amsterdam</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Monotonicity in Markov Reward and Decision Chains: Theory and Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">13FF660E0F5F25907DBDB907AA298B1B</idno>
					<idno type="DOI">10.1561/0900000002</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Order Conditions 6</term>
					<term>2 Schur Convexity 6</term>
					<term>3 Convexity 6</term>
					<term>4 Bibliographical Notes 7 Propagation Results 7</term>
					<term>1 Environment Operators 7</term>
					<term>2 Arrival Operators 7</term>
					<term>3 Departure Operators 7</term>
					<term>4 Transfer Operators 8 Monotonicity of Control 8</term>
					<term>1 Arrival Operators 8</term>
					<term>2 Departure Operators 8</term>
					<term>3 Transfer Operators 9 Models 9</term>
					<term>1 First-Order Conditions 9</term>
					<term>2 Schur Convexity 9</term>
					<term>3 Convexity in One Dimension 9</term>
					<term>4 Convexity in Multiple Dimensions 9</term>
					<term>5 Convexity in Two Dimensions 10 Other State Spaces 11 Comparing Systems 11</term>
					<term>1 Comparing Different Arrival Processes 11</term>
					<term>2 Monotonicity in Parameters 11</term>
					<term>3 More-Dimensional Models 11</term>
					<term>4 Bibliographical Notes</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper focuses on monotonicity results for dynamic systems that take values in the natural numbers or in more-dimensional lattices. The results are mostly formulated in terms of controlled queueing systems, but there are also applications to maintenance systems, revenue management, and so forth. We concentrate on results that are obtained by inductively proving properties of the dynamic programming value function. We give a framework for using this method that unifies results obtained for different models. We also give a comprehensive overview of the results that can be obtained through it, in which we discuss not only (partial) characterizations of optimal policies but also applications of monotonicity to optimization problems and the comparison of systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contents 1 Introduction 2 Typical Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Server</head><p>-Assignment Models 2.2 Routing Models 2.3 Bibliographical Notes 3 The Framework 3.1 A Motivating Example 3.2 Operators and Events 3.3 Bibliographical Notes 4 Criteria and the Environment 4.1 Cost Criteria and Markov Decision Processes 4.2 The Environment 4.3 Continuous Time 4.4 Bibliographical Notes</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Editorial Scope</head><p>Foundations and Trends R in Stochastic Systems will publish survey and tutorial articles in the following topics: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Dynamic programming (DP) is a versatile method that can be used to analyze dynamical systems with a possibly stochastic transition mechanism. Above all, it is a numerical method for so-called Markov decision chains (MDCs), in which there are actions to be taken. In systems without actions DP can also be used to find performance indicators (as an alternative to the method that computes the stationary distribution first). These systems are called Markov reward chains, where the reward refers to the performance measure. However, DP can also be used as a theoretical means to obtain certain properties of Markov decision/reward chains. That is the subject of this paper. The focus in this paper is on dynamic programming methods to obtain monotonicity results for queueing and other types of systems. The results that we obtain for MDCs can be used to characterize, partially or completely, optimal policies. In the context of Markov reward chains we obtain certain monotonicity results in the states, which can then be used in other optimization problems or to compare systems that, for example, differ in certain parameter values. Relevant results that are not obtained through DP are mentioned (but not proven) to give a complete picture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Typical Results</head><p>This chapter gives an idea of the structural results that can be obtained with dynamic programming. We discuss two representative models and their variants and generalizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Server-Assignment Models</head><p>Consider the following controlled queueing model. Customers of m different types arrive according to some process at a service station with a single server. Class-i customers require an exponentially distributed service time with parameter µ(i). Each time unit a class-i customer spends waiting costs c(i), service may be interrupted. How to assign the server as to minimize the long-run average costs?</p><p>The answer to this question is the so-called µc rule: the customers should be served in decreasing order of µ(i)c(i). When the server is serving class j and a customer of a class i with µ(i)c(i) &gt; µ(j)c(j) enters then the service should be interrupted and the server moves to class i. This result can be shown in a number of ways, one of them being dynamic programming (DP).</p><p>It can be generalized in a number of ways. An example is the criterion: instead of long-run average costs, we can consider expected discounted costs or even the expected costs at some time T . For all these criteria the µc rule is optimal.</p><p>For a number of interesting generalizations, it is convenient to reformulate the original question as follows: what are the conditions to the model to make that the policy that serves preemptively the customer with the smallest index first is optimal? We just saw that this smallest index policy (SIP) is optimal in case that µ( <ref type="formula" target="#formula_8">1</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>)c(1) ≥ • • • ≥ µ(m)c(m).</head><p>Now we add one or more servers. Under the additional assumption that µ(1) ≤ • • • ≤ µ(m) the SIP is again optimal. This can be proven with dynamic programming. The proof uses the same techniques as the proof for the single-server case, and a considerable part is completely the same. The result holds not only for the linear cost structure, but also for other objectives. One of the objectives that is allowed is the time until the system is empty for the first time, the makespan. This shows that the longest expected processing times first policy (LEPT) is optimal for the problem of minimizing makespan. In the case of linear costs, it follows that the condition µ(1) ≤ • • • ≤ µ(m) allows us to take the probability that the costs exceed a certain level as direct costs. Thus, under this assumption, the µc rule not only minimizes the expected costs at T , but it also minimizes the costs at T in distribution. A final generalization made possible by the condition µ <ref type="bibr" target="#b0">(1)</ref> </p><formula xml:id="formula_0">≤ • • • ≤ µ(m)</formula><p>is the fact that we can allow a certain dependence of the arrival process on the queue length: the arrival process can also be controlled using decisions that may depend on the numbers of customers. The SIP remains optimal. With this we can for example model more than one server in tandem, in which case SIP should be used at the final server.</p><p>Server-assignment models are discussed in detail in Section 9.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Routing Models</head><p>Let us look at another type of controlled queueing model, with a single customer class and two servers. Customers are assigned to a server at the moment of arrival. We try to minimize the total expected number of customers in the system. When service times are exponentially distributed with rate µ(i) for server i, then the optimal routing policy can be characterized as follows: when the faster server has less or as many customers in queue as the slower server, then a new arrival should be assigned to the faster server. This result can also be obtained using dynamic programming. By symmetry arguments it leads to the send to the shortest queue policy (SQP) in the case of equal service rates. Our result, for the asymmetric case, characterizes the optimal policy in half of all possible configurations, and can be generalized in a number of ways (more than 2 queues, finite buffers, other costs and criterion, controlled arrivals, and so forth). But how about the other states, where the faster server has the longer queue? One would expect that the optimal policy would be monotone in the following way: if in state (x 1 , x 2 ) (with x i denoting the number of customers at server i) it is optimal to assign to queue 1, then the same holds true in (x 1 , x 2 + 1) and consequently in all states (x 1 , x 2 + y) with y &gt; 0. This can indeed be shown using DP arguments. By symmetry arguments this leads to an increasing switching curve in the (x 1 , x 2 )-plane indicating the boundary between states where it is optimal to assign to queue 1 or 2. This result is only proven for 2 queues and a single server at each queue, but otherwise it can be generalized in many directions. For example, we can allow for dedicated arrivals streams, finite buffers, and customers that move from one queue to the other if it is optimal to do so. This allows us to model the following system: arrivals to queue 1 only, and the possibility to move queued customers to a second (often slower) server, but not back. Thus the monotonicity also holds for this system: it is only optimal to move servers to the slower server when there are more than a certain number of customers in queue, the threshold. Threshold policies are best known from one-dimensional controlled queueing systems, where arriving customers are rejected when the total number of customers in the system exceeds the threshold. One of the threshold policies minimizes the weighted sum of rejection and holding costs. The proof of this result is by showing convexity of the socalled dynamic programming value function, as a function of the number of customers in the system. This convexity also holds for the uncontrolled single-server queue. Actually, a generalization of convexity to two-dimensional lattices is at the basis of the threshold result described above. We saw how this convexity can be used for deriving properties of the optimal policy. However, it can also be used to compare controlled or uncontrolled queueing systems. As an example, consider two single-server queues which differ only in their arrival processes. One has a regular (possibly inhomogeneous) Poisson process as arrival process. The other has queue has arrival according to a Poisson process with a lower rate and batch arrivals such that the average number of arrivals is equal in both queues. It can be shown using DP that the expected queue length in the queue with batch arrivals is higher. By taking the right limits this result can be used to show that a fluid queue has a lower expected workload then the corresponding M/G/1 queue. Crucial to the proof is the convexity of the value function.</p><p>In the next chapter, we start with a discussion of the technical details of the method, by looking at the M/M/1 queue with admission control. They are discussed in their full generality in Section 9.3. "Firstorder" results for routing models (such as the optimality of the SQP) are treated in Section 9.2, "second-order" results (such as the existence of a switching curve) for two dimensions are discussed in Section 9.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Bibliographical Notes</head><p>Over the years a number of overviews of monotonicity results have appeared. We mention Stidham and Weber <ref type="bibr" target="#b76">[77]</ref> and Stidham <ref type="bibr" target="#b74">[75]</ref>.</p><p>Puterman <ref type="bibr" target="#b64">[65]</ref> is the standard reference for Markov decision chains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Framework</head><p>In this chapter we introduce the general framework. We start with a motivating example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A Motivating Example</head><p>Consider an M/M/1 queue with arrival rate λ and service rate µ. At each arrival instant we are allowed to reject the arriving customer, at costs R per rejected customer. On the other hand, every customer in the system costs 1 per unit of time. What is the policy that minimizes the long-run average costs? Value iteration, a standard numerical method from Markov decision theory, combined with uniformization, to make the continuous-time problem discrete, can be used to solve this problem.</p><p>To see how uniformization works, we should realize that in all states except the empty state 0, there are two events possible: an arrival (which is possibly rejected), and a departure. In the empty state only an arrival can occur. If we allow for transitions from a state to itself then the rate out of each state except 0 is λ + µ. By adding a dummy of fictitious transition from state 0 to itself with rate µ we find that the rate out of each state is λ + µ, without exception, for every policy. Now we consider the embedded discrete-time Markov decision chain (MDC) by looking at the system only at transition instants. They occur according to a Poisson process with rate λ + µ. The instantaneous holding costs for the embedded chain count for the whole period until the next transition, and should therefore be multiplied with (λ + µ) -1 . Now we define the dynamic programming (DP) value function. Let V n (x) be the minimal expected total costs for the embedded decision chain if there are n more jumps to go, n &gt; 0. We take V 0 (x) = 0. Then we can express V n (x) in V n-1 (x) in the following way. First the holding costs until the next jump x/(λ + µ) are incurred. Then one of two things can happen: a departure, with probability µ/(λ + µ), or an arrival, with probability λ/(λ + µ). In the former case, we move to x -1 (or to x, if x = 0). In the latter case we have to decide whether to accept the arriving customer. As V n (x) are the minimal expected total costs, we can take the expectation with respect to the next state:</p><formula xml:id="formula_1">V n (x) = x λ + µ + µ λ + µ V n-1 ((x -1) + ) + λ λ + µ min{R + V n-1 (x), V n-1 (x + 1)}. (<label>3.1)</label></formula><p>For each n &gt; 0 and every state x ∈ IN 0 there is a minimizing action: rejection or admission. For fixed n we call this function IN 0 → {rejection, admission} a policy. For n → ∞ this policy converges to the average optimal policy, that is, the policy that minimizes the long-run expected average costs (see Section 4.1 for more details). Now consider threshold policies. A threshold policy is characterized by the fact that if rejection is optimal in x, then rejection is also optimal in x + 1.</p><p>A sufficient condition for this is</p><formula xml:id="formula_2">R + V n-1 (x) ≤ V n-1 (x + 1) ⇒ R + V n-1 (x + 1) ≤ V n-1 (x + 2).</formula><p>This is satisfied if</p><formula xml:id="formula_3">R + V n-1 (x) -V n-1 (x + 1) ≥ R + V n-1 (x + 1) -V n-1 (x + 2),</formula><p>which is equivalent to convexity on IN 0 :</p><formula xml:id="formula_4">2V n-1 (x + 1) ≤ V n-1 (x) + V n-1 (x + 2).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A Motivating Example 9</head><p>The crucial step in showing the optimality of a threshold policy is showing the convexity of the value function. This convexity holds for every n, and therefore the average optimal policy is also of threshold type. The convexity can be proven by induction to n.</p><p>The inductive proof consists of proving the induction step for every component of the value function. Thus, assuming that V n-1 (x) is convex, we prove that the direct costs x/(λ + µ), the departure term V n-1 ((x -1) + ), and the arrival term min{R + V n-1 (x), V n-1 (x + 1)} are all convex functions of x. Then we use the fact that convex combinations and sums of convex functions are again convex. From this it follows that V n (x) is convex and the induction step is done.</p><p>It should be noted that to prove that</p><formula xml:id="formula_5">V n-1 ((x -1) + ) is convex we also need that V n-1 (x) is increasing in x.</formula><p>An important observation is the fact that the proof of the convexity is largely the same if we change part of the model. Take for example the uncontrolled M/M/1 queue with linear holding costs. Although there are no actions, we can again formulate the value function, by replacing min{R + V n-1 (x), V n-1 (x + 1)} by V n-1 (x + 1) in the value function <ref type="bibr">(3.1)</ref>. The convexity and increasingness can again be proven inductively. What changes are the arguments used for proving the convexity for the arrival term V n-1 (x + 1).</p><p>In this example we clearly see the central role of the functional properties convexity and increasingness, and of propagating these properties through the building blocks of the value function, which are related to the possible events in the queueing system. New events can easily be added by checking whether increasingness and/or convexity propagate. This way we get a set of events for each set of functional properties. Each value function then has the properties belonging to the corresponding set of events. Up to now we encountered the events that model a single server, admission control, and uncontrolled arrivals. The costs can also be interpreted as an event, as well as taking linear combinations. Now the value function consists entirely of event operators, and its properties follow directly from the properties of the composing events. Studying the equivalent discrete-time model becomes almost trivial: we simply replace the uniformization operator by a concatenation of operators as they occur on the transition times. It follows immediately that the results for the continuous-time model hold as well for this discrete-time model. Many other models can be studied by adding new events. Events that we consider include: an event for an environment that allows us to have general arrival processes, controlled departures, and multiple servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Operators and Events</head><p>We now define formally the operators and the value functions that we consider. We consider models with m dimensions, often queues, and a separate environment. The queues take values in IN 0 = {0, 1, . . .}. The same holds for the environment. (Other types of state spaces are shortly discussed in Chapter 10.) Event operators map a function from the states to IR to a new function from the states to IR, and value functions are basically concatenations of event operators. This leads to the following definitions. ; -Let V be the set of functions from X to IR (elements of V can be thought of as real-valued vectors the size of the state space); -For some k ∈ IN we define event operators T 0 , . . . , T k-1 as follows:</p><formula xml:id="formula_6">T i : V l i → V, l i ∈ IN, for i = 1, . . . , k; -The value function V n for n ∈ IN is defined recursively using the auxiliary V (0) n , . . . , V (k) n : -V (k) n = V n-1 ; -V (j) n = T j (V (k 1 ) n , . . . , V (k l j ) n ), j = 0, . . . , k -1, for k 1 , . . . , k l j such that j &lt; k 1 , . . . , k l j ≤ k; -V n = V (0) n .</formula><p>We model (3.1) to make the ideas behind the definition clear. Take m = 1. Then the states are two-dimensional: the 0th component is the environment, the 1st component the actual queue length. Take k = 4,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Operators and Events 11 and define</head><formula xml:id="formula_7">T 0 f (x) = x 1 λ + µ + f (x) (the direct costs), T 1 (f 1 , f 2 )(x) = µ λ + µ f 1 (x) + λ λ + µ f 2 (x) (uniformization), T 2 f (x) = f ((x -e 1 ) + ) (departures),</formula><p>and</p><formula xml:id="formula_8">T 3 f (x) = min{R + f (x), f(x + e 1 )} (admission control). Now take V (0) n = T 0 V (1) n , V<label>(1)</label></formula><formula xml:id="formula_9">n = T 1 (V (2) n , V (3) n ), V<label>(2)</label></formula><formula xml:id="formula_10">n = T 2 V (4)</formula><p>n , and</p><formula xml:id="formula_11">V (3) n = T 3 V (4)</formula><p>n . This leads to</p><formula xml:id="formula_12">V n (x) = T 0 (T 1 [T 2 (V n-1 ), T 3 (V n-1 )]).<label>(3.2)</label></formula><p>Once written out this is completely equivalent to (3.1), except for the fact that there is an environment state that remains constant. This will become relevant as soon as we model non-Poissonian arrival streams.</p><p>The central idea of how to use the value function as we defined it in Definition 3.1 is summarized in the following theorem: Theorem 3.1. Let F be some class of functions from X to IR, V n as defined in Definition 3.1, and V 0 ∈ F. If, for all i, for f 1 , . . . , f l i ∈ F it holds that T i (f 1 , . . . , f l i ) ∈ F, then also V n ∈ F for all n.</p><p>We illustrate the use again with the value function <ref type="bibr">(3.1)</ref>. Take F the set of increasing and convex functions. It can be shown (see Section 9.3) that F propagates through the operators T 0 , . . . , T 3 , as defined below Definition 3.1.</p><p>Depending on the combination of operators and the results we try to obtain we use different classes of functions. For each class F and operator T we derive the "biggest" F with F ⊂ F such that if f 1 , . . . , f l ∈ F holds that T (f 1 , . . . , f l ) ∈ F. This is notated as follows: T : F → F. Let us apply this to the queue with admission control. Denote the class of increasing function with I and the class of convex function with Cx.</p><p>It is shown in Section 9.3 that:</p><formula xml:id="formula_13">-T 0 , T 1 , T 3 : I → I, Cx → Cx; -T 2 : I → I, I ∩ Cx → Cx.</formula><p>In fact, for T 2 convexity by itself does not propagate: F should be restricted to the class of convex and increasing functions. To obtain the optimality of the threshold policy convexity is sufficient, but to propagate this property through T 2 we also need I. Luckily, I propagates through all operators. Thus the class to take is I ∩ Cx, leading to:</p><formula xml:id="formula_14">-T 0 , T 1 , T 2 , T 3 : I ∩ Cx → I ∩ Cx.</formula><p>Now we can use Theorem 3.1 to show that V n is increasing and convex. This shows the optimality of a threshold policy for this model, using the reasoning on Page 7.</p><p>In the next chapters, we will look at different groups of classes of functions. We do this in a systematic way. Chapter 4 deals with the criteria and the role the environment (the 0th state variable) plays. In Chapter 5, we define all the operators we consider, and in Chapter 6 we consider all the inequalities we are interested in, and some of their relations. In Chapter 7, we consider all operators one by one and we determine under which addtional conditions the operators preserve the functional inequalities defined in Chapter 6. In Chapter 8, we determine for the controlled operators what the consequences are for the optimal actions as functions of the states (e.g., threshold optimality). Then, in Chapter 9, we consider sets of functions and determine which set of operators propagate for each set. As an example, in Section 9.3 we look at one-dimensional convex functions, for which the model taken as example in this chapter is the main representative.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Bibliographical Notes</head><p>In several papers unifying frameworks for the study of monotonicity results have been introduced. Veatch and Wein <ref type="bibr" target="#b80">[81]</ref>, Glasserman and Yao <ref type="bibr" target="#b25">[26]</ref> and Altman and Koole <ref type="bibr" target="#b5">[6]</ref> all consider a class of functions related to submodularity (see Sections 6.3 and 9.4), resulting in the fact that the occurence of an event increases the optimal rate for any other event. This limits the number of models covered by these papers.</p><p>References <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b25">[26]</ref> both give the score space a central place. Basically, the score space counts the number of times that different events have occurred, and the actual state is a function of the current score. As a result, the score space has more dimensions than the state space. For this reason stronger results can often be obtained by working directly in the state space. See Section 9.4 for more details.</p><p>The current framework was introduced in Koole <ref type="bibr" target="#b39">[40]</ref> (where it was called event-based DP).</p><p>The main objective of this paper is to study certain classes of value functions of the form given in Definition 3.1, to look which classes of functions propagate through the operators used in the value functions, in order to obtain V n ∈ F for certain classes of functions F, using Theorem 3.1.</p><p>In this chapter we look at the relation between the original system and the value function. That is, we look how the structural result (of the type V n ∈ F, or some consequence of that concerning the policy at stage n) translates back to the original problem, for example in terms of the average cost long-run optimal policy. We look at different cost criteria, discrete and continuous-time models, and the possibility of an environment (the 0th state variable) that regulates the rates at which operators occur. We also pay attention to the special role that direct cost play.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Cost Criteria and Markov Decision Processes</head><p>For the moment we assume a discrete-time setting. In the literature, we encounter for (controlled) stochastic processes different ways to evaluate performance. Concentrating on costs, we differentiate between long-run average costs, long-run discounted costs, total costs over a finite (possibly random) horizon, and costs at a (possibly random) time instant.</p><p>We assume that the system under consideration can be described by a (time-homogeneous) Markov decision chain (MDC) or process. Then any of the criteria above can be evaluated by the use of a value function of the following form, n ∈ IN:</p><formula xml:id="formula_15">V n (x) = min a∈A c(x, a) + α n y∈X p(x, a, y)V n-1 (y) , (<label>4.1)</label></formula><p>with p(x, a, •) a probability distribution for state x ∈ X and action a ∈ A, c(x, a) ∈ IR, α n ∈ [0, 1] for all n, and V 0 given.</p><p>Let us look at the criteria one by one. If α n = 1 and V 0 (x) = 0, then V n (x) represents the minimal total costs for a horizon of length n for initial state x ∈ X . On the other hand, if c(x, a) = 0 but V 0 (x) = C(x) for some cost function C, then V n (x) represents the total minimal expected costs after n time units.</p><p>By choosing all α n = 1 the costs at every time instant are equally weighted in the total costs. By taking α n &lt; 1 early costs are weighted more (and vice versa). For a horizon n, costs after k time units are weighted with a factor α n • • • α n-k+1 . It is common to take α n = α, costs after k time units are weighted with a factor α k . This is called discounting, with the interest rate r is related to α as follows: α = (1 + r) -1 , i.e., r = (1α)/α. An alternative way to look at discounting is as total costs with a random horizon: 1α n is the probability of an horizon of length 1, α n (1α n-1 ) is the probability of an horizon of length 2, etc.</p><p>More common objectives are the long-run discounted and long-run average costs. For α n = α &lt; 1 the value function V n converges to the minimal expected long-run discounted costs, under certain conditions. Discounting can be seen as a random geometrically distributed horizon. If α n = 1 for all n then V n usually does not converge, not even for well-constructed models. Instead, V n+1 (x) -V n (x) converges to the minimal long-run average costs, under certain conditions (which are more restrictive than those for the discounted case). Elaborating on It is tempting to derive results only for costs at a fixed horizon, thus c(x, a) = 0 and V 0 (x) = C(x). Results involving (discounted) costs over multiple periods can then be derived by summing in the adequate way over the horizon. However, an important complication of using finitehorizon criteria is the fact that optimal policies depend on the horizon, they are time-dependent. Thus considering costs at the horizon does not suffice, unless we have a system without actions or if the optimal policy is the same for all horizons. If the latter is the case then the policy is called myopic, because the optimal policy for horizon 1 is optimal for all n.</p><p>As an example, consider the queue with controlled admissions of Equation (3.1), with parameter values λ = µ = 1 and R = 4. For small n admission is always optimal: the costs of holding a customer in queue over a short period is cheaper than rejecting a customer. For n = 10 it is optimal to reject in all states except {0, 1, 2}, and from n = 11 on the optimal policy is equal to the long-run optimal policy: accept only in states 0 and 1.</p><p>However, Equation (3.1), and, in general, the class of value functions defined in Definition 3.1, is not in the standard form of Equation (4.1). But, if we choose the operators T i of the form:</p><formula xml:id="formula_16">T i (f 1 , . . . , f l i )(x) = min a∈A i c i (x, a) + l i j=1 y∈IN m 0 p j i (x, a, y)f j (y) , (4.2)</formula><p>with j y p j i (x, a, y) = 1, and one operator of the form f → C + αf then it is possible to choose c and p in (4.1) such that both definitions are equivalent (see Theorem 2.2 of <ref type="bibr" target="#b39">[40]</ref>).</p><p>It is this latter operator that represents the discounting.</p><p>Definition 4.1. The operator T disc is defined by:</p><p>-</p><formula xml:id="formula_17">T disc f (x) = C(x) + αf (x) for some real-valued function C</formula><p>The current definition is for a constant discount rate. To model discount factors that depend on n the operators should depend on n as well (or, alternatively, α could depend on the environment, with the environment "counting" time: see Section 4.2).</p><p>As an example of the use of T disc , consider Equation (3.1) with discounting. Then in Equation (3.2) operator T 0 gets replaced by</p><formula xml:id="formula_18">T disc with C(x) = x 1 /(λ + µ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Environment</head><p>Dimension 0 of our state space will be used for the environment. The environment will allow us to model all kinds of variations in the model. Examples are server vacations and varying probabilities by which events occur. As long as the evolution of the environment is not influenced by the state of dimensions 1 upto m then all the monotonicity results of the following chapters still hold.</p><p>An important application of an environment is for modeling continuous-time models with general "inter-event" distributions; see Section 4.3. Definition 4.2. The operator T env is defined by:</p><formula xml:id="formula_19">-T env (f 1 , . . . , f l )(x) = y∈IN 0 λ(x 0 , y) l j=1 q j (x 0 , y)f j (x * ),</formula><p>where x * is equal to x with the 0th component replaced by y.</p><p>In this definition λ(x, y) is the probability with which the environment moves from x to y, and q j (x, y) is the probability of a type j arrival or mark during such a transition.</p><p>In general the monotonicity results do not hold anymore when the environment depends on the state of dimensions 1 upto m. Counterexamples are easily constructed. However, there is one type of dependency that can be propagated through certain useful classes of functions, and that is when the dependence is modeled through actions taken in the environment. Usually we work in a setting where it is the objective to minimize costs. The environment can either be cost-minimizing, or cost-maximizing. The latter situation makes it a zero-sum game. (Note by the way that there are no methodological objections of including maximizations in other operators.)</p><p>This leads to the following definitions: Definition 4.3. The operators T min and T max are defined by:</p><formula xml:id="formula_20">-T min (f 1 , . . . , f l )(x) = min a y∈IN 0 λ(x 0 , a, y) l j=1 q j (x 0 , a, y)f j (x * ) ; -T max (f 1 , . . . , f l )(x) = max a y∈IN 0 λ(x 0 , a, y) l j=1 q j (x 0 , a, y)f j (x * ) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Continuous Time</head><p>In this chapter we considered up to now discrete-time models. The current section will show how these models can be used to model certain continuous-time systems. In the literature there are three different methods by which we can model continuous-time systems in discrete time: uniformization, discretization, or embedding. We discuss all three, starting with uniformization (see also Section 3.1). The framework in which we discuss it is as follows. We assume we have a number of events (arrivals, departures, and so forth), each controlled by a point process (or a marked point process, the mark indicating the type of event). (Note the similarities with semi-Markov (decision) processes.)</p><p>The exponential distribution plays a crucial role in uniformization, and indeed, the simplest case is when the time between two events of the same type has an exponential distribution, independent of all other inter-event times, with a parameter depending on the event type, say λ j for event type j. Now the time until the next event is exponentially distributed with parameter i λ i . The probability that the event j happens at a jump time is λ j / i λ i . This leads to the following operator that models uniformization, which is actually a special case of T env .</p><p>Definition 4.4. The operator T unif is defined by:</p><p>-</p><formula xml:id="formula_21">T unif (f 1 , . . . , f l )(x) = j p(j)f j (x) with p(j) &gt; 0 for all j.</formula><p>In the definition, p(j) = λ j / i λ i ; normally they would sum to 1.</p><p>The operator T env can be used to model systems with general "interevent" distributions. This follows from the fact that Markov Arrival Processes (MAPs), or marked point processes, can be modeled with an environment. An MAP is a Markov process that at transitions generates events of different types. In the current context these arrivals generate occurrences of operators operating on dimensions 1 upto m. It can be shown that the set of MAPs is dense in the class of all arrival processes. This way monotonicity results for general arrival processes can be obtained, almost without additional effort. What is crucial here is that the events occur independent of the state components x 1 , . . . , x m . Thus, in general, this cannot be applied to departure processes, because when a queue is empty then the departure process is temporarily stopped. Note that for exponential service times this did not pose a problem: we worked with a continuing process of potential departures, that only became real departures when the queue was nonempty. Thus an M/G/1 queue cannot be modeled with this; two parallel exponential queues (even with dependent arrival processes) can.</p><p>Uniformization is an elegant and powerful method, but it has a number of limitations. When used for modeling non-exponential inter-event times, then the state space has an additional component that can be computationally burdensome. A way around this is embedding if there is only one non-exponential inter-event time. Next to that, it is hard to use uniformization for finite-horizon models. Then discretization can be a better alternative. Let us discuss embedding first.</p><p>Consider a system with a single generally distributed inter-event distribution and one exponential inter-event distribution. Instead of approximating the generally distributed inter-event distribution by a phase-type distribution and making the phase dimension 0, which is essentially what uniformization does, we can also take the arrival epochs as the transition epochs of the value function. The consequence is that between jump times, i.e., during each inter-arrival time, a geometric number of potential departures occur.</p><p>As an example, consider the controlled GI/M/1 queue, the basic model of Stidham <ref type="bibr" target="#b72">[73]</ref>. This can be modeled by</p><formula xml:id="formula_22">V n+1 = T disc T CA T unif V n , T D V n , T 2 D V n , . . . ,</formula><p>with T CA the controlled arrival operator and with T j D the j-fold convolution of the departure operator T D , and with p(j), the coefficient of T j D V n , the probability that j (potential) departures occur during an inter-arrival time. (See Chapter 5 for the definitions of T CA and T D .)</p><p>Embedding can also be useful if the transition rates are unbounded, as in the M/M/∞ queue. Note that in the M/M/∞ queue there is no lower bound for the expected time that we stay in a state. Therefore uniformization cannot be used. A way around is only looking at arrival instances, again with the consequence that there is a random number of departures during each period. This approach was used in Hariharan et al. <ref type="bibr" target="#b29">[30]</ref>. In Liang and Kulkarni <ref type="bibr" target="#b48">[49]</ref> another approach was chosen for a retrial queue that can have an unbounded number of customers in orbit: the total rate out of the orbit is bounded from above.</p><p>Uniformization is the obvious choice for long-run average and discounted cost problems. It can also be used for finite-horizon criteria, but in that case the total number of jumps becomes finite and random. In general, optimal policies depend on the stage n; which n to use? For this reason we can only use this method for systems in which the optimal policy does not depend on n, i.e., uncontrolled systems or systems in which the optimal policy is myopic (i.e., for all n equal, see <ref type="bibr">Page 17)</ref>. An alternative method for non-myopic systems in this case is timediscretization, i.e., looking at the systems at discrete points in time with short times in between. As the lengths of these intervals approaches 0 the performance approaches that of the continuous-time system. At the same time the probability of more than 1 event approaches 0. Discretization has an operator equal to uniformization, but with one of the functions f j equal to the identity function.</p><p>There is an important difference between discounting and embedding in the case of controlled models. Optimal policies depend in general on the entire state. If there is an environment, then there will be a policy for every state of the environment. In the case of embedding without environment there will be a single policy.</p><p>There is one final issue to be discussed concerning continuous-time systems. There are systems where actions are taken continuously over time and those where actions are only taken at jump times. To illustrate the different types of actions consider again the queue with admission control. The action whether or to admit a customer plays only at the arrival instant which is a jump moment. Now suppose we can also control the service rate, depending on the number of customers in queue. It is interesting to consider as well the possibility to change the service rate between jump times, leading to a situation where one continuously wants to determine the optimal policy. However, uniformization and embedding do not allow for actions changing inbetween epochs. Discretization does neither, but the time between decision epochs goes to 0, thus it approaches continuous control. Note however that for controlled models uniformization is mostly used for the infinite-horizon criteria. Whether or not the action can be changed between jumps is not an issue: the optimal policy is time-homogeneous, so there is no reason to change action between jumps. For the finite horizon and a myopic optimal policy there is neither a reason to change actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Bibliographical Notes</head><p>Uniformization was first used in the setting of proving monotonicity in Lippman <ref type="bibr" target="#b50">[51]</ref>. Serfozo <ref type="bibr" target="#b69">[70]</ref> made some useful extensions to this method. Discretization results that can be applied in the current context were obtained in Van Dijk <ref type="bibr" target="#b78">[79]</ref>.</p><p>The concept of the controlled environment is introduced in Hordijk and Koole <ref type="bibr" target="#b32">[33]</ref>. Putting this in a game-theory setting, with both minimization and maximization in the same value function, was done in Altman and Koole <ref type="bibr" target="#b3">[4]</ref>.</p><p>The result that MAPs are dense in the class of all arrival processes can be found in Asmussen and Koole <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Operators</head><p>In this chapter we define all operators that are used in the subsequent chapters. We start by repeating the generic operators from Chapter 4. Definition 5.1. We define the following generic operators, where x * is equal to x with the 0th component replaced by y:</p><formula xml:id="formula_23">-T disc f (x) = C(x) + αf (x) for some real-valued function C; -T env (f 1 , . . . , f l )(x) = y∈IN 0 λ(x 0 , y) l j=1 q j (x 0 , y)f j (x * ); -T min (f 1 , . . . , f l )(x) = min a y∈IN 0 λ(x 0 , a, y) l j=1 q j (x 0 , a, y)f j (x * ) ; -T max (f 1 , . . . , f l )(x) = max a y∈IN 0 λ(x 0 , a, y) l j=1 q j (x 0 , a, y)f j (x * ) .</formula><p>Next we define operators that are used to model arrivals of customers. Definition 5.2. We define the following arrival operators, for 1 ≤ i ≤ m:</p><formula xml:id="formula_24">-T A(i) f (x) = f (x + e i ); -T CA(i) f (x) = min{c + f (x), c + f (x + e i )}, c, c ∈ IR; -T FS(i) f (x) = (1 -x i B )f (x + e i ) + x i B f (x) if x i ≤ B, f (x) otherwise; -T CAF f (x) = min{c + f (x), f(x + m i=1 e i )}; -T R f (x) = min 1≤i≤m f (x + e i ).</formula><p>Operator T A(i) models arrivals to dimension ("queue") i. Depending on the actual form of the value function, especially the environment, this can be used to model for example Poisson arrivals. The CA in T CA(i) stands for "controlled arrivals," it can be used to model admission control to a queue. T FS(i) is the finite-source operator to model Engset-type models. T CAF models controlled simultaneous arrivals (a "fork"), and T R models routing to one of the queues in I.</p><p>Note that the set I can be different for every operator (or even every time an operator is used).</p><p>Next we define operators that are used to model departures of customers.</p><p>Definition 5.3. We define the following departure operators, 1 ≤ i ≤ m, and I ⊂ {1, . . . , m} some index set:</p><formula xml:id="formula_25">-T D1(i) f (x) = f ((x -e i ) + ); -T D(i) f (x) = µ(x i )f ((x -e i ) + ) + (1 -µ(x i ))f (x) with 0 ≤ µ(x) ≤ 1 for all x ∈ IN and µ(0) = 0; -T PD f (x) = 1≤i≤m µ(i)f ((x -e i ) + ) with 1≤i≤m µ(i) = 1; -T CD(i) f (x) =    min µ∈[0,1] {c(µ) + µf (x -e i ) + (1 -µ)f (x)} if x i &gt; 0, c(0) + f (x)</formula><p>otherwise, with c(µ) ∈ IR for all µ ∈ [0, 1], assuming that the minimum always exists;</p><formula xml:id="formula_26">-T MS f (x) =    min j∈I:x j &gt;0 {µ(j)f (x -e j ) + (1 -µ(j))f (x)} if j∈I x j &gt; 0, f (x) otherwise, for µ(j) ≤ 1; -T MMS f (x) =                  1 s min i 1 ,...,is∈I: k∈I I{i k =j}≤x j s k=1 (µ(i k )f (x -ei k ) + (1 -µ(i k ))f (x)) if j∈I xj ≥ s, 1 s j∈I xj µ(j)f (x -ej) + (1 -µ(j))f (x) + s -j∈I xj s f (x) otherwise,</formula><p>for µ(j) ≤ 1.</p><p>Operator T D1(i) models a single server. It is a special case of T D(i) , where the departure probability is an arbitrary function of the number of customers x i . This can be used to model for example a multi-server queue. Sometimes we require additional conditions for the departure probability function, for example concavity. PD means parallel departures, T PD is in fact of the form T unif (T D1(1) , . . . , T D1(m) ). T CD(i) is the controlled departure operator, MS stands for movable server. Finally MMS stand for multiple movable servers. What makes the definition of T MMS complicated is the fact that different servers cannot work at the same customer.</p><p>Finally we define operators for moving from one queue to the next.</p><p>Definition 5.4. We define the tandem departure operators, for 1 ≤ i ≤ m:</p><formula xml:id="formula_27">-T TD1(i) f (x) = f (x -e i + e i+1(modm) ) if x i &gt; 0, f (x) otherwise; -T CTD(i) f (x) =    min µ∈[0,1] {c(µ) + µf (x -e i + e i+1(modm) ) + (1 -µ)f (x)} if x i &gt; 0, c(0) + f (x) otherwise; -T TD(i) f (x) = x i S f (x -e i + e i+1(modm) ) + S-x i S f (x) if x i &lt; S, f (x -e i + e i+1(modm) ) otherwise; -T MTS f (x) =      min j∈I:x j &gt;0 m k=0 µ(i, k)f (x -e i + e k ) if j∈I x j &gt; 0, f (x)</formula><p>otherwise, where m k=0 µ(i, k) = 1 for all i, µ(i, j) = 0 for all i and 0 &lt; j &lt; i -1, and e 0 = 0.</p><p>Operator T TD1(i) is an uncontrolled single server that feeds the next queue. T TD1(i) feeds queue 1, making a loop possible. T CTD1(i) adds the possibility of control, T TD(i) multiple servers. T MTS is a generalization of T MS : it is a movable tandem server. Here µ(i, k) represents the probability that a customer in queue i which is being served moves to queue k. k = 0 means leaving the system. Note that feedback is possible to lower numbered queues and the next higher queue.</p><p>In this chapter we define all inequalities that we use, and we show the relations between different (combinations of) inequalities. We use increasing and decreasing in the non-strict sense.</p><p>All functions we define have as domain IN m+1 0</p><p>, where the dimensions are numbered 0, . . . , m. Recall that dimension 0 is the environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">First-Order Conditions</head><p>In this section we define the first-order inequalities. Definition 6.1. We define the following sets of functions:</p><formula xml:id="formula_28">-f ∈ I(i) if f (x) ≤ f (x + e i ) for all x ∈ IN m+1 0 , 1 ≤ i ≤ m; -I = I(1) ∩ • • • ∩ I(m); -f ∈ UI(i) if f (x + e i+1 ) ≤ f (x + e i ) for all x ∈ IN m+1 0 , 1 ≤ i &lt; m; 27 -UI = UI(1) ∩ • • • ∩ UI(m -1); -f ∈ wUI(i) if µ(i)f (x + e i+1 ) + (1 -µ(i))f (x + e i + e i+1 ) ≤ µ(i + 1)f (x + e i ) + (1 -µ(i + 1))f (x + e i + e i+1 ) for all x ∈ IN m+1 0 , 1 ≤ i &lt; m, for given constants 0 &lt; µ(j) ≤ 1, 1 ≤ j ≤ m; -wUI = wUI(1) ∩ • • • ∩ wUI(m -1); -f ∈ gUI(i) if m k=0 µ(i, k)f (x + e i+1 + e k ) ≤ m k=0 µ(i + 1, k)f (x + e i + e k ), 1 ≤ i &lt; m, e 0 = 0, for given constants µ(j, k) such that m k=1 µ(j, k) = 1, 1 ≤ j ≤ m; -gUI = gUI(1) ∩ • • • ∩ gUI(m -1). The class I speaks for itself: f ∈ I if f is non-decreasing in all components.</formula><p>When f ∈ UI then it is advantageous to have customers in highernumbered queues, further down the line in case of a tandem system. UI stands for "upstream increasing." It should be noted that</p><formula xml:id="formula_29">UI ∩ I(m) ⊂ m ∩ i=1 I(i).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Indeed, summing the last i inequalities of UI and I(m) gives I(mi).</head><p>Another interpretation of UI is that we give priority to serve customers in low-indexed queues. UI ∩ I is exactly the class of functions characterized by the partial sum ordering of Chang et al. <ref type="bibr" target="#b18">[19]</ref>; see Koole <ref type="bibr" target="#b38">[39,</ref><ref type="bibr">Appendix C]</ref>.</p><p>wUI can be seen as a weighted version of UI. It is equivalent to</p><formula xml:id="formula_30">µ(i)f (x + e j ) + (1 -µ(i))f (x + e j + e i+1 ) ≤ µ(j)f (x + e i ) + (1 -µ(j))f (x + e i + e +1 )</formula><p>for all 1 ≤ i &lt; j ≤ m. An interesting special case for wUI is f (x) = m k=1 c(k)x k , i.e., f is linear. Then the following holds:</p><formula xml:id="formula_31">f ∈ wUI ⇔ µ(1)c(1) ≥ • • • ≥ µ(m)c(m). (6.1)</formula><p>To interpret gUI we go back to the interpretation of UI of giving priority to serving upstream (low-numbered) queues in a tandem system: gUI generalizes this to general networks where feedback to all queues is possible. Queue 0 represents departures (which has nothing to do with the fact that dimension 0 represents the environment).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Schur Convexity</head><p>The inequalities defined in Definition 6.1 have a simple interpretation: less customers is preferable (I) or customers in high-numbered queues are preferable over customers in low-numbered queues (UI and generalizations). The word "preferable" should be interpreted as "having a lower value," as if we try to minimize costs. These conditions do not take the length of the queue into account. Under UI, even if a highnumbered queue has many customers, adding a customer there is still preferable over adding a customer to queue 1. In this section, we study conditions that do take the length into account, that try the balance the queue lengths in some way. Definition 6.2. We define the following sets of functions:</p><formula xml:id="formula_32">-f ∈ SC if f (x + e i ) ≤ f (x + e j )</formula><p>for all x and i, j with i = j and x i ≤ x j and</p><formula xml:id="formula_33">f (x + ke i ) = f (x + ke j )</formula><p>for all x and i, j with i = j, x i = x j , and all k &gt; 0;</p><formula xml:id="formula_34">-f ∈ ASC if f (x + e i ) ≤ f (x + e j )</formula><p>for all x and i, j with i &lt; j and x i ≤ x j and</p><formula xml:id="formula_35">f (x + ke i ) ≤ f (x + ke j )</formula><p>for all x and i, j with i &lt; j, x i = x j , and all k &gt; 0.</p><p>Thus, if f ∈ SC, then the value of f (x) is lower if x is more balanced. Note also that f (x) does not change if x is permuted: the order of the queues does not matter. In Hordijk and Koole <ref type="bibr" target="#b31">[32]</ref>, it is shown that SC is actually the class of Schur convex functions. I ∩ SC is the class of weak Schur convex functions. See Marshall and Olkin <ref type="bibr" target="#b53">[54]</ref> for more information on Schur convexity and the corresponding majorization ordering.</p><p>ASC is a generalization of SC, where we allow asymmetry in the queues. Now the order does matter. If we require ASC for any possible ordering of the queues, then it is equivalent to SC. There is no simple characterization known for ASC (see Müller <ref type="bibr" target="#b56">[57]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Convexity</head><p>We define component-wise convexity and related multi-dimensional second-order properties. Definition 6.3. We define the following sets of functions:</p><formula xml:id="formula_36">-f ∈ Cx(i) if 2f (x + e i ) ≤ f (x) + f (x + 2e i ) for all x and 1 ≤ i ≤ m; -Cx = Cx(1) ∩ • • • ∩ Cx(m); -f ∈ Cv(i) if f (x) + f (x + 2e i ) ≤ 2f (x + e i ) for all x and 1 ≤ i ≤ m; -Cv = Cv(1) ∩ • • • ∩ Cv(m); -f ∈ Super(i, j) if f (x + e i ) + f (x + e j ) ≤ f (x) + f (x + e i + e j ) for all x and 1 ≤ i &lt; j ≤ m; -Super = ∩ 1≤i&lt;j≤m Super(i, j); -f ∈ Sub(i, j) if f (x) + f (x + e i + e j ) ≤ f (x + e i ) + f (x + e j )</formula><p>for all x and 1 ≤ i &lt; j ≤ m;</p><formula xml:id="formula_37">-Sub = ∩ 1≤i&lt;j≤m Sub(i, j); -f ∈ SuperC(i, j) if f (x + e i ) + f (x + e i + e j ) ≤ f (x + e j ) + f (x + 2e i ) for all x and 1 ≤ i, j ≤ m, i = j; -SuperC = ∩ 1≤i,j≤m:i =j SuperC(i, j); -f ∈ SubC(i, j) if f (x + e i ) + f (x + e i + e j ) ≤ f (x) + f (x + 2e i + e j )</formula><p>for all x and 1 ≤ i, j ≤ m, i = j; -SubC = ∩ 1≤i,j≤m:i =j SubC(i, j);</p><formula xml:id="formula_38">-f ∈ MM(i, j) if f (x) + f (x + d i + d j ) ≤ f (x + d i ) + f (x + d j ) for all x and 0 ≤ i &lt; j ≤ m such that x + d i , x + d j ∈ IN m+1 0 , with d 0 = e 1 , d k = -e k + e k+1 , k = 1, . . . , m -1, and d m = -e m ; -MM = ∩ 1≤i&lt;j≤m MM(i, j).</formula><p>Cx and Cv are evidently component-wise convexity and concavity. Next comes super-and submodularity. SuperC and SubC stand for super-and subconvexity. No appropriate terms existed; the current names are inspired by (but not exactly the same as) terminology used in Ghoneim and Stidham <ref type="bibr" target="#b24">[25]</ref>. Note that all four properties are symmetric in the two dimensions. Combining the right inequalities implies component-wise convexity:</p><formula xml:id="formula_39">Super(i, j) ∩ SuperC(i, j) ⊂ Cx(i) (6.2)</formula><p>and</p><formula xml:id="formula_40">Sub(i, j) ∩ SubC(i, j) ⊂ Cx(i). (6.3)</formula><p>This can easily be seen by adding the inequalities. MM stands for multimodularity. For m = 2 it holds that MM = Super ∩ SuperC because they consist of exactly the same equations. For higher dimensions MM consists of more equations.</p><p>Another property related to convexity is directional convexity, defined next.</p><formula xml:id="formula_41">Definition 6.4. A function f is called directionally convex if for all x, y, z ∈ IN m+1 0 , y 0 = z 0 = 0, f (x + y) + f (x + z) ≤ f (x) + f (x + y + z).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The class of directionally convex functions is denoted as DC.</head><p>There is a simple alternative characterization of directional convexity:</p><p>Cx ∩ Super = DC. (6.4)</p><p>See Koole <ref type="bibr" target="#b43">[44]</ref> for a proof. Note also that DC is weaker than MM for m = 2, using Equation (6.2). This also holds for general m, see Koole <ref type="bibr" target="#b43">[44]</ref>. A two-dimensional function which is in DC but not in SuperC(1, 2) is f (x) = x 1 x 2 ; thus Super ∩ SuperC DC.</p><p>In conclusion:</p><p>MM ⊂ Super ∩ SuperC Super ∩ Cx = DC ∩ Cx. (6.5)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Bibliographical Notes</head><p>MM was introduced in Hajek <ref type="bibr" target="#b28">[29]</ref> for the study of assignment rules to a queue. Its relation to monotonicity results was recognized in Stidham and Weber [77, on top of page 295], although it was used earlier in Hajek <ref type="bibr" target="#b27">[28]</ref> (for m = 2) and Weber and Stidham <ref type="bibr" target="#b82">[83]</ref> for controlled queueing systems, without making the connection with <ref type="bibr" target="#b28">[29]</ref>.</p><p>Altman et al. <ref type="bibr" target="#b0">[1]</ref> is a book that is completely dedicated to MM and its many applications.</p><p>DC was, according to Müller and Scarsini <ref type="bibr" target="#b57">[58]</ref>, introduced in Shaked and Shanthikumar <ref type="bibr" target="#b70">[71]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Propagation Results</head><p>In this chapter we combine the operators with the function sets we just defined. We use the same notation as on Page 11. When we write T : A → B then we mean to say: if f ∈ A, then T f ∈ B. The ideal situation is that A = B, but often we need additional inequalities. In all cases A ⊂ B.</p><p>Although we defined concavity, we will not propagate it, we only use it in the definition of some of the operators. We focus on convexity, often in combination with increasingness.</p><p>We discuss one by one the different sets of operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Environment Operators</head><p>Theorem 7.1. The following relations hold:</p><p>-T disc (with C in the left-sided set), T env :</p><formula xml:id="formula_42">I → I, UI → UI, wUI → wUI, gUI → gUI, SC → SC, ASC → ASC, Cx → Cx, Super → Super, Sub → Sub, SuperC → SuperC, Sub → Sub, MM → MM; -T min : I → I, UI → UI, wUI → wUI when µ(1) ≤ • • • ≤ µ(m), SC → SC, ASC → ASC; -T max : I → I, UI → UI, wUI → wUI when µ(1) ≥ • • • ≥ µ(m), SC → SC, ASC → ASC, Cx → Cx.</formula><p>Thus T disc and T env are "ideal" in the way we just discussed, i.e., T : A → A holds for any combination of sets defined in Chapter 6. Note that for T disc we need in all situations that C ∈ A. The operators T min and T max are less "ideal," T : A → A does not hold in cases where the inequality has multiple terms on the left-or right-hand side. For details, see the proof below.</p><p>Proof. For all inequalities we defined in Chapter 6 it holds that they are closed under convex combinations. From this the results for T disc and T env follow directly.</p><p>T min and T max are more complicated. Suppose we have a i + b i ≤ c i for certain numbers a i , b i , and c i . Then min i a i + min i b i ≤ min i c i . Indeed, suppose j = arg min i c i . Then, min i a i + min i b i ≤ a j + b j = c j = min i c i . Thus T min propagates when the right-hand side of an inequality consists of one term. By the same argument T max propagates when the left-hand side of an inequality consists of a single term. This explains T max : Cx → Cx, and the absence of the same result for T min . (Actually, T min : Cv → Cv holds.) It also explains the conditions for wUI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Arrival Operators</head><p>Theorem 7.2. The following relations hold, 1 ≤ i, j ≤ m, i = j:</p><formula xml:id="formula_43">-T A(i) : I → I, UI → UI, wUI → wUI, gUI → gUI, Cx → Cx, Super → Super, Sub → Sub, SuperC → SuperC, Sub → Sub, MM → MM; -T CA(i) : I → I, UI → UI, wUI → wUI when µ(1) ≤ • • • ≤ µ(m), Cx(i) → Cx(i), Super(i, j) → Super(i, j), Sub → Sub, Super(i, j) ∩ SuperC(i, j) → SuperC(i, j), Super(i, j) ∩ Super C(j, i) → SuperC(j, i), Sub(i, j) ∩ SubC(i, j) → SubC(i, j), Sub (i, j) ∩ SubC(j, i) → SubC(j, i), MM → MM for i = 1; -T FS(i) : I → I, Cx → Cx, Super → Super, Sub → Sub; -T CAF : I → I, Sub(i, j) ∩ SubC(i, j) → Sub(i, j) if m = 2, SubC(i, j) → SubC(i, j) if m = 2; -T R : I → I, SC → SC, ASC → ASC, Super(i, j) ∩ Super C(i, j) ∩ SuperC(j, i) → Super(i, j) if m = 2, Super (i, j) ∩ SuperC(i, j) → SuperC(i, j) if m = 2.</formula><p>The operator T A(i) propagates through almost all inequalities, because these inequalities also hold with x replaced by x + e i . The only exceptions are SC and ASC, because of the additional conditions on x. The results for T CA(i) are much more limited because of the minimization. Because the minimization has a certain structure (the choice between f (x) and f (x + e i )) the results are stronger than for the general minimization operator T min . For T FS(i) only limited results hold; note that DC also propagates, because of Equation (6.4). It is interesting to compare this with T CAF . Now Cx does not propagate by itself; we need the stronger condition Sub ∩ SubC, from which convexity follows. The last operator, T R , propagates through Schur convex, supermodular, and superconvex functions.</p><p>Proof. For T A(i) all the mentioned inequalities still hold when translated by e i .</p><p>T CA(i) can be written as T min (T A (i), I), with I the identity operator. Thus all results that hold for T min and for T A (i) hold for T CA(i) as well. Additionally, due to the special structure of T CA(i) , certain convexity results hold as well. We prove T CA : Cx → Cx. We need to check the different possibilities for the minimizers in x and x + 2e i , denoted by a 1 and a 2 , respectively. The only non-trivial case is</p><formula xml:id="formula_44">a 1 = a 2 . It is readily seen that 2 min{c + f (x + e i ), c + f (x + 2e i )} ≤ c + f (x + e i ) + c + f (x + 2e i )</formula><p>, which corresponds to the case that a 1 corresponds to admission and a 2 to rejection, and 2 min{c + f (x + e i ), c + f (x + 2e i )} ≤ c + f (x) + c + f (x + 3e i ) (by using convexity twice), which corresponds to the remaining case (which in fact cannot occur, as we will see later).</p><p>To prove T CA(i) : Super → Super, we need to show:</p><formula xml:id="formula_45">T CA(i) f (x + e i ) + T CA(i) f (x + e j ) ≤ T CA(i) f (x) + T CA(i) f (x + e i + e j ).</formula><p>If the optimal actions on the right-hand side are the same, for example, rejection, then the inequality follows easily by induction:</p><formula xml:id="formula_46">T CA(i) f (x + e i ) + T CA(i) f (x + e j ) ≤ c + f (x + e i ) + c + f (x + e j ) ≤ c + f (x) + c + f (x + e i + e j ) = T CA(i) f (x) + T CA(i) f (x + e i + e j ).</formula><p>When the optimal action are different then we should be more careful. If admission is optimal in x and rejection in x + e i + e j then we have:</p><formula xml:id="formula_47">T CA(i) f (x + e i ) + T CA(i) f (x + e j ) ≤ c + f (x + e i ) + c + f (x + e i + e j ) = T CA(i) f (x) + T CA(i) f (x + e i + e j ).</formula><p>If rejection is optimal in x and admission in x + e i + e j then we have, by using induction twice:</p><formula xml:id="formula_48">T CA(i) f (x + e i ) + T CA(i) f (x + e j ) ≤ c + f (x + 2e i ) + c + f (x + e j ) ≤ c + f (x) + c + f (x + 2e i + e j ) = T CA(i) f (x) + T CA(i) f (x + e i + e j ).</formula><p>For proving that Sub propagates we refer to Lemma 3.1 of <ref type="bibr" target="#b5">[6]</ref>. Now consider the first inequality of SuperC. Again, the case that the optimal action for the right-hand side are equal is simple. Assume they are different. If rejection is optimal in x + e j then it suffices to show</p><formula xml:id="formula_49">f (x + 2e i ) + f (x + e j ) ≤ f (x + e j ) + c + f (x + 3e i ).</formula><p>This holds as it is the sum of SuperC and SuperC with x replaced by x + e i . In case admission is optimal in x + e j then the actions in the left-hand side can be chosen such that an equality results. Consider the second inequality of SuperC, and the case that the optimal actions at the right-hand side are different. If rejection is optimal in x then it suffices to have Cx(j). This explains why we require Super next to SuperC. If admission is optimal in x then we can choose the actions at the left-hand side such that is the sum of both inequalities from the definition of SuperC.</p><p>For the proof of T CA(1) : MM → MM we refer to <ref type="bibr" target="#b43">[44]</ref>.</p><p>Proving T FS(i) : I(i) → I(i) means showing:</p><formula xml:id="formula_50">(B i -x i )f (x + e i ) + x i f (x) ≤ (B i -x i -1)f (x + 2e i ) +(x i + 1)f (x + e i ) for x i ≤ B i . This holds indeed for f ∈ I(i). For x i &gt; B i the inequality to show is B i f (x) ≤ B i f (x + e i )</formula><p>, which holds by induction. T FS(i) :</p><formula xml:id="formula_51">I(j) → I(j) is trivial to show. T FS(i) : Cx(i) → Cx(i) is, for x i ≤ B i , equivalent to: 2(B i -x i -1)f (x + 2e i ) + 2(x i + 1)f (x + e i ) ≤ (B i -x i )f (x + e i ) + x i f (x) + (B i -x i -2)f (x + 3e i ) + (x i + 2)f (x + 2e i ),</formula><p>which holds trivially for f ∈ Cx. For x i &gt; B i the inequality follows directly by induction. T FS(i) : Cx(j) → Cx(j) is trivial to show. The proofs for Super and Sub are similar. Consider T CAF and Sub(i, j). The only interesting cases arise when the optimizing action in the right-hand side of Sub(i, j) are different. Consider the case where T CAF f (x + e i ) + T CAF f (x + e j ) = c + f (x + 2e i + e j ) + f (x + e j ). Then</p><formula xml:id="formula_52">T CAF f (x) + T CAF f (x + e i + e j ) ≤ c + f (x + e i + e j ) + f (x + e i + e j ) ≤ f (x + 2e i + e j ) + f (x + e j ),</formula><p>the last inequality by Equation (6.3).</p><p>We continue with SubC(i, j). It is equal to:</p><formula xml:id="formula_53">f (x + e i + e j ) -f (x) ≤ f (x + 2e i + e j ) -f (x + e i ).</formula><p>We continue with Super(i, j). We have to differentiate between µ(x) ≤ µ(x + e i ) and µ(x) &gt; µ(x + e i ). The first case follows readily, for the second case we use that</p><formula xml:id="formula_54">f (x + e j ) -f (x) ≤ f (x + e i + e j ) -f (x + e i ) ≤ (x + 2e i + e j ) -f (x + 2e i ).</formula><p>The final inequality to prove is Sub(i, j). Its proof is similar to that of Super(i, j).</p><p>For T D1(i) many results are already covered by T D . The rest follows easily. For the last result concerning MM we refer to <ref type="bibr" target="#b43">[44]</ref>.</p><p>For T PD we only need to show the results for SC and ASC (the others follow from the results for other operators). For the proofs we refer to <ref type="bibr" target="#b31">[32]</ref>.</p><p>For T CD we should, as for T CA , consider the different possibilities for the minimizer at the right-hand side of the inequality.</p><p>Finally, for the proofs of I and wUI for T MS and T MMS we refer to <ref type="bibr" target="#b32">[33]</ref>. The proofs for Super and SuperC for T MS can be found in <ref type="bibr" target="#b27">[28]</ref> or <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Transfer Operators</head><p>Finally we consider the operators that model customer transfers from one queue to the other.</p><p>Theorem 7.4. The following relations hold, 1 ≤ i ≤ m:</p><formula xml:id="formula_55">-T TD1(i) : I → I, UI → UI for i &lt; m, UI ∩ MM → MM for i &lt; m, UI ∩ Cx ∩ Super → Cx for i &lt; m, UI ∩ Cx ∩ Super → Super for i &lt; m; -T CTD(i) : I → I if c(0) = min µ∈[0,1] c(µ), UI → UI for i &lt; m, MM → MM; -T TD(i) : I → I, UI → UI for i &lt; m, UI ∩ Cx ∩ Super → Cx for i &lt; m, UI ∩ Cx ∩ Super → Super for i &lt; m; -T MTS : I → I, gUI → gUI for µ as in T MTS .</formula><p>Proof. For the proofs for T TD1(i) , T CTD(i) , and T TD(i) we refer to <ref type="bibr" target="#b43">[44]</ref>. For the proofs for T MTS we refer to <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b41">42]</ref>.</p><p>Certain combinations of operators that have some form of control and inequalities give structural results about the optimal policies, seen as functions of the state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Arrival Operators</head><p>Theorem 8.1. For the minimizer a(x) in T CA(i) f (x) (action 0 is rejection, 1 is acceptance) holds:</p><formula xml:id="formula_56">-If f ∈ Cx(i) then a(x) is decreasing in x i ; -If f ∈ Super(i, j) then a(x) is decreasing in x j ; -If f ∈ Sub(i, j) then a(x) is increasing in x i ; -If f ∈ SuperC(i) then a(x) is decreasing in the direction e i -e j .</formula><p>If f ∈ Cx(i) then a policy as in Theorem 8.1 is called a threshold policy, with the threshold the level of component i at which the policy switches from 1 to 0. Note that the threshold can be different for all values of x j , j = i. If f ∈ Super(i, j) then the threshold for admitting a class-i customer is in component j. Let m &gt; 1. Let f ∈ Cx(i), and consider the thresholds in i as a function of x j . This is called a switching curve. If f ∈ Cx ∩ Super = DC then the switching curve is decreasing. If f ∈ Super ∩ SuperC, then the switching curve is even strictly decreasing (until it reaches 0).</p><p>Note that the latter result also holds for f ∈ MM, thanks to Equation (6.5). For f ∈ Sub ∩ SubC the switching curve is increasing.</p><formula xml:id="formula_57">Proof. f ∈ Cx(i) means that f (x + e i ) -f (x) is increasing in x i . As T CA(i) f (x) = f (x) + min{c, c + f (x + e i ) -f (x)},</formula><p>this means that if a(x) = 0, then a(x + e i ) = 0 as well. The other results follow in a similar way. Theorem 8.2. In case m = 2, then for the minimizer a(x) in T CAF f (x) (action 0 is rejection, 1 is acceptance) holds that it is decreasing in</p><formula xml:id="formula_58">x i if f ∈ SubC(i, j).</formula><p>The proof of Theorem 8.2 is similar to that of Theorem 8.1 If f ∈ SubC = SubC(i, j) ∩ SubC(j, i), then a(x) is decreasing in x 1 and x 2 and it follows that a decreasing switching curve exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Departure Operators</head><p>Theorem 8.3. For the minimizer µ * (x) in T CD(i) f (x) holds:</p><formula xml:id="formula_59">-If f ∈ Cx(i) then µ * (x) is increasing in x i ; -If f ∈ Super(i, j) then µ * (x) is increasing in x j ; -If f ∈ Sub(i, j) then µ * (x) is decreasing in x i ; -If f ∈ SuperC(i) then µ * (x) is increasing in the direction e i -e j .</formula><p>The proof is similar to that of Theorem 8.1. It depends on the form of c(µ) whose values of µ can be minimizer. If c is linear then only 0 and 1 need to be considered. Then, for each of the results, there is a single threshold. If c is for example piecewise linear and convex, then all discontinuities are possible minimizers, and there is a threshold for each value.</p><formula xml:id="formula_60">Theorem 8.4. If f ∈ wUI, then -T MS f (x) is minimized by min j {x j &gt; 0}, for x = 0; -T MMS f (x) is minimized by i 1 , . . . , i s such that i k -1 n=1 x n &lt; k ≤ i k n=1 x n , 1 ≤ k ≤ s, for |x| &gt; s.</formula><p>The result follows immediately from the condition wUI. In other words, it says that if f ∈ wUI, then the task (tasks) with the lowest index (indices) should be served.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Transfer Operators</head><p>Theorem 8.5. For the minimizer µ * (x) in T CTD(i) f (x) holds:</p><formula xml:id="formula_61">-If f ∈ SuperC(i, (i + 1)modm) then µ * (x) is increasing in x i ; -If f ∈ SuperC((i + 1)modm, i) then µ * (x) is decreasing in x i+1 .</formula><p>The same remarks as for Theorem 8.3 apply.</p><p>Theorem 8.6. If f ∈ gUI, then T MTS f (x) is minimized by min j {x j &gt; 0}, for x = 0.</p><p>This result follows immediately from the form of gUI. Again the job with the lowest index should be served.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Models</head><p>In this chapter we consider different sets of functions, consisting of intersections of the sets defined in Chapter 6. For each set we consider all operators that propagate through this function set. These operators together can be used to build models.</p><p>We also give references to the literature, showing which papers are covered by the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">First-Order Conditions</head><p>In this section, we consider sets of functions that are characterized by one of the properties wUI or gUI. The central operators are those that assign the server(s) to the available tasks. A characteristic result is the optimality of the µc rule.</p><p>Theorem 9.1. The following hold, for 1 ≤ i ≤ m:</p><formula xml:id="formula_62">-T A(i) , T CA(i) (with µ(1) ≤ • • • ≤ µ(m)), T MS , T disc , T env , T min (with µ(1) ≤ • • • ≤ µ(m)), T max (with µ(1) ≥ • • • ≥ µ(m)): wUI → wUI;</formula><p>Two service disciplines are of interest to us: the LAST (the policy that serves the customer(s) with the least attained service time(s)) and the MAST (the policy that serves the customer(s) with the most attained service time(s)). The following corollary is a consequence of Theorem 9.1 and the phase-type results of <ref type="bibr" target="#b37">[38]</ref>.</p><p>Corollary 9.1. The average number of customers in a G/G/1 queue is:</p><p>-minimized (maximized) by LAST in case of service times with a decreasing (increasing) hazard rate; -minimized (maximized) by MAST in case of service times an increasing (decreasing) hazard rate.</p><p>As an example, take µ(i, i -1) &gt; 0, increasing in i and arrivals in queue m. This way we model services with a decreasing hazard rate (DHR). For cost function -|x| it follows from Theorem 9.1 that it is optimal to serve the lowest numbered task available, which is the one with the most service phases yet. It follows thus that MAST minimizes -|x| and therefore maximizes |x| in the case of DHR service times.</p><p>The G/G/1 queue with LAST discipline is also called Foregroundbackground queue; see Nuyens and Wierman <ref type="bibr" target="#b61">[62]</ref> for an overview of results on this queue.</p><p>The results of Corollary 9.1 can also be found in Righter and Shanthikumar <ref type="bibr" target="#b66">[67]</ref>.</p><p>We summarize this section by giving a list of function sets and the references that deal with these sets using dynamic programming:</p><p>• wUI: <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b18">[19]</ref>; • gUI: <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b58">[59]</ref>, <ref type="bibr" target="#b83">[84]</ref>.</p><p>An interesting generalization of the models of this section (especially the ones without feedback) is to a finite source of m customers each having their own parameters. Thus x i ∈ {0, 1} denotes whether customer i is present or not. For this new operator the results for I ∩ wUI propagates if λ(1) ≤ • • • ≤ λ(m), with λ(i) the arrival rate of customer i if x i = 0. For more details see Koole and Vrijenhoek <ref type="bibr" target="#b46">[47]</ref> and Koole <ref type="bibr" target="#b41">[42]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Schur Convexity</head><p>In this section we consider sets of functions that are characterized by Schur convexity. The central operator is the routing operator T R . A characteristic result is the optimality of the join-the-shortest-queue policy, a result first obtained, using a completely different method, by Winston <ref type="bibr" target="#b84">[85]</ref>.</p><p>Theorem 9.2. The following hold, for 1 ≤ i, j ≤ m:</p><formula xml:id="formula_63">-T disc , T env , T min , T max , T R , T PD with µ(i) = µ(j): I ∩ SC → I ∩ SC; -T disc , T env , T min , T max , T R , T PD with µ(i) ≥ µ(j) if i &lt; j: I ∩ ASC → I ∩ ASC.</formula><p>The proof follows directly from the results in Chapter 7.</p><p>The first result of Theorem 9.2 shows that routing to the shortest queue is optimal in the case of symmetric servers. The second concerns asymmetric servers and shows that, while choosing between two servers, it is better to assign to the faster one if there are also less customers at that queue. No results are given in case the faster server has more waiting customers; it only partially characterizes the optimal policy. Note also that the first result is a special case of the second, by reordering the queues.</p><p>Several generalizations of these results are possible, including finite buffers and dedicated arrivals to the queues, as long as the arrival rates are equal (in the SC case) or lower for queues with lower indices (in the ASC case). Finite buffers can be included by adding high costs for every customer that exceeds the buffer constraint, of the form K m k=1 (x k -B) + , which B the size of the buffers. Note that this function is SC. Of course some form of admission control should be used to avoid that the number of customers might exceed mB. This can be modeled using T min, for example by including T min(I, T R ) in the value function. For B = 1 the result for ASC reduces to sending to the fastest available server. T R can also be extended to include finite buffers of different sizes. For more details, see Hordijk and Koole <ref type="bibr" target="#b31">[32]</ref>.</p><p>Further generalizations include multi-server queues, server rates depending on other queue lengths, etc. See Johri <ref type="bibr" target="#b34">[35]</ref>, Menich and Serfozo <ref type="bibr" target="#b54">[55]</ref>, and Koole <ref type="bibr" target="#b38">[39]</ref> for more details.</p><p>A list of function sets and papers, all using dynamic programming, is as follows:</p><p>• I ∩ SC: <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b31">32]</ref>, <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b54">[55]</ref>;</p><p>• I ∩ ASC: <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b38">[39]</ref>.</p><p>Generalizing the optimality of shortest-queue routing to nonexponential service times appeared to be quite complicated. See Koole et al. <ref type="bibr" target="#b45">[46]</ref> and references therein.</p><p>An interesting related result using SC but for a continuous state space is the one in which we consider the workload in parallel queues. We formulate the complete value function. With u n we denote the nth interarrival time, numbered backwards, and with F the distribution function of the service time. Then the DP equation for the workloads reads:</p><formula xml:id="formula_64">V n+1 (w) = min 1≤j≤m ∞ 0 V n ((w + se j -u n e) + )dF (s) .</formula><p>Similar equations as for the case with queue lengths hold for the workload case:</p><p>V n (w + se i )dF (s) ≤</p><p>V n (w + se j )dF (s) for w i ≤ w j ;</p><p>V n (w) = V n (w ) for w a permutation of w; (9.1)</p><p>V n (w) ≤ V n (w + se 1 ) for s ≥ 0.</p><p>Equation <ref type="bibr">(9.1)</ref> shows that routing to the queue with the shortest workload is optimal. This equation should not be confused with V n (w + se i ) ≤ V n (w + se j ) for some or all s. Having the integral inside the minimization means that the routing decision is made not knowing the service time of the arriving customer, which is crucial to obtain the optimality result. The proof is straightforward (and can be found in <ref type="bibr" target="#b38">[39]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Convexity in One Dimension</head><p>In this section we deal with convexity results for m = 1.</p><p>Theorem 9.3. The following hold, for m = 1:</p><p>-</p><formula xml:id="formula_65">T disc , T env , T max , T A(1) , T CA(1) , T FS(1) , T CD(1) : Cx → Cx; -T disc , T env , T max , T A(1) , T CA(1) , T FS(1) , T D(1) with µ(x) ∈ I ∩ Cv, T D1(1) , T CD(1) with c(0) = min µ∈[0,1] c(µ): I ∩ Cx → I ∩ Cx.</formula><p>This result is a direct consequence of Theorems 7.2 and 7.3. For T CA(1) and T CD(1) the optimality of threshold policies follow from Theorem 8.1.</p><p>Note the differences between the two expressions in Theorem 9.3. If we require that the value function, and therefore also the direct costs, are convex and increasing then we can allow for uncontrolled departures. One-dimensional models with convex cost functions have been studied extensively, mainly to obtain the optimality of threshold policies. The results go back to Lippman <ref type="bibr" target="#b50">[51]</ref>. See also <ref type="bibr">Stidham [73]</ref> and Ramjee et al. <ref type="bibr" target="#b65">[66]</ref>. All these results fall within the current framework.</p><p>There is no intuitive reason that convexity is necessary to obtain the optimality of threshold policies, but for the current line of proof convexity is necessary. In Stidham and Weber <ref type="bibr" target="#b75">[76]</ref> another method is used to obtain threshold optimality, requiring only increasing direct costs.</p><p>Our results obtained so far are only valid if the direct costs C ∈ Cx or C ∈ I ∩ Cx. Often used cost functions are x and (xs) + , the latter in the case that T D models an s-server system. These functions are both increasing and convex. Through Little's law that is equivalent to minimizing the average system or waiting time.</p><p>An example of a non-increasing cost function is C(x) = -I{x 1 &gt; 0}r + cx, where r the reward rate for service to customers and c is the holding cost rate. This is the second model of Lippman <ref type="bibr" target="#b50">[51]</ref>.</p><p>An important question is whether the value function is also convex when the service rates in the operator T D are not concave. This is relevant to call centers, where waiting customers abandon, usually at a higher rate than the service rate. This leads to a service rate of µ(x) = min{s, x}µ + (xs) + γ, with γ the abandonment rate. This function is concave iff µ ≥ γ. When γ &gt; µ then it is possible to construct numerical counterexamples for the convexity using a value function of the form T costs T unif (T A(1) , T D(1) ).</p><p>We give a list of function sets and papers in which the models of this section are used. Note that when costs are replaced by rewards then Cx becomes Cv:</p><p>• Cx: <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b50">[51]</ref>;</p><formula xml:id="formula_66">• I ∩ Cx: [40], [73, Sec. 1], [74, Sec. III.B].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">Convexity in Multiple Dimensions</head><p>In this section we deal with convexity results that hold for arbitrary m. Theorem 9.4. The following relations hold, for 1 ≤ i ≤ m:</p><formula xml:id="formula_67">-T disc , T env , T A(i) , T CA(i) , T CD(m) , T CTD(i) : MM → MM; -T disc , T env , T A(i) , T CA(i) , T D1(m) , T CD(m) with c(0) = min µ∈[0,1] c(µ), T TD1(i) for i &lt; m: I ∩ UI ∩ MM → I ∩ UI ∩ MM; -T disc , T env , T A(i) , T D(m) with µ(x) ∈ I ∩ Cv, T TD1(i) for i &lt; m, T TD(i) for i &lt; m: I ∩ UI ∩ Cx ∩ Super → I ∩ UI ∩ Cx ∩ Super; -T disc , T env , T A(i) , T CA(i) , T FS(i) , T D(i) , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ): Sub → Sub.</formula><p>Observe that T TD1(i) and T D1(m) are special cases of T TD(i) and T D(m) . Thus controlled operators are possible on the strong condition (see Equation (6.5)) that the costs are multimodular. If we add UI then also uncontrolled single-server queues can be added to the model. Uncontrolled multi-server queues can be studied using the weaker property of directional convexity (which is equal to Cx ∩ Super) combined with UI. Note that we have no results for T min and T max .</p><p>The results for MM can be found in Weber and Stidham <ref type="bibr" target="#b82">[83]</ref>. The results involving UI can be found in Koole <ref type="bibr" target="#b43">[44]</ref>.</p><p>The models propagating Sub at first sight do not seem particularly interesting: all allowable operators only depend on a single dimension, and therefore there seems to be no correlation between the queues, other then through the control. However, by interpreting the state as counting events rather than being the underlying state this model can lead to interesting results for relevant models, using only T CA(i) . The underlying state is a function of the event counts, the scores.</p><p>As an example, consider a model with arrivals in k queues at the same time and k single-server queues. The objective is to minimize the maximum queue length, arrivals and departures are controlled. We take m = k + 1, dimension i counts departures from queue i, 1 ≤ i ≤ k, and dimension k + 1 counts the arrivals. The underlying state is (x k+1x 1 , . . . , x k+1x k ). We take as direct costs x k+1min 1≤i≤k x i plus a component to avoid negative queue lengths, k i=1 (x ix k+1 ) + K, with K 0. Note that both are in Sub. This result shows that the optimal action of any of the events is increasing in any other event (and that an event is decreasing in its own event).</p><p>Another example is a system with controlled arrivals to k queues and a controlled departure operator that takes an item from each of the queues. Now the underlying state is (x 1x k+1 , . . . , x kx k+1 ). To avoid negative state components we now take cost component k i=1 (x k+1x i ) + K, which is again Sub. This model has been studied in Benjaafar and ElHafsi <ref type="bibr" target="#b13">[14]</ref> (they work in the underlying state space). The interpretation is that each queue contains inventory of parts of a certain type, and satisfying demand requires an item of each type.</p><p>The score state approach was introduced in Glasserman and Yao <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27]</ref>, see also Altman and Koole <ref type="bibr" target="#b5">[6]</ref>.</p><p>Weber and Stidham <ref type="bibr" target="#b82">[83]</ref> and Veatch and Wein <ref type="bibr" target="#b80">[81]</ref> work in the state space, but they consider submodularity in the transitions (called transition-monotonicity). For the controlled tandem model of <ref type="bibr" target="#b82">[83]</ref>, Sub in the direction of the transitions is equivalent to MM in the state space. A three-dimensional model that combines aspects of a tandem system and arrivals in multiple queues is Miyoshi et al. <ref type="bibr" target="#b55">[56]</ref>.</p><p>Although elegant, proving transition-monotonicity (with or without working in the score space) strongly limits the number of models that can be dealt with. The results can always obtained by working directly with the states; the reverse is not true. But the conditions in the state space can be quite complicated. In conclusion: when transition-monotonicity holds for a particular model then it is an elegant way to derive monotonicity results. In other cases one should work directly in the state space.</p><p>We conclude the section with a list of function sets and papers in which they are used:</p><p>• MM: <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b82">[83]</ref>;</p><p>• I ∩ UI ∩ MM: <ref type="bibr" target="#b43">[44]</ref>;</p><p>• I ∩ UI ∩ DC: <ref type="bibr" target="#b43">[44]</ref> (in which DC is called vector convexity); • Sub (in the transitions/scores): <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27]</ref>, <ref type="bibr" target="#b55">[56]</ref>, <ref type="bibr" target="#b80">[81]</ref>, <ref type="bibr" target="#b82">[83]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5">Convexity in Two Dimensions</head><p>The results of Section 9.4 hold also for m = 2. However, additional results can be obtained for two dimensions. Remember that MM = Super ∩ SuperC for m = 2, and that DC = Cx ∩ Super. We focus on results that include I. The main consequences of not having I is that uncontrolled departures or transfers are not allowed, but direct costs need not necessarily be increasing. In <ref type="bibr" target="#b39">[40]</ref>, both function sets with and without I are studied. We neither consider UI.</p><p>Theorem 9.5. The following relations hold, for 1 ≤ i ≤ 2:</p><p>-</p><formula xml:id="formula_68">T disc , T env , T A(i) , T CA(i) , T FS(i) , T D(i) , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ): I ∩ Super → I ∩ Super; -T disc , T env , T A(i) , T CA(i) , T FS(i) , T D(i) , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ): I ∩ Cx ∩ Super → I ∩ Cx ∩ Super; -T disc , T env , T A(i) , T CA(i) , T R , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ), T CTD(i) with c(0) = min µ∈[0,1] c(µ): I ∩ Super ∩ SuperC → I ∩ Super ∩ SuperC; -T disc , T env , T A(i) , T CA(i) , T FS(i) , T CAF , T D(i) , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ): I ∩ Sub → I ∩ Sub; -T disc , T env , T A(i) , T CA(i) , T FS(i) , T D(i) , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ): I ∩ Cx ∩ Sub → I ∩ Cx ∩ Sub; -T disc , T env , T A(i) , T CA(i) , T CAF , T D1(i) , T CD(i) with c(0) = min µ∈[0,1] c(µ): I ∩ Sub ∩ SubC → I ∩ Sub ∩ SubC.</formula><p>The most interesting set of models is the one with function set I ∩ Super ∩ SuperC. The models include the routing model of Hajek <ref type="bibr" target="#b27">[28]</ref> (essentially consisting of T R and T D1(i) ) and the server assignment model of Lin and Kumar <ref type="bibr" target="#b49">[50]</ref> (consisting of T A(1) , T CTD(1) and T D1(i) for i = 1, 2).</p><p>Many researchers have attempted to generalize <ref type="bibr" target="#b27">[28]</ref> and <ref type="bibr" target="#b49">[50]</ref> to more than two servers in total, either by taking more than two singleserver queues or by taking multi-server queues. In de Véricourt and Zhou <ref type="bibr" target="#b21">[22]</ref> the errors in the papers who claimed to do this are shown. That an approach using some of our inequalities does not work can be seen as follows. We start the work of Hajek <ref type="bibr" target="#b27">[28]</ref>, in which characterizing operators are T R and T D1(i) . According to Theorem 7.2 we need Super ∩ SuperC and m = 2 to obtain convexity results for T R . However, as can be seen in Theorem 7.3, we were not able to propagate T D(i) for SuperC. This explains why we cannot combine T R and T D(i) in our model. The situation for Lin and Kumar <ref type="bibr" target="#b49">[50]</ref> is similar but a little more complicated. Because T D1(1) is one of the operators, we cannot use UI. Thus taking I ∩ UI ∩ DC as in Theorem 9.4 is not an option, thus we have to rely on one of the cases of Theorem 9.5. However, neither of these allow for T CTD(1) and T D(i) at the same time.</p><p>A third paper using I ∩ Super ∩ SuperC is Weber and Stidham <ref type="bibr" target="#b82">[83]</ref>. They consider a cycle of queues described by T A(1) , T A(2) , T CTD(1) , and T CTD <ref type="bibr" target="#b0">(1)</ref> . They also consider a tandem system, replacing T CTD(2) by T D1 <ref type="bibr" target="#b1">(2)</ref> .</p><p>For models with multi-server queues we have only a limited number of operators to choose from. The trunk reservation model of Altman et al. <ref type="bibr" target="#b1">[2]</ref> and Örmeci et al. <ref type="bibr" target="#b63">[64]</ref> contains only T CA(i) and T D(i) with direct costs (b 1 x 1 + b 2 x 2 -B) + K to model a buffer that limits the overall number of jobs. According to Theorem 9.5 I ∩ Cx ∩ Super is the appropriate model (extending the results of <ref type="bibr" target="#b1">[2]</ref>), showing the existence of decreasing switching curves for each type of calls (which was already obtained in Ross and Tsang <ref type="bibr" target="#b67">[68]</ref>, using a different method, and for a restricted set of policies). Ni et al. <ref type="bibr" target="#b60">[61]</ref> addresses the interesting problem of determining efficiently the switching curves.</p><p>Next is a list with function sets discussed in this section and papers in which they are used:</p><p>• I ∩ Cx ∩ Super: <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b62">[63]</ref>, <ref type="bibr" target="#b63">[64]</ref>;</p><p>• I(1) ∩ SuperC(1, 2): <ref type="bibr" target="#b48">[49]</ref>;</p><p>• Super ∩ SuperC: <ref type="bibr" target="#b71">[72]</ref> (on Z Z 2 ), <ref type="bibr" target="#b16">[17]</ref>;</p><p>• I ∩ Super ∩ SuperC: [1, Sec. 10.6.2], <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b49">[50]</ref>, <ref type="bibr" target="#b82">[83]</ref>.</p><p>Suk and Cassandras <ref type="bibr" target="#b77">[78]</ref> study a two-dimensional model with T A(i) and T MS and finite buffers. This is equivalent to T CA(i) and T MS and non-linear costs C. As C ∈ wUI Theorem 9.1 cannot be used. <ref type="bibr" target="#b77">[78,</ref><ref type="bibr">Lemma 2]</ref> propagates a functional property that is equal to SuperC if µ(1) = µ(2) (actually, Super is needed as well, but this is not mentioned in the paper).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Other State Spaces</head><p>In this overview we focused on the state space IN m 0 , although we could introduce finite buffers in certain models by adding functions of the form i (x i -B i ) + K or ( i x i -B) + K to the direct costs. Then any controlled operator in which costs are minimized will avoid going to states with x i &gt; B i or i x i &gt; B as long as K is big enough.</p><p>In this chapter we discuss briefly models with other state spaces.</p><p>Our first model has state space {0, 1} m . We use operator T PD and a new controlled routing operator of the form min{b + f (x), min j:x j =0 {f (x + e j }}. Thus it is possible to reject arrivals, at cost b; otherwise we have to assign the arrival to one of the empty queues. If we assume that µ(1) ≥ • • • ≥ µ(m) then I ∩ ASC ∩ Super propagates, now defined on the new state space {0, 1} m . From ASC it follows that if assignment is optimal then the customer should be assigned to the fastest available server. Super shows that assignment is less likely to be optimal if more servers are occupied; this is relevant if there are multiple arrival operators having different rejection costs. This result was first derived in <ref type="bibr" target="#b38">[39]</ref>, and is a generalization of results in Derman et al. <ref type="bibr" target="#b22">[23]</ref>.</p><p>Another interesting model with state space {0, 1} m and function set I ∩ wUI has been discussed at the end of Section 9.1.</p><p>In some situations it is also useful to have negative queue lengths, for example in situations where the components model inventory of parts and where backorders are possible. When x i &gt; 0, item i is on stock; x i &lt; 0 denotes the number of backorders. In the papers dealing with these models threshold policies are often called hedging policies, terminology introduced in Kimemia and Gershwin <ref type="bibr" target="#b35">[36]</ref>, in the context of a flexible manufacturing system with unreliable machines. An example of a paper containing a monotonicity result is Song and Sun <ref type="bibr" target="#b71">[72]</ref>, in which Super ∩ SuperC is propagated on Z Z 2 and direct convex costs taking its minimum at 0. Other examples are Benjaafar and ElHafsi [14, Section 3.3] (see Section 9.4) and Benjaafar et al. <ref type="bibr" target="#b12">[13]</ref>.</p><p>An interesting extension of Markov decision processes is to models where the state is not observed. In this situation actions cannot be based on the actual state, but on the information that is available on the state, the so-called information state. In general these are distributions on the underlying states. However, special cases exist for which the information states have some nice structure. Several monotonicity results for these models have been obtained in the literature. We mention some of these papers, without going into details.</p><p>One example is Kuri and Kumar <ref type="bibr" target="#b47">[48]</ref> which considers the symmetric routing model of Section 9.2, which was characterized by SC, but with a delay in the queue length information. They show that for a delay of 1 routing to the shortest queue is still optimal; for delay 2 or longer counterexamples exist. Both Altman and Nain <ref type="bibr" target="#b6">[7]</ref> and Altman and Koole <ref type="bibr" target="#b4">[5]</ref> consider a queue with some form of admission control and delayed information. Beutler and Teneketzis <ref type="bibr" target="#b14">[15]</ref> generalize some models characterized by I ∩ Super ∩ SuperC to partial information. Artiges <ref type="bibr" target="#b9">[10]</ref> extends the routing model of Hajek <ref type="bibr" target="#b27">[28]</ref> to a delay of 1. A general framework for partially ordered state spaces and two actions is given in Altman and Stidham <ref type="bibr" target="#b7">[8]</ref>.</p><p>Koole <ref type="bibr" target="#b40">[41]</ref> considers a piece of equipment (e.g., a fire detector) which has an exponentially distributed lifetime. As long as we do not check its condition our knowledge about it is summarized by the probability it is up (or, equivalently, its lifetime). This probability is the state of the process, thus X = [0, 1]. An action might be to check whether it is functioning and replace it when necessary. After the check, the state is 1. It is shown in <ref type="bibr" target="#b40">[41]</ref> that below a certain threshold probability we replace the piece of equipment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparing Systems</head><p>Structural properties of value functions can be used to compare different systems. In this section we focus on systems that differ in one or more operators, but for which the form of the value function is the same. Typical examples are comparing systems with batch arrivals versus arrivals one at a time, and comparing systems which differ in one or more parameters (such as the arrival or departure rate). We will see that for comparing systems or to prove montonicity in a parameter we often need convexity in the state.</p><p>We will focus on systems in which only dimension 1 is treated differently. For this reason we omit the subscript "(1)" from most of the notation. e.g., we write T A instead of T A(1) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.1">Comparing Different Arrival Processes</head><p>Next to the value function V n , defined by the operators T i , we now have a second value function V n that differs from V n only in the fact that T i is replaced everywhere by T i , for all i. We would like to show V n (x) ≤ V n (x) for all x and n, for well-chosen T i and T i . To do this it suffices to prove, for functions f and f , that T i f ≤ T i (f ) follows from f ≤ f . To show this, we usually need an extra condition of the form f or f ∈ F, with F typically Cx or I ∩ Cx.</p><p>The prime application of this idea is to compare the regular arrival operator T A f (x) = f (x + e 1 ) with a batch arrival operator</p><formula xml:id="formula_69">T A f (x) = ∞ k=0 p k f (x + ke 1 ), with ∞ k=0 p k = 1. Define p = ∞ k=0 kp k .</formula><p>The basis of the comparison results is the following lemma. Note that all comparisons of vectors and functions are componentwise.</p><p>Lemma 11.1. For functions f and f it holds that:</p><formula xml:id="formula_70">-f ≤ f ⇒ T f ≤ T f for T ∈ {T env , T max , T min , T A , T FS , T CA , T disc , T D , T CD }; -f ≤ f , f ∈ Cx, p = 1 ⇒ T A f ≤ T A f .</formula><p>Proof. The first statement is trivial. The second follows from Jensen's inequality and the first statement:</p><formula xml:id="formula_71">T A f (x) ≤ T A f (x) ≤ T A f (x).</formula><p>In case p &gt; 1, then the proof continues under the additional condition that f or f ∈ I.</p><p>A simple direct consequence of the first statement of Lemma 11.1 is in comparison with time, i.e., in the subscript n of V n . Lemma 11.2. Let V n be a value function defined using operators for which Lemma 11.1 holds. Then</p><formula xml:id="formula_72">V 0 ≤ V 1 ⇒ V n ≤ V n+1 .</formula><p>Often we take V 0 = 0. Then V 0 ≤ V 1 is equivalent to requiring nonnegative direct costs.</p><p>An important implication of Lemma 11.1 is that it allows us to compare queueing models with their fluid limits. Indeed, if we interpret x as a measure of the load in the system, and a batch as the workload of an arrival in the original queueing system, then the results compare approximations of the fluid limit and the original queue. For more details, see Altman et al. <ref type="bibr" target="#b2">[3]</ref>.</p><p>The intuition behind Lemma 11.1 is that systems behave "better" when the arrival streams are less peaked. Another situation where this occurs is when there are multiple peaked streams (i.e., on-off processes): the superposition of processes smoothes out the peaks. To study this, consider two value functions that differ in one operator that models two uniformized on-off processes (there are possibly other operators modeling other on-off processes). Abusing notation a little, we assume that the environment variable takes values in {0, 1} 2 (of course, this can simply be mapped into a one-dimensional variable), representing the states of both on-off processes. These is one operator T 0/1T representing the transitions of the two on-off processes, possibly resulting from uniformization. For simplicity we assume both on-off processes have the same parameters: with probability γ 1 (γ 0 ) each process goes to (stays in) state 1 (0), and thus 2(γ 0 + γ 1 ) = 1:</p><formula xml:id="formula_73">T 0/1T f ((a, b), i) = γ 0 f ((0, b), i) + γ 0 f ((a, 0), i) + γ 1 f ((1, b), i) + γ 1 f ((a, 1), i).</formula><p>Define another operator T 0/1A modeling the arrivals generated by the on-off processes: λ k is the probability that an arrival is generated by on-off process k, if it is in state 1. With λ 1 + λ 2 = 1 this leads to</p><formula xml:id="formula_74">T 0/1A f ((a, b), i) = λ 1 f ((a, b), i + II{a = 1}) + λ 2 f ((a, b), i + II{b = 1}). We assume that λ 1 ≤ λ 2 .</formula><p>Consider also a second operator V n , which differs from V n only in the arrival probabilities λ i :</p><formula xml:id="formula_75">λ 1 &lt; λ 1 . Because also λ 1 + λ 2 = 1, λ 2 &gt; λ 2 .</formula><p>Intuitively speaking, the V n process is more balanced than the V n process, because the arrival probabilities are closer.</p><p>Let π(0) (π(1)) be the stationary probability that any of the onoff processes is in state 0 (1). We define the ordering ≺ 0/1 as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.2">Monotonicity in Parameters</head><p>Increasingness in a parameter value is often easy to show. Take an M/M/1 queue as example. That the average costs are increasing in the arrival rate can simply be shown by induction, under the condition that the direct costs are increasing. Showing convexity is more challenging.</p><p>In what follows we define the different operators that we consider and we prove first the increasingness of the value function. This will be an excellent preparation of the main objective of this paragraph: proving convexity of the value function in the parameter value(s).</p><p>We will compare systems with different arrival rates and different number of servers. We extend T A and T D as follows as to make this possible. Let S be the upper bound of the number of servers. Definition 11.1. We define:</p><formula xml:id="formula_76">-T A(λ) = λf (x + e 1 ) + (1 -λ)f (x) for 0 ≤ λ ≤ 1; -T D(µ) = µf ((x -e 1 ) + ) + (1 -µ)f (x) for 0 ≤ µ ≤ 1; -T D(s) = [min{x 1 , s}f (x -e 1 ) + (S -min{x 1 , s})f (x)]/S.</formula><p>The equivalent of Lemma 11.1 for the operators just defined is as follows.</p><p>Lemma 11.4. For functions f and f it holds that:</p><formula xml:id="formula_77">-f ≤ f , f or f ∈ I ⇒ T A(λ) f ≤ T A(λ+δ) f ; -f ≤ f , f or f ∈ I ⇒ T D(µ+δ) f ≤ T D(µ) f ; -f ≤ f , f or f ∈ I ⇒ T D(s+1) f ≤ T D(s) f .</formula><p>Proof. Using f ≤ f and then f ∈ I we find:</p><formula xml:id="formula_78">T A(λ) f (x) = λf (x + e 1 ) + (1 -λ)f (x) ≤ λf (x + e 1 ) + (1 -λ)f (x) ≤ (λ + δ)f (x + e 1 ) + (1 -λ -δ)f (x) = T A(λ+δ) f (x).</formula><p>By starting with λf (x + e 1 ) + (1λ)f (x) ≤ (λ + δ)f (x + e 1 ) + (1λδ)f (x) and then using f ≤ f we need f ∈ I instead of f ∈ I. The other two statement are hardly more complicated to prove.</p><p>Next we move to convexity. We cannot prove it directly, we need another condition. For this, we introduce the following notation:</p><formula xml:id="formula_79">∆ 1 f (x) = f (x + e 1 ) -f (x).</formula><p>In what follows we will regularly use conditions of the form ∆ 1 f ≤ ∆ 1 f which are to be considered componentwise. Thus ∆</p><formula xml:id="formula_80">1 f ≤ ∆ 1 f is equivalent to f (x) + f (x + e 1 ) ≤ f (x) + f (x + e 1 )</formula><p>for all x. Note the equivalence with supermodularity as it is introduced in Section 6.3: when we take f (x) = f (x + e 2 ) then both definitions are equivalent.</p><p>The following lemma is crucial in proving convexity.</p><p>Lemma 11.5. For functions f and f it holds that:</p><p>-</p><formula xml:id="formula_81">∆ 1 f ≤ ∆ 1 f ⇒ ∆ 1 T f ≤ ∆ 1 T f for T ∈ {T disc , T env , T A , T FS , T D }; -∆ 1 f ≤ ∆ 1 f , f or f ∈ Cx ⇒ ∆ 1 T A(λ) f ≤ ∆ 1 T A(λ+δ) f ; -∆ 1 f ≤ ∆ 1 f , f or f ∈ Cx, f ∈ I ⇒ ∆ 1 T D(µ+δ) f ≤ ∆ 1 T D(µ) f ; -∆ 1 f ≤ ∆ 1 f , f or f ∈ Cx, f ∈ I ⇒ ∆ 1 T D(s+1) f ≤ ∆ 1 T D(s) f .</formula><p>Proof. The first statement follows directly because the operators in {T disc , T env , T A , T FS , T D } all have the same transitions, independent of the values of the function to which they are applied (which is for example not the case with T max : the actual transition depends on the values in the states that are reachable).</p><p>The second statement, written out, is equivalent to a convex combination of ∆</p><formula xml:id="formula_82">1 f (x) ≤ ∆ 1 f (x), ∆ 1 f (x + e 1 ) ≤ ∆ 1 f (x + e 1 ) and f (x + e 1 ) + f (x + e 1 ) ≤ f (x) + f (x + 2e 1 ), (11.1)</formula><p>which is the sum of the following two inequalities:</p><formula xml:id="formula_83">2f (x + e 1 ) ≤ f (x) + f (x + 2e 1 )</formula><p>11.2 Monotonicity in Parameters 67 and</p><formula xml:id="formula_84">f (x) + f (x + e 1 ) ≤ f (x) + f (x + e 1 ),</formula><p>which are exactly the conditions. Instead of the convexity of f the convexity of f can be used together with f (x + e 1 ) + f (x + 2e 1 ) ≤ f (x + e 1 ) + f (x + 2e 1 ).</p><p>Proving the third statement is a little bit more involved. We make a distinction between x 1 = 0 and x 1 &gt; 0. When</p><formula xml:id="formula_85">x 1 = 0, ∆ 1 T D(µ+δ) f (x) ≤ ∆ 1 T D(µ) f (x) reduces to (1 -µ -δ)f (x + e 1 ) + (1 -µ)f (x) ≤ (1 -µ -δ)f (x) + (1 -µ)f (x + e 1 ), which is the sum of (1 -µ -δ)f (x + e 1 ) + (1 -µ -δ)f (x) ≤ (1 -µ -δ)f (x) + (1 -µ -δ)f (x + e 1 )</formula><p>and δf (x) ≤ δf (x + e 1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The first is equivalent to ∆</head><formula xml:id="formula_86">1 T D(µ+δ) f (x) ≤ ∆ 1 T D(µ) f (x), the second is f ∈ I. Now consider x 1 &gt; 0. Writing out the inequality leads to a convex combination of ∆ 1 f (x) ≤ ∆ 1 f (x), ∆ 1 f (x -e 1 ) ≤ ∆ 1 f (x -e 1 )<label>and</label></formula><formula xml:id="formula_87">f (x) + f (x) ≤ f (x + e 1 ) + f (x -e 1 ).</formula><p>The last inequality follows in the same way as <ref type="bibr">(11.1)</ref>.</p><p>Proving the fourth statement is again more involved. Consider first the case 0 &lt; x 1 &lt; s (the case</p><formula xml:id="formula_88">x 1 = 0 is trivial). Then ∆ 1 T D(s+1) f (x) ≤ ∆ 1 T D(s) f (x) is equivalent to a convex combination of ∆ 1 f (x) ≤ ∆ 1 f (x) and f (x -e 1 ) + f (x) ≤ f (x -e 1 ) + f (x).</formula><p>(11.</p><p>2)</p><p>The latter inequalities hold by induction. Now consider x 1 = s. Then we have a combination of ∆ 1 f (x) ≤ ∆ 1 f (x), (11.2), and f (xe 1 ) ≤ f (x), which is where we need f ∈ I. Finally, consider x 1 &gt; s. Then we get a combination of ∆ 1 f (x) ≤ ∆ 1 f (x), (11.2), and</p><formula xml:id="formula_89">f (x) + f (x) ≤ f (x -e 1 ) + f (x + e 1 ).</formula><p>The proof of the latter inequality is equivalent to that of (11.1). Now we are in a position to prove convexity in the arrival rate and the number of servers. Lemma 11.6. For functions f , f , and f it holds that:</p><formula xml:id="formula_90">-2f ≤ f + f ⇒ 2T f ≤ T f + T f for T ∈ {T env , T max , T A , T FS , T disc , T D }; -2f ≤ f +f , f, f , f ∈ Cx, ∆ 1 f ≤ ∆ 1 f ≤ ∆ 1 f ⇒ 2T A(λ+δ) f ≤ T A(λ) f + T A(λ+2δ) f ; -2f ≤ f + f , f, f , f ∈ Cx, ∆ 1 f ≤ ∆ 1 f ≤ ∆ 1 f , f, f ∈ I ⇒ 2T D(µ+δ) f ≤ T D(µ) f + T D(µ+2δ) f ; -2f ≤ f + f , f,f , f ∈ Cx, ∆ 1 f ≤ ∆ 1 f ≤ ∆ 1 f , f,f ∈ I ⇒ 2T D(s+1) f ≤ T D(s) f + T D(s+2) f .</formula><p>Proof. The proof of the first statement, for all but T max , follows from the fact that 2f ≤ f + f is preserved under linear combinations. It is readily seen that also maximization is preserved. This does not hold for minimization, the reason why T min , T CD , and T CA are excluded.</p><formula xml:id="formula_91">Using 2f ≤ f + f it follows that 2T A(λ+δ) f ≤ T A(λ+δ) f + T A(λ+δ) f . Thus it suffices to show T A(λ+δ) f + T A(λ+δ) f ≤ T A(λ) f + T A(λ+2δ) f .</formula><p>Writing out this inequality shows that it is equivalent to ∆ 1 f ≤ ∆ 1 f , the second statement.</p><p>For the third statement we have to show</p><formula xml:id="formula_92">T D(µ+δ) f + T D(µ+δ) f ≤ T D(µ+2δ) f + T D(µ) f . (<label>11.3)</label></formula><p>When x 1 = 0, then <ref type="bibr">(11.</ref>3) reduces to an equality. When x 1 &gt; 0, then it gives out which follows from ∆ 1 f ≤ ∆ 1 f . To prove the last statement, we have to show that Of course the initial condition V 0 = 0 can be weakened. How can Theorem 11.7 be used? As an example, suppose we have a number of service centers, each of which can be modeled as an M/M/s queue. The question is how to allocate the total pool of servers to the service centers as to minimize the total expected number of customers in the system. Note that this, thanks to Little's law, is equivalent to the expected time customers spend in the system. C(x) = x is a linear increasing cost function, and thus we can apply Theorem 11.7. First we should assign as many servers to each queue as to make it stable, otherwise the objective is ∞. The remaining servers are assigned one by one in a greedy way, where the objective is minimized the most. Thanks to the convexity the return of adding servers to a queue is deminishing. Therefore the greedy assignment algorithm leads to a globally optimal assignment.</p><formula xml:id="formula_93">f (x) + f (x -e 1 ) ≤ f (x -e 1 ) + f (x),</formula><formula xml:id="formula_94">T D(s+1) f + T D(s+1) f ≤ T D(s+2) f + T D(s) f . (<label>11</label></formula><p>An interesting variant to this problem is considering expected waiting times instead of sojourn or system times. Now the direct costs become C(x) = (xs) + , depending on s. Denote this dependence by C s (x). Thus for this choice Lemmas 11.5 and 11.6 should be extended to different operators T disc . It is readily seen that we need ∆ 1 C s+1 ≤ ∆ 1 C s and 2C s+1 ≤ C s + C s+2 to make these lemmas work. Both inequalities hold, and therefore the average waiting times are also convex in the parameters.</p><p>In many applications, especially in call centers, it is of interest to look at functions of the waiting time distribution different from just looking at the expectation. The simplest and best known example is the probability that the waiting time exceeds a number t. Consider the case t = 0. Then the direct costs are as follows: C(x) = II{x ≥ s}. This function is clearly not convex in x, thus our methods cannot be applied to this system. The question that remains is whether some structural result holds for the stationary M/M/s queue as a function of s. Using analytical techniques Jagers and van Doorn <ref type="bibr" target="#b33">[34]</ref> have shown that for the stable stationary M/M/s queue IP(W q ≤ t) is increasing concave in s.</p><p>An interesting question is whether there is a functional of the waiting time which is convex in x and more sensitive than the expected waiting time. In Koole <ref type="bibr" target="#b42">[43]</ref> such a cost function is proposed: IE(W qt) + . Using a coupling argument it can indeed be seen that this cost function is convex in x.</p><p>Another interesting question is whether the results on T D(s) can be extended to abandonments. This can indeed be done, as long as the abandonment rate is lower than the service rate.</p><p>Finally, we pose ourselves the question whether some results hold for operators that are excluded from the comparison. For example: is the stationary queue length in the M/M/1 queue with admission control convex in the arrival rate? The answer to this intriguing question is no, see Varga <ref type="bibr" target="#b79">[80]</ref> for a counterexample. The intuition behind the counterexample is as follows. The threshold is decreasing in λ (the arrival rate). For every fixed threshold level the value function is convex. The minimum of these functions is the value function of the queue with admission control. The minimum of a number of convex functions need not be convex, and numerically it was shown in <ref type="bibr" target="#b79">[80]</ref> that this is indeed not the case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.3">More-Dimensional Models</head><p>Up to now we dealt elaborately with the comparison of different systems for one-dimensional systems. These results were mainly based on the convexity of the value function in a certain parameter. These results can be cast in a multi-dimensional setting for those cases where the convexity holds, i.e., where we have MM or DC, or Sub and SubC in the case of two-dimensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.4">Bibliographical Notes</head><p>Many monotonicity results for one-dimensional queueing systems can be found in Liyanage and Shanthikumar <ref type="bibr" target="#b52">[53]</ref>. See Armony et al. <ref type="bibr" target="#b8">[9]</ref> for recent results on M/M/s queues with impatient customers. For the Erlang blocking model with multiple customer classes we refer to Nain <ref type="bibr" target="#b59">[60]</ref> and Ross and Yao <ref type="bibr" target="#b68">[69]</ref>. These papers use stochastic orders, combined with sample path arguments.</p><p>Independently, C ¸il et al. <ref type="bibr" target="#b20">[21]</ref> have developed a similar framework as the one described in this section to study convexity of the value function in several parameters of one-dimensional systems, notably the arrival rate, the service rate, and the buffer size. Fu et al. <ref type="bibr" target="#b23">[24]</ref> already showed the submodularity of the queue length of the M/G/s queue in the state and the number of servers, using dynamic programming. They apply this to a transient staffing problem. This chapter describes and categorizes the state of the art of dynamic programming monotonicity results for multi-dimensional discrete-event systems. It also makes the analysis of new models much simpler. Results for already analyzed operators can be used, and for each function class of Chapter 9 it can be seen if the model fits in. In the remainder of this final chapter, we discuss the limitations of the methods, alternative methods, and possible future research directions.</p><p>The best known alternative to DP is stochastic coupling. The central idea is that trajectories of the process, using different initial states and/or policies, are compared. An elegant proof using this method of the optimality or routing to the shortest queue, the symmetric routing model of Section 9.2, can be found in Walrand <ref type="bibr" target="#b81">[82]</ref>. Trajectories under two different policies are coupled such that arrivals occur at the same time, as do departures from the longer queues and departures from the shorter queues. Using forward induction in time it can be shown that the trajactory under shortest-queue routing has at all times less customers in the system and a shorter longest queue (i.e., is smaller in the Schur convex sense).</p><p>Coupling has several advantages and disadvantages. An advantage is that it is easier to deal with general service times. On the other hand, convexity results are harder to derive and are different to come with a formal framework; interchange arguments remain partly intuitive and are therefore hard to check. For an overview of the method and an attempt to formalize it, see Liu et al. <ref type="bibr" target="#b51">[52]</ref>.</p><p>A few other methods are used as well. Stidham and Weber <ref type="bibr" target="#b75">[76]</ref> use an intriguing argument to determine the average-cost optimal policy in a single queue with not necessarily convex costs. Their method involves the total costs until state 0 is reached. Blanc et al. <ref type="bibr" target="#b15">[16]</ref> have a twodimensional model with a concave cost function. Their method involves the partial construction of the solution of the dynamic programming equation.</p><p>Evidently there are many models that fall outside the techniques discussed so far, and even if a model falls within, then the optimal policy is often very complicated and only partially specified (for example, an increasing switching curve). For this reason many authors have studied optimal policies for some related simpler model, such as a fluid limit. Often this leads to gross oversimplications. The study by Chen et al. <ref type="bibr" target="#b19">[20]</ref> is an example where this is not the case.</p><p>A major disadvantage of DP is the fact that the results we prove for V n have to hold for all n. It is by taking limits that we obtain results for long-run average and thus also stationary situations. Thus any result that holds only in the stationary situation cannot be obtained directly by DP. A possible solution is to consider IEV n (X) for X stationary (for 1 or more components) instead of V n (x) for every x. That is the method that is used successfully in Section 11.1 to analyze systems with different on-off arrival processes. It is to be seen whether this method is useful for a wider class of problems. Problems that can potentially be solved by an extension of this method are Klimov's problem (an extension of the single-server general-routing model of Section 9.1, see <ref type="bibr" target="#b36">[37]</ref>) and bandit problems.</p><p>An open problem that is central to the method is the extension of the results in <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b49">50]</ref> to more than two servers. It is explained in Section 9.5 why this cannot be done directly. However, it is generally believed that the convexity and threshold results should still hold for more than two servers. A valid proof of this would be a major breakthrough.</p><p>Current reserach attention has shifted partially from obtaining theoretical monotonicity results to applications such as the comparison of systems, see C ¸il et al. <ref type="bibr" target="#b20">[21]</ref>. Further comparison results can certainly be obtained. Also the relation between the partial characterization of optimal policies and adaptive control (e.g., the control of systems where certain parameters are unknown) needs further exploration.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 3 . 1 .</head><label>31</label><figDesc>(States, operators, and value function) -For some m ∈ IN we define the state space X = IN m+1 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>11. 2</head><label>2</label><figDesc>Monotonicity in Parameters 69</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>.4) Consider first x 1 ≤ s. Then(11.4) is an equality. Next consider x 1 = s + 1. Then (11.4) reduces to f (xe 1 ) ≤ f (x). Finally consider x 1 &gt; s + 1. Then(11.4) reduces to f (x) + f (xe 1 ) ≤ f (xe 1 ) + f (x), as in the proof of the third statement.</figDesc><table><row><cell>Theorem 11.7. Value functions consisting of operators from</cell></row><row><cell>the set {T</cell></row></table><note><p><p>env , T A(λ) , T FS , T disc with C ∈ I ∩ Cx, T D with µ(x) ∈ I ∩ Cv}, T D(µ) , T D(s) } are increasing and convex in the arrival rate, departure rate, and/or number of servers, assuming V 0 = 0.</p>Proof. According to Theorem 9.3 the value functions are convex and increasing. Lemmas 11.1 (first statement) and 11.4 combined to show the increasingness in the arrival rate, departure rate, and/or number of servers. The convexity in these parameters follows from Lemmas 11.5 and 11.6.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>11.2 Monotonicity in Parameters 65</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note that</head><p>x + e i + e jx = x + 2e i + e j -(x + e i ) = e i + e j . Thus if rejection is optimal in x, i.e., f (x + e i + e j )f (x) ≥ c, then it is also optimal to reject in x + e i , because of SubC. Thus there is only one possibility for which the actions on the right-hand side of SubC(i, j) are different: admission in x, rejection in x + e i . Then</p><p>The property T R : I → I is easy to prove. For ASC → ASC we refer to <ref type="bibr" target="#b31">[32]</ref>. SC → SC is a special case of ASC → ASC. The other results for T R can be found in <ref type="bibr" target="#b39">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Departure Operators</head><p>Theorem 7.3. The following relations hold, 1 ≤ i, j ≤ m:</p><p>Note that T D1 is a special case of T D . The results of the form I ∩ Cx ∩ SuperC → SuperC imply I ∩ Super ∩ SuperC → SuperC, but we prefer this more general formulation (because I ∩ Super ∩ SuperC ⊂ I ∩ Cx ∩ SuperC), although in the models of the next sections we use SuperC mostly in combination with Super.</p><p>Also for T PD many results follow directly, as T PD can be seen as a combination of T unif and T D1(i) . Only the results for SC and ASC do not follow from results for T unif and T D1(i) , and therefore need a separate proof.</p><p>Proof. Consider T D(i) . The increasingness, UI, Cx(j) (j = i), Super(j, k) and Sub(j, k) (j, k = i) follow readily, without further conditions on the form of µ(x). We prove Cx(i). We write μ(x) = μµ(x). Using that µ ∈ Cv and f ∈ I in the first inequality and f ∈ Cx in the last inequality we find:</p><p>where the µs in the inequalities are equal to the µs in the movable server operators.</p><p>The proof is a direct consequence of results in Chapter 7. From combining operators T disc , T A(i) , and T MS with Equation (6.1) and Theorem 8.4 the optimality of the µc rule follows. This was first shown in Buyukkoc et al. <ref type="bibr" target="#b17">[18]</ref> and Baras et al. <ref type="bibr" target="#b11">[12]</ref>.</p><p>In our definition of T MS we did not allow for idleness unless x = 0. If we assume that f ∈ I then it is easy to show that idleness is suboptimal.</p><p>Adding T MMS gives the model of Chang et al. <ref type="bibr" target="#b18">[19]</ref>. The extra condition µ(1) ≤ • • • ≤ µ(m) makes that the optimal policy starts with the task with the longest expected processing times first. This policy is commonly known as LEPT. An interesting cost function in this context is II{|x| &gt; 0}. It can be verified that II{|x| &gt; 0} ∈ I ∩ wUI. Thus one of the consequences of Theorem 9.1 is that LEPT minimizes the expected time to empty a system without arrivals. In Hordijk and Koole <ref type="bibr" target="#b32">[33]</ref> other cost functions are considered, and also the use of the operator T min . Now consider the models with feedback using T MTS . Then we find the model of Nain <ref type="bibr" target="#b58">[59,</ref><ref type="bibr">Sec. 3]</ref>, Koole <ref type="bibr" target="#b37">[38]</ref> (extended in <ref type="bibr" target="#b38">[39]</ref>, see also <ref type="bibr" target="#b41">[42]</ref>), and Weishaupt, <ref type="bibr" target="#b83">[84,</ref><ref type="bibr">Sec. 3</ref>].</p><p>An important application of the results for T MTS is the special case where the direct costs in T disc is equal to |x| or -|x|, and µ(i, j) is only positive for j = i -1 and i + 1, and increasing or decreasing in i.</p><p>Let all customers arrive in queue 1 (or m), and let the queue index represent the phase of the time that a customer spends in the system. Then, using limiting results of phase-type distributions, we can model G/G/1 queues with general service disciplines. In addition to that, if the service time distribution has an increasing (decreasing) hazard rate, then the approximating phase-type distributions are such that the consecutive phases have increasing (decreasing) service rates <ref type="bibr">(Koole [38]</ref>).</p><p>for all i, j, k, l ∈ IN 0 . Lemma 11.3. For functions f and f it holds that:</p><p>Proof. The proof of the first expression is similar to the proof of Lemma 4.3 of <ref type="bibr" target="#b44">[45]</ref>. The second expression is trivial to show. Lemma 11.3 can be used as follows. By taking j = k = l = 0 in the ordering, we find f ((X, Y ), i) ≤ f ((X, Y ), i) for X and Y , the states of on-off process 1 and 2, stationary.</p><p>Consider now two systems with K on-off processes, with arrival probabilities the vectors λ and λ with λ(k) = λ (k) = 1. Let λ and λ differ in only two entries, with λ more "balanced" than λ . Now Lemma 11.3 can be applied. By repeating this we find an ordering between pairs of λ and λ : λ ≺ λ if we can construct one from the other by repeatedly changing two entries. This ordering is exactly the Schur convex ordering of Marshall and Olkin <ref type="bibr" target="#b53">[54]</ref>, see Section 6.2. This leads to the following: Corollary 11.1. Consider two value functions V n and V n consisting of T disc , T env , T 0/1T , T 0/1A , T A , T D with λ ≺ λ and direct costs C ∈ I ∩ Cx then V n (i) ≺ 0/1 V n (i).</p><p>Note that we need C ∈ I as T D is part of the value function. This corollary is a generalization of results in Koole and Liu <ref type="bibr" target="#b44">[45]</ref>.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Discrete-Event Control of Stochastic Networks: Multimodularity and Regularity</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gaujal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hordijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Mathematics</title>
		<imprint>
			<biblScope unit="volume">1829</biblScope>
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On optimal call admission control in a resource-sharing system</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jiménez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="1659" to="1668" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the comparison of queueing systems with their fluid limits</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jiménez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="165" to="178" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Stochastic scheduling games and Markov decision arrival processes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Computers and Mathematics with Applications</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="141" to="148" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Control of a random walk with noisy delayed information</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems and Control Letters</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="207" to="213" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On submodular value functions and complex dynamic programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stochastic Models</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1051" to="1072" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Closed-loop control with delayed information</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Performance Evaluation Review</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="193" to="204" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimality of monotonic policies for twoaction markovian decision processes, with applications to control of queues with delayed information</title>
		<author>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="267" to="291" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Convexity properties and comparative statics for M/M/S queues with balking and reneging</title>
		<author>
			<persName><forename type="first">M</forename><surname>Armony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Plambeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshadri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">77</biblScope>
		</imprint>
	</monogr>
	<note>Working paper</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optimal routing into two heterogeneous service stations with delayed information</title>
		<author>
			<persName><forename type="first">D</forename><surname>Artiges</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="1234" to="1236" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Marked point processes as limits of Markovian arrival streams</title>
		<author>
			<persName><forename type="first">S</forename><surname>Asmussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Probability</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="365" to="372" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">K competing queues with geometric service requirements and linear costs: The µc-rule is always optimal</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Baras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D.-J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Makowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems and Control Letters</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="173" to="180" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Production-inventory systems with imperfect advance demand information and due-date updates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Benjaafar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mardan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>University of Minnesota</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Working Paper</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Production and inventory control of a single product assemble-to-order system with multiple customer classes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Benjaafar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Elhafsi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management Science</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="1896" to="1912" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Routing in queueing networks under imperfect information: Stochastic dominance and thresholds</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Beutler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Teneketzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stochastics and Stochastics Reports</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="81" to="100" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimal control of admission to a multiserver queue with two arrival streams</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P C</forename><surname>Blanc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>De Waal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="page" from="785" to="797" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Optimal threshold policies in a two-class preemptive priority queue with admission and termination control</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brouns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Der Wal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="21" to="33" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The cµ rule revisited</title>
		<author>
			<persName><forename type="first">C</forename><surname>Buyukkoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varaiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Applied Probability</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="237" to="238" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the optimality of LEPT and cµ-rules for machines in parallel</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pinedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Probability</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="667" to="681" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">In search of sensitivity in network optimization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pandit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Meyn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="313" to="363" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Effects of system parameters on the optimal policy structure in a class of queueing control problems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Örmeci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Karaesmen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Working paper</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the incomplete results for the heterogeneous server problem</title>
		<author>
			<persName><forename type="first">F</forename><surname>Véricourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-P</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="189" to="191" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the optimal assignment of servers and a repairman</title>
		<author>
			<persName><forename type="first">C</forename><surname>Derman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Lieberman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Probability</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="577" to="581" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Monotone optimal policies for a transient queueing staffing problem</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="327" to="331" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Control of arrivals to two queues in series</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Ghoneim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="399" to="409" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Monotone optimal control of permutable GSMPs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Glasserman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations Research</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="449" to="476" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Glasserman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Yao</surname></persName>
		</author>
		<title level="m">Monotone Structure in Discrete Event Systems</title>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Optimal control of two interacting service stations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hajek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="491" to="499" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Extremal splitting of point processes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hajek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations Research</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="543" to="556" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Optimal control of two parallel infinite-server queues</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th CDC</title>
		<meeting>the 29th CDC</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="1329" to="1335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the optimality of the generalized shortest queue policy</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hordijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="477" to="487" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the assignment of customers to parallel queues</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hordijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="495" to="511" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On the optimality of LEPT and µc rules for parallel processors and dependent arrival processes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hordijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Advances in Applied Probability</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="979" to="996" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Convexity of functions which are generalizations of the Erlang loss function and the Erlang delay function: Problem 90-8</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Jagers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Van Doorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Review</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="281" to="282" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Optimality of the shortest line discipline with state-dependent service times</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Johri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="157" to="161" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Modeling and control of automated manufacturing systems table of contents</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kimemia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Gershwin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
	<note>An algorithm for the computer control of a flexible manufacturing system</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Time-sharing service systems I</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Klimov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Probability and its Applications</title>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="532" to="551" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Optimal server assignment in the case of service times with monotone failure rates</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems and Control Letters</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="233" to="238" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Stochastic Scheduling and Dynamic Programming</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CWI Tract</title>
		<imprint>
			<biblScope unit="volume">113</biblScope>
			<date type="published" when="1995">1995</date>
			<publisher>CWI</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Structural results for the control of queueing systems using event-based dynamic programming</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="323" to="339" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A transformation method for stochastic control problems with partial observations</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems and Control Letters</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="301" to="308" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Stochastic scheduling with event-based dynamic programming</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Methods of Operations Research</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="249" to="261" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Redefining the service level in call centers</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Working paper</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Convexity in tandem queues</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="13" to="31" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Stochastic bounds for queueing systems with multiple on-off sources</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="25" to="48" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Minimizing response times and queue lengths in systems of parallel queues</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Koole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Sparaggis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Probability</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1185" to="1193" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Scheduling a repairman in a finite source system</title>
		<author>
			<persName><forename type="first">G</forename><surname>Koole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vrijenhoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Methods of Operations Research</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="333" to="344" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Optimal control of arrivals to queues with delayed queue length information</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31th IEEE Conference on Decision and Control</title>
		<meeting>the 31th IEEE Conference on Decision and Control</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Optimal routing control in retrial queues</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Kulkarni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applied Probability and Stochastic Processes</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Shanthikumar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Sumita</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Optimal control of a queueing system with two heterogeneous servers</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="696" to="703" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Applying a new device in the optimization of exponential queueing systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Lippman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="687" to="710" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Sample path methods in the control of queues</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="293" to="335" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Second-order properties of single-stage queueing systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Liyanage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Shanthikumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Queueing and Related Models</title>
		<editor>
			<persName><forename type="first">U</forename><forename type="middle">N</forename><surname>Bhat</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Basawa</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="129" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Inequalities: Theory of Majorization and its Applications</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Marshall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Olkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Monotonicity and optimality of symmetric parallel processing systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Menich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Serfozo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="403" to="418" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Optimal service control of a station connected with two parallel substations</title>
		<author>
			<persName><forename type="first">N</forename><surname>Miyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ohnishi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Okino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="1567" to="1572" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">On a conjecture of Koole</title>
		<author>
			<persName><forename type="first">A</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="141" to="142" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Stochastic comparison of random vectors with a common copula</title>
		<author>
			<persName><forename type="first">A</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Scarsini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Operations Research</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="723" to="740" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Interchange arguments for classical scheduling problems in queues</title>
		<author>
			<persName><forename type="first">P</forename><surname>Nain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Systems and Control Letters</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="177" to="184" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Qualitative properties of the Erlang blocking model with heterogeneous user requirements</title>
		<author>
			<persName><forename type="first">P</forename><surname>Nain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="189" to="206" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Threshold and reservation based call admission control policies for multiservice resource-sharing systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K</forename><surname>Tsang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tatikonda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bensaou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of INFOCOM</title>
		<meeting>INFOCOM</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="773" to="783" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">The foregound-background processor-sharing queue: A survey</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nuyens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wierman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Dynamic admission control for loss systems with batch arrivals</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Örmeci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Burnetas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Applied Probability</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="915" to="937" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Admission policies for a two class loss system</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Örmeci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Burnetas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Der Wal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stochastic Models</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="513" to="540" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Puterman</surname></persName>
		</author>
		<title level="m">Markov Decision Processes</title>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">On optimal call admission control in cellular networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ramjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nagarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Infocom &apos;96</title>
		<meeting>IEEE Infocom &apos;96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Scheduling multiclass single server queueing systems to stochastically maximize the number of successful departures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Righter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Shanthikumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probability in the Engineering and Informational Sciences</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="323" to="333" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">The stochastic knapsack problem</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H K</forename><surname>Tsang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="740" to="747" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Monotonicity properties for the stochastic knapsack</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1173" to="1179" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">An equivalence between continuous and discrete time Markov decision processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Serfozo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="616" to="620" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Paramatric stochastic convexity and concavity of stochastic processes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaked</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Shanthikumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of the Institute of Statistical Mathematics</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="509" to="531" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Optimal control structure of an unreliable manufacturing system with random demands</title>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th CDC</title>
		<meeting>the 35th CDC</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="4552" to="4557" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Socially and individually optimal control of arrivals to a GI|M |1 queue</title>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management Science</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1598" to="1610" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Optimal control of admission to a queueing system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="705" to="713" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Analysis, design, and control of queueing systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="705" to="713" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Monotonic and insensitive optimal policies for control of queues with undiscounted costs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="611" to="625" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">A survey of Markov decision models for control of networks of queues</title>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="291" to="314" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">optimal scheduling of two competing queues with blocking</title>
		<author>
			<persName><forename type="first">J.-B</forename><surname>Suk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Cassandras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1086" to="1091" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">On the finite horizon Bellman equation for controlled Markov jump models with unbounded characteristics: Existence and approximations</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Van Dijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Stochastic Processes and their Applications</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="141" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<title level="m" type="main">Monotonicity properties of single server queues</title>
		<author>
			<persName><forename type="first">Á</forename><surname>Varga</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>Vrije Universiteit Amsterdam</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Monotone control of queueing networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Veatch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queueing Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="391" to="408" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">An Introduction to Queueing Networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Walrand</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Optimal control of service rates in networks of queues</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stidham</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Applied Probability</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="202" to="218" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Optimal myopic policies and index policies for stochastic scheduling problems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weishaupt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Methods of Operations Research</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="75" to="89" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Optimality of the shortest line discipline</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Winston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Probability</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="181" to="189" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
