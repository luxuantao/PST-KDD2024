<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Cooperation with Action Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Abo</forename><surname>Akademi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Tampere University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Cooperation with Action Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">079FD7530D43F00034E5D59CDFFAFE38</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Computer Communication Networks]: Distributed Systems</term>
					<term>D.1.3 [Programming Techniques]: Concurrent Programming</term>
					<term>D.3.3 [Programming Languages]: Language Constructs-concurrent programming structures</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs Languages, Theory, Verification Broadcasting networks, distributed systems, fairness, guarded commands, handshaking mechanisms, models of concurrency, multiprocess communication, programming languages, program verification, scheduling, temporal logic, true concurrency l</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Action systems provide a method to program distributed systems that emphasizes the overall behavior of the system. System behavior is described in terms of the possible interactions (actions) that the processes can engage in, rather than in terms of the sequential code that the processes execute. The actions provide a symmetric communication mechanism that permits an arbitrary number of processes to be synchronized by a common handshake. This is a generalization of the usual approach, employed in languages like CSP and Ada, in which communication is asymmetric and restricted to involve only two processes. Two different execution models are given for action systems: a sequential one and a concurrent one. The sequential model is easier to use for reasoning, and is essentially equivalent to the guarded iteration statement by Dijkstra. It is well suited for reasoning about system properties in temporal logic, but requires a stronger fairness notion than it is reasonable to assume a distributed implementation will support. The concurrent execution model reflects the true concurrency that is present in a distributed execution, and corresponds to the way in which the system is actually implemented. An efficient distributed implementation of action systems on a local area network is described. The fairness assumptions of the concurrent model can be guaranteed in this implementation. The relationship between the two execution models is studied in detail in the paper. For systems that will be called fairly serializable, the two models are shown to be equivalent. Proof methods are given for verifying this property of action systems. It is shown that for fairly serializable systems, properties that hold for any concurrent execution of the system can be established by temporal proofs that are conducted entirely within the simpler sequential execution model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The behavior of a distributed system is usually described in terms of a collection of communicating processes. Each process carries out a sequential piece of program and interacts with the other processes by sending and receiving Authors' addresses: R. J. R. Back, Abo Akademi, Department of Computer Science, Lemminkliisenkatu 14, SF-20520 Abo, Finland; R. Kurki-Suonio, Tampere University of Technology, Computer Systems Laboratory, P.O. Box 527, SF-33101 Tampere, Finland. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery.</p><p>To copy otherwise, or to republish, requires a fee and/or specific permission. 0 1988 ACM 0164-0925/88/1000-0513 $01.50 messages. Message passing can be synchronized, as in CSP <ref type="bibr" target="#b25">[25]</ref>, Occam <ref type="bibr" target="#b27">[27]</ref>, or Ada <ref type="bibr">[l]</ref>, or it can be asynchronous, as is usually the case in computer networks. This approach can be implemented by standard techniques, and has proved useful in designing distributed systems.</p><p>A problem with the process-based approach is that it can be difficult to get a picture of the overall behavior of the system. Processes may interact in unexpected ways, and the number of potential interactions to be considered is usually quite large. This is reflected in proof rules for process-based programs, which tend to be cumbersome and intricate. In this paper we consider another approach to describing distributed systems, which is dual to the process approach: The behavior of the system is described in terms of the possible interactions that may occur between the processes during execution. We refer to these interactions as actions, and call a description of the system in terms of interactions an action system. By focusing on the interactions that may occur, it is easier to design the overall behavior of the system. On the other hand, it becomes harder to implement such a system in a distributed fashion; so there is a trade-off involved.</p><p>The action system approach was first introduced in <ref type="bibr" target="#b3">[5]</ref>, where it was applied to the stepwise refinement of distributed algorithms. A CSP implementation was given for the special case of two-process actions. The semantic and proof theoretic issues involved in action systems, with special emphasis on fairness issues, were studied in a subsequent paper [ 71. The work reported here is an extension of that paper. A case study of applying the mechanism in the systematic derivation of a correct distributed algorithm is given in <ref type="bibr" target="#b4">[6]</ref>. Efficient implementations of action systems are described in <ref type="bibr" target="#b5">[7]</ref> and <ref type="bibr" target="#b2">[4]</ref>. A more detailed study of fairness in action systems is given in <ref type="bibr" target="#b6">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">.l Informal Presentation of Action Systems</head><p>An action system is similar to a production system such as OPS5 <ref type="bibr" target="#b18">[19]</ref>, i.e., it is a collection of productions that are executed repeatedly, as long as possible. Another similar construct is the guarded iteration statement <ref type="bibr" target="#b14">[15]</ref> do guard1 + statementlO . . . Oguard, + statement, od, which has the same basic execution mechanism: guarded statements are executed repeatedly, as long as some guard is true. The main difference between action systems and these other language mechanisms is in the way they are executed: guarded commands and production systems are designed for sequential execution, whereas an action system is designed for concurrent execution by a collection of independent communicating processes.</p><p>An action system consists of a collection of processes and a collection of actions. A process is of the form process p : var yP ; statement,.</p><p>The variables yp stand for the local variables of process p, while statement, assigns initial values to these variables. The local variables together constitute the global state y of the action system.</p><p>An action is of the form action a by processes, :guurd, -+ statement,.</p><p>This states that action a may be executed jointly by the processes in the set processes,, provided that guard, is satisfied and the processes are not participating in other actions (the action is then said to be enabled). Executing the action changes the program state in the way described by statement,. We refer to the statement as the body of the action. The guard and the body of an action may only refer to local variables of the processes participating in the action, i.e., to the set of variables ya = U( yP 1 p E processes,).</p><p>In order to allow a distributed implementation of action systems, we will require that the guards in actions are separable. This means that the guard is a Boolean condition where each atomic predicate refers to local variables of only one process. The truth of each atomic predicate in the guard can then be determined by some process participating in the action by inspecting only its own local variables. As an example, the guard contains the atomic predicates x B 0, y d z and w b 0. It is separable if the local variables y and z belong to the same process, otherwise it is not.</p><p>The execution of an action system proceeds by repeatedly executing individual actions, as long as there are actions that are enabled. No process may participate in more than one action at a time. As long as this restriction is obeyed, any number of actions may be executed in parallel. An action that is executed by two or more processes together is referred to as a joint action, because the processes have to cooperate to achieve the effect of the action. An action that is executed by one process only is referred to as a private action, because it can be carried out by that process alone, without cooperation with other processes.</p><p>Example 1. Let us consider the Dining Philosophers problem as an example of an action system. A diagram of this system is given in Figure <ref type="figure" target="#fig_1">1</ref>. The action system consists of n philosopher processes and n fork processes, n L 2, declared as follows:</p><p>process Philosopher[i: 1 . . n]; var hungry : boolean; hungry := false; process Fork[i: 1 . . n];</p><p>A set of processes may be declared by appropriate indexing, as shown by the example. Each philosopher process has a local variable hungry, initialized to false, to indicate whether he is hungry or not. The fork processes do not have any local variables at all, as they are used purely for synchronization. The global state thus consists of the variables Philosopher <ref type="bibr">[i]</ref>.hung~, i = 1, . . . , n.</p><p>There are two kinds of actions in the system, thinking actions and eating actions. The thinking actions are  and Fork[i + 11. The action is enabled when the philosopher is hungry. The action body consists of an unspecified eating part followed by an assignment that makes the philosopher nonhungry. We assume here and in the sequel that all index arithmetic is modulo n, so i + 1 above stands for i mod n + 1. Mutual exclusion and freedom from deadlock are here guaranteed by the action mechanism: a fork can only be engaged in one action at a time, so an eating action can only take place when the philosopher is hungry and the two forks are simultaneously available. Individual starvation is, however, possible: a philosopher will starve if his two neighbors keep eating alternatingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Communication in Action Systems</head><p>In the above example the processes are synchronized by the eating actions. However, no transfer of information actually takes place here. To illustrate this, as well as more intricate synchronization between processes, let us add a tokenpassing mechanism by which individual starvation can be prevented. This mechanism will prevent the philosopher whose right fork has a token from eating, thus giving his right neighbor a chance to eat. The eating action will pass the token from the left to the right fork of the philosopher, if there is a token at the left fork. The synchronization of the eating action now involves conditions on local variables in both the philosopher process and in the right fork process.</p><p>The example illustrates how process communication is implicit in the guard and in the action bodies. The processes are synchronized by the guard: the eating action, for instance, is only executed if the philosopher is hungry, the forks are available, and the right fork does not have a token. An arbitrary number of processes may be synchronized by a joint action: the eating action synchronizes three processes. Information transfer is achieved with the action body: executing the eating action passes the token from the left fork to the right fork. No explicit synchronization or communication primitives are needed in the language. Transfer of information is symmetric in the action system mechanism, in the sense that all processes participating in an action are treated in the same way. Each process can use the local variables of the other processes to update their own local variables. Usually processes in a communication event are treated asymmetrically.</p><p>In CSP, for instance, information is only transferred from the sender to the receiver. In Ada, input information is transferred from caller to callee, while output information is transferred from callee to caller.</p><p>Another difference has to do with the possibility to choose between alternative communications.</p><p>In the original CSP <ref type="bibr" target="#b25">[25]</ref> and in Occam, this is restricted to the receiver (unless output guards are allowed), in Ada to the callee. (The restriction on output guards is removed in <ref type="bibr" target="#b26">[26]</ref>, in which CSP is treated from a proof and model theoretic point of view, and where implementation efficiency therefore is not a prime concern.) In action systems, each process can be involved in many different actions, any number of which can be simultaneously enabled. Each process involved in an action may thus be in a position to choose between alternative actions. The communication mechanism is thus symmetric also in this aspect. The action mechanism can therefore be characterized as a generalization of the communication mechanisms of CSP and Ada to symmetric multiprocess handshaking. This communication mechanism can be implemented in an efficient manner, as shown in Section 3 below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Reasoning about Action Systems</head><p>The close resemblance of action systems to the guarded iteration statements and production systems suggests that one could reason about the behavior of an action system as if it were executed in a sequential manner. Actions would be executed one at a time, such that at each step one of the enabled actions would be chosen nondeterministically and executed to completion before selecting the next action. This is the way in which the guarded iteration statement is executed. The advantages of being able to use this abstraction would be considerable. The sequential execution model is simpler to reason about, and it has a welldeveloped proof theory. For action systems that are intended to terminate one can use Hoare logic <ref type="bibr" target="#b23">[24]</ref> or the weakest precondition technique of Dijkstra [Xl. For continually running action systems (reactive systems, in the terminology of Pnueli <ref type="bibr" target="#b32">[32]</ref>), temporal logic provides a suitable framework for reasoning, along the lines of Manna and Pnueli <ref type="bibr" target="#b31">[31]</ref>.</p><p>The main problem to be considered in this paper is to what extent such a simple sequential (and nondeterministic) execution model can be used in reasoning about actions systems, when the actions are in fact executed in parallel, in a distributed fashion. The two models of execution lead to different views of when an action can be considered enabled. In a sequential execution an action is enabled if its guard is true. In a concurrent execution this is not sufficient; we must also require that all processes needed for the action be free to participate in it (i.e., they are not engaged in any other concurrently executing action).</p><p>This difference shows up in the different notions of fairness that one might reasonably expect to hold for an execution. If actions are executed in a sequential manner, then fairness for actions means that if the guard of an action is infinitely often true, then the action is infinitely often executed. We refer to this notion of fair sequential execution as action fairness. As an example, action fairness for the eating actions in Example 1 is sufficient to guarantee absence of individual starvation: each philosopher that becomes hungry will sooner or later be able to eat.</p><p>If actions are executed in a concurrent and distributed manner, then the fairness notion becomes the following: If infinitely often the guard of an action is true and all processes needed for the action are free to participate in it, then the action is infinitely often executed. We refer to this notion of fair concurrent execution as handshake fairness. An even weaker notion of fairness requires only that processes are treated fairly: a process that infinitely often is able to participate in some action should infinitely often do that. This is referred to as process fairness. Sequential and concurrent executions thus have different notions of fairness, and hence properties that hold for sequential executions of action systems need not be valid for concurrent executions of the same action systems.</p><p>Handshake fairness for the eating action in Example 1 above would mean the following: If infinitely often the eating action is enabled (the philosopher is hungry and both his forks are free), then the eating action will take place infinitely often. Handshake fairness is not sufficient to prevent individual starvation. If the two neighbors of a philosopher eat alternately, such that at each moment one of the neighbors is eating, then there is never any moment when the philosopher in the middle has both forks simultaneously available. The computation is handshake fair, even if the philosopher never gets to eat.</p><p>Process fairness for the philosophers in Example 2 means that if infinitely often the philosopher is free to engage in some action (eating or thinking), then it will infinitely often participate in some action. In the example, process fairness is sufficient to guarantee that the philosopher gets to eat infinitely often (assuming that eating and thinking actions are always finite).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Overview of Paper</head><p>The content of the rest of the paper is as follows. Action systems are defined formally in the next section. We define execution of an action system in a way that corresponds to the execution of guarded iteration statements. We refer to this execution model as the sequential execution model. We will show how to prove properties of action systems in the temporal logic framework. For liveness properties we assume action fairness for specific actions.</p><p>The implementation of action systems will be described in Section 3. We first present a concurrent execution model. This model corresponds to a parallel and distributed execution of actions in a system. We will show how this model can be implemented in a distributed fashion. As a concrete example we consider the implementation of this execution model on a local area network with reliable broadcasting. All processes are assumed to receive the broadcast messages in the same order. The unique ordering of messages makes it possible to build an efficient distributed execution mechanism for actions. We show that the implementation is correct with respect to the concurrent execution model.</p><p>Two different execution models for action systems are thus given, the sequential model in Section 2 and the concurrent model in Section 3. The sequential model is the one we want to reason about, while the concurrent model is the one that we are able to implement efficiently in a distributed fashion. The relationship between these two models is studied in Section 4. The main problem considered is the following: to what extent can the abstraction of sequential execution be kept up when execution is actually done according to the concurrent execution model? In other words, to what extent are properties that hold for a sequential execution of an action system valid also for a concurrent execution of the action system?</p><p>We show that as far as safety properties go, this abstraction can be preserved without problems. However, for liveness properties this is not the case, because the notion of fairness that we want to use in the sequential model (action fairness) is stronger than the fairness notions that are reasonable in the concurrent execution model (handshake fairness or process fairness). The latter notions are restricted by what can be guaranteed in a distributed system without introducing a centralized scheduling mechanism for actions.</p><p>This leads us to study the fairness notions in the two execution models in more detail. Computations in the concurrent execution model will be shown to simulate the computations in the sequential execution model. This allows us to relate the computations in the two models to each other, and to define action fairness for computations in the concurrent model. We will say that an action system is fairly serializable, if action fairness is guaranteed by handshake or process fairness in the concurrent execution model. If the action system is fairly serializable, then each fair computation in the concurrent model simulates an action fair computation in the sequential execution model.</p><p>We will define subclasses of action systems that are fairly serializable. These subclasses are defined both by static properties of action systems and by dynamic properties of the execution of action systems. The former can be established by proving properties of the guards and bodies of individual actions, the latter by proving that the execution of the action system satisfies certain temporal logic formulas. In practice, proving that a certain action system is fairly serializable amounts to proving that certain forms of conflicts and conspiracy among processes cannot occur during execution of the system.</p><p>In Section 5 we then consider how to prove properties of concurrent executions of action systems. We want to establish these properties by reasoning only about sequential executions of action systems. For safety properties this does not present any problem, as each safety property that holds for sequential execution of an action system will also hold for concurrent execution of this system. Liveness properties are proved in two stages. One first proves that any sequential execution satisfies the required liveness property, assuming that the necessary assumptions about action fairness are valid. One then proves that these fairness assumptions hold in a concurrent execution, by proving that the action system is fairly serializable for these actions.</p><p>We will also show that in the latter case it is sufficient to consider only sequential executions of action systems. By introducing the notion of serializability we are thus able to establish both safety and liveness properties of distributed executions of an action system using only the sequential execution model in our reasoning. We may thus ignore that the action system is, in fact, executed in a distributed fashion.</p><p>The concept of a global state is well defined in the sequential and concurrent execution models, but it is not clear what it really corresponds to in an actual distributed execution of an action system, i.e., whether the global states of a concurrent computation can in fact be observed in a real distributed implementation of the action system. We will analyze this issue more closely and show that if a temporal property holds in the concurrent execution model of an action system, then the property can also be observed to hold in an actual distributed execution of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ACTION SYSTEMS</head><p>We will here define more precisely what an action system is and how it is executed. We will use the temporal logic framework of Manna and Pnueli <ref type="bibr" target="#b31">[31]</ref> to define action systems and their executions.</p><p>A transition system is a quadruple (Z , Z O, T, 9) consisting of a set of states Z , a set of initial states Z O C I:, a finite set of transitions T, and a fairness family F= IF,,.. . , F,, ), Fi G T. Each transition t E T is a partial function t : Z: + Z . Transition t is said to be enabled in a state u E Z , if t(a) is defined.</p><p>A computation in a transition system is a finite or infinite sequence c of the form h t2</p><p>C:</p><p>uo ----* CT1 * * * * ui-1 A ui -* a, u~EZ, tiET, which satisfies the following four conditions:</p><p>(1) The computation is properly initialized, i.e., u. E 2'.</p><p>(2) The computation is admissible, i.e., for each transition ti in c, ti is enabled in This means that the following condition holds: If c contains an infinite number of states 0; in which a transition t E F is enabled, then c contains an infinite number of transitions in F.</p><p>One could also impose the weaker requirement of justice (or weak fairness) with respect to certain sets of transitions <ref type="bibr" target="#b31">[31]</ref>. For simplicity we only deal with fairness in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Formal Definition of Action Systems</head><p>An action system is a tuple S = (Proc, Act, Var, hit, Actions)</p><p>where the components are as follows:</p><p>(1) Proc is a nonempty set of process names.</p><p>(2) Act is a nonempty set of action names.</p><p>(3) Var = 1 yp Jp E Proc) is a partitioning of the program variables into local variables yp of the processes p E Proc. We write y = UVar for the set of all program variables in the system. (4) Init is a collection of process initialization statements S,( y,,), p E Proc, that assign initial values to the local variables yp.</p><p>(5) Actions is a collection of actions of the form action a by hoc,: gn( -ya) + S,( y=), a E Act.</p><p>Here Proc, C Proc is the set of processes participating in the action a, Ya = U(Y,lP E p rot,) is the set of local variables of these processes, the Boolean condition g=( ya) is the action guard, and the statement S,( ya) is the action body.</p><p>We will assume that all initialization statements S, and action bodies S, are deterministic. Initialization statements are assumed to always terminate, while action bodies are assumed to terminate whenever the guard is satisfied. In the sequel we usually model the effect of an initialization statement S, by an assignment yp := c,,, where c, is some list of constants that matches the list of variables yp. Similarly, we will model the effect of an action body S, by an assignment y0 := fa( y=), where fa is some (list of) function(s) that gives the effect of executing the action body.</p><p>An action system S may be constrained by an initial condition Q on the program variables, which must be established by the initialization of the action system. Processes without initialization statements may assign any initial values to their local variables that are consistent with the given initial condition. If no initial condition is indicated, then it is assumed to be true.</p><p>A guard of the form g ( y,), p E Proc, is called a local guard of p, as it only refers to the local variables of process p. A guard is said to be separable if it is a Boolean combination of local guards. An action system is said to be separable if each action guard in the system is separable. Separability makes it easier to implement action systems in a distributed fashion, as shown in Section 3. The semantic and proof theoretic analysis does not depend on this assumption, so it will only be made in that section.</p><p>The sequential execution model for an action system S, assuming action fairness for the actions in A C Act, is the transition system Seqs(A) = ( ZY, Zt,T, c&amp;) where</p><p>(1) each state u E Z, is an assignment of values to the program variables y, i.e., Q: y + D for some fixed domain of values D. (2) Z! is the set of all initial states u. such that (T~( yP) = c, for each p for which an initialization statement y P := c, has been provided in Init,</p><p>(3) T = (act, 1 a E Act) is a set of action transitions, and (4) FA consists of all singleton sets (act,), a E A.</p><p>An action transition act,: Z, + Z, is enabled in a state u E Z, if the guard g,( y=) of action a is true in u. It maps the values of the program variables y0 to fa( y=), leaving the other program variables unchanged. If an initial condition Q is given, then the set of initial states is further restricted to those states a0 that satisfy Q. A computation c in Seqs(A) is said to be action fair for action a, if c is fair with respect to (a&amp;). By definition, each computation of Seqs(A) is action fair for every action in A.</p><p>Action fairness is a strong requirement. In our first example, action fairness for eating actions is sufficient to prevent a philosopher from starvation. If Phibsopher <ref type="bibr">[i]</ref> is hungry, then the eating action will be enabled, and it stays enabled until the philosopher has eaten. Action fairness requires that the philosopher will eat sooner or later.</p><p>No concurrency is involved in the sequential execution model. It is therefore the easiest way of thinking and reasoning about action systems. Actions are executed one at a time, starting from a given initial state, as long as there are enabled actions to execute. At each stage, one of the enabled actions is chosen nondeterministically for execution. The computation terminates when there are no enabled actions any more. This, in essence, is the way in which the guarded iteration statement of Dijkstra is executed. The difference is that we are also interested in infinite computations, in which case we also require action fairness of the computation, i.e., we require that the alternatives in the guarded iteration statement must be chosen in a fair manner <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Proving Properties of Sequential Executions</head><p>We will here show how to prove properties of action systems within the temporal logic framework. The actions are identified with the transitions in the sequential execution model. Hence one reasons about the behavior of an action system directly in temporal logic, by considering all possible sequences of actions, subject to the given action fairness constraints. The proof rules and proof methods of <ref type="bibr" target="#b31">[31]</ref> carry over directly to action systems, and can be used as such in establishing their temporal properties. (Other expositions of the temporal logic approach are given in <ref type="bibr">[28, 321.)</ref> This close correspondence with the temporal logic framework is one of the main advantages of and motivations for using the sequential execution model for action systems. Example 3. We consider the solution with token passing in Example 2, but modify it in such a way that a philosopher has to give preference to his right neighbor only when the latter has made a reservation for his left fork by a special reserve action. When the token eventually arrives at this fork, the left neighbor is then forced to give the right neighbor a chance to eat, provided that the latter has not eaten since he reserved the left fork. The resulting action system is illustrated in Figure <ref type="figure" target="#fig_2">2</ref>.</p><p>The philosopher processes are as before, while the fork processes are extended with local variables for the reservation. Initially the first fork has the token, and no fork is reserved. The thinking action is unchanged, while the eating action must be adapted to take token passing and reservations into account. An additional action is introduced by which a philosopher reserves his left fork. We prove properties of this action system by reasoning about the possible sequences of actions that can occur during a computation of the system, subject to the given action fairness assumptions. A safety property q I states that condition I holds throughout the computation of the action system, i.e., I is an invariant of the system. This is established by proving that (i) the initializations together establish the invariant, i.e., true@&amp;; . . . ; SJI, where pl, . . . . p,, are the processes for which initializations have been provided, and (ii) each action preserves the invariant, i.e., I A &amp;b%lI holds for each action a E Act.</p><p>Here P(S)Q stands for the partial correctness of statement S with respect to precondition P and postcondition Q <ref type="bibr" target="#b23">[24]</ref>.</p><p>An example of an invariant property is that there is always exactly one fork with an associated token in the action system described above, i.e., n C Forlz[i].token = 1 i=l holds throughout the execution of the action system. This is obviously established by the initializations of the local variables and it is preserved by each action execution.</p><p>Our definition of action systems requires that each initialization statement and action body terminates if executed. If we require total correctness rather than partial correctness in (i) and (ii), then this property is established at the same time as establishing the invariance of the given condition.</p><p>Liveness properties are also proved in the usual way, using permitted fairness assumptions when necessary. As an example, consider the property that each philosopher infinitely often gets hungry:</p><p>q OPhilosopher[i].hungry, for each i = 1, . . . , n. This follows directly from the fact that whenever PhiZosopher[i] is not hungry the thinking action is enabled. If action fairness is assumed for thinking actions, then this action will be eventually executed. The thinking action will then necessarily terminate, making the philosopher hungry. Liveness in this case is straightforward to establish. Proving that the action system is starvation free is more complicated. Starvation freedom is expressed by the property q (hungvi + Olhung~~i), for i = 1, . . . , n. (For brevity, we write hungryi for Philosopher[i].hungry and similarly for the other local variables in the system.) We prove this property by using the method of well-founded ranking <ref type="bibr" target="#b31">[31]</ref>. In this method, the set of possible states is partitioned into a number of cases which forms a well-founded order in Eating <ref type="bibr">[i+l]</ref> &amp;fL+-$ the sense that (i) no transition leads from a lower case to a higher case, and (ii) for each case for which there are lower cases, there is at least one transition that necessarily leads to a lower case. These transitions are called helpful transitions. Fairness for the helpful transitions guarantees that a case at the bottom in this order is eventually reached.</p><p>Assume that philosopher i is initially hungry. We then have two cases: either his right fork has a token or it does not. If it does have a token, there are again two cases: either the right fork is reserved or it is not. Finally, in the latter case we have two cases: either philosopher i + 1 is hungry or he is not. This gives us altogether five possible cases to consider, which we denote by Wi, i = 0, 1, 2,3,4 ( IV0 is the case when philosopher i is not hungry):</p><formula xml:id="formula_0">Wo = lhungvyi, WI = hungryi A ltoken;+t, Wz = hungryi A tokeni+ A reservedi+l, Ws = hungryi A t&amp;eni+l A lreservedi+l A hungvi+l, Wb = hungryi A t&amp;eni+l A lreservedi+l A lhungvi+l.</formula><p>We already noted above that there is exactly one token in the system. Hence, Wi 4 ltokeni+n, for i = 4, 3, 2. Similarly, one can prove that fork i is only reserved if philosopher i is hungry, SO reservedi+ + hungryi+ . Figure <ref type="figure" target="#fig_7">3</ref> shows the helpful actions in these situations. In W3, for instance, action Eating[i] will lead directly to W,, whereas action Reserve[i + l] will lead to situation W, and Eating[i + l] will lead to WI. None of the other actions can change this situation. This shows that fairness for eating actions is sufficient to guarantee that starvation is impossible. Note that we do not really need action fairness for thinking and reserve actions to guarantee starvation freedom.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">IMPLEMENTATION OF ACTION SYSTEMS</head><p>In this section we show how to implement an action system in a distributed fashion. We first define a transition model for the concurrent execution of actions. After this we show how this model can be implemented in a distributed fashion. We describe an implementation of action systems on a local area network with reliable broadcasting, and show that the implementation is correct in the sense that it simulates the concurrent execution model of action systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Concurrent Execution Model</head><p>In order to model a parallel and distributed implementation of action systems, we must describe the real concurrency that is present in these. This is done by the concurrent execution model of an action system. The model is similar to the sequential execution model, in that actions are still treated as the active components that are executed. However, they now have to compete for the processes, which are treated as passive resources in the system. Real concurrency is modeled by indicating the start and the end of process participation in an action. An action will be enabled only if its guard is true and all the processes needed for its execution are free.</p><p>The concurrent execution model for an action system S = (Proc, Act, Var, hit, Actions), assuming process fairness for the processes P C Proc and handshake fairness for the actions A C Act, is a transition system Cons(P, A) = (2 r,free 2 Z&amp;ee, T, ~555,~) where the components are defined as follows:</p><p>(1) The state of the transition system is determined by the variables y, together with a collection of Boolean variables free = (free, 1 p E Proc], indicating for each process p whether it is free or currently involved in some action or initialization.</p><p>(2) %ree is the set of all initial states a0 such that (i) a0 assigns the values c, to the variables yP for each p for which an initialization statement has been given, and (ii) free, = false for each p E Proc.</p><p>(3) For each action a E Act there is a handshake transition hs, in T, and for each process p E Proc, there is a release transition relp in T. (4) The fairness sets in stP,A include all singleton sets (rel,}, p E Proc. In addition, for each p E P there is a process fairness set Fp and for each a E A a handshake fairness set F,, as described below.</p><p>The handshake transition hs, is enabled if g, ( yO) holds and free, = true for each p E Proc,. It maps the values of ya to fa( yo) and the values of free, to false, for each p E Proco, leaving all other state components unchanged. A release transition relp is enabled if free,, = false. It maps the value of free, to true, leaving the other state components unchanged.</p><p>If an initial condition Q is given for the action system, then the set of initial states is further restricted to those states a0 that satisfy Q.</p><p>A handshake transition hs, corresponds to a synchronizing handshake. It can be executed only if all processes needed for the action are free, free, = true for each p E Proc,, and willing to participate in the action a, g,(y,) = true. The effect of the action is considered to take place immediately, i.e., all variables receive their updated values by transition hs,. The release transition relp releases processp from the action in which it is engaged. The initialization of the variables free, implies that each process starts by a release transition.</p><p>Intuitively, this means that we do not assume that all processes are started up at the same time.</p><p>By making the start and the finish of process participation in the action into separate transitions, we are able to model the fact that executing a transition takes time, and that at any specific moment in the execution of an action system some processes may be in the middle of executing an action, while other processes are free and waiting to be engaged in some new action.</p><p>We define two different notions of fairness in the concurrent model. Both of these can be achieved by a distributed implementation of an action system, as we will show below. The first notion is process fairness. This means that if a process is infinitely often able to make progress it is also infinitely often allowed to do that. Formally, process fairness for a process p E P means fairness with respect to the set of transitions Fp = (h.s, 1 a E Act,,].</p><p>Here Act, = (a E Act 1 p E Proc,,) is the set of all actions in which process p can participate.</p><p>The second notion is handshake fairness. By this we mean that if the guard of an action is infinitely often true and all the required processes are free, then the action is also infinitely often executed. Formally, handshake fairness with respect to an action a means fairness with respect to the singleton set As stated above, a computation is always assumed to be fair with respect to release transitions rel,. This reflects our assumption that action bodies always terminate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Distributed Implementation of Action Systems</head><p>There are essentially three problems involved in implementing an action system: (i) it must be detected when actions become enabled; (ii) the enabled actions must be scheduled for execution; and (iii) the action bodies must be executed. All this must be done in a distributed fashion.</p><p>We will assume that all action guards are separable. A separable guard g,(ya) can be written in disjunctive normal form gA( yO) V --. V gt( y= can be replaced by actions a', . . . , ah, where u' is action a' by Proc,: gi(y,) ---, S,(y,), i=l -*, k. This collection of actions has the same effect as the original action. Hence, we may in the sequel assume that this action splitting has been done, and that all action guards are simple.</p><formula xml:id="formula_1">)</formula><p>A local guard only tests a condition on the local variables of one process. Hence, each process can test the truth of its own local guard without consulting the other processes. An action is then enabled if each process involved in the action is free and has determined that its local guard is enabled. The first problem can now be solved by letting each process announce its willingness to participate in the actions for which its local guards evaluate to true when it becomes free from executing a previous action or the initialization statement. By listening to these announcements the processes in the system can find out when some specific action becomes enabled.</p><p>The second problem is to build a distributed mechanism to select among the enabled actions those that are to be executed. The main problem is what to do with actions that become enabled at approximately the same time, but which require some common process and hence exclude each other. There are different ways of constructing such a distributed scheduling mechanism, depending on the assumptions that one makes about the underlying communication network. This problem is essentially a generalization of the problem of implementing CSP with output guards <ref type="bibr">[lo]</ref>. We describe below a way of scheduling the enabled actions when the communication mechanism is assumed to be a reliable broadcasting channel.</p><p>The third problem is how to execute an action body. The body of an action is a sequential statement that may refer to local variables of all the participating processes. Conceptually, we think of the action body as being executed in the combined state space of the participating processes. This effect can be achieved by executing the body in a distributed fashion as follows. Each process keeps a copy of the local variables of all the other processes. When an action has been selected for execution, the processes involved in this action send the values of their local variables to all the other processes involved in the action, who update their local copies with the current values of these variables. Each process then executes the action body, using its own local variables and copies of the local variables of other processes. The local variables of the processes involved in the action will then be updated in the same way, as if the statement had been executed directly on the original local variables. (This solution obviously has room for improvement, but it is sufficient to show the basic idea.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Implementation on a Local Area Network</head><p>Processors in a CSMA/CD network are connected by a common channel on which they can broadcast messages to all other processes in the system. A process waits for its turn to communicate until the channel is free (i.e., no other process is broadcasting on it) before it attempts to transmit. If two or more processes attempt to transmit at the same time, then they notice that the messages collide, and each of them will wait a random time before trying again. We will assume that the channel is reliable, so all processes will receive the same sequence of messages.</p><p>Assume now that an action system S = (hoc, Act, Var, Init, Actions) is given, and that each process is assigned to a different processor in the network. Each action is assumed to have a simple guard. In order to record the availability of processes for actions, each process p keeps an allocation table where it records for each action those processes that have announced their willingness to participate in the action. Each process will be in one of four phases: ready, waiting,  collecting, and executing. Initially all processes start up in the executing phase, where they perform their initialization statements. They then cycle through the four phases in the order listed above, as shown by Figure <ref type="figure" target="#fig_10">4</ref>. The behavior of the processes in each of the phases is as follows:</p><p>Ready: The process evaluates its local guard for each action that it could participate in. Then it broadcasts a willingness message containing the names of those actions that it is willing to participate in. It goes into the waiting phase when it receives its own willingness message. While in the ready phase, the process does not record any messages from other processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Waiting:</head><p>Willingness messages are observed only by those processes that are in the waiting phase. On receiving a willingness message, each of them updates its allocation table accordingly and then inspects it to see whether there is an action in which it could participate and for which also the other processes have announced their willingness. If so, the process tries to broadcast a selection message for such an action. For two processes, p is called older than q, if its last willingness message was sent earlier. A selection message for an action a can be sent only by the oldest process in Proc,, because it is the only one that has seen the willingness messages of all the other processes in the action.</p><p>If two or more processes simultaneously try to transmit select messages, one of them will succeed first, and the others will cancel their selections upon receiving the conflicting select message. The action named in a selection message is marked as selected by all processes in the waiting phase. Those processes that are involved in this action go into the collecting phase, while the other waiting processes remove from their allocation tables the process names that are now committed to the selected action, and remain in the waiting phase. A process that has cancelled its own selection and remains waiting inspects the allocation table again. It tries to make a new selection if it finds actions that are still enabled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Collecting:</head><p>Each process involved in a selected action broadcasts a message containing the values of its local variables. A process remains in this phase until it has succeeded in sending this message and has received the corresponding messages from the other processes involved in the action. It then goes into the executing phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Executing:</head><p>A process in the executing phase has sufficient information about the local states of all processes involved in the selected action to execute its own part of the joint transaction, i.e., to update its own local variables in the required manner. It. does this as explained above, i.e., by executing a copy of the action body, using the values of the local variables of the other processes that it received in the previous phase. After this it returns to the ready phase, resets all entries in its allocation table to empty, and the cycle starts all over again.</p><p>The efficiency of the implementation can be measured in terms of the number of messages it, requires. At least n messages must be sent for each executed action, where n is the number of processes involved in the action, as each process must at least announce its willingness to participate in subsequent actions. Our implementation requires 2n + 1 messages for each executed action with n participating processes. This number can be reduced by sending a local state message only if this state is actually needed by some other process. If no transfer of information is needed, but only synchronization, then n + 1 messages are sufficient to schedule an action.</p><p>When a process selects a private action, its willingness and selection messages may seem superfluous. They are, however, necessary if one wants to guarantee a fair treatment of handshakes.</p><p>Actually, the number of messages required for each action could be reduced to n + 1 by including the values of the local variables in the willingness message of a process. This, however, would require that all processors listen continually to all messages sent over the network, and would also require more storage at processor nodes. The implementation above has the advantage that no communication overhead is associated with the execution phase.</p><p>An essential assumption in this implementation is that a process can cancel its attempt to transmit a select, message when another select message is received. Although s'uch an interconnection is not required to exist between the transmit and receive parts of the data link layer of local area network implementations <ref type="bibr" target="#b12">[13]</ref>, it seems reasonable that such a mechanism could be implemented without violating the existing standards. Alternative implementations of multiprocess handshaking that do not require this facility are described in <ref type="bibr" target="#b2">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Correctness of Implementation</head><p>In analyzing the correctness of the above implementation we first have to determine a unique simulation mapping of the sequence of broadcasting events in the implementation to computations in the concurrent execution model. We say that a sequence of broadcasting events simulates a concurrent computation, if each sequence of broadcasting events is mapped into some initial part of a computation, such that the mapping is monotonic with respect to the prefix Notice the asymmetry that, although each sequence in B has to simulate a sequence in C, all infinite sequences in C need not be simulated. In the case of the above implementation, B consists of all possible complete message sequences in the implementation of an action system S, while C is the set of all (fair) concurrent computation sequences in Cons(P, A).</p><p>There is considerable freedom in determining the simulation mapping for an implementation.</p><p>This freedom can be used to avoid unfair computations being simulated. With this in mind we choose the simulation mapping for our implementation as follows. Each select message is associated with the corresponding handshake transition, and each willingness message is associated with a release transition. The ordering of the transitions is determined by the order in which the willingness messages are broadcast. The mutual ordering of the releases is the same as that of the corresponding willingness messages. A handshake transition is, however, placed where the actual decision leading to the select message takes place, i.e., immediately after the willingness message of the last process to become free for the action, which is not necessarily at the place where the select message for the action was sent. Hence, the ordering of the handshake transitions, with respect to release transitions and other handshake transitions, is not necessarily the same as the ordering of the select messages with respect to the willingness messages and to the other select messages. The reason for this choice has to do with fairness, and will be made clear below.</p><p>No assumptions are made about the relative speeds of the processes. It is essential, however, that each processor be sufficiently fast, so that no relevant message is lost before being processed.</p><p>The fairness properties of the implementation depend on the assumptions that can be made of the communication channel. In the following it is essential that a process that infinitely often tries to transmit will also infinitely often succeed. Since collisions are resolved by random waits, this condition is met with probability one when a process is continually trying to send a message. This is the case with all willingness and local state messages.</p><p>Another kind of situation arises when a process tries to send a selection message as a response to some willingness message. The decision to send a selection requires inspection of the allocation table, and several processes might be simultaneously making competing decisions that exclude each other. In order to give each process a fair chance in this competition, a random wait should be inserted between the decision and the sending of the select message. Such a wait is automatically included if the p-persistent carrier sense protocol <ref type="bibr" target="#b37">[37]</ref> is used with 0 &lt;p &lt; 1. With this technique the required condition is met with probability one also in the case of select messages.</p><p>Let us now define the simulation mapping y of this implementation more precisely. Let b be a message sequence containing a willingness message w,, by process p. Consider the situation that w, announces the willingness of p to participate in an action a such that all other processes in Proc, have announced their willingness in a already before p. There are now three possibilities: (i) If a is selected (on the basis of this w,,) in b, then w, is said to be satisfied by a in b;</p><p>(ii) if w, is not satisfied by a, but each prefix of b containing w, has an extension where this is the case, then w, is said to be open in b; (iii) otherwise the selection of some other action precludes the possibility of selecting a (on the basis of this wP).</p><p>Restricting LEMMA 1. The implementation of the action system S given in the preceding section simulates the concurrent execution model Cons(Proc, 0), provided that the processors are sufficiently fast to handle each message in time.</p><p>PROOF. First we check that each finite computation sequence c E Cons(Proc, 0) is simulated by some message sequence b. Such a b is obviously obtained from c if we replace each relp by an appropriate willingness message, and each hs, by the corresponding selection and local state messages. The monotonicity of y is clear, as it was constructed as the combination of two monotonic mappings. What remains to be shown is that each complete message sequence is mapped into a computation that is complete and fair with respect to each process p E Proc.</p><p>A finite complete message sequence b must contain a last willingness message w, for each p E Proc. This can neither be open nor satisfied. This means that no action is enabled after b, and r(b) is then a finite and properly ending computation.</p><p>For an infinite message sequence b we first notice that none of its willingness messages can be open for any actions a. Otherwise the oldest process in hoc, would continually try to send a selection message for a and would eventually succeed with probability one. This implies that y(b) must also be infinite. It remains to be shown that such a y(b) belongs, in fact, to Cons (Proc, 0), i.e., y(b) is fair with respect to each process p in Proc.</p><p>Suppose that an infinite r(b) is not process fair, and let Proc' C Proc be the (maximal) set of processes treated unfairly. There is then a prefix of b after which no process p E Proc' is transmitting any more. The last message of each p E Proc ' is a willingness message; let p,, be the oldest of these processes. Because of unfairness with respect to po, there is an action a such that p. E Proc,, and all processes p E Proc, are infinitely often in a state where they are simultaneously free and have all indicated their willingness to participate in a. Since p. is the oldest in Proc', and it eventually becomes older than any other process in Proc,, it will infinitely often record all willingness messages and is therefore infinitely often trying to send a select message. This will succeed with probability one, which leads to contradiction. Hence, y(b) must be fair with respect to all processes p E Proc. 0</p><p>No assumptions were made in the protocol as to which select message is sent by a process when several alternatives exist. If an alternative is infinitely often possible, then a fair decision must also choose it infinitely often. Using random choice this can be achieved with probability one. Next we shall show that our implementation is handshake fair if all decisions are fair.</p><p>Suppose that a computation is not handshake fair with respect to an action a E Act, and consider the suffix of the computation where a is no longer executed. It is now infinitely often the case that all processes p E Proc, are free to participate in a and have also indicated their willingness to do this. Some process p. must also infinitely often be oldest among them. A fair decision bypo will now infinitely often choose a, leading to a contradiction. Hence, we conclude that the implementation with fair decisions ensures handshake fairness.</p><p>The reason for associating the handshake transition with the moment of decision and not with the moment when the actual select message is sent has to do with the fairness requirements. It is possible that the process p. above, when a specific willingness message is broadcast, already has made a decision to select some action a on the basis of some earlier willingness message, although it has not yet succeeded in sending the select message. The willingness message arriving after the decision has been made but before the select message is sent may then seemingly enable some new action a' (involving processes in the selected action) that p. cannot consider anymore. The way in which the simulation mapping was defined does not, however, consider this to be unfair, since the handshake transition hs,, is not considered to be enabled in such a situation.</p><p>Since the original actions may be split in the implementation to make the guards simple, we finally check that fair decisions also ensure handshake fairness with respect to the original actions. This is obviously the case, since handshake fairness with respect to the split actions is a stronger requirement than handshake fairness with respect to the original actions.</p><p>LEMMA 2. The above implementation of action systems is process fair and, if the select decisions in the processes are fair, then the implementation is also handshake fair.</p><p>We can summarize the results of this section in the following theorem.</p><p>THEOREM 1. The implementation of an action system S of Section 3.3 simulates the concurrent execution model Cons(P, A) (up to probability one), when the choice between actions in A is carried out by the processes in a fair manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">FAIR SERIALIZABILITY</head><p>In this section we study the relationship between the two models for execution of an action system, the sequential execution model of Section 2 and the concurrent execution model of Section 3. Our aim is to find out to what extent the sequential execution model is valid as a basis for reasoning about properties of the action system, when the computation is, in fact, done according to the concurrent execution model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Serialization of Computations</head><p>In order to relate the sequential and the concurrent execution models to each other, we first define the serialization of a concurrent computation c, h tz c:u~'fJ~~ *** ui--lti_ai --*. This is the sequence c' that is obtained by replacing each handshake transition ti = h.s, in c by the corresponding action transition act,, by omitting all release transitions ti = rel, together with their associated states ci, and by deleting the state component free from the remaining states.</p><p>In the sequel, we will talk about a sequential computation of an action system S, when we mean a computation in the sequential execution model Seqs(O), i.e., no action fairness assumptions are made for the computation.</p><p>Similarly, a concurrent computation of an action system S is a computation in the concurrent model Cons(0, 0) for which no process or handshake fairness assumptions are made. Whenever fairness assumptions are made for a computation, these will be explicitly stated.</p><p>Serialization is a simulation mapping from the set of concurrent executions of an action system S to the set of sequential executions of S. Actually, an even stronger result holds, which says that each sequential execution is simulated by some concurrent execution, if fairness requirements are not considered. More precisely, we have the following result. LEMMA 3. Let S be an action system. Then (i) the serialization of a concurrent computation of S is a sequential computation of S, and (ii) each sequential computation of S is the serialization of some concurrent computation of S.</p><p>The proof of this lemma is straightforward given the definitions, and is therefore omitted here.</p><p>Action fairness is not a fairness property in the concurrent model. We can, however, define a requirement on computations in the concurrent model that corresponds to action fairness in the sequential model. We say that a concurrent computation c is action fair for action a, if the following condition is satisfied: if ga(ya) holds infinitely often in c, then transition hs, is taken infinitely often. The following is an immediate consequence of the definitions. LEMMA 4. A concurrent computation of an action system S is action fair for a if and only if its serialization is action fair for a.</p><p>We write .w',F(a) to denote that each computation c of S is action fair with respect to a, and xY~ if &amp;F(a) holds for each a E Act. Similarly, we write X'F(a) and 2?Y in the case of handshake fairness. We write 99(p) to denote that each computation of S is process fair for process p and 9% if 99(p) holds for each p E Proc.</p><p>Let us say that a temporal logic formula R is insensitive to stuttering, if the following holds: R holds for a computation sequence c if and only if R holds for any computation sequence c' that can be constructed from c by adding or deleting a finite number of stuttering transitions. A stuttering transition is a transition that does not change the state (i.e., an identity function). A temporal logic formula that only uses the eventuality and always operators (and specifically does not use the next state operator) is an example of a formula that is insensitive to stuttering.</p><p>The concurrent execution model is a faithful implementation of the sequential execution model, as far as observation of changes in the state y are concerned. In fact, apart from possible observations of stuttering, any temporal logic property that holds for all the sequential executions of an action system will also hold for all concurrent executions, provided that the same action fairness assumptions hold.</p><p>THEOREM 2. Any temporal property that holds in the sequential model Seqs(A) of an action system S and that is insensitive to stuttering, will also hold in the concurrent model Cons(0, 0), provided that MF(a) holds for each a E A. The converse is true if the temporal property does not refer to the state component free.</p><p>PROOF. Let c be a concurrent computation in Cons(0, 0) and let c' be the serialization of c. By Lemma 4, c is action fair for each action in A if and only if c' is action fair for each action in A. Let R be a temporal property that is insensitive to stuttering. Then R will be true for computation c if and only if R holds for the sequence of states u = uo, cl, . . . , generated by the computation c. This is the case if and only if R holds for the sequence of states O* that we get from u by dropping the state component free from all states, because R can only refer to variables in the state component y. This in turn is equivalent to R being true for the sequence of states u' that we get from CT* by dropping all repetitions of states in the sequence, because R is assumed to be insensitive to stuttering. This finally holds if and only if R is true for the computation sequence c', as u' is the sequence of states generated by the computation c '.</p><p>In conclusion, R holds for a sequential computation c' that is fair for actions A if and only if it holds for every concurrent computation c of which it is a FL J. R. Back and R. Kurki-Suonio serialization and that is fair for the actions A. The required conclusion now follows by <ref type="bibr">Lemma 3. c3</ref> The two models are thus otherwise equivalent, but their fairness notions are different. The natural fairness notion in the serial model is not a proper fairness notion in the concurrent model, and it leads to stronger requirements than it seems possible to enforce in distributed implementations.</p><p>The relationships between the three notions of fairness are as follows:</p><p>THEOREM 3. Let S be some action system, and let a be an action in 5'. Then PROOF. For part (i) consider any concurrent computation c that is not R'F(a). Transition he, is then enabled infinitely often in a suffix of c without being executed. This implies also that g, holds infinitely often and, hence, c is not &amp;Y(a).</p><p>For part (ii), if c is a concurrent computation that is not 9F(p), then there must be an action a E Act, such that h.s, is infinitely often enabled but never executed in a suffix of c, which means that c is not ZK Part (iii) is demonstrated by examples. For part (i) consider the possibility for starvation in the concurrent execution of the action system in Example 1. For part (ii), the action system of Example 3 allows concurrent computations where all philosophers eat infinitely often but none of the reserve actions are ever executed. These computations are obviously .c?JF but not 2; q</p><p>The problem is that these implications hold in the wrong direction. What we actually need is that those fairness notions that can be guaranteed in a distributed implementation (i.e., process fairness and handshake fairness) imply the fairness notion that we want to use in reasoning about action systems, i.e., action fairness. This, however, is not true in general, as shown by the theorem.</p><p>Different solutions are possible to this problem. One solution is to accept some form of centralized scheduling, and in this way build implementations with stronger fairness properties, such that action fairness can be guaranteed. Another solution is to abandon the sequential execution model, and use the concurrent execution model instead, together with the fairness notions provided with this model. Either way, we would give up something quite important, either the distributedness of our communication mechanism or the ease of reasoning that the sequential model gives us.</p><p>We will here consider a third solution to this problem. We will try to identify those classes of action systems for which handshake or process fairness are sufficient to guarantee action fairness in the concurrent model. More formally, let us say that an action system S is fairly serializable for an action a E Act, if &amp;9(a) holds in the concurrent execution model Cons(P, A).</p><p>Fair serializability of an action system will be a consequence of the specific way in which the actions interact with each other. In essence, it means that there is some mechanism in the system that prevents unfair executions from occurring.</p><p>Thus, given a specific action system, we may either prove that the action system is fairly serializable for the set of actions for which we need action fairness or, if this is not the case, we might try to transform the action system to another one, which in all important aspects is similar to the original one, but which is also fairly serializable. In the latter case, we are essentially building a scheduling mechanism into the action system, to guarantee the kind of action fairness we want.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Static Conditions for Serializability</head><p>There are three related phenomena that can prevent process fairness from ensuring handshake fairness or action fairness, or prevent handshake fairness from ensuring action fairness in the concurrent execution model. These will be termed competition, omission, and conspiracy. We will in the sequel characterize these phenomena formally, and give conditions that guarantee that they cannot occur. We consider the possibility for these phenomena at two different levels, static and dynamic. The static level is concerned with membership properties of the sets hoc, and with predicates concerning effects of single actions in the space of all states 2,. Predicates about the possible execution sequences of actions belong to the dynamic level and involve temporal analysis. Here we shall consider the static possibilities for competition, omission, and conspiracy. The results are extended to the dynamic level in the next subsection.</p><p>Let us first introduce some notations. Two actions exclude each other, i.e., cannot be executed simultaneously, if they have some process in common. The set of actions excluded by an action a E Act is denoted Exclude, = (b E Act 1 a # b, Proc, n Proc,, # 0). Within this syntactically determinable set we define the subsets consisting of actions that may compete with a, enable a, disable a, or keep a enabled: Competition. By competition we understand the possibility that several actions are simultaneously enabled and compete for overlapping sets of processes. Absence of competition for an action is a strong requirement, implying that the processes involved in the action have no other alternatives. In Example 1 it is the competing eating actions that cause problems; private thinking actions have no competition.</p><p>An action a E Act is defined to be statically competition safe, if Compete, = 0, i.e., if no other action is ever competing with a. We now have the following result.</p><p>LEMMA 5. 99 guarantees dF(a) for an action a E Act, if a is statically competition safe.</p><p>PROOF. Consider a suffix of a concurrent computation where g, holds infinitely often for a statically competition safe a, but hs, is never taken. Since g, can be turned false only by an action competing with a, g, will stay continually true. If some process p E Proc, is engaged in another action, it will eventually be released by rel,, after which competition safeness of a guarantees that p will stay free. All p E Proc, will thus eventually become free, and 99 then guarantees the execution of hs,, leading to a contradiction. 0</p><p>Omission. If an enabled action involves at least one process that has no alternative actions to choose from, then 99 with respect to this process guarantees that the action is not neglected forever. Omission is the phenomenon that, in the absence of such a process, an action is indefinitely neglected by giving systematically preference to some other actions occupying the same processes. In Example 3 the reserve actions have no such dedicated process and their omission is therefore possible.</p><p>An action a E Act is defined to be statically omission safe, if there is a process p E Proc, such that either p is not involved in any other action, i.e., Act, = (a), or none of the actions requiringp is competing with a, and a is also not disabled by any other action, i.e., Act, II Compete, = 0, and Disable, = 0.</p><p>We have the following result. LEMMA 6. 9TF guarantees XF(a) for an action a E Act, if a is statically omission safe.</p><p>PROOF. Consider a suffix of a concurrent computation where infinitely often g, is true and all p E Proc, are available for action a, but hs, is not taken. By definition, statical omission safeness of a implies the existence of a process p E Proc, for which the computation is not process fair. Cl Conspiracy. By conspiracy we understand the phenomenon that an action is prevented from execution by two or more other actions, each holding in turn some of the processes that the action needs, so that all the processes are never simultaneously available. Starvation of a philosopher in Example 1 is caused by a conspiracy of the eating actions of his two neighbors.</p><p>Let us consider static safeness conditions against conspiracy. Conspiratorial situations against an action a E Act involve an overlapped execution of a sequence of at least two actions, each holding some processes in Proc,. A finite or infinite sequence of actions [ = ( bl , b2, . . . ) for which such a behavior is possible has to satisfy the syntactic conditions bi E Exclude,, Proc, fl Proq p Procbi+l.</p><p>The latter condition states that it is possible for action bi to release all the processes that bi+, needs, before releasing some process which action a needs. Thus, action bi+l can start before action a becomes enabled. Such a sequence ,$ will be called a cover of a.</p><p>Consider now a situation where an action a E Act is forever prevented from execution by the conspiratorial behavior of other actions. Then each sequence of states where g, holds must be included in a cover of a. Two different situations arise, depending on whether g, holds continually or not.</p><p>First, if g, holds indefinitely from some point on, there must be an infinite cover. This has to contain elementary cyclic covers ,$ = (bl, . . . , bk, bl) consisting of k different actions, k L 2, that satisfy the static conditions bi E Keep,, i = 1, . . . , k.</p><p>Such a finite cover is called a conspiratorial cycle against a.</p><p>Secondly, if g, is infinitely often turned on and off, then each interval when g, is enabled must be included in a finite cover. The last action bk of such a cover turns g, off; it is turned on either by the first action bl of the cover or by an action b0 that starts between bI and bz but is not part of the cover. This leads to the definition of a conspiratorial chain [ = (b,, bI, . . . , bk), k 2 2, against a as a sequence where (bI, . . . , bk) is a cover of a not containing internal cycles, b. = bl or Proc, n Procq g Proq,, and the following static conditions are satisfied:</p><formula xml:id="formula_2">b. E Enable,, bi E Keep,, 1 &lt; i c k, bk E Disable,.</formula><p>An action a E Act is defined to be statically conspiracy safe, if there is no conspiratorial cycle or conspiratorial chain against a.</p><p>The following lemma follows from the above analysis of conspiracy situations. Obviously static competition safeness is stronger than the two other properties, implying both static omission safeness and static conspiracy safeness.</p><p>Example 4. We show how static competition or conspiracy safeness could be imposed on the eating actions in Example 1. Let us attach a new variable to each fork, indicating a "left" or a "right" fork. If eating is allowed only with the proper forks in both hands, and the two forks are always exchanged after eating, the system is obviously competition safe. Hence process fairness guarantees that action fairness holds for the eating actions, by Lemma 5. This means that all actions are treated fairly in the system.</p><p>The sequential model with d&amp;r can then be used to prove that starvation is not possible, unless all forks are of the same kind. This property is not sensitive to stuttering. Hence, by Theorem 2, if this property holds in the sequential execution model assuming action fairness for all actions, it will also hold in the concurrent execution model, when the assumption of action fairness is satisfied. Hence process fairness is sufficient to guarantee that starvation is not possible.</p><p>The static criteria for competition, omission, and conspiracy safeness are quite strong, and there are many situations in which they would not be applicable. These criteria are therefore to be taken as a first check, by which one identifies those cases for which more refined methods are required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Temporal Conditions for Fair Serializability</head><p>The discussion in the previous section suggests that static conditions for serializability are too strong to handle all cases that can occur in practice. We therefore proceed to extend the static analysis to a temporal or dynamic analysis of action systems. While static safeness conditions ensure that certain unwanted situations cannot possibly arise, the dynamic conditions state that they do not actually occur in system executions.</p><p>The temporal expressions for our dynamic conditions will be liveness properties in reduced action systems where some of the original actions are omitted. Let S = (Proc, Act, Var, hit, Actions) be an action system. We define the reduction of S by actions A C Act to be the action system S/A = (Proc, Act -A, Var, 0, Actions') where Actions' is constructed from Actions by deleting the actions in A. Note that there are no initialization statements in the reduced system, so all processes start with arbitrary values for their local variables. (Actually, the initial values of the process variables will in the sequel always be restricted by some additional initial condition that is imposed on the reduced action system.)</p><p>We modify some of the definitions to cover collections of actions instead of single actions. For an arbitrary set of actions A C Act, we write gA for the disjunction V&amp;A &amp;. We also extend &amp;F(a) and <ref type="bibr">29(a)</ref> to cover sets of actions. By &amp;F(A) we understand that some action in A is executed infinitely often if gA holds infinitely often. Similarly, &amp;"sr(A) means that some action in A is executed infinitely often, if some transition in (hs, 1 a E A] is infinitely often enabled.</p><p>Notice that RZ'F (A) and X'F (A ) do not imply .Q?F (a) or 2'9 (a) for any single action a E A. The converse does, however, hold. More generally, we have that &amp;F(A) and &amp;9(B) implies &amp;F(A U B), and similarly for handshake fairness.</p><p>Competition. Consider a situation where actions A G Act are not executed from some point on, although &amp; holds infinitely often. Assuming 9.9-it must then be the case that some competing action b 66 A is executed infinitely often instead. This kind of competition is not possible, if &amp; A &amp;a eventually becomes and remains false unless some action in A is executed.</p><p>More formally, a set of actions A C Act is competition safe in action system S, if there is an invariant I of S such that the implication q ogA =$ ool(&amp;?a PROOF. Similar to Lemma 5, where competition was prevented once and for all, except that competition is permitted here, but is guaranteed to stop eventually. Cl Omission. Consider a collection of actions A _C Act with a common process p E Proc, and let B denote its complement in Act,, A U B = Act,, A r3 B = 0. The set of actions A is omission safe by process p in action system S, if there is an invariant I of S such that the implication holds in the reduction S\A with initial condition I, when MY(B) is assumed. More generally, a collection of actions A C_ Act is defined to be omission safe if it is a union A = UAi where each Ai is omission safe by some process p.</p><p>We now have the following result.</p><p>LEMMA 9. 99 guarantees R'T(A) for a set of actions A C_ Act, if A is omission safe.</p><p>If A is competition safe, then A rl Act, is omission safe for all processes p involved in A. This shows that competition safeness implies omission safeness also in the dynamic case.</p><p>Conspiracy. Extending the static conditions for conspiracy safeness to the dynamic case means, in fact, that the existentially quantified state y in the definitions of the enabling, disabling, and keeping predicates is replaced by the current state:</p><formula xml:id="formula_3">Enabkdy) = ib E EnabkI&amp;?b(y) A -%(Y) A &amp;(fb(Y))h Dkabk(y) = (b E Dkzbh igb(Y) A &amp;(Y) A lga(fdy))l, Keep&amp;) = Ib E Kee&amp; igb(Y) A &amp;l(Y) A &amp;(fb(Y))i.</formula><p>In order for a cyclic cover t = (bl, . . , , bk, bl) to cause conspiracy against a, the condition bi E Keep,(y) must then hold for the current state y when bi is about to participate in the conspiracy. Let this condition, for an arbitrary conspiratorial cycle ,$ against a, be denoted by (PE,i, Let A ' G A be a subset for which dog* * w&amp;4') holds in the reduction S\A with initial condition I, for some invariant I of S. To prevent conspiracy against the actions A it is then obviously sufficient to prevent conspiracy against the subset A '. Such a subset A ' is called a core of A.</p><p>A set of actions A G Act is now defined to be conspiracy safe in action system S if there is a core A ' of A such that for each conspiratorial cycle or chain [ against a E A ' with actions bi 4 A there is at least one condition Ps,i which will eventually become and stay false, if a is infinitely often enabled. This means that for a conspiratorial cycle the condition must hold in the reduction S\A with initial condition I, when dF(b) is assumed for each action b E [. For each conspiratorial chain the condition q Oga + OOlQ,,i must hold in the reduction S\A with initial condition I, when &amp;F(b) is assumed for each action b E t. As before, I is here some invariant of S. We now have the following result. LEMMA 10. XF(A) for a set of actions A C Act guarantees .LYF(A), provided that A is conspiracy safe.</p><p>Competition safeness of A implies that both Keep,(y) -A and Di.sable,( y) -A will eventually stay empty for all a E A, if g, holds infinitely often without any action in A being executed. Therefore competition safeness implies conspiracy safeness also in the dynamic case.</p><p>We summarize the results of Sections 4.2 and 4.3 in the following theorem.</p><p>THEOREM 4. Let S be an action system. Then (i) 9'F guarantees &amp;F(A) for a set of actions A C Act in S, if A is competition safe, (ii) 92T guarantees XF(A) for a set of actions A C Act in S, if A is omission safe, (iii) S?F(A) for a set of actions A C Act guarantees .wfF(A), provided that A is conspiracy safe.</p><p>Although the conditions in this theorem are sufficient but not necessary, they seem to provide reasonably powerful criteria for proofs of fair serializability. The relationship between the fairness notions studied in this section are shown in Figure <ref type="figure" target="#fig_18">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PROVING PROPERTIES OF CONCURRENT EXECUTIONS</head><p>Let us now consider how to prove temporal properties of concurrent executions of action systems. Our aim is to be able to prove that an actual distributed execution of an action system has some desired property. Proving this would basically require that we argue about the properties in terms of an implementation of the action system, using for instance the implementation on local area networks given in Section 3. This, however, would be very tedious, and we prefer to prove properties with respect to the execution models that we have given for action systems. In particular, we would like to use the sequential model, because this is simpler and easier to reason about. Below we will tie together the results of the preceding section and show how to prove properties that hold for the concurrent model, by proving corresponding properties for the sequential execution model. We will also discuss more carefully how properties that hold for the concurrent execution model can be interpreted as properties of an actual distributed execution of an action system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Proving Liveness Properties</head><p>Assume that we have an implementation of an action system S that guarantees process fairness for all processes, and handshake fairness for some actions A in Act. We want to prove that some temporal property R is satisfied by each concurrent execution of the execution system that is 99 and %9-(a), a E A. Assume that the property R is insensitive to stuttering. We may now proceed as follows.</p><p>(i) We first prove that the property R holds for each sequential execution of S, assuming dT(A') for some sets of actions A' in Act. (ii) We then prove that each .w'F(A') condition holds for concurrent executions of S, assuming 99 and ZF(a), a E A.</p><p>Let us consider both these steps in more detail.</p><p>From step (i) it follows by Theorem 2 that property R will also hold for each concurrent execution of S for which the conditions &amp;F(A') hold. Hence if we can prove step (ii), then R will obviously hold for each concurrent execution of S that is 9F and ZF(A), a E A.</p><p>Consider now step (ii). Action fairness can be established using the results of the previous section. Initially, we start with some collection of action fairness obligations MF(Al), . . . , HF(A,), that we need to establish. By the results of the preceding section we may establish these fairness properties by proving that ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,19&amp;I</p><p>the action system has certain safeness properties:</p><p>(1) A fairness obligation sx?F(A') is established directly, if we can prove competition safeness for this set of actions. (2) We can reduce a fairness obligation dF(A') to a fairness obligation 2F"F(A'), if we can prove conspiracy safeness for this set of actions.</p><p>(3) A fairness obligation J?'F(A') can be established directly, by proving omission safeness for this set of actions.</p><p>The second step is established, if by using these rules we can reduce the fairness obligations to those handshake fairness assumptions that we may assume for the implementation, i.e., 29(a), for each a E A. These rules may be applied directly to the sets Ai, or we might partition these sets into smaller sets, and prove fairness assumptions separately for each of these smaller sets. (This latter approach is further elaborated in <ref type="bibr" target="#b6">[8]</ref>.)</p><p>Static competition, omission, and conspiracy safeness are expressed as properties in ordinary first-order calculus. Dynamic competition, omission and conspiracy safeness are expressed as temporal logic properties of the concurrent execution model. In the latter case we have to show that some temporal property Q holds for each concurrent execution of the reduced system S\AI, assuming &amp;F(C) for the reduction, for some sets of actions Ai and C in Act. The property Q is in all these cases insensitive to stuttering and makes no reference to variables free in the concurrent model. Hence, Q will hold in each concurrent execution of S\A( assuming &amp;F(C), if and only if it holds in each sequential execution of S\A i assuming &amp;F(C).</p><p>Thus, to establish the required temporal properties, we need only to consider sequential executions of action systems.</p><p>If the property Q cannot be established for the reduced system S/A{, even if &amp;F(C) is assumed, then we may repeat the above proof procedure, but now applied to the system S\AI with MY(C) and X9-(a), a E A. The sequence of reductions must eventually terminate, as at least one action is removed from the system in each reduction.</p><p>In conclusion, by using the safeness notions and the notion of action fairness, we are able to establish that some desired property holds for any concurrent execution of an action system S by only reasoning about temporal properties of sequential executions of S. We have thus achieved the goal that we set ourselves in the introduction.</p><p>Example 5. We apply the above proof method to the dining philosophers program of Example 3. We want to show that individual starvation cannot occur in a concurrent execution of the example program, if each execution is process fair. Thus we want to show that for each i = 1, . . . , n. q (hungry~ * O+zung?y~)</p><p>(1)</p><p>By the proof method above, we divide the proof into two steps:</p><p>(i) We first prove (in the sequential execution model) that (1) holds, assuming action fairness for all eating actions.</p><p>(ii) We then show that action fairness holds for all eating actions, assuming only process fairness.</p><p>Part (i) of the proof has already been established in Section 2.2. Hence it only remains to show part (ii), that the action system is fair for all eating actions.</p><p>Omission safeness. We show first that Eating[i] is omission safe. This will be guaranteed by the process Philosopher We have to show that I A q Og, + OoTgB holds in the reduced system, with EutingIi] removed, assuming action fairness for (Reserue[i], Thinking <ref type="bibr">[i]</ref>). This amounts to showing that, if hungryi holds infinitely often in the reduced system, then eventually reserve&amp; will become true. This is obviously the case when action Reserue[i] is treated fairly. Conspiracy safeness. Action fairness is now guaranteed if we can show that (Eating[i]j is conspiracy safe. This can be done by showing that hungryi eventually implies both tokeni and reserved; in this reduced system.</p><p>We use well-founded ranking to establish this. We select a mapping f(y) = (m, b) of system states y into a set W, W = (0, . . . , n -1) X (true, false), such that m is the smallest integer for which tokeni-, = true and b is the value of reservedi-,. The existence of m is ensured by the invariant proved in Section 2.2, which states that there is always exactly one fork with an associated token. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The action Reserve[i + l] disables action Eating[i] only if hungryi A hungry+, A lreservedi+l</head><p>A tolzeni+l. Assume that the enabling condition for action Eating[i] holds in the reduced system, i.e., hungry A (lreservedi+l V ltokeni+l). If tokeni+ = false, then this will hold forever, as it can only be set to true by the removed action Eating <ref type="bibr">[i]</ref>. If tokeni+ = true, then we have two cases. Either the condition hungryi+ does not hold infinitely often, in which case the condition lhungvi+l will eventually hold forever, or hungry+, does hold infinitely often. In the latter case action Eating[i + l] will be infinitely often enabled, so by the fairness assumption it will eventually be executed. Once executed, it will set tokeni+l = false, which thereafter will stay false forever. In all these cases one of the conditions required for the action Reserue This concludes our proof that the action system of Example 3 is action fair for each eating action, and hence, by combining this result with the result of Section 2.2, that the action system avoids starvation of the philosophers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Interpretation of Correctness Proofs</head><p>The effect of an action a E Act, i.e., the updating of the variables of the participating processes, is associated with the handshake transition hs, in the concurrent model. All local variables are considered to be immediately updated when the decision to execute action a is made. The fact that updating the local variables in a process p takes time is modeled by the interval from handshake hs, to the releases rel,, p E Proc,. Since this does not directly correspond to the behavior of a real implementation, the validity of the model requires some justification.</p><p>To make things more concrete, let us consider an action system with two actions, Act = ja, b}, and three processes, Proc = (pl, p2, p3). Each process pi has one local Boolean variable yi. The actions are defined by action a byp,, pz: A possible sequence of events in a real implementation is given in Table <ref type="table">I</ref>. The question marks indicate situations where the value of a variable is not known for certain, because an update is in progress.</p><p>Handshakes and releases in Table <ref type="table">I</ref>  This presents us with a problem of how to interpret properties that we have proved to hold for a concurrent execution of an action system. Consider the property q ( y1 = y2), which can be proved to hold for this action system. In a real execution, when action a is executed, either p1 or p2 would update its local variable before the other, thus temporarily destroying this invariant. Similarly a liveness property like 0 ( y1 = y2 = y3), which can be proved to hold in the action system, might never actually hold in a real execution of the action system.</p><p>What should be the truth of an assertion about the global state, when some program variables are in the middle of being updated? It is not satisfactory to say that the assertion is only defined when all variables in it have a well-defined value. In a real execution of an action system there need not be a single moment of time (except for the initial and final states) when all program variables have well-defined values. This is a consequence of the parallelism in execution. Still, we would like to say that any execution of the action system in some real and observable way does have the safety or liveness property that we have proved for the concurrent execution model.</p><p>In our description of the behavior of a real system above we have assumed a universal time that determines a complete ordering of events. There need not, however, exist any means to determine this ordering by observing the system. For observations one could assume a relativistic notion of time where no other timing constraints are present except those determined by the handshakes <ref type="bibr" target="#b30">[30]</ref>. Any sequence of observations that is not in conflict with this partial ordering is then possible. A model of execution, such as our concurrent model, would be considered valid if any sequence of global states generated by the model is consistent with these constraints.</p><p>The concept of a global state is, however, obscured if the relativistic notion of time is adopted in the way suggested above. Although the sequence of global states in the model is not in conflict with what might be observed of the real system, it need not agree with any particular observations either. It can be questioned whether reasoning with such a global state has any relevance. In other words, if we prove that some safety property holds throughout the execution in the concurrent model, this would only say to us that even if this property is not true of our present observation of the system, there is some other way of observing the system, in which the property does hold. To make some inference about the actual behavior of the system it seems reasonable to require that the sequence of states in the model will also be observed in the real execution of the action system.</p><p>We will therefore propose another approach to this problem: We specify the way in which one should observe the system, so that one sees a sequence of global states that agrees with the sequence generated by the concurrent execution model. A possible arrangement for such observations is as follows. A request is broadcast simultaneously to all processes, asking them to give their local states. If not engaged in a transaction, a process replies immediately to the request; otherwise it delays the reply until the current action has been completed. The replies are collected to form a global state, which will correspond to a global state used in our model. The complete sequence of global states in the concurrent model is obtained, if this sampling of the global state is done frequently enough, and successive exact duplications of the global states are removed. Consequently, any property that holds in the concurrent execution model of an action system will also hold for the sequence of global states observed in this way of an actual execution of an action system.</p><p>It is worth noticing that the particular view of time we selected for the model has no effect on the fairness notions in the concurrent model, since no handshake transition can be enabled while any of the processes in question is involved in another action.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>The generalized handshake mechanism and our approach to describing system behavior in terms of joint actions was originally inspired by the Petri net approach to system modeling. If action guards are ignored, then the generalized handshake corresponds directly to the firing rule for transitions in Petri nets. An action system can be understood as a special kind of Petri net where each process is represented by a token, considered to carry the local variables of the process with it. The addition of guards to Petri nets has been proposed in <ref type="bibr" target="#b13">[14]</ref>. Also, the action system approach is quite close to the shared variable transition model for describing the behavior concurrent systems, as presented in <ref type="bibr" target="#b31">[31]</ref>. They are, in fact, identical for the sequential execution model. The main thing that distinguishes our approach from these is the requirement that the action guards be separable, and that these transition systems are to be executed in parallel in a distributed fashion.</p><p>The work reported here generalizes previous work in <ref type="bibr" target="#b3">[5]</ref>. There the notions of centralized and decentralized action systems were defined, but only the serial execution model was given. What we here call an action system corresponds to a decentralized action system in that paper. An implementation in CSP was given for the special case when each action involves at most two processes. Although the fairness questions of the implementation were ignored, this CSP implementation can easily be shown to be 99 or 29, depending on whether the implementation of CSP supports process or channnel fairness <ref type="bibr" target="#b29">[29]</ref>. The implementation given here is an improvement over the CSP implementation, as it is given directly for a local area network, thus avoiding the problem of finding an efficient implementation of CSP with output guards. The idea of synchronizing more than two processes by common handshakes has also been proposed by Francez and Hailpern in their work on scripts <ref type="bibr" target="#b21">[22]</ref>. These are primarily seen as higher level procedure-like mechanisms for organizing the cooperation of processes in a distributed system. It is also possible to achieve the effect of joint actions with the script mechanism. The mechanism is not, however, seen as a primitive communication mechanism, but is rather thought to be built on existing communication mechanisms, such as CSP or Ada handshaking. Proposals for synchronizing multiple processes that are somewhat similar to ours have also been proposed by Ramesh <ref type="bibr" target="#b34">[34]</ref> and Forman <ref type="bibr" target="#b19">[20]</ref>. A somewhat different approach to multiparty interaction is taken in [ 121.</p><p>Providing a distributed implementation of our mechanism is a generalization of the problem of giving a distributed implementation of CSP with output guards, which has been treated quite extensively in the literature (see <ref type="bibr">[2, lo]</ref> for a reference to work in this area). None of the implementations that we are aware of is based on using a shared broadcast channel. The implementation by Schneider <ref type="bibr" target="#b35">[35]</ref> seems to be closest to ours, as it also uses broadcasting, but the channel is not shared, and the necessary ordering of the messages is imposed by timestamps.</p><p>The notions of process fairness and handshake fairness are, in fact, the same as the process fairness and channel fairness that were introduced in <ref type="bibr" target="#b29">[29]</ref> in the context of CSP. The notion of action fairness, although quite natural in the case of a shared variable interpretation of action systems, does not seem to have been considered before in the context of distributed systems. It does not come up so naturally in connection with conventional approaches, as they lack higher-level notions for structuring process cooperation.</p><p>The validity of the sequential model with action fairness led us to the problem of fair serializability.</p><p>Comparing this with the analogous notion in database transactions we note that fair serializability has no effect on the result of the transactions, only on the fairness notion that can be supported. This notion was first proposed and studied in <ref type="bibr" target="#b5">[7]</ref>. It was subsequently applied by Grumberg, Francez, and Katz <ref type="bibr" target="#b22">[23]</ref> to study the fair termination problem of CSP programs. An alternative presentation of this basic idea is given in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr">Section 5.21</ref>. Another recent study on this topic is <ref type="bibr" target="#b1">[3]</ref>.</p><p>An important advantage of the action system approach is that it makes it easy to construct distributed programs by stepwise refinement. The action system approach was originally developed with this purpose in mind. The stepwise refinement method for action systems was originally described in <ref type="bibr" target="#b3">[5]</ref>. A later application of this method to the problem of removing virtual channels in a distributed program is described in <ref type="bibr" target="#b36">[36]</ref>. The action system approach is also very useful for a Dijkstra-style way of developing programs by incrementally adding invariants for a distributed system, and then giving actions that preserve these invariants, while simultaneously achieving some liveness conditions (see, e.g., <ref type="bibr" target="#b15">[16,</ref><ref type="bibr">171)</ref>. A case study of this approach, in the context of action systems, is described in <ref type="bibr" target="#b4">[6]</ref>.</p><p>An approach similar to action systems has recently been proposed by Chandy and Misra <ref type="bibr">[ll]</ref>. They also argue for the necessity to describe the overall behavior of a distributed system, rather than looking at the behavior of processes in the system individually.</p><p>The possible behaviors in their systems are described by guarded iteration statements, which, as we have shown above, are equivalent to the sequential execution model of action systems. They use this approach to program a distributed algorithm in a stepwise manner, similar to the way in which the distributed sorting algorithm is developed in <ref type="bibr" target="#b4">[6]</ref>. We think that this work provides additional support for the fruitfulness of the action system approach to the programming of the algorithmic behavior of a distributed system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>The main purpose of this paper has been to present and analyze the action system approach to constructing distributed systems. We have tried to show that this approach gives a good basis for describing the overall behavior of a distributed system, and that it fits nicely into the temporal logic framework for verifying safety and liveness properties. Our analysis of action systems was divided into three parts. First, we presented a simple sequential execution model for action systems, on which the temporal reasoning about action systems is based. The parallel execution is here modeled by sequential, nondeterministic execution, in a way similar to the sequential execution of guarded iteration statements. The notion of action fairness was introduced to allow proofs of liveness properties.</p><p>Next, we showed how to implement action systems in a distributed fashion. For this purpose we defined another execution model, the concurrent execution model, which corresponds to the way in which action systems are executed in the implementation.</p><p>The notions of handshake and process fairness were introduced in this model. We showed that action systems can be implemented efficiently on a broadcasting network, and that the required notions of process and action fairness can be guaranteed by this implementation.</p><p>In the last part we studied the relationship between the two models of execution. We showed that except for fairness, the two models are equivalent in the sense that any temporal property that can be proved to hold for each sequential execution of an action system will also hold for each concurrent execution of the action system. The handshake and process fairness notions guaranteed by the implementation are, however, weaker than the action fairness notion that we need in proving properties in the sequential execution model. We identified a class of action systems that we called fairly serializable, for which process or handshake fairness does imply action fairness. We have given proof rules by which fair serializability of action systems can be shown. By using these proof rules one can prove both safety and fairness properties for action systems within the simpler sequential execution model. Let us finally wind up with some problems that we find interesting and worth further study. One problem that the action system approach shares with other endogenous models of program behavior is the modularization of large systems. The strength of the process-based approaches, especially those based on communicating processes, is that they support a very nice, object-oriented way of constructing a large program from smaller parts. The problem of finding a good modularization mechanism for action systems is very similar to the corresponding problems for Prolog and production system languages such as OPS5, as well as for the modular construction of Petri nets.</p><p>The design of higher level control structures for action systems is also a topic worth further study. Sequencing is a good example of the need for such constructs: enforcing some actions to be executed in sequence requires unattractive manipulation of Boolean flags, which makes the program harder to understand and prove correct.</p><p>Distributed implementation of action systems on point-to-point networks forms another class of interesting problems. This application area is quite important, especially as the action system approach seems to be well suited to construct multiprocessor algorithms on loosely coupled MIMD machines. Some work in this area has been done in <ref type="bibr" target="#b17">[18]</ref> and more recently in <ref type="bibr">[9, 331.</ref> Another important topic has to do with efficient distributed execution of action bodies. The body should be partitioned among the processes in such a way that redundant computations are avoided.</p><p>Finally the problems involved in relating the sequential execution model to the true concurrency model seem important and well worth studying in more detail by using a more abstract model for true concurrency. Our results show that the simple interleaving model of communication, in which communication events are modeled by atomic actions that do not take any time, is insufficient as a way of modeling the real behavior of distributed systems. Especially when considering fairness properties, it is necessary to take into account that the communication events, even in the case of synchronous handshakes, do take time.</p><p>The methods for proving fair serializability that we described in Section 4 seem to provide a reasonably good collection of tools to tackle realistic problems. However, they do not necessarily provide a complete set of tools, and the proof method involved in using them can be quite cumbersome. A promising topic for research would be to extend these methods and build a special-purpose proof system by which the method of fair serializability could be used to establish properties of real distributed executions of action systems in a more rigorous fashion.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>action Thinking[i: 1 . . n] by Philosopher[i]: lPhilosopher[i].hungv -+ Think; Philosopher[i].hungv := true; Thinking[i]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Dining philosophers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 2 .</head><label>2</label><figDesc>We add to each fork process a local Boolean variable token, which is true when the fork has the token. The fork process is now process Fork[i: 1 . . . n]; var tohen : boolean; tohen := (i = 1); Initially, the token is at Forlz[l]. The eating action is changed to action Eating[i: 1 . . . n] by Philosopker[i], Fork[i], Fork[i + 11: PhiZosopher[i].hung~ A lFork[i + l].token + Eat; Philosopher[i].hungr := false; if Fork[i].token then Fork[i].token, Fork[i + l].tokeen := false, true;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>521 ( 3 )</head><label>5213</label><figDesc>pi-1, and ti(ui-1) = ui+ ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,1988.Distributed Cooperation with Action Systems l If finite, the computation is properly ending, i.e., no transition in T is enabled in the final state c,,. (4) If infinite, the computation is fair with respect to each fairness set F E F.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Dining philosophers with reserve actions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>process PhiZosopher[i : 1 . . n]; var hungry : boolean; hungry : = fakre;process Fork[i: 1 . . n]; var token, reserved: boolean; reserved := false; token := (i = 1);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>action Thinking[i: 1 . . n] by PhiZosopher[i]: lPhiZosopher[i].hungry + Think; Philosopher[i].hungry := true; action Reserve[i: 1 . . n] by Philosopher[i], Fork[i]: Philosopher[i].hungry A lFork[i].reserved + Fork[i].reserved := true; action Eating[i: 1 . . n] by Philosopher[i], Fork[i], Fork[i + 11: Philosopher[i].hungry A l(Fork[i + l].token A Fork[i + l].reserved) + Eat; Philosopher[i].hungry := false; if Fork[i].token then Fork[i].token, Fork[i + l].token := false, true; Fork[i].reserved := false;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Proof diagram for starvation freedom.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>where each disjunct is of the form &amp;ba) = pt!mc d,bLJ, D i.e., it is a conjunction of local guards gi,, ( yP) of the processes p involved in the action. A conjunction of this form is called a simple guard. An action a, action a by Proc,: g,(y,) + S,(y,)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>ACM Transactionson Programming Languages and Systems, Vol. 10, No. 4.1988.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Phases of implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>ordering of sequences, and if each completed sequence of broadcasting events is mapped to a (complete) computation. More generally, let B and C be sets of sequences, and let B* and C* denote the prefix closures of these sets. The function y : B* -+ C* is a simulation mapping if the following conditions hold: (i) y is monotonic, i.e., b 5 b' + r(b) 5 I, where 5 stands for the prefix ordering of sequences. (ii) For each finite sequence c E C* there is some finite b E B* such that r(b) = c. (iii) For each b E B, r(b) E C. B simulates C if there is a simulation mapping y : B* + C*.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>to message sequences b ' without open willingness messages, the transition sequence y ' (b ' ) is defined as the sequence obtained from b ' by replacing (1) each occurrence of a willingness message w,, that is satisfied by a in b by (2) every other willingness message w, by rel,, and (3) all other messages by the empty sequence E. The states in y ' (b ' ) are uniquely determined by the initial states and the sequence of transitions. Obviously, y ' is monotonic, and the construction of the implementation guarantees that y ' (b ' ) is a properly initialized and admissible computation sequence, whenever b' is some prefix of a message sequence generated by the implementation. For an arbitrary message sequence b E B*, let 4(b) be the maximal prefix of b with no open willingness message in b. The simulation mapping of the implementation is now defined as y(b) = y ' (4 (b)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>(i) &amp;F(a) in the concurrent execution model implies Z.-F(a), (ii) 29 implies 9% (iii) neither implication holds in the reverse direction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Compete, = (b E Exclude, I 3y E ZY: ga( y) A gb( y)), Enabk = lb E Exclude, I 3~ E 2,: gdy) A la(y) A ga(fdy))L Disable, = (b E Excludeal 3y E Zy: gdy) A gab) A xdfdy))), Keep, = Ib E Exclude, I 3~ E &amp;: gdy) A g,(y) A ga(fdy))l.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>LEMMA 7 .</head><label>7</label><figDesc>29(a)    for an action a E Act guarantees &amp;F(a), if a is statically conspiracy safe.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Starvation freedom is expressed by the property o(Philosopher[i].hungry =+ 01Philosopher[i].hungry).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>A gb) ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4.1988. holds for all a E A, b E Compete, -A in the reduction S\A with initial condition 1, when &amp;F(b) is assumed. We now have the following result. LEMMA 8. PFguarantees dF(A) for a set of actions A C Act, if A is competition safe.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Relationship between fairness notions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>[i]. The two sets of actions in the definition of omission safeness are in this case A = (Eating[i]], B = (Reserue[i], Thinking[i]J.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>Figure 6 shows all possible covers of the action Euting[i 1. In the figure, there is an arrow from action b to b ', if b, b ' E Exclude, and Proc, fl Procb $ ProcbT. We indicate whether an action can enable (E) or disable (D) action Euting[i]; all actions except Thinking[i] can keep it enabled. Analyzing these covers we see that any conspiratorial cycle must contain either Reserue[i] or Eating[i -11, and any conspiratorial chain must contain Reserue[i + l] and either Thinking[i] or Eating[i + 11. Let us first consider the conspiratorial cycles. We will prove that for any conspiratorial cycle (bl, bz, . . . , bk, bl), holds for some j in the reduction S\(Euting[i]) of S, with tiF(bj) assumed for j=l * * , lz. It is obviously sufficient to replace 'P,,j here by the guard of bj. After'what was shown above about Reserue[i], it now suffices to prove that the guard of Euting[i -l] will eventually turn false in the reduced system without action Euting[i].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>The well-founded ordering in W is defined as follows: (m, b) &gt; (m', b ' ), if m &gt; m', or if m = m ', b = f&amp;e and b ' = true. The least element in W is (0, true), and the required situation has been achieved when f(y) has this value. repeatedly enable the condition for action Eating[i] in the reduced system. Hence, no chain with action Thinking[i] can achieve conspiracy against Eating[i 1. Consider now a chain with actions Eating[i + l] and Reserue[i + 11.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>[i + l] to disable action Eating[i] eventually becomes false forever. Hence no chain with actions Eating[i + l] and Res[i + 11 can achieve conspiracy against Eating[i].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>Y1=yz--,y1,Y2:=1y1,1y2 action b by p2, p3: yz = y3 ---, y3 := 73.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head></head><label></label><figDesc>correspond roughly to the respective transitions in the concurrent execution model shown in Table II. In the concurrent model the local variables yi are immediately updated by the handshake transitions. In an actual implementation the updating is done sometime during the execution of the action body, and need not happen at the same time in different processes. As a result, properties like (yl = y3) could have different values in the concurrent model and in reality. In the model this expression is l FL J. FL Back and R. Kurki-Suonio Table I. Snapshots of the Real Operation of An Action System initiallyhs, and false by hsb; in a real execution it might as well be first turned true by p3 and then false by pl. Because of simultaneity it is not even clear whether any such changes could be seen in a real execution.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4.1988, Pages 513-554.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>ACM Transactionson Programming Languages and Systems, Vol. 10, No. 4,1988.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No.4,1988.   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>ACM Transactionson Programming Languages and Systems, Vol. 10, No. 4,19SS.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>l FL J. R. Back and R. Kurki-Suonio</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,19&amp;J.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>l R. J. R. Back and R. Kurki-Suonio</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_7"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,19&amp;3.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_8"><p>ACM Transactionson Programming Languages and Systems, Vol. 10, No. 4,19&amp;U.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_9"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,19SS.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_10"><p>R. J. Fi. Back and R. Kurki-Suonio</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_11"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No.4,198s.   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_12"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4.1988. Distributed Cooperation with Action Systems</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_13"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,198&amp;J.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_14"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4,198S.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_15"><p>ACM Transactionson Programming Languages and Systems, Vol. 10, No. 4,198&amp;3.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_16"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No. 4.1988.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_17"><p>ACM Transactionson Programming Languages and Systems, Vol. 10, No. 4,198fi.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_18"><p>ACM Transactions on Programming Languages and Systems, Vol. 10, No.4, 1988.   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_19"><p>R. J. R. Back and R. Kurki-Suonio</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We would like to thank the referees for their insightful comments on the paper. Discussions with Mats Aspnas, Luc Bouge, Nissim Francez, Eeva Hartikainen, Leslie Lamport, and Fred Schneider have also been very helpful.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Thus the situation where m = 0, and b = true will eventually be reached, provided that we have action fairness for all sets of helpful actions in the reduced system. Hence, we need to apply our fairness proof methods once again, but now for the reduced system in which action Euting <ref type="bibr">[i]</ref> has been removed. Thus, for case (i), we need to prove that the reduced action system, with initial condition m &gt; 0, and b = false, is action fair for (Euting[i -m], Reserue[i -ml), and similarly for the other cases.</p><p>In order to check this we first notice that each set of helpful actions is omission safe. Conspiracy safeness is straightforward in cases (ii) and (iii). In case (i) this can be shown by selecting (Reserue[i -m]) as the core of A.</p><p>Let us then consider the conspiratorial chains. The only actions that can enable Euting <ref type="bibr">[i]</ref> are Buting[i + l] and Z'hinlzing[i], and the only action that can disable it is Reserue[i + 11. Hence a conspiratorial chain must either contain Z'hinking <ref type="bibr">[i]</ref> and Reserue[i + l] or it must contain Euting[i + l] and Reserue[i + 11. We have to show that for each conspiratorial chain (bo, h, . . . , M, (1 A q 0gEating[i]) * ool(o.$,j for some j in the reduction S\ (Euting[i]) of S, with dF(bj ) assumed for j = 0, 1, . . . , k.</p><p>Consider first a chain with actions Thinking then hungryi holds infinitely often. This condition can only be turned off by the action Euting[i], once it starts to hold in the reduced system, so eventually it will hold forever. Consequently, the action Thinking[i] cannot</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Concepts and notations for concurrent programming</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Suru</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="43" />
			<date type="published" when="1983-03">March 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Appraising fairness in languages for distributed programming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th ACM Conference on Principles of Programming Languages</title>
		<meeting><address><addrLine>Munich; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987-01">Jan. 1987. 1987</date>
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multi-process handshaking on broadcasting networks</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hartikainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Reports in Computer Science</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<date type="published" when="1985">1985</date>
			<pubPlace>Abo Akademi, Abo, Finland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Decentralization of process nets with a centralized control</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second ACM SZGACT-SZGOPS Symposium on Principles of Distributed Computing</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983-08">Montreal, Aug. 1983. 1983</date>
			<biblScope unit="page" from="131" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A case study in constructing distributed algorithms: Distributed exchange sort</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Winter School on Theoretical Computer Science</title>
		<meeting>Winter School on Theoretical Computer Science<address><addrLine>Lammi, Finland</addrLine></address></meeting>
		<imprint>
			<publisher>Finnish Society of Information Processing Science</publisher>
			<date type="published" when="1984-01">Jan. 1984</date>
			<biblScope unit="page">33</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Co-operation in distributed systems using symmetric multi-process handshaking</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Reports in Computer Science</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<date type="published" when="1984">1984</date>
			<pubPlace>Abo Akademi, Abo, Finland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Serializability in distributed systems with handshaking</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Lepistii</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">317</biblScope>
			<biblScope unit="page" from="52" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">On the design of high performance distributed systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bagrodia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<pubPlace>Austin</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. of Texas</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An effective implementation for the generalized inputoutput construct of CSP</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Buckley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst. $</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="223" to="235" />
			<date type="published" when="1983-04">April 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An example of stepwise refinement of distributed programs: Quiscence detection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="326" to="343" />
			<date type="published" when="1986-07">July 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The multiway rendezvous</title>
		<author>
			<persName><forename type="first">A</forename><surname>Charlesworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="350" to="366" />
			<date type="published" when="1987-07">July 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">CSMA/CD Access Method and Physical Layer Specifications</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Standard</title>
		<imprint>
			<biblScope unit="volume">802</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1983-07">July 1983</date>
			<publisher>IEEE</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Superposed automata nets</title>
		<author>
			<persName><forename type="first">F</forename><surname>De Cindio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Michelis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Pomello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Simone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Application and Theory of Petri Nets</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Girault</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Reisig</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">52</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Invariance and nondeterminacy. In Mathematical Logic and Programming Languages</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<editor>C. A. R. Hoare and J. C. Shepherdson</editor>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Prentice-Hall</publisher>
			<biblScope unit="page" from="157" to="165" />
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On-the-fly garbage collection: An exercise in cooperation</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Scholten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="966" to="975" />
			<date type="published" when="1978-11">Nov. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Synchronizing multiple processes in common handshakes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Eklund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reports in Computer Science 39, Abo Akademi</title>
		<meeting><address><addrLine>Abo, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">OPS, a domain independent production system language</title>
		<author>
			<persName><forename type="first">C</forename><surname>Forgy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Dermot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fifth International Joint Conference on Artificial Intelligence</title>
		<meeting>Fifth International Joint Conference on Artificial Intelligence<address><addrLine>Cambridge, Mass</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1977-08">Aug. 1977. 1977</date>
			<biblScope unit="page" from="933" to="939" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Raddle, an informal introduction</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">R</forename><surname>Forman</surname></persName>
		</author>
		<idno>STP-182-85</idno>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
		<respStmt>
			<orgName>Microelectronics and Computer Technology Corp., Austin, Tex.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
		<author>
			<persName><surname>Fairness</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Script: A communication abstraction mechanism</title>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hailpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second ACM-SZGACT-SZGOPS Symposium on Principles of Distributed Computing</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983-08">Montreal, Aug. 1983. 1983</date>
			<biblScope unit="page" from="213" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fair termination of communicating processes</title>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third ACM SZGACT-SZGOPS Symposium on Principles of Distributed Computing</title>
		<meeting><address><addrLine>Vancouver; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1984-08">Aug. 1984. 1984</date>
			<biblScope unit="page" from="254" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969-10">Oct. 1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="100" to="106" />
			<date type="published" when="1978-08">Aug. 1978. Jan. 1983</date>
		</imprint>
	</monogr>
	<note>Commun. ACM</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<meeting><address><addrLine>Englewood Cliffs, N.J.</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Occam Programming Manual</title>
		<author>
			<persName><surname>Inmos Ltd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Temporal Logic of Programs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kroeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EATCS Monographs on Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<date type="published" when="1986">1986</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Fairness assumptions for CSP in a temporal logic framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kuiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Description of Programming Concepts</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Ii</surname></persName>
		</editor>
		<editor>
			<persName><surname>Bjerner</surname></persName>
		</editor>
		<meeting><address><addrLine>Ed. North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="159" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Time, clocks, and ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">How to cook a temporal proof system for your pet language</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tenth ACM Conference on Principles of Programming Languages</title>
		<meeting><address><addrLine>Austin, Tex; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983-01">Jan. 1983. 1983</date>
			<biblScope unit="page" from="141" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Applications of temporal logic to the specification and verification of reactive systems: A survey of current trends</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Current Trends in Concurrency</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">224</biblScope>
			<biblScope unit="page" from="510" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">A new and efficient implementation of multiprocess synchronization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ramesh</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A new class of high-level programs for distributed computing systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ramesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Mehndiratta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fifth Conference on FST-TCS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Fifth Conference on FST-TCS<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="page" from="42" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Synchronization in distributed programs</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Tram Program. Lang. Syst</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Stepwise removal of virtual channels in distributed algorithms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second International Workshop on Distributed Algorithms</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Tanenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Computer</forename><surname>Networks</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1987-08">August 1987. 1988. 1988. 1988</date>
		</imprint>
	</monogr>
	<note>revised May. accepted June</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
