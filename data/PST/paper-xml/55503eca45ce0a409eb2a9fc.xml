<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">High-Speed Polynomial Multiplication Architecture for Ring-LWE and SHE Cryptosystems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Donald</forename><forename type="middle">Donglong</forename><surname>Chen</surname></persName>
						</author>
						<title level="a" type="main">High-Speed Polynomial Multiplication Architecture for Ring-LWE and SHE Cryptosystems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">52F9EA594BA423FCB8F3D4ECE5B59819</idno>
					<idno type="DOI">10.1109/TCSI.2014.2350431</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Cryptography</term>
					<term>FFT polynomial multiplication</term>
					<term>Field-programmable gate array (FPGA)</term>
					<term>Number theoretic transform (NTT)</term>
					<term>Pipelined architecture</term>
					<term>Polynomial multiplication</term>
					<term>Ring-LWE</term>
					<term>SHE</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Polynomial multiplication is the basic and most computationally intensive operation in ring-learning with errors (ring-LWE) encryption and "somewhat" homomorphic encryption (SHE) cryptosystems. In this paper, the fast Fourier transform (FFT) with a linearithmic complexity of , is exploited in the design of a high-speed polynomial multiplier. A constant geometry FFT datapath is used in the computation to simplify the control of the architecture. The contribution of this work is three-fold. First, parameter sets which support both an efficient modular reduction design and the security requirements for ring-LWE encryption and SHE are provided. Second, a versatile pipelined architecture accompanied with an improved dataflow are proposed to obtain a high-speed polynomial multiplier. Third, the proposed architecture supports polynomial multiplications for different lengths and moduli . The experimental results on a Spartan-6 FPGA show that the proposed design results in a speedup of 3.5 times on average when compared with the state of the art. It performs a polynomial multiplication in the ring-LWE scheme and the SHE scheme in only 6.3 and 33.1 , respectively.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>C LASSICAL cryptosystems like RSA [1], [2] and elliptic curve cryptography (ECC) <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref> are based on the hardness of factoring and the elliptic curve discrete logarithm problem (ECDLP), respectively. However, by using the algorithms proposed by Shor <ref type="bibr" target="#b4">[5]</ref>, factoring and ECDLP can be solved in polynomial time by a quantum computer. Though it is unclear whether a sufficient powerful quantum computer can be built within decades, with the fast improvement of cryptanalysis, computation power, and the unpredictable development D. D. Chen, R. C. C. Cheung, and D. Pao are with the Department of Electronic Engineering, City University of Hong Kong, Hong Kong, China (e-mail: donald.chen@my.cityu.edu.hk; r.cheung@cityu.edu.hk; d.pao@cityu.edu.hk).</p><p>N. Mentens, F. Vercauteren, S. S. Roy, and I. Verbauwhede are with ESAT/ COSIC and iMinds, KU Leuven, Vlaams-Brabant, Leuven, Belgium (e-mail: nele.mentens@esat.kuleuven.be; frederik.vercauteren@esat.kuleuven.be; sujoy.sinharoy@esat.kuleuven.be; ingrid.verbauwhede@esat.kuleuven.be).</p><p>Digital Object Identifier 10.1109/TCSI.2014.2350431 of the quantum computer <ref type="bibr" target="#b5">[6]</ref>, post-quantum secure and yet practical alternatives are needed.</p><p>Lattice-based cryptosystems are good candidates for replacing these classical cryptosystems, because of their security proofs and the fact that there is no known quantum algorithm that can solve the lattice problem efficiently. Based on the security of lattice problems, many cryptographic schemes like the identification scheme <ref type="bibr" target="#b6">[7]</ref>, encryption schemes <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, and digital signature scheme <ref type="bibr" target="#b9">[10]</ref> have been proposed. Among them, many encryption schemes are based on the security of the learning with error problem (LWE), which Regev <ref type="bibr" target="#b10">[11]</ref> proved is at least as hard as solving certain lattice problems in the worst case.</p><p>Beside the significant progress in the theory of lattice-based cryptography, practical implementation issues are gaining attention from the research community <ref type="bibr" target="#b11">[12]</ref>- <ref type="bibr" target="#b13">[14]</ref>. One important milestone in bridging the gap between theory and practice is the introduction of ideal lattices <ref type="bibr" target="#b14">[15]</ref>. It reduces the size of the parameter set, which makes the efficient construction of lattice-based cryptosystems feasible.</p><p>Apart from the practical use in lattice-based cryptography, ideal lattices can be also applied to the fully homomorphic encryption (FHE) <ref type="bibr" target="#b15">[16]</ref> and "somewhat" homomorphic encryption (SHE) scheme <ref type="bibr" target="#b16">[17]</ref>. Both FHE and SHE provide secure computation on encrypted data in cloud computing, which is a significant breakthrough in cryptography. However, due to the large key size and the complicated computation, there is still lack of sufficient research on the efficient implementation of these schemes.</p><p>In order to facilitate researchers' hardware designs of the ring-LWE and SHE cryptosystems, a versatile and efficient polynomial multiplier would be of great help. This is because the most computationally intensive operation in these cryptosystems is the polynomial multiplication, and an efficient design of the polynomial multiplier will have significant benefit to the performance of the system.</p><p>The first hardware design for the LWE encryption scheme <ref type="bibr" target="#b8">[9]</ref> is proposed by Göttert et al. <ref type="bibr" target="#b17">[18]</ref> on FPGA. Due to the fully parallel design, the throughputs of the encryption outperform the software implementation by a factor of 316. The tradeoff of the parallel design is the large area consumption.</p><p>Pöppelmann et al. <ref type="bibr" target="#b18">[19]</ref> proposed a fast and yet compact design for the polynomial multiplication in ring-LWE <ref type="bibr" target="#b19">[20]</ref> and SHE <ref type="bibr" target="#b16">[17]</ref>. In their architecture, one butterfly unit is designed to compute the FFT and IFFT, which reduces the hardware area usage. However, due to the same design decision of one butterfly, the parallel property of the FFT could not be exploited. Thus, a further speedup of this system is possible.</p><p>Aysu et al. <ref type="bibr" target="#b20">[21]</ref> improved the architecture of <ref type="bibr" target="#b18">[19]</ref> and targeted for area-efficient design. The used parameter is a Fermat number, which enables efficient hardware design. Specifically, it can both enable efficient modular reduction <ref type="bibr" target="#b21">[22]</ref> and replace multiplication by powers of ( is a power of 2 in this case) in FFT/IFFT by a simple shift operation. The proposed architecture reduces the number of slices and block RAMs by around 67% and 80%, respectively. It can be seen that the selection of parameters that enable efficient implementations has significant impact on the performance of the system.</p><p>In this paper, a versatile pipelined hardware architecture is designed for the high-speed polynomial multiplication. The target of our work is to facilitate users' efficient design of cryptosystems like ring-LWE and SHE. In our work, the fast Fourier transform (FFT) <ref type="bibr" target="#b22">[23]</ref> with linearithmic complexity and parallel inter-stage computation, is exploited in the design of such polynomial multiplier. The main contributions of this paper are as follows:</p><p>• Parameter set selection method which supports both efficient modular reduction and the security requirement for ring-LWE encryption and SHE are analyzed and provided; • A generic high speed pipelined architecture along with an improved dataflow are designed to exploit the parallelism in polynomial multiplication; • The proposed parameterized architecture supports the computation of polynomial multiplication for different lengths and moduli ; • The implementation results show that our high speed design computes a ring-LWE scheme multiplication in only 6. <ref type="bibr" target="#b2">3</ref> and a SHE multiplication in 33.1 s, which results in a speedup of approximately 3.5 times compared to <ref type="bibr" target="#b18">[19]</ref>. The rest of this paper is organized as follows. Section II recaps the mathematical background. In Section III, the parameter sets for the ring-LWE encryption scheme and SHE are analyzed and an efficient parameter set selection method for modular reduction are proposed. The high speed pipelined architecture is described in detail in Section IV. Section V presents the implementation results and compares our works with the state of the art. Section VI concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. MATHEMATICAL PRELIMINARIES</head><p>Ideal lattices, which define ideals in the ring for some irreducible polynomial of degree , are good tools for the construction of various cryptographic schemes. The polynomial is represented as . Suppose and are two polynomials in the ring. The multiplication of and by using the school-book algorithm is calculated as , with a quadratic complexity of . In this paper, we focus on the commonly used case <ref type="bibr" target="#b7">[8]</ref> in which , is a power of 2, and is a prime number with . The choice of enables the usage of the property , which can simplify the polynomial multiplication as <ref type="bibr" target="#b0">(1)</ref> Using this property, the multiplication still has quadratic complexity with multiplications and additions or subtractions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Number Theoretic Transform and Fast Fourier Transform</head><p>The number theoretic transform (NTT) is a discrete Fourier transform defined over a finite ring <ref type="bibr" target="#b23">[24]</ref>. Let be a primitive -th root of unity in , and be polynomials of degree less than . The -point NTT are defined as:</p><p>(2) where . Since is a prime, has an inverse modulo where . Similarly also has an inverse . For Inverse NTT (INTT), the computation is similar to NTT after replacing with</p><p>. INTT also needs an additional final multiplication by on each element of the output. The NTT can be computed by using the fast Fourier transform (FFT) datapath <ref type="bibr" target="#b23">[24]</ref>. The FFT algorithm is shown in Algorithm 1.</p><p>Algorithm 1 Fast Fourier transform algorithm <ref type="bibr" target="#b23">[24]</ref> Let be a primitive -th root of unity in . Let be the inverse number of such that . Let be the coefficient vector of degree for the polynomial where . Input:</p><p>. Output:</p><p>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Polynomial Multiplication Using FFT</head><p>Using FFT, one can compute the cyclic convolution efficiently. However, the polynomial multiplication in is not equal to the cyclic convolution as shown above. It is obvious that the computation would become more efficient if we can compute the polynomial multiplication by using FFT. One way to achieve this goal is by zero padding.</p><p>Let be a primitive -th root of unity in . Let and be the coefficient vectors of polynomials and , respectively. By appending zeros to construct arrays and , respectively, the polynomial multiplication (linear convolution) of and can be computed by FFT and IFFT as</p><p>, where denotes point-wise multiplication of the coefficients.</p><p>In this paper, we refer to the polynomial multiplication using FFT as FFT multiplication. It can be seen that FFT and IFFT can be computed with complexity while the point-wise multiplication can be computed with complexity , thus the FFT multiplication has linearithmic complexity .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. FFT Multiplication Using Negative Wrapped Convolution</head><p>Though the polynomial multiplication using FFT and IFFT can be computed with linearithmic complexity, it needs to double the transformation length and the number of point-wise multiplications due to the zero padding. We can use the negative wrapped convolution method <ref type="bibr" target="#b24">[25]</ref> to avoid doubling the effort in the polynomial multiplication in . The definition of negative wrapped convolution is as follows. Let be the negative wrapped convolution of and ), then the are computed as One can find that the equation above is equal to the polynomial multiplication over in <ref type="bibr" target="#b0">(1)</ref>. This indicates we can perform the polynomial multiplication over by computing the negative wrapped convolution.</p><p>Details of polynomial multiplication using the negative wrapped convolution are shown in Algorithm 2. In order to guarantee the existence of which satisfies , when is prime and is power of 2, we should have .  Using the negative wrapped convolution to compute polynomial multiplication over , the modular reduction is eliminated. Moreover, compared with the zero padding method, the length of FFT, IFFT, and point-wise multiplication reduces from to . The operation comparison between FFT multiplication by zero padding and FFT multiplication using negative wrapped convolution is shown in Table <ref type="table" target="#tab_3">I</ref>. Compared with the zero padding method, the negative wrapped convolution method saves a considerable number of operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Polynomial multiplication using FFT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PARAMETER SET SELECTION FOR EFFICIENT MODULAR REDUCTION DESIGN</head><p>As shown in Table I modular reduction by is the most frequently used operation in FFT multiplication, so an efficient design will have significant impact on the whole architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Modular Reduction Algorithm Analysis</head><p>Inspired by <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b25">[26]</ref>, modular reduction can be computed efficiently by using Algorithm 3. Carefully examining Algorithm 3 we conclude that a small value of (small ) reduces the number of loops in the computation. Furthermore, if is a number with low Hamming weight, the addition of the corresponding segments of can replace the multiplication , which reduces the area usage for modular reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 Modular reduction algorithm</head><p>Let and be the bit length of and , respectively. Let be the input number with a maximum bit length . Input:</p><p>. Output:</p><p>. 1: while 2: 3: 4: end while 5: if 6: 7: else 8: 9: end if 10: return One extreme case which meets the above two conditions is a Fermat number, for which . However, the currently known Fermat numbers larger than are not prime <ref type="bibr" target="#b26">[27]</ref>, thus we cannot use them in the lattice-based cryptosystems. In conclusion, the selection of prime for which is small and with low Hamming weight will have great benefit for the performance of the modular reduction operation, thus for the whole FFT multiplication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Efficient and Secure Parameter Selection Restrictions</head><p>In order to demonstrate the performance of our design, we choose parameter sets for the implementation of two popular cryptosystems, namely ring-LWE encryption and SHE. For ring-LWE encryption, the parameter sets which can provide medium and long term security are and</p><p>, respectively <ref type="bibr" target="#b27">[28]</ref>. In terms of SHE, the parameter sets and from <ref type="bibr" target="#b16">[17]</ref> are chosen. Taking into account that is neither small nor has low Hamming weight for and , these parameters do not result in an efficient design of the modulo reduction. Though the Hamming weight of the non-adjacent form [29, p. 98] of is 5, the value of is still too large. In order to improve the performance, searching some nice values of for these two parameter sets are necessary. In order to find some nice for efficient computation without affecting the security requirement of ring-LWE encryption and SHE, we have the following restrictions during the selection of . 1) should be a prime number; 2) In order to guarantee that the FFT multiplication can use negative wrapped convolution, as is a power of 2, should satisfy ; 3) In order to meet the security requirement of LWE encryption and SHE, for parameter sets with the same , the new should have the same bit size as the original one; 4) should be a number with low Hamming weight; 5) should be a small number. Restriction 1 and 2 guarantee the existence of primitive -th root of unity and such that , that enables the negative wrapped convolution method in FFT multiplication. Restriction 1 and 3 are for security consideration while restriction 4 and 5 enable efficient modular reduction by .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Complexity Analysis and Parameter Selection Process</head><p>For each lengthparameter set, the selection process could be started from the comparison of the -bit prime numbers. Among these numbers, the which has both the lowest Hamming weight and the smallest would be the best choice. If no such number exists, the process will switch to the comparison of computation complexity for each modular reduction.</p><p>Note that the number of loops in Algorithm 3 is . Then, in the -th loop , one by bits constant multiplication and one by bits subtraction are required. Let be the Hamming weight of , then one by bits constant multiplication equivalent to times bits additions. In summary, in each loop of the modular reduction , there are times bits additions, 1 time by bits subtraction, and 1 time bits addition. Note that the complexity of addition and subtraction are .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE II SECURE PARAMETER SETS SELECTION AND COMPARISON FOR THE RING-LWE ENCRYPTION SCHEME AND THE "SOMEWHAT" HOMOMORPHIC ENCRYPTION SCHEME. NAF REPRESENTS NON-ADJACENT FORM</head><p>The which leads to the smallest computation complexity in modular reduction will be chosen.</p><p>Following the selection method above, we select two new for parameter sets and which enable the smallest computation efforts in modular reduction. These parameter sets for LWE and SHE are listed in Table <ref type="table" target="#tab_3">II</ref> for easy comparison. One can find that our newly selected have low Hamming weight and the values of are small, which is suitable for efficient modular reduction design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PIPELINED ARCHITECTURE FOR FFT MULTIPLICATION</head><p>In this section, we will first describe the architecture design of the FFT multiplier. Then the pipelined architecture of the FFT multiplier will be introduced in detail. Finally, the memory control mechanism will be presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Top Level Architecture Design for FFT Multiplier</head><p>The algorithm of polynomial multiplication using FFT is presented in Algorithm 2. Carefully examining the algorithm, one can find that steps 3,4 and steps 6,7 have no data dependency. This enables a high speed design by computing each of these two steps in parallel.</p><p>In order to enable two FFT computations in parallel, the smallest architecture consists of two butterflies together with two multipliers. These processing units can compute two coefficients for and concurrently. IFFT is different from FFT in the multiplication by instead of , and an additional multiplication by at the end of the last stage. Hence, the processing units of the FFT can be fully reused to compute the IFFT. Since only one IFFT instead of two is required, the two butterflies and multipliers are all used to compute in parallel, which doubles the speed for the IFFT.</p><p>With the processing units mentioned above, we found that in the last stage of the FFT, when the two multipliers are still working on multiplication by powers of , the point-wise multiplication is available for computation. In order to pipeline the last stage of the FFT with point-wise multiplication, two more multipliers are added to compute the point-wise multiplications and , respectively, between the FFT and IFFT computations.</p><p>Following the design ideas mentioned previously, a pipelined architecture for the FFT multiplier is designed and presented in Fig. <ref type="figure" target="#fig_0">1(a)</ref>. As can be seen from Fig. <ref type="figure" target="#fig_0">1</ref>(a), four input buses are designed to enable a pipelined input. After a certain computation cycle, four coefficients of the resulting polynomial appear at the  output at each cycle. These coefficient outputs can be fed into other operators of the ring-LWE or SHE cryptosystems for further computation. An implementation example of ring-LWE decryption system by using the proposed FFT multiplier is shown in Fig. <ref type="figure" target="#fig_0">1(c</ref>).</p><p>1) Proposed Working Dataflow for the FFT Multiplier: The proposed architecture operates according to the dataflow depicted in Fig. <ref type="figure" target="#fig_1">2</ref>. Two butterflies work in parallel and are responsible for and . For the inverse FFT, two butterflies compute one in parallel. Note that the multiplication by powers of and point-wise multiplication are absorbed in the first stage and last stage FFT, respectively, thus only more cycles are required for the multiplication by powers of . The cycle requirement of each operation of the FFT multiplication is shown in Table <ref type="table" target="#tab_4">III</ref>  pipelined with stage 0 of the FFT, which leads to a reduction of cycles compared with the original design. In the original design, and are precomputed, and the multiplication of these values is performed separately. Our improved design simplifies the computation by precomputing the products . With this design the number of cycles for the multiplication by and is reduced from to . The cycle requirement of each operation of the FFT multiplication is shown in Table <ref type="table" target="#tab_4">III</ref>. The total cycle requirement for one FFT multiplication is reduced to 3) Memory Utilization: In order to enable pipelining in our architecture, simple dual-port RAMs (RAMs), which can read and write concurrently, are used to store the coefficient arrays. In our architecture, at least four RAMs are necessary to feed four coefficients into the FFT processors at each cycle; each RAM is responsible for the storage of coefficients. In our design, eight RAMs are employed by using the ping-pong alternative storage mechanism of which the details will be explained in the later subsections. Instead of generating , , , and on the fly, ROMs are used for the storage of these precomputed values. In the FFT computation, one ROM is enough to store the values of because the two FFT processors always need the same input. In the IFFT computation, the ROM usage is the same but a dual-port mode is required for the fact that the inputs are different in the final stage of IFFT.</p><p>4) FFT Architecture Selection: Constant geometry FFT <ref type="bibr" target="#b29">[30]</ref>, which shares the same datapath for all the stages, is a good candidate for our pipelined design. The constant geometry FFT algorithm is shown in Algorithm 1. A 16-point constant geometry FFT datapath is depicted in Fig. <ref type="figure" target="#fig_3">3</ref>. As can be seen, the datapath for constant geometry FFT is the same both inter-and intra-stage, which makes the read/write control of the sub-stage architecture as simple as of the whole stage.</p><p>One may argue that in-place FFT is also a good candidate, in which the storage addresses of input and output are the same. However, the read/write addresses of in-place FFT are different from one stage to another. This makes the read/write control of the in-place FFT more complex than the constant geometry FFT; different control logics are required to manipulate the RAM read/write addresses in different stages. Since high speed is the primary target of our design, the simple control in constant geometry FFT, which could lead to a higher operating frequency of the multiplier, becomes our first choice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Building Blocks and Memory Control Mechanism 1) Modular Reduction:</head><p>The architecture for modular reduction by is introduced as an example in Fig. <ref type="figure" target="#fig_4">4</ref>. Note that the design for other is similar. The newly selected are numbers with low Hamming weight, thus the constant multiplication can be performed by adding the corresponding segments of . Using this approach can both reduce the carry chain of the adder and save logic for the shift operation. Moreover, when the bit-width for the shift operation is larger than the bit width of as shown in the solid line box in Fig. <ref type="figure" target="#fig_4">4</ref>, the addition can be also eliminated.</p><p>It is worth to note that after the first subtraction, the later operations should support a signed representation of the operands. After reducing the bit length to (signed number), a detection on the sign bit decides whether a further addition is required to bound the value within . 2) Butterfly Unit for FFT/IFFT: The butterfly unit for constant geometry FFT/IFFT is shown in Fig. <ref type="figure">5</ref>. The butterfly processor and the channel selector constitute the butterfly unit. The butterfly processor performs the addition and subtraction with modular reduction in FFT/IFFT (i.e. <ref type="bibr">Step 5,</ref><ref type="bibr" target="#b5">6</ref> in Algorithm 1). A channel selector <ref type="bibr" target="#b30">[31]</ref> is responsible for wiring the coefficients back to their corresponding RAMs.</p><p>3) Pipeline Depth Control for Pipeline read/write: The pipelined dataflow example of a 16-point constant geometry FFT/IFFT is depicted in Fig. <ref type="figure">6</ref>. In order to achieve 100% usage of the FFT processor in the FFT/IFFT computation, two coefficients are required as inputs at each cycle consecutively without pipeline bubbles intra-and inter-stage. Therefore, we should first guarantee that within each stage, the RAM input time ( is the stage number) of the last two coefficients (i.e.</p><p>) is smaller than the output time of the first output among these two coefficients (i.e.</p><p>). Hence, the pipeline delay should satisfy in order to guarantee the values within each stage connect without any bubble (An example is provided in Fig. <ref type="figure">6</ref>).</p><p>However, if the condition is met, a read/write collision which is described in Fig. <ref type="figure">6</ref>, will occur between each stage in the RAMs; the processed new data for the next stage FFT/IFFT will overwrite the unread data of the current stage. Therefore, a read-before-write behavior could only provide a correct read for the coefficients with indices smaller than . In order to solve this collision problem without adding pipelining bubbles, one could double the number of RAM blocks and use the ping-pong alternative storage method. Manipulated by the control signals, multiplexers are used to select the RAM blocks as shown in Fig. <ref type="figure" target="#fig_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Coefficient RAM Control Mechanism</head><p>Carefully examining the coefficient input schedules for FFT/IFFT (output schedules for the RAMs) of each stage of Algorithm 1, we can find that there are two input schedules for the butterfly of the constant geometry FFT. The first input schedule is for stage 0, where the coefficients with small indices are led to one input, while the coefficients with large indices are led to the other input. The second type of input schedule is for the rest of the stages, where the coefficients with even indices are led to the first input, while the coefficients with odd indices are led to the other input. Therefore, we can arrange the coefficient storage in the RAMs as shown in Fig. <ref type="figure" target="#fig_6">7</ref>.  ) of stage 2 is smaller than the RAM output time (time 19) of the first output among these two coefficients (i.e. ) within the same stage. Thus the RAM output can follow the RAM input immediately without any delay within the stage. However, if the condition is met, a read/write collision will occur. Coefficient of stage 1 will be at the output of the RAM at time 8, after cycles, the processed new coefficient for stage 2 will be written back to RAM at time 11. However, following the schedule of FFT/IFFT, the coefficient of stage 1 will not be computed until time 12. Since the values of for stage 1 and stage 2 should be stored in the same RAM address, a direct write back of the stage 2 will overwrite the unread stage 1 value. This will create a wrong stage 1 FFT input of at time 13.</p><p>With this design, a reverse order read operation in stage 0 and a sequence read in other stages provides the correct coefficient schedule for FFT/IFFT. When it comes to the input schedule of RAMs, we should first consider the output schedule of stage 0 to stage in the FFT. From Algorithm 1, we can find that the index gap between the outputs of each butterfly is , and these two indices    <ref type="bibr" target="#b18">[19]</ref> AND OUR HIGH-SPEED FFT MULTIPLIER ON A SPARTAN-6 (XC6SLX100-3) FPGA selector is depicted in Fig. <ref type="figure" target="#fig_7">8</ref>. With this design, the two outputs from the butterfly can be written back to the corresponding RAMs at each cycle with only 1 cycle delay.</p><p>The output schedule of stage in the FFT determines the input of stage 0 of the IFFT. In order to make the output of the IFFT in sequence order, the input of the IFFT should be in reverse order as compared to the FFT. Hence, the coefficient storage in stage 0 for the IFFT in RAMs should be in sequence, which is the same as stage 0 in the FFT shown in Fig. <ref type="figure" target="#fig_6">7</ref>. Note that the indices of two coefficients generated by the butterfly processor have the same parity, which makes a direct write back to the RAMs possible. By selecting the gray-colored channels from the channel selector, which are shown in Fig. <ref type="figure">5</ref>, the in-sequence coefficient storage can be implemented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. FPGA OPTIMIZATION RESULTS AND COMPARISONS</head><p>The proposed architecture is implemented on a Spartan-6 (xc6slx100-3) FPGA using Verilog. The post place-and-route (PAR) implementation results are generated using Xilinx ISE 14.7 with the default synthesis option.</p><p>In order to facilitate future comparisons, the results which the FFT multipliers are built by pure LUTs are provided (Design 1). In order to guarantee the speed and have a relatively fair comparison of the area-latency product with <ref type="bibr" target="#b18">[19]</ref>, we tried to construct the base multiplier by using as less DSPs as in <ref type="bibr" target="#b18">[19]</ref>. For this reason the 58 58-bit base multipliers for FFT multiplier are constructed by using Karatsuba's algorithm <ref type="bibr" target="#b31">[32]</ref>. We also tried to reduce the BRAM number by using block memory to realize RAMs and using distributed memory to build ROMs (Design 2). In order to achieve the high-speed target, we fully use the DSPs and block RAMs (BRAMs) in the device to realize the base multiplier and RAM/ROM, respectively (Design 3). The implementation results of the above designs are shown in Table <ref type="table" target="#tab_5">IV</ref>.</p><p>In our design, LUT based components are combined with registers to split into balanced delay paths, which make the design operate under high frequency. Note that the critical path is the route between the input and output of the base multiplier or the RAM. Therefore, the speed performance of the base multiplier or the RAM determines the operating frequency of the whole system. The cycle delay of the base multiplier is set to the optimum number in order to achieve the highest operating frequency, thus the total cycle count may be different for the same length FFT multipliers.</p><p>The comparisons between the latest work of Pöppelmann et al. <ref type="bibr" target="#b18">[19]</ref> and our Design 2 are shown in Table <ref type="table" target="#tab_5">V</ref>. We compare the area-latency product for the FFT multipliers which have the same number of DSPs and less BRAM usage than <ref type="bibr" target="#b18">[19]</ref> ( 256, 512, and 1024). The best achieved improvement on area-latency product is 68% for the multiplier. The performance gain is mainly thanks to the newly selected , which enables a more efficient modular reduction design.</p><p>The improvement is 36.5% for the FFT multipliers. This is because the usage of distributed memory and the construction of the base multipliers (using both DSP and LUTs) consume more LUTs in this case, which increase the number of slices and reduce the operating frequency. The area-latency product comparison with <ref type="bibr" target="#b18">[19]</ref> for is not fair because we have less DSPs but more BRAMs. However, it can be seen from the latency comparison of the two Design 2 results that for the large data size FFT multiplier, block memory instead of distributed memory is preferred to achieve high speed in FPGA.</p><p>In our design, the cycle requirement of a lengthpolynomial multiplication is . In the work of <ref type="bibr" target="#b18">[19]</ref> the cycle requirement is . Compared with <ref type="bibr" target="#b18">[19]</ref>, our design will save at least 50% of the cycles in the computation, theoretically. It can be seen that the cycle reduction is higher than 60% for the four FFT multipliers in our design.</p><p>The latency comparison between <ref type="bibr" target="#b18">[19]</ref> and our design is depicted in Fig. <ref type="figure" target="#fig_8">9</ref>. Compared with <ref type="bibr" target="#b18">[19]</ref>, our high-speed pipelined architecture has approximately 3.5 times speedup on average. The speedup is mainly achieved by the reduction in cycles and the increase of operating frequency. The cycle reduction is achieved thanks to the pipelined design and the improved dataflow while the increase in frequency is achieved by the simple read/write control of the constant geometry FFT. When compared with the software implementation from <ref type="bibr" target="#b16">[17]</ref>, which  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS AND FUTURE WORKS</head><p>A high-speed pipelined design for FFT multiplication is presented for efficient implementation of ring-LWE and "somewhat" homomorphic encryption cryptosystems. Parameter selection restrictions and an efficient selection method are analyzed and provided. The implementation results of the proposed multipliers on a Spartan-6 FPGA show that our architecture achieves a 3.5 times speedup on average when compared with the state of the art. The results also show that the selected new parameters support efficient modular reduction design, which improves the performance of the whole FFT multiplier.</p><p>Future works will exploit the full usage of the processing units of the proposed pipelined architecture, and will simplify the control logic of our design. We will consider using the ATHENa framework to improve the synthesis results <ref type="bibr" target="#b32">[33]</ref>. We will also investigate how to incorporate the proposed FFT multiplier in the ring-LWE and SHE cryptosystems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The top level architecture and an implementation example for the proposed FFT multiplier. There are registers between each two operators; we omit them in (a) for simplicity.</figDesc><graphic coords="5,67.98,65.16,455.10,268.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Data flow of the proposed FFT multiplication.</figDesc><graphic coords="5,55.02,372.12,216.12,79.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>. The total cycle requirement for one FFT multiplication is . 2) Improved Dataflow for the FFT Multiplier: Carefully examining Algorithm 1, one can find that when (stage 0), always equal to 0, hence . This indicates the multiplication in stage 0 is meaningless because it is always equal to . Or putting it in a different way, one can replace the multiplication by in stage 0 by the multiplication by . With this design, the multiplication by can be</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Datapath of the constant geometry FFT. The numbers in the middle of the lines represent the value of in Algorithm 1.</figDesc><graphic coords="6,42.00,64.14,246.00,273.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Architecture of the modular reduction by. As shown in the solid line box, when the bit width for shift operation (The shift bit width is 9) is larger than the bit width of (The bit width of is 4), the addition can be eliminated.</figDesc><graphic coords="7,70.98,64.14,448.14,115.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. Architecture of the butterfly unit. Selecting the black-colored channels in the channel selector enables output schedule as shown in Fig. 8 while selecting the gray-colored channels enables the in-sequence output schedule.</figDesc><graphic coords="7,139.02,224.16,312.00,85.98" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Coefficient storage arrangement of 16-point FFT/IFFT in RAMs.</figDesc><graphic coords="7,304.98,357.12,246.00,54.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Input and output schedule of the butterfly processor and the channel selector of a 16-point FFT (one stage example from stage 1 to stage). is the pipelined delay of the butterfly processor.</figDesc><graphic coords="8,45.00,63.12,504.00,60.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. The comparison of the latency between the design of Pöppelmann et al [19] and our design.</figDesc><graphic coords="9,40.98,64.14,246.00,186.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>takes 11 ms for an FFT multiplication by using 2.1GHz Intel Core 2 Duo, our design realizes a speedup of approximately 130 times.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Manuscript received March 26, 2014; revised July 01, 2014; accepted July 31, 2014. Date of publication October 08, 2014; date of current version January 06, 2015. This work was partly supported by the Research Grant Council of the Hong Kong Special Administrative Region, China (Project No. CityU 123612), and Croucher Startup Allowance (Project No. 9500015). This work was also supported by the Research Council KU Leuven: TENSE ( GOA/11/007), by iMinds, by the European Union Seventh Framework Programme) (FP7/2007-2013) under Grant n.609611 (PRACTICE, by the Flemish Government, FWO G.0550.12N, by the Hercules Foundation AKUL/11/19. Sujoy Sinha Roy is supported by an Erasmus Mundus PhD Scholarship. This paper was recommended by Associate Editor X. Zhang.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE I THE</head><label>I</label><figDesc>OPERATION ANALYSIS AND COMPARISON BETWEEN FFT MULTIPLICATION</figDesc><table /><note><p>BY USING ZERO PADDING AND NEGATIVE WRAPPED CONVOLUTION</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE III THE</head><label>III</label><figDesc>CYCLE ANALYSIS OF EACH OPERATION OF THE PROPOSED FFT MULTIPLIER AND THE IMPROVED DESIGN. THE CYCLE REQUIREMENT FOR THE PIPELINE DELAY IS NEGLIGIBLE COMPARED WITH THE TOTAL CYCLE REQUIREMENT, HENCE OMITTED FOR SIMPLICITY</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE V COMPARISONS</head><label>V</label><figDesc>BETWEEN THE DESIGN OF PÖPPELMANN et al.</figDesc><table /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A method for obtaining digital signatures and public-key cryptosystems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="126" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A new algorithm for high-speed modular multiplication design</title>
		<author>
			<persName><forename type="first">M.-D</forename><surname>Shieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-H</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2009" to="2019" />
			<date type="published" when="2009-09">Sept. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The state of elliptic curve cryptography</title>
		<author>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Designs, Codes, Cryptography</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="173" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient algorithm and architecture for elliptic curve cryptography for extremely constrained secure applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Azarderakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jarvinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mozaffari-Kermani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Circuits Syst. I, Reg. Papers</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1144" to="1155" />
			<date type="published" when="2014-04">Apr. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algorithms for quantum computation: discrete logarithms and factoring</title>
		<author>
			<persName><forename type="first">P</forename><surname>Shor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 35th Annu. Symp. Found. Comput. Sci</title>
		<meeting>35th Annu. Symp. Found. Comput. Sci</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">NSA seeks to build quantum computer that could crack most types of encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gellman</surname></persName>
		</author>
		<ptr target="http://wapo.st/19DycJT" />
	</analytic>
	<monogr>
		<title level="s">The Washington Post</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Lattice-based identification schemes secure under active attacks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography PKC 2008, ser</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Germany</forename><surname>Berlin/Heidelberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4939</biblScope>
			<biblScope unit="page" from="162" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On ideal lattices and learning with errors over rings</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology EURO-CRYPT 2010, ser</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Better key sizes (and attacks) for LWEbased encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lindner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology CT-RSA 2011</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ed</forename><surname>Berlin/Heidelberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Germany</forename></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6558</biblScope>
			<biblScope unit="page" from="319" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Lattice signatures without trapdoors</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology EUROCRYPT 2012</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Germany</forename><surname>Berlin/Heidelberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="738" to="755" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, cryptography</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 37th Annu. ACM Symp. Theory Comput., 2005, ser. STOC &apos;05</title>
		<meeting>37th Annu. ACM Symp. Theory Comput., 2005, ser. STOC &apos;05</meeting>
		<imprint>
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Implementation and comparison of latticebased identification protocols on smart cards and microcontrollers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boorghany</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jalili</surname></persName>
		</author>
		<idno>Rep. 2014/078</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Cryptology ePrint Archive</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">High precision discrete Gaussian sampling on FPGAs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SAC</title>
		<meeting>SAC</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Enhanced lattice-based signatures on reconfigurable hardware</title>
		<author>
			<persName><forename type="first">T</forename><surname>Pöppelmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ducas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Güneysu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>Rep. 2014/254</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Generalized compact knapsacks are collision resistant</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Berlin/Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4052</biblScope>
			<biblScope unit="page" from="144" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 41st Annu. ACM Symp. Theory Comput., 2009, ser. STOC &apos;09</title>
		<meeting>41st Annu. ACM Symp. Theory Comput., 2009, ser. STOC &apos;09</meeting>
		<imprint>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Can homomorphic encryption be practical?</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lauter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd ACM Workshop Cloud Comput. Security, 2011, ser. CCSW &apos;11</title>
		<meeting>3rd ACM Workshop Cloud Comput. Security, 2011, ser. CCSW &apos;11</meeting>
		<imprint>
			<biblScope unit="page" from="113" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the design of hardware building blocks for modern lattice-based encryption schemes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Göttert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Feller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Buchmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Huss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems CHES 2012, ser</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Schaumont</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin/Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7428</biblScope>
			<biblScope unit="page" from="512" to="529" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Towards efficient arithmetic for lattice-based cryptography on reconfigurable hardware</title>
		<author>
			<persName><forename type="first">T</forename><surname>Pöppelmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Güneysu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Progress in Cryptology LATINCRYPT 2012</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">/</forename><surname>Berlin</surname></persName>
		</editor>
		<editor>
			<persName><surname>Heidelberg</surname></persName>
		</editor>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7533</biblScope>
			<biblScope unit="page" from="139" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Trapdoors for hard lattices and new cryptographic constructions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 40th Annu. ACM Symp. Theory Comput., 2008, ser. STOC &apos;08</title>
		<meeting>40th Annu. ACM Symp. Theory Comput., 2008, ser. STOC &apos;08</meeting>
		<imprint>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Low-cost and area-efficient FPGA implementations of lattice-based cryptography</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aysu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schaumont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2013 IEEE Int. Symp. Hardware-Oriented Security Trust (HOST)</title>
		<meeting>2013 IEEE Int. Symp. Hardware-Oriented Security Trust (HOST)</meeting>
		<imprint>
			<biblScope unit="page" from="81" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient VLSI implementation of modulo ( ) addition and multiplication</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zimmermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Comput. Arith. (ARITH 1999)</title>
		<meeting>Comput. Arith. (ARITH 1999)</meeting>
		<imprint>
			<biblScope unit="page" from="158" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An algorithm for the machine computation of complex Fourier series</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cooley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turkey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">90</biblScope>
			<biblScope unit="page" from="297" to="301" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The fast Fourier transform in a finite field</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Pollard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="365" to="374" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">SWIFFT: A modest proposal for FFT hashing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Fast</forename><surname>Software Encryption</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5086</biblScope>
			<biblScope unit="page" from="54" to="72" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Heidelberg, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Generalized Mersenne numbers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Solinas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Faculty of Mathematics</title>
		<meeting><address><addrLine>Waterloo, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Univ. Waterloo</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Fast Fourier Transform and Convolution Algorithms</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Naussbaumer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Estimating the security of lattice-based cryptosystems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rückert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schneider</surname></persName>
		</author>
		<idno>rep. 2010/137</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Cryptology ePrint Archive</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Guide to Elliptic Curve Cryptography</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hankerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An adaptation of the fast Fourier transform for parallel processing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="252" to="264" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Low complexity and hardware-friendly spectral modular multiplication</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C C</forename><surname>Cheung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2012 Int. Conf. Field-Program. Technol. (FPT)</title>
		<meeting>2012 Int. Conf. Field-Program. Technol. (FPT)</meeting>
		<imprint>
			<biblScope unit="page" from="368" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Multiplication of multidigit numbers on automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Karatsuba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ofman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Soviet Physics Doklady</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="595" to="596" />
			<date type="published" when="1963">1963</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">ATHENa: Automated Tool for Hardware EvaluatioN</title>
		<ptr target="http://cryptography.gmu.edu/athena/" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
