<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Design Patterns: Abstraction and Reuse of 0 bject-Orient ed Design</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Erich</forename><surname>Gamma'</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><surname>Helm2</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ralph</forename><surname>Johnson3</surname></persName>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Vlissides2</surname></persName>
						</author>
						<author>
							<persName><forename type="first">I</forename><forename type="middle">B M</forename><surname>Thomas</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><surname>Watson</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<settlement>Taligent</settlement>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Research Center</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<addrLine>10725 N. De Anza Blvd</addrLine>
									<postBox>P.O. Box 704</postBox>
									<postCode>950142000, 10598</postCode>
									<settlement>Cupertino, Yorktown Heights</settlement>
									<region>CA, NY</region>
									<country>USA, USA &apos;</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">UrbanaXhampaign</orgName>
								<address>
									<addrLine>1034 W. Springfield Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">UBILAB</orgName>
								<orgName type="institution" key="instit2">Union Bank of Switzerland</orgName>
								<address>
									<settlement>Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Design Patterns: Abstraction and Reuse of 0 bject-Orient ed Design</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3B8035A043F794958068BFE88D67E7FA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose design patterns as a new mechanism for expressing object-oriented design experience. Design patterns identify, name, and abstract common themes in object-oriented design. They capture the intent behind a design by identifying objects, their collaborations, and the distribution of responsibilities. Design patterns play many roles in the object-oriented development process: they provide a common vocabulary for design, they reduce system complexity by naming and defining abstractions, they constitute a base of experience for building reusable software, and they act as building blocks from which more complex designs can be built. Design patterns can be considered reusable micro-architectures that contribute to an overall system architecture. We describe how to express and organbe design patterns and introduce a catalog of design patterns. We also describe our experience in applying design patterns to the design of object-oriented systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Design methods are supposed to promote good design, to teach new designers how to design well, and to standardize the way designs are developed. Typically, a design method comprises a set of syntactic notations (usually graphical) and a set of rules that govern how and when to use each notation. It will also describe problems that occur in a design, how to fix them, and how to evaluate a design. Studies of expert programmers for conventional languages, however, have shown that knowledge is not organized simply around syntax, but in larger conceptual structures such as algorithms, data structures and idioms [l, 7, 9, 271, and plans that indicate steps necessary to fulfill a particular goal <ref type="bibr" target="#b24">[26]</ref>. It is likely that designers do not think about the notation they are using for recording the design. Rather, they look for patterns to match against plans, algorithms, data structures, and idioms they have learned in the past. Good designers, it appears, rely on large amounts of design experience, and this experience is just as important as the notations for recording designs and the rules for using those notations.</p><p>Our experience with the design of object-oriented systems and frameworks f15, <ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b28">30,</ref><ref type="bibr">311</ref> bears out this observation. We have found that there exist idiomatic class and object structures that help make designs more flexible, reusable, and elegant. For example, the Model-View-Controller (MVC) paradigm from Smalltalk <ref type="bibr" target="#b17">[19]</ref> is a design structure that separates representation from presentation. MVC promotes flexibility in the choice of views, independent of the model. Abstract factories <ref type="bibr">[lo]</ref> hide concrete subclasses from the applications that use them so that class names are not hard-wired into an application.</p><p>Well-defined design structures like these have a positive impact on software development. A software architect who is familiar with a good set of design structures can apply them immediately to design problems without having to rediscover them. Design structures also facilitate the reuse of successful architectures-expressing proven techniques as design structures makes them more readily accessible to developers of new systems. Design structures can even improve the documentation and maintenance of existing systems by furnishing an explicit specification of class and object interactions and their underlying intent.</p><p>To this end we propose design patterns, a new mechanism for expressing design structures. Design patterns identify, name, and abstract common themes in object-oriented design. They preserve design information by capturing the intent behind a design. They identify classes, instances, their roles, collaborations, and the distribution of responsibilities. Design patterns have many uses in the object-oriented development process:</p><p>-Design patterns provide a common vocabulary for designers to communicate, document, and explore design alternatives. They reduce system complexity by naming and defining abstractions that are above classes and instances. A good set of design patterns effectively raises the level at which one programs.</p><p>-Design patterns constitute a reusable base of experience for building reusable software. They distill and provide a means to reuse the design knowledge gained by experienced practitioners. Design patterns act as building blocks for constructing more complex designs; they can be considered micro- architectures that contribute to overall system architecture.</p><p>-Design patterns help reduce the learning time for a class library. Once a library consumer has learned the design patterns in one library, he can reuse this experience when learning a new class library. Design patterns help a novice perform more like an expert. -Design patterns provide a target for the reorganization or refactoring of class hierarchies <ref type="bibr" target="#b21">[23]</ref>. Moreover, by using design patterns early in the lifecycle, one can avert refactoring at later stages of design.</p><p>The major contributions of this paper are: a definition of design patterns, a means to describe them, a system for their classification, and most importantly, a catalog containing patterns we have discovered while building our own class libraries and patterns we have collected from the literature. This work has its roots in Gamma's thesis <ref type="bibr">[ll]</ref>, which abstracted design patterns from the ET++ framework. Since then the work has been refined and extended based on our colleetive experience. Our thinking has also been influenced and inspired by discussions within the Architecture Handbook Workshops at recent OOPSLA conferences [3, 41.</p><p>This paper has two parts. The first introduces design patterns and explains techniques to describe them. Next we present a classification system that characterizes common aspects of patterns. This classification will serve to structure the catalog of patterns presented in the second part of this paper. We discuss how design patterns impact object-oriented programming and design. We also review related work.</p><p>The second part of this paper (the Appendix) describes our current catalog of design patterns. As we cannot include the complete catalog in this paper (it currently runs over 90 pages <ref type="bibr" target="#b9">[12]</ref>), we give instead a brief summary and include a few abridged patterns. Each pattern in this catalog is representative of what we judge to be good object-oriented design. We have tried to reduce the subjectivity of this judgment by including only design patterns that have seen practical application. Every design pattern we have included works-most have been used at least twice and have either been discovered independently or have been used in a variety of application domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design Patterns</head><p>A design pattern consists of three essential parts:</p><p>1. An abstract description of a class or object collaboration and its structure.</p><p>The description is abstract because it concerns abstract design, not a particular design. 2. The issue in system design addressed by the abstract structure. This determines the circumstances in which the design pattern is applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>The consequences of applying the abstract structure to a system's architecture. These determine if the pattern should be applied in view of other design constraints.</p><p>Design patterns are defined in terms of object-oriented concepts. They are suf- ficiently abstract to avoid specifying implementation details, thereby ensuring wide applicability, but a pattern may provide hints about potential implementation issues.</p><p>We can think of a design pattern as a micro-architecture. It is an architecture in that it serves as a blueprint that may have several realizations. It is "micro" in that it defines something less than a complete application or library. To be useful, a design pattern should be applicable to more than a few problem domains; thus design patterns tend to be relatively small in size and scope. A design pattern can also be considered a transformation of system structure. It defines the context Class Object Compound for the transformation, the change to be made, and the consequences of this transformation.</p><p>To help readers understand patterns, each entry in the catalog also includes detailed descriptions and examples. We use a template (Figure <ref type="figure">1</ref>) to structure our descriptions and to ensure uniformity between entries in the catalog. This template also explains the motivation behind its structure. The Appendix contains three design patterns that use the template. We urge readers to study the patterns in the Appendix as they are referenced in the following text. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Characterization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Categorizing Design Patterns</head><p>Design patterns vary in their granularity and level of abstraction. They are numerous and have common properties. Because there are many design patterns, we need a way to organize them. This section introduces a classification system for design patterns. This classification makes it easy to refer to families of related patterns, to learn the patterns in the catalog, and to find new patterns.  We can think of the set of all design patterns in terms of two orthogonal criteria, jurisdiction and characterization. Table <ref type="table">1</ref> organizes our current set of patterns according to these criteria. Jurisdiction is the domain over which a pattern applies. Patterns having class jurisdiction deal with relationships between base classes and their subclasses;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Jurisdictio</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DESIGN PATTERN NAME Jurisdiction Characterization</head><p>What is the pattern's name and classification? The name should convey the pattern's essence succinctly. A good name is vital, as it will become part of the design vocabulary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intent</head><p>What does the design pattern do? What is its rationale and intent? What particular design issue or problem does it address?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation</head><p>A scenario in which the pattern is applicable, the particular design problem or issue the pattern addresses, and the class and object structures that address this issue. This information will help the reader understand the more abstract description of the pattern that follows.</p><p>What are the situations in which the design pattern can be applied? What are examples of poor designs that the pattern can address? How can one recognize these situations?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applicability</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Participants</head><p>Describe the classes and/or objects participating in the design pattern and their responsibilities using CRC conventions <ref type="bibr" target="#b10">[5]</ref>.</p><p>Describe how the participants collaborate to carry out their responsibilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Collaborations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Diagram</head><p>A graphical representation of the pattern using a notation based on the Object Modeling Technique (OMT) <ref type="bibr" target="#b23">[25]</ref>, to which we have added method pseudo-code.</p><p>How does the pattern support its objectives? What are the trade-offs and results of using the pattern? What does the design pattern objectify? What aspect of system structure does it allow to be varied independently?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implement at ion</head><p>What pitfalls, hints, or techniques should one be aware of when implementing the pattern? Are there language-specific issues? The following sections describe pattern jurisdictions in greater detai</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T h i s</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Class Jurisdiction</head><p>Class Creational. Creational patterns abstract how objects are ins for each antiated by hiding the specifics of the creation process. They are useful because it is often undesirable to specify a class name explicitly when instantiating an object. Doing so limits flexibility; it forces the programmer to commit to a particular class instead of a particular protocol. If one avoids hard-coding the class, then it becomes possible to defer class selection to run-time.</p><p>Creational class patterns in particular defer some part of object creation to subclasses. An example is the Factory Method, an abstract method that is called by a base class but defined in subclasses. The subclass methods create instances whose type depends on the subclass in which each method is implemented. In this way the base class does not hard-code the class name of the created object. Factory Methods are commonly used to instantiate members in base classes with objects created by subclasses.</p><p>For example, an abstract Application class needs to create applicationspecific documents that conform to the Document type. Application instantiates these Document objects by calling the factory method DoMakeDocument. This method is overridden in classes derived from Application. The subclass DrawApplication, say, overrides DoMakeDocument to return a DrawDocument object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Class Structural.</head><p>Structural class patterns use inheritance to compose protocols or code. As a simple example, consider using multiple inheritance to mix two or more classes into one. The result is an amalgamclass that unites the semantics of the base classes. This trivial pattern is quite useful in making independentlydeveloped class libraries work together <ref type="bibr" target="#b13">[15]</ref>.</p><p>Another example is the class-jurisdictional form of the Adapter pattern. In general, an Adapter makes one interface (the adaptee's) conform to another, thereby providing a uniform abstraction of different interfaces. A class Adapter accomplishes this by inheriting privately from an adaptee class. The Adapter then expresses its interface in terms of the adaptee's.</p><p>Class Behavioral. Behavioral class patterns capture how classes cooperate with their subclasses to fulfill their semantics. Template Method is a simple and well-known behavioral class pattern <ref type="bibr" target="#b30">[32]</ref>. Template methods define algorithms step by step. Each step can invoke an abstract method (which the subclass must define) or a base method. The purpose of a template method is to provide an abstract definition of an algorithm. The subclass must implement specific behavior to provide the services required by the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Object Jurisdiction</head><p>Object patterns all apply various forms of non-recursive object composition. Object composition represents the most powerful form of reusability-a collection of objects are most easily reused through variations on how they are composed rather than how they are subclassed.</p><p>Object Creational. Creational object patterns abstract how sets of objects are created. The Abstract Factory pattern (page 18) is a creational object pattern. It describes how to create "product" objects through an generic interface. Subclasses may manufacture specialized versions or compositions of objects as permitted by this interface. In turn, clients can use abstract factories to avoid making assumptions about what classes to instantiate. Factories can be composed to create larger factories whose structure can be modified at run-time to change the semantics of object creation. The factory may manufacture a custom composition of instances, a shared or one-of-a-kind instance, or anything else that can be computed at run-time, so long as it conforms to the abstract creation protocol.</p><p>For example, consider a user interface toolkit that provides two types of scroll bars, one for Motif and another for Open Look. An application programmer may not want to hard-code one or the other into the application-the choice of scroll bar will be determined by, say, an environment variable. The code that creates the scroll bar can be encapsulated in the class Kit, an abstract factory that abstracts the specific type of scroll bar to instantiate. Kit defines a protocol for creating scroll bars and other user interface elements. Subclasses of Kit redefine operations in the protocol to return specialized types of scroll bars. A MotifKit's scroll bar operation would instantiate and return a Motif scroll bar, while the corresponding OpenLookKit operation would return an Open Look scroll bar.</p><p>Object Structural. Structural object patterns describe ways to assemble objects to realize new functionality. The added flexibility inherent in object composition stems from the ability to change the composition at run-time, which is impossible with static class composition4.</p><p>Proxy is an example of a structural object pattern. A proxy acts as a convenient surrogate or placeholder for another object. A proxy oan be used as a local representative for an object in a different address space (remote proxy), to represent a large object that should be loaded on demand (virtual proxy), or to protect access to the original object (protected proxy). Proxies provide a level of indirection to particular properties of objects. Thus they can restrict, enhance, or alter an object's properties.</p><p>The Flyweight pattern is concerned with object sharing. Objects are shared for at least two reasons: efficiency and consistency. Applications that use large quantities of objects must pay careful attention to the cost of each object. Substantial savings can accrue by sharing objects instead of replicating them. However, objects can only be shared if they do not define context-dependent state. Flyweights have no context-dependent state. Any additional information they need to perform their task is passed to them when needed. With no contextdependent state, flyweights may be shared freely. Moreover, it may be necessary to ensure that all copies of an object stay consistent when one of the copies changes. Sharing provides an automatic way to maintain this consistency.</p><p>Object Behavioral. Behavioral object patterns describe how a group of peer objects cooperate to perform a task that no single object can carry out by itself. For example, patterns such as Mediator and Chain of Responsibility abstract control flow. They call for objects that exist solely to redirect the flow of messages. The redirection may simply notify another object, or it may involve complex computation and buffering. The Observer pattern abstracts the synchronization of state or behavior. Entities that are co-dependent to the extent that their state must remain synchronized may exploit Observer. The classic example is the model-view pattern, in which multiple views of the model are notified whenever the model's state changes.</p><p>The Strategy pattern (page 21) objectifies an algorithm. For example, a text composition object may need to support different line breaking algorithms. It is infeasible to hard-wire all such algorithms into the text composition class and subclasses. An alternative is to objectify different algorithms and provide them as Compositor subclasses. The interface for Compositors is defined by the abstract Compositor class, and its derived classes provide different layout strategies, such as simple line breaks or full page justification. Instances of the Compositor subclasses can be coupled with the text composition at run-time to provide the appropriate text layout. Whenever a text composition has to find line breaks, it forwards this responsibility to its current Compositor object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Compound Jurisdiction</head><p>In contrast to patterns having object jurisdiction, which concern peer objects, patterns with compound jurisdiction affect recursive object structures.</p><p>Compound Creational. Creational compound patterns are concerned with the creation of recursive object structures. An example is the Builder pattern. A Builder base class defines a generic interface for incrementally constructing recursive object structures. The Builder hides details of how objects in the structure are created, represented, and composed so that changing or adding a new representation only requires defining a new Builder class. Clients will be unaffected by changes to Builder.</p><p>Consider a parser for the RTF (Rich Text Format) document exchange format that should be able to perform multiple format conversions. The parser might convert RTF documents into (1) plain ASCII text and ( <ref type="formula">2</ref>) a text object that can be edited in a text viewer object. The problem is how to make the parser independent of these different conversions.</p><p>The solution is to create an RTFReader class that takes a Builder object as an argument. The RTFReader knows how to parse the RTF format and notifies the Builder whenever it recognizes text or an RTF control word. The builder is responsible for creating the corresponding data structure. It separates the parsing algorithm from the creation of the structure that results from the parsing process. The parsing algorithm can then be reused to create any number of different data representations. For example, an ASCII builder ignores all notifications except plain text, while a Text builder uses the notifications to create a more complex text structure.</p><p>Compound Structural. Structural compound patterns capture techniques for structuring recursive object structures. A simple example is the Composite pattern. A Composite is a recursive composition of one or more other Composites.</p><p>A Composite treats multiple, recursively composed objects as a single object.</p><p>The Wrapper pattern (page 24) describes how to flexibly attach additional properties and services to an object. Wrappers can be nested recursively and can therefore be used to compose more complex object structures. For example, a Wrapper containing a single user interface component can add decorations such as borders, shadows, scroll bars, or services like scrolling and zooming. To do this, the Wrapper must conform to the interface of its wrapped component and forward messages to it. The Wrapper can perform additional actions (such as drawing a border around the component) either before or after forwarding a message.</p><p>Compound Behavioral. Finally, behavioral compound patterns deal with behavior in recursive object structures. Iteration over a recursive structure is a common activity captured by the Iterator pattern. Rather than encoding and distributing the traversal strategy in each class in the structure, it can be extracted and implemented in an Iterator class. Iterators objectify traversal algorithms over recursive structures. Different iterators can implement pre-order, in-order, or post-order traversals. All that is required is that nodes in the structure provide services to enumerate their sub-structures. This avoids hard-wiring traversal algorithms throughout the classes of objects in a composite structure. Iterators may be replaced at run-time to provide alternative traversals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experience with Design Patterns</head><p>We have applied design patterns to the design and construction of a several systems. We briefly describe two of these systems and our experience.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">ET+ + S wapsManager</head><p>The ET++SwapsManager [lo] is a highly interactive tool that lets traders value, price, and perform what-if analyses for a financial instrument called a swap. During this project the developers had to first learn the ET++ class library, then implement the tool, and finally design a framework for creating "calculation engines" for different financial instruments. While teaching ET++ we emphasized not only learning the class library but also describing the applied design patterns. We noticed that design patterns reduced the effort required to learn ET++. Patterns also proved helpful during development in design and code reviews. Patterns provided a common vocabulary to discuss a design. Whenever we encountered problems in the design, patterns helped us explore design alternatives and find solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2</head><p>QOCA (Quadratic Optimization Constraint Architecture) <ref type="bibr">[14,</ref> 151 is a new object-oriented constraint-solving toolkit developed at IBM Research. QOCA leverages recent results in symbolic computation and geometry to support efficient incremental and interactive constraint manipulation. QOCA's architecture is designed to be flexible. It permits experimentation with different classes of constraints and domains (e.g., reals, booleans, etc.), different constraint-solving algorithms for these domains, and different representations (doubles, infinite precision) for objects in these domains. QOCA's object-oriented design allows parts of the system to be varied independently of others. This flexibility was achieved, for example, by using Strategy patterns to factor out constraint solving algorithms and Bridges to factor out domains and representations of variables. In addition, the Observable pattern is used to propagate notifications when variables change their values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>QOCA: A Constraint Solving Toolkit</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Summary of Observations</head><p>The following points summarize the major observations we have made while applying design patterns:</p><p>-Design patterns motivate developers to go beyond concrete objects; that is, they objectify concepts that are not immediately apparent as objects in the problem domain. -Choosing intuitive class names is important but also difficult. We have found that design patterns can help name classes. In the ET++SwapsManager's calculation engine framework we encoded the name of the design pattern in the class name (for example CalculationStrategy or TableAdaptor). This convention results in longer class names, but it gives clients of these classes a hint about their purpose.</p><p>-We often apply design patterns aftel. the first implementation of an architecture to improve its design. For example, it is easier to apply the Strategy pattern after the initial implementation to create objects for more abstract notions like a calculation engine or constraint solver. Patterns were also used as targets for class refactorings. We often find ourselves saying, "Make this part of a class into a Strategy," or, "Let's split the implementation portion of this class into a Bridge." -Presenting design patterns together with examples of their application turned out to be an effective way to teach object-oriented design by example.</p><p>-An important issue with any reuse technology is how a reusable component can be adapted to create a problem-specific component. Design patterns are particularly suited to reuse because they are abstract. Though a concrete class structure may not be reusable, the design pattern underlying it often is.</p><p>-Design patterns also reduce the effort required to learn a class library. Each class library has a certain design "culture" characterized by the set of patterns used implicitly by its developers. A specific design pattern is typically reused in different places in the library. A client should therefore learn these patterns as a first step in learning the library. Once they are familiar with the patterns, they can reuse this understanding. Moreover, because some patterns appear in other class libraries, it is possible to reuse the knowledge about patterns when learning other libraries as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>Design patterns are an approach to software reuse. Krueger [20] introduces the following taxonomy to characterize different reuse approaches: software component reuse, software schemas, application generators, transformation systems, and software architectures. Design patterns are related to both software schemas and reusable software architectures. Software schemas emphasize reusing abstract algorithms and data structures. These abstractions are represented formally so they can be instantiated automatically. The Paris system <ref type="bibr" target="#b16">[18]</ref> is representative of schema technology. Design patterns are higher-level than schemas; they focus on design structures at the level of collaborating classes and not at the algorithmic level. In addition, design patterns are not formal descriptions and cannot be instantiated directly. We therefore prefer to view design patterns as reusable software architectures. However, the examples Krueger lists in this category (blackboard architectures for expert systems, adaptable database subsystems) are all coarse-grained architectures. Design patterns are finer-grained and therefore can be characterized as reusable micro-architectures. Most research into patterns in the software engineering community has been geared towards building knowledge-based assistants for automating the appli-cation of patterns for synthesis (that is, to write programs) and analysis (in debugging, for example) [13, 241. The major difference between our work and that of the knowledge-based assistant community is that design patterns encode higher-level expertise. Their work has tended to focus on patterns like enumeration and selection, which can be expressed directly as reusable components in most existing object-oriented languages. We believe that characterizing and cataloging higher-level patterns that designers already use informally has an immediate benefit in teaching and communicating designs.</p><p>A common approach for reusing object-oriented software architectures are object-oriented frameworks <ref type="bibr" target="#b30">[32]</ref>. A framework is a codified architecture for a problem domain that can be adapted to solve specific problems. A framework makes it possible to reuse an architecture together with a partial concrete implementation. In contrast to frameworks, design patterns allow only the reuse of abstract micro-architectures without a concrete implementation. However, design patterns can help define and develop frameworks. Mature frameworks usually reuse several design patterns. An important distinction between frameworks and design patterns is that frameworks are implemented in a programming language. Our patterns are ways of using a programming language. In this sense frameworks are more concrete than design patterns.</p><p>Design patterns are also related to the idioms introduced by Coplien [7]. These idioms are concrete design solutions in the context of C++. Coplien "focuses on idioms that make C++ programs more expressive." In contrast, design patterns are more abstract and higher-level than idioms. Patterns try to abstract design rather than programming techniques. Moreover, design patterns are usually independent of the implementation language.</p><p>There has been interest recently within the object-oriented community <ref type="bibr" target="#b5">[8]</ref> in pattern languages for the architecture of buildings and communities as advocated by Christopher Alexander in The Timeless Way of Building [2]. Alexander's patterns consist of three parts:</p><p>-A context that describes when a pattern is applicable.</p><p>-The problem (or "system of conflicting forces") that the pattern resolves in -A configuration that describes physical relationships that solve the problem.</p><p>Both design patterns and Alexander's patterns share the notion of context/problem/configuration, but our patterns currently do not form a complete system of patterns and so do not strictly define a pattern language. This may be because object-oriented design is still a young technology-we may not have had enough experience in what constitutes good design to extract design patterns that cover all phases of the design process. Or this may be simply because the problems encountered in software design are different from those found in architecture and are not amenable to solution by pattern languages.</p><p>Recently, Johnson has advocated pattern languages to describe how to use use object-oriented frameworks <ref type="bibr" target="#b14">[16]</ref>. Johnson uses a pattern language to explain how to extend and customize the Hotdraw drawing editor framework. However, that context. these patterns are not design patterns; they are more descriptions of how to reuse existing components and frameworks instead of rules for generating new designs.</p><p>Coad's recent paper on object-oriented patterns [6] is also motivated by Alexander's work but is more closely related to our work. The paper has seven patterns: "Broadcast" is the same as Observer, but the other patterns are different from ours. In general, Coad's patterns seem to be more closely related to analysis than design. Design patterns like Wrapper and Flyweight are unlikely to be generated naturally during analysis unless the analyst knows these patterns well and thinks in terms of them. Coad's patterns could naturally arise from a simple attempt to model a problem. In fact, it is hard to see how any large model could avoid using patterns like "State Across a Collection" (which explains how to use aggregation) or "Behavior Across a Collection" (which describes how to distribute responsibility among objects in an aggregate). The patterns in our catalog are typical of a mature object-oriented design, one that has departed from the original analysis model in an attempt to make a system of reusable objects. In practice, both types of patterns are probably useful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Design patterns have revolutionized the way we think about, design, and teach object-oriented systems. We have found them applicable in many stages of the design process-initial design, reuse, refactoring. They have given us a new level of abstraction for system design.</p><p>New levels of abstraction often afford opportunities for increased automation. We are investigating how interactive tools can take advantage of design patterns. One of these tools lets a user explore the space of objects in a running program and watch their interaction. Through observation the user may discover existing or entirely new patterns; the tool lets the user record and catalog his observations. The user may thus gain a better understanding of the application, the libraries on which it is based, and design in general.</p><p>Design patterns may have an even more profound impact on how objectoriented systems are designed than we have discussed. Common to most patterns is that they permit certain aspects of a system to be varied independently. This leads to thinking about design in terms of "What aspect of a design should be variable?" Answers to this question lead to certain applicable design patterns, and their application leads subsequently to modification of a design. We refer to this design activity as variation-oriented design and discuss it more fully in the catalog of patterns <ref type="bibr" target="#b9">[12]</ref>.</p><p>But some caveats are in order. Design patterns should not be applied indiscriminately. They typically achieve flexibility and variability by introducing additional levels of indirection and can therefore complicate a design. A design pattern should only be applied when the flexibility it affords is actually needed. The consequences described in a pattern help determine this. Moreover, one is often tempted to brand any new programming trick a new design pattern. A true design pattern will be non-trivial and will have had more than one application.</p><p>We hope t h a t the design patterns described in this paper and in the companion catalog will provide t h e object-oriented community both a common design terminology a n d a repertoire of reusable designs. Moreover, we hope the catalog will motivate others t o describe their systems in terms of design patterns and develop their own design patterns for others t o reuse. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Catalog Overview</head><p>The following summarizes the patterns in our current catalog.</p><p>Abstract Factory provides an interface for creating generic product objects. It removes dependencies on concrete product classes from clients that create product objects. Adapter makes the protocol of one class conform to the protocol of another. Bridge separates an abstraction from its implementation. The abstraction may vary its implementations transparently and dynamically. Builder provides a generic interface for incrementally constructing aggregate objects.</p><p>A Builder hides details of how objects in the aggregate are created, represented, and composed. Command objectifies the request for a service. It decouples the creator of the request for a service from the executor of that service. Composite treats multiple, recursively-composed objects as a single object. Chain of Responsibility defines a hierarchy of objects, typically arranged from more specific to more general, having responsibility for handling a request. Factory Method lets base classes create instances of subclass-dependent objects. Flyweight defines how objects can be shared. Flyweights support object abstraction Glue defines a single point of access to objects in a subsystem. It provides a higher Interpreter defines how to represent the grammar, abstract syntax tree, and inter-Iterator objectifies traversal algorithms over object structures. Mediator decouples and manages the collaboration between objects. Memento opaquely encapsulates a snapshot of the internal state of an object and is used to restore the object t o its original state. Observer enforces synchronization, coordination, and consistency constraints between objects. Prototype creates new objects by cloning a prototypical instance. Prototypes permit clients to install and configure dynamically the instances of particular classes they need to instantiate.</p><p>Proxy acts as a convenient surrogate or placeholder for another object. Proxies can restrict, enhance, or alter an object's properties. Solitaire defines a one-of-a-kind object that provides access t o unique or well-known services and variables. State lets an object change its behavior when its internal state changes, effectively changing its class. Strategy objectifies an algorithm or behavior. Template Method implements an abstract algorithm, deferring specific steps to sub-Walker centralizes operations on object structures in one class so that these opera-Wrapper attaches additional services, properties, or behavior t o objects. Wrappers at the finest granularity. level of encapsulation for objects in the subsystem.</p><p>preter for simple languages. class methods.</p><p>tions can be changed independently of the classes defining the structure. can be nested recursively to attach multiple properties to objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ABSTRACT FACTORY Object Creational</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intent</head><p>Abstract Factory provides an interface for creating generic product objects. It removes dependencies on concrete product classes from clients that create product objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation</head><p>Consider a user interface toolkit that supports multiple standard look-and-feels, say, Motif and Open Look, and provides different scroll bars for each. It is undesirable t o hard-code dependencies on either standard into the application-the choice of look-and-feel and hence scroll bar may be deferred until run-time. Specifying the class of scroll bar limits flexibility and reusability by forcing a commitment to a particular class instead of a particular protocol. An Abstract Factory avoids this commitment.</p><p>An abstract base class WindowKit declares services for creating scroll bars and other controls. Controls for Motif and Open Look are derived from common abstract classes. For each look-and-feel there is a concrete subclass of WindowKit that defines services to create the appropriate control. For example, the Create-ScrollBarO operation on the MotifKit would instantiate and return a Motif scroll bar, while the corresponding operation on the OpenLookKit returns an Open Look scroll bar. Clients access a specific kit through the interface declared by the Win-dowKit class, and they access the controls created by a kit only by their generic interface.  <ref type="figure">L---------------</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CreaieSmU&amp;o</head><formula xml:id="formula_0">-</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applicability</head><p>When the classes of the product objects are variable, and dependencies on these classes must be removed from a client application.</p><p>When variations on the creation, composition, or representation of aggregate objects or subsystems must be removed from a client application. Differences in configuration can be obtained by using different concrete factories. Clients do not explicitly create and configure the aggregate or subsystem but defer this responsibility to an AbstractFactory class. Clients instead call a method of the Abstract-Factory that returns an object providing access to the aggregate or subsystem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Participants 0 Abstract Fac t ory</head><p>declares a generic interface for operations that create generic product objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">ConcreteFactory</head><p>defines the operations that create specific product objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">GenericProduct</head><p>declares a generic interface for product objects.</p><p>0 SpecificProduct</p><p>defines a product object created by the corresponding concrete factory.</p><p>all product classes must conform to the generic product interface. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences</head><p>Abstract Factory provides a focus during development for changing and controlling the types of objects created by clients. Because a factory objectifies the responsibility for and the process of creating product objects, it isolates clients from implementation classes. Only generic interfaces are visible to clients. Implementation class names do not appear in client code. Clients can be defined and implemented solely in terms of protocols instead of classes.</p><p>Abstract factories that encode class names in operation signatures can be difficult to extend with new kinds of product objects. This can require redeclaring the AbstractFactory and all ConcreteFactories. Abstract factories can be composed with subordinate factory objects. Responsibility for creating objects is delegated to these sub-factories. Composition of abstract factories provides a simple way to extend the kinds of objects a factory is responsible for creating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples</head><p>Interviews uses the "Kit" suffix <ref type="bibr" target="#b19">[21]</ref> to denote abstract factory classes. It defines WidgetKit and DialogKit abstract factories for generating look-and-feel-specific user interface objects. Interviews also includes a LayoutKit that generates different composition objects depending on the layout desired.</p><p>ET++ <ref type="bibr" target="#b29">[31]</ref> employs the Abstract Factory pattern to achieve portability across different window systems (X Windows and SunView, for example). The Win-dowSystem abstract base class defines the interface for creating objects representing window system resources (for example, Makewindow, MakeFont, Makecolor). Concrete subclasses implement the interfaces for a specific window system. At runtime ET++ creates an instance of a concrete Windowsystem subclass that creates system resource objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementat ion</head><p>A novel implementation is possible in Smalltalk. Because classes are first-class objects, it is not necessary to have distinct ConcreteFactory subclasses to create the variations in products. Instead, it is possible to store classes that create these products in variables inside a concrete factory. These classes create new instances on behalf of the concsete factory. This technique permits variation in product objects at finer levels of granularity than by using distinct concrete factories. Only the classes kept in variables need to be changed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>See Also</head><p>Factory Method: Abstract Factories are often implemented using Factory Methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>STRATEGY Object Behavioral</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intent</head><p>A Strategy objectifies an algorithm or behavior, allowing the algorithm or behavior to be varied independently of its clients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation</head><p>There are many algorithms for breaking a text stream into lines. It is impossi- -SimpleCompositor implements a simple strategy that determines line -TeXCompositor implements the w a l g o r i t h m for finding line breaks. This strategy tries to optimize line breaks globally, that is, one paragraph at a time.</p><p>-Arraycompositor implements a strategy that is used not for text but for breaking a collection of icons into rows. It selects breaks so that each row has a fixed number of items. Whenever an algorithm or behavior should be selectable and replaceable at runtime, or when there exist variations in the implementation of the algorithm, reflecting different space-time tradeoffs, for example.</p><p>Use a Strategy whenever many related classes differ only in their behavior. Strategies provide a way to configure a single class with one of many behaviors.</p><p>breaks one at a time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applicability Participants</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Strategy</head><p>objectifies and encapsulates an algorithm or behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>StrategyContext</head><p>maintains a reference to a Strategy object.</p><p>maintains the state manipulated by the Strategy.</p><p>can be configured by passing it an appropriate Strategy object. Variations on an algorithm can also be implemented with inheritance, that is, with an abstract class and subclasses that implement different behaviors. However, this hard-wires the implementation into a specific class; it is not possible to change behaviors dynamically. This results in many related classes that differ only in some behavior. It is often better to break out the variations of behavior into their own classes. The Strategy pattern thus increases modularity by localizing complex behavior. The typical alternative is to scatter conditional statements throughout the code that select the behavior to be performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Collaborations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation</head><p>The interface of a Strategy and the common functionality among Strategies is often factored out in an abstract class. Strategies should avoid maintaining state across invocations so that they can be used repeatedly and in multiple contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples</head><p>In the RTL System for compiler code optimization <ref type="bibr" target="#b15">[17]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>See Also</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>WRAPPER Compound Structural</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intent</head><p>A Wrapper attaches additional services, properties, or behavior to objects. W r a p pers can be nested recursively to attach multiple properties to objects.</p><p>Sometimes it is desirable to attach properties to individual objects instead of classes. In a graphical user interface toolkit, for example, properties such as borders or services like scrolling should be freely attachable to any user interface component.</p><p>One way to attach properties to components is via inheritance. Inheriting a border from a base class will give all instances of its derived classes a border. This is inflexible because the choice of border is made statically. It is more flexible to let a client decide how and when to decorate the component with a border.</p><p>This can be achieved by enclosing the component in another object that adds the border. The enclosing object, which must be transparent to clients of the component, is called a Wrapper. This transparency is the key for nesting W r a p pers recursively to construct more complex user interface components. A Wrapper forwards requests to its enclosed user interface component. The Wrapper may perform additional actions before or after forwarding the request, such as drawing a border around a user interface component.</p><p>Typical properties or services provided by user interface Wrappers are:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation</head><p>decorations like borders, shadows, or scroll bars; or services like scrolling or zooming.</p><p>The following diagram illustrates the composition of a TextView with a Border-Wrapper and a Scrollwrapper to produce a bordered, scrollable Textview.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(Textview)</head><p>f ==l</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applicability</head><p>When properties or behaviors should be attachable to individual objects dynamically and transparently.</p><p>When there is a need to extend classes in an inheritance hierarchy. Rather than modifying their base class, instances are enclosed in a Wrapper that adds the additional behavior and properties. Wrappers thus provide an alternative to ex- tending the base class without requiring its modification. This is of particular concern when the base class comes from a class library that cannot be modified.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>T</head><label></label><figDesc>h e authors wish t o thank Doug Lea a n d Kent Beck for detailed comments a n d discussions about this work, a n d Bruce Anderson a n d the participants of the Architecture Handbook workshops a t OOPSLA '91 a n d '92.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Collaborations00</head><label></label><figDesc>Usually a single instance of a ConcreteFactory class is created at run-time. This concrete factory creates product objects having a particular implementation. To use different product objects, clients must be configured to use a different concrete factory. AbstractFactory defers creation of product objects to its ConcreteFactory sub-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>A</head><label></label><figDesc>Composition maintains a reference to a Compositor object. Whenever a Composition is required to find line breaks, it forwards this responsibility to its current Compositor object. The client of Composition specifies which Compositor should be used by installing the corresponding Compositor into the Composition (see the diagram below).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>b</head><label></label><figDesc>Strategy manipulates the Strategycontext. The StrategyContext normally passes itself as an argument to the Strategy's methods. This allows the Strategy to call back the StrategyContext as required. b Strategycontext forwards requests from its clients to the Strategy. Usually clients pass Strategy objects to the StrategyContext. Thereafter clients only interact with the StrategyContext. There is often a family of Strategy classes from which a client can choose. a family of policies that a StrategyContext can reuse. Separating a Strategy from its context increases reusability, because the Strategy may vary independently from the StrategyContext.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>See Also Fig. 1. Basic Design Pattern Template class</head><label></label><figDesc>jurisdiction covers static semantics. The object jurisdiction concerns relationships between peer objects. Patterns having compound jurisdiction deal</figDesc><table><row><cell>with recursive object structures. Some patterns capture concepts that span juris-</cell></row><row><cell>dictions. For example, iteration applies both to collections of objects (i.e., object</cell></row><row><cell>jurisdiction) and to recursive object structures (compound jurisdiction). Thus</cell></row><row><cell>there are both object and compound versions of the Iterator pattern.</cell></row><row><cell>Characterization reflects what a pattern does. Patterns can be characterized</cell></row><row><cell>as either creational, structural, or behavioral. Creational patterns concern</cell></row><row><cell>the process of object creation. Structural patterns deal with the composition of</cell></row><row><cell>classes or objects. Behavioral patterns characterize the ways in which classes or</cell></row><row><cell>objects interact and distribute responsibility.</cell></row><row><cell>characterization using examples from our catalog.</cell></row><row><cell>section presents examples from real systems. We try to include at least two</cell></row><row><cell>examples from different domains.</cell></row><row><cell>What design patterns have closely related intent? What are the important dif-</cell></row><row><cell>ferences? With which other patterns should this one be used?</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>ble to hard-wire all such algorithms into the classes that require them. Different algorithms might be appropriate at different times.One way t o address this problem is by defining separate classes that encapsulate the different linebreaking algorithms. An algorithm objectified in this way is called a Strategy. Interviews[22] and ET++ [31] use this approach. Suppose a Composition class is responsible for maintaining and updating the line breaks of text displayed in a text viewer. Linebreaking strategies are not implemented by the class Composition. Instead, they are implemented separately by subclasses of the Compositor class. Compositor subclasses implement different strategies as follows:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>, Strategies define different register allocation schemes (RegisterAllocator) and different instruction set scheduling policies (RISCscheduler, CISCscheduler). This gives flexibility in targeting the optimizer for different machine architectures. The ET++SwapsManager calculation engine framework [lo] computes prices for different financial instruments. Its key abstractions are Instrument and Yield-Curve. Different instruments are implemented as subclasses of Instrument. The Yieldcurve calculates discount factors to present value future cash flows. Both of these classes delegate some behavior to Strategy objects. The framework provides a family of Strategy classes that define algorithms to generate cash flows, to value swaps, and to calculate discount factors. New calculation engines are created by parameterizing Instrument and Yieldcurve with appropriate Strategy objects. This approach supports mixing and matching existing Strategy implementations while permitting the definition of new Strategy objects.Walker often implements algorithms over recursive object structures. Walkers can be considered compound strategies.</figDesc><table /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Participants 0 Component</head><p>the object to which additional properties or behaviors are attached. 0 Wrapper encapsulates and enhances its Component. It defines an interface that conforms to its Component's.</p><p>-Wrapper maintains a reference to its Component. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>See Also</head><p>Adapter: A Wrapper is different from an Adapter, because a Wrapper only changes an object's properties and not its interface; an Adapter will give an object a completely ;Lew interface.</p><p>Composite: A Wrapper can be considered a degenerate Composite with only one component. However, a Wrapper adds additional services-it is not intented for object aggregation.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The role of domain experience in software design</title>
		<author>
			<persName><forename type="first">B</forename><surname>Adelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Soloway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1351" to="1360" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Alexander</surname></persName>
		</author>
		<title level="m">The Timeless W a y of Building</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A laboratory for teaching object-oriented thinking</title>
	</analytic>
	<monogr>
		<title level="m">Addendum to the Proceedings, Object-Oriented Programming Systems, Languages, and Applications Conference, Vancouver</title>
		<meeting><address><addrLine>Phoenix, AZ; British Columbia; New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1989-10">October 1991. October 1992. October 1989</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
	<note>Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Object-oriented patterns</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Coad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="152" to="159" />
			<date type="published" when="1992-09">September 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><surname>Addison-Wesley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<pubPlace>Reading, Massechusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Constructing abstractions for object-oriented applications</title>
		<author>
			<persName><forename type="first">Ward</forename><surname>Cunningham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><surname>Beck</surname></persName>
		</author>
		<idno>CR-87-25</idno>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Tektronix, Inc</publisher>
		</imprint>
		<respStmt>
			<orgName>Computer Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Cognitive issues in reusing software artifacts</title>
		<author>
			<persName><forename type="first">Bill</forename><surname>Curtis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Reusability</title>
		<editor>
			<persName><forename type="first">Ted</forename><forename type="middle">J</forename><surname>Biggerstaff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alan</forename><forename type="middle">J</forename><surname>Perlis</surname></persName>
		</editor>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="269" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The ET++SwapsManager: Using object technology in the financial engineering domain</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eggenschwiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erich</forename><surname>Gamma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings</title>
		<meeting><address><addrLine>Vancouver, British Columbia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-10">October 1992</date>
			<biblScope unit="page" from="166" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Objektorientierte Software-Entwicklung a m Beispiel uon ET++: Design-Muster, Klassenbibliothek, Werkzeuge</title>
		<author>
			<persName><forename type="first">Erich</forename><surname>Gamma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A catalog of object-oriented design patterns</title>
		<author>
			<persName><forename type="first">Erich</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralph</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>IBM Research Division</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>in preparation</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Advanced C+f Programming Styles and Idioms</title>
		<author>
			<persName><forename type="first">Kent</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ward</forename><surname>Cunningham</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Software design using reusable algorithm abstraction</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mehdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><forename type="middle">H</forename><surname>Harandi</surname></persName>
		</author>
		<author>
			<persName><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd IEEE/BCS Conf. on Software Engineering</title>
		<meeting>2nd IEEE/BCS Conf. on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="94" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A linear constraint technology for user interfaces</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Lasses</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graphics Interface</title>
		<meeting><address><addrLine>British Columbia</addrLine></address></meeting>
		<imprint>
			<publisher>Vancouver</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="301" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An object-oriented architecture for constraint-based graphical editing</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Vlissides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Eurographics Workshop on Object-Oriented Graphics</title>
		<meeting>the Third Eurographics Workshop on Object-Oriented Graphics</meeting>
		<imprint>
			<publisher>ChampCry, Switzerland</publisher>
			<date type="published" when="1992-10">October 1992</date>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
	<note>Also available as IBM Research Division Technical Report RC 18524</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Documenting frameworks using patterns</title>
		<author>
			<persName><forename type="first">Ralph</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings</title>
		<meeting><address><addrLine>Vancouver, BC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-10">October 1992</date>
			<biblScope unit="page" from="63" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The RTL system: A framework for code optimization</title>
		<author>
			<persName><forename type="first">Ralph</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Mcconnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Michael</forename><surname>Lake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Code Generation-Concepts, Tools, Techniques. Proceedings of the International Workshop on Code Generation</title>
		<editor>
			<persName><forename type="first">Robert</forename><surname>Giegerich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Susan</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</editor>
		<meeting><address><addrLine>Dagstuhl, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="255" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A system for reusing partially interpreted schemas</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-S</forename><surname>The</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Ninth International Conference on Software Engineering</title>
		<meeting>of the Ninth International Conference on Software Engineering<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A cookbook for using the model-view controller user interface paradigm in Smalltalk-80</title>
		<author>
			<persName><forename type="first">Glenn</forename><forename type="middle">E</forename><surname>Krasner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">T</forename><surname>Pope</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object-Oriented Programming</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="26" to="49" />
			<date type="published" when="1988-09">August/September 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Software reuse</title>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">W</forename><surname>Krueger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Encapsulating a C++ library</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><surname>Linton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 199% USENIX C++ Conference</title>
		<meeting>the 199% USENIX C++ Conference<address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-08">August 1992</date>
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Composing user interfaces with Interviews</title>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">A</forename><surname>Linton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">M</forename><surname>Vlissides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">R</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="8" to="22" />
			<date type="published" when="1989-02">February 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Refactoring: An aid in designing application frameworks and evolving object-oriented systems</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">F</forename><surname>Opdyke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralph</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOOPPA Conference Proceedings</title>
		<meeting><address><addrLine>Marist College, Poughkeepsie, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-09">September 1990</date>
			<biblScope unit="page" from="145" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Formalizing reusable software components in the programmer&apos;s apprentice</title>
		<author>
			<persName><forename type="first">Charles</forename><surname>Rich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">C</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Reusability</title>
		<editor>
			<persName><forename type="first">Ted</forename><forename type="middle">J</forename><surname>Biggerstaff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alan</forename><forename type="middle">J</forename><surname>Perlis</surname></persName>
		</editor>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="313" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Object-Oriented Modeling and Design</title>
		<author>
			<persName><forename type="first">James</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Blaha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Premerlani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederick</forename><surname>Eddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Lorenson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Englewood Cliffs</publisher>
			<pubPlace>New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Empirical studies of programming knowledge</title>
		<author>
			<persName><forename type="first">Elliot</forename><surname>Soloway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kate</forename><surname>Ehrlich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Tronsactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="1984-09">September 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Novice mistakes: Are the folk wisdoms correct?</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Spohrer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elliot</forename><surname>Soloway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="624" to="632" />
			<date type="published" when="1992-07">July 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">ParcPlace Systems, Objectworks/Smalltalk Release 4 Users Guide</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>ParcPlace Systems</publisher>
			<pubPlace>Mountain View, California</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Self: The power of simplicity</title>
		<author>
			<persName><forename type="first">David</forename><surname>Ungar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Randall</forename><forename type="middle">B</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings</title>
		<meeting><address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-10">October 1987</date>
			<biblScope unit="page" from="227" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Unidraw: A framework for building domain-specific graphical editors</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">M</forename><surname>Vlissides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">A</forename><surname>Linton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A CM Transactions on Information Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="237" to="268" />
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A survey of current research in object-oriented design</title>
		<author>
			<persName><forename type="first">Andre</forename><surname>Weinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erich</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rudolf</forename><surname>Marty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-09">September 1988. 1990</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="104" to="124" />
		</imprint>
	</monogr>
	<note>ET++-An object-oriented application framework in C++</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Rebecca</forename><surname>Wirfs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-</forename><surname>Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralph</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
