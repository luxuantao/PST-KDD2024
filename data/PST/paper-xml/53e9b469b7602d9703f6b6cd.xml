<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SOME RESULTS AND EXPERIMENTS IN PROGRAMMING TECHNIQUES FOR PROPOSITIONAL LOGIC</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>J~~ostowf</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Business Admmistration</orgName>
								<orgName type="institution">University of Iifinois</orgName>
								<address>
									<postCode>61820</postCode>
									<settlement>Champaign</settlement>
									<region>IL</region>
									<country>U.S</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">College of Management and School of Industrial and Systems Engineering</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<postCode>30332</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SOME RESULTS AND EXPERIMENTS IN PROGRAMMING TECHNIQUES FOR PROPOSITIONAL LOGIC</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2163C14B3E253E65E55D1C0D15F53DE5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>LMDGANC</term>
					<term>Maxwell AFB</term>
					<term>Montgomery</term>
					<term>AL 36112. U.S.A</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Scope and Purpose-We develop interconnections between Artificial Intelligence and Operations Research by establishing results which relate an extension of traditional integer programming approaches for propositional Iogic to very efficient theorem-proving techniques for this logic. This logic is adequate far developing many expert systems, either direct&amp;, or Ga reductions of a fragment of predicate logic to pro~sitionai logic.</p><p>The paper is written for an Operations Research audience, and it includes a review of relevant aspects of logic and theorem-proving.</p><p>In addition, we provide a technique for eficiently reducing general propositions to clausal form, and we give special results for Horn format production rules which occur in many applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>We pravide some results which relate mathematical programming (MP) techniques for treating propositional logic [l], to the Davis-Putnam procedure from theorem proving (TP) <ref type="bibr" target="#b1">[2]</ref>. We alsa give a linear-time method for achieving a clausal form equivalent to a given proposition, using some additional letters. Some experimental results are included.</p><p>The algorithm DP of Davis and Putnam has been extensively researched in a number of papers. The DP algorithm is designed for the more complex and expressive predicate logic <ref type="bibr">[l]</ref>. In predicate logic, practical consensus favors algorithms which use resolution and unification techniques <ref type="bibr">[3-S]</ref> rather than the original "complete instantiation" approach of (unadapted) DP. However, DP remains an algorithm of choice for propositional logic. This paper is written for an Operation Research audience, where some review of basic Iogic and theorem-proving is appropriate in the exposition.</p><p>In Section 1, we will define propositional logic and give the conventional exponential~s~a~e reduction of a proposition to conjunctive normal form {cnf.), together with the new reduction. Comparisons between the two reductions will be given (Proposition 2.2 and Theorem 2.1).</p><p>We will recall how a proposition in cnf. can be represented by a {pure) integer program (IP). It will then be evident to the reader that, like the Moliere character who spoke prose but did not know it, IP has been used to do pro~sitional logic in c.n,f. form for some time. In fact, via mixed integer programming (MIP) one has had the ability to mix propositionat logic with linear constraints on continuous and integer variables, a mixture which goes beyond TP methods. We conclude Section 2 with some exampIes of the application of propositional logic.</p><p>In Section 3, we shall give two versions of the DP algorithm, and of a simple "clausal chaining" (CC) algorithm. We relate these three algorithms to the 'fP approach of mathematical programming and to each other (see Propositions 3.1, 3.2 and 3.3).</p><p>In Section 4, we will describe an experiment implemented in <ref type="bibr" target="#b5">[6]</ref> and give some computational results for the IP approach.</p><p>In our development for propositional Iogic, we will treat the conventional logic, rather than the "certainty factor" (CF) approach which is used in some settings of partial knowledge and inexact inference (as, for example, <ref type="bibr">[T-9]</ref>). However, a CF treatment is also possible by MIP <ref type="bibr">[lo]</ref>.</p><p>Let P,, . . . . P, be the letters which denote unanalysed atom&amp; ~ro~s~rio~~. In any specific applications context, the meaning of these propositions will be known. However, the focus here is on the laws which govern all theoretically possible truth value assignments; in this sense, the atomic propositions are "unanalysed"".</p><p>New propositions are formed from P, ( . . . , P, by repeated use of the pr~p~sir~u~al co~n~~t~~~.~ /2 ('and'), v ('or') and 1 ('not'). (Here the (nonexclusive) 'or' in, for example, P, v P, allows for the possibility that both P, and P2 hold, unlike the 'or' in some natural languages.) Thus if A and B are propositions, so are A A 8, A v B and 1A (or 13). The p~~~~~~ti#~~ are exactly the expressions generated in this way, starting from P,, . . . , P,. We afso use + A to denote A and -A to denote 1 A. The symbol ' v ' is a ~i~junct~oi~, while 'A ' is a co~#~c~~o~.</p><p>The s~~~r~~~~~ of a propostion or formula A are defined in the natural way. If, for example, AZ.41 v.,. v A, or if A = A, A . . . A A,, the subformulas of A are A and the subformulas of A,, . . .t A,. The subformulas of A = 1B are A and the subformulas of B.</p><p>The term It Pj for an atomic proposition Pj is called a l~terul; i.e. a literai is an atomic letter or its negation.</p><p>For any assignment of "truth values" T (for 'truth') or F (for 'false') to the atomic propositions P , f + . . i P,, one can quickly compute the truth value of a proposition A. (Such an assignment called a valuation.) We write a law o~pr~p~sit~~~ logic A = B to abbreviate the fact that A and B have the same truth value for atl valuations of P,, . . ., P,* When A E 8, we say that A and B are ~~~iv~~~#t. For example, 1 -t A = A, 1 (A v Bf SE 1 A A 13, and 7 (A A B) s 7 A v 7 B are laws of propositional iogic. (The Iatter two are called the "de Morgan Laws".)</p><p>A proposition A which is true for tafl valuations is called a &amp;~u~olog~~ a proposition which is true for some valuations is called s&amp;.$&amp;b. Thus A is a tautology exactly if fff is not satisfiable,</p><p>The foilowing are called distributive taws: in part (a), "v distributes across A ," while in part fb), "A distributes across v ". Here is an example of a finding conjunctive normal form, using Proposition 2.1, in steps: 4. (1 p, v P, v 1 PJ A D (note that P, v 7 P, is always true and can be removed).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DE(P,V</head><p>-lP,)A(P,V lP,v lP2)=P1v lP,.</p><p>6. (lp, v P, v ~P,)A (PI v lP,) is a c.n.f. for 1, using 4 and 5.</p><p>This distributive law process for obtaining a c.n.f. or d.n.f. can require super-exponential space, as well as time. For example, if one uses it to compute a c.n.f. for (P, A P,)v (P3 A P,)v . . . v (P2,_ i A Pz,) the typical conjunct Ai occurring has the form Picl,v Pit2)v.. . v P,,, where e(j) E (2j -1, 2jj and all c") &gt; 2% such conjuncts appear.</p><p>We next describe an algorithm CNF (adapted from <ref type="bibr" target="#b5">[6]</ref>) for obtaining a c.n.f. equivalent of a proposition A which uses additional atomic letters. * It will be seen to run in linear time on most models of computation. (The existence of a polynomial time reduction to c.n.f. is implicit in Cook's paper [ 111; the reduction we give is different from [ 1 l] and more compact.)</p><p>This algorithm CNF is recursive, and is applied iteratively from smaller to larger subformulas of a given formula A. First, for each such subformula, it constructs a list of clauses W(B) and a literal B' which represents B, as follows: In this manner, %(A) can be constructed for any formula A. Then the desired c.n.f. equivalent for A is the list of clauses %?(A) plus the one element clause A'.</p><p>For example, when A = (P, A Pz) v (P3 A P4), CNF first generates the systems K(B,) where B, = P, A P,:</p><p>-lP, v lP,vB\, P, v lB;, P, v 1I3;.</p><p>(3) _._.__ *Added in proof: The algorithm CNF is due to G. Tseitin.</p><p>The system V(B,) for B, = P, A P, is similarly generated. The system %'(A) consists of all clauses in '%Z(ls,) and %(B2), plus the clauses:</p><formula xml:id="formula_0">B; v B; v 1 A', 1 B; v A', 1B;VA'<label>(4)</label></formula><p>Then the cnf. equivalent for A consists of all clauses in %(A) plus the unit clause A'. By induction on the construction of a formula A, using the remarks given above in the description of CNF, one easily establishes the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2.2</head><p>When all clauses in V(A) hold, any truth valuation on Pi, . . . , P, yields unique truth valuations on the new letters introduced for the subformulas of A, such that the truth valuation for the letter A' is that of the proposition A. Conversely, for any truth valuation on P,, . . ., P,, and these new letters, which satisfies all clauses in %(A), the valuation restricted to P,, . . ., P, causes the proposition A to have the truth value of the letter A'.</p><p>We next discuss how we shall represent c.n.f. problems via integer programs (IP); our approach here will be standard (e.g. <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">Chap. 141)</ref>.</p><p>AclauseV,,,~Pjfor~#f~(l,.</p><p>. ., s&gt; is represented in IP by a single constraint where z(P1), . . . , z(P,) E { 0, l} are zero-one (i.e. binary) variables which have been introduced, and z( -Pj) abbreviates 1 -z(Pj). The same approach is used for clauses generated by CNF in the additional atomic letters. Clearly, with "1" corresponding to "T", and 0 corresponding to F, <ref type="bibr" target="#b4">(5)</ref> holds if VjeJ + Pi is true under the truth valuation. When a constraint ( <ref type="formula">5</ref>) is entered for each clause in a c.n.f. or a c.n.f. equivalent of A, then the resulting system has a binary solution iff A is satisfiable; and the set of all satisfying valuations corresponds to all binary solutions. We shall abbreviate (5) as z(VjcJ I_+ Pj) &gt; 1 for a clause VjoJ f Pj.</p><p>When the binary variables z(Pj) E { 0, I&gt; are relaxed to continuous variables z(Pj) E [0, 1 J, we have a linear relaxation (LR) of ( <ref type="formula">5</ref>). (Note that the LR contains constraints 0 &lt; z(Pj) d 1.) In branch-andbound (BB) approaches to IP (see <ref type="bibr" target="#b12">[13]</ref>), the LR is used in a crucial manner both to guide and to curtail the search for a binary solution to, for example, a satisfiability problem. Thus, the quality of the LR is crucial to the IP approach.</p><p>BB is an OR-tree backtracking family of algorithms. At each search node, the corresponding LR is solved. If it is inconsistent, then so is the satis~ability problem for that node. If the LR turns out to have a binary solution, then a satisfying truth valuation has been found-we call this the "incumbentfinding" feature of BB. Otherwise, when the LR is consistent but a binary solution for it is not obtained, the LR is used in a number of possible heuristic manners to determine a "branching variable" z(Pj). Two new nodes are formed, one with z(PJ = Oand one with z(Pj) = 1, and the process continues. For a detailed discussion of BB and some possible heuristics, see <ref type="bibr" target="#b12">[13]</ref>.</p><p>Since the LR is crucial to the BB approach, we next seek a result which relates the LR for the conventional c.n.f. of a proposition A, to the LR for the c.n.f. equivalent obtained by our algorithm CNF.</p><p>Lemma 2.1. Let A be a disjunction of c.n.f.s A = (Ai,, Bi)v (hEJ Cj) with Bi, Cj clauses in Pi, * * ., P, (I # 4, J # 4). Fix a ZE [O, 11.  Let S denote the set of all solutions to the LR for the c.n.f. of A, in which "1" on the r.h.s. of ( <ref type="formula">5</ref>) is replaced by "z", where the c.n.f. is obtained by the distributive law Proposition 2.1(a), but without using the simplification that two occurrences of a literal f Pk in a clause can be replaced by a single occurrence. Then S is equal to the projection T' onto the variables z(Pj), 1 &lt; j 6 s, of the set of all solutions T to the LR of Q?(A) such that z(A') 2 Z.</p><p>Proof: When the cited distributive law is used, we obtain A s flisl hEJ (Bj v Cj) so that the LR has constraints Z(Bi v Cj) 3 z iEI, jEJ. ( <ref type="formula">6</ref>)</p><p>In ( <ref type="formula">6</ref>), it is understood that repeated occurrences of a literal f P, in Bi v Cj is not replaced by one occurrence. (Note that if both + P, and -Pk occur in Bi v Cj, z(Bi v Cj) 3 1 is always satisfied in the LR and could be removed, but we do not do so here.) When CNF is used, the following constraint system %(A) (in addition to upper and lower bounds on variables) is obtained (where we drop primes in B' for subformulas B of A):</p><formula xml:id="formula_1">z t1 -z(Bi)) + z /j Bi 3 l ( 1 1el @)I Z(Bi)+(l-Z(/JBi))&gt; 1, iEl (7b)l 1 (1 --(Cj)) + Z /j Cj 2 l jcJ ( 1 EJ lbz ABi +Z(A)&gt;l ( ) iel m 1-Z c 1 ACj +Z(A)3 1. (<label>7g</label></formula><formula xml:id="formula_2">)</formula><p>'EJ Since z 3 z(A), we have from ( <ref type="formula" target="#formula_1">7</ref>) Z(Bi v Cj) = Z(Bi) + z(Cj) (since simplification is not used) 3 z(Aip, Bi) + z(hEJ Cj) [using (7b)], (7d)) 3 z [using (7e)]. Thus the projection T' is a subset of S, by <ref type="bibr" target="#b5">(6)</ref>.</p><p>Conversely, let a solution to the LR of (6) be given. Put z(Aicl Bi) = min,,, Z(Bi), z(~.J Cj) = min,,, z(Cj), z(A) = min{l, z&amp;, Bi) + z(/GEJ Cj)}. One easily verifies that a solution to ( <ref type="formula" target="#formula_1">7</ref>) is obtained with z(A) &gt; z. Thus S c T'. Hence S = T'.</p><p>Q.E.D. By use of Lemma 2.1, one easily shows that the LR obtained for A = (Pi A P2) v . . . v (Pzs_ 1 A P2,) via CNF is equivalent to that for the super-exponential size c.n.f. obtained from using distributive laws. This is because no simplifications, of the type described in that lemma, are possible. However, when such simplifications can be made, the LR for the usual distributive law formulation (6) can be tighter (i.e. smaller) than that obtained via CNF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>As an example, consider A = (PI A P2) v (P, A P3) which has cnf. P, A (PI v P3) A (P2 v PI) A (Pz v P3</head><p>). Then in ( <ref type="formula">6</ref>) z(P1) = 1 is forced. However, in <ref type="bibr" target="#b6">(7)</ref> we have the solution z(P,) = z(P2) = z(P3) = z(P, A Pz) = z(P, A P3) = z(A) = l/2, which allows z(P,) = l/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2.1</head><p>Let A be a proposition in which all negations (if any) occur in literals. Let S denote the set of all solutions to the LR for the c.n.f. of A, as obtained by the distributive law Proposition 2.1(a). Let T' denote the projection on to the variables z(Pj), 1 &lt;j 6 s of the set of all solutions T to the c.n.f. equivalent obtained for A by CNF.</p><p>Then S E T'. Moreover, when the simplification of several occurrences of a literal in a clause to one occurrence is not used, then S = T'.</p><p>Proof: First, we establish an extension of Lemma 2.1 for general propositions A of this form. This is done by induction on the number c of propositional connectives other than negations in A. For c = 0, there is nothing to prove, so we can assume c 3 1.</p><p>If A is a disjunction, an argument similar to that for Lemma 2.1 establishes this case.</p><p>If A is a conjunction, e.g. A = B A C, again we use the systems V(B) and g(C) for B and C obtained via CNF, and the induction hypothesis. In the IP formulation of %?(A) these constraints occur (erasing primes):</p><formula xml:id="formula_3">(I-z(B)) + (1 -z(C)) + z(A) 2 1 z(B) + (1 -z(A)) 2 1 z(C) + (1 -z(A)) 2 1. (8)</formula><p>Let a solution to <ref type="bibr" target="#b4">(5)</ref> for A be given, in which the r.h.s. of "1" is replaced by "z". This is also a solution to (5) for B and C, with the same replacement, as <ref type="bibr" target="#b4">(5)</ref> for A is obtained by juxtaposing these two systems (in view of A = B A C). By the inductive hypothesis, the solution can be extended to a solution for both 9?(B) and %7(C) in which z(B) 2 z and z(C) 2 z. If we put z(A) = min(z(B), z(C)) we have z(A) 2 z and also <ref type="bibr" target="#b7">(8)</ref> is satisfied. Hence we have a solution to %?(A) with z(A) 2 z.</p><p>Conversely, let a solution to (8) be given with z(A) 2 z. By ( <ref type="formula">8</ref>), also z(B) Z z and z(C) 3 z. By the inductive hypothesis, this solution also satisfies <ref type="bibr" target="#b4">(5)</ref> with "1" replaced by "z".</p><p>To obtain the theorem, we put z = 1 and recall that z(A) &gt;, 1 occurs in the IP formulation of the c.n.f. equivalent for A constructed by CNF.</p><p>Q.E.D. We conclude with two examples of propositional logic, one drawn from traditional MIP modeling approaches, and the second one motivated by the Horn sentence framework of <ref type="bibr" target="#b2">[3]</ref>.</p><p>Example 2.1. If either project 1 or 2 is done, then either project 3 is not to be done, or both project 4 and project 5 are to be done.</p><p>Here let Pi denote that the ith project is done. We have the proposition A = [(P, v P2)-+ lP, v (P,A P,)], wherethesign "--+" is implication. In this context, B--+ C is logically equivalent to 1B v C; i.e. to the fact that either B is not done or, barring that, C is done (no causality between B and C is asserted). Thus</p><p>Using CNF, the following system can be used to describe the logical condition: (104</p><formula xml:id="formula_4">z(A) = 1 z(P3) + z(A) 2 I 1 -z(P4 A Ps) + z(A)</formula><formula xml:id="formula_5">(lob)</formula><p>where each Li is a letter (hence contains no negation) and where L is known to be false. In the above, L,, . . ., L, is notationally equivalent to L, A . . . A L,, and is taken from <ref type="bibr" target="#b2">[3]</ref>. In <ref type="bibr" target="#b2">[3]</ref>, the false letter L of (lob) is often deleted, leaving (lob) blank on the right-hand side. In (lOa), we allow the case r = 0; in (lob) always r 2 1. Of course, (1Oa) is interpreted as the disjunction 1 L, v . . . v 1 L, v L,, 1, while (lob) is interpreted as 1 L, v . , . v 1 L,. Thus, a Horn sentence is already a clause. Moreover, each clause has at most one positive occurrence of a propositional letter. A Horn sentence is thus a special case of a logical constraint, in which a set of r positive conditions either implies another positive condition (lOa) or is impossible (lob). The interest in this special case is that a wide variety of practical situations can be represented in this format (see <ref type="bibr" target="#b2">[3]</ref>) and it yields to efficient procedures which are not generally valid (see, for example, our Proposition 3.2 below).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE DAVIS-PUTNAM PROCEDURE AND INTEGER PROGRAMMING</head><p>The Davis-Putnam procedure DP of <ref type="bibr" target="#b1">[2]</ref> is an algorithm for establishing the satisfiability or nonsatisfiability of a proposition A in cnf.</p><p>A listing is made of the clauses of A. A clause is called a unit clause if it is of the form f Pj for some letter Pj, i.e. if it consists of one literal. Clearly, a unit clause is made true by exactly one truth valuation. An atomic letter Pj is called monotone if every occurrence of Pj in any clause is positive (i.e. as Pi) or every occurrence is negative (i.e. as 1 Pj). For monotone Pj, there is an obvious truth valuation which causes every clause in which Pj occurs to be satisfied, without affecting the satisfiability of the c.n.f. as a whole. On the other hand, a monotone letter need not be forced to take on this truth valuation.</p><p>The algorithm DP is as follows:</p><p>Subroutine CC For as long as there is a unit clause, assign the corresponding atomic letter the truth value needed to make this clause true. If this value is opposite that of an earlier truth value set for this letter, or to a unit clause, the list of clauses is inconsistent. Otherwise, remove all clauses made true by this truth value, and remove the opposite of this literal from all clauses then remaining. If no clauses remain, a satisfying truth valuation has been found; if no unit clauses remain, go to Subroutine Mon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subroutine Mon</head><p>As long as there are monotone letters, set these letters to the truth valuation which makes all clauses true that contain them, and remove these clauses from the list. If no clauses remain, a satisfying truth valuation has been found.</p><p>Otherwise, go to Subroutine Resolve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subroutine Resolve</head><p>As there are no unit clauses and no monotone letters, for every letter P occurring in the clauses, the clauses can be divided into three groups: Group A: Pv R,, . , ., Pv R,--the clauses containing P positively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(11)</head><p>Remove any clause Riv Sj in which both a letter Pk and its negation Pk occur. Repeats of the same literal in a clause are replaced by one occurrence of it. If no clauses remain, there is a satisfying truth valuation. Otherwise, return to Subroutine CC. This concludes our description of DP. The validity of DP follows from the facts that: any truth valuation satisfying Groups A, B and C also satisfy <ref type="bibr" target="#b10">(11)</ref>; and conversely, for any truth valuation satisfying <ref type="bibr" target="#b10">(11)</ref> there is a truth value for P to satisfy Groups A, B and C. (For details, see <ref type="bibr" target="#b1">[2]</ref>.) DP is finite, since Subroutive Resolve removes an atomic letter each time it is used.</p><p>A second form DP' of DP is given in <ref type="bibr" target="#b3">[4]</ref>, w h ere a set of lists of clauses is generated, and where Subroutine Resolve is replaced by:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subroutine Split</head><p>Replace groups A, B and C by these two sets of lists of clauses: R,, . . ., R,, T,, . . ., T,; and P is set to F (124 and S ,, . . -9 St,, T,,..., T,; and P is set to T.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(12b)</head><p>These lists are added to the set of lists. A list is then withdrawn from this set, and one returns to Subroutine CC.</p><p>For DP', another change which must be made is in Subroutine CC: if a list is inconsistent, while lists still remain in the set, another list is taken from the set and Subroutine CC is applied; otherwise, if the set of lists is empty the original list of clauses is inconsistent.</p><p>The 'CC" stands for "clausal chaining". Obviously, any truth value set for a letter by CC is forced, if that list of clauses is to be true. However, even for Horn clauses, there can be forced truth values which cannot be obtained from CC. As an example, Subroutine CC can take no action on the list of Horn clauses 1 A v B, 1 A v 1 B (i.e. A -+ B and A, B -+), since there are no unit clauses. However, A must be false to make these clauses true. Using the observations of the previous paragraph, it is easily proven by induction on the number of letters fixed by Subroutine CC, that the corresponding binary variables are fixed in the LR. In particular, if Subroutine CC indicates the inconsistency of a list, then the LR is inconsistent; and if it finishes with all letters set to consistent truth values, so does LR, and LR is consistent.</p><p>Suppose now that Subroutine CC finishes with clauses remaining. Then none of these are unit clauses, so every variable remaining in LR can be set to one-half, with all constraints satisfied. In particular, LR is consistent.</p><p>Q.E.D. From Proposition 2.1, the effect of the linear relaxation is almost identical to that of clausal chaining, except for the crucial feature that an incumbent binary solution may be found in the LR, while Subroutine CC does not attempt to produce incumbents.</p><p>LR can be consistent when the list of clauses is not satisfiable. For example, the four clauses P,vP,, -lP,vP,, P,v lP,, 1 P, v 1 P, are inconsistent, but the LR is consistent with z(P,) = z(Pt) = l/2. Here the clause P, v P, is not Horn (it contains two positive literals). However, this phenomenon does not occur for Horn clauses, by our next result. For a list of Horn clauses, Subroutine CC indicates no inconsistency exactly if the list of Horn clauses is satisfiable. Moreover, the LR of this list is consistent exactly if the list is satisfiable.</p><p>Proof. Assume that Subroutine CC indicates no inconsistency. Then the forcing of a truth value of a letter by Subroutine CC results in a set of Horn clauses remaining, if any clauses remain. For if the letter P, is set true, and its negation 1 Pj occurs in a clause, there is at least one other literal in that clause (as CC indicates no consistency), and the removal of 1 Pj leaves a Horn clause. On the other hand, if 1 Pj is set true and Pj occurs in a clause, again there is at least one other literal occurring, and the removal of Pj results in a Horn clause.</p><p>By using the observations of the last paragraph inductively, one easily shows that, after Subroutine CC completes, any clauses remaining are Horn. However, a list of Horn clauses, which contains no unit clauses, can be satisfied by valuing as false all atomic letters occurring.</p><p>Thus, if Subroutine CC indicates no inconsistency, the list of Horn clauses is satisfiable. By Proposition 3.1, we can also state "exactly if" in place of "if'. We verify the claim regarding LR also by Proposition 3.1.</p><p>Q.E.D. We next address the issue of the strength of DP relative to that of DP'. The sum of the number of constraints in (12a) and (12b), which is a + b -I-2c, is typically smaller than the size of (II), which is ab + c less removed clauses. In fact, for a, b b 4 with a, b b &amp; we have ab + c 3 u + b + 2~. Moreover, constraint size is smaller in <ref type="bibr" target="#b11">(12)</ref>. Thus, size considerations generally favors <ref type="bibr" target="#b11">(12)</ref> over <ref type="bibr" target="#b10">(11)</ref>. The following result further supports this view. Proposit ion <ref type="bibr">3.3</ref> Any letter fixed by Subroutine CC at a truth value in <ref type="bibr" target="#b10">(11)</ref> is fixed in the same way in both (12a) and (12b), whenever these latter lists are not proven unsatisfiable by Subroutine CC. Any monotone variable after Subroutine CC in <ref type="bibr" target="#b10">(11)</ref> is monotone in the same way in both (12a) and (12b) whenever these latter lists are not proven unsatis~able. If Subroutine CC proves <ref type="bibr" target="#b10">(11)</ref> unsatisfiable, it does the same for (12a) and (12b).</p><p>Proof. The result easily follows from the fact, that the LR for both (12a) and (12b) is contained in that for (1 l), and by Proposition 3.1. With regard to the LR for (12a), for example, the constraint z(RJ 3 1 implies .z(Rj v Sj) 3 1 for all j = 1, . . . , b as one easily shows (recall that all variables are in [O&gt; 11).</p><p>Q.E.D. Proposition 3.3 asserts a dominance of ( <ref type="formula">12</ref>) over <ref type="bibr" target="#b10">(11)</ref>. Typically it is a strict dominance. For example, when Group A is P v Q, P v 1 Q and Group B is 1 P v R, 1 P v 1 R while Group C is empty, both (12a) and (12b) are found inconsistent by Subroutine CC. However, <ref type="bibr" target="#b10">(11)</ref> </p><formula xml:id="formula_6">is Qv R, 1 Q v R, Q v 1 R, 1 Q v 1 R</formula><p>for which Subroutine CC obtains no fixed letters. Subroutine Mon likewise takes no action.</p><p>By Proposition 3.1, the generally superior impiementation DP' of the Davis-Putnam procedure very much follows the branch-and-bound (BB) approach, except that DP' includes Subroutine Mon, which is not in BB. The splitting <ref type="bibr" target="#b11">(12)</ref> of course corresponds in BB to branching on z(P). That subroutine alone is a feature unique to the propositional logic setting, in which only some satisfying truth valuation is sought. In contrast, BB is designed to do optimization of a linear criterion, where constraints other than propositional ones may also be present. Optim~~tion can require setting a letter to the value opposite its monotone value. Of course, Subroutine Mon can be added to BB in this setting of no criterion function. Some of the popular "chaining" procedures, for drawing logical inferences from lists of implications, are incomplete for propositional logic in a very strong sense. Specilically, they are not as strong as the "clausal chaining" of Subroutine CC.</p><p>We demonstrate this fact for "backward chaining" in the next example, which concerns lists of implications of the form: and Here (13) differs from the Horn format <ref type="bibr" target="#b9">(10)</ref> in that literals, and not simply letters, can occur.</p><p>Example 3.1. The "blackward chaining" (BC) process constructs an AND/OR tree, which itself is of substantial technical complexity.</p><p>Starting from a literal f L whose conclusion is sought, all rules (13a) with L,, 1 = L are noted. If r = 1 (i.e. no hypotheses occur in the rule), + L is immediately inferred. Otherwise, if any one of the noted rules can be made to "fire", then +L can be inferred. For one such rule to "fire", all its hypotheses + L1, . . . , + L, must first be concluded. These hypotheses set up subgoals, which are treated as with the main goal (of concluding +L), and the process is iterated.</p><p>The AND/OR tree thus generated can be "pruned" somewhat. For example, if a subgoal has a subgoal equal to itself, or to one from which it descends in the tree, one can abandon attempts to establish the second subgoal.</p><p>For the list of clauses</p><formula xml:id="formula_7">A--+ ) B-A, lB+C<label>(14)</label></formula><p>with the goal of concluding C, procedure BC will set up the unique subgoal of concluding 1 B. Then, as no rule concludes lB, procedure BC stops. However, Subroutine CC will conclude C. Indeed, it sets A "false" (from A+ ), B "false" (from B +A i.e. from 1 B v A), and then C "true" (from lB--+C i.e. from B v C).</p><p>In backward chaining, a distinction is made in the way a letter is treated, accordingly as it occurs on the left or on the right of an implication. This distinction has an intuitive appeal and may be drawn from causal implication, but it has no place in logical implication. Essentially, Subroutine CC is superior to BC since it ignores that distinction.</p><p>On the other hand, in the context of Horn clauses with no rules of the form (lob), it can be shown that BC and CC con&amp;de the same letters, and no negations of letters are concluded. In this context, unsatisfiability cannot occur, as all letters can be valued "true" and all implications become true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SOME EXPERIMENTAL RESULTS</head><p>We have conducted several series of tests for satisfiability of formulas which were already in conjunctive normal form (or which were lists of implications with literals, hence directly convertible to that form). We report on those runs which used the conventional repr~entation (5) of clauses. We summarize some experiments reported in detail in <ref type="bibr" target="#b5">[6]</ref>. The formulas were randomly generated by a method to be described below. Generally, such formulas proved easy to test for satisfiability, although by seeking difficult problems we could find these, too.</p><p>The series occurred over about a year's period of time, and three MJP codes were used: BANDBX, devised by Clarence H. Martin, which includes a very sophisticated and effective incumbent-finding heuristic due to Balas and Martin <ref type="bibr" target="#b13">[14]</ref>; the IP code of Land and Powell <ref type="bibr" target="#b14">[15]</ref>, which lacks many advanced features and is not designed for production runs, but which is a well-documented experimental code; and the APEX IV code of CDC, one of the most powerful general-purpose commerical MIP codes available. Of course, all three MIP codes and their heuristics are designed for general mixed-integer programs, which can vary from distribution system design, to scheduling, to capital-budgeting, etc. No attempt was made to adapt any of these codes to propositional logic; in particular, Subroutine Mon was not added.</p><p>Data sets were generated as follows. A number L of literals, a number C of clauses, and a number S of literals per clause was specified. To generate a specific clause, S propositional letters were drawn without replacement and with equal probability, from the L available. Two methods were used to determine whether the occurrence of a chosen letter was positive or negative. In Tables <ref type="table">1</ref> and<ref type="table" target="#tab_1">2</ref>, the nature of the first occurrence was chosen at random, and later occurrences alternated as positive or negative. It was felt that this made the problems harder, In Tables <ref type="table" target="#tab_2">3</ref> and<ref type="table" target="#tab_3">4</ref>, the nature of each occurrence was determined at random. The second method is very similar to a generation scheme discussed in [ 161 and [ 173.   Following the generation of all C clauses, a simple "pruning" of monotone letters and their clauses was inductively applied, until there were no monotone letters. Pruning was designed to remove some features that would make problems easier for humans to solve. The data set sizes reported in Tables 1 and 2 are after pruning, while in Tables <ref type="table" target="#tab_2">3</ref> and<ref type="table" target="#tab_3">4</ref> the sizes are before pruning. Pruning generally decreases a problem's size by about 10%.</p><p>The node count reported in the tables is the number of linear programs solved in the search tree, including the very first such program. We separate out the initial LP time from the Total Time.</p><p>In Tables <ref type="table" target="#tab_2">3</ref> and<ref type="table" target="#tab_3">4</ref>, APEX Units are reported, rather than CPU seconds; an APEX Unit is very nearly one second. This commercial code operates as a "black box", and we were not as free to work with it as with the others. We also noted that, in Tables <ref type="table" target="#tab_2">3</ref> and<ref type="table" target="#tab_3">4</ref>, where some of the letters are set to values, APEX was invariably more efhcient for "zero" settings than for "one" settings. After we checked our problem generator and sampled its data sets, we concluded that the generator was working properly, and that the discrepancy was due to some feature of APEX. Below, we report on the zero settings.</p><p>Some of the problems reported on in the BANDBX runs of Table <ref type="table">1</ref> are in the NP-complete [lS, 19) category of three or more literals per clause, and some are not. However, there was no correspondence between this feature and problem difficulty, or if anything, the correspondence was the reverse of what one expected. This continued to hold true in later experiments.</p><p>We changed from BANDBX to the Land and Powell code in order to solve larger problem sets, due to dimensioning problems with our version of BANDBX. This also gave us an opportunity to see if the sophisticated incumbent-finding method of BANDBX was responsible for the favorable runs. The answer appears to be negative, although incumbent-finding per se is very likely crucial. Probably a wide range of "reasonable heuristics" will suffice.</p><p>The times reported in Table <ref type="table" target="#tab_1">2</ref> are less important than in the other tables, as the Land and Powell code is not designed for tfficiency. However, the node counts are significant.</p><p>In the problem sets reported in Table <ref type="table" target="#tab_2">3</ref> for the APEX Code, some of the letters were set to truth values, in addition to the satisfiability constraints. However, care was taken that, in each clause, at least three letters were not set. The clauses had seven literals each. These problems are all consistent and, indeed, the larger problem sets strongly tended to be consistent.</p><p>From numerous tests, including those reported above, we came to conclude that a very difficult problem for branch-and-bound would have these characteristics: its LP would be feasible (i.e. Subroutine CC uncovers no inconsistency), it would not be (so the incumbent-finding feature of BB would be of no help), but a small loosening of its constraints would make it satisfiable.</p><p>To create such a "barely inconsistent" problem we took a single data set of 400 clauses in 100 letters, with three literals per clause, which was satisfiable. We then fixed a large percentage of the letters at a truth value, so as to make the result inconsistent by linear programming (i.e. Subroutine CC). We then made stepwise reductions in the number of fixed variables, by freeing up the fixes, until satisfiability was achieved.</p><p>The result of this experiment is reported in Table <ref type="table" target="#tab_3">4</ref>. It was consistent with our expectations. The last unsatisfiable problem is with lovariables fixed, and it is indeed the hardest in terms of run time or the number of nodes.</p><p>The run times achieved in these experiments are startling, in view of the fact that an LP is very likely a wasteful way of implementing Subroutine CC. Via LP, all the unnecessary data structures of matrices, reducedcosts, etc. are carried along. These are most likely a hindrance when only propositional logic problems are considered.</p><p>We tentatively conclude from our experience, that the algorithm DP', if augmented by an adequate heuristic for attempting a satisfying valuation as computation proceeds, will prove to be an effective real-time method for propositional logic problems of several hundred clauses and literals, with seven or fewer literals per clause.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Proposition 2. 1 (</head><label>1</label><figDesc>a) ~v(~AC)~(~v~)~(~vc) (b) Ar\fBvC)_=(Ai\B)v(AnC). If we first use the de Murgan laws to get negations agamst atomic propositions, and then repeatedly use Proposition 2.1(a) where it apphes (and some simpli~~ations like A A 8 E B A A, etc.), we will transform a general proposition A to an equivalent proposition of the form A, A . . . A A, in which every Ai, 1&lt; i &lt; t, has the form Ai = VjEJciJ + Pj for some non-empty subset J(i) c { 1, . . . , s}. ThenA,~... A A, is called a conjunctive normal form (c.n.J) for A, and the Ai are the clauses of the c.n.f. If instead we use Proposition 2.1(b) we transform A to an equivalent B, v . . . v B, in which each B, 1 6 id U, has the form Bi = &amp;K(i) + Pj. Then B, v . . . v B, is called a disjunctive normul form (d.n$) for A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3 .[</head><label>3</label><figDesc>A=P,r\(P,vlP,),B=lP,,C=-IP,] [(P,vlP,)A(lP,vP,vlP3)]AD (in (P,rr(P,v lP3))v 1P, use A= lP,, B=P,, C=P,v -1P,), where D = (PI A (P2 v lP3)) v -1 P,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 )</head><label>2</label><figDesc>(a) If B is a literal, V?(B) is empty, and 8' = B. (b) If B = C, A. . . A C,, with all %(CJ and C: constructed, 1 6 i 6 t, we let B' be any new letter, and g(B) is u:= 1 %(Ci) plus these clauses: lC;vlC;v...vlC;vB C;v -lB' l,&lt;i&lt;t. (1) Remark: If all C: are valued "true", the first line of (1) forces B' to be valued "true", when that clause (line) holds. If any C: is valued "false", the second group of clauses in (1) forces B' to be valued "false". For these reasons, the clauses in (1) force B' to be valued as C', A . . . A C;. (c) IfB=C, v.. . v C,, with all %?(Cj) and C: constructed, 1 &lt; i &lt; t, we let B' be any new letter and 44'(B) is !J:= 1 %(Ci) plus these clauses: c; v . . * vC;v 1B (As in (b) above, the clauses in (2.2) force B' to be valued as C; v . . . v C;. (d) If B = 1 C, then %(B) = g(C) and B' = 1 C'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 1 l 1 Z</head><label>11</label><figDesc>-Z(lP,A lP,)+z(A)&gt; 1 z(P,)+z(P,)+z(lP, A lP,)&gt; 1 l-z(P,)+l-z(lP,nlP,)bl 1 -Z(Pz)+ 1 -Z(lP, A lp,)&gt; 1 1 -z(Pq) + (1 -z(P,)) + z(P, A Ps) 3 Clearly, the first live rows of (9) can be replaced by the one row z( 1 P, A 1 P2) + (1 -z(P,)) + z(P, A Ps) &gt; 1. Since no simplification occurs, of the type cited in Theorem 2.1, (9) has an LR which (after projection) is equivalent to that for the usual c.n.f. of A. Example 2.2. A Horn sentence [3] is an implication of the form or L,, . ., L,-*L,+1 L,, . . .) L,d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Group B: lPvS1,..., 1 P v S,-the clause! containing P negatively. Group C: T,, . . ., T,-clauses not containing P. (Group C may be empty, but not groups A or B, and the R, and Sj are nonempty clauses.) Then replace the current list of clauses (Groups A, B and C) by:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Proposition 3. 1</head><label>1</label><figDesc>The letters forced to truth values by Subroutine CC have their corresponding variables fixed at the corresponding binary value in the LR; and any letter not forced to a value by Subroutine CC can have the value one-half in the LR. Moreover, LR is inconsistent exactly if Subroutine CC indicates inconsistency. Proof: If the unit clause is, for example, Pj, then in the LR we have a constraint z(Pj) = 1 in the LR, with Pj forced true by Subroutine CC. If a clause B contains Pj, then as z(B) = z(Pj) + nonnegative terms, we have z(B) 2 1 in the LR, so this constraint may be deleted. If B contains 1 Pj, then z(B) = 1 -z(Pj) + z(B'), where B' contains the remaining terms, so z(B) = z(B') and z(B) 3 1 is equivalent to z(B') b 1. The analysis is similar if the unit clause is 1 Pj.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Proposition 3. 2</head><label>2</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table I .</head><label>I</label><figDesc>Satisfiabllity tests using BANDRX</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Time (CPU s)</cell></row><row><cell>Problem size</cell><cell>Satisliable?</cell><cell>Nodes</cell><cell>LP</cell><cell>Total</cell></row><row><cell>L=3l,C=44,S=2 L=35,C=45,S=2 L=37.C=45,S=2 L=36,C=52,S=? L=46,C=63,S=t L=53.C=68,S=2 L=36,C=39.S=3 L=38,C=45,S=3 L=43,C=45.S=4 L=4O.C=45,S=4 L=25.C=35,S=5</cell><cell>NO No Yes No No Yes Yes Yes Yes Yes Yes</cell><cell>2 3 4 3 3 3 1 , I 2 I</cell><cell>4.0 4.7 4.7 6.0 8.7 IO.1 3.9 5.5 5.2 5.3 3.5</cell><cell>6.5 9.8 10.X 14.4 21.3 21.5 4.1 6.5 5.4 7.0 3.6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Satisfiability tests using Land Powell's code</figDesc><table><row><cell>Time CPU s)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Teats using Apex IV</figDesc><table><row><cell>Time (APEX)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 .</head><label>4</label><figDesc>Creatmg a hard probiem</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>Time</cell><cell></cell></row><row><cell></cell><cell></cell><cell>Nodes</cell><cell></cell><cell>.~</cell></row><row><cell>Total</cell><cell>Consistent</cell><cell>--</cell><cell>APEX Units</cell><cell></cell></row><row><cell>fixed</cell><cell>?</cell><cell>Total</cell><cell>LP</cell><cell>Total</cell></row><row><cell>38</cell><cell>No</cell><cell>I</cell><cell>INFEAS</cell><cell>11.3</cell></row><row><cell>20</cell><cell>NO</cell><cell>1</cell><cell>INFEAS</cell><cell>40.9</cell></row><row><cell>ix</cell><cell>No</cell><cell>I</cell><cell>INFEAS</cell><cell>71.0</cell></row><row><cell>16</cell><cell>No</cell><cell>1</cell><cell>INFEAS</cell><cell>62.4</cell></row><row><cell>14</cell><cell>No</cell><cell>I</cell><cell>INFEAS</cell><cell>84. I</cell></row><row><cell>I2</cell><cell>No</cell><cell>13</cell><cell>88.7</cell><cell>266.8</cell></row><row><cell>IO</cell><cell>No</cell><cell>16</cell><cell>77.0</cell><cell>299.R</cell></row><row><cell>8</cell><cell>Yes</cell><cell>I3</cell><cell>75.6</cell><cell>170.2</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>$Research of the second author has been partially supported by National Science Foundation grant MCS-8304075.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Shoenfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mnthematical</forename><surname>Logic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A computing procedure for quantification theory</title>
		<author>
			<persName><forename type="first">M</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Putnam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J/ ACM</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="201" to="215" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Logic for Problem-Solving</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>North-Holland; Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Automated Theorem-Prouing: A Logical Basis</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Loveland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A machine oriented logic based on the resolution principle</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JI ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="23" to="41" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Modelling with integer variables</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lowe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
		<respStmt>
			<orgName>Georgia Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Knowledge-Based Systems in Artificial Intelligence</title>
		<author>
			<persName><forename type="first">R</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Lenat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>McGraw-Hill International</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Production rules as a representation for a knowledge-based consultation program</title>
		<author>
			<persName><forename type="first">R</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Buchanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shortliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1" to="45" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A model of inexact reasoning in medicine</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Shortliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mafh. Biosci</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="3" to="5" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">On monotone chaining procedures of the CF type. College of Management</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jeroslow</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Georgia Institute of Technology</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The complexity of theorem-proving procedures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings qf&apos;rhe Third ACM Symposium on the Theory of Computing</title>
		<meeting>qf&apos;rhe Third ACM Symposium on the Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1971">1971</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Quantitative Concepts for Management</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Eppen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Gould</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Nemhauser</surname></persName>
		</author>
		<title level="m">Integer Programming</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">E</forename><surname>Balas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mgmt Sci</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="89" to="96" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Fortran Codes for Mathematical Programming: Linear, Quadratic and Discrete</title>
		<author>
			<persName><forename type="first">A</forename><surname>Land</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Powell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>Wiley</publisher>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Probabilistic analysis of the pure literal heuristic for the satisliability problem</title>
		<author>
			<persName><forename type="first">J</forename><surname>France</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Opns Res. I</title>
		<imprint>
			<biblScope unit="page" from="273" to="289" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Probabilistic analysis of the Davis Putnam procedure for solving the satisfiability problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Paull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discr. appl. Math</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="77" to="87" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Computers</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Intractability</forename><forename type="middle">W H</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">San</forename><surname>Francisco</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reducibility among combinatorial problems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Complexity qf&apos; Computer Computations</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Miller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="85" to="104" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
