<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Learning the valid incoming direction of IP packets q</title>
				<funder ref="#_kHYuJe8">
					<orgName type="full">National Science Foundation</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-10-09">9 October 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jun</forename><surname>Li</surname></persName>
							<email>lijun@cs.uoregon.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Oregon</orgName>
								<address>
									<postCode>97403</postCode>
									<settlement>Eugene</settlement>
									<region>OR</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jelena</forename><surname>Mirkovic</surname></persName>
							<email>mirkovic@isi.edu</email>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Information Sciences Institute</orgName>
								<orgName type="department" key="dep2">Marina del Rey</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<postCode>90292</postCode>
									<region>CA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Toby</forename><surname>Ehrenkranz</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Oregon</orgName>
								<address>
									<postCode>97403</postCode>
									<settlement>Eugene</settlement>
									<region>OR</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mengqiu</forename><surname>Wang</surname></persName>
							<email>mengqiuw@yahoo.com</email>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">UCLA</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Reiher</surname></persName>
							<email>reiher@cs.ucla.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">UCLA</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lixia</forename><surname>Zhang</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">UCLA</orgName>
								<address>
									<postCode>90095</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Learning the valid incoming direction of IP packets q</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-10-09">9 October 2007</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1016/j.comnet.2007.09.024</idno>
					<note type="submission">Received 16 March 2007; received in revised form 14 September 2007; accepted 26 September 2007</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Incoming direction</term>
					<term>IP spoofing</term>
					<term>Source address validity</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Packet forwarding on the Internet is solely based on the destination address of packets, and it is easy to forge the source address of IP packets without affecting the delivery of the packets. To solve this problem, one can have routers check whether or not every packet comes from a correct direction based on its source address field. However, due to routing asymmetry in today's Internet, a router cannot simply reverse its forwarding table to determine the correct incoming direction of a packet.</p><p>In this paper, we present the source address validity enforcement protocol, SAVE, which allows routers to learn valid incoming directions for any given source address. SAVE is independent from-and can work with-any specific routing protocol. By only interfacing with the forwarding table at routers, SAVE allows routers to properly propagate valid source address information from source address spaces to all destinations, and allows each router en route to build and maintain an incoming tree to associate each source address prefix with a corresponding incoming interface. The incoming tree is further valuable in handling routing changes: although a routing change at one router could affect the incoming direction of source address spaces from many locations, only the router that sees the change needs to send out new updates. Finally, SAVE has a good performance with low overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>It is well known that the source address of IP packets in today's Internet can be easily forged. When an Internet router sends traffic towards its destination, the router will forward it solely based on its destination address, no matter what the source address of the packet is. This ease of source address spoofing has helped attackers to hide themselves and has made innocent end-hosts be both blamed and attacked. Typical examples include DDoS attacks <ref type="bibr" target="#b1">[2]</ref>, TCP SYN flooding attacks <ref type="bibr" target="#b2">[3]</ref>, smurf attacks <ref type="bibr" target="#b3">[4]</ref>, and reflector attacks <ref type="bibr" target="#b4">[5]</ref>. Moreover, this problem impairs many sourceaddress-based functions often performed by routers at the core or edge of the Internet; for example, routers may need to perform per-source fair queuing, congestion control, or source-address-based traffic management schemes.</p><p>Researchers have studied both reactive and proactive approaches to handling packets with forged IP source addresses. Unfortunately, there are defects in existing approaches. In employing a reactive approach, one can try to trace back the real origin of packets <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref>, or discover that a packet is from a path already identified as an attack path <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. However, packet tracing takes place after an attack is detected, not when it is occurring.</p><p>If one already can determine that a packet carries an invalid source address, one could proactively filter such a packet right away. For example, if one can assume that routing is symmetric (i.e., the route from a node A to B is the same as that from B to A), one could use a router's forwarding table to determine whether or not a packet with a specific source address arrives from the same interface as forwarding a packet toward that address <ref type="bibr" target="#b11">[12]</ref>. However, we know that paths through the Internet are frequently asymmetric <ref type="bibr" target="#b12">[13]</ref>, which means that the forwarding tables used by routers to deliver packets are not reliable for determining where packets should come from. Or, before a packet leaves a stub network to enter the Internet, one can check whether or not the packet indeed carries a source address from the stub network, i.e., ingress filtering <ref type="bibr" target="#b13">[14]</ref>; similarly, for packets reaching a stub network from the Internet, one can apply egress filtering to ensure they do not carry a source address from the stub network <ref type="bibr" target="#b14">[15]</ref>. But, with the ingress or egress filtering, edge routers can only check a packet's incoming direction with a very coarse granularity (i.e., whether toward or from a stub network), and routers not at the edge cannot help at all. One could also filter packets by checking whether or not a packet carries a specific key or some kind of cryptographic authentication information <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>, or even a TTL value within an expected range <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. But relying on keys remaining secret is not always safe, and cryptographic operations become too expensive on a perpacket basis; filtering based on invalid TTL values is frequently imprecise.</p><p>What is much needed is a reliable, lightweight, and proactive approach that would allow a router to easily verify source addresses of IP packets. Routers currently have forwarding tables that specify the outgoing interface for each destination address space (or destination address prefix). If they also had tables specifying proper incoming directions for source address spaces, then an attacker's choice of forgeable IP source addresses will be sharply reduced. All improperly addressed packets could be easily dropped as soon as the forgeries were detected, and attack-tracing tools can much more easily determine the possible sources of attacks <ref type="bibr" target="#b19">[20]</ref>. Moreover, this table could be used for nonsecurity related purposes, such as source-based traffic engineering, congestion control, or fair queuing. A router performing reverse path forwarding (RPF <ref type="bibr" target="#b20">[21]</ref>) can track down hop by hop those routers that are on the delivery path from a source to itself, and multicasting protocols (such as DVMRP <ref type="bibr" target="#b21">[22]</ref>, CBT <ref type="bibr" target="#b22">[23]</ref>, and PIM <ref type="bibr" target="#b23">[24]</ref>) that use RPF to build reverse shortest-path multicasting trees now could build true shortest-path trees.</p><p>In this paper, we present our source address validity enforcement (SAVE) protocol. SAVE builds incoming tables at routers, enabling them to verify whether each received packet has arrived from the expected incoming interface according to the packet's source address. In addition, based on the ''incoming tree'' concept we will describe, SAVE can help a router learn the path that packets from a specific source address would travel to reach this router. The SAVE protocol aims to have the following properties:</p><p>? SAVE is independent of the underlying routing protocol, so that it can easily run on top of different routing infrastructures; ? SAVE should respond to routing changes and adjust incoming table entries at every SAVE router in a timely manner; ? SAVE must be lightweight in order to minimize router overhead and scale well while achieving its goals; ? SAVE needs to cleanly handle various advanced routing techniques in use throughout the Internet (such as mobile IP, tunneling, multipath routing, as well as the inter-domain and intra-domain routing infrastructure); ? SAVE can only be deployed incrementally, and should offer benefits with incremental deployment; and</p><p>? SAVE must be secured or attackers could bypass any security it offers or even directly use SAVE to launch certain attacks.</p><p>The rest of this paper is organized as follows: Section 2 discusses related work; Section 3 describes the basic approach of SAVE; Sections 4-6 describe the protocol in detail; Section 7 discusses how SAVE deals with advanced routing techniques; Section 8 presents simulation results on the costs of running the protocol and demonstrations of its efficacy; Section 9 touches on remaining issues; and Section 10 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>Source address validity enforcement can be either router-based or end-host-based. We briefly touch upon end-host-based solutions first, then focus on router-based solutions since SAVE is router-based. We also describe hybrid solutions that need participation from both routers and end-hosts, or that both routers and end-hosts can separately apply.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">End-host-based approaches</head><p>A variety of end-host-based detection approaches can be found in <ref type="bibr" target="#b18">[19]</ref>. These approaches can be further classified as active or passive, depending on if end-hosts actively probe to determine source address validity, or if they simply observe the incoming packets.</p><p>However, routers and end-hosts both need the source address of IP packets to be valid (see <ref type="bibr">Section 1)</ref>. An end-host-based approach will not help routers in this regard.</p><p>In fact, although end-host detection is easier to deploy, it is the lack of source address inspection at routers that allows IP spoofing to run wild. Purely end-host-based approaches can indeed help verify the validity of IP source address, but only a router-based solution can prevent packets with an invalid source address from crossing the network and reaching victims.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Router-based approaches</head><p>Below we focus mostly on router-based methods, as SAVE is also router-based. Existing works include forwarding-table-based filtering, ingress/ egress filtering, route-based distributed filtering, key-based approaches, and general filtering.</p><p>Recall the strength of SAVE is that it allows every router to learn and rely on the incoming direction of IP packets in order to validate their source address.</p><p>Forwarding-table-based-filtering <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b24">25]</ref> assumes that the outgoing interface that a router uses to reach a given address, as specified by its forwarding table, is also the valid incoming interface for packets originating from that address. Unfortunately, routing asymmetry on the Internet is common <ref type="bibr" target="#b12">[13]</ref>, invalidating this assumption.</p><p>At the border of a stub network, ingress <ref type="bibr" target="#b13">[14]</ref> and egress <ref type="bibr" target="#b14">[15]</ref> filtering respectively ensure that packets from the stub network and toward the stub network have valid source IP addresses. However, this approach does not provide every router with incoming direction knowledge; and for routers at the edge of a stub network, it only can tell whether a packet with a specific source address should be inbound or outbound. SAVE allows every router to learn the correct incoming interface of source addresses.</p><p>Route-based distributed packet filtering (DPF) research in <ref type="bibr" target="#b19">[20]</ref> studied benefits of DPF filtering for attack prevention and traceback, and partial deployment strategies. Unfortunately, the work assumed the existence of a DPF system without actually designing an approach for routers to learn the correct route for every source address. More recently, researchers have proposed DPF-like implementations, including IDPF <ref type="bibr" target="#b25">[26]</ref> and BASE <ref type="bibr" target="#b26">[27]</ref>. However, besides being very BGP-specific, IDPF only learns feasible paths, not actual paths. BASE is also tightly tied to BGP, and it cannot handle AS-level routing asymmetry well.</p><p>SPM <ref type="bibr" target="#b16">[17]</ref> utilizes keys associated with source-destination AS pairs. Unlike SAVE, it cannot be used for router-based services that require incoming direction knowledge. Designed only for spoofing prevention, SPM is specific to BGP and benefits participating ASes at the AS level. Perhaps most distressing, if attackers learn the correct key for a source-destination pair, they can successfully send spoofed packets from anywhere in the network without raising suspicion.</p><p>Baker <ref type="bibr" target="#b11">[12]</ref> proposes a general filtering approach where many fields, including but not limited to the source address, can be used for filtering. For instance, martian address filtering allows routers to discard packets if their source addresses are special addresses (loopback address, broadcast address, etc.) or are not unicast addresses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Hybrid approaches</head><p>Besides methods which only routers can implement, or that only end-hosts can implement, other approaches exist which either routers or end-hosts could possibly utilize. Still other approaches require both routers and end-hosts to work together. We describe these approaches below.</p><p>One such approach is to apply cryptographic operations to guarantee authenticity of packet information, represented by IPsec <ref type="bibr" target="#b27">[28]</ref>. IPsec can be run in two modes, tunnel mode and transport mode. In tunnel mode, packets are protected between two routers, or an end-host and a router. In transport mode, packets are protected between end-hosts. Unfortunately, the high computational cost of cryptographic operations prevent such approaches from being widely employed per packet.</p><p>Hop-count filtering <ref type="bibr" target="#b17">[18]</ref> relies on spoofed packets traveling over a different number of hops than legitimate traffic. The concept could be applied by either end-hosts or routers. But, with only a small range of possible hop-counts, it has limited efficacy.</p><p>Packet tracing has been widely studied <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b8">9]</ref>, and often involves packet marking <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref><ref type="bibr" target="#b33">[34]</ref>. Generally, packet tracing involves both routers and endhosts: routers must mark packets while end-hosts often decide which packets to trace. While complementary to each other, a fundamental difference between SAVE and tracing is that tracing is typically performed after an attack is detected, possibly too late to avoid damage! Tracing IP packets with forged source addresses requires complex and often expensive techniques to observe the traffic at routers and reconstruct a packet's real path. Many tracing methods become ineffective when the volume of attack traffic is small or the attack is distributed <ref type="bibr" target="#b34">[35]</ref>.</p><p>Similar in concept to packet tracing, routers running Pi <ref type="bibr" target="#b9">[10]</ref> or StackPi <ref type="bibr" target="#b10">[11]</ref> mark each packet to identify the path that it traveled. End-hosts use the path identifiers to filter out packets which traveled along an identified attack path. Detecting attack paths, and dropping attack packets is up to the end-hosts. Routers cannot filter attack packets, nor can they discover incoming direction information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SAVE primer</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Basic approach</head><p>The goal of the SAVE protocol is to allow routers to filter packets with forged source addresses, or reli-ably perform various source-based functionalities. SAVE accomplishes this by building an incoming table at each router that specifies the valid incoming interface for packets with a specific source address.</p><p>The information needed to construct an incoming table is inherently different from that used to build a forwarding table. In a routing protocol, routing updates advertise the set of destination address spaces that routers can reach and the properties of the routes used. Each router then uses these updates and some local policies to calculate its best outgoing interface for each destination address space. On the other hand, the SAVE protocol should be designed to inform routers about the path that has already been chosen, in order to allow routers on the path to a destination to deduce valid incoming interfaces for specific source addresses.</p><p>In SAVE, every router is associated with a set of source addresses. For packets from these addresses, they must go through this router to reach certain destinations. A router that forwards packets on behalf of hosts in a local area network (LAN) has a source address space that covers addresses of those LAN hosts; a border router of an autonomous system (AS) handles the source address space of the entire AS; and a transit router with no attached hosts has a source address space that consists of all its own IP addresses.</p><p>The basic approach of SAVE works as follows. For every entry in its forwarding table, a SAVE router periodically generates SAVE updates toward the corresponding destination address space that travel along the same path as legitimate packets from this router's source address space. Forwarding table changes will also trigger new SAVE updates. In both cases, an update will specify the originating source address space and carries the destination address space. Since every SAVE update arrives on the same incoming interface as the valid IP packets from the source address space of the update, every router en route between the source and final destination can record the incoming interface of a SAVE update as the legitimate incoming interface for the source address space of the update. In addition, in order to reduce bandwidth overhead, SAVE allows intermediate routers to piggyback their own source address spaces on a passing-by SAVE update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Fundamental challenges</head><p>Although the basic SAVE operations are simple, there are several fundamental challenges. Here we discuss two of them: (1) ensuring SAVE updates follow the same path as valid data packets and (2) reacting to routing changes. We cover additional issues related to reducing overhead and handling advanced routing techniques in Sections 6 and 7, respectively.</p><p>The first issue is to ensure that the SAVE updates follow the proper packet delivery paths. The key here is that a SAVE update is forwarded toward a destination address space, not a single IP address. The SAVE protocol must account for all paths toward the addresses in a destination address space. In Fig. <ref type="figure" target="#fig_0">1</ref>, for the SAVE update that router B initiated on behalf of the source address space S B , if router A only forwards the update toward router R, router r will not be able to learn the valid incoming interface for S B . Instead, in order to ensure all downstream routers can learn the proper incoming direction information, the SAVE protocol needs to generate one SAVE update toward router R, and one toward router r.</p><p>The second issue concerns routing changes. Routing changes establish new paths from sources to destinations, and SAVE must make sure the incoming interface information will be up-to-date at every router for every source address space. In the basic approach, SAVE routers that notice a forwarding table change will initiate new SAVE updates. However, not all routers that should generate SAVE updates will necessarily experience a change in their forwarding table. In Fig. <ref type="figure">2</ref>, router D initially chooses router B as the next hop to reach address space S A . The incoming table of router A is shown in Table <ref type="table">1a</ref>. Assume that due to the failure of link BD, router D updates its forwarding table so that router C becomes its new next hop to S A . Although D will send a new SAVE update to S A , which indicates to A that packets from S D should now arrive from interface 2 instead, routers E and F do not change their forwarding entries for S A , and thus they will not regenerate SAVE updates! As a result, router A will have stale information about address spaces S E and S F (Table <ref type="table">1b</ref>).</p><p>Periodically sending SAVE updates solves the problem eventually, but not in a sufficiently timely manner. What is needed is that when router A receives a SAVE update that changes the incoming interface for address space S D , router A can decide right away that the same change should also be applied to address spaces S E and S F . SAVE handles this issue through the use of an incoming tree mechanism, which we describe in Section 5.2. Fig. <ref type="figure">2</ref>. An example topology of routers and their source address spaces. (S X stands for router X's source address space.) After link BD fails, router D changes its route to S A . A SAVE update is thus triggered at D and sent toward S A , causing router A to update its incoming table. But E and F do not detect the routing change, leaving two stale entries about S E and S F in A's incoming table <ref type="table">(Table 1</ref> properly propagate SAVE updates, ensuring SAVE updates follow the correct path; furthermore, SAVE introduces an incoming-tree-based mechanism to learn and store the valid incoming direction information for different source addresses, as well as correctly handle routing changes in a timely manner. Fig. <ref type="figure" target="#fig_1">3</ref> shows the architecture of the SAVE protocol. SAVE's main components include generating SAVE updates, processing SAVE updates, and updating the incoming tree and incoming table based on SAVE updates. We describe these components in detail below. Section 4 describes the method SAVE uses to communicate incoming direction information. Then Section 5 goes into how a router stores incoming direction information in a novel manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Architecture of SAVE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SAVE effectively addresses the above fundamental challenges. While only interfacing with the forwarding table at routers, SAVE allows routers to</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Communicating incoming direction information</head><p>SAVE routers communicate incoming direction information through SAVE updates. In this section, we describe SAVE updates themselves in detail, followed by how the updates are generated and propagated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">SAVE update</head><p>Every SAVE update has a destination address space field that specifies the final destination address space of this SAVE update. This field helps downstream SAVE routers correctly propagate a SAVE update. If a SAVE update originated from router R 1 has crossed SAVE routers R 2 , R 3 , . . ., R n in sequence in reaching the destination address space of the update, packets from the source address space of R 1 will also cross R 2 , R 3 , . . ., R n in sequence. (We will describe the SAVE update prop-agation procedure in Section 4.3.) These crossed routers can then record the incoming interface of the update as the valid incoming interface for packets from the source address space of R 1 .</p><p>In fact, while heading toward its destination address space, every SAVE update also has an address space vector (ASV) field to record a chain of source address spaces that are associated with the routers that the SAVE update has crossed in sequence, starting with the origin router of the update. If a SAVE update originated from R 1 has crossed SAVE routers R 2 , R 3 , . . ., R n in sequence, the ASV field will have the form hS 1 , S 2 , . . ., S n i, where S i is the source address space of R i (i = 1, 2, . . ., n). Every router that receives this SAVE update can be certain that valid packets en route from address space S i , towards the update's destination, will cross R i+1 , R i+2 , . . ., R n before reaching itself. (There may be some unlisted routers between R n and the current router, as we can see in Section 6.1.) In other words, every router along the path of a SAVE update can record the incoming interface of the SAVE update as the legitimate incoming interface for packets from every source address space in the ASV of the update.</p><p>Finally, to reduce bandwidth overhead by SAVE updates, in certain circumstances a SAVE router can append its update on a passing update. In other words, every SAVE update also has an appendable flag to indicate whether downstream SAVE routers can append their source address spaces to this update's ASV field. We will illustrate this flag in detail in Section 6.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Generating SAVE updates</head><p>A SAVE router generates SAVE updates for every entry in its forwarding table. If router R has source address space S R and has a forwarding entry for destination address space D, the corresponding SAVE update will be: hdestination address space = D, ASV = hS R i, appendable = truei. At this point, the ASV field only contains the source address space of R, but the next SAVE router on the path to D will be allowed to append its source address space since the appendable flag is true.</p><p>This SAVE update will head toward D. In particular, it will be forwarded along the outgoing interface specified in the forwarding entry for D. Along with the update propagation process that will be illustrated in Section 4.3, this is necessary to ensure that the update will take the same path as packets from this router's source address space. SAVE supports both triggered updates and periodic updates. Not only will a SAVE router periodically initiate SAVE updates, but whenever it detects a change in a forwarding table entry, the router will also trigger a SAVE update corresponding to this entry. The pseudocode in Fig. <ref type="figure" target="#fig_2">4</ref> describes steps for generating SAVE updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Propagating SAVE updates</head><p>Unless a SAVE router is the last hop for every address from the destination address space of a received SAVE update, the router is an intermediate hop for this update and needs to further propagate it downstream. In order for the SAVE update to reach its destination address space, the router will forward the update in the same way as it would forward regular packets toward the destination address space of the update. Doing so, the incoming interface of the SAVE update at every downstream SAVE router will be the same as-thus also recorded as-the incoming interface of all source address spaces carried in the ASV field of the update.</p><p>An intermediate SAVE router uses its forwarding table to decide how to forward a SAVE update. Denoting D the destination address space of a SAVE update, recall that the update should travel along the same path as regular packets toward D. However, the router may not have a forwarding table entry that points exactly to D. The router could have one or more forwarding table entries that point to the sub-spaces of D, or a forwarding entry that points to a super-space of D. To forward a packet with a specific destination address in D, the router needs to choose the most specific forwarding table entry that matches the destination address of the packet. Thus, in order for an update to travel along the same direction as packets towards all addresses of D, the update must be forwarded according to all such forwarding table entries.</p><p>As described in the pseudocode in Fig. <ref type="figure" target="#fig_3">5</ref>, SAVE is designed to propagate a SAVE update as follows:</p><p>? For every forwarding entry that specifies a route toward a sub-space of D, the router will create a new SAVE update, which is a duplicate of the original SAVE update except that the destination address space in the new update will be set to this sub-space. The router then needs to recursively propagate the new SAVE update in the same way as the update in question. Here, creating new updates will result in splitting the original SAVE update into multiple SAVE updates. ? If there are no sub-space forwarding entries, or all sub-space forwarding entries together do not cover the whole space of D, the forwarding entry toward the smallest super-space that covers Dwhich could be the entry that exactly points to D if it exists-will be used to forward the SAVE update. This is because this forwarding entry will be used for forwarding data packets toward D, or toward the part of D not covered by sub-space forwarding entries. Note that in this case the destination address space of the SAVE update does not change.</p><p>Finally, if a passing update is appendable according to its appendable flag (we describe the flag in Section 6.1), an intermediate SAVE router will append its own source address space to the update's ASV field before further forwarding it downstream. The ASV field allows downstream SAVE routers to record and adjust the incoming interface of packets from not only the source address spaces in the ASV field, but also other source address spaces. We illustrate this concept in Section 5. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Storing incoming direction information</head><p>SAVE routers employ two data structures for keeping track of incoming direction information: the incoming table and the incoming tree. The incoming table at a SAVE router is simple: it contains entries that specify valid incoming interfaces for different source address prefixes. The incoming tree, which is in fact used to create the incoming table, is slightly more complicated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Incoming table</head><p>The incoming table needs to be fast and efficient since it must be inside a router's fast path. Its simple concept and similarity to forwarding tables helps in this regard; routers are already highly optimized for table lookups for forwarding tables, and this optimization can also help when using incoming tables to look up valid incoming direction information.</p><p>The incoming table is further optimized to reduce the storage cost by leveraging symmetries in network routing. When routing is symmetric, i.e., a router uses the same interface for both forwarding packets to an address space and receiving packets from that space, the router's forwarding table entry for that space can also serve as the incoming table entry for that space. In other words, the router does not need to create a new incoming table entry for that space. Otherwise, when routing is asymmetric, the router adds a flag to the forwarding table entry to indicate that the incoming table must be consulted to determine the correct incoming interface. The degree to which this optimization saves storage space depends on the degree of routing asymmetry present.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Incoming tree</head><p>The incoming tree at a SAVE router serves two purposes: (1) to derive the incoming table of that router, and (2) to maintain the relationship of different source address spaces. The former is straightforward: Every node on the tree represents a source address space and is mapped to the valid incoming interface for that address space (except the root of the tree). Note a source address space can include one or more address prefixes. For the latter, the incoming tree is designed to have the following properties:</p><p>? If-and only if-a SAVE update crosses router A and then router B before reaching a router R, node S A will be the child of node S B on R's incoming tree. Here S A and S B are A's and B's source address space, respectively. Note that B and R could be separated by other routers, or are the same router. For defining parent/child relationships, S R is treated as the root node of router R's incoming tree. ? As a natural result of the first property, the incoming interface that a child node is mapped to is determined by-and the same as-the incoming interface that its parent is mapped to. ? Recursively applying the second property, all nodes from a sub-tree that is directly below the root are mapped to the same incoming interface, making building an incoming table from an incoming tree even more straightforward.</p><p>Consider router A in Fig. <ref type="figure">2</ref>. Its incoming tree before link BD fails is shown in Fig. <ref type="figure" target="#fig_5">6a</ref>, where S D is the parent of S E , and S E is the parent of S F . Triggered by the routing change at D, S D 's new SAVE update will cross C before reaching A, causing A to modify its incoming tree so that S D becomes the child of S C , and all source address spaces of D, E, and F will now correctly map to interface 2 (Fig. <ref type="figure" target="#fig_5">6b</ref>).</p><p>Another important property of an incoming tree is that not only can it help determine the ''incoming interface'' for packets from a specific source, but also the ''incoming path''. For example, Fig. <ref type="figure" target="#fig_5">6b</ref> indicates that packets from S E will pass through router D, and then C, before reaching router A. We leave the possible usage of incoming path knowledge as a topic for future investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Updating an incoming tree</head><p>Upon receipt of a SAVE update, a SAVE router uses the ASV of the SAVE update to maintain its incoming tree, and thus its incoming table (see Fig. <ref type="figure">7</ref> for a pseudocode description of the algorithm).</p><p>In general, an ASV has the form hS 1 , S 2 , . . ., S n i, where S i is the source address space of a SAVE router R i (i = 1,. . ., n). To preserve the properties of the tree discussed in Section 5.2, the incoming tree updating procedure must first ensure that the ASV will be ''grafted'' into the tree as an intact branch, where S i will be the direct child of S i+1 . Second, the procedure must map this branch to the incoming interface that the SAVE update arrived on. Third, descendants of S i on the tree must map to the same incoming interface as S i .</p><p>The tree update procedure therefore parses the ASV in reverse order (see Fig. <ref type="figure">7</ref>), processing S n , the last ASV element, first. If S n is not yet in the tree, it is grafted directly under the root; otherwise, if S n 's existing interface in the tree is not this update's incoming interface, the sub-tree under S n (not just S n itself) will be remapped to the new interface and grafted under the root. For any other element of the ASV, S i (i 5 n), given that node S i+1 has just been positioned into the tree correctly, the whole S i sub-tree can be relocated directly under node S i+1 . This could map the S i sub-tree to a new interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Optimizing SAVE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">The appendable flag</head><p>Instead of initiating a new update toward a destination address space S D , a SAVE router can piggyback the update on a passing SAVE update U that also heads toward S D . But, if the router has just initiated its own SAVE update toward S D , it can mark U as non-appendable by setting U's appendable flag as false. This router still appends its own  source address space, but all downstream routers will stop appending their source address spaces into U's ASV field, thus keeping the size of U from unnecessarily growing. Now that downstream routers do not always append their source address spaces, the ASV field of a SAVE update does not always map to the entire path that the update has traversed. However, every downstream router will still be able to derive a complete ASV that corresponds to all the routers that a SAVE update has crossed, as illustrated below.</p><p>Assume a downstream router R receives a SAVE update U(R 1 ) that originated from R 1 . The ASV field of U(R 1 ) is expressed as hS 1 , S 2 , . . ., S n i, where S i is the source address space of a SAVE router R i , and U(R 1 ) is marked as non-appendable. The nonappendable flag suggests that R n is an intermediate router and must have already initiated a SAVE update, denoted as U(R n ), toward the same destination address space as U(R 1 ). R should receive both U(R 1 ) and U(R n ). Assume the ASV field of U(R n ) is hS n , S n+1 , . . ., S n+m i. If U(R n ) is appendable, its ASV will map to the entire path from R n to R. R can then concatenate the ASV of U(R 1 ) and the ASV of U(R n ) to obtain a complete ASV, i.e. hS 1 , S 2 , . . ., S n , S n+1 , . . ., S n+m i. And this ASV maps to all routers on the path from R 1 to R. If R n 's update is marked as non-appendable, R can still successfully obtain the complete ASV for U(R 1 ) by executing a recursive procedure: learning the complete ASV corresponding to U(R n ). Note that the above concatenation does not happen literally; instead, it is implicit because of the incoming tree update procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Replaceable updates</head><p>As another optimization, SAVE does not need to forward those updates that are replaceable. An update is replaceable from the point of view of a specific SAVE router if every address space element in the update's ASV is contained by this router's source address space. This router already has produced or will produce the necessary SAVE updates to carry the information in replaceable updates. This optimization matches well with the two-level routing infrastructure of the Internet: since all packets from an AS to the outside must cross a border router, and the whole AS space is the source address space of that border router, those SAVE updates from within an AS are all replaceable and will not leak beyond the AS. Section 7.2 further discusses AS-level replaceable updates. Fig. <ref type="figure">7</ref>. Incoming tree update procedure upon receipt of a SAVE update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Routing-protocol specific optimization</head><p>As described thus far, the design of SAVE is routing-protocol independent. This important aspect allows SAVE to run on top of any routing infrastructure. However, further optimizations are possible if SAVE is allowed to use protocol-specific information.</p><p>If SAVE only runs on BGP routers, SAVE's overhead can be further reduced. Instead of using network prefixes to represent its source address spaces, a router can simply use its AS number. This optimization could decrease both the storage overhead and the traffic overhead. With a single AS number generally replacing multiple prefixes, the space required to represent a source address space decreases-possibly dramatically if the AS number is replacing many prefixes. Thus, anywhere source address spaces are used, we will see a reduction in SAVE's overhead. Specifically, a router's incoming tree will require less space, and the ASV of a SAVE update will be smaller. (In order to keep a router's fast path as streamlined as possible, AS numbers can be translated into prefixes when building the incoming table from the incoming tree.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">SAVE and advanced routing techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Multihoming and multipath routing</head><p>With the SAVE protocol implemented as described thus far, problems will arise regarding the use of multihoming and multipath routing. When multihoming or multipath routing is in use, a downstream router may receive multiple SAVE updates for the same source address space, but from different incoming directions. Without any modifications, the incoming tables of downstream routers would only consider packets matching the incoming direction for the last SAVE update received to be valid.</p><p>To solve this problem, we introduce a simple, optional tag to the source address space entries within the ASV (address space vector) field of SAVE updates. This tag identifies which home or path the update originated from or passed through, respectively. The tag only needs to be unique amongst all of the multiple homes or multiple paths. This is simple to achieve, since when an address space is multihomed, the routers in charge of that space will know; similarly, when a router has multiple outgoing paths for the same destination space, it knows. So, when a router is in charge of a multihomed space, or a router uses multipath routing, it adds the tag for the corresponding home or path to its source address space in any outgoing update's ASV. As described earlier in Section 5.2, each unique source address space in the ASV (now further differentiated by tags) corresponds to a unique node in downstream routers' incoming trees. This allows downstream routers to correctly maintain their incoming trees, and therefore incoming tables.</p><p>Fig. <ref type="figure" target="#fig_7">8a</ref> and Table <ref type="table" target="#tab_1">2a</ref> show a multihoming example. Similarly, Fig. <ref type="figure" target="#fig_7">8b</ref> and Table <ref type="table" target="#tab_1">2b</ref> contain a multipath example. Note, this solution may create incoming trees that are no longer true trees; nodes may have multiple parents. However, since the graph is directional, the functionality is not impaired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Hierarchical routing</head><p>The concept of replaceable updates (Section 6.   hierarchy for BGP routing and the intra/inter-area hierarchy for OSPF <ref type="bibr" target="#b35">[36]</ref> routing can help reduce the size of routing tables, and the intra/inter-AS hierarchy for BGP further allows organizations to hide their internal routing information from outside parties. SAVE can also take advantage of this hierarchy to have smaller incoming trees and incoming tables, while still not exposing internal routing information to outside parties. The general idea is simple and is as follows. Utilizing the intra/inter-AS hierarchy, all border routers of a given AS act as one ''virtual router'' with the entire AS as its source address space. Any update from an internal router towards an external destination space will simply be dropped by the border router. If the internal routing change which triggered the internal update also caused an AS-level routing change, the border router will generate an update itself, representing the entire AS. If there is no AS-level routing change, the border router has no reason to generate or forward the internal update towards external ASes; as far as border routers from other ASes are concerned, no incoming directions have changed. Similarly, an update traveling from an external router towards internal destinations is also dropped. As far as an internal router is concerned, the ''virtual'' router is always the incoming direction of all external traffic.</p><p>The above optimizations do not change significantly for OSPF intra/inter-area operation. For our purposes, OSPF area border routers function essentially like AS border routers above. All of the area border routers for a single area function as a single virtual router. An area border router does not forward intra-area updates to external areas, nor does it forward inter-area updates to internal routers.</p><p>When deployed at the AS-level, further optimizations from Section 6.3 can also be applied. Since all AS border routers use BGP, instead of representing the source address space of an AS using network prefixes, a border router can use the AS number of the domain. In this way, internal routers use network prefixes, while border routers use AS numbers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Mobile IP and tunneling</head><p>Some Internet traffic does not use default routing behavior, and SAVE must handle such traffic properly. Such cases include mobile IP, tunneling, source routing, etc.</p><p>Mobile IP <ref type="bibr" target="#b36">[37]</ref> potentially conflicts with SAVE in that a mobile host's packets, if carrying its home IP address, would be rejected whenever the mobile host is outside its home network (since generally it uses a different path to the destination than the rest of its home network). The reverse tunneling technique <ref type="bibr" target="#b37">[38]</ref>, proposed to handle such conflicts for general address filtering, also works for SAVE. A mobile host's packets are first tunneled from a foreign network back to its home agent, and then forwarded to the destination; thus, the source addresses of those packets are valid on each segment of the path. IPv6 requires that a packet from a mobile host in a foreign network use a care-of address (an address belonging to the foreign network) as the packet's source address <ref type="bibr" target="#b38">[39]</ref>, thus also solving the problem.</p><p>IP tunneling complicates source address validation. A packet's true source address is buried inside a wrapping IP header that contains the source address of the ingress of a tunnel, thus the true internal source address can bypass the validation. Source validation must be performed before a packet enters a tunnel as well as after the packet departs from the tunnel. For example, in Fig. <ref type="figure" target="#fig_8">9a</ref> spoofing packets from attacker A enter a tunnel at router I and depart from the tunnel at router E before reaching the destination router at D. If their source address can be found to be spoofing by SAVE routers along the path from A to I or from E to D, these packets can then be caught.</p><p>When a SAVE update reaches the ingress point of a tunnel, the update will be encapsulated and then forwarded through the tunnel as a regular data packet. There is no SAVE-related action taken on this update until it is decapsulated at the egress point of the tunnel.</p><p>In the view of SAVE, there are two different types of tunnels: those that merely add one level of encapsulation (and perhaps also IPsec for a secure tunnel), which follow the same route as regular data packets, and those that deviate from the regular routing path. The latter type can cause legitimate packets to be dropped. As shown in Fig. <ref type="figure" target="#fig_8">9b</ref>, whereas packets from S toward D normally go through router I along path ID to reach D, if I reroutes these packets through a tunnel before reaching D, they will appear to D as arriving from an illegitimate incoming direction. We handle this case using our solution for multipath routing (Section 7.1). When the ingress point of a tunnel (router I in Fig. <ref type="figure" target="#fig_8">9b</ref>) recognizes that the tunnel may introduce two legitimate paths toward a destination, it will add a tag to its source address space when forwarding SAVE updates through the tunnel, and another tag when forwarding SAVE updates through a regular path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Performance evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Simulation design</head><p>We have implemented and tested the SAVE protocol in a custom simulation environment. We performed extensive simulation experiments to obtain information related to: (1) whether all spoofed packets can be successfully detected and dropped, (2) whether valid packets are dropped erroneously, (3) the transient behavior of SAVE, and (4) the cost of SAVE.</p><p>In the simulation, all routers run the SAVE protocol in addition to routing protocols. Corresponding to the two-level routing infrastructure of the Internet, we used the transit-stub topology generator from GT-ITM <ref type="bibr" target="#b39">[40]</ref> to generate inter-domain connectivity and intra-domain connectivity. We simulated both inter-domain routing and intradomain routing. We also introduced asymmetric routing.</p><p>For inter-domain routing we used BGP <ref type="bibr" target="#b40">[41]</ref>, the de facto inter-domain routing protocol. For intradomain routing, we chose RIP <ref type="bibr" target="#b41">[42]</ref> as it is the easiest to implement in simulation. In fact, SAVE is independent of routing protocols; any routing protocol would suffice as long as it correctly creates forwarding tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.">Effectiveness against spoofed packets</head><p>Spoofed packets may escape in the following stringent or rare situations: (1) if a router's incoming table specifies that a range of IP addresses should come in from a particular direction, the router has no way of knowing if a packet with a source address in that range carries a forged source address from the same range; (2) also, prior to the adjustment based on newly received SAVE updates, certain entries at the incoming table of a SAVE router may be temporarily obsolete so that spoofed packets from a wrong direction might be regarded as valid and thus escape.</p><p>We performed extensive simulation experiments to verify the correctness of SAVE, focusing on false negatives. Each simulated packet source generates both valid packets and spoofed packets that are controlled by two independent Poisson processes. Spoofed source addresses were randomly chosen from a pool of all source addresses in the network. Every router is under an average load condition and every packet carries a reachable destination address; thus a packet can only be dropped due to address filtering or a transient routing inconsistency caused by topology changes. If SAVE can drop all spoofed packets, the distribution of dropped packets over time should match the generation model of spoofed packets. This was verified in numerous scenarios over different topologies, with the presence of asymmetric routing and dynamic routing changes. We report one such scenario in Fig. <ref type="figure" target="#fig_9">10</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.">Correctly identifying legitimate packets</head><p>When a forwarding table changes and a new route to a destination address space is being set up, there is a transient period in which the incoming tables are incorrect, due to the delay of generating, forwarding, and processing the triggered SAVE update. During this time SAVE must adjust every incoming table along the new route. If a data packet is sent toward the destination during this period, it could be erroneously dropped even though it carries a valid source address. More accurately, assuming that the propagation delay of a SAVE update is the same as that of a valid data packet, the data packet can be dropped by mistake if: 1. The data packet is sent while the SAVE update is still being generated due to a forwarding table change; in this case, the packet can reach downstream routers earlier than the SAVE update, and will be validated using the obsolete incoming information there. 2. The data packet is received at an intermediate router or its final hop while the incoming tree and the incoming table are still being updated using the triggered SAVE update; due to the obsolete entry in the incoming table, the packet will be regarded as a spoofed packet.</p><p>Given that both windows above involve only processing delay and are fairly short, we expect that few legitimate packets will be dropped due to stale incoming table entries. In our experiments we experienced no filtering drops of valid packets due to routing changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4.">Storage overhead of SAVE</head><p>The incoming table built by SAVE is on the fast path of a router and it is important that the incoming table does not take too much space. We report two different costs for the incoming table: one is the cost when all routes are asymmetric; the other is the cost with an average level of asymmetry resulted from running routing protocols in the simulation. The former case is rare but provides a worst case scenario; in general, the amount of routing asymmetry observed in the Internet is less.</p><p>In addition, we also compared the size of the corresponding fast-path data structures at a router: the incoming table <ref type="table">used</ref>    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5.">Control traffic overhead of SAVE</head><p>To assess the bandwidth requirements of SAVE, we compared the triggered and periodic bandwidth costs of SAVE and routing protocols. Again, results are presented as a comparison, since it is more meaningful than raw numbers.</p><p>Assuming SAVE updates and routing updates are initiated with the same frequency (we use every 30 s), we compared SAVE and RIP in terms of periodic bandwidth cost over single-domain topologies. Simulations over different topologies show similar results (Fig. <ref type="figure" target="#fig_10">13</ref>), where 10 different topologies were measured for each given number of routers. The ratio of SAVE bandwidth cost versus RIP bandwidth cost is lower than 1 as the number of nodes in topologies grows beyond 40, suggesting that SAVE has better scaling properties than RIP. We also measured the per-link bandwidth cost of SAVE, which varies with topology. Over those single-domain topologies in Fig. <ref type="figure" target="#fig_0">11</ref>, the maximum perlink bandwidth cost varies from 3.2 to 6.9 kbytes/s.</p><p>We also compared SAVE bandwidth in multipledomain topologies with BGP and RIP combined. Because BGP does not initiate periodic routing updates, we compared the bandwidth without periodic transmission of SAVE updates and RIP updates. The result is shown in Fig. <ref type="figure" target="#fig_2">14</ref>. In the worst case measured, SAVE uses less than 60% of the bandwidth of BGP and RIP combined. The maximum per-link bandwidth cost here varies from 0.6 to 6.4 kbytes/s over the topologies we used in Fig. <ref type="figure" target="#fig_0">12</ref>.</p><p>To measure the triggered cost, we introduced random link failures, then compared the bandwidth cost of triggered SAVE updates with that of triggered routing updates; here, the routing protocols are BGP and RIP combined in multiple-domain topologies. The comparison over a specific simulated topology with a total of 90 routers and 97 links is shown in Fig. <ref type="figure" target="#fig_3">15</ref>. Depending on the topology and the number and location of failed links, the cost varies for both SAVE and routing protocols. In most cases, however, SAVE has lower triggered bandwidth cost than routing protocols. Topology changes often start a chain reaction of triggered routing updates; by contrast, not all of these changes lead to forwarding table changes. Thus SAVE updates are not always triggered and less bandwidth is consumed.</p><p>Finally, the bandwidth cost incurred by routing protocols is already quite small compared to data traffic over the Internet. For instance, in our simulation, SAVE's bandwidth cost per link for a 92-router topology is around 120 bytes/s per link, whereas many real routers are capable of handling traffic in a  much greater magnitude of 10 Gbps or even 100 Tbps. Incurring a bandwidth cost of the same or less magnitude than routing protocols, SAVE only introduces a small amount of traffic into the Internet. SAVE's benefits should outweigh this cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Open issues</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1.">Securing the SAVE protocol</head><p>The SAVE protocol builds incoming tables usable for a variety of purposes, including providing security to the network. Special care must be taken to secure the SAVE protocol against malicious attempts to compromise, misuse or disable the protocol. The SAVE update exchange process between routers must be protected.</p><p>Securing the SAVE protocol shares some similarities with securing a routing protocol. Just as routing updates must be protected to allow correct routing protocol operation, SAVE updates must be protected to allow correct SAVE operation. We believe that existing and upcoming approaches to securing routing protocols can be leveraged to secure SAVE updates.</p><p>Given the above discussion, we suggest that:</p><p>? SAVE updates should be exchanged only between routers, excluding regular hosts. Thus, in order to mount an attack via SAVE updates, the attacker would need to compromise some router. ? Routers should establish trust relationships prior to exchanging SAVE updates. ? Each SAVE update should be signed (or encrypted) to guarantee its integrity. Replay of SAVE updates must also be prevented, using standard cryptographic methods. ? The processing (including the authentication) of SAVE updates should be lightweight to prevent a DoS attack on the SAVE router. If a SAVE router only communicates with trusted neighbors and can do so in a lightweight fashion, DoS attacks will have fewer chances to succeed.</p><p>The SAVE protocol also has a correctness issue similar to that of routing protocols-a compromised router, if undetected, can severely damage the proper functioning of the network by sending bogus SAVE updates. Some simple intrusion detection implemented in routers would help to counter this problem.</p><p>A compromised or improperly configured router may also allow some spoofing packets to get through. If a SAVE router's egress filtering is disabled, for instance, attackers residing within that router's local network would be able to spoof the addresses of networks upstream from that router. Note that these attackers would still not be able to send spoofed packets with any source and any destination, but only packets with those source/destination pairs for which their router is along the path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2.">Incremental deployment</head><p>To be of any practical use, SAVE must provide substantial value even when it is only incrementally deployed. SAVE must ensure that incoming tables can still be properly established and maintained in the presence of legacy routers, which do not run SAVE. Also, SAVE must handle data packets that carry source addresses from a legacy router's address space.</p><p>With incremental deployment, those packets which carry source addresses that cannot be found in a router's incoming table can be flagged by the router, rather than immediately dropped. This flag can tell a higher layer (such as transport or application layer) that special handling is needed. One possibility would be to deliver copies of such packets to an intrusion detection system near the target address.</p><p>If a region's routers deploy SAVE, one immediate advantage gained is that the address space of this region will be recorded in other SAVE routers' incoming tables, making the space unlikely to be chosen for spoofed source addresses. Recall that one typical DoS attack is to put the victim's address in the source address of TCP SYN packets, causing the victim to be flooded by SYN-ACK packets. Deploying SAVE routers protects the local address space from this attack.</p><p>Researchers at Purdue have evaluated incremental deployment of route-based distributed packet filtering (DPF) and suggested a deployment strategy that decreases the number of spoofable addresses while minimizing the percentage of routers performing the filtering <ref type="bibr" target="#b19">[20]</ref>. Since route-based DPF is indeed incoming-table-based filtering, this research is complementary with the SAVE protocol and directly applicable to many aspects of SAVE's deployment. It suggests that using incoming tables created by SAVE for source address validation will work well even if only a small percentage of routers run incoming-table-based filtering. It also indicates that incoming tables built with incremental SAVE deployment can be useful for traceback.</p><p>Incremental deployment of SAVE is complex and still has open issues. We are currently in the process of enhancing SAVE for incremental deployment <ref type="bibr" target="#b42">[43]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusion</head><p>Up to this point packet delivery over the Internet has been solely based on destination-address-directed forwarding. Attackers have exploited this to forge source addresses in their malicious packets to disguise their identities. Yet, without the knowledge of what direction a packet should arrive from, routers cannot filter out such attack packets. Asymmetric network routing, which became common over the years, also makes it difficult for routers to obtain such incoming direction knowledge.</p><p>Today's Internet requires correct, reliable, and secure incoming direction knowledge at all routers that need it. The SAVE protocol is the first practical step in making it possible to learn the valid incoming direction of IP packets.</p><p>The incoming tree mechanism of SAVE allows every SAVE router to learn the valid incoming direction of every packet, and more importantly, to react to routing changes with a low cost and in a timely manner! Furthermore, except for certain optional optimizations, SAVE operates by assuming no specifics of routing protocols; every SAVE router only needs to consult its forwarding table. We have demonstrated that the protocol produces correct incoming tables with reasonable costs, comparable to or less than the costs of creating forwarding tables.</p><p>We believe that the benefits of incoming direction knowledge justifies the cost of running SAVE. If for no other reason, incoming tables are already of clear value in handling the prevalent use of forged IP source addresses on attack packets. Both manual and automated responses to network attacks will be easier as the defenders will have confidence whether every packet bears a correct address, or at least an address on the same network as the attacking machine.</p><p>As we continue to improve the protocol and investigate its utility, we believe that the incoming knowledge made available by SAVE will be equally useful for many other purposes. Network problem diagnosis, IP multicast routing protocols, and vari-ous source-address-based services will all benefit from SAVE.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. An example of SAVE update forwarding.</figDesc><graphic url="image-3.png" coords="5,39.69,561.67,215.64,106.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The architecture of the SAVE protocol.</figDesc><graphic url="image-5.png" coords="6,44.02,67.32,215.64,132.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. SAVE update generation pseudocode.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Recursive SAVE update propagation procedure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The incoming tree at router A before router D's routing change.(b) The incoming tree at router A after router D's routing change.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig.6. Incoming tree example for topology in Fig.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>2) can be extended to work with the routing hierarchy present in the Internet. Both the intra/inter-AS The address space corresponding to SC is multihomed at routers C and F (SC = SF). (b) Router D uses multipath routing; both router B and router C are its legitimate next hop before reaching A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Incoming tree examples with multihoming and multipath. The topology from Fig. 2 is used.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. SAVE and IP tunneling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. SAVE effectiveness verification. In this scenario, a DDoS attack is performed from three different machines. Every packet in the simulation has a global unique sequence number. (a) Shows the pattern of spoofed packets generated at three hosts (legitimate packets are not shown). (b) Shows the patterns of packets that are dropped by SAVE. We can observe that all spoofed packets are dropped.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 13 .</head><label>13</label><figDesc>Fig.<ref type="bibr" target="#b12">13</ref>. Periodic bandwidth cost comparison between SAVE and RIP over different single-domain topologies (10 samples; confidence level: 95%).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 14 .Fig. 15 .</head><label>1415</label><figDesc>Fig. 14. Bandwidth comparison between SAVE and routing protocols (BGP &amp; RIP) over different multiple-domain topologies (10 samples; confidence level: 95%).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>).</figDesc><table><row><cell>Table 1</cell><cell></cell></row><row><cell>Example incoming tables</cell><cell></cell></row><row><cell>Source address space</cell><cell>Valid incoming interfaces</cell></row><row><cell cols="2">(a) Router A's incoming table before router D's routing change</cell></row><row><cell>(Fig. 2)</cell><cell></cell></row><row><cell>S B</cell><cell>1</cell></row><row><cell>S C</cell><cell>2</cell></row><row><cell>S D</cell><cell>1</cell></row><row><cell>S E</cell><cell>1</cell></row><row><cell>S F</cell><cell>1</cell></row><row><cell cols="2">(b) Router A's incoming table after router D's routing change</cell></row><row><cell>(Fig. 2)</cell><cell></cell></row><row><cell>S B</cell><cell>1</cell></row><row><cell>S C</cell><cell>2</cell></row><row><cell>S D</cell><cell>2</cell></row><row><cell>S E</cell><cell>1 (should be 2)</cell></row><row><cell>S F</cell><cell>1 (should be 2)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>Incoming tables with multihoming and multipath routing</figDesc><table><row><cell>Source address space</cell><cell>Valid incoming interfaces</cell></row><row><cell cols="2">(a) The incoming table corresponding to Fig. 8a</cell></row><row><cell>S B</cell><cell>1</cell></row><row><cell>S C = S F</cell><cell>1,2</cell></row><row><cell>S D</cell><cell>1</cell></row><row><cell>S E</cell><cell>1</cell></row><row><cell cols="2">(b) The incoming table corresponding to Fig. 8b</cell></row><row><cell>S B</cell><cell>1</cell></row><row><cell>S C</cell><cell>1</cell></row><row><cell>S D</cell><cell>1,2</cell></row><row><cell>S E</cell><cell>1,2</cell></row><row><cell>S F</cell><cell>1,2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>by SAVE and the forwarding table used by routing protocols. This comparison is useful in the real world. As network operators already know the storage cost of routing protocols, they can use these comparisons to further understand the storage of SAVE. Figs. 11 and 12 show the incoming table size of SAVE as well as its comparison with forwarding tables built by routing protocols. Fig. 11 compares SAVE with RIP for different single-domain topologies. Fig. 12 compares SAVE with BGP for different multiple-domain topologies. Clearly, SAVE incurs</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table Incoming Table</head><label>Incoming</label><figDesc>(No Symmetry) Forwarding Table Fig. 11. Storage cost comparison for single-domain topologies. or less storage overhead. Figs. 11 and 12 show that, in the worst case, the incoming table is similar in size to the forwarding table; and with more reasonable amounts of asymmetry present in our simulation, the storage cost of the incoming table is very small.</figDesc><table><row><cell></cell><cell>90</cell><cell></cell><cell></cell><cell>Incoming Table</cell><cell></cell></row><row><cell></cell><cell>80</cell><cell cols="3">Incoming Table (No Symmetry)</cell><cell></cell></row><row><cell></cell><cell>70</cell><cell></cell><cell cols="2">Forwarding Table</cell><cell></cell></row><row><cell>Storage Cost (KB)</cell><cell>20 30 40 50 60</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>10</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>20</cell><cell>40</cell><cell>60</cell><cell>80</cell><cell>100</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Number of Routers</cell><cell></cell></row><row><cell cols="7">Fig. 12. Storage cost comparison for multiple-domain</cell></row><row><cell cols="2">topologies.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>equal</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>J.Li  et al. / Computer Networks 52 (2008) 399-417</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>J. Li et al. / Computer Networks 52 (2008) 399-417</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>q This material is partially based upon work supported by the <rs type="funder">National Science Foundation</rs> under Grant No. <rs type="grantNumber">ANI-9980501</rs>. A</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_kHYuJe8">
					<idno type="grant-number">ANI-9980501</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">SAVE: Source address validity enforcement protocol</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mirkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Reiher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1557" to="1566" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">CERT advisory CA-2000-01 denial-of-service developments</title>
		<ptr target="http://www.cer-t.org/advisories/CA-2000-01.html" />
		<imprint>
			<date type="published" when="2000-01">January 2000</date>
		</imprint>
		<respStmt>
			<orgName>Computer Emergency Response Team</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Analysis of a denial of service attack on TCP</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Schuba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">V</forename><surname>Krsul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Spafford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zamboni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1997 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="208" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">CERT advisory CA-1998-01 smurf IP denial-of-service attacks</title>
		<ptr target="http://www.cer-t.org/advisories/CA-1998-01.html" />
		<imprint>
			<date type="published" when="1998-01">January 1998</date>
		</imprint>
		<respStmt>
			<orgName>Computer Emergency Response Team</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An analysis of using reflectors for distributed denial-of-service attacks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Communications Review (CCR)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="38" to="47" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">ICMP traceback messages</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Bellovin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-03">March 2000</date>
		</imprint>
	</monogr>
	<note>work-in-progress Internet Draft: draft-bellovin-itrace-00.txt</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Network support for IP traceback</title>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="226" to="237" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Singlepacket IP traceback</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Snoeren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Partridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Sanchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tchakountio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Strayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="721" to="734" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Stone</surname></persName>
		</author>
		<title level="m">CenterTrack: An IP overlay network for tracking DoS floods</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>Proceedings of the USENIX Security Symposium</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Pi: A path identification mechanism to defend against DDoS attack</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="93" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">New packet marking and filtering mechanisms for DDoS and IP spoofing defense</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><surname>Stackpi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal of Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1853" to="1863" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Requirements for IP Version 4 routers</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baker</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc1812.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">1812</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">End-to-end routing behavior in the Internet</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCOMM</title>
		<meeting>the ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Network ingress filtering: defeating denial of service attacks which employ IP source address spoofing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Senie</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc2827.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">2827</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Recommended Internet service provider security services and procedures</title>
		<author>
			<persName><forename type="first">T</forename><surname>Killalea</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc3013.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3013</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Security architecture for the Internet Protocol, RFC 2401, obsoleted by RFC 4301</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Atkinson</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc2401.txt" />
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">3168</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Spoofing prevention method</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bremler-Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE INFOCOM</title>
		<meeting>the IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Hop-count filtering: An effective defense against spoofed DDoS traffic</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Computer and Communications Security</title>
		<meeting>the Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="30" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Detecting spoofed packets</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Templeton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Levitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the DARPA Information Survivability Conference and Exposition</title>
		<meeting>the DARPA Information Survivability Conference and Exposition</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="164" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the effectiveness of route-based packet filtering for distributed DoS attack prevention in power-law Internets</title>
		<author>
			<persName><forename type="first">K</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCOMM</title>
		<meeting>the ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Reverse path forwarding of broadcast packets</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Dalal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Metcalfe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1040" to="1048" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multicast routing in datagram internetworks and extended LANs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Deering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="85" to="110" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Core based trees (CBT): an architecture for scalable inter-domain multicast routing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ballardie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCOMM</title>
		<meeting>the SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The PIM architecture for wide-area multicast routing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Farinacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="153" to="162" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Ingress filtering for multihomed networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Savola</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc3704.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3704</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Constructing interdomain packet filters to control IP spoofing based on BGPupdates</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chandrashekar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>IEEE Infocom</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">BASE: An incrementally deployable mechanism for viable IP spoofing prevention</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hasker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Information, Computer, and Communication Security</title>
		<meeting>the ACM Symposium on Information, Computer, and Communication Security</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Security architecture for the Internet protocol</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Seo</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc4301.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">4301</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Tracing anonymous packets to their approximate source</title>
		<author>
			<persName><forename type="first">H</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cheswick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX LISA</title>
		<meeting>the USENIX LISA</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Tabu marking scheme for IP traceback</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IPDPS</title>
		<meeting>the IPDPS</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An algebraic approach to IP traceback</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stubblefield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="119" to="137" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Trade-offs in probabilistic packet marking for IP traceback</title>
		<author>
			<persName><forename type="first">M</forename><surname>Adler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="217" to="244" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient packet marking for large-scale IP traceback</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Computer and Communications Security</title>
		<meeting>the Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="117" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">FIT: Fast Internet traceback</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE INFOCOM</title>
		<meeting>the IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On the effectiveness of probabilistic packet marking for IP traceback under denial of service attack</title>
		<author>
			<persName><forename type="first">K</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE INFOCOM</title>
		<meeting>the IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">OSPF Version 2</title>
		<author>
			<persName><forename type="first">J</forename><surname>Moy</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc2328.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">2328</biblScope>
			<biblScope unit="issue">Standard</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Perkins</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc3344.txt" />
	</analytic>
	<monogr>
		<title level="j">IP mobility support for IPv</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>RFC</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Reverse Tunneling for Mobile IP, RFC 2344</title>
		<author>
			<persName><forename type="first">G</forename><surname>Montenegro</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc2344.txt" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>obsoleted by RFC 3024</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Mobility support in IPv6</title>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Arkko</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc3775.txt" />
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3775</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">How to model an internetwork</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Zegura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Calvert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhattacharjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE INFOCOM</title>
		<meeting>the IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="594" to="602" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<author>
			<persName><forename type="first">Y</forename><surname>Rekhter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc1771.txt" />
	</analytic>
	<monogr>
		<title level="m">RFC 1771 (Draft Standard), obsoleted by RFC</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">RIP Version 2</title>
		<author>
			<persName><forename type="first">G</forename><surname>Malkin</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/rfc/rfc2453.txt" />
	</analytic>
	<monogr>
		<title level="m">RFC 2453 (Standard) (1998)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">An incrementally deployable protocol for learning the valid incoming direction of IP packets</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ehrenkranz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<idno>CIS-TR-2007-05</idno>
		<imprint>
			<date type="published" when="2007-03">March 2007</date>
		</imprint>
		<respStmt>
			<orgName>University of Oregon</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
