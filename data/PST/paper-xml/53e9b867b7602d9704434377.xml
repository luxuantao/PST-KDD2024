<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Conditional Differential Cryptanalysis of NLFSR-Based Cryptosystems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Simon</forename><surname>Knellwolf</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">FHNW</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Willi</forename><surname>Meier</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">FHNW</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">María</forename><surname>Naya-Plasencia</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">FHNW</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Conditional Differential Cryptanalysis of NLFSR-Based Cryptosystems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F4F6437B518DB6F288910C5DFCDD1EC6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>differential cryptanalysis</term>
					<term>NLFSR</term>
					<term>distinguishing attack</term>
					<term>key recovery</term>
					<term>Grain</term>
					<term>KATAN/KTANTAN</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Non-linear feedback shift registers are widely used in lightweight cryptographic primitives. For such constructions we propose a general analysis technique based on differential cryptanalysis. The essential idea is to identify conditions on the internal state to obtain a deterministic differential characteristic for a large number of rounds. Depending on whether these conditions involve public variables only, or also key variables, we derive distinguishing and partial key recovery attacks. We apply these methods to analyse the security of the eSTREAM finalist Grain v1 as well as the block cipher family KATAN/KTANTAN. This allows us to distinguish Grain v1 reduced to 104 of its 160 rounds and to recover some information on the key. The technique naturally extends to higher order differentials and enables us to distinguish Grain-128 up to 215 of its 256 rounds and to recover parts of the key up to 213 rounds. All results are the best known thus far and are achieved by experiments in practical time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>For constrained environments like RFID tags or sensor networks a number of cryptographic primitives, such as stream ciphers and lightweight block ciphers have been developed, to provide security and privacy. Well known such cryptographic algorithms are the stream ciphers Trivium <ref type="bibr" target="#b5">[5]</ref> and Grain <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b14">13]</ref> that have been selected in the eSTREAM portfolio of promising stream ciphers for small hardware <ref type="bibr" target="#b10">[9]</ref>, and the block cipher family KATAN/KTANTAN <ref type="bibr" target="#b6">[6]</ref>. All these constructions build essentially on non-linear feedback shift registers (NLFSRs). These facilitate an efficient hardware implementation and at the same time enable to counter algebraic attacks.</p><p>Stream ciphers and block ciphers both mix a secret key a and public parameter (the initial value for stream ciphers and the plaintext for block ciphers) in an involved way to produce the keystream or the ciphertext, respectively. In cryptanalysis, such systems are often analysed in terms of boolean functions that to each key k and public parameter x assign an output bit f (k, x). Several cryptanalytic methods analyse derived functions from f . They can be roughly divided into algebraic and statistical methods. The cube attack presented in <ref type="bibr" target="#b9">[8]</ref> is an algebraic method. It consists in finding many derivatives of f that are linear in the key bits such that the key can be found by solving a system of linear equations. The d-monomial test introduced in <ref type="bibr" target="#b11">[10]</ref> provides a statistical framework to analyse the distribution of degree d monomials in the algebraic normal form of f . Another statistical approach is presented in <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b15">14]</ref>, where the concept of probabilistc neutral key bits is applied to derivatives of f . The notion of cube testers introduced in <ref type="bibr" target="#b1">[2]</ref> covers many of these methods. All of them have in common that they interact with f mainly in a black box manner, exploiting the structure of the underlying primitive only indirectly.</p><p>In this paper we propose a general analysis principle that we call conditional differential cryptanalysis. It consists in analysing the output frequency of derivatives of f on specifically chosen plaintexts (or initial values). Differential cryptanalyis, introduced in <ref type="bibr" target="#b3">[4]</ref> for the analysis of block ciphers, studies the propagation of an input difference through an iterated construction and has become a common tool in the analysis of initialization mechanisms of stream ciphers, see <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b19">18]</ref>. In the case of NLFSR-based constructions, only few state bits are updated at each iteration, and the remaining bits are merely shifted. This results in a relatively slow diffusion. Inspired by message modification techniques introduced in <ref type="bibr" target="#b18">[17]</ref> for hash function cryptanalysis, we trace the differences round by round and identify conditions on the internal state bits that control the propagation of the difference through the initial iterations. From these conditions we derive plaintexts (or initial values) that follow the same characteristic at the initial rounds and allow us to detect a bias in the output difference. In some cases the conditions also involve specific key bits which enables us to recover these bits in a key recovery attack.</p><p>The general idea of conditional differential cryptanalysis has to be elaborated and adapted with respect to each specific primitive. This is effected for the block cipher family KATAN and its hardware optimized variant KTANTAN as well as for the stream ciphers Grain v1 and Grain-128. The analysis of the block cipher family KATAN/KTANTAN is based on first order derivatives and nicely illustrates our analysis principle. For a variant of KATAN32 reduced to 78 of the 254 rounds we can recover at least two key bits with probability almost one and complexity 2 22 . Comparable results are obtained for the other members of the family. We are not aware of previous cryptanalytic results on the KATAN/KTANTAN family. The analysis of Grain v1 is similar to that of KATAN, however the involved conditions are more sophisticated. We obtain a practical distinguisher for up to 104 of the 160 rounds. The same attack can be used to recover one key bit and four linear relations in key bits with high probability. Grain v1 was previously analysed in <ref type="bibr" target="#b7">[7]</ref>, where a sliding property is used to speed up exhaustive search by a factor two, and in <ref type="bibr" target="#b0">[1]</ref>, where a non-randomness property for 81 rounds could be detected.</p><p>Conditional differential cryptanalysis naturally extends to higher order derivatives. This is demonstrated by our analysis of Grain-128, which, compared to Grain v1, is surprisingly more vulnerable to higher order derivatives. We get a practical distinguisher for up to 215 of the 256 rounds and various partial key recovery attacks for only slightly less rounds. For a 197 round variant we recover eight key bits with probability up to 0.87, for a 213 round variant two key bits with probability up to 0.59. The previously best known cryptanalytic result was a theoretical key recovery attack on 180 rounds, and was able to speed up exhaustive key search by a factor 2 4 , but without the feasibility to predict the value of single key bits, see <ref type="bibr" target="#b12">[11]</ref>. Moreover, a result in <ref type="bibr" target="#b7">[7]</ref> mentions key recovery for up to 192 rounds and in <ref type="bibr" target="#b0">[1]</ref> a non-randomness property was detected in a chosen key scenario.</p><p>The paper is organised as follows. Section 2 recalls the definition of higher order derivatives of boolean functions and discusses the application of frequency tests to such derivatives. Section 3 provides the general idea of conditional differential cryptanalysis of NLFSR-based cryptosystems. In the Sections 4, 5 and 6 this idea is refined and adapted to a specific analysis of the KATAN/KTANTAN family, Grain v1 and Grain-128.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Notation and Preliminaries</head><p>In this paper F 2 denotes the binary field and F n 2 the n-dimensional vector space over F 2 . Addition in F 2 is denoted by +, whereas addition in F n 2 is denoted by ⊕ to avoid ambiguity. For 0 ≤ i ≤ n -1 we denote e i ∈ F n 2 the vector with a one at position i and zero otherwise.</p><p>We now recall the definition of the i-th derivative of a boolean function introduced in <ref type="bibr" target="#b16">[15,</ref><ref type="bibr" target="#b17">16]</ref> and we discuss the application of a frequency test to such derivatives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Derivatives of Boolean Functions</head><p>Let f : F n 2 → F 2 be a boolean function. The derivative of f with respect to a ∈ F n 2 is defined as</p><formula xml:id="formula_0">Δ a f (x) = f (x ⊕ a) + f (x).</formula><p>The derivative of f is itself a boolean function. If σ = {a 1 , . . . , a i } is a set of vectors in F n 2 , let L(σ) denote the set of all 2 i linear combinations of elements in σ. The i-th derivative of f with respect to σ is defined as</p><formula xml:id="formula_1">Δ (i) σ f (x) = c∈L(σ) f (x ⊕ c).</formula><p>We note that the i-th derivative of f can be evaluated by summing up 2 i evaluations of f . We always assume that a 1 , . . . , a i are linearly independent, since otherwise Δ (i) σ f (x) = 0 trivially holds. If we consider a keyed boolean function f (k, •) we always assume that the differences are applied to the second argument and not to the key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Random Boolean Functions and Frequency Test</head><p>Let D be a non-empty subgroup of F n 2 . A random boolean function on D is a function D → F 2 whose output is an independent uniformly distributed random variable. If f is a random boolean function on D, the law of large numbers says that for sufficiently many inputs x 1 , . . . , x s ∈ D the value</p><formula xml:id="formula_2">t = s k=1 f (x k ) -s/2 s/4</formula><p>approximately follows a standard normal distribution. Denoting </p><formula xml:id="formula_3">Φ(x) = 1 √ 2π x -∞ e -</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Frequency Test on Derivatives</head><p>If σ = {a 1 , . . . , a i } is a set of linearly independent differences, the i-th derivative of a boolean random function is again a boolean random function. Its output is the sum of 2 i independent uniformly distributed random variables. But for any two inputs x, x with x ⊕ x ∈ L(σ) the output values are computed by the same sum and thus</p><formula xml:id="formula_4">Δ (i) σ f (x) = Δ (i) σ f (x ).</formula><p>Hence, the i-th derivative is not a random function on D, but on the quotient group D/L(σ). A frequency test of Δ (i) σ f on s inputs needs s2 i queries to f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Conditional Differential Cryptanalysis of NLFSR</head><p>This section provides the general idea of our analysis. It is inspired by message modification techniques as they were introduced in <ref type="bibr" target="#b18">[17]</ref> to speed up the collision search for hash functions. We trace differences through NLFSR-based cryptosystems and exploit the non-linear update to prevent their propagation whenever possible. This is achieved by identifying conditions on the internal state variables of the NLFSR. Depending on whether these conditions involve the public parameter or also the secret key, they have to be treated differently in a chosen plaintext attack scenario. The goal is to obtain many inputs that satisfy the conditions, i.e. that follow the same differential characteristic at the initial rounds.</p><p>In more abstract terms, we analyse derivatives of keyed boolean functions and exploit that their output values are iteratively computed.</p><p>We briefly explain NLFSR-based cryptosystems and why our analysis principle applies to them. Then we define three types of conditions that control the difference propagation in NLFSR-based cryptosystems and we explain how to deal with each of these types in a chosen plaintext (chosen initial value) attack scenario. The basic strategy is refined and adapted in the later sections to derive specific attacks on KATAN/KTANTAN, Grain v1 and Grain-128.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">NLFSR-Based Cryptosystems</head><p>An NLFSR of length l consists of an initial state s 0 , . . . , s l-1 ∈ F 2 and a recursive update formula s l+i = g(s i , . . . , s l+i-1 ) for i ≥ 0, where g is a non-linear boolean function. The bit s l+i is called the bit generated at round i and s i , . . . , s l+i-1 is called the state of round i-1. Our analysis principle applies to any cryptographic construction that uses an NLFSR as a main building block. These constructions perform a certain number of rounds, generating at each round one or more bits that non-linearly depend on the state of the previous round. It is this non-linear dependency that we exploit in conditional differential cryptanalysis.</p><p>Let</p><formula xml:id="formula_5">f : F m 2 × F n 2 → F 2 denote</formula><p>the keyed boolean function that to every key k and public parameter x assigns one output bit f (k, x) of an NLFSR-based construction. If we consider a first order derivative of the function f , we apply a difference a ∈ F n 2 to the public parameter. The value Δ a f (k, x) then denotes the output difference f (k, x) + f (k, x ⊕ a). If s i is a state bit of our construction, we denote Δ a s i (k, x) the difference in this state bit for the key k, the public parameter x and the difference a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Conditions and Classification</head><p>We now introduce the concepts of our analysis principle. In general, the difference of a newly generated state bit depends on the differences and the values of previously generated state bits. Each time that Δ a s i (k, x) non-linearly depends on a bit that contains a difference, we can identify conditions on previously generated state bits that control the value of Δ a s i (k, x). In most cases, the conditions are imposed to prevent the propagation of the difference to the newly generated state bits. In particular it is important to prevent the propagation at the initial rounds. Since we want to statistically test the frequency of Δ a f (k, •) on inputs that satisfy the conditions, there is an important tradeoff between the number of imposed conditions and the number of inputs that we can derive. The conditions can not only involve bits of x, but also bits of k. We classify them into three types:</p><p>-Type 0 conditions only involve bits of x.</p><p>-Type 1 conditions involve bits of x and bits of k.</p><p>-Type 2 conditions only involve bits of k.</p><p>In a chosen plaintext (chosen initial value) scenario, type 0 conditions can easily be satisfied by the attacker, whereas he cannot control type 2 conditions at all. In most cases, type 2 conditions consist of simple equations and the probability that they are satisfied for a uniformly random key can easily be determined. Since we do not assume that our attacks can be repeated for more than one key, type 2 conditions generally decrease the advantage of distinguishing attacks and define classes of weak keys for this kind of attacks. On the other hand we specifically exploit type 2 conditions to derive key recovery attacks based on hypothesis tests. This is explained in Section 6 where we analyse Grain-128.</p><p>In a different way, also type 1 conditions can be used to recover parts of the key. To deal with the type 1 conditions, we introduce the concept of free bits. Suppose that the state bit s i depends on x as well as on some bits of k, and suppose that we want to satisfy the type 1 condition s i = 0. In a chosen plaintext scenario, we cannot control this condition in a simple way. We call those bits of x that do not influence the value of s i for any key k, the free bits for the condition. The remaining bits of x are called non-free. Together with k the nonfree bits determine whether the condition is satisfied or not. We call x a valid input if, for a given key k, it satisfies the imposed condition. If we define the set ϕ as ϕ = {e i ∈ F n 2 |x i is a free bit} then we can generate 2 |ϕ| valid inputs from a single valid input x: these are the elements of the coset x ⊕ L(ϕ). In general, more than one type 1 condition are imposed. In that case, the free bits are those that are free for all of these conditions. In some cases it may be possible to give a finite number of configurations for the non-free bits such that at least one configuration determines a valid input. Otherwise, if t type 1 conditions are imposed, we expect that about one of 2 t different inputs is valid and we just repeat the attack several times with different random inputs.</p><p>In some cases we can not obtain enough inputs only by the method of free bits. We then try to find non-free bits that only must satisfy a given equation but otherwise can be freely chosen. This provides us with more degrees of freedom to generate a sample of valid inputs. We refer to the analysis of KATAN and Grain v1 for concrete examples of this method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Choosing the Differences</head><p>The choice of a suitable difference for conditional differential cryptanalysis is not easy and strongly depends on the specific construction. In particular this holds for higher order derivatives, but also for first order ones. In general, the difference propagation should be controllable for as many rounds as possible with a small number of conditions. In particular, there should not be too many type 1 and type 2 conditions at the initial rounds. Differences which can be controlled by isolated conditions of type 1 or type 2 are favorable for key recovery attacks.</p><p>The set of differences for higher order derivatives can be determined by combining first order differences whose characteristics do not influence each other at the initial rounds. In a non-conditional setting, <ref type="bibr" target="#b0">[1]</ref> describes a genetic algorithm for finding good sets of differences. This black-box approach did not yield particularly good sets for our conditional analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Analysis of KATAN/KTANTAN</head><p>KATAN/KTANTAN is a family of lightweight block ciphers proposed in <ref type="bibr" target="#b6">[6]</ref>. The family consists of six ciphers denoted by KATANn and KTANTANn for n = 32, 48, 64 indicating the block size of the cipher. All instances accept an 80-bit key and use the same building blocks, namely two NLFSRs and a small LFSR acting as a counter. The only difference between KATANn and KTANTANn is the key scheduling.</p><p>In the following we describe KATAN32 and provide the details of our analysis for this particular instance of the family. Our analysis of the other instances is very similar. We only sketch the differences and provide the empirical results.</p><p>We emphasize that our analysis does not reveal a weakness of any of the original KATAN/KTANTAN ciphers. In contrary, with respect to our method, it seems that the number of rounds is sufficiently large to provide a confident security margin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Description of KATAN32</head><p>The two NLFSRs of KATAN32 have length 13 and 19 and we denote their states by l i , . . . , l i+12 and r i , . . . , r i+18 , respectively. A 32-bit plaintext block x is loaded to the registers by l i = x 31-i for 0 ≤ i ≤ 12 and r i = x 18-i for 0 ≤ i ≤ 18. The LFSR has length 8 and we denote its state by c i , . . . , c i+7 . Initialization is done by c i = 1 for 0 ≤ i ≤ 6 and c 7 = 0. The full encryption process takes 254 rounds defined by</p><formula xml:id="formula_6">c i+8 = c i + c i+1 + c i+3 + c i+8 , l i+13 = r i + r i+11 + r i+6 r i+8 + r i+10 r i+15 + k 2i+1 , r i+19 = l i + l i+5 + l i+4 l i+7 + l i+9 c i + k 2i ,</formula><p>where k 0 , . . . , k 79 are the bits of the key and k i is recursively computed by</p><formula xml:id="formula_7">k j+80 = k j + k j+19 + k j+30 + k j+67</formula><p>for i ≥ 80. Finally, the states of the two NLFSRs are output as the ciphertext.</p><p>If we consider a round-reduced variant of KATAN32 with r rounds, the bits l r+i for 0 ≤ i ≤ 12 and r r+i for 0 ≤ i ≤ 18 will be the ciphertext.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Key Recovery for KATAN32 Reduced to 78 Rounds</head><p>Our analysis is based on a first order derivative and uses the concept of free bits to satisfy type 1 conditions. Here, to obtain enough inputs, we will identify non-free bits that only must satisfy an underdefined system of linear equations, which gives us more freedom degrees generate the samples. We consider a difference of weight five at the positions 1,7,12,22 and 27 of the plaintext block. Let a = e 1 ⊕ e 7 ⊕ e 12 ⊕ e 22 ⊕ e 27 denote the initial difference. At round 0 we have</p><formula xml:id="formula_8">Δ a l 13 (k, x) = 1 + x 10 , Δ a r 19 (k, x) = x 24 + 1</formula><p>and impose the conditions x 10 = 1 and x 24 = 1 to prevent the difference propagation. Similarly at the rounds 1, 2, 3 and 5, we impose the bits x 2 , x 6 , x 5 , x 9 , x 19 , x 25 to be zero. At round 7 we have</p><formula xml:id="formula_9">Δ a l 20 (k, x) = r 22</formula><p>and we impose the first type 1 condition</p><formula xml:id="formula_10">r 22 = x 28 + x 23 + x 21 + k 6 = 0. (<label>1</label></formula><formula xml:id="formula_11">)</formula><p>At round 9 we impose x 3 = 0. Then three additional type 1 conditions</p><formula xml:id="formula_12">r 19 = x 31 + x 26 + x 27 + x 22 + k 0 = 1,<label>(2)</label></formula><formula xml:id="formula_13">r 23 = x 27 + x 22 + x 23 x 20 + x 18 + x 7 + x 12 + k 1 + k 8 = 0,<label>(3)</label></formula><formula xml:id="formula_14">r 26 = 1 + x 20 (x 17 + k 3 ) + k 14 = 0 (4)</formula><p>are imposed at the rounds 11, 13 and 20.</p><p>The free bits for these conditions can be directly read from the equations. They are: 0 , x 4 , x 8 , x 11 , x 13 , x 14 , x 15 , x 16 , x 29 and x 30 .</p><p>So far, for any valid plaintext we can derive a sample of 2 10 valid plaintexts. Since, in this case, this is not enough to perform a significant frequency test, we try to obtain larger samples by better analysing the non-free bits. Looking at the equations (1) to ( <ref type="formula">4</ref>), we note that the non-free bits x 7 , x 12 , x 18 , x 21 , x 22 , x 26 , x 27 , x 28 and x 31 only occur linearly. They can be freely chosen as long as they satisfy the system of linear equations ⎧ ⎨ ⎩</p><p>x 28 + x 21 = A x 31 + x 26 + x 27 + x 22 = B x 27 + x 22 + x 18 + x 7 + x 12 = C for constants A, B, C. This system has 2 6 different solutions that can be added to each valid plaintext. In total this gives a sample of size 2 16 that we can generate from a valid plaintext. Since we imposed 9 type 0 conditions we are left with 2 5 different samples of plaintexts for a given key. The conditions are satisfied for at least one of these samples. On this sample the difference in bit 18 of the ciphertext after 78 rounds (this is bit r 78 ) is strongly biased. We perfom a frequency test of Δ a r 78 (k, •) on each of the 2 5 generated samples. At significance level α = 10 -4 the frequency test fails on at least one of them with probability almost one, and if it fails, all four type 1 conditions are satisfied with probability almost one. This allows us to recover k 0 , k 6 , the relation k 1 + k 8 and either k 14 (if x 20 = 0) or the relation k 3 + k 14 with high probability. The complexity of this attack is 2 22 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Analysis of KATAN48 and KATAN64</head><p>All the three members of the KATAN family perform 254 rounds, they use the same LFSR and the algebraic structure of the non-linear update functions is the same. The differences between the KATANn ciphers are the block size n, the length of the NLFSRs, the tap positions for the non-linear update and the number of times the NLFSRs are updated per round.</p><p>For KATAN48 the NLFSRs have length 19 and 29 and each register is updated twice per round. We obtained our best result with a difference of weight four at the positions 1, 10, 19 and 28 in the plaintext block. Imposing four type 0 conditions and two type 1 conditions we are able to derive a sample of size 2 31 from a valid plaintext. This allows us to recover the key bit k 12 and the relation k 1 + k 14 after 70 rounds (this corresponds to 140 updates of the NLFSRs) with a complexity of 2 34 .</p><p>For KATAN64 the NFLSRs have length 25 and 39 and each register is updated three times per round. We obtained our best result with a difference of weight three at the positions 0, 13 and 26. Imposing six type 0 conditions and two type 1 conditions we are able to derive a sample of size at least 2 32 from a valid plaintext. This allows us to recover k 2 and k 1 + k 6 after 68 rounds (204 updates of the NLFSRs) with a complexity of 2 35 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Analysis of the KTANTAN Family</head><p>KTANTANn is very similar to KATANn. They only differ in the key scheduling part. In KATAN the key is loaded into a register and linearly expanded to the round keys after round 40. Until round 40 the original key bits are used as the round keys. In KTANTAN, from the first round, the round keys are a linear combination of key bits (depending on the state of the counter LFSR, which is entirely known). Hence, our analysis of KATANn directly translates to KTANTANn, but instead of recovering a single key bit, we recover a linear relation of key bits. For instance in KATAN32 we recover the relation k 7 + k 71 instead of bit k 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Analysis of Grain v1</head><p>Grain v1 is a stream cipher proposed in <ref type="bibr" target="#b14">[13]</ref> and has been selected for the final eSTREAM portfolio <ref type="bibr" target="#b10">[9]</ref>. It accepts an 80-bit key k and a 64-bit initial value x. The cipher consists of three building blocks, namely an 80-bit LFSR, an 80-bit NLFSR and a non-linear output function. The state of the LFSR is denoted by s i , . . . , s i+79 and the state of the NLFSR by b i , . . . , b i+79 . The registers are initialized by b i = k i for 0 ≤ i ≤ 79, s i = x i for 0 ≤ i ≤ 63 and s i = 1 for 64 ≤ i ≤ 79 and updated according to</p><formula xml:id="formula_15">s i+80 = f (s i , . . . , s i+79 ), b i+80 = g(b i , . . . , b i+79 ) + s i ,</formula><p>where f is linear and g has degree 6. The output function is taken as</p><formula xml:id="formula_16">z i = k∈A b i+k + h(s i+3 , s i+25 , s i+46 , s i+64 , b i+63 ),</formula><p>where A = {1, 2, 4, 10, 31, 43, 56} and h is defined as</p><formula xml:id="formula_17">h(s i+3 , s i+25 , s i+46 , s i+64 , b i+63 ) = s i+25 + b i+63 + s i+3 s i+64 + s i+46 s i+64 + s i+64 b i+63 + s i+3 s i+25 s i+46 + s i+3 s i+46 s i+64 + s i+3 s i+46 b i+63 + s i+25 s i+46 b i+63 + s i+46 s i+64 b i+63</formula><p>The cipher is clocked 160 times without producing any keystream. Instead the output function is fed back to the LFSR and to the NLFSR.</p><p>If we consider round-reduced variants of Grain v1 with r initialization rounds, the feedback of the output stops after r rounds and the first keystream bit is z r .</p><p>Our analysis is similar to the one of KATAN32, but the equations for the conditions are more complex. We first present an attack on 97 rounds and then extend it to 104 rounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Distinguishing Attack and Key Recovery for 97 Rounds</head><p>Our analysis is based on the first order derivative with respect to a single difference in bit 37 of the initial value. Let a = e 37 denote the difference. The first conditions are defined at round 12, where the difference in s 37 eventually propagates to the state bits s 92 and b 92 via the feedback of z 12 . We have</p><formula xml:id="formula_18">Δ a z 12 (k, x) = 1 + x 15 x 58 + x 58 k 75 .</formula><p>We impose the type 0 condition x 58 = 1 and we define the type 1 condition x 15 + k 75 = 0 to prevent the propagation. The next conditions are determined at round 34, where we have Δ a z 34 (k, x) = s 98 + x 59 s 80 + s 80 s 98 + s 80 b 97 .</p><p>We define the conditions s 80 = 0 and s 98 = 0. Similarly we determine s 86 = 0 and s 92 = 0 at the rounds 40 and 46, respectively. So far, we imposed one type 0 condition at round 12 and we have five type 1 conditions at the rounds 12, 34, 40 and 46. The type 1 conditions jointly have 25 free bits:</p><p>x 7 , x 8 , x 10 , x 11 , x 14 , x 16 , x 17 , x 20 , x 22 , x 24 , x 28 , x 30 , x 32 , x 33 , x 34 , x 36 , x 39 , x 42 , x 45 , x 49 , x 54 , x 55 , x 59 , x 60 and x 61 .</p><p>In average we expect that one out of 2 5 randomly chosen initial values satisfies the conditions. We define a distinguisher that chooses 2 5 random initial values and for each performs a frequency test of Δ a z 97 (k, •) on the sample of 2 25 inputs generated by the free bits. Instead of randomly choosing 2 5 initial values we can choose 2 4 and test each of them for x 15 = 0 and x 15 = 1. This guarantees that the condition from round 12 is satisfied for at least one of them. Experiments with 2 10 keys at a significance level α = 0.005 show that at least one of the 2 5 tests fails with probability 0.99. This gives a distinguisher with complexity 2 31 and advantage of about 0.83 for Grain v1 reduced to 97 rounds.</p><p>The two conditions x 15 +k 75 = 0 and s 86 = 0 are crucial to obtain a significant bias after 97 rounds. In a key recovery scenario this reveals information about the key. Experiments show that both conditions hold with probability almost one if the frequency test fails. This recovers the key bit k 75 and the value of k 7 + k 8 + k 10 + k 37 + k 49 + k 62 + k 69 (coming from s 86 = 0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Extension to 104 Rounds</head><p>Using the same conditions as before, we extend the attack to 104 rounds. We use the same idea as for KATAN32 to increase the size of the sample that can be generated from one initial value. We gain four additional degrees of freedom by noting that the non-free bits x 6 , x 19 , x 29 , x 44 and x 57 influence only the condition imposed at round 40 and must only satisfy the linear equation</p><formula xml:id="formula_19">x 6 + x 19 + x 29 + x 44 + x 57 = A</formula><p>for a constant A. In total, we can now derive a sample of size 2 29 from one initial value.</p><p>The distinguisher defined above has now a complexity of 2 35 and advantage of about 0.45. When the frequency test fails, the conditions x 15 + k 75 = 0 and s 92 = 0 are satisfied with a probability almost one, which gives us k 75 and the value of k 13 + k 14 + k 16 + k 22 + k 43 + k 55 + k 68 (coming from s 92 = 0). The remaining three conditions are satisfied with a probability about 0.70 and give us similar relations in the key bits.</p><p>The sample size can be further increased, because also the non-free bits x 13 , x 23 , x 38 , x 51 and x 62 only must satisfy a linear equation. This gives a distinguisher with complexity 2 39 and advantage of about 0.58.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Analysis of Grain-128</head><p>Grain-128 was proposed in <ref type="bibr" target="#b13">[12]</ref> as a bigger version of Grain v1. It accepts a 128-bit key k and a 96-bit initial value x. The general construction of the cipher is the same as for Grain v1, but the LFSR and the NLFSR both contain 128bits. The content of the LFSR is denoted by s i , . . . , s i+127 and the content of the NLFSR is denoted by b i , . . . , b i+127 . The initialization with the key and the initial value is analogous to Grain v1 and the update is performed according to</p><formula xml:id="formula_20">s i+128 = f (s i , . . . , s i+127 ), b i+128 = g(b i , . . . , b i+127 ) + s i ,</formula><p>where f is linear and g has degree 2. The output function is taken as</p><formula xml:id="formula_21">z i = k∈A b i+k + h(b i+12 , s i+8 , s i+13 , s i+20 , b i+95 , s i+42 , s i+60 , s i+79 , s i+95 ),</formula><p>where A = {2, 15, 36, 45, 64, 73, 89} and h is defined as</p><formula xml:id="formula_22">h(x) = b i+12 s i+8 + s i+13 s i+20 + b i+95 s i+42 + s i+60 s i+79 + b i+12 b i+95 s i+95</formula><p>The cipher is clocked 256 times without producing any keystream. Instead the output function is fed back to the LFSR and to the NLFSR.</p><p>If we consider round-reduced variants of Grain-128 with r initialization rounds, the feedback of the output stops after r rounds and the first keystream bit is z r .</p><p>For the analysis of Grain-128 we use higher order derivatives. The general idea of conditional differential cryptanalysis naturally extends. As in the case of first order derivatives we always assume that the differences are applied to the initial value and not to the key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Distinguishing Attack up to 215 Rounds</head><p>Our attack is based on a derivative of order thirteen with respect to the set of differences σ = {e 0 , e 1 , e 2 , e 34 , e 35 , e 36 , e 37 , e 65 , e 66 , e 67 , e 68 , e 69 , e 95 }.</p><p>These differences are chosen because they do not influence each other in the initial rounds. As a consequence the corresponding differential characteristic (of order thirteen) is zero for as many as 170 rounds. This can be extended to 190 rounds by imposing simple type 0 conditions that control the propagation of each single difference. As an example we derive the conditions for the difference e 65 . The first condition is derived from round 5, where we have</p><formula xml:id="formula_23">Δ e65 z 5 (k, x) = x 84 .</formula><p>We impose x 84 = 0. In the same way the conditions x 58 = 0 and x 72 = 0 prevent difference propagation at rounds 45 and 52. At round 23 we have</p><formula xml:id="formula_24">Δ e65 z 23 (k, x) = k 118 .</formula><p>As we will see below, the type 2 condition k 118 = 0 determines a class of weak keys for the distinguishing attack.</p><p>Proceeding the same way for the other differences we derive 24 type 0 conditions that consist in setting the following bits to zero: x 27 , x 28 , x 29 , x 30 , x 41 , x 42 , x 43 , x 44 , x 58 , x 59 , x 60 , x 61 , x 62 , x 72 , x 73 , x 74 , x 75 , x 76 , x 77 , x 84 , x 85 , x 86 , x 87 , x 88 . In addition to k 118 the key bits k 39 , k 119 , k 120 and k 122 can be identified to define classes of weak keys.</p><p>There are 2 96-13-24 = 2 59 initial values that are different in F n 2 /L(σ) and satisfy all type 0 conditions. We define a distinguisher that performs a frequency test of Δ <ref type="bibr" target="#b14">(13)</ref> σ z r (k, •) on 2 12 of these inputs. Table <ref type="table" target="#tab_1">1</ref> summarizes the empirical results obtained for 2 12 different keys tested at a significance level α = 0.005. The indicated values denote the probabilty 1-β, where β denotes the probability that Δ  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Key Recovery up to 213 Rounds</head><p>In this section we specifically exploit type 2 conditions to recover single key bits with high probability. The attack is explained by a prototypical example that recovers three bits of Grain-128 reduced to 197 rounds with a probability up to 0.87. It is based on a derivative of order five and can easily be extended to recover more bits by using slightly other derivatives. This is demonstrated by an attack that recovers eight bits using two additional derivatives (both of order five). A second attack uses the derivative of order thirteen from the previous section and recovers three bits for Grain-128 reduced to 213 rounds with a probability up to 0.59.</p><p>Prototypical Example. We use a derivative of order five with respect to the differences σ = {e 1 , e 36 , e 66 , e 67 , e 68 }. In the same way as in the distinguishing attack, we impose conditions on the initial value to control the propagation of each difference. Altogether we impose 12 type 0 conditions and denote by W the set of initial values satisfying all of them. The crucial observation is the following. The key bit k 121 controls the characteristic of e 68 in the very early phase of initialization, namely at round 26. If k 121 = 1 the difference propagates, otherwise it does not. This strongly influences the frequency of Δ</p><p>(5) σ z r (k, •) after r = 197 rounds. Similar strong influences can be found for k 40 after r = 199 rounds and for k 119 after r = 200 rounds. This allows to recover these bits by a binary hypothesis tests. Key Recovery by Hypothesis Test. Let X be a uniformly distributed random variable taking values in W/L(σ) and define p r (k) = Pr[Δ (5)  σ z r (k, X) = 1].</p><p>If the key is considered as a uniformly distributed random variable K, p r (K) is a random variable in the interval [0, 1]. Our attack is based on the observation that the conditional distributions of p r (K) conditioned on K i = 0 and K i = 1, for well chosen i, strongly differ even for a large number of rounds. This can be exploited to perform a binary hypothesis test on the value of K i . An attacker can estimate a single observation pr of p r (K) to take her decision. Since in all our attacks the expectation of p r (K) conditioned on K i = 0 is significantly smaller than the conditional expectation conditioned on K i = 1, we determine a parameter π ∈ [0, 1] and take our decision according to the rule defined as</p><formula xml:id="formula_25">K i = 0 if pr &lt; π 1 otherwise.</formula><p>The success probability of the attack essentially depends on the choice of π. If we denote α = Pr[p r (K) ≥ π|K i = 0] the probability that we falsely guess K i = 1 and β = Pr[p r (K) &lt; π|K i = 1] the corresponding probability that we falsely guess K i = 0, then the probability of a correct decision, denoted P c , is given as</p><formula xml:id="formula_26">P c = 1 -(α + β)/2.</formula><p>An optimal π maximizes P c . Since the conditional distributions of p r (K) are not known explicitely, we empirically determine π in a precomputation phase of the attack.</p><p>Back to the Example. The first row of Table <ref type="table" target="#tab_2">2</ref> shows the precomputed parameters π and the resulting probability P c for our prototypical example. The precomputation of each π was done for 2 14 key pairs and 2 14 initial values for each key. This gives an overall precomputation complexity of 6 • 2 33 since we have to compute two histograms for each key bit. The attack itself consists in estimating pr for r = 197, 199 and 200. Note that all three estimates can be obtained by the same computation which has complexity 2 19 when estimating over 2 14 initial values. The probabilities P c are not completely independent and the probability of correctly guessing all three bits together is about 0.463.</p><p>Recovering 8 Bits after 197 Rounds. The prototypical example can be extended by using two other sets of differences which are obtained by shifting all differences by one position to the left and to the right, respectively. This allows to recover five additional bits of the key, namely k 39 , k 40 , k 118 , k 120 and k 122 . The complexities of this extended attack are 9•2 34 for the precomputation and 3•2 19 for the attack itself. We recover all eight bits correctly with a probability of 0.123. This can be improved up to 0.236 by first determining k 121 and k 122 and then recovering the remaining bits conditioned on the values of k 121 and k 122 .</p><p>Recovering Bits up to 213 Rounds. If we use the derivative of order thirteen that we already used in the distinguishing attack, after 213 rounds we can recover two key bits with probability of almost 0.6. The last row of Table <ref type="table" target="#tab_2">2</ref> summarizes the results. Here, the precomputation was done for 2 12 key pairs and 2 12 initial values for each key which gives a precomputation complexity of 2 38 . The complexity of the attack itself is 2 25 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We presented a first analysis of the KATAN/KTANTAN family as well as the best known cryptanalytic results on Grain v1 and Grain-128. This was obtained by conditional differential cryptanalysis which also applies to other NLFSRbased contructions and provides further hints for choosing an appropriate number of rounds with regard to the security/efficiency tradeoff in future designs of such constructions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>( 13 )</head><label>13</label><figDesc>σ z r (k, •) passes the frequency test. Our distinguisher has complexity 2 25 and advantage 1-α-β. The values in the first row are obtained without any condition on the key. They show that we can distinguish Grain-128 reduced to 215 rounds with an advantage of about 0.008. The other rows indicate the probabilities for the classes of weak keys defined by the indicated type 2 conditions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Distinguishing attack on Grain-128 reduced to r rounds: Probability 1 -β for α = 0.005 and complexity 2 25 . Type 2 conditions define classes of weak keys.</figDesc><table><row><cell>type 2</cell><cell>r = 203</cell><cell>r = 207</cell><cell>r = 211</cell><cell>r = 213</cell><cell>r = 215</cell></row><row><cell>condition</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>-</cell><cell>1.000</cell><cell>0.587</cell><cell>0.117</cell><cell>0.173</cell><cell>0.013</cell></row><row><cell>k39 = 0</cell><cell>1.000</cell><cell>0.630</cell><cell>0.128</cell><cell>0.275</cell><cell>0.017</cell></row><row><cell>k118 = 0</cell><cell>1.000</cell><cell>0.653</cell><cell>0.177</cell><cell>0.231</cell><cell>0.024</cell></row><row><cell>k119 = 0</cell><cell>1.000</cell><cell>0.732</cell><cell>0.151</cell><cell>0.267</cell><cell>0.025</cell></row><row><cell>k120 = 0</cell><cell>1.000</cell><cell>0.876</cell><cell>0.234</cell><cell>0.249</cell><cell>0.026</cell></row><row><cell>k122 = 0</cell><cell>1.000</cell><cell>0.668</cell><cell>0.160</cell><cell>0.285</cell><cell>0.015</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Key recovery for reduced Grain-128: Pc is the probability of correctly guessing key bit ki. The attack complexity is 2 19 for |σ| = 5 and 2 25 for |σ| = 13.</figDesc><table><row><cell>Difference set</cell><cell>ki</cell><cell>r</cell><cell>π</cell><cell>Pc</cell></row><row><cell>σ = {e1, e36, e66, e67, e68}</cell><cell>k40</cell><cell>199</cell><cell>0.494</cell><cell>0.801</cell></row><row><cell></cell><cell>k119</cell><cell>200</cell><cell>0.492</cell><cell>0.682</cell></row><row><cell></cell><cell>k121</cell><cell>197</cell><cell>0.486</cell><cell>0.867</cell></row><row><cell>σ = {e0, e1, e2, e34, e35, e36, e37,</cell><cell>k39</cell><cell>213</cell><cell>0.490</cell><cell>0.591</cell></row><row><cell>e65, e66, e67, e68, e69, e95}</cell><cell>k72</cell><cell>213</cell><cell>0.488</cell><cell>0.566</cell></row><row><cell></cell><cell>k119</cell><cell>206</cell><cell>0.356</cell><cell>0.830</cell></row><row><cell></cell><cell>k120</cell><cell>207</cell><cell>0.486</cell><cell>0.807</cell></row><row><cell></cell><cell>k120</cell><cell>211</cell><cell>0.484</cell><cell>0.592</cell></row><row><cell></cell><cell>k122</cell><cell>213</cell><cell>0.478</cell><cell>0.581</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was partially supported by the European Commission through the ICT programme under contract ICT-2007-216676 ECRYPT II.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by the Hasler Foundation www.haslerfoundation.ch under project number 08065. Supported by an ERCIM "Alain Bensoussan" Fellowship Programme.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Efficient FPGA Implementations of High-Dimensional Cube Testers on the Stream Cipher Grain-128</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Aumasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Henzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>SHARCS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cube Testers and Key Recovery Attacks on Reduced-Round MD6 and Trivium</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Aumasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Dunkelman</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5665</biblScope>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Dunkelman</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
		<title level="m">Differential Cryptanalysis in Stream Ciphers. Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2007">2007/218 (2007</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Differential Cryptanalysis of DES-like Cryptosystems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1990</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">537</biblScope>
			<biblScope unit="page" from="2" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Trivium: A Stream Cipher Construction Inspired by Block Cipher Design Principles</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Cannière</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISC 2006</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Katsikas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>López</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Gritzalis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4176</biblScope>
			<biblScope unit="page" from="171" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">KATAN and KTANTAN -A Family of Small and Efficient Hardware-Oriented Block Ciphers</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Cannière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Dunkelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Knezevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES 2009</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Clavier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Gaj</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5747</biblScope>
			<biblScope unit="page" from="272" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Analysis of Grain&apos;s Initialization Algorithm</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Cannière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ö</forename><surname>Küçük</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFRICACRYPT 2008</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5023</biblScope>
			<biblScope unit="page" from="276" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cube Attacks on Tweakable Black Box Polynomials</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="278" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://www.ecrypt.eu.org/stream/" />
		<title level="m">ECRYPT: The eSTREAM project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Framework for Chosen IV Statistical Analysis of Stream Ciphers</title>
		<author>
			<persName><forename type="first">H</forename><surname>Englund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Turan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INDOCRYPT 2007</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Srinathan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Rangan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4859</biblScope>
			<biblScope unit="page" from="268" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Chosen IV Statistical Analysis for Key Recovery Attacks on Stream Ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khazaei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFRICACRYPT 2008</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5023</biblScope>
			<biblScope unit="page" from="236" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A Stream Cipher Proposal: Grain-128</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maximov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1614" to="1618" />
		</imprint>
		<respStmt>
			<orgName>ISIT</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Grain: A Stream Cipher for Constrained Environments</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJWMC</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="86" to="93" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">New Directions in Cryptanalysis of Self-Synchronizing Stream Ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khazaei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INDOCRYPT 2008</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Chowdhury</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Das</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5365</biblScope>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Truncated and Higher Order Differentials</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 1994</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1008</biblScope>
			<biblScope unit="page" from="196" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Higher order derivatives and differential cryptanalysis</title>
		<author>
			<persName><forename type="first">X</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communicationis and Cryptography: Two Sides of one Tapestry</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Blahut</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Costello</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Mittelholzer</surname></persName>
		</editor>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="227" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">How to Break MD5 and Other Hash Functions</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2005</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Resynchronization Attacks on WG and LEX</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2006</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">J B</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4047</biblScope>
			<biblScope unit="page" from="422" to="432" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
