<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Efficient XPath Query Processor for XML Streams</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yi</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Susan</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Yifeng</forename><surname>Zheng</surname></persName>
							<email>yifeng@cis.upenn.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">An Efficient XPath Query Processor for XML Streams</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2D892EB58A6BDAF2D98EF8CE5C6FC008</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Streaming XPath evaluation algorithms must record a potentially exponential number of pattern matches when both predicates and descendant axes are present in queries, and the XML data is recursive. In this paper, we use a compact data structure to encode these pattern matches rather than storing them explicitly. We then propose a polynomial time streaming algorithm to evaluate XPath queries by probing the data structure in a lazy fashion. Extensive experiments show that our approach not only has a good theoretical complexity bound but is also efficient in practice.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>XML has become the de facto standard for data exchange. The problem of efficiently evaluating XML queries, e.g. XPath, in both main memory and streaming environments has therefore attracted a lot of attention from the research community <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b27">28]</ref>.</p><p>In this paper, we focus on a streaming environment, as found with stock market data, network monitoring or sensor networks. In such an environment, data streams, which can be potentially infinite, arrive continuously and must be processed using a single sequential scan because of the limited storage space available. Query results should be distributed incrementally and as soon as they are found, potentially before we read all the data. Furthermore, the query processing algorithm should scale well in time and space. An algorithm that meets these requirements for XPath processing over XML data is called a streaming XPath evaluation algorithm.</p><p>Several streaming XPath evaluation algorithms based on finite state automata (FSA) have been proposed to process XPath queries containing the child axis ('/'), descendant axis ('//') and wildcard ('*') <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b18">19]</ref>. Automaton-based methods are attractive due to their efficiency and clean design. However, they cannot evaluate XPath queries which contain predicates ('[...]') since an FSA is memory-less, as observed in <ref type="bibr" target="#b24">[25]</ref>. Since predicates are common in XPath queries, we must be able to handle not only wildcards, child and descendant axes, but also predicates.</p><p>When evaluating predicates on XML streams, we may encounter data that potentially can be a query solution -a candidate node -before we encounter the data required to evaluate the predicates to decide its membership; therefore, we must remember candidates as well as their query pattern matches until the relevant data is encountered. For example, consider the XPath query //a[d]/b[e]//c and the sample XML document shown in figure <ref type="figure">1</ref>(a) <ref type="foot" target="#foot_0">1</ref> . When we process the XML element c 1 in the document order (or equivalently, a pre-order traversal of the XML tree), we cannot determine whether or not it is in the query result at the point that it is encountered. We therefore need to record information about the pattern match to subquery //a/b//c: (a n , b 1 , c 1 ) until we can determine the predicate satisfaction of a n and b 1 , thus deciding whether or not c 1 is a solution.</p><p>Based on this intuition, several algorithms <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b19">20]</ref> have been proposed to process XML queries containing predicates. These algorithms are efficient and scale well for nonrecursive XML streams, i.e. data in which tags do not repeat along a root-to-leaf path. However, when predicates are combined with descendant axis traversal and the XML data is recursive, evaluating XPath queries in a streaming fashion raises new challenges:</p><p>• Due to the combination of descendant axis traversal in a query and the recursive structure of XML data, the number of pattern matches of a single XML node to a subquery can be potentially exponential to the query size. Consider the query Q 1 : //a[d]//b[e]//c and the XML data in figure 1(a). Note that Q 1 is different from the earlier query due to the descendant (rather than child) axis traversal between tags a and b. For the XML node c 1 there are n 2 ways for c 1 to match subquery //a//b//c: (a i , b j , c 1 ), where 1 ≤ i ≤ n, 1 ≤ j ≤ n. Representing n 2 in terms of the size of the data and query, this becomes O((|D|/|Q|) |Q| ), where |D| is the XML data size, |Q| is the XPath query size.</p><p>• At least one pattern match must satisfy the query predi- cates to make a candidate become part of the result. However, until a pattern match which satisfies the query predicates is found, we must record all the pattern matches for a candidate and test their predicate satisfaction. In the worst case, we will not know whether or not the candidate is indeed a solution until all pattern matches are considered. For example, when node c 1 is met, since we are not able to determine the predicate satisfaction of its n<ref type="foot" target="#foot_1">2</ref> subquery pattern matches we must record all of them. Processing the data in document order, we then verify that the matches</p><formula xml:id="formula_0">(a i , b j , c 1 ), 2 ≤ i ≤ n, 2 ≤ j ≤ n fail the predicates in Q 1 .</formula><p>At the very end, we find that the match (a 1 , b 1 , c 1 ) satisfies the predicates and therefore c 1 is a query solution.</p><p>These challenges do not exist in a non-streaming environment since XML nodes can be randomly accessed during query processing. For example, in the best known polynomial time main memory algorithms for evaluating XPath queries <ref type="bibr" target="#b15">[16]</ref>, the whole document is loaded into main memory before query processing. Since XML nodes can be randomly accessed, predicates can be checked first so that we do not need to remember the pattern matches. These techniques are not suitable for processing XML streams, where only a single sequential scan is allowed. Furthermore, as will be shown in section 5, the algorithms have trouble processing large XML files.</p><p>Previous XPath streaming algorithms that handle predicates either do not support descendant axis traversal <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b20">21]</ref>, or explicitly store all pattern matches <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref>. As analyzed in <ref type="bibr" target="#b25">[26]</ref>, the worst case complexity of the algorithms in <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref> </p><formula xml:id="formula_1">is O(|D| × 2 |Q| × k),</formula><p>where k is the number of different query pattern matches in which an XML node participates.</p><p>As discussed, recording pattern matches by enumerating and storing them explicitly can be expensive. Motivated by <ref type="bibr" target="#b6">[7]</ref>, we therefore design a stack-based data structure to concisely encode pattern matches. We then propose a novel XPath streaming algorithm, TwigM, which searches for satisfying matches in the compact data structure by pruning the search space without enumerating all the pattern matches. In this way, TwigM achieves a complexity which is polynomial in the size of the data and query. As tested in extensive experiments, TwigM is a practically efficient and worst case polynomial algorithm.</p><p>The TwigM algorithm was implemented in an XPath query processor for XML streams and demonstrated in <ref type="bibr" target="#b10">[11]</ref>.</p><p>The contributions of this paper are:</p><p>1. We design a data structure to encode the matches in a compact form. For example, to process Q 1 on the sample data in figure <ref type="figure">1</ref>(a), TwigM stores 2n nodes to encode n 2 pattern matches.</p><p>2. We propose a streaming XPath evaluation algorithm called TwigM. Recall that to determine whether a candidate is indeed a solution entails finding at least one pattern match that satisfies all the query predicates.</p><p>Rather than computing all the pattern matches in the search space explicitly from the compact data structure, and then testing predicate satisfaction, TwigM prunes the search space as we process the XML stream by checking predicate satisfaction on a small number of elements in the data structure. For example, we only need to check predicate satisfaction on 2n elements instead of checking n 2 pattern matches to evaluate Q 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>We analyze the time complexity of TwigM, which is polynomial in terms of the size of the data and query.</p><p>4. We present a detailed performance evaluation of an implementation of TwigM compared with several other related systems. The results show that our approach not only has a good theoretical complexity but a good performance on various practical queries and data sets.</p><p>The remainder of the paper is organized as follows. Section 2 presents the data model and query language. Section 3 gives an overview our XPath streaming evaluation strategy. TwigM is introduced and analyzed in section 4. Section 5 presents performance results. Section 6 discusses related work, and section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Data Model and Query Language</head><p>In this paper, XML data is modeled as a stream of modified SAX events: startElement(tag, level, id) and endElement(tag, level), where tag is the tag of the node being processed, level is level of the node in the corresponding XML tree, and id is unique identifier of the node. 2  These events are the input to our algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1:</head><p>The current node is the XML node whose tag is currently being parsed by the SAX parser. An active node is an XML node whose start tag has been processed but end tag has not yet been processed by the SAX parser. Proposition 2.1: At any point in time, the number of active nodes is bounded by the depth of the XML tree.</p><p>We focus the discussion on a commonly used subset of XPath 1.0: XP {/,//, * ,[]} , following <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b30">32]</ref>. XP {/,//, * ,[]} consists of child axis traversal (/), descendant axis traversal (//), wildcards (*), branches (or predicates, denoted as [...]), and name tests.</p><p>Following previous work <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref>, we represent an XPath query in XP {/,//, * ,[]} as a query tree. For example, the query Q 1 ://a[d]//b[e]//c searches for all c nodes that are descendants of b nodes, which in turn have a child e and an ancestor a with at least one child d. The tree corresponding to Q 1 is shown in figure <ref type="figure">1(b)</ref>. The c node in Q 1 is called the return node and is indicated by darkening the node. An unannotated line between two nodes represents a child axis, and a line annotated with // represents a descendant axis. If a node has more than one child or is the return node, then it is called a branching node. For example, nodes a, b and c are branching nodes in Q 1 . We use "XPath query" and "query tree" interchangeably.</p><p>As discussed in section 1, there are two challenges in efficiently processing XP {/,//, * ,[]} on XML streams: first, descendant axes in the query combined with the recursive structure of XML data; and second, predicates in the query combined with the single-scan requirement of stream processing. Therefore we will start by considering two simple subsets of XP {/,//, * ,[]} : XP {/,//, * } , which denotes XPath queries without branching; and XP {/,[]} , which denotes XPath queries without descendent axis traversal and wildcards. The techniques used in processing queries in these sub-languages will then be combined in a query processor for XP {/,//, * ,[]} .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Overview of Query Processing</head><p>In this section, we give the intuition of how XP {/,//, * ,[]} queries are evaluated over XML data streams; details of the algorithms will be given in the next section.</p><p>For an XPath query Q, we build a machine M which takes as input a sequence of SAX events of an XML stream D and computes a set of node ids as solutions of Q 3 . The structure of M resembles that of Q, with data structures attached to machine nodes to record information about matches(see figure <ref type="figure">2(b</ref>) and (c)). We start by describing machines for the simple cases, PathM for queries in XP {/,//, * } and BranchM for queries in XP {/,[]} , before extending them to one for XP {/,//, * ,[]} , TwigM. 3 Our implementation returns XML fragments instead of node ids. As discussed earlier, the combination of descendant axis traversal in queries and the recursive structure of XML data can result in an exponential number of pattern matches to the query size for a single query solution. To evaluate queries using polynomial time, we encode matches compactly and avoid enumerating all the matches for a solution.</p><p>To achieve the first requirement, we attach a stack to each machine node v to record active XML nodes which are solutions to the subquery from the machine root to v. The XML nodes on a stack are retained only as long as they are active, and therefore by Proposition 2.1 the memory requirement for a stack is bounded by the document depth. Since a tag may occur multiple times in a query, the total memory requirement is bounded by the size of the query times the document depth.</p><p>To achieve the second requirement, we push an XML node onto the stack of machine node v if its relationship with the nodes in the stack of v's parent node u satisfies the axis between u and v. Since u's stack stores all active solutions for the subquery from the root to u, the XML node pushed onto v's stack is a solution for the subquery from the root to v. The time to check the push condition for each XML node is therefore bounded by the number of active nodes (i.e the document depth, Proposition 2.1) times the query size. A machine node is created for each query node and given the label of its corresponding query node's tag. For example, machine node v 1 is labeled a, v 2 is labeled b, and v 3 is labeled c. The machine node built for the root (return) node in the query is also called the root (return) node in the machine. Thus v 1 is the root of M 2 and v 3 is the return node.</p><p>A stack is built for each machine node to record information about active XML nodes that are solutions to its subquery. For example, the stack for v 1 records active XML nodes reachable by //a, and the stack for v 2 records active XML nodes reachable by //a//b. Since active XML nodes can be distinguished by their levels, the stacks record only the level of matching active nodes.</p><p>The edge between machine nodes is annotated with a node push condition according to the axis between the corresponding query nodes. For example, the parent edge of v 2 is labeled by "(≥, 1)", since the corresponding query node b has a parent edge of '//'. The edge label indicates that an XML node will be pushed to v 2 's stack if and only if there exists a node in v 1 's stack such that their level difference is ≥ 1.</p><p>PathM accepts the SAX events of an XML stream and computes the solutions for the query. Each SAX event (tag, level, id) will be sent to machine nodes whose label is the same as tag or '*'. In M 2 's execution on the XML tree D 2 of figure 2(a), the SAX event startElement(a, 1, a 1 ) will be sent to v 1 since its label is a.</p><p>A machine node v qualifies for a startElement SAX event (tag, level, id), if (1) v is the root and level satisfies its parent edge label; or (2) v is not the root and there exists an l ′ on the stack of v's parent such that levell ′ satisfies v's parent edge label. This XML node is pushed onto the qualified node v's stack as a solution to the subquery from the root to v. Continuing with our example, a 1 is pushed on v 1 's stack since v 1 is the root, v 1 's parent edge is labeled (≥,1), and a 1 's level = 1 ≥ 1. Similarly, we push data nodes a 2 , . . ., a n on v 1 's stack, data nodes b 1 , . . ., b n on v 2 's stack, and data nodes c 1 on v 3 's stack. The snapshot of M 2 's state at this point of execution is shown in figure <ref type="figure">2(c</ref>). Since v 3 is the return node, node id c 1 is output.</p><p>A machine node v qualifies for an endElement event(tag,level) if level is equal to the top node in v's stack (meaning that this is the matching end tag); v then pops its stack to guarantee that only active nodes remain. For example, endElement(c, 2n + 1) is sent to machine node v 3 since its label is c. Furthermore, the top element in v 3 's stack is level 2n + 1 and is equal to the level of the endElement event; we therefore pop v 3 's stack.</p><p>As an optimization, we do not need to create machine nodes for '*' interior query nodes. Instead, we record the level difference of non-'*' query nodes through the edge labels of their corresponding machine nodes. Observe that in this example, although there are n 2 pattern matches which qualify c 1 as a query solution ((a i , b j , c 1 ) where 1 ≤ i ≤ n, 1 ≤ j ≤ n), we only store 2n nodes. Furthermore, to verify each sub-query solution it is sufficient to check nodes on the parent stack of a qualified machine node. For example, to determine that c 1 is a query solution we only need to check nodes in v 2 's stack, rather than enumerating and testing all n 2 query pattern matches that c 1 participates in.</p><p>Although the stacks used in PathM are similar to those proposed in <ref type="bibr" target="#b6">[7]</ref>, the algorithms to compute query results are quite different. First, PathM pushes nodes onto a stack L: level B: branch match C: candidates</p><formula xml:id="formula_2">1 F F L B C c1 2 T T L B C C L -1 φ C L -1 φ C L -1 φ (c) BranchM M 3 for Q 3 Figure 3. Example for BranchM</formula><p>if and only if they are solutions to the corresponding subquery, rather than pushing all nodes whose tag matches the label of the stack. Second, to determine if an XML node is a query solution, we only need to check its relationship with nodes in the parent stack of the query return node (polynomial time), rather than enumerating and verifying all the pattern matches the XML node participates in.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">BranchM: XP {/,[]} Query Processing</head><p>Another challenge for evaluating XPath queries in a streaming environment lies in checking predicate satisfaction. We focus on this problem in BranchM, which processes queries in XP {/,[]} . The issue is that when a data node matches a machine node, we may not be able to determine if it is a solution to the query since the nodes matching the predicate conditions may not have been seen yet.</p><p>We therefore associate with each machine node a set of possible solutions called candidates. To verify a candidate, we need to record pattern matches to subqueries and test predicate satisfaction on them. Since a predicate is an existential quantifier which can be satisfied with a single match to each condition, we attach a boolean array called branch match to each machine node and record whether or not each of the child conjunctions has found a match in the XML data rather than recording all the matches. Example 3.2: Figure <ref type="figure">3(c)</ref> shows the machine M 3 for query Q 3 in figure <ref type="figure">3(b)</ref>. The BranchM machine is different from a PathM machine in three key ways: First, an edge label in BranchM is always (=,1) since there are only child axes and no '*'-nodes; we therefore omit edge labels from the figure. Second, at any moment there is at most one active XML node matching a query node; machine nodes therefore record a single match rather than a stack of matches. Third, for each BranchM machine node, we associate the level L of the match (initialized to 0), a set of candidates C (initialized to ∅), and the branch match boolean array B (initialized to f alse (F )). Now, consider the action of M 3 on the data in figure <ref type="figure">3(a)</ref>. In this example, we are not able to determine if c 1 is a query solution until we test predicate satisfaction of the pattern match (a 1 , b 1 , c 1 ) for subquery /a/b/c.</p><p>As in PathM, when BranchM receives a SAX event (tag, level, id) it will send it to the machine nodes whose label is the same as tag. For example, startElement(a, 1, a 1 ) will be sent to the machine node v 1 since its label is a.</p><p>A machine node determines if it qualifies for a startElement(tag, level, id) event by comparing level with the element in its parent node according to the parent edge condition, as in PathM. The level of a matched active data node is then recorded in L. If the machine node is the return node, we add id to its candidate set C. Continuing the example above, machine node v 1 qualifies for this event since the label of v 1 is a and v 1 is root. The level information 1 is therefore recorded in v 1 's L. Similarly, we record the level of b 1 (2) in v 2 's L and the level of c 1 (3) in v 3 's L, and put the id of c 1 into v 3 's candidate set C.</p><p>When a machine node receives an endElement(tag, level) event, it checks if the event corresponds to the recorded data node. For any qualified machine node v, it then checks if all the components in its branch match B are true (T ). If so, this branch has found a match to all its predicates. If v is the root, we output its candidate set C; otherwise, we set its parent's branch match component for v to true, and add v's candidate set to its parent's candidate set. We then reset the qualified machine node's state to (L = -1, C = ∅, B = &lt; F, . . . , F &gt;).</p><p>Continuing the example above, when endElement(c, 3) is sent to M 3 , it again matches v 3 . Since v 3 's branch match is trivially true (there are no qualifications on the match, and therefore B is missing for v 3 in the figure), we set its parent v 2 's branch match for v 3 to T , add v 3 's candidate set {c 1 } to v 2 's candidate set, and reset v 3 's state. We proceed in a similar fashion for the other startElement and endElement events. The snapshot after the endElement event for e 1 is shown in figure <ref type="figure">3(c</ref>). Finally, on the endElement event for a 1 , machine node v 1 qualifies; since its branch match B is all T , its candidate set {c 1 } is output as the query solution. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Putting Them Together in TwigM</head><p>Having discussed the technical approaches for dealing with descendant axis traversal and predicate testing, we now put the two together in TwigM for evaluating queries in the language XP {/,//, * ,[]} over recursive XML streams.</p><p>There are three important features of TwigM. First, as in BranchM, TwigM tests predicate satisfaction on a given pattern match using a branch match boolean array in a recursive fashion to verify a candidate query solution. Second, because of the presence of '//' and '*', TwigM builds a stack to record active XML node matches for each query node as in PathM. However, each stack element now contains the level, candidate set, and branch match array for the matched data node. The stacks compactly encode all the pattern matches to subqueries that a candidate query solution participates in. Third, since TwigM needs to test predicates on multiple pattern matches to verify each candidate, it groups pattern matches and eliminates the ones with failed predicates effectively without enumeration. Therefore TwigM only probes a polynomial number of matches in a potentially exponential search space and achieves a polynomial time complexity. Example 3.3: Figure <ref type="figure" target="#fig_4">4</ref> shows the machine M 1 for query Q 1 in figure <ref type="figure">1(b)</ref>. There are five nodes in M 1 , v 1 , v 2 , v 3 , v 4 and v 5 labeled a, b, c, d and e, respectively. Each node has the level difference requirement on its parent edge as in PathM.</p><p>Each node also has a stack, which is initially empty. An element of a stack has the same data structure as the state of a node in BranchM; it is a triple, representing the matching XML node's level, candidate set and branch match. Now, consider the action of M 1 on the data D 1 in figure <ref type="figure">1(a)</ref>. The startElement processing is similar to PathM except a triple with level information, candidates and branch match is pushed onto the stack instead of only level information. For example, when processing the data node a 1 with level 1 and id a 1 , since machine node v 1 qualifies for this event, the triple (L = 1, C = ∅, B = &lt; F, F &gt;) is pushed on v 1 's stack. Similarly, we push corresponding information for nodes a 2 , . . ., a n on v 1 's stack, nodes b 1 , . . ., b n on v 2 's stack, and c 1 along with its node id as a candidate on v 3 's stack.</p><p>When the endElement event of c 1 is received by M 1 , the event is sent to v 3 . The top element n in v 3 's stack has the same level as c 1 . Since n's branch match B is trivially all T , for each element in the stack of v 3 's parent (v 2 ) whose level satisfies the parent edge condition, we set its branch match for v 3 to T , denoting that it has found a match to query child c, and upload the candidate set: {c 1 } 4 . In this example, every element in v 2 's stack satisfies the parent edge condition. Then we pop v 3 's stack. The snapshot at this moment is shown in figure <ref type="figure" target="#fig_4">4</ref>, where the second component of branch matches for v 2 has been set to T to denote that the match for v 3 has been found.</p><p>When the endElement event for b n is received, it matches the top element n in v 2 's stack. However, since one component of the branch match of n is F (predicate e has not found a match), we directly pop v 3 's stack. Similarly, we process the endElement events for nodes b n-1 , . . ., b 2 and startElement events for node e 1 . On the endElement event of e 1 , a match is now found for the top element n of v 5 's stack. Since n satisfies the parent edge condition with the top element in v 2 's stack, b 1 , we set b 1 's branch match for v 5 to T and pop n. On the endElement event for b 1 , since its branch match is all T , we set the branch matches of the elements in v 1 's stack (which all satisfy the parent edge label condition) for v 2 to T , upload their candidate sets, and pop the stack. Finally, on the endElement event for a 1 , since v 1 's branch match is all T and it is the root, its candidate set {c 1 } is output as the query result.</p><p>As we can see, TwigM uses stacks to compactly encode query pattern matches. In the above example, n 2 pattern matches (3n 2 elements) to subquery //a//b//c in which the XML node c 1 participates are recorded using 2n + 1 elements in stacks. To verify a candidate query solution, TwigM removes a set of unsatisfied pattern matches by popping one element in the stack. For example, since node b n does not satisfy the predicate we pop it, eliminating all n matches in which b n was participating ((a i , b n , c 1 ), 1 ≤ i ≤ n). When multiple satisfying pattern matches exist for a query solution, TwigM eliminates duplicate candidates by taking the union. Therefore TwigM only needs to process a polynomial number of elements in the stacks to verify a candidate query solution instead of computing all the pattern matches. In the above example, TwigM processes 2n elements in the stacks rather than n 2 pattern matches. 4 The stacks we use allow examining all elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Abstract Machine TwigM</head><p>We now formally present TwigM discussed in the previous section. First we define an XP {/,//, * ,[]} query Q. Definition 4.1: An XP {/,//, * ,[]} query is a tree Q(V , Σ, η, ρ, root, ζ, sol), where • V is a finite set of nodes • Σ is a finite alphabet of node tags • η:V → {'*'} ∪Σ is the name function; η(n) returns the name of n, which can be either a tag or '*'</p><formula xml:id="formula_3">• ρ:V → {ǫ} ∪ V is the parent function; ρ(n) returns the parent node of n • ζ:V → {/, //} is the parent edge function; ζ(v) returns the label of the incoming edge of v • root ∈ V is the root of Q • sol ∈ V is the return node.</formula><p>TwigM machine is a tuple (V , η, ρ, ζ, I, S, δ s ,δ e , root, sol) built from a query Q (V ′ , Σ, η ′ , ρ ′ , root ′ , ζ ′ , sol ′ ) where • V is a set of machine nodes corresponding to nodes in Q. root and sol are machine nodes corresponding to root ′ and sol ′ of Q, respectively. Several functions are defined on machine nodes.</p><p>A name function η returns the label of a machine node. Each machine node except the root has a parent which can be retrieved by a parent function ρ.</p><p>Parent edge function ζ:V → {=, ≥} × N on a node v returns v's parent edge label, which records the level difference and axis information between v and its parent ρ(v) as the condition on which an XML node should be pushed into the state of v. The first component is a function, either "≥" or "=", depending on the axis between query node v and ρ(v), and the second component is a positive integer representing level difference of between v and ρ(v). We say that an integer l satisfies the parent edge condition of v if the function ζ(v) <ref type="bibr" target="#b0">[1]</ref>(l, ζ(v) <ref type="bibr" target="#b1">[2]</ref>) returns T (true).</p><p>A child identity function β : V → N identifies a child within its parent by its order, so that the match information of the child can be recorded in its parent's branch match.</p><p>• I is the input SAX event startElement (tag, level, id) or endElement (tag, level) which are described by the domain of node tags Σ<ref type="foot" target="#foot_2">5</ref> , node level Γ, and XML node ids Υ.</p><p>• S denotes the state associated with machine nodes, and is described by a stack function ξ: V → (Γ × {T, F } * × Υ * ) * . In the following we use S to denote the states (Γ × {T, F } * × Υ * ) * . ξ(v) returns a stack of active XML nodes that are solutions to the subquery from the query root to Algorithm 1 Functions δ s , δ e for TwigM Start Element Function δs</p><formula xml:id="formula_4">1: for all v such that ((η(v) = a)∨(η(v) ='*'))∧((v = root)∧ ζ(v)[1](l, ζ(v)[2]) ∨ (v! = root) ∧ ∃e ∈ ξ(ρ(v))(ζ(v)[1](l - e[1], ζ(v)[2])) do 2:</formula><p>push(ξ(v), &lt; l, &lt; F, . . . F &gt;, ∅ &gt;);</p><p>3:</p><formula xml:id="formula_5">if (v = sol) then 4: top(ξ(v))[3] = top(ξ(v))[3] ∪ {id}; 5:</formula><p>end if 6: end for End Element Function δe</p><formula xml:id="formula_6">1: for all v such that ((η(v) = a) ∨ (η(v) ='*')) ∧ (top(ξ(v))[1] = l) do 2: if (∀i((top(ξ(v))[2][i] = T )) then 3: if (v = root) then 4:</formula><p>ouput(top(ξ(v)) <ref type="bibr" target="#b2">[3]</ref>); for all e such that e ∈ ξ(ρ pop(ξ(v)) 13: end for the corresponding query node. For a node in a stack, we record its level, branch match and candidate set information. Branch match records for each child of v whether or not a match on data has been found. The candidate set records the set of possible solutions to be verified with respect to v.</p><formula xml:id="formula_7">(v)) ∧ ζ(v)[1](l - e[1], ζ(v)[<label>2</label></formula><p>• δ s and δ e are transition functions corresponding to startElement and endElement events, respectively. The functions compute the next state of a machine node according to its current state and the input SAX event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Machine Construction</head><p>Next, let us describe how to construct a TwigM for a given query Q:</p><p>• Nodes V , sol, name function η : For each query node v ′ in V ′ whose name is an XML tag (η ′ (v ′ ) ∈ Σ), we build a machine node v and set η(v) = η ′ (v ′ ); for each branching or leaf query node whose label is '*', we build a machine node v and set η(v) ='*'. All v thus constructed comprise V . Let f and f ′ represent the mapping functions between query nodes and machine nodes,</p><formula xml:id="formula_8">f ′ (v ′ ) = v and f (v) = v ′ . Set sol = f ′ (sol ′ ).</formula><p>Note that we could create a machine node for each query node. However, we do not need to build machine nodes for interior '*' nodes since we capture them in the level difference between nodes, as described next.</p><p>• Parent function ρ, parent edge function ζ, child identity function β, root: To construct ζ and ρ, for two query nodes v ′ 1 and v ′ 2 , such that v ′ 1 is an ancestor of v ′ 2 with no intervening non *-nodes (that is, the path between v ′ 1 and v ′ 2 is comprised of all *nodes), let c be the number of *-nodes between v ′ 1 and v ′ 2 . Set f ′ (v ′ 1 ) to be the parent of f ′ (v ′ 2 ), and set the second component of the edge label between them in TwigM to be c + 1. If one of the edges between v ′ 1 and v ′ 2 in Q is labeled '//', then set the first component of the edge to ≥; otherwise set it to =.</p><p>We set the root as the machine node without parent. For each child c of a machine node v, we set β(c) to be the order of c within v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Stack function ξ</head><p>For each node v ∈ V , we build a stack and initialize it to be empty.</p><p>• Start element function δ s δ s : I × S × {=, ≥} × N → (V → S) computes the next state of node v according to input startElement SAX events, current state of v's parent and v's parent edge label.</p><p>A startElement(a, l, id) event invokes the δ s function on each qualified machine node v.</p><formula xml:id="formula_9">A node v is qualified if: (1) η(v) = a or η(v) = '*';</formula><p>(2) v is the root and l satisfies the parent edge condition; or (3) v is not the root and there exists an element e in the stack of v's parent whose level is l' and ll' satisfies v's parent edge condition. If v is qualified, then we push &lt; l, &lt; F, . . . F &gt;, ∅ &gt; onto v's stack. Furthermore, if v is sol then we add id to v's candidate set. δ s is formally defined in algorithm 1.</p><p>• End element function δ e δ e : I × S × {=, ≥} × N → (V → S) computes the next state of node v and that of its parent according to the input endElement SAX events, v's current state, and v's parent edge label.</p><p>An endElement event (a, l) invokes the δ e function on every qualified machine node v. A node v is qualified if η(v) = a or η(v) = '*', and the level of the top element of v's stack is l.</p><p>Let n be the top element of v's stack. If v is root and n's branch match is all T , we can determine that there is a pattern match for the query, therefore n's candidates are output as query solutions. If v is not root and n's branch match is all T , then for every element n ′ in v's parent stack, such that the level difference of n and n ′ satisfies v's parent edge label condition, we know that n is a match to a query child of n ′ 's, and therefore set the component of v in n ′ 's branch match to T . Furthermore, we load the candidates of n to n ′ to be verified with respect to v ′ 's subtree query. Finally, we pop v's stack. Note that if node n's branch match contains F , we not only discard n, but all the pattern matches n participates in; therefore we can remove failed pattern matches without having to enumerate them. δ e is formally defined in Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Correctness and Complexity Analysis</head><p>Theorem 4.1: TwigM correctly evaluates queries.</p><p>To prove the theorem, we first give several definitions. Definition 4.2: Given a node v in a query tree Q, we name the subquery from root to v without branches the prefix subquery of v. If we cut off all the branches of the nodes between root and v, excluding v, the remainder of Q is called the suffix subquery of v.</p><p>For example, //a//b is the prefix subquery of node b with respect to Q in figure <ref type="figure">1</ref> Since each query node whose label is not '*' has a corresponding machine node, we blur machine nodes and query nodes in the following. Proposition 4.2: On the startElement event for a node a, a is pushed onto a machine node v's stack if and only if a is an active node and a solution to the prefix subquery of v. Proof Sketch: Proof by induction on the levels of the machine nodes in TwigM starting from the root. According to the construction of the parent edge function ζ, it holds immediately for the root. Assume the proposition holds for a machine node with level l. An XML node a is pushed onto the stack of node v with level l + 1, if and only if there is a node in v's parent's stack, and their level difference satisfies v's parent edge condition. Therefore the proposition holds. Proposition 4.3: On an endElement event for a data node a, which matches the top node n in the stack of a machine node v, we set the branch match of v to the nodes in v's parent's stack if and only if each candidate of n is a solution to the suffix subquery of v. Proof Sketch: Proof by induction on the levels of machine nodes in TwigM starting from leaves. The base case holds according to proposition 4.2. Theorem 4.1 is a special case of proposition 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.4:</head><p>The time complexity of TwigM is O((|Q| + RB)|Q| |D|), where R is the depth of the XML tree. Proof Sketch: The polynomial time complexity results from three key features of TwigM. First we use stacks to store an exponential number of pattern matches compactly. Second, before we push a node onto a stack, we check its relationship with the nodes in its parent stack, and therefore guarantee that the nodes in a stack are solutions to the prefix subquery. Third, for predicates, we only use a boolean to record its satisfaction.</p><p>All the detailed proofs can be found in <ref type="bibr" target="#b9">[10]</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Evaluation</head><p>We have implemented TwigM in C++ and demonstrated it in <ref type="bibr" target="#b10">[11]</ref>. The SAX parser used is Expat <ref type="bibr" target="#b11">[12]</ref>. In this section, we present a detailed performance study of this implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experiment Setup</head><p>Environment. All experiments were conducted on a Pentium III 1.5GHz machine with 512MB memory, running the Redhat 9 distribution of GNU/ Linux(kernel 2.4.20-8). All experiments were repeated 10 times and the average processing time was calculated disregarding the maximum and minimum values. Datasets. We conducted experiments on three datasets. The first is a synthetic dataset generated by IBM's XML Generator <ref type="bibr" target="#b17">[18]</ref>, which takes a DTD and a set of parameters as input. We use the Book DTD from the XQuery use cases [30] as the input DTD. We apply the default settings of XML Generator for all the parameters except for NumberLevels and MaxRepeats. NumberLevels bounds the maximum depth of the XML document generated and is set to 20. MaxRepeats   determines the maximum number of times an element can repeat in its parent and is set to 9. The second is a benchmark data set generated by XMark <ref type="bibr" target="#b29">[31]</ref> conforming to the default auction DTD. The third one is a real dataset from the International Protein Sequence Database <ref type="bibr" target="#b14">[15]</ref>. Features of the datasets are shown in figure <ref type="figure">5</ref>.</p><p>Queries. We tested 10 queries on the book and protein datasets, as listed in figure <ref type="figure" target="#fig_8">6</ref>. Q 1 to Q 4 belong to XP {/,//, * } , Q 5 to Q 8 belong to XP {/,//,[]} , but restrict the path expressions in predicates to be either an attribute or a single child axis. Q 8 has a value test as predicate and produces results of small sizes. Q 9 and Q 10 belong to XP {/,//, * ,[]} , and allow multiple predicates to apply to a single node, path expressions in XP {/,//, * ,[]} to be present in predicates, predicates to be nested, and '*'s to appear anywhere. For the benchmark dataset, we tested the benchmark queries provided by XMark <ref type="bibr" target="#b29">[31]</ref> which only contain "/", "//", "*" and predicates. We use the original query names for the benchmark queries.</p><p>Systems. We compare TwigM with several XML query processing systems. XMLTK (version 1.01) <ref type="bibr" target="#b2">[3]</ref> is a streaming XPath XP {/,//, * } processor using a DFA (Deterministic Finite Automaton) constructed lazily. XSQ (version 1.0) <ref type="bibr" target="#b24">[25]</ref> is a streaming XPath XP {/,//,[]} processor using transducers, in which a predicate is restricted to be a single child axis or an attribute, with an optional value test. The release versions of other XML query streaming processors such as SPEX <ref type="bibr" target="#b23">[24]</ref>, XSM <ref type="bibr" target="#b22">[23]</ref>,XAOS <ref type="bibr" target="#b5">[6]</ref>, TurboXPath <ref type="bibr" target="#b19">[20]</ref> and BEA/XQRL <ref type="bibr" target="#b13">[14]</ref> are not yet publically available. We also compare with two non-streaming XML query processors: Galax (release 0.3.5) <ref type="bibr" target="#b27">[28]</ref> is a comprehensive implementation of XQuery 1.0. XMLTaskForce (release 2003-01-30) <ref type="bibr" target="#b15">[16]</ref> is a main-memory, nearly complete implementation of the XPath 1 recommendation, and the only such system with polynomial time complexity in the literature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Query Processing Time</head><p>First we compare the processing time of TwigM with XMLTK, XSQ, Galax and XMLTaskForce <ref type="foot" target="#foot_3">6</ref> . The performance of TwigM and XMLTK is stable, and does not degrade on complex queries. The performance of the other systems degrades due to enumerating multiple pattern matches to a subquery for a query result. For example, TwigM Galax</p><formula xml:id="formula_10">(a) Q 1 (b) Q 5 (c) Q 9</formula><p>The system reports errors for missing points. Systems that are not shown in the legend do not support this query. As we can see, only TwigM is able to evaluate all the test queries on the three datasets. Its performance is good and stable: it performs well on recursive and non-recursive data, simple as well as complex queries. When multiple pattern matches are present (e.g. the book dataset), the performance advantage of TwigM is substantial. Although XMLTK outperforms TwigM on Q 1 to Q 4 , the difference between their performance is small compared to the difference between TwigM's performance and that of XSQ and Galax. For queries containing multiple '*', XMLTK needs to build a DFA with an exponential number of states in the worst case and its performance degrades significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Memory Usage</head><p>Next we compare the memory usage of TwigM with XMLTK, XSQ, Galax and XMLTaskForce. Process memory usage is measured using Redhat's system monitor. The total memory usage of XSQ includes memory consumed by the Java virtual machine. Figures <ref type="figure" target="#fig_11">8(a),</ref><ref type="figure">(b</ref>) and (c) report the memory usage for the Book, Benchmark and Protein datasets, respectively. There are several observations. First, the streaming processors, TwigM, XMLTK and XSQ, use substantially less memory than the non-streaming processors, Galax and XMLTaskForce, which require memory much larger than the data size. Second, as the sizes of the datasets change from 9MB(Book) to 34MB(Benchmark) to 75MB(Protein), the memory consumption of TwigM, XMLTK and XSQ remains roughly the same; XMLTask-Force runs out of memory for Protein. Third, TwigM and XMLTK use as little as 1MB memory for all queries in all datasets. The system reports errors for missing points. Systems that are not shown in the legend do not support this query. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Scalability of Query Processing Time</head><p>We also measure the scalability of the systems as data size increases.</p><p>To test the scalability as the data size increases, we duplicated the Book dataset between 2 and 6 times. Figure <ref type="figure" target="#fig_14">9</ref> reports the processing time on increasing sizes of XML data for queries of different types: Q 1 , Q 5 and Q 9 , respectively. The performance of other queries are similar and are omitted. The results show that as the file size increases the execution time of TwigM increases very slowly for both simple and complex queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Scalability of Memory Usage</head><p>Figure <ref type="figure" target="#fig_16">10</ref> shows the memory usage of different systems as the book data size increases. As we can see, when the data size increases from 9M B to 54M B, the memory usage of the streaming processors (TwigM, XMLTK and XSQ) is constant, while the memory consumption of Galax and XMLTaskForce increases much faster than the data size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Overall Results</head><p>From the experiments, we can see that TwigM has several benefits:</p><p>• TwigM algorithm is practically efficient with guaranteed polynomial time complexity.</p><p>• TwigM has polynomial time complexity in the size of the data and query, which is verified in the experiment.</p><p>• When multiple pattern matches are present, the performance of TwigM is substantially better than other systems, as shown in the book dataset.</p><p>• For all the datasets in the experiments, TwigM is the most efficient query engine that handles XPath with child, descendant axes and predicates.</p><p>• TwigM is suitable for processing data streams with small memory usage. The memory consumption of TwigM remains almost constant (1MB) as the data and query sizes change in the experiments. We have also tested benchmark queries over data that is over 1GB in size, and found that the memory usage remains at 1MB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Several XPath streaming engines have been proposed. XSQ <ref type="bibr" target="#b24">[25]</ref>, SPEX <ref type="bibr" target="#b23">[24]</ref>, and XSM <ref type="bibr" target="#b22">[23]</ref> use a hierarchical arrangement of transducers augmented with a buffer. XSQ processes XPath queries with child and descendant axes, and predicates with the restriction that predicates do not contain axes. SPEX processes regular expressions, which are similar to the XPath queries of XSQ. XSM and FluX <ref type="bibr" target="#b20">[21]</ref> do not support descendant axis traversal. <ref type="bibr" target="#b4">[5]</ref> analyzes the buffer requirement for evaluating XPath queries without wildcards on XML streams. In contrast, TwigM is a polynomial algorithm for XPath queries containing child axis, descendant axis, wildcards and (unrestricted) predicates.</p><p>XAOS <ref type="bibr" target="#b5">[6]</ref> is an XPath processor that supports reverse axes (parent and ancestor) using a matching structure to store XML nodes. XAOS produces query results by traversing the matching structure at the end of the stream. In contrast, TwigM can produce results incrementally.</p><p>[20] discusses how to handle child, descendant axes, predicates and wildcards in XQuery using TurboXPath. When a recursive data node matching a query node is met, an independent thread of control is generated. Therefore the pattern matches to the query are independently recorded and manipulated explicitly.</p><p>BEA/XQRL <ref type="bibr" target="#b13">[14]</ref> is a full implementation of XQuery. The design goal of BEA/XQRL is different from our work: BEA/XQRL targets processing general XQuery queries on small XML messages (a few 100KB in size), while our goal is to process a commonly used subset of XPath queries efficiently on large XML streams (megabytes and gigabytes). We believe that these two systems demonstrate the tradeoffs between query language expressiveness and system simplicity and efficiency.</p><p>[29] discusses how to exploit schema information to optimize XQuery evaluation on XML streams. <ref type="bibr" target="#b21">[22]</ref> proposes XQuery rewriting techniques according to the dependency relationship between clauses in an XQuery for streaming process.</p><p>A number of XPath query filtering systems have been proposed. Filtering systems focus on determining whether or not an incoming data stream matches a large number of queries. YFilter <ref type="bibr" target="#b12">[13]</ref> uses a single automaton to evaluate common expressions of queries to improve the performance. XTrie <ref type="bibr" target="#b8">[9]</ref> uses a trie structure instead of a flat table to index XPath queries based on common substrings. XPush <ref type="bibr" target="#b16">[17]</ref> lazily constructs a single deterministic pushdown automaton to filter XPath queries with predicates. <ref type="bibr" target="#b3">[4]</ref> gives the lower bounds of XPath filter algorithms.</p><p>There are many papers on non-streaming XPath query processing. <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b26">27]</ref> propose polynomial main memory algorithms for answering full XPath queries by randomly accessing an XML document. Galax <ref type="bibr" target="#b27">[28]</ref> is a full-fledged XQuery query engine based on random accesses on a DOM model. <ref type="bibr" target="#b30">[32,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b6">7]</ref> process tree pattern queries over a database system for XML data. Although <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> also use a stackbased data structure, they focus on a different processing environment than ours, and therefore have different algorithms. First, our algorithm takes a streaming XML document as input, while the input of <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> is relations of XML node labels {DocID, StartPos, EndPos, Level} with optional indices. Second, our algorithm produces results incrementally, while <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> use sort and merge-join, which are blocking operations; they therefore cannot produce results incrementally. Furthermore, we focus on XPath query processing which returns the nodes matching the return node in the query; therefore it is possible to achieve a polynomial time complexity. On the other hand, the queries handled by <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> return all the pattern matches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>We have discussed reasons for the potentially exponential time complexity of existing XPath streaming query processors: computing all the pattern matches for each solution of queries containing both predicates and descendant axis traversal on recursive data. Using a compact data structure to encode pattern matches, we gave a polynomial time algorithm to evaluate a large class of XPath queries, XP {/,//, * ,[]} , over streaming XML data. The al-gorithm, TwigM, achieves its efficiency by searching for results lazily without enumerating all the pattern matches. A detailed experimental study shows that our approach not only has a good theoretical complexity bounds but also works well in practice on a wide variety of queries and datasets.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Q 1 Figure 1 .</head><label>11</label><figDesc>Figure 1. Sample XML Data and an XPath Query</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 Figure 2 .</head><label>22</label><figDesc>Figure 2. Example for PathM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 3 . 1 :</head><label>31</label><figDesc>Figure 2(c) shows the machine M 2 for the query Q 2 in figure 2(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. TwigM M 1 for Q 1 in Figure 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(b), //a//b[e]//c is the suffix subquery of b, however, //a//b//c is not a suffix subquery of b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Query Sets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>means that the system doesn't support the query, take long time or report error for query evaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7</head><label>7</label><figDesc>Figure 7. Query Execution Time 84 84 96 106 84 84 84 86 92 87</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Memory Usage</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Figures 7(a),(b) and (c) report the query execution time for the Book, Benchmark and Protein datasets respectively. As we can see, for XP {/,//, * } XMLTK has the best performance; for other queries, TwigM is the fastest.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Query Execution Time as Book Data Size Increases</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Memory Usage for Q 10 as Book Data Size Increases</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Throughout the paper, we use subscripts to distinguish nodes with the same tag.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>We omit the discussion of attributes for now, however our implementation supports attributes as well as elements.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>We assume that the alphabet of node tags in the query is the same as that of the XML data, and add ǫ for empty id in the last component of endElement events.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>The processing time reported here is normalized according to benchmark<ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b1">2]</ref> </p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We are grateful to Val Tannen, Zack Ives and Grigorios Karvounarakis for their valuable feedback on this work. This research is funded by NSF IIS 0415810 Preserving Constraints in XML Data Exchange, and NSF IIS 0513778 Data Cooperatives: Rapid and Incremental Data Sharing with Applications to Bioinformatics.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Structural joins: A primitive for efficient XML query pattern matching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Al-Khalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Ocaml Draws with C in Trivial Benchmark</title>
		<author>
			<persName><forename type="first">J</forename><surname>Assange</surname></persName>
		</author>
		<ptr target="http://caml.inria.fr/archives/200008/msg00018.html/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">XMLTK: An XML Toolkit for Scalable XML Stream Processing</title>
		<author>
			<persName><forename type="first">I</forename><surname>Avila-Campillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Onizuka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Raven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Technologies for XML</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the Memory Requirements of XPath Evaluation over XML Streams</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fontoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Josifovski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Buffering in Query Evaluation over XML Streams</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fontoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Josifovski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Streaming XPath Processing with Forward and Backward Axes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Barton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Charles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raghavachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Josifovski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fontoura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of ICDE</title>
		<meeting>eeding of ICDE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Holistic twig joins: Optimal XML pattern matching</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Benchmarking Java against C and Fortran for scientific applications</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Pottage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Freeman</surname></persName>
		</author>
		<editor>Java Grande</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="97" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient filtering of XML documents with XPath expressions</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">An Efficient XPath Streaming Processor</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<idno>MS-CIS-04-02</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>University of Pennsylvania</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">ViteX: A Streaming XPath Processing System</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The Expat XML Parser</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<ptr target="http://expat.sourceforge.net/" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Path Sharing and Predicate Evaluation for High-Performance XML Filtering</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Diao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Altinel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="467" to="516" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The BEA/XQRL Streaming XQuery Processor</title>
		<author>
			<persName><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hillery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Riccardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Westmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sundararajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Georgetown Protein Information Resource. Protein Sequence Database</title>
		<ptr target="http://www.cs.washington.edu/research/xmldatasets/" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient Algorithms for Processing XPath Queries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pichler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Stream Processing of XPath Queries with Predicates</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Ibm</forename><surname>Generator</surname></persName>
		</author>
		<ptr target="http://www.alphaworks.ibm.com/tech/xmlgenerator" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An XML query engine for network-bound data</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Querying XML Steams</title>
		<author>
			<persName><forename type="first">V</forename><surname>Josifovski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fontoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Schema-based Scheduling of Event Processors and Buffer Minimization for Queries on Structured Data Streams</title>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Scherzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schweikardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Stegmaier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient Evaluation of XQuery over Streaming Data</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A Transducer-Based XML Query Processor</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ludascher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mukhopadhayn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An Evaluation of Regular Path Expressions with Qualifiers against XML Streams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kiesling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">XPath queries on streaming data</title>
		<author>
			<persName><forename type="first">F</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chawathe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">XSQ: A Streaming XPath Engine</title>
		<author>
			<persName><forename type="first">F</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chawathe</surname></persName>
		</author>
		<idno>CS-TR-4493</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>University of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Typing and querying XML documents: some complexity bounds</title>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Simeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><surname>Galax</surname></persName>
		</author>
		<ptr target="http://db.bell-labs.com/galax" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Semantic Query Optimization for XQuery over XML Streams</title>
		<author>
			<persName><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Rundensteiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<ptr target="http://monetdb.cwi.nl/xml/index.html" />
		<title level="m">XMARK the XML-benchmark project</title>
		<imprint>
			<date type="published" when="2001-04">April 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On supporting containment queries in relational database management systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Lohman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Proceedings of SIGMOD</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
