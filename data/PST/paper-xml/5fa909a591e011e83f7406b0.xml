<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sandslash: A Two-Level Framework for Efficient Graph Pattern Mining</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2020-11-05">5 Nov 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xuhao</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
							<email>roshan@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
							<email>gill@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Loc</forename><surname>Hoang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
							<email>pingali@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Sandslash: A Two-Level Framework for Efficient Graph Pattern Mining</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2020-11-05">5 Nov 2020</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/nnnnnnn.nnnnnnn</idno>
					<idno type="arXiv">arXiv:2011.03135v1[cs.DC]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph pattern mining (GPM) is used in diverse application areas including social network analysis, bioinformatics, and chemical engineering. Existing GPM frameworks either provide high-level interfaces for productivity at the cost of expressiveness or provide low-level interfaces that can express a wide variety of GPM algorithms at the cost of increased programming complexity. Moreover, existing systems lack the flexibility to explore combinations of optimizations to achieve performance competitive with hand-optimized applications.</p><p>We present Sandslash, an in-memory Graph Pattern Mining (GPM) framework that uses a novel programming interface to support productive, expressive, and efficient GPM on large graphs. Sandslash provides a high-level API that needs only a specification of the GPM problem, and it implements fast subgraph enumeration, provides efficient data structures, and applies high-level optimizations automatically. To achieve performance competitive with expert-optimized implementations, Sandslash also provides a low-level API that allows users to express algorithm-specific optimizations. This enables Sandslash to support both high-productivity and high-efficiency without losing expressiveness. We evaluate Sandslash on shared-memory machines using five GPM applications and a wide range of large real-world graphs. Experimental results demonstrate that applications written using Sandslash high-level or low-level API outperform that in state-of-the-art GPM systems AutoMine, Pangolin, and Peregrine on average by 13.8Ã—, 7.9Ã—, and 5.4Ã—, respectively. We also show that these Sandslash applications outperform expert-optimized GPM implementations by 2.3Ã— on average with less programming effort.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Graph pattern mining (GPM) problems arise in many application domains <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20]</ref>. One example is motif counting <ref type="bibr" target="#b5">[6,</ref><ref type="bibr">23,</ref><ref type="bibr" target="#b40">41]</ref>, which counts the number of occurrences of certain structural patterns, such as those shown in Fig. <ref type="figure">1</ref>, in a given graph. These numbers are often different for graphs from different domains, so they can be used as a "signature" to infer, for example, the probable origin of a graph <ref type="bibr" target="#b19">[20]</ref>.</p><p>Programming efficient parallel solutions for GPM problems is challenging. Most problems are solved by searching the input graph for patterns of interest. For efficiency, the search space needs to be pruned aggressively without compromising correctness, but this can be complicated since the pruning strategy usually depends on the structural patterns of interest. Complicated book-keeping data structures are needed to avoid repeating work during the search process; maintaining these data structures efficiently in a parallel program can be challenging. A number of GPM frameworks have been proposed to reduce the burden on the programmer <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b60">61]</ref>. They can be categorized into high-level and low-level systems: they both simplify GPM programming compared to hand-optimized code, but they make different tradeoffs and have different limitations.</p><p>High-level systems such as AutoMine <ref type="bibr" target="#b38">[39]</ref> and Peregrine <ref type="bibr" target="#b28">[29]</ref> take specifications of patterns as input and leverage static analysis techniques to automatically generate GPM programs for those patterns. These systems promote productivity, but they may not allow expressing more efficient algorithms. Low-level systems such as RStream <ref type="bibr" target="#b55">[56]</ref> and Pangolin <ref type="bibr" target="#b11">[12]</ref> provide low-level API functions for the user to control the details of mining process, and they can be used to implement solutions for a wider variety of GPM problems but they require more programming effort. Moreover, both high-level and low-level systems lack the ability to explore combinations of optimizations that have been implemented in handwritten GPM solutions for different problems. Therefore, they do not match the performance of hand-optimized solutions. In this paper, we present Sandslash, an in-memory GPM system that provides high productivity and efficiency without compromising generality. Sandslash provides a novel programming interface that separates problem specifications from algorithmic optimizations. The Sandslash high-level interface requires the user to provide only the specification of the pattern(s) of interest. Sandslash analyzes the specification and automatically enables efficient search strategies, data representations, and optimizations. To customize the GPM algorithm and improve performance further, the user can leverage the Sandslash low-level interface to exploit application-specific knowledge. This two-level API combines the expressiveness of existing low-level systems while achieving the productivity enabled by existing high-level systems. Meanwhile, Sandslash automates a number of optimizations that have been used previously only in handwritten solutions to particular GPM problems. Since these optimizations are missing in previous high-level systems, Sandslash can outperform these systems in most cases. In addition, low-level Sandslash exposes fine-grained control to allow the user to compose low-level optimizations, which leads to better performance than hand-optimized implementations without requiring the programmer to code the entire solution manually.</p><p>Evaluation on a 56-core CPU demonstrates that applications written using Sandslash high-level API outperform the state-of-the-art GPM systems, AutoMine <ref type="bibr" target="#b38">[39]</ref>, Pangolin <ref type="bibr" target="#b11">[12]</ref>, and Peregrine <ref type="bibr" target="#b28">[29]</ref> by 7.7Ã—, 6.2Ã— and 3.9Ã— on average, respectively. Applications using Sandslash low-level API outperform AutoMine, Pangolin, and Peregrine by 22.6Ã—, 27.5Ã— and 7.4Ã— on average, respectively. Sandslash applications are also 2.3Ã— faster on average than expert-optimized GPM applications.</p><p>This work makes the following contributions: â€¢ We present Sandslash, an in-memory GPM system that supports productive, expressive, and efficient pattern mining on large graphs. â€¢ We propose a high-level programming model in which the choice of efficient search strategies, subgraph data structures, and high-level optimizations are automated, and we expose a low-level programming model to allow the programmers to express algorithm-specific optimizations. â€¢ We holistically analyze the optimization techniques available in hand-tuned applications and separately enabled them in the two levels. We show that existing optimizations in the literature applied to specific problems/applications can be applied more generally to other GPM problems. The user is allowed to flexibly control and explore the combination of optimizations. â€¢ Experimental results show that Sandslash substantially outperforms existing GPM systems. They also show the impact of (and the need for) Sandslash's low-level API.</p><p>Compared to expert-optimized applications, Sandslash achieves competitive performance with less programming effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem Definition</head><p>We use standard definitions in graph theory for subgraph, vertex-induced and edge-induced subgraphs, isomorphism and automorphism (definitions in Appendix B.7 A pattern is a graph defined explicitly or implicitly. An explicit definition specifies the vertices and edges of the graph while an implicit definition specifies its desired properties. Given a graph ğº and a pattern P, an embedding ğ‘‹ of P in ğº is a vertex-or edge-induced subgraph of ğº s.t. ğ‘‹ â‰ƒ P. In this work, we focus on connected subgraphs and patterns only.</p><p>Given a graph ğº and a set of patterns ğ‘† ğ‘ = {P 1 , . . . , P ğ‘› }, GPM finds all the vertex-or edge-induced embeddings of P ğ‘– in ğº. For explicit-pattern problems, the solver finds embeddings of the given pattern(s). For implicit-pattern problems, ğ‘† ğ‘ is not explicitly given but described using some rules. Therefore, the solver must find the patterns as well as the embeddings. If the cardinality of ğ‘† ğ‘ is 1, we call this problem a single-pattern problem. Otherwise, it is a multi-pattern problem. Note that graph pattern matching <ref type="bibr" target="#b20">[21]</ref> finds embeddings only for explicit pattern(s), whereas graph pattern mining <ref type="bibr" target="#b1">[2]</ref> solves both explicit-and implicit-pattern problems.</p><p>In some GPM problems, the required output is the listing of embeddings. However, in other GPM problems, the user wants to get statistics such as a count of the occurrences of the pattern(s) in ğº. The particular statistic for P in ğº is termed its support. The support has the anti-monotonic property if the support of a supergraph does not exceed the support of a subgraph. Counting and listing may have different search spaces because listing requires enumerating every embedding while counting does not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph Pattern Mining Problems</head><p>We consider five GPM problems in a given input graph ğº.</p><p>(1) Triangle Counting (TC): The problem is to count the number of triangles in ğº. It uses vertex-induced subgraphs.</p><p>(2) ğ‘˜-Clique Listing (ğ‘˜-CL): A subset of vertices ğ‘Š of ğº is a clique if every pair of vertices in ğ‘Š is connected by an edge in ğº. If the cardinality of ğ‘Š is ğ‘˜, this is called a ğ‘˜-clique (triangles are 3-cliques). The problem of listing ğ‘˜-cliques is denoted ğ‘˜-CL, and it uses vertex-induced subgraphs.</p><p>(3) Subgraph Listing (SL): The problem is to enumerate all edge-induced subgraphs of ğº isomorphic to a pattern P.</p><p>(4) ğ‘˜-Motif Counting (ğ‘˜-MC): This problem counts the number of occurrences of the different patterns that are possible with ğ‘˜ vertices. In the literature, each pattern is called a motif or graphlet. Fig. <ref type="figure">1</ref> shows all 3-motifs and 4motifs. This problem uses vertex-induced subgraphs.</p><p>(5) ğ‘˜-Frequent Subgraph Mining (ğ‘˜-FSM): Given integer ğ‘˜ and a threshold ğœ ğ‘šğ‘–ğ‘› for support, ğ‘˜-FSM finds patterns with ğ‘˜ or fewer edges and lists a pattern P if its support is greater than ğœ ğ‘šğ‘–ğ‘› . This is called a frequent pattern. If ğ‘˜ is not specified, it is set to âˆ, meaning it considers all possible values of ğ‘˜. This problem finds edge-induced subgraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Subgraph Tree and Vertex/Edge Extension</head><p>The subgraph tree is a useful abstraction for organizing GPM computations. The vertex-induced subgraphs of a given input graph ğº=(ğ‘‰ , ğ¸) can be ordered naturally by containment (i.e., if one is a subgraph of the other). It is useful to represent this partial order as a vertex-induced subgraph tree whose vertices represent the subgraphs. Level ğ‘™ of the tree represents subgraphs with ğ‘™ + 1 vertices. The root vertex of the tree represents the empty subgraph 1 . Intuitively, subgraph ğ‘† 2 =(ğ‘Š 2 , ğ¸ 2 ) is a child of subgraph ğ‘† 1 =(ğ‘Š 1 , ğ¸ 1 ) in this tree if ğ‘† 2 can be obtained by extending ğ‘† 1 with a single vertex ğ‘£ âˆ‰ ğ‘Š 1 that is connected to some vertex in ğ‘Š 1 (ğ‘£ is in the neighborhood of subgraph ğ‘† 1 ); this process is called vertex extension. Formally, this can be expressed as ğ‘Š 2 =ğ‘Š 1 âˆª {ğ‘£ } where ğ‘£ âˆ‰ ğ‘Š 1 and there is an edge (ğ‘£, ğ‘¢) âˆˆ ğ¸ for some ğ‘¢ âˆˆ ğ‘Š 1 . It is useful to think of the edge connecting ğ‘† 1 and ğ‘† 2 in the tree as being labeled by ğ‘£. Fig. <ref type="figure" target="#fig_1">2</ref> shows a portion of a vertexinduced subgraph tree with three levels (for lack of space, not all subgraphs are shown). Note that a given subgraph can occur in multiple places in this tree. For example, in 1 In practice, the root and the 0 ğ‘¡â„ level are not built explicitly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>High-level Sandslash</head><p>Low-level Sandslash Fig. <ref type="figure" target="#fig_1">2</ref>, the subgraph containing vertices 1 and 2 occurs in two places. These identical subgraphs are automorphisms (automorphic with each other).</p><p>The edge-induced subgraph tree for a given input graph can be defined in a similar way. Edge extension extends an edge-induced subgraph ğ‘† 1 with a single edge (ğ‘¢, ğ‘£) provided at least one of the endpoints of the edge is in ğ‘† 1 .</p><p>The subgraph tree is a property of the input graph. When solving a specific GPM problem, a solver uses the subgraph tree as a search tree and builds a prefix of the subgraph tree that depends on the problem, pattern, and other aspects of the implementation (e.g., if the size of the pattern is ğ‘˜, subgraphs of larger size are not explored). We use the term embedding tree to refer to the prefix of the subgraph tree that has been explored at any point in the search.</p><p>Finally, since a pattern is a graph, its connected subgraphs form a tree as well. These subgraphs are called sub-patterns, and the tree formed by them is called the sub-pattern tree.</p><p>3 Sandslash API Fig. <ref type="figure" target="#fig_2">3</ref> shows the overview of Sandslash, which is built on top of the Galois <ref type="bibr" target="#b41">[42]</ref> parallel system. In this section, we describe the high-level and low-level API of Sandslash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">High-Level API</head><p>Table <ref type="table" target="#tab_1">1</ref> shows Sandslash high-level API that can be used to specify a GPM problem (as defined in Section 2). The first two required flags define whether the embeddings are vertex-induced or edge-induced and whether the matched embeddings need to be listed or counted. The third required flag defines if the set of patterns is explicit or implicit. If they are explicit, then the patterns must be defined using getExplicitPatterns(). Otherwise, the rule to select implicit patterns must be defined using isImplicitPattern(). process() is a function for customized output. terminate() specifies an optional early termination condition (useful to implement pattern existence query). The default support for each pattern in Sandslash is count (number of embeddings). The support Listing 1. Sandslash low-level API functions. can be customized using three functions: getSupport() defines the support of an embedding, isSupportAntiMonotonic() defines if the support has the anti-monotonic property, and reduce() defines the reduction operator (e.g., sum) for combining the support of different embeddings of the same pattern. In addition, Sandslash has a runtime parameter ğ‘˜ to denote the maximum size (vertices or edges) of the (vertexor edge-induced) embeddings to find. The problem specifications for TC, CL, SL, and MC are straightforward. All four specify an explicit set of patterns 2 . Each pattern is specified using an edge-list. For example, in TC, the user provides an edge-list of {(0,1) (0,2) (1,2)}. Table 1's right column shows the problem specification for FSM. isImplicitPattern() is used to specify that only frequent patterns (i.e., those with support greater than MIN_SUPPORT) are of interest. FSM uses the domain (MNI) support, which is anti-monotonic, and its associated reduce operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Low-Level API</head><p>Sandslash low-level API is shown in Listing 1. Since the mining process includes search, extension, and reduction, control of the mining process includes customizing (1) the graph to search (initLG and updateLG), (2) the extension candidates and their selection (toAdd and toExtend), and (3) the reduction operations to perform (getPattern and localReduce). Sandslash low-level API exposes necessary getPattern() returns the pattern of an embedding. This function can be used to replace the default graph isomorphism test with a custom method to identify patterns (Appendix B.5). Note that Pattern can be user-defined; therefore, Sandslash can support custom aggregation-keys like Fractal <ref type="bibr" target="#b18">[19]</ref>.</p><p>Some algorithms <ref type="bibr" target="#b2">[3]</ref> do local counting for each vertex or edge instead of global counting. Sandslash provides localReduce to support local counting. Listings 2 and 3 in the Appendix show 3-MC and 4-MC using this low-level API.</p><p>Some algorithms <ref type="bibr" target="#b15">[16]</ref> search local (sub-)graphs instead of the (global) input graph. initLG and updateLG can be used to support search on local graphs. Listing 4 in the Appendix shows optimized ğ‘˜-CL using the Sandslash low-level API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Productivity and Expressiveness</head><p>Table <ref type="table" target="#tab_3">2</ref> compares the lines of code of GPM applications in Sandslash and other GPM systems with that of handoptimized GPM applications. Sandslash's high-level specification requires similar programming effort to that of other high-level systems. Zero lines of C++ user code are needed for explicit pattern problems (only flags and pattern edgelist are required). Sandslash's low-level programs require only a little more programming effort since all high-level optimizations are automatically performed by the system. Note that Fractal is classified as a low-level system because it supports high-level API only for single, explicit-pattern problems (i.e., SL). For implicit-pattern problems like FSM, Fractal requires the user to write code for iterative expand-aggregate-filter.</p><p>As for expressiveness, since Sandslash uses the vertex/edge extension model that existing low-level systems use, it is as expressive as these systems. Sandslash high-level API is adequate for the specification of GPM problems implemented in previous GPM systems and is easily extendable to support new features (e.g., anti-edges and anti-vertices in Peregrine) that fit in the vertex/edge extension abstraction. In contrast, existing high-level systems use a pattern-aware model based on set intersection and set difference which does not work well for implicit-pattern problems. For example, FSM implemented in Peregrine and AutoMine (details in Appendix B.3) needs to enumerate possible patterns before the search, which causes non-trivial performance overhead. In Section 4, we show that the vertex/edge extension model can be effectively augmented with pattern awareness, and more importantly, together with the high-level optimizations, Sandslash can even outperform existing high-level systems, with the same productivity.</p><p>All existing GPM systems lack support for some of the functions in Sandslash low-level API. Consequently, they either lack such optimizations or expose an even lower-level API to give the user full control of the mining process at the cost of preventing the system from applying high-level optimizations. For example, Fractal <ref type="bibr" target="#b18">[19]</ref> allows the user to compose low-level optimizations using custom subgraph enumerators. In contrast, Sandslash low-level API is designed to enable the user to express custom algorithms while allowing the system to apply high-level optimizations and explore different traversal orders. For example, to implement local graph search in Sandslash, the user only implements initialization/modification functions for the local graph, which allows Sandslash to apply all possible high-level optimizations in Table <ref type="table" target="#tab_6">3a</ref> during exploration. In Fractal, the user must change the entire exploration which includes implementing all the optimizations by hand; the system cannot apply optimizations automatically. This also applies for other low-level optimizations like local counting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">High-Level Sandslash</head><p>This section describes high-level Sandslash. It uses efficient search strategies (Section 4.1), data representations (Section 4.2), and high-level optimizations (Section 4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Search Strategies</head><p>Given a pattern P with ğ‘˜ vertices, we can build the subgraph tree described in Section 2 to a depth ğ‘˜ and test each subgraph ğ‘‹ at the leaf of the tree to see if ğ‘‹ â‰ƒ P. This approach is pattern-oblivious and works effectively for any pattern (even if P is implicit). In Sandslash, we augment this model with pattern-awareness. If the user defines an explicit pattern problem, Sandslash does pattern analysis and constructs a matching order (Appendix B.3) to guide vertex extension. This prunes the search tree and avoids isomorphism tests. As the same subgraph (i.e., automorphisms) may occur in multiple places of the tree, Sandslash uses the standard symmetry breaking technique (see Appendix B.1) to avoid over-counting.</p><p>GPM solutions must also decide the order in which the subgraph tree is explored. Any top-down visit order on the tree can be used. Breadth-first search (BFS) exposes more parallelism while requiring more storage than a depth-first search (DFS). DFS consumes less memory but has fewer opportunities for parallel execution. Arabesque, RStream, and Pangolin use BFS exploration while the other GPM systems in Table <ref type="table" target="#tab_3">2</ref> use DFS exploration. Sandslash performs a pseudo-DFS parallel exploration (following convention this area, we refer to it simply as DFS), using the following strategy.</p><p>â€¢ Each vertex ğ‘£ in the input graph corresponds to a vertexinduced subgraph for the vertex set {ğ‘£ } and therefore corresponds to a search tree vertex ğ‘¡ ğ‘£ . â€¢ The subtree below each such tree vertex ğ‘¡ ğ‘£ is explored in DFS order. This is a task executed serially by a single thread. When the exploration reaches the pattern size ğ‘˜, the support is updated appropriately. â€¢ Multiple threads execute different tasks in parallel. The runtime uses work-stealing for thread load-balancing; the unit of work-stealing is a task.</p><p>Pattern filtering for implicit-pattern problems that use anti-monotonic support: The search strategy described above mines implicit-pattern problems like FSM by enumerating all embeddings, binning them according to their patterns, and checking the support for each pattern. This can be optimized by exploiting the sub-pattern tree when the support is anti-monotonic (Section 2). If a sub-pattern does not have enough support, then its descendants in the sub-pattern tree will not have enough support and can be ignored due to the anti-monotonic property. Instead of pruning sub-patterns during post-processing, one can prune after generating all the embeddings for a given sub-pattern. This allows Sandslash to avoid generating the embeddings for descendant sub-patterns. This is easy in BFS since it generates embeddings level by level, and in each level, the entire list of the embeddings is scanned to aggregate support for each sub-pattern. However, this does not work for DFS of the sub-graph tree as DFS is done by each thread independently.</p><p>To handle pattern-wise aggregation, Sandslash performs a DFS traversal on the sub-pattern tree instead of the subgraph tree. This ensures that the embeddings for a given sub-pattern are generated by a single thread using the same approach for pattern extension in hand-optimized gSpan <ref type="bibr" target="#b57">[58]</ref>; i.e., the embeddings are gathered to their pattern bins during extension and canonicality is checked for each sub-pattern to avoid duplicate pattern enumeration. When the thread finishes extension in each level, the support for each subpattern can be computed using its own bin of embeddings.</p><p>Conference'17, July 2017, Washington, DC, USAXuhao Chen, Roshan Dathathri, Gurbinder Gill, Loc Hoang, Keshav Pingali </p><formula xml:id="formula_0">v 0 v 1 v 2 v 3 history frontier Level 0 1 2 3 [v 0 ] [v 0 , v 1 ] [v 0 , v 1 , v 2 ] [v 0 , v 1 , v 2 , v 3 ] Current embedding</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Representation of Tree</head><p>Since subgraphs are created incrementally by vertex or edge extension of parent subgraphs in the embedding tree, the representation of subgraphs should allow structure sharing between parent and child subgraphs. We describe the information stored in the embedding tree and the concrete representation of the tree for vertex-induced sub-graphs first.</p><p>â€¢ Each non-root vertex in the tree points to its parent vertex.</p><p>â€¢ Each non-root vertex in the tree corresponds to a subgraph obtained from its parent subgraph by vertex extension with some vertex ğ‘£ of the input graph. The vertex set of a subgraph can be obtained by walking up the tree and collecting the vertices stored on the path to the root. These vertices are the predecessors of ğ‘£ in the embedding; they correspond to vertices discovered before ğ‘£ in that embedding. As shown in Fig. <ref type="figure" target="#fig_3">4</ref>, the leaf containing ğ‘£ 3 represents the subgraph with a vertex set of {ğ‘£ 3 , ğ‘£ 2 , ğ‘£ 1 , ğ‘£ 0 }, which are the vertices stored on the path to the root from this leaf. â€¢ Given a set of vertices ğ‘Š = {ğ‘£ 0 , ğ‘£ 1 , . . . , ğ‘£ ğ‘› } in a subgraph, the edges among them are obtained from the input graph ğº.</p><p>To avoid repetitive look-ups, edge information is cached in the embedding tree. When performing vertex extension by adding a vertex ğ‘¢, the edges between ğ‘¢ and its predecessors in the embedding tree are determined and stored in the tree together with ğ‘¢. This set of edges can be represented compactly using a bit-vector of length ğ‘™ for vertices at level ğ‘™ of the tree. We call this bit-vector the connectivity code (see an example in Appendix B.6). This technique is called Memoization of Embedding Connectivity (MEC) <ref type="bibr" target="#b11">[12]</ref>. â€¢ For edge-induced extension, a set of edges instead of vertices is stored for each embedding. There is no need to store connectivity for embeddings since the set of edges already contains this information. â€¢ For a sub-pattern tree, embeddings of each sub-pattern are gathered as an embedding list (bin of embeddings). The search tree is constructed with sub-patterns as vertices, and each sub-pattern in the tree has an embedding list associated with it. Embedding connectivity is not needed as the sub-pattern contains this information. </p><formula xml:id="formula_1">v 3 v 1 v 0 v 2 input graph v 1 v 0 v 2 v 3 {0, 2} ... v 3 { 0 , 2 }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">High Level Optimizations</head><p>Sandslash automatically performs high-level optimizations without guidance from the user. Degree Filtering (DF): When searching for a pattern in which the smallest vertex degree is ğ‘‘, it is unnecessary to consider vertices with degree less than ğ‘‘ during vertex extension. When MO is enabled, at each level, only one vertex ğ‘£ of the pattern is searched for, so all vertices with degree less than that of ğ‘£ can also be filtered. This optimization (DF) has been used in a hand-optimized SL implementation, PSgL <ref type="bibr" target="#b46">[47]</ref>. Sandslash enables DF for all GPM problems. DF is mostly beneficial for SL and ğ‘˜-CL with large values of ğ‘˜.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Memoizing of Neighborhood Connectivity (MNC):</head><p>When extending an embedding ğ‘‹ = {ğ‘£ 0 , . . . ğ‘£ ğ‘› } by adding a vertex ğ‘¢, a common operation is to check the connectivity between ğ‘¢ and each vertex in ğ‘‹ . To avoid repeated lookups in the input graph, we memoize connectivity information in a map (namely connectivity map) during embedding construction.</p><p>The map takes a vertex ID (say ğ‘£) and returns the positions in the embedding of the vertices connected to ğ‘£. In Fig. <ref type="figure">5</ref>, ğ‘£ 3 is connected to ğ‘£ 0 and ğ‘£ 2 , so when ğ‘£ 3 is looked up in the map, the map returns 0 and 2, the embedding positions of ğ‘£ 0 and ğ‘£ 2 . This map is generated incrementally during the construction of the embedding tree. Whenever a new vertex (ğ‘¤) is added to the current embedding, the map for the neighbors of ğ‘¤ that are not already in that embedding are updated with the position of ğ‘¤ in the embedding; when backing out of this step in the DFS walk, this information is removed from the map.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>High-level Low-level SB DAG MO DF MNC FP CP LG LC</head><formula xml:id="formula_2">TC âœ“ âœ“ âœ“ ğ‘˜-CL âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ SL âœ“ âœ“ âœ“ âœ“ ğ‘˜-MC âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ ğ‘˜-FSM âœ“ âœ“</formula><p>(a) Optimizations applied to GPM applications.  Fig. <ref type="figure">5</ref> shows how the connectivity map is updated during vertex extension. At time â¶, depth of ğ‘£ 0 is sent to the map to update the entries of ğ‘£ 1 , ğ‘£ 2 and ğ‘£ 3 since ğ‘£ 1 , ğ‘£ 2 and ğ‘£ 3 are neighbors of ğ‘£ 0 and they are not in the current embedding. At time â·, depth of ğ‘£ 2 is sent to the map, and the entry of ğ‘£ 3 is updated. Note that although ğ‘£ 0 is also a neighbor of ğ‘£ 2 , there is no need to update the entry of ğ‘£ 0 since ğ‘£ 0 already exists in the current embedding. When ğ‘£ 3 is added to the embedding, the map performs look up with ğ‘£ 3 , and the positions {0, 2} are returned at time â¸. Therefore, we know that ğ‘£ 3 is connected to the 0-th and 2-th vertices in the embedding, which are ğ‘£ 0 and ğ‘£ 2 . For parallel execution, the map is thread private, and each entry is represented by a bit-vector.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>High-level Low-level SB DAG MO DF MNC FP CP LG LC AutoMine</head><formula xml:id="formula_3">[39] âœ“ âŠš Pangolin [12] âœ“ âœ“ âœ“ âœ“ âœ“ Peregrine [29] âœ“ âœ“ âŠš Sandslash-Hi âœ“ âœ“ âœ“ âœ“ âœ“ Sandslash-Lo âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“<label>(</label></formula><p>This optimization (MNC) has been used in a hand-optimized ğ‘˜-CL implementation, kClist <ref type="bibr" target="#b15">[16]</ref>, and a hand-optimized ğ‘˜-MC implementation, PGD <ref type="bibr" target="#b2">[3]</ref>. Sandslash enables this optimization for implicit-pattern problems that require vertexinduced embeddings and for explicit-pattern problems unless the pattern is a triangle; for triangles, Sandslash uses set intersection instead of MNC. In particular, Sandslash enables MNC for SL, an optimization that is missing in handoptimized SL implementations <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b46">47]</ref>.</p><p>MNC does not exist in previous GPM systems such as Peregrine and AutoMine which use set intersection/differences to compute connectivity. Note that MNC is different from the vertex set buffering (VSB) technique used in Peregrine and AutoMine. To remove redundant computation, VSB buffers the vertex sets computed for a given embedding. However, for multi-pattern problems, different patterns may require buffering different vertex sets. Peregrine's solution is to match one pattern at a time, which is inefficient for a large number of patterns. AutoMine's solution is to only buffer one vertex set, which leads to recomputing unbuffered vertex sets. The other alternative is to buffer multiple vertex sets for a large pattern, but this does not scale in terms of memory use. Unlike these solutions, MNC works well for multi-pattern problems since the information in the map can be used for both set intersection and set difference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Low-Level Sandslash</head><p>Hand-optimized GPM applications <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b44">45]</ref> can use algorithmic insight to aggressively prune the search tree.  In this section, we describe how Sandslash low-level API enables users to express such optimizations without implementing everything from scratch. Sandslash low-level API also allows Sandslash to perform all possible high-level optimizations, which leads to even better performance than hand-optimized applications.</p><p>To use the low-level API, the user needs only to understand the subgraph tree abstraction and how to prune the tree. They do not need to understand Sandslash's implementation.</p><p>Fine-Grained Pruning (FP) and Customized Pattern Classification (CP): FP and CP are low-level optimizations enabled in a prior system, Pangolin <ref type="bibr" target="#b11">[12]</ref>, so we describe them in Appendices B.4 and B.5. To support FP, Sandslash exposes API calls toExtend() and toAdd() (Listing 1), which allow the user to use algorithmic insight to prune the search space. FP is enabled when either function is used. To support CP, Sandslash exposes getPattern() to identify (or classify) the pattern of an embedding using pattern features instead of graph isomorphism tests. CP is enabled when this function is used.</p><p>Local Counting (LC): For GPM problems that count matched embeddings instead of listing them, there may be no need to enumerate all matched embeddings since it may be possible to derive precise counts from counts of other patterns. Formally, the count of embeddings that match a pattern P may be calculated using the count of embeddings that match another pattern P â€² . This is useful when both patterns are being searched for or when one pattern is more efficient to search for than the other. This typically requires a local count <ref type="bibr" target="#b27">[28]</ref> (or micro-level count <ref type="bibr" target="#b2">[3]</ref>) of embeddings associated with a single vertex or edge instead of a global count (or macro-level count) of embeddings that match the pattern.</p><p>Conference'17, July 2017, Washington, DC, USAXuhao Chen, Roshan Dathathri, Gurbinder Gill, Loc Hoang, Keshav Pingali Given a pattern P and a vertex ğ‘£ (or an edge ğ‘’) âˆˆ ğº, let ğ‘† be the set of all the embeddings of P in ğº. The local count of P on ğ‘£ (or ğ‘’) is defined as the number of subgraphs in ğ‘† that contains ğ‘£ (or ğ‘’). Fig. <ref type="figure">6</ref> shows an example of local counting on edge ğ‘’. Given an edge ğ‘’ : (ğ‘¢, ğ‘£), the local count of ğ‘’ for wedges ğ¶ ğ‘¤ğ‘‘ğ‘” (ğ‘’) can be calculated from the local count of ğ‘’ for triangles ğ¶ ğ‘¡ğ‘Ÿğ‘– (ğ‘’) using this formula:</p><formula xml:id="formula_4">ğ¶ ğ‘¤ğ‘‘ğ‘” = (ğ‘‘ğ‘’ğ‘” ğ‘¢ âˆ’ ğ¶ ğ‘¡ğ‘Ÿğ‘– âˆ’ 1) + (ğ‘‘ğ‘’ğ‘” ğ‘£ âˆ’ ğ¶ ğ‘¡ğ‘Ÿğ‘– âˆ’ 1)<label>(1)</label></formula><p>ğ‘‘ğ‘’ğ‘” ğ‘¢ and ğ‘‘ğ‘’ğ‘” ğ‘£ are the degrees of ğ‘¢ and ğ‘£.</p><p>Since wedge counts can be computed from triangle counts, enumerating wedges is avoided when using local counting for 3-MC. Similar formulas can be applied for ğ‘˜-MC. Besides, local counting can also be used to prune the search space for many subgraph counting problems. For example, to count edge-induced diamonds, we first compute the local triangle count ğ‘› ğ‘¡ for each edge ğ‘’, and use the formula ğ‘› ğ‘¡ 2 = ğ‘› ğ‘¡ Ã— (ğ‘› ğ‘¡ âˆ’1)/2 to get the local diamond count. The global diamond count is obtained by simply accumulating local counts.</p><p>Sandslash exposes localReduce (Listing 1) to let the user specify how local counts are accumulated. Sandslash also exposes toExtend and toAdd to permit the user to customize the subgraph tree exploration so that the user can determine which patterns need to be enumerated. Listing 2 in Appendix shows the user code for 3-MC using local counting. Sandslash activates local counting when the user implements localReduce.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search on Local Graph (LG)</head><p>In some problems like ğ‘˜-CL, pattern invariants can be exploited to prune the search space <ref type="bibr" target="#b15">[16]</ref>. To extend an embedding {ğ‘£ 1 ...ğ‘£ ğ‘– } at level ğ‘– âˆ’ 1 for ğ‘˜-CL, the baseline search strategy considers all the neighbors of these vertices in the input graph that are not already in the embedding. For ğ‘˜-CL, any successful candidate vertex for extension must be a neighbor of all ğ‘£ ğ‘– (otherwise the extension will not result in a clique), so it is more efficient to intersect the neighbor lists of the ğ‘£ ğ‘– and consider only the vertices in this intersection as candidates for vertex extension. Abstractly, this can be viewed as constructing a local graph that is the vertex-induced subgraph ğº ğ‘– consisting of the vertices ğ‘£ ğ‘– and the vertices in the intersection of their neighbor lists, and selecting candidate vertices only from ğº ğ‘– . Furthermore, if ğ‘£ ğ‘–+1 is the vertex selected at this stage, subgraph ğº ğ‘–+1 is obtained from ğº ğ‘– by removing all vertices in ğº ğ‘– that are not neighbors of ğ‘£ ğ‘–+1 . In this way, the local graph keeps shrinking as the level increases, further reducing the search space. Fig. <ref type="figure" target="#fig_7">7</ref>  Sandslash allows the user specify how to initialize the local graph using initLG() and update it at the end of each DFS level using updateLG() (optional). When initLG() is defined, Sandslash enables LG to get the neighborhood information during extension using the local graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We present experimental setup in Section 6.1 and then compare Sandslash with state-of-the-art GPM systems and expertoptimized implementations in Section 6.2. Finally, Sandslash is analyzed in more detail in Sections 6.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental Setup</head><p>We evaluate two variants of Sandslash: Sandslash-Hi, which only enables high-level optimizations, and Sandslash-Lo, which enables both high-level and low-level optimizations. We compare Sandslash with the state-of-the-art GPM systems <ref type="foot" target="#foot_0">3</ref> : AutoMine <ref type="bibr" target="#b38">[39]</ref>, Pangolin <ref type="bibr" target="#b11">[12]</ref>, and Peregrine <ref type="bibr" target="#b28">[29]</ref>. We use the five applications (also used in previous systems) listed in Table <ref type="table" target="#tab_3">2</ref>. We also evaluate the state-of-the-art expertoptimized GPM applications <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b51">52]</ref> listed in Table <ref type="table" target="#tab_3">2</ref> except for CECI <ref type="bibr" target="#b6">[7]</ref> (not publicly available). For fair comparison, we modified DistGraph <ref type="bibr" target="#b51">[52]</ref> and PGD <ref type="bibr" target="#b2">[3]</ref> so that they produce the same output as Sandslash. We added a parameter ğ‘˜ in DistGraph: exploration stops when the pattern size becomes ğ‘˜. For PGD, we disabled counting disconnected patterns.</p><p>Table <ref type="table" target="#tab_7">4</ref> lists the input graphs. The first 3 graphs (Pa, Yo, pdb) are vertex-labeled graphs which can be used for FSM. We also include widely used large graphs (Lj, Or, Tw4, Fr, Uk), and a very large web-crawl <ref type="bibr" target="#b9">[10]</ref> (Gsh). These graphs do not have labels and are only used for TC, ğ‘˜-CL, SL, ğ‘˜-MC.</p><p>Our experiments were conducted on a 4 socket machine with Intel Xeon Gold 5120 2.2GHz CPUs (56 cores in total) and 190GB RAM. All runs use 56 threads. For the largest graph, Gsh, we used a 2 socket machine with Intel Xeon Cascade Lake 2.2 Ghz CPUs (48 cores in total) and 6TB of Intel Optane PMM (byte-addressable memory technology). Peregrine preprocesses the input graph to reorder vertices based on their degrees, which can improve the performance of GPM applications. In our evaluation, Sandslash does not reorder vertices to be fair to other systems and hand-optimized applications which do not perform such preprocessing. We use a time-out of 30 hours, exclude graph loading and preprocessing time, and report results as an average of three runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparisons with Existing Systems</head><p>Recall that Tables 3a and 3b list the optimizations applicable for each GPM application and enabled by each GPM system. Triangle Counting (TC): Note that BFS and DFS are similar for enumerating triangles. As shown in Table <ref type="table" target="#tab_8">5</ref>, Sandslash achieves competitive performance with Pangolin and expertimplemented GAP <ref type="bibr" target="#b4">[5]</ref>. Both Pangolin and Sandslash outperform Peregrine and AutoMine because they use DAG which is more efficient than on-the-fly symmetry breaking. On average, Sandslash outperforms AutoMine, Pangolin, Peregrine, and GAP by 10.1Ã—, 1.4Ã—, 13.8Ã—, and 1.4Ã— respectively, for TC. ğ‘˜-Clique Listing (ğ‘˜-CL): Table <ref type="table" target="#tab_9">6</ref> presents ğ‘˜-CL results. Pangolin (BFS-only) performs poorly as memoizing of neighborhood connectivity (MNC) can only be enabled in DFS. Peregrine does on-the-fly symmetry breaking (SB), but it does not construct and use DAG as in Pangolin and Sandslash. Therefore, Peregrine performs similarly to Pangolin although it is a DFS based system. AutoMine is slower than Sandslash because it does not do symmetry breaking. We observe that Sandslash-Hi is already significantly faster than all the previous GPM systems. Moreover, Sandslash-Lo achieves better performance than even expert-implemented kClist <ref type="bibr" target="#b15">[16]</ref> by enabling search on a local graph (LG). There are some cases where Sandslash-Lo underperforms Sandslash-Hi. This is because searching on local graph requires computing/maintaining local graphs. When the search space is not reduced significantly, the overhead might outweigh the benefits. We  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lj</head><p>Or Fr 2 35   2 37   2 39   # embeddings enumerated 5-CL Lj Or Fr 2 32   2 35   2 38   3-MC Sandslash-Hi Sandslash-Lo ğ‘˜-Frequent Subgraph Mining (ğ‘˜-FSM): Table <ref type="table" target="#tab_12">9</ref> presents ğ‘˜-FSM results (AutoMine is omitted because it does not use domain support for FSM). Although Peregrine uses DFS exploration, it does global synchronization among threads for each DFS iteration in FSM, which essentially results in BFSlike exploration. In contrast, Sandslash uses DFS exploration on the sub-pattern tree and filters patterns without synchronization. Peregrine is the fastest for Yo due to better load balance and relatively small number of frequent patterns. We observe that for graphs with a large number of frequent patterns (Pa), Peregrine becomes very inefficient as its patterncentric approach enumerates all the possible patterns first and then enumerates embeddings for each pattern one by one; this is detrimental to performance for larger graphs and patterns (e.g., it times out for Pdb). Sandslash is similar or faster than Pangolin in most cases but is slower for Pa at ğœ=30K mainly because the BFS based approach has high parallelism for that case. For 4-FSM, Sandslash outperforms both Pangolin and Peregrine. Sandslash performs better than expert-implemented DistGraph <ref type="bibr" target="#b51">[52]</ref> too as it automatically enables all optimizations that are in DistGraph. Sandslash is the only system that can run 4-FSM on Pdb. On average, Sandslash outperforms Pangolin, Peregrine, and DistGraph by 1.2Ã—, 4.6Ã— and 2.4Ã—, respectively, for FSM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Analysis of Sandslash</head><p>Due to lack of space, we present only the impact of optimizations in Sandslash that are missing in other systems (Table <ref type="table" target="#tab_5">3b</ref>).</p><p>High-Level Optimizations: We observe 2% to 16% improvement for ğ‘˜-CL due to the degree filtering (DF) optimization. Fig. <ref type="figure">8</ref> shows speedup due to memoization of embedding connectivity (MEC) and memoization of neighborhood connectivity (MNC) optimizations for ğ‘˜-MC. For ğ‘˜-MC, the connectivity information in both the neighborhood and the embedding is memoized. MEC and MNC improve performance by 7.4Ã— and 87Ã— on average. Low-Level Optimizations: Formula-based local counting (LC) reduces compute time by avoiding unnecessary enumeration of patterns. Table <ref type="table" target="#tab_10">7</ref> shows Sandslash-Lo is 38Ã— faster than Sandslash-Hi due to LC. As the pattern gets larger, pruning becomes more important. LC improves performance of 3-MC and 4-MC by 25Ã— and 136Ã— on average, respectively. This highlights the need to expose a low-level interface to express customized pruning strategies. Fig. <ref type="figure">9</ref> illustrates the performance improvement on ğ‘˜-CL using the local graphs (LG) optimization on large patterns. Shrinking the local graph can reduce the search space compared to using the original graph. This improves performance by 1.2Ã— to 3.5Ã— for Or and Fr. The speedup for Or increases as the pattern size ğ‘˜ increases. However, for Fr, the speedup peaks at ğ‘˜ = 7, indicating that further shrinking becomes less effective as ğ‘˜ grows. This trend depends on the input graph topology, but in general, this optimization is effective for supporting large patterns.</p><p>Both LC and LG optimizations prune the enumeration search space. We compare the search spaces of Sandslash-Hi and Sandslash-Lo to explain how they improve performance. Fig. <ref type="figure" target="#fig_9">10</ref> shows the number of enumerated embeddings for ğ‘˜-CL and ğ‘˜-MC. We observe a significant reduction for Or and Fr in Sandslash-Lo, explaining the performance differences between Sandslash-Hi and Sandslash-Lo in Tables <ref type="table" target="#tab_10">6 and 7</ref>. However, the pruning is less effective for Lj in ğ‘˜-CL, and given the overhead of local graph construction, Sandslash-Lo performs similar to Sandslash-Hi for Lj as shown in Table <ref type="table" target="#tab_9">6</ref>. Large Patterns: Fig. <ref type="figure" target="#fig_11">11</ref>   Existing systems cannot efficiently mine large patterns due to a much larger enumeration search space or significant amount of redundant computation. In contrast, Sandslash can effectively handle these large patterns, and in all cases Sandslash-Lo is faster than expert-implemented kClist. Large Inputs: The large input graph, Gsh, requires 199GB in Compressed Sparse Row (CSR) format on disk, so we evaluate it using 96 threads on the Optane machine. We were not able to run AutoMine and Peregrine on this large input. For 4-CL, Pangolin takes 6.5 hours, whereas Sandslash-Hi takes only 0.9 hours. Sandslash-Hi's memory usage is low as well: peak memory usage for Sandslash-Hi is 436 GB, while Pangolin, a BFS-based system, uses 3.5 TB memory. kClist and Sandslash-Lo run out of memory because maintaining the local graphs consumes more than 6 TB memory. Strong Scaling: The speedup of Sandslash on 56 threads over Sandslash on 1 thread is, on average, 43Ã—, 28Ã—, 39Ã—, 35Ã—, and 8Ã— for TC, ğ‘˜-CL, SL, ğ‘˜-MC, and ğ‘˜-FSM, respectively. The speedup for ğ‘˜-FSM is lower due to constrained parallelism in traversing the sub-pattern tree. Sandslash balances work well because the number of grains/vertices is large enough. Orthogonal techniques like fine-grained work-stealing in Fractal and vertex reordering (preprocessing) in Peregrine can be added to Sandslash to further improve load balance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Low-level GPM Systems: Arabesque <ref type="bibr" target="#b53">[54]</ref> is a distributed GPM system that proposed the embedding-centric programming paradigm. RStream <ref type="bibr" target="#b55">[56]</ref> is an out-of-core GPM system on a single machine. Its programming model is based on relational algebra. Kaleido <ref type="bibr" target="#b60">[61]</ref> is a single-machine system that uses a compressed sparse embedding (CSE) data structure to reduce memory consumption. G-Miner <ref type="bibr" target="#b10">[11]</ref> is a distributed GPM system which incorporates task-parallel processing. Pangolin <ref type="bibr" target="#b11">[12]</ref> is a shared-memory GPM system targeting both CPU and GPU. Instead of the BFS exploration used in the above systems, Fractal <ref type="bibr" target="#b18">[19]</ref> uses DFS to enumerate subgraphs on distributed platforms. Compared to these systems, Sandslash improves productivity and performance since many optimizations are automated in Sandslash. Some of these GPM systems use distributed, out-of-core, or GPU platforms, which is orthogonal to our work. The focus of our work is utilizing in-memory CPU platforms to get the best performance.</p><p>High-level GPM Systems: AutoMine <ref type="bibr" target="#b38">[39]</ref> is a DFS based system targeting a single-machine. It provides a high-level programming interface and employs a compiler to generate high performance GPM programs. Sandslash supports a wider range of GPM problems and also enhances performance without compromising productivity. Peregrine is the state-of-the-art high-level GPM system. It includes efficient matching strategies from well-established techniques <ref type="bibr" target="#b7">[8,</ref><ref type="bibr">23,</ref><ref type="bibr" target="#b31">32]</ref> and improves performance compared to previous systems. Nevertheless, Sandslash outperforms Peregrine using only its high-level API. Furthermore, Sandslash provides a low-level API to trade-off programming effort for much better performance.</p><p>GPM Algorithms: There are numerous hand-optimized GPM applications targeting various platforms. For TC, there are parallel solvers on multicore CPUs <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b59">60]</ref>, distributed CPUs <ref type="bibr">[22,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b50">51]</ref>, and GPUs <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b42">43]</ref>. kClist <ref type="bibr" target="#b15">[16]</ref> is a parallel ğ‘˜-CL algorithm derived from <ref type="bibr" target="#b13">[14]</ref>. It constructs DAG using a core value based ordering to reduce search space. PGD <ref type="bibr" target="#b2">[3]</ref> counts 3 and 4-motifs by leveraging proven formulas to reduce enumeration space. Escape <ref type="bibr" target="#b44">[45]</ref> extends this approach to 5-motifs. Subgraph listing <ref type="bibr">[1, 7, 8, 30-33, 35, 37, 40, 46, 47, 49, 50, 55]</ref> is another important application in which a matching order is applied to reduce search space and avoid graph isomorphism tests. gSpan <ref type="bibr" target="#b57">[58]</ref> is a sequential FSM algorithm using a lexicographic order for symmetry breaking. DistGraph <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b52">53]</ref> parallelizes gSpan with a customized dynamic load balancer that splits tasks on the fly. We did holistic analysis on the optimizations introduced in these expert-written solvers and implemented them in Sandslash for better productivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this work, We present Sandslash, a two-level sharedmemory GPM system that provides high productivity and high performance without compromising expressiveness. The user can easily compose GPM applications with the support of automated optimizations and transparent parallelism. The system also gives the user flexibility to express advanced optimizations to boost performance further. Sandslash significantly outperforms existing systems and even hand-optimized implementations.</p><p>Listing 3. Sandslash-Lo user code for 4-MC using local counting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Details of Optimizations and Definitions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1 Symmetry Breaking (Partial Order)</head><p>The problem of overcounting is circumvented by an automorphism check which selects a canonical representation from identical subgraphs. This technique is also known as symmetry breaking. A widely used approach is to apply partial orders between vertices in the embedding <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b31">32]</ref>. For special patterns, e.g., cliques, symmetry breaking can be done by constructing a DAG, which avoids runtime checks but requires preprocessing. Sandslash supports both techniques and adaptively applies them according to the detected pattern. In Fig. <ref type="figure" target="#fig_1">2</ref> Listing 4. Sandslash-Lo user code for ğ‘˜-CL using the local graph. also useful for pruning the search tree, e.g., the subgraph (2,1) is not extended in Fig. <ref type="figure" target="#fig_1">2</ref> because it is automorphic to the subgraph <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b1">2)</ref>. High-level Sandslash enumerates only canonical embeddings, while low-level Sandslash allows user-defined automorphism check.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Orientation (Total Order)</head><p>The technique establishes a total ordering among vertices, and converts the input graph into a Directed Acyclic Graph (DAG). The search is then done over this DAG instead of the original input graph, which substantially reduces the search space. In Sandslash, orientation is automatically enabled when Sandslash detects a clique as the input pattern, i.e., when |ğ¸| = |ğ‘‰ | Ã— (|ğ‘‰ | âˆ’ 1)/2 for a given pattern ğ‘ƒ (ğ‘‰ , ğ¸). Currently two types of orientation schemes are supported: (1) degree based and (2) core value based. For degree based orientation, the ordering among vertices is established based on their degrees: each edge points towards the vertex with higher degree. When there is a tie, the edge points to the vertex with larger vertex ID. For core value based orientation, ordering is established using the core value of vertices <ref type="bibr" target="#b15">[16]</ref>, </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3 Pattern-Guided Search (Matching Order)</head><p>The pattern structure can be leveraged to prune the search space, which is known as matching-order. Fig. <ref type="figure" target="#fig_12">12</ref> shows the 5 possible matching orders for diamond. We can find the triangle first, and then add the fourth vertex connected to two of the endpoints of the triangle. Another possible matching order is to find a wedge first, and then find the fourth vertex that is connected to all three vertices of the wedge. Both orders find the diamond, but they explore different parts of the search space. In real-world sparse graphs, the number of wedges is usually orders-of-magnitude larger than the number of triangles, so it is more efficient to find the triangle first.</p><p>In general, using the right matching order reduces computation and memory consumption. Sandslash uses a greedy approach <ref type="bibr" target="#b31">[32]</ref> to choose a good matching order: at each step, (1) we choose a sub-pattern which has more internal partial orders; (2) If there is a tie, we choose a denser sub-pattern, i.e., one with more edges. In Fig. <ref type="figure" target="#fig_12">12, (c</ref>) is the matching order chosen by the system, since there is a partial order between vertex 0 and 1 for symmetry breaking (B.1). The intuition is that applying partial ordering as early as possible can better prune the search tree. Similarly, matching denser sub-pattern first can possibly prune more branches at early stage.</p><p>Note that using matching order avoids isomorphism test if the patterns are explicit. However, for implicit-pattern problems, this approach needs to enumerate all the possible patterns before search. For example, FSM in AutoMine generates a matching order for each unlabeled pattern and includes a lookup table to distinguish between labeled patterns. This table is massive when the graph has many distinct labels. Peregrine also suffers significant overhead for FSM since there are many patterns and it matches each of them one by one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4 Fine-Grained Pruning</head><p>Many GPM algorithms use their own pruning strategy during the tree search, which significantly reduces the search space. Sandslash exposes toAdd and toExtend to allow finegrained control on the pruning strategies. For example, in indicating ğ‘£ 2 is connected with ğ‘£ 1 . ğ‘£ 4 has a code of {1,0,1}, meaning ğ‘£ 4 is connected to ğ‘£ 1 and ğ‘£ 3 , but not ğ‘£ 2 . Concatenating codes of all vertices, we get the code of this embedding {111101}. With this code we can rebuild the exact structure of the embedding on the left. <ref type="bibr" target="#b15">[16]</ref>, since an ğ‘–-clique can only be extended from an (ğ‘–-1)-clique, toExtend and toAdd can be used to only extend the last vertex in the embedding and check if the newly added vertex is connected to all previous vertices in the embedding, respectively. In general, these two functions are used to specify the matching order and partial orders for explicit-pattern problems. The matching order is described by toExtend which specifies the next vertex to extend in each level. Connectivity and partial orders are checked in toAdd. Sandslash generates these functions automatically for explicit-pattern problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ğ‘˜-CL</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.5 Customized Pattern Classification</head><p>To recognize the pattern of a given embedding, a straightforward approach is the graph isomorphism test, which is an expensive computation. To avoid the test, Sandslash uses matching order for explicit patterns. For multiple explicit pattern problems, the connectivity check can be used to identify different patterns. For small implicit patterns, Sandslash uses customized pattern classification (CP) <ref type="bibr" target="#b11">[12]</ref>. For example, in FSM, the labeled wedge patterns can be differentiated by hashing the labels of the three vertices (the two endpoints of the wedge are symmetric). To enable CP, the user needs to use the getPattern API function to implement a customized method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.6 Example for Connectivity Code</head><p>As shown in Fig. <ref type="figure" target="#fig_0">13</ref>, if the bit at position ğ‘– of connectivity code is set, there is an edge in ğº between vertex ğ‘¢ and the vertex contained in the ancestor at level ğ‘– in the tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.7 Subgraphs, Subgraph Trees and Patterns</head><p>The following definitions are standard <ref type="bibr" target="#b24">[25]</ref>. Given a graph ğº (ğ‘‰ , ğ¸), a subgraph ğº â€² (ğ‘‰ â€² , ğ¸ â€² ) of ğº is a graph where ğ‘‰ â€² âŠ† ğ‘‰ , ğ¸ â€² âŠ† ğ¸. If ğº 1 is a subgraph of ğº 2 , we denote it as ğº 1 âŠ† ğº 2 .</p><p>Given a vertex set ğ‘Š âŠ† ğ‘‰ , the vertex-induced subgraph is the graph ğº â€² whose (1) vertex set is ğ‘Š and whose (2) edge set contains the edges in ğ¸ whose endpoints are in ğ‘Š . Given an edge set ğ¹ âŠ† ğ¸, the edge-induced subgraph is the graph ğº â€² whose (1) edge set is ğ¹ and whose (2) vertex set contains the endpoints in ğ‘‰ of the edges in ğ¹ . The difference between the two types of subgraphs can be understood as follows. Suppose vertices ğ‘£ 1 and ğ‘£ 2 are connected by an edge ğ‘’ in ğº. If ğ‘£ 1 and ğ‘£ 2 occur in a vertex-induced subgraph, then ğ‘’ occurs in the subgraph as well; in an edge-induced subgraph, edge ğ‘’ will be present only if it is in the given edge set ğ¹ . Any vertex-induced subgraph can be formulated as an edgeinduced subgraph.</p><p>Two graphs ğº 1 (ğ‘‰ 1 , ğ¸ 1 ) and ğº 2 (ğ‘‰ 2 , ğ¸ 2 ) are isomorphic, denoted ğº 1 â‰ƒ ğº 2 , if there exists a bijection f: ğ‘‰ 1 â†’ ğ‘‰ 2 , such that any two vertices ğ‘¢ and ğ‘£ of ğº 1 are adjacent in ğº 1 if and only if f (ğ‘¢) and f (ğ‘£) are adjacent in ğº 2 . In other words, ğº 1 and ğº 2 are structurally identical. In the case when f is a mapping of a graph onto itself, i.e., when ğº 1 and ğº 2 are the same graph, ğº 1 and ğº 2 are automorphic, i.e. ğº 1 ğº 2 .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 . 3 -</head><label>13</label><figDesc>Figure 1. 3-vertex (left) and 4-vertex (right) motifs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. A portion of a vertex-induced subgraph tree with 3 levels. Lightly colored subgraphs are removed from consideration by automorphism checks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Overview of Sandslash. Dash indicates optional.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Embedding data structure (vertex-induced).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 Figure 5 .</head><label>15</label><figDesc>Figure 5. An example of connectivity memoization. â¶, â· and â¸ are timestamps to show the order of actions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>b) Optimizations supported by GPM frameworks. âœ“: full support; âŠš: limited support.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>5 Figure 6 .</head><label>56</label><figDesc>Figure 6. An example of local counting. Given the local triangle count of edge ğ‘’ is ğ¶ ğ‘¡ğ‘Ÿğ‘– = 2, and ğ‘‘ğ‘’ğ‘” ğ‘¢ = 4, ğ‘‘ğ‘’ğ‘” ğ‘£ = 5, we can get local wedge count of ğ‘’ as ğ¶ ğ‘¤ğ‘‘ğ‘” = (4 âˆ’ 2 âˆ’ 1) + (5 âˆ’ 2 âˆ’ 1) = 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Local graph induced by edge (ğ‘£ 5 , ğ‘£ 6 ) and common neighbors of ğ‘£ 5 and ğ‘£ 6 from the global graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 .Figure 9 .</head><label>89</label><figDesc>Figure 8. ğ‘˜-MC speedup with memoization of embedding/neighborhood connectivity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Comparing search space (# of enumerated embeddings) of high-and low-level Sandslash.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>shows ğ‘˜-CL on Fr graph with ğ‘˜ from 4 to 9. Pangolin and Peregrine timed out for ğ‘˜ = 8 and ğ‘˜ = 9. Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’Out Timeâˆ’</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Execution time (sec in log scale) of ğ‘˜-CL on Fr graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. Possible matching orders for pattern diamond. The number in each vertex is not a vertex ID but the order being matched. Colors show the symmetric positions. The matching process can start from blue vertices (a &amp; b &amp; c) or green vertices (d &amp; e). Among them, (a) and (e) match a wedge first, and then form a diamond; (b) (c) and (d) discover a triangle first, and then form a diamond. instead of degrees. It saves memory for local graph search, but requires more pre-processing time than the degree based orientation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Example of the connectivity code. The code of ğ‘£ 2 is {1},</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>). Isomorphic graphs ğº 1 and ğº 2 are denoted as ğº 1 â‰ƒ ğº 2 . If ğº 1 and ğº 2 are automorphic, they are denoted as ğº 1 ğº 2 .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Left column lists Sandslash high-level API flags and functions. Right column is the spec and user code of FSM using the API.</figDesc><table><row><cell>Flag</cell><cell cols="2">Required Example: spec for FSM</cell></row><row><cell>isVertexInduced</cell><cell>yes</cell><cell>false</cell></row><row><cell>isListing</cell><cell>yes</cell><cell>false</cell></row><row><cell>isExplicit</cell><cell>yes</cell><cell>false</cell></row><row><cell>Function</cell><cell cols="2">Required Example: user code for FSM</cell></row><row><cell>getExplicitPatterns()</cell><cell>no</cell><cell>-</cell></row><row><cell>isImplicitPattern(Pattern pt)</cell><cell>no</cell><cell>pt.support â‰¥ MIN_SUPPORT</cell></row><row><cell>process(Embedding emb)</cell><cell>no</cell><cell>-</cell></row><row><cell>terminate(Embedding emb)</cell><cell>no</cell><cell>-</cell></row><row><cell>isSupportAntiMonotonic()</cell><cell>no</cell><cell>true</cell></row><row><cell cols="2">getSupport(Embedding emb) no</cell><cell>getDomainSupport(emb)</cell></row><row><cell cols="2">reduce(Support s1, Support s2) no</cell><cell>mergeDomainSupport(s1, s2)</cell></row><row><cell cols="3">bool toExtend ( Embedding emb , Vertex v ) ;</cell></row><row><cell cols="3">bool toAdd ( Embedding emb , Vertex u ) ;</cell></row><row><cell cols="2">bool toAdd ( Embedding emb , Edge e ) ;</cell><cell></cell></row><row><cell cols="2">Pattern getPattern ( Embedding emb ) ;</cell><cell></cell></row><row><cell cols="3">void localReduce ( int depth , vector &lt; Support &gt; &amp; supports ) ;</cell></row><row><cell cols="3">void initLG ( Graph gg , Vertex v , Graph lg ) ;</cell></row><row><cell cols="3">void initLG ( Graph gg , Edge e , Graph lg ) ;</cell></row><row><cell>void updateLG ( Graph lg ) ;</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>2</head><label></label><figDesc>Sandslash provides helper functions to enumerate a clique or all patterns of a given size ğ‘˜. It also allows reading the patterns from files. Sandslash provides helper functions getDomainSupport and mergeDomainSupport for the standard definition of domain support.</figDesc><table><row><cell></cell><cell cols="2">Language TC</cell><cell>ğ‘˜-CL</cell><cell>SL</cell><cell>ğ‘˜-MC</cell><cell>ğ‘˜-FSM</cell></row><row><cell>Hand Optimized</cell><cell>C/C++</cell><cell cols="5">GAP [5] KClist [16] CECI [7] PGD [3] DistGraph [52] 89 394 3,000 2,538 17,459</cell></row><row><cell>Arabesque [54]</cell><cell>Java</cell><cell>43</cell><cell>31</cell><cell>-</cell><cell>35</cell><cell>80</cell></row><row><cell>RStream [56]</cell><cell>C++</cell><cell>101</cell><cell>61</cell><cell>-</cell><cell>98</cell><cell>125</cell></row><row><cell cols="2">Fractal [19] Java/Scala</cell><cell>6</cell><cell>6</cell><cell>5</cell><cell>12</cell><cell>48</cell></row><row><cell>Pangolin [12]</cell><cell>C++</cell><cell>26</cell><cell>36</cell><cell>57</cell><cell>82</cell><cell>252</cell></row><row><cell>AutoMine [39]</cell><cell>C++</cell><cell>0</cell><cell>0</cell><cell>N/S</cell><cell>-</cell><cell>N/S</cell></row><row><cell>Peregrine [29]</cell><cell>C++</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>54</cell><cell>68</cell></row><row><cell>Sandslash-Hi</cell><cell>C++</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>9</cell><cell>75</cell></row><row><cell>Sandslash-Lo</cell><cell>C++</cell><cell>-</cell><cell>67</cell><cell>-</cell><cell>61</cell><cell>-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>Lines determines if a vertex ğ‘£ in embedding ğ‘’ğ‘šğ‘ must be extended. toAdd decides if extending embedding ğ‘’ğ‘šğ‘ with vertex ğ‘¢ (or edge ğ‘’) is allowed. toExtend and toAdd do finegrained pruning to reduce search space (Appendix B.4).</figDesc><table><row><cell>of code in Sandslash, other GPM systems, and</cell></row><row><cell>expert-optimized GPM applications. N/S: not supported; '-': sup-</cell></row><row><cell>ported but not yet implemented. AutoMine, Peregrine are high-level</cell></row><row><cell>systems, Sandslash is a two-level system, and the rest are low-level</cell></row><row><cell>systems.</cell></row><row><cell>control and is expressive enough to support sophisticated</cell></row><row><cell>algorithms.</cell></row></table><note>toExtend</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Table 3a (left) lists which of these optimizations are applied to each application. Table 3b (left) lists which of them are supported by other GPM systems.</figDesc><table /><note>Symmetry Breaking (SB), Orientation (DAG), and Matching Order (MO): These optimizations are supported by at least one previous GPM system (Table3b), so we describe them in Appendices B.1, B.2, and B.3. Sandslash applies SB for all GPM problems. Sandslash enables DAG only if it is a single explicit-pattern problem and if the pattern is a clique. It enables MO for single explicit-pattern problems except if the pattern is a triangle (because it is not beneficial).</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 .</head><label>3</label><figDesc>Optimizations enabled in Sandslash. High level optimizations: SB: Symmetry breaking; DF: Degree Filtering; DAG: orientation; MO: Matching Order; MNC: Memoization of Neighborhood Connectivity. Low-level optimizations: FP: Fine-grained Pruning; CP: Customized Pattern classification; LG: search on Local Graph; LC: Local Counting.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3a (</head><label>3a</label><figDesc>right) lists optimizations that are applicable to each application, and Table 3b (right) lists which of them are supported by other GPM systems.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 4 .</head><label>4</label><figDesc>illustrates an example of induced local graphs. Input graphs (symmetric, no loops, no duplicate edges, neighbor list sorted) and their properties (ğ‘‘ is the average degree).</figDesc><table><row><cell>Graph</cell><cell cols="2">Source # V</cell><cell># E</cell><cell cols="2">ğ‘‘ # Labels</cell></row><row><cell>Pa</cell><cell>Patents [24]</cell><cell>3M</cell><cell cols="2">28M 10</cell><cell>37</cell></row><row><cell>Yo</cell><cell>Youtube [13]</cell><cell>7M</cell><cell cols="2">114M 16</cell><cell>29</cell></row><row><cell>Pdb</cell><cell cols="2">ProteinDB [52] 49M</cell><cell cols="2">388M 8</cell><cell>25</cell></row><row><cell>Lj</cell><cell>LiveJournal [36]</cell><cell>5M</cell><cell cols="2">86M 18</cell><cell>0</cell></row><row><cell>Or</cell><cell>Orkut [36]</cell><cell>3M</cell><cell cols="2">234M 76</cell><cell>0</cell></row><row><cell>Tw4</cell><cell cols="4">Twitter40 [34] 42M 2,405M 29</cell><cell>0</cell></row><row><cell>Fr</cell><cell cols="4">Friendster [59] 66M 3,612M 28</cell><cell>0</cell></row><row><cell>Uk</cell><cell cols="4">UK2007 [9] 106M 6,604M 31</cell><cell>0</cell></row><row><cell>Gsh</cell><cell cols="4">Gsh-2015 [10] 988M 51,381M 52</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 5 .</head><label>5</label><figDesc>Execution time (sec) of TC.</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Lj Or Tw4</cell><cell>Fr</cell><cell>Uk</cell></row><row><cell cols="2">Pangolin</cell><cell>0.4 2.3</cell><cell cols="2">75.5 55.1</cell><cell>45.8</cell></row><row><cell cols="2">AutoMine</cell><cell cols="3">1.1 6.4 9849.4 126.6 565.9</cell></row><row><cell cols="2">Peregrine</cell><cell cols="3">1.6 7.3 8492.4 100.3 3640.9</cell></row><row><cell></cell><cell>GAP</cell><cell>0.3 2.7</cell><cell cols="2">65.8 77.0</cell><cell>48.1</cell></row><row><cell cols="3">Sandslash-Hi 0.3 1.8</cell><cell cols="2">57.2 44.9</cell><cell>24.5</cell></row><row><cell></cell><cell></cell><cell>4-CL</cell><cell></cell><cell>5-CL</cell></row><row><cell></cell><cell cols="3">Lj Or Tw4 Fr</cell><cell>Uk</cell><cell>Lj Or</cell><cell>Fr</cell></row><row><cell>Pangolin</cell><cell>19.5 56.6</cell><cell cols="2">TO 564.1</cell><cell>TO 970.4 223.4 1704.4</cell></row><row><cell>AutoMine</cell><cell cols="4">11.0 32.9 67168.4 209.6 44666.6 575.6 170.1 389.0</cell></row><row><cell>Peregrine</cell><cell>15.9 73.7</cell><cell cols="3">TO 397.3 55808.4 520.8 782.1 957.6</cell></row><row><cell>kClist</cell><cell cols="4">1.2 2.5 1174.0 84.0 OOM 22.3 5.8 87.5</cell></row><row><cell cols="5">Sandslash-Hi 0.6 2.4 1676.8 166.2 2481.2 13.9 7.4 194.9</cell></row><row><cell cols="5">Sandslash-Lo 0.7 1.9 681.8 60.4 2451.7 14.2 4.8 64.3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 6 .</head><label>6</label><figDesc>ğ‘˜-CL execution time (sec) (OOM: out of memory; TO: timed out).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 7 .</head><label>7</label><figDesc>ğ‘˜-MC execution time (sec) (OOM: out of memory; TO: timed</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>3-MC</cell><cell></cell><cell></cell><cell>4-MC</cell></row><row><cell></cell><cell cols="2">Lj Or</cell><cell>Tw4</cell><cell>Fr</cell><cell>Uk</cell><cell>Lj</cell><cell>Or</cell></row><row><cell>Pangolin</cell><cell cols="2">10.8 96.5</cell><cell cols="3">TO 2460.1 23676.6</cell><cell>TO</cell><cell>TO</cell></row><row><cell>AutoMine</cell><cell cols="7">3.1 18.2 48901.7 352.8 4051.0 15529.7 90914.5</cell></row><row><cell>Peregrine</cell><cell cols="5">2.5 4.9 8447.4 165.3 3571.5</cell><cell cols="2">163.6 1701.4</cell></row><row><cell>PGD</cell><cell cols="5">11.2 42.5 OOM OOM OOM</cell><cell cols="2">192.8 4069.6</cell></row><row><cell cols="3">Sandslash-Hi 2.1 12.1</cell><cell cols="5">TO 723.7 4979.1 2366.2 30394.7</cell></row><row><cell cols="6">Sandslash-Lo 0.3 1.6 304.6 43.8 386.8</cell><cell cols="2">16.7 232.4</cell></row><row><cell>out).</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">diamond</cell><cell></cell><cell></cell><cell>4-cycle</cell></row><row><cell></cell><cell>Lj</cell><cell>Or</cell><cell>Tw4</cell><cell>Fr</cell><cell>Lj</cell><cell>Or</cell><cell>Fr</cell></row><row><cell>Pangolin</cell><cell cols="2">92.3 884.5</cell><cell cols="4">TO 9301.6 553.5 13208.2</cell><cell>TO</cell></row><row><cell>Peregrine</cell><cell cols="7">5.4 10.2 20898.4 178.1 144.4 1867.2 32276.8</cell></row><row><cell cols="5">Sandslash-Hi 1.5 4.2 44659.5 284.2</cell><cell>6.3</cell><cell cols="2">79.0 20490.9</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 8 .</head><label>8</label><figDesc>Execution time (sec) of SL.explain this in detail in Section 6.3. On average, Sandslash-Lo outperforms AutoMine, Pangolin, Peregrine, and kClist by 21.0Ã—, 35.1Ã—, 31.1Ã—, and 1.4Ã— respectively, for ğ‘˜-CL. ğ‘˜-Motif Counting (ğ‘˜-MC): Table7compares ğ‘˜-MC performance. Sandslash-Hi outperforms AutoMine due to symmetry breaking, and Sandslash-Lo is orders of magnitude faster than Sandslash-Hi due to the local counting optimization. Table8presents SL results (Au-toMine is omitted since it has vertex-induced subgraph counting, not SL). Sandslash outperforms all other systems, except Peregrine for the diamond pattern on Lj and Fr, which is probably because it reorders vertices during preprocessing. Pangolin on the other hand is much slower than the other systems as it does not support memoization of neighborhood connectivity (MNC) optimization. The MNC approach in Sandslash is more efficient than the vertex set buffering (VSB) in Peregrine as explained in Section 4.3: Peregrine must do neighborhood intersections to determine connectivity while Sandslash does not. On average, Sandslash outperforms Pangolin and Peregrine by 29.5Ã— and 5.6Ã— respectively.Conference'17, July 2017, Washington, DC, USAXuhao Chen, Roshan Dathathri, Gurbinder Gill, Loc Hoang, Keshav Pingali</figDesc><table><row><cell>Pangolin is particularly inefficient for 4-MC as it cannot</cell></row><row><cell>memoize neighborhood connectivity (MNC). Sandslash-Hi</cell></row><row><cell>and Sandslash-Lo count all patterns simultaneously, whereas</cell></row><row><cell>Peregrine does counting for each pattern/motif one by one,</cell></row><row><cell>which allows it apply optimizations for each pattern. Un-</cell></row><row><cell>like Sandslash, Peregrine reorders vertices during prepro-</cell></row><row><cell>cessing. Peregrine is faster than Sandslash-Hi likely due to</cell></row><row><cell>these reasons. Sandslash-Lo is faster than Peregrine due to</cell></row><row><cell>the formula-based local counting optimization, which can-</cell></row><row><cell>not be supported in the Peregrine API. All optimizations in</cell></row><row><cell>expert-implemented PGD [3] are enabled in Sandslash-Lo.</cell></row><row><cell>Sandslash-Lo outperforms PGD because PGD does not apply</cell></row><row><cell>symmetry breaking and has much larger enumeration space.</cell></row><row><cell>On average, Sandslash-Lo outperforms AutoMine, Pangolin,</cell></row><row><cell>Peregrine, and PGD by 27.2Ã—, 53.6Ã—, 8.6Ã— and 17.9Ã—, respec-</cell></row><row><cell>tively.</cell></row><row><cell>Subgraph Listing (SL):</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 9 .</head><label>9</label><figDesc>Execution time (sec) of ğ‘˜-FSM:-ğœ ğ‘šğ‘–ğ‘› : minimum support (OOM: out of memory; TO: timed out).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>, lightly colored subgraphs are removed by automorphism checks, leaving a unique canonical subgraph for each set of automorphisms. Automorphism checks are 1 // initialize the local graph by computing the 2 // intersection of v 's neighbors and u 's neighbors , 3 // where v is the start vertex , u is a neighbor of v 's. 4 void initLG ( Graph gg , Vertex v , Graph lg ) {</figDesc><table><row><cell>5</cell><cell>for ( u : gg . adjList ( v ) )</cell></row><row><cell>6</cell><cell>lg . insertVertex ( u ) ; // insert vertex u to the local</cell></row><row><cell></cell><cell>graph</cell></row><row><cell>7</cell><cell>// the system maintains the global to local ID mapping</cell></row><row><cell>8</cell><cell>for ( u : gg . adjList ( v ) )</cell></row><row><cell>9</cell><cell>for ( w : ( gg . adjList ( u ) &amp; gg . adjList ( v ) ) )</cell></row><row><cell>10</cell><cell>lg . insertEdge (u , w ) ; // insert edge (u , w) to</cell></row><row><cell></cell><cell>local graph</cell></row><row><cell>11 }</cell><cell></cell></row><row><cell cols="2">12 // update the local graph by removing vertices not in</cell></row><row><cell cols="2">13 // the newly generated embedding list</cell></row><row><cell cols="2">14 void updateLG ( int depth , Graph lg ) {</cell></row><row><cell>15</cell><cell>// for each vertex in the new embedding list</cell></row><row><cell>16</cell><cell>for ( u : this -&gt; emb_list [ depth +1]) {</cell></row><row><cell>17</cell><cell>// get the size of the old adjList</cell></row><row><cell>18</cell><cell>int degree = lg . getDegree ( depth , u ) ;</cell></row><row><cell>19</cell><cell>int idx = lg . edgeStart ( u ) ;</cell></row><row><cell>20</cell><cell>int tail = eid + degree ;</cell></row><row><cell>21</cell><cell>// set the size of the new adjList to 0</cell></row><row><cell>22</cell><cell>lg . setDegree ( depth +1 , u , 0) ;</cell></row><row><cell>23</cell><cell>// traverse the neighbors of u</cell></row><row><cell>24</cell><cell>for ( w : lg . adjList ( u ) ) {</cell></row><row><cell>25</cell><cell>// if w is in the new embedding list</cell></row><row><cell>26</cell><cell>if ( this -&gt; emb_list [ depth +1]. contains ( w ) ) {</cell></row><row><cell>27</cell><cell>// w remains in the new adjList of u</cell></row><row><cell>28</cell><cell>// size of u 's new adjList increases by 1</cell></row><row><cell>29</cell><cell>lg . incDegree ( depth +1 , u ) ;</cell></row><row><cell>30</cell><cell>} else {</cell></row><row><cell>31</cell><cell>// remove w by swap it with</cell></row><row><cell>32</cell><cell>// the vertex at the tail of the old adjList</cell></row><row><cell>33</cell><cell>lg . insertAdj ( idx --, lg . getEdgeDst ( tail --) ;</cell></row><row><cell>34</cell><cell>lg . insertAdj ( tail , w ) ;</cell></row><row><cell>35</cell><cell>}</cell></row><row><cell>36</cell><cell>idx ++;</cell></row><row><cell>37</cell><cell>}</cell></row><row><cell>38</cell><cell>}</cell></row><row><cell>39 }</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0">These GPM systems are orders of magnitude faster than previous GPM systems such as Arabesque<ref type="bibr" target="#b53">[54]</ref>, RStream<ref type="bibr" target="#b55">[56]</ref>, G-Miner<ref type="bibr" target="#b10">[11]</ref>, and Fractal<ref type="bibr" target="#b18">[19]</ref>.</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Emptyheaded: A relational engine for graph processing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Christopher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Aberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andres</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kunle</forename><surname>NÃ¶tzli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Olukotun</surname></persName>
		</author>
		<author>
			<persName><surname>RÃ©</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2017-10">October 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Managing and Mining Graph Data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Charu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Springer US</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient graphlet counting for large networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nesreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><forename type="middle">A</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><surname>Duffield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Biomolecular network motif counting and discovery by color coding</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hajirasouliha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hormozdiari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Sahinalp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="241" to="249" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The GAP benchmark suite</title>
		<author>
			<persName><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<idno>CoRR, abs/1508.03619</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Higher-order organization of complex networks</title>
		<author>
			<persName><forename type="first">Austin</forename><forename type="middle">R</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">F</forename><surname>Gleich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">353</biblScope>
			<biblScope unit="issue">6295</biblScope>
			<biblScope unit="page" from="163" to="166" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">CECI: Compact Embedding Cluster Index for Scalable Subgraph Matching</title>
		<author>
			<persName><forename type="first">Bibek</forename><surname>Bhattarai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, SIGMOD &apos;19</title>
				<meeting>the 2019 International Conference on Management of Data, SIGMOD &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1447" to="1462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient subgraph matching by postponing cartesian products</title>
		<author>
			<persName><forename type="first">Fei</forename><surname>Bi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenjie</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, SIGMOD &apos;16</title>
				<meeting>the 2016 International Conference on Management of Data, SIGMOD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1199" to="1214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A large timeaware graph</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Santini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGIR Forum</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="33" to="38" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The WebGraph framework I: Compression techniques</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Thirteenth International World Wide Web Conference (WWW 2004)</title>
				<meeting>of the Thirteenth International World Wide Web Conference (WWW 2004)<address><addrLine>Manhattan, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="595" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">G-miner: An efficient task-oriented graph mining system</title>
		<author>
			<persName><forename type="first">Hongzhi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunjian</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Da</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth EuroSys Conference, EuroSys &apos;18</title>
				<meeting>the Thirteenth EuroSys Conference, EuroSys &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Pangolin: An efficient and flexible graph mining system on cpu and gpu</title>
		<author>
			<persName><forename type="first">Xuhao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2020-08">August 2020</date>
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Dataset for statistics and social network of youtube videos</title>
		<author>
			<persName><forename type="first">X</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="http://netsg.cs.sfu.ca/youtubedata/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Arboricity and subgraph listing algorithms</title>
		<author>
			<persName><forename type="first">Norishige</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takao</forename><surname>Nishizeki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="210" to="223" />
			<date type="published" when="1985-02">February 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Predicting protein function by frequent functional association pattern mining in protein interaction networks</title>
		<author>
			<persName><forename type="first">Young-Rae</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidong</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Info. Tech. Biomed</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="36" />
			<date type="published" when="2010-01">January 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Listing k-cliques in sparse real-world graphs*</title>
		<author>
			<persName><forename type="first">Maximilien</forename><surname>Danisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oana</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauro</forename><surname>Sozio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 World Wide Web Conference, WWW &apos;18</title>
				<meeting>the 2018 World Wide Web Conference, WWW &apos;18<address><addrLine>Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="589" to="598" />
		</imprint>
	</monogr>
	<note>International World Wide Web Conferences Steering Committee</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Frequent substructure-based approaches for classifying chemical compounds</title>
		<author>
			<persName><forename type="first">M</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuramochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1036" to="1050" />
			<date type="published" when="2005-08">Aug 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Theoretically efficient parallel graph algorithms can be fast and scalable</title>
		<author>
			<persName><forename type="first">Laxman</forename><surname>Dhulipala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th on Symposium on Parallelism in Algorithms and Architectures, SPAA &apos;18</title>
				<meeting>the 30th on Symposium on Parallelism in Algorithms and Architectures, SPAA &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="393" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fractal: A general-purpose graph pattern mining system</title>
		<author>
			<persName><forename type="first">Vinicius</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><forename type="middle">H C</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dorgival</forename><surname>Guedes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meira</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, SIGMOD &apos;19</title>
				<meeting>the 2019 International Conference on Management of Data, SIGMOD &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1357" to="1374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A puzzle concerning triads in social networks: Graph constraints and the triad census</title>
		<author>
			<persName><forename type="first">Katherine</forename><surname>Faust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="233" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Matching structure and semantics: A survey on graph-based pattern matching</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Fall Symposium: Capturing and Using Patterns for Evidence Detection</title>
				<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">PDTL: Parallel and distributed triangle listing for massive graphs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Giechaskiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Panagopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yoneki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 44th International Conference on Parallel Processing</title>
				<imprint>
			<date type="published" when="2015-09">Sep. 2015</date>
			<biblScope unit="page" from="370" to="379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Network motif discovery using subgraph enumeration and symmetry-breaking</title>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">A</forename><surname>Grochow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Kellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Annual International Conference on Research in Computational Molecular Biology, RECOMB&apos;07</title>
				<meeting>the 11th Annual International Conference on Research in Computational Molecular Biology, RECOMB&apos;07<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="92" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The NBER patent citation data file: Lessons, insights and methodological tools</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Jaffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Trajtenberg</surname></persName>
		</author>
		<ptr target="http://www.nber.org/patents/" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Graph theory. Addison-Wesley series in mathematics</title>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<publisher>Addison-Wesley Pub. Co</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">DistTC: High performance distributed triangle counting</title>
		<author>
			<persName><forename type="first">Loc</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vishwesh</forename><surname>Jatala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuhao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Udit</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPEC 2019 23rd IEEE High Performance Extreme Computing</title>
				<imprint>
			<date type="published" when="2019-09">September 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Tricore: Parallel triangle counting on gpus</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC18: International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<imprint>
			<date type="published" when="2018-11">Nov 2018</date>
			<biblScope unit="page" from="171" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The power of pivoting for exact clique counting</title>
		<author>
			<persName><forename type="first">Shweta</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seshadhri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Web Search and Data Mining, WSDM &apos;20</title>
				<meeting>the 13th International Conference on Web Search and Data Mining, WSDM &apos;20<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="268" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Peregrine: A pattern-aware graph mining system</title>
		<author>
			<persName><forename type="first">Kasra</forename><surname>Jamshidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Mahadasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth EuroSys Conference, EuroSys &apos;20</title>
				<meeting>the Fifteenth EuroSys Conference, EuroSys &apos;20</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Path sampling: A fast and provable method for estimating 4-vertex subgraph counts</title>
		<author>
			<persName><forename type="first">Madhav</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seshadhri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Pinar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on World Wide Web, WWW &apos;15</title>
				<meeting>the 24th International Conference on World Wide Web, WWW &apos;15<address><addrLine>Republic and Canton of Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="495" to="505" />
		</imprint>
	</monogr>
	<note>International World Wide Web Conferences Steering Committee</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Graphflow: An active graph database</title>
		<author>
			<persName><forename type="first">Chathura</forename><surname>Kankanamge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><surname>Sahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedbhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD &apos;17</title>
				<meeting>the 2017 ACM International Conference on Management of Data, SIGMOD &apos;17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1695" to="1698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">DUALSIM: Parallel subgraph enumeration in a massive graph on a single machine</title>
		<author>
			<persName><forename type="first">Hyeonji</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juneyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sourav</forename><forename type="middle">S</forename><surname>Bhowmick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeonghoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seongyun</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Moath</surname></persName>
		</author>
		<author>
			<persName><surname>Jarrah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, SIGMOD &apos;16</title>
				<meeting>the 2016 International Conference on Management of Data, SIGMOD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1231" to="1245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Turboflux: A fast continuous subgraph matching system for streaming graph data</title>
		<author>
			<persName><forename type="first">Kyoungmin</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">In</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeong-Hoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyungyu</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geonhwa</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data, SIGMOD &apos;18</title>
				<meeting>the 2018 International Conference on Management of Data, SIGMOD &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="411" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">What is twitter, a social network or a news media?</title>
		<author>
			<persName><forename type="first">Haewoon</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changhyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hosung</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sue</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on World Wide Web, WWW &apos;10</title>
				<meeting>the 19th International Conference on World Wide Web, WWW &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="591" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Scalable subgraph enumeration in mapreduce</title>
		<author>
			<persName><forename type="first">Longbin</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2015-06">June 2015</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="974" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<title level="m">Snap: Stanford network analysis platform</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Distributed graph pattern matching</title>
		<author>
			<persName><forename type="first">Shuai</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinpeng</forename><surname>Huai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tianyu</forename><surname>Wo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on World Wide Web, WWW &apos;12</title>
				<meeting>the 21st International Conference on World Wide Web, WWW &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="949" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Graphzero: Breaking symmetry for efficient graph mining</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Reinehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Connor</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tongping</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Automine: Harmonizing high-level abstraction and high performance for graph mining</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM Symposium on Operating Systems Principles, SOSP &apos;19</title>
				<meeting>the 27th ACM Symposium on Operating Systems Principles, SOSP &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="509" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Optimizing subgraph queries by combining binary and worst-case optimal joins</title>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedhbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2019-07">July 2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1692" to="1704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Network motifs: Simple building blocks of complex networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shen-Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Itzkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashtan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chklovskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Alon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">298</biblScope>
			<biblScope unit="issue">5594</biblScope>
			<biblScope unit="page" from="824" to="827" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A lightweight infrastructure for graph analytics</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Symposium on Operating Systems Principles (SOSP), SOSP &apos;13</title>
				<meeting>the 24th ACM Symposium on Operating Systems Principles (SOSP), SOSP &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="456" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">H-index: Hash-indexing for parallel triangle counting on gpus</title>
		<author>
			<persName><forename type="first">Santosh</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaoye</forename><forename type="middle">Sherry</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aydin</forename><surname>Buluc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiejun</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hang</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE High Performance Extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019-09">Sep. 2019</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">One quadrillion triangles queried on one million processors</title>
		<author>
			<persName><forename type="first">Roger</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Steil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">W</forename><surname>Priest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE High Performance Extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Escape: Efficiently counting all 5-vertex subgraphs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ali Pinar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vaidyanathan</forename><surname>Seshadhri</surname></persName>
		</author>
		<author>
			<persName><surname>Vishal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on World Wide Web, WWW &apos;17</title>
				<meeting>the 26th International Conference on World Wide Web, WWW &apos;17<address><addrLine>Republic and Canton of Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1431" to="1440" />
		</imprint>
	</monogr>
	<note>International World Wide Web Conferences Steering Committee</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Fast and robust distributed subgraph enumeration</title>
		<author>
			<persName><forename type="first">Xuguang</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junhu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wook-Shin</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1344" to="1356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Parallel subgraph listing in a large-scale graph</title>
		<author>
			<persName><forename type="first">Yingxia</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junjie</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ning</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;14</title>
				<meeting>the 2014 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="625" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Multicore triangle computations without tuning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tangwongsan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 31st International Conference on Data Engineering</title>
				<imprint>
			<date type="published" when="2015-04">April 2015</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Efficient parallel subgraph enumeration on a single machine</title>
		<author>
			<persName><forename type="first">Shixuan</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yulin</forename><surname>Che</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lipeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiong</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE 35th International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="232" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Scaling up subgraph query processing with efficient subgraph matching</title>
		<author>
			<persName><forename type="first">Shixuan</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiong</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE 35th International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="220" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Counting triangles and the curse of the last reducer</title>
		<author>
			<persName><forename type="first">Siddharth</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergei</forename><surname>Vassilvitskii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on World Wide Web, WWW &apos;11</title>
				<meeting>the 20th International Conference on World Wide Web, WWW &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="607" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A distributed approach for graph mining in massive networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Min. Knowl. Discov</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1024" to="1052" />
			<date type="published" when="2016-09">September 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Parallel graph mining with dynamic load balancing</title>
		<author>
			<persName><forename type="first">N</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE International Conference on Big Data (Big Data)</title>
				<imprint>
			<date type="published" when="2016-12">Dec 2016</date>
			<biblScope unit="page" from="3352" to="3359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Arabesque: A system for distributed graph mining</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Carlos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><forename type="middle">J</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgos</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammed</forename><forename type="middle">J</forename><surname>Siganos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP &apos;15</title>
				<meeting>the 25th Symposium on Operating Systems Principles, SOSP &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="425" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">An algorithm for subgraph isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="42" />
			<date type="published" when="1976-01">January 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Rstream: Marrying relational algebra with streaming for efficient graph mining on a single machine</title>
		<author>
			<persName><forename type="first">Kai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiqiang</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Thorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><forename type="middle">Quang</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoqing</forename><forename type="middle">Harry</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;18</title>
				<meeting>the 12th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;18<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="763" to="782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Fast linear algebra-based triangle counting with kokkoskernels</title>
		<author>
			<persName><forename type="first">Mehmet</forename><surname>Michael M Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><forename type="middle">W</forename><surname>Deveci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">D</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sivasankaran</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName><surname>Rajamanickam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE High Performance Extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">gspan: graph-based substructure pattern mining</title>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE International Conference on Data Mining</title>
				<meeting>the 2002 IEEE International Conference on Data Mining</meeting>
		<imprint>
			<date type="published" when="2002-12">Dec 2002</date>
			<biblScope unit="page" from="721" to="724" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Defining and evaluating network communities based on ground-truth</title>
		<author>
			<persName><forename type="first">Jaewon</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<idno>CoRR, abs/1205.6233</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Fast triangle counting using cilk</title>
		<author>
			<persName><forename type="first">Abdurrahman</forename><surname>YaÅŸar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sivasankaran</forename><surname>Rajamanickam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ãœmit</forename><forename type="middle">V</forename><surname>Ã‡atalyÃ¼rek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE High Performance extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Kaleido: An Efficient Out-of-core Graph Mining System on A Single Machine</title>
		<author>
			<persName><forename type="first">Cheng</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhibin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tianqi</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiafeng</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2020 IEEE International Conference on Data Engineering (ICDE 2020), ICDE &apos;20</title>
				<meeting>the 2020 IEEE International Conference on Data Engineering (ICDE 2020), ICDE &apos;20</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m">20 } 21 Pattern p0 = generateClique</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title level="m">Pattern p1 = generateCycle</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m">Set &lt; Pattern &gt; patterns ({ p0 , p1 })</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title/>
		<author>
			<persName><surname>Map &lt; Pattern</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Support &gt; support_map = enumerate ( patterns</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
