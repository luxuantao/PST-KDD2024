<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TRANSIT: Specifying Protocols with Concolic Snippets *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Abhishek</forename><surname>Udupa</surname></persName>
							<email>audupa@cis.upenn.edu</email>
						</author>
						<author>
							<persName><forename type="first">Arun</forename><surname>Raghavan</surname></persName>
							<email>arraghav@cis.upenn.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jyotirmoy</forename><forename type="middle">V</forename><surname>Deshmukh</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sela</forename><surname>Mador-Haim</surname></persName>
							<email>selama@cis.upenn.edu</email>
						</author>
						<author>
							<persName><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
							<email>milom@cis.upenn.edu</email>
						</author>
						<author>
							<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
							<email>alur@cis.upenn.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Toyota Technical Center</orgName>
								<address>
									<settlement>Gardena</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">TRANSIT: Specifying Protocols with Concolic Snippets *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B2853979DB13C2E0DAE93185414788A4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1 [Programming Techniques]: Automatic Programming</term>
					<term>D.2.2 [Design Tools and Techniques]: Computer-aided Software Engineering</term>
					<term>D.2.4 [Software Verification]: Model Checking Program Synthesis</term>
					<term>Distributed Protocol Synthesis</term>
					<term>Cache Coherence Protocols</term>
					<term>Programming by Example</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>With the maturing of technology for model checking and constraint solving, there is an emerging opportunity to develop programming tools that can transform the way systems are specified. In this paper, we propose a new way to program distributed protocols using concolic snippets. Concolic snippets are sample execution fragments that contain both concrete and symbolic values. The proposed approach allows the programmer to describe the desired system partially using the traditional model of communicating extended finite-state-machines (EFSM), along with high-level invariants and concrete execution fragments. Our synthesis engine completes an EFSM skeleton by inferring guards and updates from the given fragments which is then automatically analyzed using a model checker with respect to the desired invariants. The counterexamples produced by the model checker can then be used by the programmer to add new concrete execution fragments that describe the correct behavior in the specific scenario corresponding to the counterexample.</p><p>We describe TRANSIT, a language and prototype implementation of the proposed specification methodology for distributed protocols. Experimental evaluations of TRANSIT to specify cache coherence protocols show that (1) the algorithm for expression inference from concolic snippets can synthesize expressions of size 15 involving typical operators over commonly occurring types, (2) for a classical directory-based protocol, TRANSIT automatically generates, in a few seconds, a complete implementation from a specification consisting of the EFSM structure and a few concrete examples for every transition, and (3) a published partial description of the SGI Origin cache coherence protocol maps directly to symbolic examples and leads to a complete implementation in a few iterations, with the programmer correcting counterexamples resulting from underspecified transitions by adding concrete examples in each iteration.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Over the last few decades, technology for program analysis, model checking, and software verification has matured, and has witnessed growing adoption in industry. However, verification tools have largely been confined to discovering bugs in systems that have already been designed. This raises the question: how can we leverage the advances in analysis tools to assist programmers, during the program development phase, in an interactive manner? In this paper, we propose a methodology for programming distributed protocols, in which a programmer can express the intended design using multiple formats, which a synthesis tool then integrates into an executable implementation. Our approach is inspired by recent work on sketching and on programming by examples. In sketching, a programmer writes a partial program with incomplete details, and a synthesizer then fills in the missing details based on userspecified assertions <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref> (see also <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b25">26]</ref>). With this approach, the programmer can continue to use the familiar imperative style of programming, but can use the synthesis tool to find intricate details necessary for fine-tuning code by supplying a few high-level invariants. In programming by examples, the programmer expresses the desired behavior using a set of example input/output traces, and the synthesis tool constructs an executable implementation consistent with these examples. This has been shown to be an intuitive and effective style for programming finite-state reactive controllers <ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref>, Excel macros performing string manipulations <ref type="bibr" target="#b6">[7]</ref>, and pointer-manipulations for updating data structures <ref type="bibr" target="#b21">[22]</ref>.</p><p>This paper focuses on programming reactive systems such as distributed protocols. For such protocols, although the core algorithms are published with accompanying correctness proofs and performance analyses, these descriptions typically do not specify every detail, and translating them into a correct working implementation is challenging due to corner cases arising from asynchrony and concurrency <ref type="bibr" target="#b1">[2]</ref>. A distributed protocol is typically described by listing the set of processes participating in the protocol, the set of channels connecting the processes, the types of messages each channel can carry, and the descriptions of individual processes given as extended finite-state-machines (EFSMs). An EFSM description consists of a list of internal state variables, a set of control states, and a set of transitions connecting control states. Each transition is specified by a guard condition and update code that refer to the internal state variables and fields of incoming and outgoing messages. This style of specifying distributed protocols is common in standardized descriptions of network protocols as RFCs, rigorous textbook descriptions of distributed algorithms <ref type="bibr" target="#b16">[17]</ref>, modeling languages supported by formal verification tools such as SPIN <ref type="bibr" target="#b11">[12]</ref> and Murϕ <ref type="bibr" target="#b4">[5]</ref>, and domain-specific languages such as SLICC <ref type="bibr" target="#b17">[18]</ref>. The traditional programming style requires the programmer to fill in every detail of every transition, and our goal is to offer programmer assistance with this tedious and error-prone task.</p><p>Using the proposed language, TRANSIT, a programmer describes the communication architecture of a distributed protocol Figure <ref type="figure">1</ref>. Design methodology using concolic snippets by listing the set of processes, the set of channels connecting them, the types of messages each channel can carry, and the EFSM skeleton for each process by listing control states and internal state variables. TRANSIT also allows behavioral specification of each process using concolic snippets, which are fragments of desired execution that contain conditional updates to variables using both concrete and symbolic values (the term "concolic" was coined in the context of testing programs using both concrete and symbolic inputs <ref type="bibr" target="#b19">[20]</ref>). This approach offers the programmer the flexibility to either describe each EFSM transition in the traditional way using symbolic expressions for guards and updates, or to specify only representative examples of such transitions. The TRANSIT synthesis tool then generates a complete protocol by inferring guards and update actions that are consistent with the specified snippets. The programmer also specifies high-level temporal invariants which the protocol needs to satisfy. A finite instance of the synthesized protocol is then checked against these invariants using a model checker. The programmer debugs any reported counterexamples with a visualizer and adds more snippets to rule out erroneous behaviors. Figure <ref type="figure">1</ref> illustrates the proposed methodology.</p><p>The main computational problem in our approach is to infer an expression to be used in a guard or an update appearing in an EFSM transition that is (1) built in a type-consistent manner using the specified vocabulary of function symbols and variables, and (2) is consistent with the given set of concrete and symbolic examples. Our solution is a variant of the counterexample-guided inductive synthesis (CEGIS) approach <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23]</ref>, and involves an interplay between pruning based on concrete examples and concretization of symbolic examples using an SMT solver. Specifically, our implementation enumerates expressions of increasing sizes, where the space of expressions is pruned significantly by considering two expressions equivalent if they evaluate to the same values for the given concrete examples. This results in an expression that is consistent with all the concrete examples. This expression is then checked for consistency with respect to the symbolic examples using an SMT solver. If the consistency check succeeds, then the expression is the desired answer. If it fails, the evidence for inconsistency returned by the solver contributes to a concrete example, which is considered in subsequent iterations.</p><p>The TRANSIT prototype implementation invokes the SMT solver Z3 <ref type="bibr" target="#b18">[19]</ref> and the model checker Murϕ <ref type="bibr" target="#b4">[5]</ref>. To evaluate the algorithm for inferring an expression from concolic examples, we consider a vocabulary of the common operations on Booleans, integers, and bounded sets. The algorithm can infer expressions with a size of 15 symbols within a few minutes.</p><p>To evaluate the feasibility of the proposed methodology, we focus on cache coherence protocols, a class representative of distributed protocols. We performed two case studies where students with no experience with coherence protocols used the TRANSIT prototype to program two canonical cache coherence protocols from textbook descriptions using concolic examples <ref type="bibr" target="#b24">[25]</ref>. Both case studies resulted in generating protocols that were successfully checked by the model checker. We found that: (1) the final, correctly generated protocol typically required one or two concrete snippets per transition, (2) synthesizing the protocol from snippets took only a few seconds, and (3) the entire iterative protocol development required a few hours of manual effort for either case study.</p><p>In our final case study, we used TRANSIT to specify the industrial-strength SGI Origin protocol. The published description <ref type="bibr" target="#b15">[16]</ref> was directly mapped to symbolic snippets corresponding to typical transitions. However, as the published prose is not a complete specification, it results in an implementation that violates coherence invariants during the model-checking phase. Because the counterexamples produced by the model checker correspond to concrete executions, our methodology allowed the programmer to augment the original description with concrete fixes to these violating traces, culminating in a correct implementation of the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Illustrative Examples of Our Approach</head><p>We illustrate the use of TRANSIT using cache coherence protocols as an example application. Such protocols maintain a coherent view of shared memory among threads running in multi-core and multi-socket systems. Although programmers view memory as a single data store, most systems incorporate private per-core caches to reduce access latency. Coherence protocols prevent threads from reading stale data from caches by ensuring that reads to memory locations (addresses) receive the last value written to that location by any thread. Coherence is conventionally enforced using mutually exclusive read/write permissions: either multiple processors may simultaneously cache an address with read permissions (i.e., shared readers) or a single processor may cache that address with read/write permissions (i.e., exclusive writer). Although several different hardware and software approaches exist, this paper focuses on invalidation-based directory hardware implementations. In such a system, processors issue requests to a central directory which tracks the current permissions of each cache. On receiving a request for write permission, the directory issues invalidation messages to all caches that hold a valid copy (read or write permissions) and gathers acknowledgments from these caches before granting write permissions to the requester. Similarly, the directory redirects read requests to the last writer to that address (tracked as the "owner" in the directory) to ensure that valid data is transferred to the requesting processor.</p><p>As with existing approaches for modeling protocols using state machines, TRANSIT views the protocol in terms of a well defined structure (referred to as the protocol skeleton) and its behavioral description.</p><p>Protocol skeleton. A protocol description usually includes the high-level structural description of the desired protocol. For example, from Chapter 8 of the coherence primer <ref type="bibr" target="#b24">[25]</ref>, the specification would include: (1) Processes: a distinguished EFSM called the Directory and one EFSM per cache controller. (2) Communication architecture: three networks that the EFSMs use to send/receive messages, including any ordering guarantees. (3) Message types: such as Get and Data that may be carried on specific networks (for instance, the Response network can only carry Data and Inv-Ack message types). (4) Control states of each EFSM: such as M, S and I for the directory EFSM. <ref type="bibr" target="#b4">(5)</ref> Internal variables for each EFSM: such as Sharers in directory, which is used to track the list of cache processes with a valid copy of data. The above protocol skeleton is usually expressed as type declarations and variable definitions in existing approaches. The programmer specifies the protocol skeleton similarly in the proposed approach as well.</p><p>Traditional behavioral description. Having set up the above structure, a protocol implementation next requires the behavioral specification of the EFSMs. Protocol designers typically describe behavior in terms of example flows <ref type="bibr" target="#b26">[27]</ref> or interaction of processes when they exchange messages, triggering events and consequent actions. These descriptions are commonly expressed and communicated informally (using visual aids like example state diagrams and message sequence charts, or listing case-by-case actions textually) both in industrial protocols as well as in academic literature <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b24">25]</ref>. Such informal descriptions can completely specify relatively straightforward protocols like the textbook MSI example <ref type="bibr" target="#b24">[25]</ref>. In these cases, the programming task is largely to infer and symbolically codify the semantics implied by the examples. For more complex protocols, the informal descriptions convey salient features, like common-case behavior and perhaps some of the more interesting scenarios that might arise (usually in terms of rules). Implementing such protocols involves the additional step of filling in any unspecified details. However, it has been shown that this approach to implementing complete protocols symbolically as a program can be error-prone even for experts, with bugs manifesting even in released processors <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. Specifying behavior with snippets. We observe that the complexity in protocols does not usually stem from the code for individual transitions -these tend to be straight line code. The complexity is due to corner cases and race conditions arising from concurrency and asynchrony when protocols are considered in their entirety <ref type="bibr" target="#b1">[2]</ref>. Using a concolic approach allows the programmer to mix symbolic snippets (transition code) describing well-defined behavior (like rules or state machine transitions) with concrete snippets describing specific example scenarios.</p><p>The TRANSIT tool composes the given concrete and symbolic snippets to generate an implementation which allows at least all the behaviors described in the input snippets. This implementation is then model checked for coherence invariants. Any underspecification or error in the specification of the EFSM behavior will result in a counterexample during model checking, which the programmer can then fix using concrete snippets to prevent subsequent occurrences of at least that specific violation. Example using concolic snippets. We illustrate this mixed (or concolic) use of TRANSIT with an anecdote from our case study in implementing the SGI Origin protocol from published informal textual rules <ref type="bibr" target="#b15">[16]</ref> (Section 6 contains more details on this case study, and using TRANSIT with concolic snippets to implement protocols which are completely specified). The protocol skeleton states that the directory EFSM has variables Sharers and Owner to maintain its internal state. One of the rules in the paper describes the behavior of a directory upon a read request from a cache as: "If directory state is Exclusive with another owner, transitions to Busy-shared with requester as owner and send out an intervention shared request to the previous owner and a speculative reply to the requester. Go to 5b". Note that this description does not specify how the Sharers process variable in the directory EFSM needs to be updated. The programmer indicated that if the sender of the message was not the previous Owner, the value of the Sharers variable needs to contain at least the sender of the received message in addition to the old value of the Sharers variable. Based on this specification, TRANSIT generated the code:</p><formula xml:id="formula_0">Sharers := Sharers ∪ {Msg.Sender}</formula><p>However, an attempt to verify the generated implementation using Murϕ resulted in a coherence violation. TRANSIT provided a visual trace of the counterexample to the programmer, a simplified version of which is shown in Figure <ref type="figure">2</ref>. Observe that the transition on the directory shown in Figure <ref type="figure">2</ref>   the scenario described earlier, where Msg.Sender is Cache2 and the Owner variable is initially set to Cache1. Upon inspecting the trace, the programmer recognized that in this particular scenario, with Sharers needed to include the previous value of the Owner as well. After a concrete snippet specifying this specific conditional update was added, TRANSIT then generated a new implementation including the correct update to Sharers as:</p><formula xml:id="formula_1">Sharers := Sharers ∪ {Msg.Sender, Owner}</formula><p>This example illustrates how a programmer can benefit from using the concolic nature of TRANSIT. TRANSIT allows the programmer to combine the familiar symbolic programming style for specifying the protocol skeleton and well-understood behavior. TRAN-SIT also makes it convenient to fix bugs with concrete execution fragments that describe the desired outcome in the particular scenario where the bug manifests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Protocol Specification using Concolic Snippets</head><p>A protocol implementation results in transition code for communicating EFSMs. Figure <ref type="figure">3</ref> shows the EFSM for a directory process in a cache coherence protocol. TRANSIT borrows from traditional software <ref type="bibr" target="#b17">[18]</ref> and hardware <ref type="bibr" target="#b3">[4]</ref> protocol description languages to specify the protocol skeleton (i.e., types and variable definitions) and transitions (using a guarded command language). However, TRANSIT offers the additional ability to mix concrete and symbolic transitions as snippets, and to under-specify elements of transitions for the tool to infer. We now describe how to specify a protocol using TRANSIT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">High-level Building Blocks of TRANSIT</head><p>Coherence protocols typically assume an asynchronous, messagepassing based model of communication. Each process description includes a list of input channels to receive messages, and output channels on which messages are sent. A channel can be modeled as a multiset or a queue depending on the desired ordering guarantees.  The syntactic elements of TRANSIT, shown in Figure <ref type="figure" target="#fig_1">4</ref>, are as follows:</p><p>Control states define the logical state of the directory and cache machines. These can be thought of as the program counter for these machines.</p><p>Process variables internal to each machine, such as Sharers in the directory. These may be Booleans, integers or bounded sets.</p><p>Input events correspond to receiving messages or external triggers (to issue requests). An input event is specified as a single message variable and the network on which it is received.</p><p>Guards are Boolean expressions over process variables and fields of received messages.</p><p>Output events correspond to sending messages to other processes. They are represented as a list of message variables and the name of network on which each message is sent.</p><p>Action statements update process variables to new values and specify values for the fields of outbound messages.</p><p>We defer a discussion on Pre and Post to Section 3.2. A complete specification of the behavior of an EFSM is thus a set of actions A that are to be executed, a set of output events O that are to be generated, the next control state s to transition to, all predicated on a guard g, for each combination of input event and control state e, s . The semantics of such a specification are that the EFSM executes actions A, generates events O, and finally transitions to control state s in response to an input event e when the EFSM is in control state s, provided g evaluates to true. In the asynchronous model of computation, the order in which processes execute is nondeterministic. However, once a process has been chosen for execution, its actions are assumed to be deterministic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Programming with TRANSIT</head><p>Figure <ref type="figure" target="#fig_1">4</ref> shows the composition of a single transition snippet in TRANSIT. Using existing approaches such as SLICC <ref type="bibr" target="#b17">[18]</ref> or hardware description languages, the programmer would completely specify the guards and actions in the transition. However, TRANSIT allows for guards to be left empty and for actions to be specified as constraints governed by pre-and post-conditions as shown in Fig- <ref type="figure" target="#fig_1">ure 4</ref>. In such cases, the tool computes expressions for the empty guards and update statements satisfying the given constraints.</p><p>The programmer has a choice of specifying completely symbolic, completely concrete, or mixed concolic snippets. In each case, TRANSIT generates a symbolic implementation. The pre-and post-conditions are Boolean predicates over process variables and message fields. Primed variables denote updated values of process variables. We assume a parallel assignment model, which precludes primed variables from appearing in pre-conditions and allows at most one primed variable per post-condition. Note that although guards and pre-conditions are both Boolean predicates ranging over the same variables, they have markedly different uses: guards appear in the complete protocol implementation of the EFSM in a guarded-command language, whereas pre-conditions are inputs to the inference engine which allow users to capture particular scenarios and are not part of the generated protocol implementation. Symbolic snippets. By specifying the guard and actions symbolically, we obtain a symbolic snippet which completely specifies a transition. A non-empty guard is assumed to be symbolic (i.e., completely specified and not generated by TRANSIT). Symbolic actions are specified by making the post-condition an equality constraint. Concolic snippets. If the guard is left empty, or the actions are specified using pre-and post-condition constraints (instead of equality), the snippet is concolic in nature. The TRANSIT tool generates symbolic code for update statements and/or the guard to be consistent with the given constraints. The following concolic snippet specifies the transition for the directory process mentioned in the SGI-Origin anecdote in Section 2. This snippet is applicable only when the current state is EXCLUSIVE and a message is received on the network ReqNet. To be consistent with the snippet, TRANSIT must generate code to update the new value of Sharers to be a superset of the old value and the sender of the incoming message. Concrete snippets. Concolic snippets may contain symbolic preand post-conditions over variables, but concrete snippets specify concrete values for any variables in these constraints. They may leave the guard empty as well. For example, the concrete snippet below shows the bug-fix described in Section 2:</p><formula xml:id="formula_2">Transition(EXCLUSIVE, ReqNet Msg) { [] =&gt; (BUSY_SHARED, RepNet RMsg, IntNet IMsg) { (Msg.MType = READ &amp; Owner = C1 &amp; Msg.Sender = C2) ==&gt; { Sharers' = {C1, C2}; . . . }}}</formula><p>In summary, symbolic and concrete snippets can be thought of as instances of concolic snippets in which guards and actions are either completely specified (symbolic), or specified with concrete values for all variables (concrete). The task of the TRANSIT tool is to generate expressions for guards and update expressions for variables such that they are consistent with the given snippets. We formalize this problem in Section 5 after first describing our expression inference algorithm in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Inferring Expressions</head><p>We first define the problem of inferring an expression from concrete or concolic examples in Section 4.1, which our synthesis procedure uses as a subroutine.  </p><formula xml:id="formula_3">o := e] is satisfiable. If ¬C[o := e]</formula><p>is unsatisfiable, then e is the desired expression. Otherwise, the satisfying model contributes a concrete example that is added to the set of concrete examples and the entire process is repeated. Thus, the algorithm handles "exists an expression" using enumerative techniques and "is valid for variable values" using symbolic constraint solving.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Problem Definition</head><p>We define an expression vocabulary G as a tuple (T , F), where T is a set of types, and F is a set of typed function symbols, where for each f ∈ F, arity(f ) ∈ N denotes the arity of f , type(f ) ∈ T denotes the type of the range of f , and argtype(f, i) ∈ T , i ∈ [1, arity(f )] denotes the type of the domain of the i th argument to f . Function symbols of arity zero are constants. F is finite, so we have a fixed number of constant symbols. However, constant expressions such as 2 are allowed as an abbreviation for add <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b0">1)</ref>.</p><p>Let V denote a set of typed variable symbols and let type(v) ∈ T denote the type of a variable v in V. Given an expression vocabulary G = (T , F) and a set of typed variables V, we denote the set of expressions of type t as Exp(F, V, t). This set is defined inductively as follows:</p><formula xml:id="formula_4">(1) If v ∈ V then v ∈ Exp(F, V, type(v)), and (2) If f ∈ F , and ∀i ∈ [1, k] : ei ∈ Exp(F, V, argtype(f, i)), then f (e1, e2, . . . , e k ) ∈ Exp(F, V, type(f )), where k = arity(f ).</formula><p>If e ∈ Exp(F, V, t), then we write type(e) = t. We assume that the Boolean type (denoted Bool) is always present in any instantiation of T and that the basic Boolean operators (conjunction, disjunction and negation) are part of F.</p><p>For specifying cache coherence protocols, we use an expression vocabulary where the set of types is T = {Bool, Int, PID, Set} ∪ Enums. Here, Int denotes the integer type, PID is a special type for process identifiers, Set is a type denoting a set of values of type PID, and Enums is a set of user defined enumerated types. The set of functions F in the vocabulary is shown in Table <ref type="table" target="#tab_3">1</ref>.</p><p>The size of an expression e, size(e), is defined as the number of function symbols and variable symbols appearing in e. Further, we denote by Exp k (F, V, t) the set {e : e ∈ Exp(F, V, t) ∧ size(e) = k}, i.e., the subset of expressions of type t with size k.</p><p>Given a set of typed variables V and a distinguished typed variable o / ∈ V (henceforth known as the output variable), an example C is a Boolean formula of the form pre ⇒ post where pre ∈ Exp(F, V, Bool) and post ∈ Exp(F, V ∪ {o}, Bool). In other words, if the variables in V satisfy the pre-condition pre, then the output variable o should be assigned an expression over these variables such that the post-condition post holds. An example set over the output variable o, denoted C(o), is defined as the set of examples {C1, . . . , Cn} such that the conjunction n (pre i ⇒ post i ) is satisfiable. An expression e is consistent with the example set C(o) iff for all C ∈ C(o), C[o := e] is a formula that is valid. Example. Let V = {x, y}, where type(x) and type(y) are both Int. Consider the example set {C1}, where C1 is ((x = 0) ∧ (y = 1)) ⇒ (o = 1). The expressions y and x + y are all consistent with C(o), while the expression x is inconsistent, as C1[o := x] is the invalid formula (x = 0) ∧ (y = 1) ⇒ (x = 1). Now, consider the example set {C1, C2}, where C2 is the example (x = 1) ∧ (y = 1) ⇒ (o = 2). The expression y is not consistent with the new example set, as C2[o := y] is the invalid formula (x = 1) ∧ (y = 1) ⇒ (y = 2); however, the expression x + y is still consistent.</p><p>The expression inference problem can now be stated as: given an expression vocabulary G = (T , F) with a set of variables V and an example set C(o) over the typed output variable o, find an expression e in Exp(F, V, type(o)) which is consistent with C(o).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Inferring Expressions from Concrete Examples</head><p>We say that an example is concrete if it has the form:</p><formula xml:id="formula_5">( v∈V (v = kv)) ⇒ (o = ko)</formula><p>, where for all v ∈ V, kv and ko are concrete expressions<ref type="foot" target="#foot_0">1</ref> of types type(v) and type(o), respectively. An example set containing only concrete examples is called a concrete example set. An alternative representation for a concrete example is the tuple (S, ko), where S is a valuation function mapping variables in V to values and ko is the concrete value for the output variable o. We use the notation S(e) to denote the evaluation of an expression e for the valuation S for its constituent variables. Checking if an expression e is consistent with a concrete example C is straightforward: we check if S(e) = ko. Given a concrete example set ConcreteExs = {C1, . . . , Cn}, e is consistent with ConcreteExs iff e is consistent with each Ci.</p><p>The algorithm enumerates expressions inductively until it finds an expression e that is consistent with ConcreteExs. In the first step, only expressions of size one are considered, i.e., variable symbols or constants. In the n th step, expressions of size n are obtained by composing expressions obtained in previous steps using functions in F. As each expression e is enumerated, it is checked for consistency with ConcreteExs.</p><p>To enhance scalability, the algorithm uses the examples to guide the search as well, rather than just to check for consistency. Intuitively, if two expressions e and e evaluate to the same values for each example C ∈ ConcreteExs, then only one of e or e needs to be carried forward to the next iteration, as the information encoded in ConcreteExs is insufficient to distinguish e and e . The algorithm exploits this property to prune the search space of expressions.</p><p>Let ConcreteExs = {C1, . . . , Cn} be a concrete example set. Suppose each Ci is represented as (Si, ki). Then the signature Sig(e, ConcreteExs) of an expression e with respect to ConcreteExs is a vector of values k1, k2, . . . kn , where each ki = Si(e). In other words, the signature of an expression e is the Example. Consider the expression vocabulary shown in Table <ref type="table" target="#tab_3">1</ref>. Suppose that we wish to describe the expression to compute the maximum of two integers a and b. Algorithm 1, referred to as SolveConcrete, implements the enumeration based strategy, with the pruning of the search space based on the notion of indistinguishability, to find an expression that is consistent with respect to a given set of concrete examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Inferring Expressions from Concolic Examples</head><p>We now describe an algorithm for the general problem defined in Section 4.1, i.e., we relax the restriction that the examples be concrete. Each example C ∈ ConcolicExs -where ConcolicExs Evaluating a candidate expression e is sufficient to check if e is consistent with respect to a given set of concrete examples. However, checking consistency of an expression w.r.t. a concolic example set requires a validity query involving terms from the expression vocabulary. For our expression vocabulary we can use a satisfiability modulo theories (SMT) solver to check consistency.</p><p>We now discuss how we can adapt Algorithm SolveConcrete to infer expressions consistent with respect to a set of concolic examples. The notion of indistinguishability has been defined only with respect to a set of concrete examples. It has no simple analogue with respect to concolic examples. But using indistinguishability to prune the search space contributes significantly to the scalability of our enumerative approach, as our experiments show in Section 4.4. Thus, it would be desirable to retain the benefits of using indistinguishability to prune the search space in the solution for the general problem of inferring an expression consistent w.r.t. a set of concolic examples. To this end, the algorithm which we now propose uses a set of concretizations of the concolic examples to serve as concrete examples w.r.t. which the search space is pruned. Consider a concolic example set ConcolicExs over an output variable o and an expression e found to be inconsistent with some concolic example C of the form pre ⇒ post. Then there must exist a valuation S over the variables v ∈ V which satisfies the formula ¬C[o := e]. Now, pre must necessarily be satisfiable under the valuation S. Let ko be a value which satisfies the formula   <ref type="table" target="#tab_3">1</ref>. We can specify max(a, b) with the concolic example:</p><formula xml:id="formula_6">v∈V v = S(v) ∧ post(C[o := ko]).</formula><formula xml:id="formula_7">true ⇒ (o ≥ a) ∧ (o ≥ b) ∧ ((o = a) ∨ (o = b))</formula><p>Table <ref type="table" target="#tab_5">2</ref> shows the expressions that were checked for consistency, the witness for the inconsistency of the expression obtained, and the concrete example inferred from the witness. The first row of the table seeds the set of concrete examples. The subsequent rows indicate the expression queried for symbolic validity and the concrete example inferred. We observe that the expression corresponding to max(a, b) was discovered after making only four calls to the SMT solver, although the algorithm enumerated approximately five hundred expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Evaluation of the Expression Inference Algorithm</head><p>To evaluate the utility of the expression inference algorithm, we focus on the size of the expressions which the algorithm is able to compute successfully as a key metric. To benchmark the performance of the algorithm SolveConcrete, a large number of random expressions of varying sizes were generated. For each expression, a set of ten concrete examples that were consistent with the expression was generated. For each such concrete example set, the Algorithm SolveConcrete was used to compute an expression that is consistent. Figure <ref type="figure" target="#fig_6">5</ref> shows that the "Pruned" variant -which prunes the search space using the notion of indistinguishabilityoften explores two to three orders of magnitude fewer expressions than the "Exhaustive" variant -which does not perform any pruning -for expression sizes larger than ten (note the logarithmic scale on the Y-axis in Figure <ref type="figure" target="#fig_6">5</ref>).</p><p>To evaluate the algorithm SolveConcolic, we used the benchmarks shown in Table <ref type="table" target="#tab_8">3</ref>. The algorithm computes expressions of up to size 15 within a reasonable amount of time as shown in Table <ref type="table" target="#tab_8">3</ref>. The algorithm exceeds our 30 minute time-out on only one benchmark, whose solution has an expression size greater than 20. The right-most column in Table <ref type="table" target="#tab_8">3</ref> shows that the algorithm reaches the desired solution within a few iterations of the CEGIS outer loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The TRANSIT Synthesis Tool</head><p>We now describe the implementation of TRANSIT, which uses the algorithms described in Section 4 to generate an implementation of the protocol from concolic snippets. To this end, TRANSIT needs to:</p><p>(1) compute process-variable update expressions, and (2) compute guards for transitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Computing Update Expressions</head><p>TRANSIT employs a parallel assignment model, allowing the update for each primed variable to be computed independently. For each primed variable v , the TRANSIT snippets specify a set of con- colic examples, each of the form Pre ⇒ Post. This is precisely the form in which the Algorithm SolveConcolic expects a concolic example and can thus be solved directly by the algorithm. We instantiate o in Algorithm SolveConcolic with v , V with the set of all process variables and incoming message fields i.e., all the variables which can be read in the current scope and ConcolicExs with the set of concolic examples provided in the TRANSIT snippets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Computing Guard Expressions</head><p>A guard can be viewed as a Boolean-valued expression. The key difference between computing guards and computing update expressions is that for a given control state and input event, guards cannot be computed independently of each other. To ensure that the behavior of the EFSM implementations generated by TRANSIT are deterministic, the computed guards for each control state and input event pair are required to be pairwise mutually exclusive. To compute guards on transitions from a given state, TRANSIT groups the concolic snippets with the same starting state, input event and next state into one guard-action as shown in Figure <ref type="figure" target="#fig_1">4</ref>. Therefore, given a starting state and input event, each possible next state has a corresponding guard-action associated with it. Given a set of guard-actions B1, . . . , Bn, the j th guard-action block is a set of examples conditioned by Prej1, . . ., Pre jk j . The algorithm for computing guards sequentially computes the guards for each of the blocks, starting with B1. Thus, before synthesizing the j th guard, it has the guards ϕ1, . . . , ϕj-1 corresponding to the guard-action blocks B1, . . . , Bj-1 available to it. To compute a guard ϕj for the guard-action block Bj, we observe that ϕj must evaluate to false whenever the guard ϕi evaluates to true, for any i &lt; j. This property is expressed with the concolic examples:</p><formula xml:id="formula_8">ConcolicExs1 = {ϕi ⇒ ¬ϕj | i &lt; j}</formula><p>Next, ϕj must evaluate to true whenever any of the preconditions Pre jl , l ∈ [1, kj] evaluate to true. This property can be expressed with the following concolic example:</p><formula xml:id="formula_9">ConcolicExs2 =      k j l=1 Pre jl   ⇒ ϕj   </formula><p>Also, corresponding to each block Bi for which a guard has not yet been synthesized (i.e., i &gt; j), ϕj must evaluate to false whenever any of preconditions in Bi evaluate to true. This property is expressed with the following symbolic examples</p><formula xml:id="formula_10">ConcolicExs3 = k i l=1 Pre il =⇒ ¬ϕj i &gt; j</formula><p>Finally the concolic example set required for inferring ϕj is the union of ConcolicExs1, ConcolicExs2 and ConcolicExs3. Again, V is instantiated to be the set of all process variables and the incoming    </p><formula xml:id="formula_11"># Description Expected Expression Exp. Size Constraints Time (s) # Iters 1 Max. of a, b ite(gt(a, b), a, b) 6 (a) (a &gt; b) ⇒ (o = a); (b &gt; a) ⇒ (o = b) &lt; 1 1 (b) true ⇒ (o ≥ a ∧ o ≥ b ∧ (o = a ∨ o = b)) &lt; 1 2 2 Max. of a,</formula><formula xml:id="formula_12">true ⇒ (o ⊆ (s 1 ∪ s 2 ); &lt; 1 2 setminus(s 1 , s 2 ), true ⇒ (o ∩ (s 1 ∩ s 2 )) = {}; setminus(s 2 , s 1 )) true ⇒ (o ∪ (s 1 ∪ s 2 )) = (s 1 ∪ s 2 ) 4 Sym. Diff.<label>7</label></formula><formula xml:id="formula_13">(a) (|s 1 | &gt; |s 2 |) ⇒ (o = s 1 ); &lt; 1 1 ite(gt(setsize(s 1 ), (|s 2 | &gt; |s 2 |) ⇒ (o = s 2 ) setsize(s 2 )), s 1 , s 2 ) (b) true ⇒ (|o| ≥ |s 1 | ∧ |o| ≥ |s 2 | &lt; 1 2 ∧ (o = s 1 ∨ o = s 2 ))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluating TRANSIT</head><p>To evaluate the proposed approach for specifying protocols with concolic snippets, we describe our experiences in using TRANSIT to specify some representative cache coherence protocols. As the proposed aims to be easy to use, a direct scientific comparison with existing approaches is challenging for two reasons: (1) a large user study, besides logistical difficulty, presents the problem of defining and extracting meaningful comparative metrics, and (2) a programmer attempting the same problem with two different approaches is subject to a familiarity bias. We instead document the experiences of three different programmers -each a co-author of this paper -in specifying three coherence protocols of varying complexity (two textbook examples and one industrial strength protocol) with TRANSIT. We summarize the perceived advantages as well as limitations of our approach based on these experiences. All experiments were performed using the expression vocabulary shown in Table <ref type="table" target="#tab_3">1</ref>.</p><p>We first validated the feasibility of using our expression enumeration approach by transcribing fully specified protocols from the GEMS simulation toolkit <ref type="bibr" target="#b17">[18]</ref> into fully symbolic TRANSIT snippets. With four cache processes and one directory, the entire synthesis process took less than a second for each protocol. The key results are summarized in Table <ref type="table" target="#tab_9">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Case Study A: Non-blocking MSI Protocol.</head><p>We specified the non-blocking "MSI protocol" described in the synthesis lectures <ref type="bibr" target="#b24">[25]</ref> using concolic snippets in TRANSIT. A nonblocking directory allows a greater number of concurrent requests to be in flight, requiring the programmer to consider a larger number of corner cases due to increased concurrency.</p><p>The scenarios described in the text resulted in a sparse initial set of snippets, as most of the tricky corner cases were either indirectly specified in the textual description or were left unspecified. Hence, the programmer added 67 more snippets over 13 debugging iterations before converging to a correct protocol. In each such iteration, the programmer either added symbolic snippets, when the behavior of the protocol in some corner case was completely unspecified, or concrete snippets, when a specification existed but was incomplete. Table <ref type="table" target="#tab_11">5</ref> summarizes the effort and complexity in this experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Case Study B: From MSI to MESI</head><p>The goal of our second case study was to augment the blocking MSI protocol with an "E" state to arrive at the MESI protocol. The E state (shorthand for exclusive) is an optimization that grants readwrite permissions to the first reader of an unshared address (i.e., not present in any cache) -as opposed to just read permission in MSI -thereby eliminating coherence traffic on a subsequent write to the same address. The synthesis lectures <ref type="bibr" target="#b24">[25]</ref> describe this protocol in terms of new scenarios and modifications to scenarios in the MSI protocol. Our approach was to add the corresponding snippets to the existing set of snippets used to specify the MSI protocol. Because the examples describe a MESI protocol with a non-blocking directory, we modified our baseline MSI protocol correspondingly.</p><p>The extended protocol contained five new states (four for the cache, one for the directory), and seven new message types. In the first iteration, we added 19 snippets to specify transitions involving the E state and the non-blocking behavior of the directory. These snippets described the behavior of the protocol in underspecified corner cases and scenarios involving transient states and were added in response to the errors reported by the model checker.</p><p>The programmer was able to obtain a fully verified protocol by adding twelve additional snippets over eight iterations. Additional metrics gathered during this case study are presented in Table <ref type="table" target="#tab_11">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Case Study C: The SGI Origin Protocol</head><p>For our final case study, we chose the coherence protocol used in the SGI-Origin 2000 servers <ref type="bibr" target="#b15">[16]</ref>, which is highly cited in the cache coherence literature. The Origin protocol is a directorybased, MESI protocol, and it supports multiple concurrent requests to the same address. Processes communicate through messages that may be arbitrarily re-ordered in the network. The consequent race conditions made it an interesting candidate for this case study.</p><p>Laudon and Lenoski <ref type="bibr" target="#b15">[16]</ref> describe the common case protocol behavior using request flows. In this experiment, ignoring the "poisoned" directory state (used for page-migration), we transcribed each of the read, read exclusive, upgrade, and write-back flows using symbolic snippets in TRANSIT. Except for obvious cases, we left most of the guards empty and specified all conditional attributes on message fields and process variables with pre-conditions.</p><p>The protocol skeleton comprised of the cache process and directory processes, four request types, twelve response types, the request and response networks, and an intervention network used to buffer intervention requests. We initially specified 56 transitions in the cache machine and 18 transitions in the directory machine. We also specified the guards in instances where the incoming message type was found to be inconsequential; doing so prevented the tool from exploring artificially large expressions involving the disjunction of these enumerated types. The resulting protocol resulted in an error discovered by the model checker due to the cache process receiving an unexpected message. We fixed this case by adding a concrete snippet describing the desired behavior of the cache. Once again we left the guards unspecified, but the pre-conditions and update constraints were predicated by identical values for the input message fields and internal process variables, as seen in the violating trace.</p><p>Continuing similarly, we added concrete snippets to fix error traces. In some cases, the tool identified inconsistencies between the added trace and a pre-existing constraint. We found it straightforward to reconcile these differences before converging to a protocol that model checked. The final synthesis step took a little over 30 minutes, exploring over four million states during model checking. The generated TRANSIT specification had a total of 50 transitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Discussion and Limitations</head><p>We found the primary convenience of using TRANSIT to be the manner in which the initial specification phase and the iterative debugging phases could be expressed differently. Although it was natural to transcribe the bulk of the protocol symbolically from the algorithmic description of flows, corner cases invariably resulted. Most errors occurred due to unintended interactions between flows. The unexpected message condition cited above resulted from a cache process that was participating in a read-write-back race scenario. TRANSIT generalized the concrete fixes provided by the programmer in a manner that was guaranteed not to contradict the constituent flows. Fixing this bug symbolically would have required reasoning about the impact on both these flows. Similarly, another coherence violation was the result of the sharer set in the directory being updated incorrectly when a previous owner was downgraded. Again, the fix involved adding a snippet that concretely specified the next contents of the sharer set with the pre-condition specifying only the erroneous case.</p><p>Similar to other synthesis approaches, one limitation of TRAN-SIT is the readability of the produced code. Although expression size might sometimes approximate desirable metrics (like gate count in hardware descriptions), it can result in less intuitive code. For instance, consider the following code generated by TRANSIT in one of our case studies:</p><p>SetSize(SetAdd(Sharers, InMsg.Sender)) -1</p><p>Although this code is more is compact than the equivalent, but more verbose:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Broadly speaking, the topic of this paper can be classified as program synthesis, an active area of research with numerous approaches. We limit the comparison of our work to those that we feel are most closely related. Methodologically, our approach is inspired by program sketching <ref type="bibr" target="#b22">[23]</ref> and template-guided program synthesis <ref type="bibr" target="#b25">[26]</ref>. In such approaches, a programmer specifies the scaffold of a program by listing the high-level structure, the variables, the functional specification as a pre and post condition, and the form of desired assignments inside the specified structure. The desired expressions are then formalized as terms with unknown parameters, whose values are computed using constraint solving techniques analogous to the ones used for automatic derivation of program invariants.</p><p>The problem of inferring an expression that matches a given set of concrete examples is addressed by the work by Gulwani on a variety of domains including end-user spreadsheet programming <ref type="bibr" target="#b6">[7]</ref>. Although they do not use symbolic examples, their strategy for concrete examples, based on version space algebra, is different from the approach we adopt: the algorithm computes a representation of the set of all expressions that are consistent with each example, achieves compactness of the representation by a judicious use of data structures and pruning based on domain knowledge, and constructs the product of all such representations to choose an expression that is consistent with all the examples.</p><p>The problem of inferring expressions consistent with concrete and symbolic snippets can be viewed as an instance of the counterexample-guided inductive synthesis (CEGIS) strategy <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23]</ref>. As mentioned earlier, the problem is analogous to solving an ∃∀ formula. The solutions described in prior work <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b12">13]</ref> explicitly encoded the problem into an SMT constraint, which was then solved using an SMT solver. The approach described in this work uses an enumerative technique to handle the existential quantifier and uses an SMT solver to check for universality.</p><p>Distributed protocols, such as cache coherence protocols, have been the canonical application for model checking <ref type="bibr" target="#b2">[3]</ref>. In reactive synthesis, a finite-state controller is derived from correctness requirements in temporal logic, but this problem becomes undecidable when synthesizing a distributed protocol (see <ref type="bibr" target="#b27">[28]</ref> for a survey and <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b20">21]</ref> for recent approaches aimed at coping with the high computational complexity of the synthesis problem). An interesting recent approach to distributed protocol design relies on genetic programming <ref type="bibr" target="#b13">[14]</ref>: given an initial protocol and correctness requirements, if the model checker finds that the protocol does not satisfy the requirements, the tool tries multiple mutations of the guards and updates used in the protocol, ranks the resulting versions by estimating how close they are to satisfying the requirements using state-space analysis, and iterates by probabilistically selecting a variant with weights proportional to ranks. Note that we require the programmer to specify the skeleton of the protocol (such as control states and state variables), and thus we focus not on deriving protocol logic from high-level requirements, but on providing assistance to complete the intended design correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions</head><p>In this paper, we have proposed an approach for specifying distributed protocols by adopting verification tools that interact with the programmer. The approach relies on the observation that parts of the protocol behavior, as well as fixes during the debugging phase, can be naturally expressed in terms of example snippets. We described the concept of concolic snippets to allow a programmer to specify the protocol behavior as a mix of concrete examples and symbolic partial transitions. For the computational problem of inferring an expression that is consistent with the given set of concolic examples, we presented an algorithm that significantly prunes the space of expressions that need to be considered, and also limits the number of calls to an SMT solver needed to check consistency with respect to symbolic constraints. To demonstrate the feasibility of our methodology, we developed a prototype tool based on the algorithm for expression inference that generates complete protocol specifications from concolic snippets, which are then verified using a model checker.</p><p>Our preliminary case studies using this tool allowed inexperienced programmers to correctly synthesize representative cache coherence protocols of modest complexity with several hours of human effort. We were also able to translate an incomplete flowbased description of an industrial-strength protocol into a working implementation by effectively exploiting the flexibility afforded by concolic specifications. Encouraged by the initial experimental results, our next steps are to explore techniques to automatically analyze counterexamples returned by the model checker and alternate strategies for expression inference, and synthesizing EFSM descriptions from distributed scenarios such as message sequence charts.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .Figure 3 .</head><label>23</label><figDesc>Figure 2. The counterexample trace</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. A concolic snippet. CurrentState and NextState are the start and end control states. The snippet specifies zero or more outbound messages. It also specifies a guard-action block for each guard containing a set of conditional updates. The expression Prei specifies the condition (on process variables and the fields of the received message) under which the boolean constraints Postij hold. Each Postij constrains the updated value of exactly one process variable or output message field in terms of the old values of the process variables and the fields of the received message.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Section 4.2 presents a solution for a restricted version of this problem in which the examples involve only concrete values, whereas Section 4.3 presents a solution for the general case where the examples have concolic values. The expression inference problem corresponds to the following computational problem: given a quantifier-free formula C over (typed) variables V and a distinguished (output) variable o, find an expression e such that the formula C[o := e] is valid, where C[o := e] is the usual notation for the formula obtained by syntactically substituting e for every occurrence of o in C. Conceptu-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Consider concrete example C1 = (S1, k1), where S1 is the map a : 5, b : 3, c : 4 . Also consider the concrete example C2 = ( a : 3, b : 1, c : 2 , k2). Let ConcreteExs = {C1, C2}. For expressions e1 = a+b, e2 = b+a, e3 = c + c, the signatures Sig(e1, ConcreteExs) = 8, 4 , Sig(e2, ConcreteExs) = 8, 4 , and Sig(e3, ConcreteExs) = 8, 4 are equal. Thus e1, e2, and e3 are indistinguishable with respect to ConcreteExs. Note that this implies that larger expressions such as a + (a + b) and a + (c + c) are also indistinguishable w.r.t. ConcreteExs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 2 : 3 e 8 S</head><label>238</label><figDesc>SolveConcolic Input : A set of concolic examples ConcolicExs over a typed output variable o, an expression vocabulary F and a set of typed variables V. Output: An expression e, which is consistent with ConcolicExs. Data : ConcreteExs, a set of concrete examples inferred from ConcolicExs. 1 ConcreteExs ← {} 2 while true do ←SolveConcrete (ConcreteExs, F , V) ConcolicExs such that ¬C[o := e] is satisfiable do ← a valuation of variables v ∈ V which satisfies the formula ¬C[o := e] 9 ko ← a value that satisfies the formula v∈V v = S(v) ∧ post(C[o := ko]) 10 ConcreteExs ← ConcreteExs ∪ (S, ko) is a set of concolic examples -has the form pre ⇒ post, where the structure of pre and post are unrestricted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>The tuple (S, ko) is now a concretization of the concolic example C. The proposed algorithm thus maintains a concrete example set ConcreteExs containing concretizations of concolic examples C ∈ ConcolicExs. By ensuring that any expression e enumerated henceforth is consistent with ConcreteExs before checking for consistency over ConcolicExs, the number of expensive SMT queries needed can be reduced. Whenever an expression e that is consistent with ConcreteExs, but is inconsistent with ConcolicExs is found, additional concretizations of the concolic examples are added to ConcreteExs. This technique helps in two ways: (1) the number of queries to an SMT solver is reduced, and (2) the search space can be pruned on the basis of indistinguishability. Algorithm 2, referred to as SolveConcolic, makes use of these pruning strategies. Note that it uses Algorithm SolveConcrete as a subroutine. It maintains a set of concrete examples, ConcreteExs b : -1, o : 0 a a : 0, b : 1, o : 0 a : 0, b : 1, o : 1 ite(iszero(dec(b)), b, a) a : 0, b : 2, o : 0 a : 0, b : 2, o : 2 ite(gt(b, a), b, a) --</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Average number of expressions explored for various expression sizes by the Pruned and Exhaustive variants of Algorithm SolveConcrete. We omit data for the Exhaustive variant for sizes greater than 10 where it exceeds the memory limit of 3.5 GB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>ite(equals(e, c 1 ), a, b) 6 (e = c 1 ) ⇒ (o = a); &lt; 1 4 (e = c 1 ) ⇒ (o = b) 7 Largest of 2 sets 8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>is a concrete instance of</figDesc><table><row><cell>Cache1</cell><cell>Cache2 RE AD , Se nd er = Ca ch e2 Dir</cell><cell>State = EXCLUSIVE Owner = Cache1 Sharers = {}</cell></row><row><cell></cell><cell></cell><cell>State = BUSY_SHARED</cell></row><row><cell></cell><cell></cell><cell>Owner = Cache2</cell></row><row><cell></cell><cell></cell><cell>Sharers = { Cache2 }</cell></row><row><cell></cell><cell>Int Msg</cell><cell></cell></row><row><cell></cell><cell>Re pM sg</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>Expression Vocabulary used in Coherence Protocols ally, this problem is similar to solving ∃∀-formulas, and we use the counterexample-guided inductive synthesis (CEGIS) strategy that has previously been used to solve such problems<ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b22">23]</ref>.The algorithm enumerates expressions, with suitable pruning strategies, to find a candidate expression e that is consistent with the concrete examples that contribute to C. It then checks if ¬C[</figDesc><table><row><cell>Function</cell><cell>Description</cell></row><row><cell>add (Int, Int) → Int</cell><cell>Integer Addition</cell></row><row><cell>sub (Int, Int) → Int</cell><cell>Integer Subtraction</cell></row><row><cell>inc (Int) → Int</cell><cell>Add one to an Integer</cell></row><row><cell>dec (Int) → Int</cell><cell>Subtract one from an Integer</cell></row><row><cell>setadd (Set, PID) → Set</cell><cell>Add an entry into a Set</cell></row><row><cell>setsize (Set) → Int</cell><cell>Cardinality of a Set</cell></row><row><cell>setunion (Set, Set) → Set</cell><cell>Set Union</cell></row><row><cell>setinter (Set, Set) → Set</cell><cell>Set Intersection</cell></row><row><cell>setminus (Set, Set) → Set</cell><cell>Set Difference</cell></row><row><cell>setof (PID) → Set</cell><cell>Create a singleton Set</cell></row><row><cell>or (Bool, Bool) → Bool</cell><cell>Boolean Disjunction</cell></row><row><cell>and (Bool, Bool) → Bool</cell><cell>Boolean Conjunction</cell></row><row><cell>not (Bool) → Bool</cell><cell>Boolean Negation</cell></row><row><cell>setcontains (Set, PID) → Bool</cell><cell>Membership test on a Set</cell></row><row><cell>iszero (Int) → Bool</cell><cell>Test if an integer is Zero</cell></row><row><cell>∀t ∈ T equals (t, t) → Bool</cell><cell>Equality Test</cell></row><row><cell>ge (Int, Int) → Bool</cell><cell>Greater than or equal to</cell></row><row><cell>gt (Int, Int) → Bool</cell><cell>Greater than</cell></row><row><cell>∀t ∈ T , ite (Bool, t, t) → t</cell><cell>Conditional Expression</cell></row><row><cell>numcaches () → Int</cell><cell># of Caches (constant)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Algorithm 1 :</head><label>1</label><figDesc>SolveConcreteInput : A concrete example set ConcreteExs on a typed variable o, an expression vocabulary (T , F ) and a set of typed variables V. Output: An expression e, which is consistent with ConcreteExs. Data : The sets ExpSet(t, i), t ∈ T , i ∈ N, denoting sets of expressions of type t and size i, initialized to empty sets. A set SigSet which stores the signatures of all enumerated expressions e over ConcreteExs, initially empty.</figDesc><table><row><cell cols="2">2 SizeOneExps ←⊥</cell></row><row><cell cols="2">3 foreach v ∈ V do</cell></row><row><cell>4</cell><cell>SizeOneExps ← SizeOneExps ∪ {v}</cell></row><row><cell cols="2">5 foreach (c ∈ F ) ∧ (arity(c) = 0) do</cell></row><row><cell>6</cell><cell>SizeOneExps ← SizeOneExps ∪ {c}</cell></row><row><cell cols="2">7 foreach e ∈ SizeOneExps do</cell></row><row><cell>8</cell><cell>if Sig(e, ConcreteExs) / ∈ SigSet then</cell></row><row><cell>9</cell><cell>SigSet ← SigSet ∪ {Sig(e, ConcreteExs)}</cell></row><row><cell>10</cell><cell>if Sig(e, ConcreteExs) = Goal then</cell></row><row><cell>11</cell><cell>return e</cell></row></table><note><p>1 Goal ← k 1 , k 2 , . . . , kn , for each C i = (S i , k i ) ∈ ConcreteExs 12 ExpSet(type(e), 1) ← ExpSet(type(e), 1) ∪ {e} 13 i ← 2 14 while true do 15 foreach f ∈ F do 16 m ← arity(f ) 17 foreach partition p of i -1 into m-partitions do 18 foreach (e 1 , e 2 , . . . , em) ∈ m j=1 ExpSet(argtype(f, j), p j ) do 19 e ← f (e 1 , e 2 , . . . , em) 20 if Sig(e, ConcreteExs) / ∈ SigSet then 21 SigSet ← SigSet∪{Sig(e, ConcreteExs)} 22 if Sig(e, ConcreteExs) = Goal then 23 return e 24 Add e to ExpSet(type(e), size(e)) 25 i ← i + 1 vector of values obtained by evaluating e over the concrete examples. Two expressions e and e are said to be indistinguishable w.r.t a concrete example set ConcreteExs iff Sig(e, ConcreteExs) = Sig(e , ConcreteExs).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 .</head><label>2</label><figDesc>Illustration of the working of SolveConcrete -which are concretizations of examples in ConcolicExs -and invokes the SolveConcrete algorithm on it. If SolveConcrete finds an expression e which is consistent w.r.t. ConcreteExs, the algorithm checks if e is consistent w.r.t. ConcolicExs with a query to an SMT solver. If e is inconsistent with ConcolicExs, then the algorithm augments ConcreteExs with new concrete examples as described earlier and repeats the entire process. Example. To illustrate the working of the algorithm, consider finding an expression for max(a, b), with the expression vocabulary in Table</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 3 .</head><label>3</label><figDesc>Description of the benchmarks used to evaluate the algorithms and experimental results</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Synthesis</cell><cell></cell><cell></cell></row><row><cell cols="2">Prot-# Sce-</cell><cell></cell><cell>Updates</cell><cell></cell><cell></cell><cell>Guards</cell><cell>State-</cell></row><row><cell>ocol</cell><cell cols="7">narios Num. Exps Time Num. Exps Time Space</cell></row><row><cell></cell><cell></cell><cell cols="6">synth. tried (secs) synth. tried (secs)</cell></row><row><cell>VI</cell><cell>19</cell><cell>49</cell><cell>449</cell><cell>&lt; 1</cell><cell>17</cell><cell>525</cell><cell>&lt; 1 140K</cell></row><row><cell>MSI</cell><cell>77</cell><cell cols="2">157 3330</cell><cell>&lt; 1</cell><cell cols="2">45 3710</cell><cell>&lt; 1 854K</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 4 .</head><label>4</label><figDesc>Performance of snippet-based design message fields. o is instantiated to be ϕj. Algorithm SolveConcolic can now be used to infer the required guard expression ϕj.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 5 .</head><label>5</label><figDesc>Effectiveness Metrics for Protocol Design contained conjunctions of several different message types, making the generated code more difficult to read (although not less efficient than what a programmer would write).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>These are constant-valued expressions that do not contain variables. For example, if the only integer-valued constants in F are 0 and 1, then kv is allowed to be the term</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>as an abbreviation for add(1, 1).</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was partially supported by NSF award CCF 0905464 and NSF Expeditions in Computing grant CCF 1138996.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Intel Core2 Extreme Processor X6800 and Intel Core2 Duo Desktop Processor E6000 and E4000 Sequence -Specification Update</title>
		<ptr target="http://www.intel.com/design/processor/specupdt/313279.htm" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">So Many States, So Little Time: Verifying Memory Coherence in the Cray X1</title>
		<author>
			<persName><forename type="first">D</forename><surname>Abts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Lilja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Parallel and Distributed Processing Symposium, IPDPS &apos;03</title>
		<meeting>the International Parallel and Distributed Processing Symposium, IPDPS &apos;03</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verification of the Futurebus+ Cache Coherence Protocol</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hiraishi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">.</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ness</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="217" to="232" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic Synthesis of Cache-Coherence Protocol Processors Using Bluespec</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Models for Codesign, MEMOCODE &apos;05</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Protocol Verification as a Hardware Design Aid</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Drexler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Computer Design, ICCD &apos;92</title>
		<meeting>the International Conference on Computer Design, ICCD &apos;92</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="522" to="525" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Lazy Synthesis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th International Conference on Verification, Model Checking, and Abstract Interpretation, VMCAI &apos;12</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7148</biblScope>
			<biblScope unit="page" from="219" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automating String Processing in Spreadsheets using Input-output Examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 38th ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages, POPL &apos;11</title>
		<meeting>The 38th ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages, POPL &apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Synthesis of Loopfree Programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM SIGPLAN conference on Programming Language Design and Implementation, PLDI &apos;11</title>
		<meeting>the 32nd ACM SIGPLAN conference on Programming Language Design and Implementation, PLDI &apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Can Programming Be Liberated, Period?</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="28" to="37" />
			<date type="published" when="2008-01">Jan. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Let&apos;s Play: Scenario-Based Programming Using LSCs and the Play-Engine</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Marelly</surname></persName>
		</author>
		<author>
			<persName><surname>Come</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Behavioral Programming. Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="90" to="100" />
			<date type="published" when="2012-07">Jul. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The Spin Model Checker: Primer and Reference Manual</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Oracle-guided Component-based Program Synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering -Volume 1, ICSE &apos;10</title>
		<meeting>the 32nd ACM/IEEE International Conference on Software Engineering -Volume 1, ICSE &apos;10</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">MCGP: A Software Synthesis Tool Based on Model Checking and Genetic Programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Internation Symposium on Automated Technology for Verification and Analysis, ATVA &apos;10</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6252</biblScope>
			<biblScope unit="page" from="359" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Software Synthesis Procedures</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Piskac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Suter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="103" to="111" />
			<date type="published" when="2012-02">Feb. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The SGI Origin: A ccNUMA Highly Scalable Server</title>
		<author>
			<persName><forename type="first">J</forename><surname>Laudon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lenoski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual International Symposium on Computer Architecture, ISCA &apos;97</title>
		<meeting>the 24th Annual International Symposium on Computer Architecture, ISCA &apos;97</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="241" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Distributed algorithms</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multifacet&apos;s General Execution-driven Multiprocessor Simulator (GEMS) Toolset</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Marty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="2005-11">Nov. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT Solver</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS &apos;08</title>
		<meeting>the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS &apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">CUTE: A Concolic Unit Testing Engine for C</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE &apos;05</title>
		<meeting>the 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Sciduction: Combining Induction, Deduction, and Structure for Verification and Synthesis</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Design Automation Conference, DAC &apos;12</title>
		<meeting>the 49th Annual Design Automation Conference, DAC &apos;12</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="356" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Synthesizing Data Structure Manipulations from Storyboards</title>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM Symposium on Foundations of Software Engineering, FSE &apos;11</title>
		<meeting>the 19th ACM Symposium on Foundations of Software Engineering, FSE &apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="289" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Programming by Sketching for Bitstreaming Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rabbah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ebcioglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGPLAN 2005 Conference on Programming Language Design and Implementation, PLDI &apos;05</title>
		<meeting>the SIGPLAN 2005 Conference on Programming Language Design and Implementation, PLDI &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Sketching Concurrent Data Structures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGPLAN 2008 Conference on Programming Language Design and Implementation, PLDI &apos;08</title>
		<meeting>the SIGPLAN 2008 Conference on Programming Language Design and Implementation, PLDI &apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="136" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A Primer on Memory Consistency and Cache Coherence</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Morgan Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">From Program Verification to Program Synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th annual ACM Symposium on Principles of Programming Languages, POPL &apos;10</title>
		<meeting>the 37th annual ACM Symposium on Principles of Programming Languages, POPL &apos;10</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="313" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Going with the Flow: Parameterized Verification using Flows: An Industrial Experience</title>
		<author>
			<persName><forename type="first">M</forename><surname>Talupur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Tuttle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 Internation Conference on Formal Methods in Computer-Aided Design, FMCAD &apos;08</title>
		<meeting>the 2008 Internation Conference on Formal Methods in Computer-Aided Design, FMCAD &apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Facets of Synthesis: Revisiting Church&apos;s Problem</title>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computational Structures, 12th International Conference, FOSSACS &apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5504</biblScope>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
