<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Modeling and Analyzing MAPE-K Feedback Loops for Self-adaptation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Arcaini</surname></persName>
							<email>paolo.arcaini@unibg.it</email>
							<affiliation key="aff0">
								<orgName type="institution">DIGIP Università degli Studi di Bergamo</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Elvinia</forename><surname>Riccobene</surname></persName>
							<email>elvinia.riccobene@unimi.it</email>
							<affiliation key="aff1">
								<orgName type="department">Dipartimento di Informatica</orgName>
								<orgName type="institution">Università degli Studi di Milano</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Patrizia</forename><surname>Scandurra</surname></persName>
							<email>patrizia.scandurra@unibg.it</email>
							<affiliation key="aff2">
								<orgName type="institution">DIGIP Università degli Studi di Bergamo</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Modeling and Analyzing MAPE-K Feedback Loops for Self-adaptation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4744688FB483BD6C573942D3C6DD12C7</idno>
					<idno type="DOI">10.1109/SEAMS.2015.10</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The MAPE-K (Monitor-Analyze-Plan-Execute over a shared Knowledge) feedback loop is the most influential reference control model for autonomic and self-adaptive systems. This paper presents a conceptual and methodological framework for formal modeling, validating, and verifying distributed self-adaptive systems. We show how MAPE-K loops for selfadaptation can be naturally specified in an abstract stateful language like Abstract State Machines. In particular, we exploit the concept of multi-agent Abstract State Machines to specify decentralized adaptation control by using MAPE computations. We support techniques for validating and verifying adaptation scenarios, and getting feedback of the correctness of the adaptation logic as implemented by the MAPE-K loops. In particular, a verification technique based on meta-properties is proposed to allow discovering unwanted interferences between MAPE-K loops at the early stages of the system design. As a proof-ofconcepts, we model and analyze a traffic monitoring system.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Modern software systems typically operate in dynamic environments and deal with highly changing operational conditions: components can appear and disappear, may become temporarily or permanently unavailable, may change their behavior, etc. Self-Adaptation (SA) has been widely recognized <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b25">[26]</ref> as an effective approach to deal with the increasing complexity, uncertainty and dynamicity of these systems. A well recognized engineering approach to realize self-adaptation is by means of a feedback control loop called MAPE-K <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b11">[13]</ref> and conceived as a sequence of four computations Monitor-Analyze-Plan-Execute over a Knowledge base.</p><p>To provide guarantee of the functional correctness of the adaptation logic, formal methods can be used as a rigorous means for specifying and reasoning about self-adaptive systems' behavior, both at design time and at runtime. However, the survey in <ref type="bibr" target="#b33">[34]</ref> shows that, although the attention for self-adaptive software systems is gradually increasing, the number of studies that employ formal methods remains low, and mainly related to runtime verification. Formally founded design models that cover both structural and behavioral aspects of self-adaptation and of approaches to validate and verify behavioral properties are highly demanded. Of extreme importance is engineering self-adaptive systems in a way that unwanted interferences/conflicts between feedback control loops are excluded at the early stages of the system design. This work is part of our ongoing research activity <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref> on formal modeling self-adaptive systems having a decentralized MAPE-K control loop architecture. As in <ref type="bibr" target="#b35">[36]</ref>, with decentralization, we refer to how control decisions in a self-adaptive software system are coordinated among different components, regardless of how those control components are physically distributed. Specifically, we consider decentralization at the level of the four computations of a MAPE-K loop.</p><p>By assuming a clear separation of adaptation concerns and exploiting the theoretical framework of the multi-agent Abstract State Machines (ASM) <ref type="bibr" target="#b10">[12]</ref>, we here show how to model and analyze in ASM the behavior of a self-adaptive system by representing MAPE-K loops explicitly and naturally formalized in terms of agents' actions (ASM transition rules). Most existing formal approaches to SA assume a centralized point of control and none of them, except <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b0">[1]</ref> (see Sect. II), provides a semantic description of the adaptation logic from the perspective of feedback control loops.</p><p>Our framework supports also formal techniques for validating and verifying adaptation scenarios, and getting feedback (already at system design time) of the correctness of the adaptation logic as implemented by the MAPE-K loops. In addition to common state-of-the-art model checking techniques for verifying properties of self-adaptive systems, we support the analysis of systems where multiple MAPE-K loops interact (and possibly operate on top of each other) by detecting possible intra-and inter-loop interferences and conflicts. To this purpose, a verification technique based on the proof of meta-properties is proposed to allow discovering unwanted interferences between MAPE-K loops.</p><p>The rest of this paper is organized as follows. Sect. II presents related work. Sect. III describes the reference model we adopt for realizing SA, and Sect. IV introduces the Traffic Monitoring System here taken as running case study. Sect. V provides some background on the ASM formal method. Sect. VI presents the proposed ASM-based modeling and analysis framework for self-adaptive systems. The ASM model of the Traffic Monitoring System is shown in Sect. VII. In Sect. VIII we present the results of applying the model validation and verification techniques on the case study by, respectively, simulating adaptation scenarios and verifying meta-properties and properties through model checking for system adaptation concerns such as flexibility and robustness.</p><p>Sect. IX discusses some faced challenges. Sect. X concludes the paper and outlines future directions of our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>Our proposal takes inspiration by many former works on formal modeling and analysis of self-adaptive systems.</p><p>Automata-based or transition-based computational models have been advocated for adaptation, such as the S[B] systems <ref type="bibr" target="#b29">[30]</ref> and Synchronous Adaptive Systems (SAS) of MARS <ref type="bibr" target="#b2">[3]</ref>. They have in common a multi-level view of SA. They rely on a multi-layered model reminiscent of hierarchical state machines and automata. In the simple case of two layers, the lower behavioral level describes the actual dynamic behavior of the system and the upper structural level accounts for the dynamically changing environmental constraints imposed on the lower system. Petri Nets extensions also exist for dealing with adaptation. The work in <ref type="bibr" target="#b36">[37]</ref>, for example, combines Petri Nets modeling with LTL for property checking, including correctness of adaptations and robustness properties of adaptive programs.</p><p>In the area of concurrency, classical Process Algebra (CCS, CSP, ACP) have been tailored, such as in <ref type="bibr" target="#b8">[10]</ref>, to the modeling of self-adaptive systems as a subclass of reactive systems. The approach SOTA <ref type="bibr" target="#b1">[2]</ref> supports an early, goal-level, model checking analysis for adaptive systems. However, they adopt a very complex model checking process involving several formalisms: the i* framework is used for modeling static aspects, an operational SOTA language is defined and used to describe the dynamic aspects and dependencies among components, and process calculus Finite State Processes (FSP) and asynchronous first-order linear-time temporal logic (FLTL) code of the formal model checker Labeled Transition System Analyzer (LTSA) is then provided to formally define the goal or utility for verification purposes. In addition to specific temporal properties specified for a particular model, the framework can also check general properties that any model should assure (e.g., absence of deadlock). In <ref type="bibr" target="#b18">[19]</ref> a formal model for contextaware adaptive systems is proposed by establishing a threelayered separation among system components, context entities, and management components. Relationships between layers are dynamically established via the generation of strategies by the management layer. Maude is adopted as a semantic framework for the proposed model, and Maude reflection and meta-programming capabilities are exploited to enrich it with context-awareness concepts. Formal analysis is performed using the Maude model checker. <ref type="bibr" target="#b22">[23]</ref> presents a case study of an adaptive production automation cell modeled in the Lustre language -a typed synchronous dataflow language with a discrete time model -using the SCADE Suite and the verification of functional properties.</p><p>We also considered approached relying on state-and machine-based formalisms close to ASMs such as the B method, Alloy and Z. The authors in <ref type="bibr" target="#b27">[28]</ref> present an approach to the formal specification and verification of dynamic re-configurations of component-based systems using the B method for the specification of component architectures and FTPL -a logic based on architectural constraints and on event properties, translatable into LTL -to express temporal properties over (re-)configuration sequences to model-check. <ref type="bibr" target="#b20">[21]</ref> uses architectural constraints specified in Alloy for the specification, design and implementation of self-adaptive architectures for distributed systems. <ref type="bibr" target="#b28">[29]</ref> outlines an approach for modeling and analyzing fault tolerance and self-adaptive mechanisms in distributed systems. The authors use a modal action logic formalism, augmented with deontic operators, to describe normal and abnormal behavior.</p><p>As important as their contribution could be to support the specification and analysis of self-adaptive systems, the formalization approaches mentioned above do not support the explicit modeling of feedback loops for SA and their properties. The actual feedback control loops are hidden or abstracted. In our approach, instead, we clearly explore MAPE-K feedback loops as a means to identify and enact adaptation, so elevating them to first-class entities in the ASM formal specification of a selfadaptive system. Moreover, most of these formal approaches to SA assume a centralized point of control.</p><p>In <ref type="bibr" target="#b23">[24]</ref>, Timed Automata are used to model the Traffic Monitoring case study (the same presented here) and verify (with the tool Uppaal) flexibility and robustness properties by model checking. The same case study is specified using the Z method in <ref type="bibr" target="#b34">[35]</ref>. These are (to the best of our knowledge) the first works presenting a formal approach to specify and verify behavioral properties of decentralized self-adaptive systems through MAPE-K feedback loops, and this is the reason why we mainly inspired to them. However, the approaches in <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b34">[35]</ref> suffer from the over-specification due to the rigidity of the formalisms Timed Automata and Z. Differently, the natural expression in ASM of fundamental computing concepts through programming practice and mathematical standards allow the practitioner to work with ASMs without any further explanation, viewing them as "pseudocode over abstract data" which comes with a well defined semantics supporting the intuitive understanding <ref type="bibr" target="#b10">[12]</ref>. Moreover, the simplicity and modularity of the resulting ASM formal specification allow the application of the method to the specification of largescale self-adaptive systems.</p><p>The Traffic Monitoring System has been revised in <ref type="bibr" target="#b32">[33]</ref> where the simple sequence of four MAPE computations to form a control loop is extended in case of camera failures to (i) allow the execution of multiple sub-loops within a single control loop -intra-loop coordination, and (ii) enable MAPE computations across loops to coordinate the various phases of adaptation -inter-loop coordination. The flexibility and abstractness of our framework allow us to model any adaptation strategy and coordination schema of control loops, and to discover and analyze conflicts that may arise also in complex scenarios where MAPE-K sub-loops deal with subconcerns of the main adaptation concern.</p><p>The authors in <ref type="bibr" target="#b12">[14]</ref> present an essential model of Adaptable Transition Systems. The same authors in <ref type="bibr" target="#b13">[15]</ref> propose a conceptual framework for adaptation centered around the role of control data and its realization in a reflective logical language Fig. <ref type="figure">1:</ref> A self-adaptive software system (adapted from <ref type="bibr" target="#b35">[36]</ref>) like Maude by using the Reflective Russian Dolls model. They also exploit the statistical model checker PVeStA and present a robot swarms equipped with obstacle-avoidance self-assembly strategies as case study. The proposed computational model for SA is, however, built around hierarchical structures of managing layers. To really capture the distributed nature of self-adaptive systems, more coordination patterns of managing components/agents need to be employed <ref type="bibr" target="#b35">[36]</ref>.</p><p>According to a decentralized feedback loop-based approach, a general goal-oriented modeling framework <ref type="bibr" target="#b0">[1]</ref>, called SOTA (State Of The Affairs) and tool-supported by SimSOTA (an Eclipse plug-in), is being developed to support the modeling, simulation and validation of self-adaptive systems. Similarly to our approach, SOTA aims at supporting the development of self-adaptive systems by allowing to validate the actual correctness of decentralized feedback loop models before implementation. However, unlike our formal approach, SOTA adopts a semi-formal notation, namely UML activity diagrams, as primary notation to model the behavior of feedback loops.</p><p>A recently proposed approach is ActivFORMS (Active FORmal Models for Self-adaptation) <ref type="bibr" target="#b24">[25]</ref>. Its aim is to guarantee that the adaptation goals verified offline (i.e., at design time) are guaranteed also at runtime. It adopts an integrated formal model of a MAPE-K loop (i.e., models of the knowledge and the adaptation components) that is directly executed by a virtual machine at runtime and can be dynamically changed with changing goals. We postpone as future work to study the conformance relation between the formal model and the real system execution at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. REFERENCE MODEL FOR SELF-ADAPTATION</head><p>According to the conceptual model FORMS <ref type="bibr" target="#b34">[35]</ref> 1 and the study in <ref type="bibr" target="#b35">[36]</ref>, SA is based on the design principle of separation of concerns. As shown in Fig. <ref type="figure">1</ref> (adapted from <ref type="bibr" target="#b35">[36]</ref>), a selfadaptive system is situated in an environment (both physical and software entities) and basically consists of a two-layer architecture: a managed subsystem layer that comprises the application logic, and a managing subsystem on top of the managed subsystem comprising the adaptation logic. This last realizes a feedback loop that monitors the environment and the managed subsystem, and adapts the latter when necessary, 1 FORMS is a metamodel consisting of formally specified modeling elements that correspond to the key concerns in the design of self-adaptive software systems, and a set of relationships that guide their composition. Fig. <ref type="figure">2</ref>: Adaptation scenarios (adapted from <ref type="bibr" target="#b23">[24]</ref>) such as to deal with particular types of faults (self-heal), selfoptimize when operating conditions change, self-reconfigure when a goal changes, etc. Typically, the managing subsystem is conceived as a set of interacting feedback loops, one per each self-adaptation aspect (or concern). Other layers can be added to the system where higher-level managing subsystems manage underlying subsystems, which can be managing systems themselves.</p><p>A common approach to realize a feedback loop is by means of a MAPE-K (Monitor-Analyze-Plan-Execute over a Knowledge base) <ref type="bibr" target="#b25">[26]</ref> loop. A component Knowledge (K) maintains data of the managed system and environment, adaptation goals, and other relevant states that are shared by the MAPE components. A component Monitor (M) gathers particular data from the underlying managed system and the environment through probes (or sensors) of the managed system, and saves data in the Knowledge. A component Analyze (A) performs data analysis to check whether an adaptation is required. If so, it triggers a component Plan (P) that composes a workflow of adaptation actions necessary to achieve the system's goals. These actions are then carried out by a component Execution (E) through effectors (or actuators) of the managed system.</p><p>Computations M, A, P, and E may be made by multiple components that coordinate with one another to adapt the system when needed, i.e., they may be decentralized throughout the multiple MAPE-K loops <ref type="bibr" target="#b35">[36]</ref>. These MAPE components can communicate explicitly or indirectly by sharing information in the knowledge repository.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. RUNNING CASE STUDY</head><p>As case study to exemplify hereinafter our formal framework for self-adaptive systems, we present a traffic monitoring application inspired by the work in <ref type="bibr" target="#b23">[24]</ref>.</p><p>A number of intelligent cameras along a road (see Fig. <ref type="figure">2</ref>) are endowed with a data processing unit and a communication Fig. <ref type="figure">3</ref>: Camera system architecture (adapted from <ref type="bibr" target="#b23">[24]</ref>) unit to interact with each other. Cameras have to collaborate to observe larger phenomena such as traffic jams and aggregate the monitored data. Traffic jams can span the viewing range of multiple cameras and can dynamically grow and dissolve. Cameras enter or leave the collaboration whenever the traffic jam enters or leaves their viewing range.</p><p>Fig. <ref type="figure">3</ref> shows the architecture of a camera system. Every local camera (the component Camera) provides the functionality to detect traffic jams and inform clients. To access the hardware and communication facilities on the camera, the local camera system can rely on the services provided by the distributed communication and host infrastructure. Camera collaboration dynamics are managed by an organization controller (the component Organization Middleware). The organization controller is responsible for restructuring camera organizations and for adapting the system. The need for self-adaptation is triggered by changes in the surrounding environment, namely the congestion detected by a sensor of the camera -a subcomponent Traffic Monitor of the camera component -, and by the failures of other cameras (silent nodes) as detected by the component Self Healing Subsystem using a Heartbeat interaction pattern. Organization controllers of cameras collaborate to manage an organization that spans multiple cameras. To simplify synchronization issues, a master/slave control model is used at intra-organizational level. For each organization, one of the organization controllers is elected as master, whereas the other controllers of the organization are slaves. The master is responsible for managing the dynamics of that organization by synchronizing with all of the slaves.</p><p>According to the reference model for SA presented in Sect. III, the managed system is the local camera, while the managing subsystem corresponds to the self-healing subsystem and the organization middleware. These last components implement MAPE-K control loops for two main adaptation concerns <ref type="foot" target="#foot_0">2</ref> . The first concern is system flexibility for the dynamic adaptation of an organization. See, for example, the scenario in Fig. <ref type="figure">2</ref> from configuration T0 to T1, where camera 2 joins the organization of cameras 3 and 4 after it monitors a traffic jam. The second concern is adaptation to external camera failures (robustness), i.e., when a failing camera becomes unresponsive without sending any incorrect data. This scenario is shown in Fig. <ref type="figure">2</ref> from T2 to T3, where camera 2 fails. A further MAPE-K loop is also used to deal with internal failures of the camera (robustness).</p><p>V. BACKGROUND ON ASMS ASMs are an extension of FSMs <ref type="bibr" target="#b10">[12]</ref> where unstructured control states are replaced by states comprising arbitrary complex data, and transitions are expressed by rules describing how data change from one state to the next. ASM states are multi-sorted first-order structures, i.e., domains of objects with functions and predicates (boolean functions) defined on them. State function values are saved into locations which may be updated from one state to another by firing a set of transition rules (or machine program).</p><p>The basic form of a transition rule is the guarded update "if Condition then Updates", where function Updates -having form f (t 1 , . . . , t n ) := t -are simultaneously executed when Condition -a first order formula -is true. Besides the guarded rule, there is a finite set of rule constructors to model simultaneous parallel actions (par), sequential actions (seq), non-determinism (choose), unrestricted synchronous parallelism (forall), domain extension (extend). Due to their parallel execution, we require updates to be consistent, i.e., no pair of updates exist at a time which try to update the same location to different values.</p><p>Functions remaining unchanged during the computation are static. Those updated by agent actions are dynamic, and distinguished in monitored (read by the machine and modified by the environment), controlled (read and written by the machine), shared (read/written by the machine/environment).</p><p>ASMs allow to model any kind of computational paradigm, from a single agent executing simultaneous parallel actions, to distributed multiple agents interacting in a synchronous or asynchronous way. A multi-agent ASM is given by a family of pairs (a, ASM(a)), where each agent a : Agent has a "local" view, View (a, S), of the global state S (see Fig. <ref type="figure">4</ref>). An agent executes its own (possibly the same but differently instantiated) machine ASM(a) specifying its local behavior, and contributes to determine the next state S . A predefined function program on Agent indicates the ASM associated with an agent, and it is used to dynamically associate behavior to agents. Within transition rules, each agent can identify itself by means of a special 0-ary function self : Agent which is interpreted by each agent a as itself.</p><p>For a complete theoretical definition of the ASM multiagent model, we refer the reader to <ref type="bibr" target="#b10">[12]</ref>.</p><p>The ASM formal method is supported by the tool-set ASMETA (ASM mETAmodeling) <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref> for model editing, validation and verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. SELF-ADAPTIVE ASMS</head><p>Here we present a formal framework, based on the ASM formalism, to model a self-adaptive system according to a Fig. <ref type="figure">4</ref>: Global state and partial view in a multi-agent ASM (taken from <ref type="bibr" target="#b10">[12]</ref>) system's layered architecture with decentralized MAPE-K control loops.</p><p>Because of the distributed nature of self-adaptive systems, we use the notion of multi-agent ASMs. A software component is therefore represented in terms of an ASM agent able to interact with other agents (components). All together these ASM agents comprise the logic of a distributed ASM, called self-adaptive ASM, that provides the overall functionality of the self-adaptive system. It is, therefore, able to monitor the environment and itself and to self-adapt accordingly.</p><p>According to Sect. III, the self-adaptive layer (the managing subsystem) is conceived as a set of interacting MAPE-K loops. Therefore, the set Agent of a self-adaptive ASM is the union of the set MgA of managing agents and the set MdA of managed agents. Managing agents encapsulate the logic of self-adaptation of the MAPE-K loops, while managed agents encapsulate the system's functional logic.</p><p>A self-adaptive system may expose a certain number of MAPE-K loops, {MAPE(adj 1 ), . . . , MAPE(adj n )}, one per each adaptation concern adj i . The behavior of a MAPE(adj i ) is conceptually captured by a set of ASM transition rules:</p><formula xml:id="formula_0">MAPE(adj i ) = {R a1 MAPE(adji) , . . . , R am MAPE(adji) }</formula><p>where {a 1 . . . , a m } ⊆ MgA are the managing agents involved in the execution of the loop MAPE(adj i ), and R aj MAPE(adji) is the ASM rule modeling the behavior of the agent a j , j = 1, . . . , m, in the loop MAPE(adj i ).</p><p>Since in a decentralized setting a single managing agent a j ∈ MgA may be involved in one or more loops MAPE(adj i ), i = 1, . . . , n, its program takes the form:</p><formula xml:id="formula_1">program(a j ) = parR aj MAPE(adjj 1 ) , . . . , R aj MAPE(adjj k ) endpar</formula><p>and consists in the parallel execution of its behavioral contributions to the j 1 , . . . , j k loops the agent is involved in. These rules are annotated (as comments //) with appropriate labels @M c (for context-aware monitoring), @M s (for self-aware monitoring), @A (for analyzing), @P (for planning), and @E (for execution) <ref type="foot" target="#foot_1">3</ref> , depending on the role of the agent a in the loop.</p><p>An adaptation concern is also characterized by a knowledge K(adj). In ASM, this is an ASM module defining only signature (domains and functions symbols) shared among the managing agents of the MAPE-K loop MAPE(adj) to maintain representations of the managed subsystem (the reflective model <ref type="bibr" target="#b34">[35]</ref>) and the environment, and other useful information for the enactment of the MAPE computations. The union of all these knowledges leads to an unique common knowledge K = adj K(adj) shared by all managing agents.</p><p>The notion of environment is directly supported in the ASM theory by means of ASM monitored functions (see Sect. V). Probes (or sensors) from the environment are therefore modeled as ASM monitored functions or derived functions (the result of an elaboration of monitored functions). Probes from the managed system are instead represented by the changing value of ASM controlled functions modeling internal information to aware the system about itself. Actuators (or effectors) are specified in terms of actions (ASM rules) of managed agents that update controlled locations according to the adaptation plan decided by managing agents.</p><p>In the subsections below, we describe how to express in ASM the key mechanisms of the reference model FORMS <ref type="bibr" target="#b34">[35]</ref> for realizing SA through MAPE-K feedback loops.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Context-and Self-Awareness</head><p>According to <ref type="bibr" target="#b34">[35]</ref>, an update computation perceives the state of the environment, while a monitor computation perceives the state of the managed subsystem to update the system model (the observed data from the system) in the knowledge. Update computations and monitor computations may trigger analyze computations when particular conditions hold. An analyze computation assesses the collected data from the environment and/or the system itself to determine the system's ability to satisfy its goals. Update computations in combination with analyze computations provides for contextawareness <ref type="bibr" target="#b34">[35]</ref>, which is a key property of self-adaptive systems. Monitor and analyze computations provide for selfawareness <ref type="bibr" target="#b34">[35]</ref>, which is another key property.</p><p>We use the terms context-aware monitoring and self-aware monitoring to denote update computations and monitor computations, respectively. In managing components, these computations are explicitly captured by ASM rules annotated with @M c and @M s, respectively. Context-aware monitoring consists into looking values of ASM monitored locations (the environment), while self-aware monitoring consists into looking values of ASM controlled locations representing internal locations of the managed system.</p><p>A rule scheme for a context/self-aware monitoring computation of a MAPE-K loop may take the two different forms <ref type="bibr" target="#b0">(1)</ref> and ( <ref type="formula" target="#formula_2">2</ref>) depending on the decentralized or centralized control of the loop's computations, respectively.</p><formula xml:id="formula_2">if Cond then Updates K //@M c[s] (1) if Cond then Analyze //@M c[s]<label>(2)</label></formula><p>In both schemes, Cond, the condition under which the rule is applied, is an arbitrary first-order formula over monitored (in case of context-awareness) and/or controlled (in case of selfawareness) locations of the managed ASM. In the decentralized control scheme (1), Updates K is a finite set of transition rules simultaneously executed. They may consist of function updates f (t 1 , . . . , t n ) := t changing (or defining, if there was none) the value of the knowledge location represented by the function f at the given parameters, and/or of call rules for more complex computations. Such knowledge updates may trigger an analyze activity executed by other managing agents. In case of centralized control <ref type="bibr" target="#b1">(2)</ref>, Analyze is an ASM transition rule for an analyze computation (see schemes ( <ref type="formula">3</ref>) and ( <ref type="formula">4</ref>)) triggered by the monitoring computation and executed by the same agent in a waterfall style. An analyze computation is specified by an ASM conditional rule annotated with @A:</p><formula xml:id="formula_3">if Cond K then Updates K //@A (3)</formula><p>It involves the evaluation of a first order formula Cond K , to determine if a violation of the system's goals occurs and an adaptation plan has to be triggered. This formula can be arbitrary complex and expresses the logic relationship of certain knowledge location values that must be true in order that violating situation holds. In a decentralized control, Updates K are updates of knowledge functions that may trigger planning activity executed by other agents. Alternatively, in centralized mode (schema 4), a planning computation can be directly executed by the same agent in a waterfall style.</p><p>if Cond K then Plan //@A (4)</p><p>where P lan is a transition rule for planning (see next section). Note that complex planning computations may be missing in a MAPE-K loop and therefore the transition from an analyze computation to an execute computation may be direct. In this case, the ASM rules schemes 3 and 4 will trigger an execute activity indirectly (by knowledge updates) or directly (by executing an execute computation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Adaptation Operators</head><p>A plan computation creates or selects a procedure to enact a necessary adaptation in the managed system. It can be a single action or a complex workflow. Then, as decided by the planning, an execute computation carries out the adaptation actions on the managed system using effectors.</p><p>In ASM, plan computations are ASM transition rules annotated with @P. They are conditional rules or may adopt a more complex ASM rule scheme. Such rules predispose the desired adaptation actions, and trigger (setting values of the shared knowledge) the managing agent(s) responsible to execute such adaptations or directly invoke execute computations.</p><p>Finally, an execute computation is an ASM rule annotated with @E and made of atomic adaptation actions. The following adaptation actions are supported:</p><p>• change locations value of the knowledge to (indirectly) trigger the execution of managed ASM agents playing the role of effectors; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Coordination</head><p>MAPE computations may be enhanced with support for distribution through coordination <ref type="bibr" target="#b35">[36]</ref>. Cooperation and competition are forms of interactions among concurrent MAPE computations. So, interactive MAPE-K loops may require developing coordination models explicitly. To this purpose, ASM agents may adopt recurrent coordination patterns for distributed control (e.g., master-slaves pattern, hierarchical control pattern, alternate pattern, etc.) as formalized in <ref type="bibr" target="#b9">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. ASM MODEL OF THE TRAFFIC MONITORING SYSTEM</head><p>The ASM specification of a local camera system consists of four agents: Camera and TrafficMonitor representing the managed camera subsystem, and OrganizationController (oc) and SelfHealingController (shc) representing, respectively, the managing components Organization Middleware and Self Healing Subsystem.</p><p>We use the MAPE-K loops identified before to specify the self-adaptive behavior of the overall distributed system made of n cameras. The first MAPE-K loop deals with the flexibility concern to restructure organizations in case of congestion and it is handled by the organization controllers. The loop is defined as follows:</p><formula xml:id="formula_4">MAPE(flexibility) = n i=1 {orgContrFlexBehavior[oc i ]}</formula><p>where orgContrFlexBehavior[oc i ] is an instance of the rule orgContrFlexBehavior for the organization controller oc i of camera i, for i = 1 . . . n.</p><p>The second MAPE-K loop deals with the adaptation to failures of other cameras (silent cameras). It is handled by both the organization controllers and the self-healing controllers. It is defined as: Finally, the third MAPE-K loop deals with internal failures of the camera. Both managing agents of each camera implement such a loop. It is defined as:</p><formula xml:id="formula_5">MAPE(extFailure) = n i=1 r failureAdapt[oc i ], r failureDetect[shc i ]</formula><formula xml:id="formula_6">MAPE(intFailure) = n i=1 r selfFailureAdapt[oc i ], r selfFailureDetect[shc i ]</formula><p>where r selfFailureAdapt is the rule of the organization controllers and r selfFailureDetect the rule of the selfhealing controllers.</p><p>In the following, we describe the behavior of the two types of managing agents (i.e., the organization controller and the self-healing controller) that implement the three MAPE-K loops. We make use of the textual syntax AsmetaL of the ASMETA framework <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. The complete ASM specification is available online at <ref type="bibr">[9]</ref>.</p><p>An organization controller runs on each camera and is responsible for managing organization adaptations. Code 1 shows the organization controller's program<ref type="foot" target="#foot_2">4</ref> that executes in parallel three rules as contributions of the agent to the three MAPE-K control loops.</p><p>A self-healing controller runs on each camera. The corresponding ASM agent's program is the rule r_selfHeal reported in Code 2. It executes in parallel two rules for dealing with self-adaptation due to external and internal failures (the two MAPE-K loops for robustness) by alerting (by knowledge update) the organization controller that, in turn, will adapt the organization accordingly. This is the situation when two MAPE-K loops interact.</p><p>Details on the rule definitions can be found in the specification available on line. As exemplification, we here explain the last rule of the organization controller for adaptation due to internal failure. It is defined as instance of the (centralized)  </p><formula xml:id="formula_7">macro rule r selfFailureAdapt = par if stopCam(camera(self)) then //@M s state(camera(self)) := FAILED //@E endif if startCam(camera(self)) then //@M s if state(camera(self)) = FAILED then //@A par //@E state(camera(self)) := MASTER ... endpar endif endif endpar</formula><p>Code 4: Wrong version of rule r_selfFailureAdapt state of the machine execution. For example, we added to the specification the following invariants (state(c i ) = FAILED and state(c i-1 ) != FAILED) implies next(c i-1 ) = c i+1 (state(c i ) = FAILED and state(c i+1 ) != FAILED) implies prev(c i+1 ) = c i-1 checking that the neighboring camera relations are correctly arranged after a failure: whenever a camera c i fails (with i = 2, . . . , n -1), camera c i-1 updates its next camera to c i+1 , and camera c i+1 updates its previous camera to c i-1 .</p><p>2) Scenario-based Validation: This technique consists in designing a set of scenarios specifying the expected behavior of the models. We simulated different scenarios with increasing number of cameras. In particular, we created and validated the adaptations scenarios shown in Fig. <ref type="figure">2</ref> from T0 to T1 for flexibility, and from T2 to T3 for adaptation to external failure.</p><p>Scenarios are expressed, by using constructs of the language Avalla, as interaction sequences of actor actions to set the environment (i.e., the values of monitored/shared functions), to check the machine state, to ask for the execution of given transition rules, and reactions of the machine which can perform a step or a sequence of steps until a condition holds. Scenarios are executed by the simulator AsmetaS, instrumented properly. During simulation, the validator AsmetaV captures any check violation and, if none occurs, it finishes with a PASS verdict.</p><p>The scenario reported in Code 5 describes the adaptation from T0 to T1. At the beginning, cameras c3 and c4 form </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Verification</head><p>We have verified the specifications through model checking. AsmetaSMV <ref type="bibr" target="#b3">[4]</ref> is a tool of the ASMETA framework that translates ASM specifications into models of the NuSMV model checker. It allows the verification of Computation Tree Logic (CTL) and Linear Temporal Logic (LTL) formulae.</p><p>We have verified system-independent properties (or metaproperties), i.e., properties that any self-adaptive model should guarantee, and properties representing adaptation goals related to the requirements of the specific system. Sect. VIII-B1 presents the former category, while Sect. VIII-B2 describes the latter category.</p><p>1) Model Review: This approach aims at determining if a model is of sufficient quality to be easy to develop, maintain, and enhance. This technique permits to identify defects early in the system development, reducing the cost of fixing them. For this reason, it should be applied also on preliminary models. The AsmetaMA tool <ref type="bibr" target="#b4">[5]</ref> (based on AsmetaSMV) allows automatic review of ASMs. Typical vulnerabilities and defects that can be introduced during the modeling activity using ASMs are checked as violations of suitable meta-properties (MP , defined in <ref type="bibr" target="#b4">[5]</ref> as CTL formulae). The violation of a meta-property means that a quality attribute is not guaranteed, and it may indicate the presence of a real fault (i.e., the ASM is indeed faulty), or only of a stylistic defect (i.e., the ASM could be written in a better way).</p><p>For this work, we have identified some meta-properties tailored for self-adaptive systems:</p><p>• MP nc : MAPE loops are not in conflict. Two MAPE loops (or the same MAPE loop) are in conflict if they simultaneously update the same knowledge (i.e., the same location) at the same time to two different values. This definition corresponds to the definition of inconsistent update <ref type="bibr" target="#b10">[12]</ref>. We have an intra-loop inconsistency if the inconsistent updates belong to the same MAPE loop, and an inter-loop inconsistency if the inconsistent updates belong to two different MAPE loops.</p><p>• MP e : all rules involved in MAPE loops are executed.</p><p>This meta-property only guarantees that there is no over specification inside a MAPE loop formalization. However, it does not guarantee functional correctness of a MAPE loop. This can only be controlled with applicationdependent properties specified by the user, as described in Sect. VIII-B2. • MP m : the knowledge is minimal, i.e., it does not contain locations that are unnecessary (they are never read nor updated) or that do no assume all the values of their codomains. Note that a violation of this meta-property may also indicate that the specification is not complete, i.e., that the designer forgot to read/update a location.</p><p>In our first developed models we discovered an intra-loop inconsistency (meta-property MP nc ) caused by the inconsistent updates also found by simulation (see Sect. VIII-A1). Although a normal simulation or the scenario-based validation can sometimes unveil the presence of inconsistent updates, when the model becomes particularly complex, inconsistencies may be more difficult to find, and an automatic approach as that provided by the model reviewer is helpful. Moreover, simulation can show only some inconsistencies (i.e., those detected in the executed runs), whereas model review detects all the inconsistencies.</p><p>We have also found several minimality violations (i.e., metaproperty MP m ), since some locations could not assume all the values of their codomains. For example, the boolean binary function slave(Camera, Camera) represents the slavery relations exiting between the cameras: location slave(c i , c j ) is true iff c j is slave of c i . The model reviewer advised us that all the locations slave(c i , c j ) with j ≤ i cannot be true: indeed, a camera cannot be slave of a subsequent camera or of itself. Obviously, in this case the meta-property violation does not indicate a real fault, but only that the model is not minimal. In order to address the minimality violation, we could have modeled the slavery relations using a different data structure (e.g., associating with each camera the set of its slaves). Note that, although in the formal specification the chosen data structure is not a real issue, in the final implementation the choice of an optimized data structure could be important, particularly if there are some memory limitations on the hardware.</p><p>2) Verification of Case Study Requirements: Model review permits to verify general properties (automatically built from the model) that any model should guarantee. More complicated properties related to the requirements of the application must be specified by the modeler.</p><p>We have verified classical temporal properties to guarantee correctness and reliability of our running case study. Moreover, we also considered properties originally proposed in <ref type="bibr" target="#b23">[24]</ref>, dividing them in three categories: invariants, flexibility, and robustness to silent node failures. Below we report some of the specified properties.</p><p>Invariants: These properties must hold in all the states. For example, we have verified that all cameras cannot be slaves (or master with slaves) at the same time. Note that the AsmetaS simulator supports invariant checking. Each invariant ϕ, here verified through model checking with the temporal property ag(ϕ), has also been checked by the simulator and the scenario-based validator. Obviously, by simulation we have been able to verify only the states covered by the executed runs, whereas model checking gave us the assurance that the invariants hold in each model state.</p><p>Flexibility: The following properties check that the system correctly adapts itself to the different traffic conditions (i.e., presence or absence of traffic congestion). We have proved different properties, considering the possible different roles assumed by the cameras when they observe congestion.</p><p>For example, we have checked the most basic organization: when a master camera c i detects a congestion and the next camera c i+1 is master and congested as well, then the two cameras form an organization where c i is master with slaves and c i+1 its slave (for each i = 1, . . . , n -1). Based on our master election policy, we have checked more complex properties, as, for example, the following. If three consecutive master cameras are congested, they form an organization, where the leftmost camera c i is the master and the other two cameras are its slaves (with i = 2, . . . , n -2). Robustness: We have verified that the system is able to correctly recover from a silent node failure, i.e., that the nonfailing cameras reorganize themselves correctly.</p><p>First, we have checked that, if a camera c i fails (being c i+1 its slave), then c i+1 leaves its master (with i = 1, . . . , n -1).</p><p>As additional property we have checked that, whenever the slaves of an organization detect a failure of their master, they eventually form a new organization, as long as the traffic remains congested. We only show one configuration, but all the possible configurations have been checked. R2: ag((stateC(c1) = FAILED and slaves(c1,c2) and slaves(c1,c3))</p><p>implies e[(congested(orgCont2) and congested(oc3)) U (stateC(c2) = MASTERWITHSLAVES and slaves(c2,c3))])</p><p>IX. DISCUSSION &amp; FACED CHALLENGES Self-adaptive systems are generally difficult to specify, validate, and verify due to their high complexity and dynamic nature. Particularly, when involving decentralized adaptation, the system adaptive behavior is the result of the collaborative behavior of multiple managing agents and components responsible for enabling adaptation.</p><p>Modeling self-adaptation features was possible thanks to the multi-agent computational model available in ASMs to specify distributed computation and coordination among agents. Furthermore, in the way we model MAPE-K control loops in ASMs, we achieve a clear separation between adaptation logic and functional logic. This is possible since the formal approach allows:</p><p>(i) To separate, by modeling them as separated agents, managing components from managed ones. E.g., the agent OrganizationController manages the local camera. proof of suitable meta-properties, can reveal intra/interloop inconsistencies inside the agents' programs. Such conflicting situations often requires to reason about "priorities" of adaptation concerns, which can be established by appropriate scheduling of the agents' operations.</p><p>In our case study, by this technique, we discovered an intra-loop inconsistency inside the program of the OrganizationController. (vii) Assert the system correctness. Once one gains enough confidence that the self-adaptive system works according to the expected adaptation logic, verification is necessary to assure correctness properties. By model checking, we have verified a set of properties expressing, as temporal logic formulas, adaptation goals (mainly flexibility and robustness) of our case study. (viii) Check for model completeness without overspecification. Besides correct, a model must be complete, i.e., all the computational and adaptive aspects must be specified, but also minimal, i.e., no over-specification must be, due to unnecessary signature and/or transition rules never executed. We checked suitable meta-properties to guarantee knowledge minimality and the absence of "dead" rules. In our case study we found some minimality violations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. CONCLUSION AND FUTURE DIRECTIONS</head><p>In this paper, we showed how to model the self-adaptation layer of modern distributed systems in terms of multi-agent ASMs. By exploiting the abstraction and flexibility of this formal method, we introduced the concept of self-adaptive ASMs as formal framework to specify self-adaptive behavior. We applied our formal modeling approach to the Traffic Monitoring case study. We were able to avoid over-specification while achieving clear separation of concerns that helped us to focus on one adaptation concern at a time, and, for each concern, to separate the managing behavior from the managed one. We were able to model the interaction between managed and managing agents as ASM agents interaction, without the necessity to extend the ASM formalism. Validation and verification activities helped us to reason about interfering adaptation concerns and adaptation goals.</p><p>In the future, we want to exploit runtime monitoring techniques, that the ASM formalism already supports <ref type="bibr" target="#b5">[6]</ref> for Javalike programs, to connect our formal model to a runtime adaptation middleware. We also plan to exploit appropriate extensions of ASMs with time models <ref type="bibr" target="#b21">[22]</ref> for specifying time-triggered adaptation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>macro rule r organizationController = par orgContrFlexBehavior(self) //Adaptation due to congestion r failureAdapt[] //Adaptation due to external failure r selfFailureAdapt[] //Adaptation due to internal failure endpar agent OrganizationController : r organizationController[] Code 1: Program of each organization controller macro rule r selfHeal = par r failureDetect[] //Adaptation due to external failure r selfFailureDetect[] //Adaptation due to internal failure endpar agent SelfHealingController: r selfHeal[] Code 2: Program of each self-healing controller where r failureAdapt is the rule of the organization controllers and r failureDetect the rule of the self-healing controllers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Example of simulation -Detection of an inconsistent update</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>scenarioCode 5 :</head><label>5</label><figDesc>Flexibility T0 T1 load main.asm set stopCam(c1) := false; set stopCam(c2) := false; set stopCam(c3) := false; set stopCam(c4) := false; set startCam(c1) := false; set startCam(c2) := false; set startCam(c3) := false; set startCam(c4) := false; set congestion(c1) := false; set congestion(c2) := false; set congestion(c3) := true; set congestion(c4) := true; set elapsedWaitTime(shc3) := false; set elapsedWaitTimePlusDelta(shc4) := false; exec par state(c3) := MASTERWITHSLAVES state(c4) := SLAVE slaves(c3, c4) := true getMaster(c4) := c3 congested(oc3) := true congested(oc4) := true endpar; step set congestion(c2) := true; step check getMaster(c4)=c3 and s offer(c3)=true and s offer(c4)=false and slaves(c3,c4)=true and state(c1)=MASTER and state(c2) = MASTER and state(c3) = MASTERWITHSLAVES and state(c4)=SLAVE; step check isAlive(c4)=false and newSlave(c2,c3)=true and getMaster(c4)=c3 and s offer(c3)=true and s offer(c4)=false and slaves(c3,c4)=false and state(c1)=MASTER and state(c2) = MASTER and state(c3) = SLAVE and state(c4)=SLAVE; step check isAlive(c4) = false and newSlave(c2,c3) = false and getMaster(c4) = c3 and s offer(c3) = true and s offer(c4) = false and slaves(c2,c3) = true and slaves(c2,c4) = true and state(c1) = MASTER and state(c2) = MASTERWITHSLAVES and state(c3) = SLAVE and state(c4) = SLAVE; Flexibility validation scenario from T0 to T1 in Avalla an organization. When c2 detects congestion, it joins the organization as MASTER. Appropriate assertions control that the right messages are sent and that the correct slavery relations are established.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>I1:</head><label></label><figDesc>ag(not(forall $c in Camera with state($c) = SLAVE)) I2: ag(not(forall $c in Camera with state($c) = MASTERWITHSLAVES))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>F1:</head><label></label><figDesc>ag((state(c i ) = MASTER and congested(oc i ) and state(c i+1 ) = MASTER and congested(oc i+1 )) implies af(state(c i ) = MASTERWITHSLAVES and slaves(c i , c i+1 )) )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>F4:</head><label></label><figDesc>ag((state(c i ) = MASTER and congested(oc i ) and state(c i+1 ) = MASTER and congested(oc i+1 ) and state(c i+2 ) = MASTER and congested(oc i+2 ) and stateC(c i-1 ) = MASTER and not(congested(oc i-1 ))) implies ef(stateC(c i ) = MASTERWITHSLAVES and slaves(c i , c i+1 ) and slaves(c i , c i+2 )))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(ii) To distribute a MAPE loop among those agents that are involved in the loop's computations. E.g., both agents SelfHealingController and OrganizationController are involved in the robustness loops for external and internal failure. (iii) To separate, inside the behavior of a managing agent, different adaptation concerns (modeled by separated transition rules). E.g., in the program of the Organization-Controller, the rule orgControlFlexBehaviour models the agent's contribution in the flexibility concern, while the rule r_failureAdapt is related to the robustness concern for external failures. (iv) To distinguish between decentralized and centralized loop's control, by defining specific rule schemes. This separation of concerns helps the designer to focus on one adaptation activity at a time, and, for each adaptation aspect, separate the adapting parts from the adapted ones. This also facilities reasoning about components behavior and avoid over-specification, keeping models concise. The availability of a set of tool for model analysis helped us in different activities: (v) Validate adaptation requirements by executing specifications. For the Traffic Monitoring case study, we simulated different scenarios for flexibility and robustness. (vi) Determine conflicting MAPE loops. Simultaneous execution of different adaptive behaviors might cause consistency violations, when different MAPE loops update locations inconsistently. Model simulation, by checking for inconsistent updates, can help to discover these situations. However, a deeper model analysis, by means of the</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The vision of MAPE-K loops we take here slightly differ from the one taken in<ref type="bibr" target="#b23">[24]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>These labels help understanding how the MAPE computations are distributed among the agents. For future scopes, these annotations may be extracted from the comments and used by the simulation environment at runtime.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Note that the concrete syntax agent agent_type : rule[] denotes in AsmetaL the initialization of the agent's function program.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>R1: ag((stateC(c i ) = FAILED and slaves(c i , c i+1 )) implies ef(not(slaves(c i , c i+1 ))))</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>This work was supported in part by the Italian Ministry of Research within the PRIN project "GenData 2020".</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>macro rule r selfFailureAdapt = par if stopCam(camera(self)) then //@M s if state(camera(self)) != FAILED then //@A state(camera(self)) := FAILED //@E endif endif if startCam(camera(self)) then //@M s if state(camera(self)) = FAILED then //@A par //@E state(camera(self)) := MASTER ... endpar endif endif endpar Code 3: Excerpt of rule r_selfFailureAdapt pattern (2) described in Sect. VI and it is partially shown in Code 3. This rule describes the contribution of the organization controller in the intFailure MAPE-K loop. It consists of a selfaware monitoring computation (i.e., the concurrent reading of the probes stopCam and startCam) followed by an analyze computation (i.e., the reading of the knowledge's function state representing the camera's state). Finally, if required by the analyze computation, an execute computation is directly performed (i.e., the updating of the state of the camera) without a plan computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. VALIDATION AND VERIFICATION</head><p>We here describe the model analysis activities we can perform on self-adaptive systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Validation</head><p>Model validation is a first model analysis activity, less demanding than property verification, that has to be used to validate the specification itself, but that can be also used to provide guarantees about qualities of the self-adaptive system. For model validation, we exploited the simulator AsmetaS <ref type="bibr" target="#b19">[20]</ref> and the validator AsmetaV <ref type="bibr" target="#b15">[16]</ref> of the toolset ASMETA <ref type="bibr" target="#b7">[8]</ref>.</p><p>1) Simulation: We performed either interactive simulation, where monitored inputs were provided interactively during simulation, and random simulation, where inputs values were chosen randomly by the simulator itself. During simulation, we also checked for consistent updates: in an ASM, two updates are inconsistent if they update the same location to two different values at the same time <ref type="bibr" target="#b10">[12]</ref>. We discovered, by simulating (see the trace in Fig. <ref type="figure">5</ref>) a preliminary version of our specification (shown in Code 4), that the organization controller could, at the same time, turn the status of its camera both to MASTER and to FAILED. That particular situation could occur when a camera c was already FAILED and the system received the signals to both turn on and turn off the camera (i.e., both monitored locations startCam(c) and stopCam(c) were true). This was due to a wrong scheduling of the operations of the organization controller (the correct version is shown in Code 3).</p><p>By means of the AsmetaS simulator, we also checked for model invariants, namely properties that must hold in any</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">SimSOTA: engineering and simulating feedback loops for self-adaptive systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Abeywickrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zambonelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International C* Conference on Computer Science &amp; Software Engineering, C3S2E13</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Desai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>De Almeida</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Bernardino</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Mudur</surname></persName>
		</editor>
		<meeting><address><addrLine>Porto, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">July 10 -12, 2013. 2013</date>
			<biblScope unit="page" from="67" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Model checking goal-oriented requirements for self-adaptive systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Abeywickrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zambonelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 19th International Conference and Workshops on Engineering of Computer-Based Systems, ECBS 2012</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Popovic</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Schätz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Voss</surname></persName>
		</editor>
		<meeting><address><addrLine>Novi Sad, Serbia</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">April 11-13, 2012. 2012</date>
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">From modelbased design to formal verification of adaptive embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Adler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schüle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Vecchié</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Software Engineering, 9th International Conference on Formal Engineering Methods, ICFEM 2007</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Hinchey</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Larrondo-Petrie</surname></persName>
		</editor>
		<meeting><address><addrLine>Boca Raton, FL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">November 14-15, 2007. 2007</date>
			<biblScope unit="volume">4789</biblScope>
			<biblScope unit="page" from="76" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">AsmetaSMV: A Way to Link High-Level ASM Models to Low-Level NuSMV Specifications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Arcaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Abstract State Machines, Alloy, B and Z</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Frappier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Glässer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Laleau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Reeves</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5977</biblScope>
			<biblScope unit="page" from="61" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatic review of abstract state machines by meta property verification</title>
		<author>
			<persName><forename type="first">P</forename><surname>Arcaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
		<idno>VA 23681-2199</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second NASA Formal Methods Symposium (NFM 2010)</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Muñoz</surname></persName>
		</editor>
		<meeting>the Second NASA Formal Methods Symposium (NFM 2010)<address><addrLine>Langley Research Center, Hampton; USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-04">April 2010</date>
			<biblScope unit="page" from="4" to="13" />
		</imprint>
	</monogr>
	<note>NASA</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">CoMA: Conformance Monitoring of Java Programs by Abstract State Machines</title>
		<author>
			<persName><forename type="first">P</forename><surname>Arcaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7186</biblScope>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A modeldriven process for engineering a toolset for a formal method</title>
		<author>
			<persName><forename type="first">P</forename><surname>Arcaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scandurra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw., Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="166" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://asmeta.sourceforge.net/" />
		<title level="m">The ASMETA toolset website</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A CSP-based framework for the specification, verification, and implementation of adaptive systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bartels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kleine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Symposium on Software Engineering for Adaptive and Self-Managing Systems, SEAMS &apos;11</title>
		<meeting>the 6th International Symposium on Software Engineering for Adaptive and Self-Managing Systems, SEAMS &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="158" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Modeling workflow patterns from first principles</title>
		<author>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Parent</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K.-D</forename><surname>Schewe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">C</forename><surname>Storey</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Thalheim</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4801</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Abstract State Machines: A Method for High-Level System Design and Analysis</title>
		<author>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stärk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Engineering self-adaptive systems through feedback loops</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D M</forename><surname>Serugendo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gacek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Kienle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Litoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzè</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering for Self-Adaptive Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">H C</forename><surname>Cheng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>De Lemos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Inverardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5525</biblScope>
			<biblScope unit="page" from="48" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Adaptable transition systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Corradini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gadducci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lluch-Lafuente</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vandin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Trends in Algebraic Development Techniques, 21st International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Martí-Oliet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Palomino</surname></persName>
		</editor>
		<meeting><address><addrLine>Salamanca, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012-06-07">2012. June 7-10, 2012. 2012</date>
			<biblScope unit="volume">7841</biblScope>
			<biblScope unit="page" from="95" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Modelling and analyzing adaptive self-assembly strategies with maude</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bruni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Corradini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gadducci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lluch-Lafuente</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vandin</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Held as a Satellite Event of ETAPS</title>
	</analytic>
	<monogr>
		<title level="m">Rewriting Logic and Its Applications -9th International Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Durán</surname></persName>
		</editor>
		<meeting><address><addrLine>Tallinn, Estonia</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012-03-24">2012. March 24-25, 2012. 2012</date>
			<biblScope unit="volume">7571</biblScope>
			<biblScope unit="page" from="118" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Scenario-Based Validation Language for ASMs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carioni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scandurra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Abstract State Machines, B and Z</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Bowen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Boca</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5238</biblScope>
			<biblScope unit="page" from="71" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Software engineering for self-adaptive systems: A research roadmap</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Lemos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Inverardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Andersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bencomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cukic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Software engineering for self-adaptive systems: A second research roadmap</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Lemos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Andersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Litoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schmerl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Villegas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Vogel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering for Self-Adaptive Systems II</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Model checking pervasive context-aware systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Djoudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bouanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeghib</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 23rd International WETICE Conference</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Reddy</surname></persName>
		</editor>
		<meeting><address><addrLine>Parma, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014-06">2014. 2014. June, 2014. 2014</date>
			<biblScope unit="page" from="92" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Metamodel-based Language and a Simulation Engine for Abstract State Machines</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gargantini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scandurra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1949" to="1983" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Self-organising software architectures for distributed systems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Georgiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WOSS</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="33" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Time in state machines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prinz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundam. Inform</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="143" to="174" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Modeling of selfadaptive systems with SCADE</title>
		<author>
			<persName><forename type="first">M</forename><surname>Güdemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Angerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ortmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Reif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Circuits and Systems (ISCAS 2007)</title>
		<meeting><address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007-05-20">27-20 May 2007. 2007</date>
			<biblScope unit="page" from="2922" to="2925" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A case study on formal verification of self-adaptive behaviors in a decentralized system</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Iftikhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weyns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Kokash and Ravara</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="45" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Activforms: active formal models for self-adaptation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Iftikhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weyns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEAMS</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Bencomo</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="125" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The vision of autonomic computing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">O</forename><surname>Kephart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Chess</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="50" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Kokash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ravara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 11th International Workshop on Foundations of Coordination Languages and Self Adaptation</title>
		<meeting>11th International Workshop on Foundations of Coordination Languages and Self Adaptation<address><addrLine>Newcastle, U.K.</addrLine></address></meeting>
		<imprint>
			<publisher>EPTCS</publisher>
			<date type="published" when="2012-09-08">2012. September 8, 2012. 2012</date>
			<biblScope unit="volume">91</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Combining proof and model-checking to validate reconfigurable architectures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lanoix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dormoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kouchnarenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">279</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="43" to="57" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Towards specification, modelling and analysis of fault tolerance in self managed systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Maibaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 International Workshop on Self-adaptation and Self-managing Systems, SEAMS &apos;06</title>
		<meeting>the 2006 International Workshop on Self-adaptation and Self-managing Systems, SEAMS &apos;06<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="30" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A multi-level model for selfadaptive systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Merelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Paoletti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tesei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Kokash and Ravara</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="112" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Towards ASM-based formal specification of self-adaptive systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scandurra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Y</forename><forename type="middle">A</forename><surname>Ameur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Schewe</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">8477</biblScope>
			<biblScope unit="page" from="204" to="209" />
			<date type="published" when="2014">2014</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Formal modeling self-adaptive serviceoriented applications</title>
		<author>
			<persName><forename type="first">E</forename><surname>Riccobene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scandurra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SAC 2015, 30 th ACM Symposium on Applied Computing, Service-Oriented Architecture and Programming</title>
		<meeting>ACM SAC 2015, 30 th ACM Symposium on Applied Computing, Service-Oriented Architecture and Programming</meeting>
		<imprint>
			<publisher>SOAP) Track</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On interacting control loops in self-adaptive systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vromant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weyns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Andersson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering for Self-Adaptive Systems, SEAMS 2011</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">A survey of formal methods in self-adaptive systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Weyns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">U</forename><surname>Iftikhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>De La Iglesia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ahmad</surname></persName>
		</author>
		<editor>B. C. Desai, E. Vassev, S. P. Mudur, and B. C. Desai</editor>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="67" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">FORMS: a formal reference model for self-adaptation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Weyns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Andersson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICAC</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Parashar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">J O</forename><surname>Figueiredo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Kiciman</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="205" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On patterns for decentralized control in self-adaptive systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Weyns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Schmerl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Grassi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mirandola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Prehofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wuttke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Andersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Göschka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering for Self-Adaptive Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>De Lemos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Müller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">7475</biblScope>
			<biblScope unit="page" from="76" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Model-based development of dynamically adaptive software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H C</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Software Engineering, ICSE &apos;06</title>
		<meeting>the 28th International Conference on Software Engineering, ICSE &apos;06<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="371" to="380" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
