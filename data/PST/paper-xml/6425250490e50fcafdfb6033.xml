<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Transparent Runtime Change Handling for Android Apps</title>
				<funder ref="#_EZKFVjX">
					<orgName type="full">Research Grants Council of the Hong Kong Special Administrative Region, China</orgName>
				</funder>
				<funder ref="#_quHhe8F #_sej2N7E #_MqAQEpB">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zizhan</forename><surname>Chen</surname></persName>
							<email>chenzz@cse.cuhk.edu.hk</email>
							<affiliation key="aff0">
								<orgName type="institution">The Chinese University of Hong</orgName>
								<address>
									<settlement>Kong Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zili</forename><surname>Shao</surname></persName>
							<email>shao@cse.cuhk.edu.hk</email>
							<affiliation key="aff1">
								<orgName type="institution">The Chinese University of Hong</orgName>
								<address>
									<settlement>Kong Hong Kong</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Transparent Runtime Change Handling for Android Apps</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3582016.3582060</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>mobile systems</term>
					<term>embedded systems</term>
					<term>operating systems</term>
					<term>runtime configuration change handling</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Mobile devices often face runtime configuration changes, such as screen orientation changes, screen resizing, and language switching. The current Android design adopts a restarting-based solution to load the corresponding resources according to the new configuration. Therefore, application developers must explicitly deal with state preservation and restoration brought about by the activity restarting. Otherwise, the runtime change will cause state loss and even app crash issues. To solve the runtime change handling issues, we propose RCHDroid, a transparent runtime change handling approach for apps at the Android system level. When a configuration change occurs, we do not restart the activity, but instead, create a new activity according to the new configuration and migrate states from the old one to the new one, while putting the old activity into an inactive mode. We propose a lazy-migration scheme to handle asynchronous tasks that remain working on the old activity, which migrates the result events when the asynchronous tasks return. We have implemented a prototype of RCHDroid with real hardware and released the source code for public access. Overall, using RCHDroid, existing apps can handle runtime configuration changes without any modifications and save the runtime change handling time by 25.46%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>? Computer systems organization ? Embedded software; ? Human-centered computing ? Ubiquitous and mobile computing systems and tools; Mobile devices.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Mobile devices, such as smartphones and tablets, are highly portable and often require configuration changes to handle scenario changes, such as screen rotation, keyboard attachment, and language switching <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b36">37]</ref>. For example, on average, users change device orientations every 5 mins accumulatively over sessions of the same app <ref type="bibr" target="#b8">[9]</ref>. When these changes occur at runtime (i.e., while the user is using an app in the foreground), configuration changes made by the Android system are called runtime changes or runtime configuration changes. Such runtime changes, if not handled properly, will mess up the display or even crash the app, which directly influences the user experience. Therefore, efficient runtime change handling is important and requires careful management.</p><p>To solve the runtime change handling issues, there are two existing directions: First, the Android-App way <ref type="bibr" target="#b15">[16]</ref>, i.e., a passive restarting-based runtime change handling scheme of the current Android design, pushes the responsibility of handling runtime configuration changes to app developers. Second, the Static-Analysis way <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b33">34]</ref>, i.e., a static app-analysis-based approach that helps app developers to build apps with reduced implementation complexity to handle the runtime change issues.</p><p>With the Android-App way, as shown in Fig. <ref type="figure" target="#fig_0">1</ref> (a), the current Android design adopts a passive restarting-based runtime change handling scheme, which makes the runtime changes handling become challenging and error-prone for app developers. If app developers do not explicitly declare to handle the runtime change by themselves and implement callback functions, the Android system will destruct the current activity instance, release the resources, and then restart an activity instance according to the new configuration. Such restarting is usually unexpected by app developers (e.g., as shown in <ref type="bibr" target="#b8">[9]</ref>, 92.4% of app developers are unaware of the restarting during the runtime change and choose the restarting-based runtime change handling), which can cause a series of serious runtime issues, ranging from state loss to app crashes <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b33">34]</ref>. As shown in Fig, <ref type="figure" target="#fig_0">1</ref> (a), an app developer starts an asynchronous task to update a view in the activity and does not realize that the asynchronous task needs to be stopped when a configuration change occurs. Then, after restarting, when the asynchronous task is completed and returned, the original views have been destructed, which will cause NullPointer or WindowLeaked exceptions and crash the app.</p><p>For the Static-Analysis way, the existing works follow a static app-analysis-based approach to help app developers to make their apps aware of the runtime changes during the app development. KREfinder <ref type="bibr" target="#b33">[34]</ref> aims to identify the data to be saved and restored during activity restarts. RuntimeDroid <ref type="bibr" target="#b8">[9]</ref> provides an automatic patch tool to help app developers to implement runtime change handling functions and reconstruct the view tree without restarting their apps. However, the static app-analysis-based approach has three limitations. First, since the data to be saved is determined by the app logic, a static code analysis may fail to identify the proper set of data, thus generating false positives. Second, since the view tree construction depends on the app logic, a generic app analysis may not properly restore a complex view tree without knowing the app logic. Third, as most apps handle the runtime change based on the default Android restarting-based scheme, all of them need to be redeveloped following the static app-analysis-based approach, which incurs tremendous time and cost.</p><p>In this paper, we for the first time propose a new Android-System way to handle the runtime change issues at the Android system level. The Android-System way brings twofold benefits. First, the runtime change handling will be automatically conducted by the system, and thus become transparent to app developers. Second, it is more feasible to handle the runtime changes at the system level, since activity instances and system services can be directly controlled to conduct management.</p><p>Following the Android-System way, we propose RCHDroid, a transparent Runtime Change Handling approach for Android apps. The root of the problem to be solved is that an activity instance will be restarted and states are released during the restarting-based runtime change handling. Since most app developers do not expect this restart, they will not save the state and stop the asynchronous task in time, which will then cause state loss issues and app crash exceptions. To address this, inside the Android framework, we propose a new shadow state, in which the activity instance is not visible but still alive. When a runtime change happens, we do not kill the original activity instance but instead, put it into the shadow state (see Fig. <ref type="figure" target="#fig_0">1 (b)</ref>). In the meantime, we create a new foreground activity instance, called sunny-state activity, based on the new configuration. When the shadow-state activity's view tree is changed due to the asynchronous task return, the view tree of the sunny-state activity will be changed accordingly.</p><p>There are three challenges in implementing RCHDroid. First, as we aim to transparently handle the runtime change at the system level, apps are treated as black-boxes, that is, we will not predict the internal logic of apps and how the view tree is controlled. For instance, when asynchronous tasks finish, we will not predict what operations are done by apps and how the view tree is updated. Second, the runtime change handling performance should be optimized. Since RCHDroid starts a new activity instance when a runtime change happens, which may influence the runtime change handling time. Third, RCHDroid should introduce minimum overhead to the current Android system. Specifically, since we maintain two activity instances after a runtime change happens, the memory pressure of the Android virtual machine should be considered.</p><p>To address these challenges, RCHDroid includes several novel designs. First, after an asynchronous task finish, we apply a lazymigration approach to migrate the effects of the view tree of the shadow-state activity to that of the sunny-state activity. The key observation is that although we cannot predict what operations will be done after the asynchronous task finishes, in the end, the result of these operations always needs to be updated to the view tree. We catch this update step and migrate the update operations to the view tree of the sunny-state activity. Second, we apply a coinflipping-based activity management approach to save the runtime change handling time. The current sunny-state activity is coupled with a shadow-state activity. When a runtime change happens, rather than creating another activity, we always attempt to find the coupled shadow-state activity and check whether it is still alive. If yes, we will flip the states of these two coupled activities, i.e., the shadow-state activity becomes the sunny-state activity, and vice versa. Third, to ease the memory pressure of the Android virtual machine, we propose a threshold-based garbage collection (GC) policy to reclaim the shadow-state activity based on its age and usage frequency.</p><p>We have implemented a fully functional prototype of RCHDroid on Android 10 and evaluated it with real hardware. A series of experiments have been conducted to evaluate RCHDroid with benchmarks and real apps. Experimental results show that with RCHDroid, existing apps can handle runtime changes without any modifications. Compared with the restarting-based runtime change handling, RCHDroid can reduce the average runtime change handling latency by 25.46%.</p><p>In summary, we make the following contributions:</p><p>? We propose a novel approach, in which we add two new states inside the Android framework to manage activity instances during runtime changes. To the best of our knowledge, this is the first work to address the runtime change handling issues transparently at the Android system level. ? We propose several novel techniques (e.g., lazy-migration, coin-flipping-based activity management, and threshold-based GC) to migrate the view tree for asynchronous tasks during runtime changes with minimum modifications to the Android framework while reducing the time and memory space. ? We implement a fully functional prototype of RCHDroid with real hardware. The source code, the prototype implementation, and the detailed evaluation have been released for public access.</p><p>? Compared with RuntimeDroid <ref type="bibr" target="#b8">[9]</ref>, which requires thousands of lines of code modifications for an app, RCHDroid requires no modifications to apps.</p><p>The following sections are arranged as follows: ? 2 introduces the background and motivation. ? 3 presents the RCHDroid design and techniques. ? 4 describes the implementation of RCHDroid. ? 5 evaluates RCHDroid with benchmarks and real apps. In ? 6, to demonstrate the prevalence of the runtime change issues in current popular apps, we conduct another evaluation with the top 100 apps of the Google Play store. Finally, ? 7 and ? 8 present the related works and conclude the paper, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND AND MOTIVATION</head><p>This section gives a brief introduction to Android activity management. We further analyze the runtime change issues and motivate RCHDroid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Android Activity Management</head><p>In the Android system, an activity describes an interface which users can interact with. As shown in Fig. <ref type="figure" target="#fig_1">2</ref> (a), each app is running in a process. An app has an activity thread, i.e., the user interface (UI) thread, which is responsible for updating the interface. The app is free to create other threads (i.e., Async Threads) to conduct asynchronous time-consuming works in parallel with the activity thread, such as image loading and network accessing. However, updating the user interface can only be done by the activity thread for safety issues <ref type="bibr" target="#b41">[42]</ref>. The activity thread can maintain multiple activity instances, and each activity instance is corresponding to an interface. The activity instance contains the app states and a view tree, which describes what should be displayed on the interface. The root of the view tree is called decor view, a special view group that contains views and other view groups.</p><p>The android system has a system server that controls the lifecycle of apps <ref type="bibr" target="#b11">[12]</ref>. As shown in Fig. <ref type="figure" target="#fig_1">2</ref> (b), the system server runs an activity task manager service (ATMS), which maintains the activity stack. The activity stack maintains a set of task records, each representing a task, i.e., an app. The topmost task represents the app that is currently running in the foreground. Each task itself also maintains a task stack, which contains a set of activity records. Each activity record corresponds to an activity instance in the activity thread. The topmost activity record represents the current interface. The system server controls the life-cycle of activity instances through inter-process communications (IPCs). When creating a new activity from an existing activity instance, the request is first handled by the activity thread. The activity thread then sends a message to the ATMS, which searches its activity stack and task records to see whether the new activity record already exists. If found, the ATMS will reorder the corresponding task record and activity record to the top of the activity stack and the task stack, respectively. Otherwise, the ATMS will create a new task record and a new activity record, and then push them to the activity stack and the task stack, respectively. After that, the activity record token will be sent back to the activity thread, which creates and initializes the activity instance correspondingly.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Limitations of the Static-Analysis Way</head><p>The static app-analysis-based approach has three limitations. First, since the data to be saved is determined by the app logic, a static code analysis may fail to identify the proper set of data, thus generating false positives. For instance, for the KREfinder <ref type="bibr" target="#b33">[34]</ref>, across the 114 apps with potential errors, there were 2.3 false-positive reports per app, on average. Second, since the view tree construction depends on the app logic, a generic app analysis may not properly restore a complex view tree without knowing the app logic. For instance, to restore a view, RuntimeDroid <ref type="bibr" target="#b8">[9]</ref> needs to insert an assignment with the corresponding reference right before the view is used (e.g., p=getString(R.string.hello)). For simple apps, all of the view assignments are performed in the onCreate function, and the views are also statically defined in one resource file (e.g., main.xml). However, for more complex apps, the view assignments are distributed among multiple classes and are highly dynamic. For example, with the fragment activity <ref type="bibr" target="#b13">[14]</ref>, the views are distributed and assigned in different fragments. The fragments can be dynamically attached to the main activity, which causes dynamic changes to the view tree. The views can also be dynamically generated by code, which is not defined in the resource file. Thus, the assignment insertion of RuntimeDroid cannot handle these situations. Third, as most apps handle the runtime change based on the default Android restarting-based scheme, all of them need to be redeveloped following the static app-analysis-based approach, which incurs tremendous time and cost. For instance, as shown in <ref type="bibr" target="#b8">[9]</ref>, 92.4% of app developers choose the default restarting-based runtime change handling. Our evaluation of the top 100 apps from Google Play <ref type="bibr" target="#b14">[15]</ref> also shows that 74% of the top popular apps are based on the default restarting-based runtime change handling. Thus, for most apps, redevelopment is required following the static app-analysis-based approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Motivation</head><p>The current Android design by default adopts a passive restartingbased runtime change handling scheme, which can cause three issues as listed below <ref type="bibr" target="#b8">[9]</ref>:</p><p>? App Crash: An app starts an asynchronous task on another thread before the runtime change happens. After the asynchronous task finishes and the activity thread tries to update the view tree, as the original activity instance has been deconstructed and the view tree has been released during the runtime change, it causes NullPointer and WindowLeaked exceptions and crashes the app. ? Poor Responsiveness: Since the activity will be restarted and new resources must be loaded, the user interface will be frozen during this period and cannot respond to user interactions. ? State Loss: Since the activity instance will be deconstructed and a new instance will be constructed based on the new configuration, the states of the old activity instance will be lost if not stored in time. All of the above issues are caused by the activity restarting during the runtime change, i.e., the old activity instance is quickly destroyed and all related states and views are released. Based on this observation, we propose RCHDroid, a transparent runtime change handling scheme without restarting the activity, to address the above issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RCHDROID</head><p>RCHDroid is a novel app development framework (see ? 3.1) and cooperates with the existing Android system to provide transparent runtime change handling. Most importantly, it requires no modifications for apps running atop Android. Specifically, RCHDroid includes the following changes to the Android framework: two new states to enable the activity to keep alive after a runtime change (see ? 3.2), a lazy-migration-based view tree migration scheme (see ? 3.3), a coin-flipping-based activity stack management scheme (see ? 3.4) and a garbage collection policy (see ? 3.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design Overview</head><p>RCHDroid works with the Android system to handle the runtime change and reuse most of the existing infrastructure with minimum modifications. As shown in Fig. <ref type="figure" target="#fig_2">3</ref>, the runtime change handling of RCHDroid is a joint task done by both the activity thread and the ATMS. Shadow State. When a runtime change happens, the ATMS will send the new configuration to the activity record, which applies the new configuration and determines whether the current activity instance should be restarted. Since RCHDroid aims to provide a transparent runtime change migration, we skip this test and always prevent restarting the activity instance. Then, the configuration change message will be sent to the activity thread. Inside the activity thread, we change the current activity instance into the shadow state (see ? 3.2) and request to start a corresponding sunny-state activity based on the new configuration (Step ? in Fig. <ref type="figure" target="#fig_2">3</ref>).</p><p>Coin-Flipping. The activity creation request will be sent to the ATMS, which correspondingly changes the state of the activity record on the system server. If it is the first-time runtime change, we will create a new activity record and push it onto the stack of the current task inside the ATMS (Step ?). Otherwise, we will apply a coin-flipping-based activity record management scheme. Specifically, we will not create a new activity but search the current activity stack and see whether there exists a shadow-state activity that has not been garbage collected (see ? 3.5). Once found, we will reorder the shadow-state activity record to the top of the stack and change its state to the sunny state, and the current sunny-state activity will be flipped to the shadow sate in the meantime (see ? 3.4). Lazy-Migration. After that, the token of the new activity record will be sent back to the activity thread, inside which we create a new activity instance based on the new configurations and set it to the sunny state. During the creation period, we will apply a lazymigration-based view tree management scheme inside the activity thread. Specifically, the current states of the shadow-state activity will be stored and transferred to the sunny-state activity, and the view tree of the sunny-state activity will be mapped to the shadowstate activity (Step ?). As the activity may start an asynchronous task before the runtime change happens, after the asynchronous task finish, and before taking effect on the shadow-state activity, we catch the effect and migrate it to the corresponding view of the sunny-state activity based on the mappings (Step ?).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Activity States</head><p>Before explaining activity runtime change handling, we first recapitulate how activity functions work in general. As shown in Fig. <ref type="figure" target="#fig_3">4</ref>, when users touch the app icon, an activity starts. Each newlycreated activity is in the Created state. After doing the necessary initialization through the Created and Started states, the activity reaches the Resumed state to show on the screen and interacts with users. In case of an app swap, the activity goes to the background and enters the Paused state. If the app is no longer visible, the app will be put into the Stopped state and finally be destroyed in the Destroyed state. To migrate the activity safely, we add two new states that are invisible to users: a Shadow state and a Sunny state. As shown in Fig. <ref type="figure" target="#fig_3">4</ref>, if an activity is stopped with the shadow flag when the runtime configuration change happens, it goes into the Shadow state. A Shadow state activity is not visible to users but still alive and will not be destroyed by the Android system unless it is garbagecollected (see ? 3.5). When an activity enters the Shadow state, the activity thread will snapshot its states and store the state into a data bundle. The activity is still able to respond to asynchronous task callbacks and modify its view tree accordingly.</p><p>When an activity is created and resumed with the sunny flag, it goes into the Sunny state. A Sunny state activity is shown in the foreground and visible to users, which is equivalent to the Resumed state in most cases. The only difference is that, in the Sunny state, the view tree of the activity should respond to changes of the shadow-state activity's view tree and make modifications accordingly (see ? 3.3).</p><p>Note that we maintain at most one shadow-state activity instance for the whole Android system at any time, which is coupled with the current foreground Activity instance. This is reasonable since the shadow-state activity is still alive and will stay in the memory, which incurs memory overhead. Only the current foreground Activity instance, which faces runtime change issues, should be coupled with a shadow-state activity instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">View Tree Migration</head><p>There are two considerations when migrating a view tree. First, the view tree state of the current activity just before the runtime change happens must be stored and recovered on the new view tree. Second, the future view tree changes due to an asynchronous task return should also be reflected on the new view tree. The challenge is we cannot foresee what operations will be conducted when an asynchronous task returns since it is up to the app logic.</p><p>We address the first issue by exploiting the application programming interface (API) onSaveInstanceState provided by Android. We explicitly call this API to save the states of the shadow-state activity when a runtime configuration change happens, which will recursively call the save functions of each view in the view tree and save all view states into a bundle data structure. If app developers have implemented the save function to store the app-specific data, they will also be saved during this process. We then use this bundle to initiate the sunny-state activity, which goes through the app logic to build the view tree based on the new configuration and recover states of views based on the data stored in the bundle. By going  through the initialization states (i.e., Created and Started) with the saved activity instance states bundle, we recover the activity based on the new configuration without knowing the app logic.</p><p>We address the second issue by proposing a lazy-migration-based view tree management scheme. First, as shown in Fig. <ref type="figure" target="#fig_4">5</ref>, before the migration happens, we build an essence-based mapping between the shadow-state activity's view tree and the sunny-state activity's view tree. This is designed based on the observation that the runtime change only affects the appearance of views but essentially both of the trees still represent the same views. For instance, after transferring a smartphone from the portrait orientation to the landscape orientation, a button may have a different shape and display on a different position, but they are still the same button and use the same view id. Specifically, we build a hash table of view ids and view objects by traversing the sunny-state activity's view tree. Based on the hash table, we then traverse the shadow-state activity's view tree, and for each view, look up the hash table by its view id and store a pointer to the corresponding sunny-state view object.</p><p>Second, when asynchronous tasks finish and return, the task thread will send a message to the message queue of the activity thread since only the activity thread can update the view tree, which will trigger a callback function. Although the callback function is user-defined and we cannot predict the app logic, based on the observation that any updates to views will finally trigger a generic invalidate function, we catch the final update step and insert a migration step from the shadow-state activity's view tree to the sunny-state activity's view tree. Specifically, since essence-based mappings have been built before the migration, each view of the shadow-state activity's view tree stores the pointer of the corresponding view in the sunny-state activity's view tree. We first get the attributes of the shadow-state activity's views based on each view's type and then set the attributes to the corresponding view in the sunny-state activity's views through the mappings.</p><p>As shown in Table <ref type="table" target="#tab_2">1</ref>, we take different migration policies for different types of views. For instance, for the TextView typed views, such as EditText and Button, we get the text attribute of the shadowstate activity's TextView and call the setText function to update the sunny-state activity's TextView. For the AbsListView typed views, such as ScrollView and GridView, we migrate them by getting the selector position state and the selected item based on the shadow-state activity's views and set these states to the sunny-state activity's views. We have covered all basic types of views, which are the parent of other sub-types of views. User-defined views, which inherit from these basic view types, will also be migrated according to the types they belong to.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Activity Stack Management</head><p>The ATMS controls the global state of activities and triggers the lifecycle changes of each activity. There are two considerations when we handle a runtime change. First, the ATMS must distinguish the creation request of handling a runtime change from that of normal cases. Second, the ATMS needs to avoid creating a new activity record as much as possible since creating and initializing a new activity is time-consuming.</p><p>As shown in Fig. <ref type="figure" target="#fig_5">6</ref> (1), we address the first issue by extending the creation intent class of Android with a new sunny flag and modifying the creation steps of the ATMS to make it aware of this special type of creation requests. With a default flag (i.e., without a specific flag such as NEW_TASK or SINGLE_TOP), the ATMS avoids creating a new activity if the target activity to be created is the same as the current activity running on the top of the stack. This is because the current Android design assumes each activity should only have one instance, thus, creating one activity that is the same as itself will finish with creating nothing. However, since RCHDroid now assumes each activity can have two instances, that is, a shadowstate instance and a sunny state instance, we modify the ATMS to make it able to create a second instance event if the target activity to be created is the same as the current activity on the top of the stack. After creating the new activity record, we will push the new activity record to the same task stack as the current activity and change the state of the current activity record to the shadow state.</p><p>As shown in Fig. <ref type="figure" target="#fig_5">6</ref> (2), we address the second issue by proposing a coin-flipping-based activity record management scheme. The basic idea is that in order to avoid creating a new activity, we search the task stack of the current activity and attempt to find a shadowstate activity that is still alive; if found, we swap the shadow state of the shadow-state activity and the current activity, and flip the shadow-state activity to the top of the task stack. Specifically, we extend the activity record class with a new shadow state field and related interfaces to set and check the shadow state. We then insert a checking step before the normal creation steps of the ATMS, which traverses the task stack of the current activity and checks the shadow state of each activity record. Once found, the shadow-state  activity will be reordered to the top of the stack and the shadow state is removed, while the current activity will be set to a shadow state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Garbage Collection (GC)</head><p>As described in ? 3.2, RCHDroid introduces two new states to the activity life-cycle. Since a shadow-state activity will not be automatically killed by the Android system, the corresponding resources of the shadow-state activity need to be released and garbage-collected. We design a GC policy for the shadow-state activity based on two considerations. First, an activity instance that recently enters the shadow state should not be released. This is because, after a runtime change, the runtime configuration has a high probability to change back soon. Second, an activity that frequently enters and exits the shadow state should not be released.</p><p>We propose a threshold-based solution based on these two considerations. Specifically, we maintain two thresholds for the shadowstate activity instance in the activity thread: THRESH_T and THRE-SH_F. When a GC routine is triggered in the activity thread, we will check the time period since the last time the shadow-state activity enters the shadow state, which is denoted as shadow_time. We will also check how many times it enters the shadow state in the last k seconds period, which is denoted as shadow_frequency. A shadowstate activity whose shadow_time is longer than THRESH_T and shadow_frequency is less than THRESH_F will be garbage-collected. The detailed algorithm is shown in Algorithm 1. Specifically, we will compare the shadow-state activity's shadow_time and shadow_ frequency with the THRESH_T and THRESH_F, respectively. If both conditions are met, the shadow-state activity will be terminated and corresponding resources will be released.</p><p>Note that there is at most one shadow-state activity in the activity thread, which is coupled with the current foreground sunny-state activity instance. If the foreground activity instance is terminated or switched, the corresponding shadow-state activity will be released immediately. The GC will not impact user experience as it is performed in the background.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION</head><p>We have implemented the RCHDroid with minimum modifications to the Android system. As shown in Table <ref type="table" target="#tab_4">2</ref>, the total modifications introduced by RCHDroid have only 348 lines of code (LoC).</p><p>First, we modify the Activity class, the View class, and the ViewGroup class to implement the Sunny and Shadow states and view tree migration. Specifically, we modify the Activity class with only 81 LoC to add the Shadow and Sunny states and related functions to set and get these states. We add a function getAllSunnyViews to build the hash table of the sunny-state activity's view tree and set the view pointers of the shadow-state activity's view tree through setSunnyViews based on the hash table. We modify the View class with only 79 LoC. We add the Shadow and Sunny state and related access functions to the View class. We also add a sunny view pointer, which is null by default and will be set by the activity thread before the view tree migration. We modify the invalidate function of the View class to catch the update intent and trigger different migration functions based on the view type. We modify the ViewGroup class with only 12 LoC by adding two functions, dispatchShadowStateChanged and dispatchSunnyStateChanged, to help dispatch the Shadow and Sunny states along the view tree, respectively.</p><p>Second, we modify the Intent class and ActivityThread class to implement the runtime change handling and GC in the activity thread. Specifically, we modify the Intent class with only 4 LoC to add a sunny flag, which is used by the activity thread to request the ATMS to create a new activity when a runtime change happens. For the ActivityThread class, we add a current shadow-state activity pointer, a current sunny-state activity pointer, and related functions with only 91 LoC. We modify the performActivityConfigura-tionChanged function to request creating a new activity with the intent of the sunny flag when a runtime change happens, in which the old activity is set into shadow state, and the states of the shadowstate activity are also stored into a bundle at this time. We modify the performLaunchActivity function to load the states from the shadow-state activity's bundle and initialize the sunny-state activity. We modify the handleResumeActivity function to implement the view tree mapping. Moreover, we add a doGcForShadowIfNeeded function to implement the garbage collection.</p><p>Third, we modify the ActivityRecord class, the ActivityStack class, and the ActivityStarter class to implement the runtime change handling and activity stack management in the ATMS. We modify the ActivityRecord class with only 11 LoC to add the Shadow state and related functions. We also modify the ensureActivityConfiguration function to avoid relaunching the activity when a runtime change happens. We modify the ActivityStack class with only 29 LoC to add a findShadowActivityLocked function, which helps search the stack of a task to find a shadow-state activity record. We modify the ActivityStarter class with only 41 LoC to implement the coin-flipping-based activity record management scheme. We modify the startActivityUnchecked and setTaskFromIntentActivity functions, which will try to find a shadow-state activity in the stack of the current task. If found, we will reorder the shadow-state activity to the top of the stack and remove the shadow state of the activity record. Otherwise, we will create a new activity record and push it to the top of the stack. Finally, on success, the state of the current activity will be set to the Shadow state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION</head><p>In this section, we evaluate RCHDroid by answering the following questions:</p><p>? Is RCHDroid able to handle the runtime change issues?</p><p>(see ? 5.2) ? How do apps perform when they use RCHDroid? (see ? 5.3, ? 5.4, and ? 5.7) ? Does RCHDroid incur more overhead? (see ? 5.5 and ? 5.6) We compare RCHDroid with the state-of-art Android 10 system (denoted as Android-10) and RuntimeDroid <ref type="bibr" target="#b8">[9]</ref>. We distinguish RCH-Droid from RCHDroid-init that denotes RCHDroid during the first runtime handling without exiting shadow-state activity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experiment Setup</head><p>We conduct the experiments on the ROC-RK3399-PC-PLUS development board <ref type="bibr" target="#b35">[36]</ref>, which is equipped with a 6-core 2.0 GHz ARM 64-bit processor, an ARM Mali-T860 MP4 4-core GPU, 2GB dualchannel DDR3 memory, and 16GB eMMC. The operating system is Android 10 <ref type="bibr" target="#b10">[11]</ref>. The code of RCHDroid has been released for public access <ref type="bibr" target="#b45">[46]</ref>.</p><p>We conduct the experiments with two sets of apps. The first app-set contains 27 apps, which are able to run on the development board, from the TP-37 app-set <ref type="bibr" target="#b33">[34]</ref> that is reported to have the runtime change issues. We exclude 10 apps of TP-37 that are not able to run on the development board due to environment restrictions such as Bluetooth <ref type="bibr" target="#b18">[19]</ref>, NFC <ref type="bibr" target="#b19">[20]</ref> and Google Play <ref type="bibr" target="#b37">[38]</ref>. The second appset <ref type="bibr" target="#b45">[46]</ref> contains benchmark apps with different sizes of view trees to evaluate the performance and cost. In which each benchmark app's view tree contains a set of ImageViews and a Button view. The number of ImageViews is varied. When touching the button, an AsyncTask will be issued to update the ImageViews in five seconds.</p><p>For performance results, all reported numbers are the mean of at least five runs. The standard deviation in all cases is less than 5% of the mean. The runtime handling time is the time between the configuration change arriving at the ATMS and the corresponding activity resumed. The energy consumption is measured by a power meter, which shows the voltage and current of the development board in real time. The real-time CPU usage and memory usage data are collected from the Android Studio profiler tool <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Effectiveness</head><p>To show whether RCHDroid is able to handle the runtime change issues without any modifications to apps, we conduct the experiment on the 27 apps that have the runtime change issues. As shown in Table <ref type="table" target="#tab_5">3</ref>, RCHDroid addresses 25 out of 27 runtime issues of the apps thanks to the view tree migration scheme. When a runtime change happens, the current activity will not be killed and restarted, but only put into a shadow state. The states of the current activity will be explicitly stored into a bundle, which will be restored on the new sunny-state activity. All of the states of the views provided by Android will be automatically stored; for the user-defined states, if app developers have implemented the onSaveInstanceState function, they will also be explicitly stored and restored by RCHDroid during the runtime change. On the contrary, the user-defined states, if not stored in any views and app developers have not implemented the onSaveInstanceState function (App #9 and App #10 in Table <ref type="table" target="#tab_5">3</ref>), will be lost as with the current Android design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Performance</head><p>We evaluate the performance of RCHDroid in terms of the runtime change handling time, app memory usage, and CPU usage. Overall Performance. We measure the runtime handling time for RCHDroid and Android-10 on the first app-set with 27 apps,  The shadow-state activity will be reused, which avoids the creation of a new activity instance and the building of the essence-based mapping.</p><p>Memory Usage. We measure the memory usage for RCHDroid and Android-10 on the first app-set with 27 apps, and the experimental results are shown in Fig. <ref type="figure">8</ref>. Overall, RCHDroid incurs acceptable memory overhead. Specifically, the average memory usages of the apps running on RCHDroid and Android-10 are 53.53 MB and 47.56MB, respectively. The memory usage of RCHDroid is 1.12? of Android-10 on average. RCHDroid adopts a threshold-based GC policy (see ? 3.5) for the shadow-state activity, which will release the shadow-state activity that is not used recently and frequently. CPU/Memory Usage Trace. We measure the CPU and memory usage over time for the benchmark app with four ImageViews on RCHDroid and Android-10. As shown in Fig. <ref type="figure" target="#fig_8">9</ref>, when the first runtime change happens at 17 ms, the app CPU usages of Android-10 and RCHDroid reach 11% and 15%, respectively. RCHDroid slightly increases the CPU usage because it needs to build the view tree mappings. The button touch event happens at 67 ms, which is followed by the second runtime change at 79 ms. As shown in Fig. <ref type="figure" target="#fig_8">9</ref>, after the second runtime change, the app CPU usages of Android-10 and RCHDroid reach 11% and 12%, respectively. Note that the CPU usage of RCHDroid drops from 15% to 12% compared with the first runtime change, thanks to the coin-flipping-based activity management.</p><p>Note that the memory usage of Android-10 drops dramatically to 0 MB at 117 ms after the second runtime change. This is because the button touch event issues an AsyncTask at 67 ms, which triggers the updating of the ImageView at 117 ms. Since the current Android design restarts the activity instance to handle the runtime change, the old views are released. When the AsyncTask returns and triggers the updating of views, the app will throw the NullPointer exception and crash down. On the contrary, RCHDroid, with lazy-migration, successfully handles the second runtime change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Scalability</head><p>We measure the scalability of RCHDroid in terms of the runtime change handling time and view tree migration time.</p><p>Runtime Change Handling Time. To evaluate the runtime change handling scalability of RCHDroid, we measure the runtime change handling time for RCHDroid and Android-10 with the second app-set, which includes the benchmark apps with different numbers of views. As shown in Fig. <ref type="figure" target="#fig_9">10 (a)</ref>, as the number of views increases, the runtime handling time of RCHDroid remains unchanged, which is 89.2 ms and is smaller than that of Android-10, which is 141.8 ms. This is because RCHDroid avoids restarting the activity instance and reusing the shadow-state activity instance. The runtime handling time of RCHDroid-init increases from 154.6 ms to 180.2 ms with the number of views increasing. The reason is that RCHDroid needs to create a new sunny-state activity and migrate the states from the shadow-state activity to the sunny-state activity, so increasing  the number of views will increase the creation time and migration time. However, as discussed in ? 3.3, a hash-table-based solution is adopted to build the mappings, the time cost in RCHDriod-init is limited to O(n) (n is the number of views). Asynchronous View Tree Migration Time. We further evaluate the asynchronous view tree migration time of RCHDroid on the benchmark apps with different numbers of views. For Android-10, in which there is no the asynchronous view tree migration, we show the runtime change handling time as a comparison. As shown in Fig. <ref type="figure" target="#fig_9">10 (b)</ref>, with the number of views increasing, the asynchronous view tree migration time of RCHDroid increases linearly from 8.6 ms to 20.2 ms, which is much smaller than the runtime change handling time of Android-10.</p><formula xml:id="formula_0">2 0 2 1 2 2 2 3 2 4</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">GC Trade-Off</head><p>To find the optimal GC threshold parameters, we measure the runtime change handling time, the CPU overhead, and the memory overhead with different THRESH_T. For each round, we run the benchmark app with 32 ImageViews for ten minutes and conduct  six runtime changes per minute. We heuristically set THRESH_F as four times per minute based on the assumption that if a user changes the configuration four times per minute, it is frequent and the shadow-state activity has a high probability to be reused. As shown in Fig. <ref type="figure" target="#fig_10">11</ref>, as the THRESH_T increases, the runtime change handling time and CPU overhead decrease while the memory overhead increases. The reason is that a longer GC interval means the shadow-state activity instance can stay longer, so the runtime change can be handled by the coin-flip without creating a new instance with a shorter runtime change handling time and lower CPU overhead. On the other hand, since the shadow-state activity instance is kept in the memory, it increases the memory overhead. However, after the THRESH_T increases to 50 seconds and higher, it is shown that the latency, CPU overhead, and memory overhead remain unchanged. Thus, we set the THRESH_T as 50 seconds, which achieves the optimal trade-off between the runtime change handling performance and overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Energy Consumption</head><p>To evaluate whether RCHDroid introduces more energy consumption compared with Android-10, we measure the energy consumption of the development board on the first app-set with 27 apps. The energy consumption of RCHDroid remains unchanged and is 4.03 W after runtime changes happen for all of the 27 apps, which   is the same as that of Android-10. This is because although RCH-Droid introduces a shadow-state activity instance after the runtime change, the shadow-state activity is not shown in the foreground and remains in an inactive state, which will not incur any extra energy consumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Comparison with RuntimeDroid</head><p>We compare RCHDroid with the state-of-the-art RuntimeDroid with the apps shown in Table <ref type="table" target="#tab_6">4</ref> that are used for evaluation in <ref type="bibr" target="#b8">[9]</ref>. Runtime Change Handling Time. Fig. <ref type="figure" target="#fig_11">12</ref> shows the runtime change handling time comparison with RuntimeDroid. Since Run-timeDroid has not open-sourced its source code, we use the results presented in their paper <ref type="bibr" target="#b8">[9]</ref>. Compared with RCHDroid, Runtime-Droid is more efficient. This is because RuntimeDroid addresses the runtime change issues at the app level, which masks the restarting and adopts a dynamic-migration way.</p><p>Modifications to Apps. Although RuntimeDroid can save more runtime change handling time, it requires modifications to each app. As shown in Table <ref type="table" target="#tab_6">4</ref>, RuntimeDroid requires thousands of LoC modifications to apps, while RCHDroid requires no modifications to apps since we solve the runtime change issues at the Android system level.</p><p>Deployment Overhead. The total deployment time of RCH-Droid is 92,870 ms. For RuntimeDroid, although it does not need to deploy a new version of the Android system, it requires to apply a patch for each app, with the average patch time ranging from 12,867 ms to 161,598 ms. In contrast, by addressing the runtime change handling problem at the Android system level, RCHDroid requires no modifications to apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATION ON GOOGLE PLAY TOP 100 APPS</head><p>To demonstrate the prevalence of the runtime change issues in current popular apps, we conduct another set of experiments with the top 100 apps of the Google Play store. With the same experimental setting in ? 5.1, for each app in the top 100 apps of the Google Play store, we first install it on the evaluation board with RCHDroid and Android-10, respectively, then check whether or not the runtime change issues exist, and finally conduct performance comparison.</p><p>The experimental results are shown next, which are in line with the results in ? 5.2 and ? 5.3. Runtime Change Issues. To check whether the runtime change issues exist, for each app, when it is running in a state, we change screen sizes and observe if the state can be correctly restored. The experimental results are shown in Table <ref type="table" target="#tab_7">5</ref>, in which, it can be seen that the runtime change issues exist in 63% (i.e., 63 out of 100) of the apps, which are based on the default restarting-based runtime change handling. For the remaindering 37% (i.e., 37 out of 100) of the apps, the runtime change issues are not found, in which 26 apps explicitly declare to handle the runtime changes by themselves, and 11 apps utilize the default restarting-based handling.</p><p>Fig. <ref type="figure" target="#fig_13">13</ref> shows the specific runtime change issues with Twitter, Disney+, KJVBible, and Orbot (for other apps, see <ref type="bibr" target="#b44">[45]</ref>). As shown in Fig. <ref type="figure" target="#fig_13">13</ref> (a), when logging on to Twitter, the user name box content is lost after the restart caused by the configuration change. Fig. <ref type="figure" target="#fig_13">13</ref> shows that, when reading the privacy policy of Disney+, the scroll location is reset after the restart. Fig. <ref type="figure" target="#fig_13">13 (c</ref>) shows that, when taking a quiz on KJVBible, the timer is reset after the restart. Fig. <ref type="figure" target="#fig_13">13</ref> (d) shows that, when selecting the network bridge type in Orbot, the selected bridge method is reset to the default one after the restart.</p><p>Effectiveness. RCHDroid addresses 93.65% (i.e., 59 out of 63) for the runtime change issues thanks to the view tree migration scheme. By contrast, 4 out of 63 apps (i.e., App #2, #57, #66, and #70) cannot be solved by RCHDroid. The reason is that in these apps, the user-defined states are not stored in any views and there is no implementation of the onSaveInstanceState function, so the states will be lost as with the current Android design.</p><p>Performance. We evaluate the performance of RCHDroid with the 59 apps, whose runtime change issues can be solved by RCH-Droid, by comparing the runtime handling time and memory usage with Android-10.</p><p>The experimental results of the runtime handling time for RCH-Droid and Android-10 are shown in Fig. <ref type="figure" target="#fig_15">14</ref>    The experimental results of the memory usages for RCHDroid and Android-10 are shown in Fig. <ref type="figure" target="#fig_15">14 (b)</ref>. The average memory usage running on RCHDroid and Android-10 are 173.85MB and 162.28MB, respectively. Thus, the average memory overhead introduced by RCHDroid is 7.13% compared with Andriod-10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>We summarize and discuss existing works in this section, which includes static app analysis and persistent data bug analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Static App Analysis</head><p>Static app analysis <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b27">28]</ref> focuses on analyzing the code of apps, either from the source code or generated Android application package (APK), to find the bugs in apps. KREfinder <ref type="bibr" target="#b33">[34]</ref> aims to find the restarting issues and identify data to be saved and restored during the activity restarting through the static code analysis. However, since the data to be saved is determined by the app logic, static code analysis can only identify a set of data that probably needs to be saved, which incurs a high rate of false-positive. Runtime-Droid <ref type="bibr" target="#b8">[9]</ref> provides an automatic patch tool to help app developers to implement runtime change handling functions and reconstruct the view tree without restarting their apps. However, as the view tree depends on both the resource and app logic, a generic patch tool can only reconstruct a simple view tree according to the layout file. With more complex views it is not practical to restore the view tree without knowing the app code. Amalfitano et al. <ref type="bibr" target="#b1">[2]</ref> study orientation changes and corresponding issues due to orientation changes. They use the record-and-playback technique to match the GUI after a double-orientation event and identify several types of GUI state loss issues, such as dialog, menu, and view state loss. However, they only focus on finding the issues and do not provide solutions. Different from these works, RCHDroid solves the runtime change handling issues at the Android system level and requires no modifications to apps.</p><p>Another series of studies focus on finding the potential app bugs by injecting events through the event injecting technology <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b38">39]</ref>. AppDoctor <ref type="bibr" target="#b22">[23]</ref> aims to find the potential restarting-based runtime change handling issues by injecting events. Zaeem et al. <ref type="bibr" target="#b42">[43]</ref> provide a mobile app testing tool by deriving test cases from GUI models and interactions. The tool compares the GUI state before and after the interaction, including screen rotation and restart, with an attempt to find runtime change issues caused by these interactions. Adamsen et al. <ref type="bibr" target="#b0">[1]</ref> test apps by injecting neutral event sequences such as pause-resume, pause-stop-restart, and pause-stop-destroycreate. However, these works also focus on finding the rotate-based runtime change issues instead of handling these issues. Other existing works on static app analysis focus on the issues that are not closely related to the runtime change issues, such as detecting bugs related to race conditions and energy bugs <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b43">44]</ref>, network and location data <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b25">26]</ref>, and performance <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b28">29]</ref> and memory leak <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b39">40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Persistence Bug Analysis</head><p>Besides the works focusing on analyzing the issues related to runtime change and data restoring within the scope of mobile apps, there have been studies on finding persistent data bugs such as in file systems <ref type="bibr" target="#b31">[32]</ref> and databases <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b32">33]</ref>. For instance, Yang et al. <ref type="bibr" target="#b40">[41]</ref> propose a model checking technique to find bugs in filesystem code. Gunawi et al. <ref type="bibr" target="#b16">[17]</ref> propose a declarative specification-based checker to check and repair filesystem integrity. Subramanian et al. <ref type="bibr" target="#b34">[35]</ref> study the impact of disk data corruption on database integrity.</p><p>These works, however, cannot be applied to solve the runtime handling issues of mobile apps. Particularly, within mobile systems such as Android, configuration changes happen mostly at the runtime when apps are actively running in the foreground. Thus, they cannot be detected with persistent data bug analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>In this paper, we propose RCHDroid to transparently solve the runtime change handling issues for Android apps. Instead of restarting the activity to handle the runtime change, RCHDroid proposes two new states, shadow and sunny, and puts the activity into a shadow state and transparently migrates the states from the shadow-state activity to a sunny-state activity, which fits the new configuration. We propose a lazy-migration technique to migrate the results of asynchronous tasks. We have implemented a fully functional prototype of RCHDroid on Android 10 and evaluated it with real hardware. Experimental results show that with RCHDroid, existing apps can handle runtime changes without any modifications. Compared with the restarting-based runtime change handling, RCHDroid can greatly reduce the runtime change handling latency.</p><p>Users can reproduce the CPU and memory usage over time with the benchmark app in Figure <ref type="figure" target="#fig_8">9</ref> as follows:</p><p>? Users can load the benchmark app source code into the Android Studio. The app can run on the development board through the ADB. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Comparison of current restarting-based runtime change handling and proposed transparent runtime change handling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Android activity management.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Design overview of RCHDroid.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Activity state diagram. Boxes drawn by solid lines represent the activity life cycle of Android, and those drawn by dotted lines represent the newly added states of RCHDroid for runtime handling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: View tree migration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Activity stack management.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Runtime change handling time comparison of RCH-Droid and Android-10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure</head><label></label><figDesc>Figure Memory usage comparison of RCHDroid andAndroid-10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Comparison of CPU and memory usages over time between RCHDroid and Android-10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Scalability of RCHDroid. (a) Runtime handling time with different numbers of views. (b) Asynchronous view tree migration time with different numbers of views.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: GC trade-off. (a) Runtime handling time with different THRESH_T. (b) CPU and memory overhead with different THRESH_T.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Runtime change handling time comparison between RuntimeDroid and RCHDroid. Bars show the runtime handling time normalized with Android-10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: The runtime change issue examples. Red boxes mark out the runtime change issues. (a) The name box content is lost after the restart. (b) The scroll location is reset after the restart. (c) The timer is reset after the restart. (d) The selected network bridge is reset after the restart.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>(a). The average runtime handling times of RCHDroid and Android-10 are 250.39ms and 420.58ms, respectively. Compared with Android-10, RCHDroid saves 38.60% runtime change handling time on average. Compared with RCHDroid-init, RCHDroid saves 44.96% runtime change handling time on average, thanks to the coin-flipping-based activity stack management scheme (see ? 3.4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Comparison of RCHDroid and Android-10. (a) Runtime change handling time. (b) Memory usage.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>?</head><label></label><figDesc>Users can use the profiler tool of Android Studio to monitor memory usage and CPU usage over time. ? Users can trigger the first runtime change by the command through ADB: wm size 1080x1920. ? Users can touch the button to update the views. The views updating is asynchronous, during which, users should trigger the second runtime change by the command through ADB: wm size reset. Users can reproduce the runtime change handling time with different numbers of views of RCHDroid in Figure 10 as follows: ? Users can load the benchmark app source code into the Android Studio. The app can run on the development board through the ADB. ? The number of views can be changed. Users can modify src/main/java/.../MainActivity.java, src/main/res/layout-land /activity_main.xml, and src/main/res/layout-port/activity_ main.xml to change the view number. ? Users can trigger the runtime change by the commands through ADB: wm size 1080x1920 and wm size reset. The runtime change handling time will be saved in the log. Users can print the related logs by the command through ADB: logcat | grep "zizhan". The runtime change handling time is the time between the configuration change happened and the activity resumed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Migration policy based on view types.</figDesc><table><row><cell>View Type</cell><cell>Description</cell><cell>Migration Policy</cell></row><row><cell>TextView</cell><cell>Displays text to the user</cell><cell>setText</cell></row><row><cell>ImageView</cell><cell>Displays image resources</cell><cell>setDrawable</cell></row><row><cell>AbsListView</cell><cell cols="2">Displays a scrollable collection of positionSelector views setItemChecked</cell></row><row><cell>VideoView</cell><cell>Displays a video file</cell><cell>setVideoURI</cell></row><row><cell cols="3">ProgressBar Indicates progress of an operation setProgress</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>RCHDroid implementations and modifications.</figDesc><table><row><cell cols="2">No. Classes</cell><cell>Implementations and Modifications</cell><cell>LoC</cell></row><row><cell></cell><cell>Activity</cell><cell>Add the Shadow/Sunny state and related functions.</cell><cell>81</cell></row><row><cell>1</cell><cell>View</cell><cell>Add the Shadow/Sunny state and the view pointer; Modify the invalidate function.</cell><cell>79</cell></row><row><cell></cell><cell>ViewGroup</cell><cell>Add the dispatch function for the Shadow/Sunny state.</cell><cell>12</cell></row><row><cell></cell><cell>Intent</cell><cell>Add the sunny flag.</cell><cell>4</cell></row><row><cell>2</cell><cell>ActivityThread</cell><cell>Add shadow-state and sunny-state views, GC routine; Modify the runtime change, launch and resume functions.</cell><cell>91</cell></row><row><cell>3</cell><cell>ActivityRecord ActivityStack</cell><cell>Add the Shadow state and related interfaces; Modify the configuration change handling function. Add the shadow-state activity look up function.</cell><cell>11 29</cell></row><row><cell></cell><cell cols="2">ActiivtyStarter Modify activity start related functions.</cell><cell>41</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Results of 27 apps running on RCHDroid.</figDesc><table><row><cell cols="2">No. App Name</cell><cell cols="2">Downloads[15] Issues of Current Android Design</cell><cell>RCHDroid</cell></row><row><cell>1</cell><cell>AlarmClockPlus</cell><cell>5M+</cell><cell>The alarm state is lost after restart</cell><cell>?</cell></row><row><cell>2</cell><cell>AlarmKlock</cell><cell>500K+</cell><cell>The alarm time change is gone after restart</cell><cell>?</cell></row><row><cell>3</cell><cell>AndroidToken</cell><cell>5M+</cell><cell>The selected token is lost after restart</cell><cell>?</cell></row><row><cell>4</cell><cell>BlueNET</cell><cell>500K+</cell><cell>The server is unexpectedly turned off after restart</cell><cell>?</cell></row><row><cell>5</cell><cell>BrightnessProfile</cell><cell>5M+</cell><cell>Brightness level is lost after restart</cell><cell>?</cell></row><row><cell>6</cell><cell>BTHFPowerSave</cell><cell>500K+</cell><cell>State changes are lost after restart</cell><cell>?</cell></row><row><cell>7</cell><cell>CalenMob</cell><cell>10K+</cell><cell>The working date resets to current date after restart</cell><cell>?</cell></row><row><cell>8</cell><cell>DateSlider</cell><cell>10K+</cell><cell>The chosen date is lost after restart</cell><cell>?</cell></row><row><cell>9</cell><cell>DiskDiggerPro</cell><cell>100K+</cell><cell>The percentage set by the user is lost after restart</cell><cell>?</cell></row><row><cell cols="2">10 Dock4Droid</cell><cell>10K+</cell><cell>The last-added app is missing after restart</cell><cell>?</cell></row><row><cell cols="2">11 DrWebAntiVirus</cell><cell>100M+</cell><cell>The check box setting is lost after restart</cell><cell>?</cell></row><row><cell cols="2">12 Droidstack</cell><cell>100K+</cell><cell>The title is not preserved after restart</cell><cell>?</cell></row><row><cell cols="2">13 FoxFi</cell><cell>10M+</cell><cell>The entered email is lost after restart</cell><cell>?</cell></row><row><cell cols="2">14 MOBILedit</cell><cell>1K+</cell><cell>The WiFi settings are not retained after restart</cell><cell>?</cell></row><row><cell cols="2">15 OIFileManager</cell><cell>5M+</cell><cell>The last-opened path is lost after restart</cell><cell>?</cell></row><row><cell cols="2">16 OpenSudoku</cell><cell>1M+</cell><cell>User-filled numbers are lost after restart</cell><cell>?</cell></row><row><cell cols="2">17 OpenWordSearch</cell><cell>1M+</cell><cell>The word filled by user is lost after restarts</cell><cell>?</cell></row><row><cell cols="2">18 WorkRecorder</cell><cell>5K+</cell><cell>The workout start time is lost after restart</cell><cell>?</cell></row><row><cell cols="2">19 PowerToggles</cell><cell>10K+</cell><cell>The notification widgets are lost after restart</cell><cell>?</cell></row><row><cell cols="2">20 PhoneCopier</cell><cell>10K+</cell><cell>The email address is lost after restart</cell><cell>?</cell></row><row><cell cols="2">21 ScrambledNet</cell><cell>10K+</cell><cell>The game state is lost after a restart</cell><cell>?</cell></row><row><cell cols="2">22 ScrollableNews</cell><cell>1K+</cell><cell>The color selection is lost after restart</cell><cell>?</cell></row><row><cell cols="2">23 ServDroidWeb</cell><cell>1K+</cell><cell>The new status is gone after restarts</cell><cell>?</cell></row><row><cell cols="2">24 SouveyMusicPro</cell><cell>1K+</cell><cell>The settings of Metronome are lost after restart</cell><cell>?</cell></row><row><cell cols="2">25 SSHTunnel</cell><cell>100K+</cell><cell>SSH connection profile is lost upon restart</cell><cell>?</cell></row><row><cell cols="2">26 VPNConnection</cell><cell>1K+</cell><cell>The IPSec ID is lost upon restart</cell><cell>?</cell></row><row><cell cols="2">27 ZircoBrowser</cell><cell>1K+</cell><cell>Bookmark is lost after restart</cell><cell>?</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>RuntimeDroid modification to apps (Line of Code).</figDesc><table><row><cell>Apps</cell><cell cols="3">Android-10 RuntimeDroid Modifications</cell></row><row><cell>Mdapp</cell><cell>26,342</cell><cell>28,419</cell><cell>2077</cell></row><row><cell>Remindly</cell><cell>6,966</cell><cell>7,820</cell><cell>854</cell></row><row><cell>AlarmKlock</cell><cell>2,838</cell><cell>3,610</cell><cell>772</cell></row><row><cell>Weather</cell><cell>10,949</cell><cell>12,208</cell><cell>1259</cell></row><row><cell>PDFCreator</cell><cell>19,624</cell><cell>20,895</cell><cell>1271</cell></row><row><cell>Sieben</cell><cell>20,518</cell><cell>22,123</cell><cell>1605</cell></row><row><cell>AndroPTPB</cell><cell>3,405</cell><cell>5,127</cell><cell>1722</cell></row><row><cell cols="2">VlilleChecker 12,083</cell><cell>12,843</cell><cell>760</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 :</head><label>5</label><figDesc>Runtime change issues in Google Play top 100 apps.</figDesc><table><row><cell cols="2">No. App Name</cell><cell>Downloads[15]</cell><cell cols="2">Runtime Change Specific Problem Issue (Yes/No)</cell></row><row><cell>1</cell><cell>AmazonPrimeVideo</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell>2</cell><cell>Filto</cell><cell>5M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell>3</cell><cell>TikTok</cell><cell>1B+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell>4</cell><cell>Instagram</cell><cell>1B+</cell><cell>No</cell><cell>No</cell></row><row><cell>5</cell><cell>WhatsApp</cell><cell>5B+</cell><cell>No</cell><cell>No</cell></row><row><cell>6</cell><cell>CashApp</cell><cell>50M+</cell><cell>No</cell><cell>No</cell></row><row><cell>7</cell><cell>DeepCleaner</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell>8</cell><cell>ZOOM</cell><cell>500M+</cell><cell>No</cell><cell>No</cell></row><row><cell>9</cell><cell>Disney+</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">10 Snapchat</cell><cell>1B+</cell><cell>Yes</cell><cell>State loss (login page)</cell></row><row><cell cols="2">11 AmazonShopping</cell><cell>500M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">12 Telegram</cell><cell>1B+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">13 TorBrowser</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">14 MaxCleaner</cell><cell>5M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">15 Messenger</cell><cell>5B+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">16 PeacockTV</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">17 WalmartShopping</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">18 McDonald's</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">19 Facebook</cell><cell>5B+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">20 NewsBreak</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">21 CapCut</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">22 QR&amp;BarcodeScanner</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (zoom bar)</cell></row><row><cell cols="2">23 MicrosoftTeams</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">24 Indeed</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">25 Tubi</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">26 SHEIN</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">27 TextNow</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (login page)</cell></row><row><cell cols="2">28 Twitter</cell><cell>1B+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">29 Wonder</cell><cell>1M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">30 Netflix</cell><cell>1B+</cell><cell>Yes</cell><cell>State loss (FAQ list)</cell></row><row><cell cols="2">31 AllDocumentReader</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">32 Roku</cell><cell>50M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">33 PlutoTV</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">34 DoorDash</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">35 Uber</cell><cell>500M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">36 Discord</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (register page)</cell></row><row><cell cols="2">37 Audible</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">38 Ticketmaster</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">39 Life360</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">40 Hulu</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">41 Orbot</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">42 MovetoiOS</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">43 DailyDiary</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">44 Yoshion</cell><cell>1M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">45 MSAuthenticator</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">46 PowerCleaner</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (report page)</cell></row><row><cell cols="2">47 SamsungSmartSwitch</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">48 Alibaba.com</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">49 Reddit</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">50 Paramount+</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">51 Lyft</cell><cell>50M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">52 Pinterest</cell><cell>500M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">53 OfferUp</cell><cell>50M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">54 BeReal</cell><cell>5M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">55 UberEats</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">56 FetchRewards</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">57 HaircutPrank</cell><cell>1M+</cell><cell>Yes</cell><cell>State loss (volume bar)</cell></row><row><cell cols="2">58 MyBath&amp;BodyWorks</cell><cell>1M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">59 Wholee</cell><cell>5M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">60 UltraCleaner</cell><cell>1M+</cell><cell>Yes</cell><cell>State loss (file number)</cell></row><row><cell cols="2">61 eBay</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">62 FacebookLite</cell><cell>1B+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">63 Adidas</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (product list)</cell></row><row><cell cols="2">64 Duolingo</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">65 BravoCleaner</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">66 CastForChrome</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">67 Waze</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">68 UltraSurf</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">69 PetDiary</cell><cell>500K+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">70 KingJamesBible</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">71 EmailHome</cell><cell>5M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">72 CapitalOne</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">73 Plex</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">74 DoordashDasher</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">75 Shop</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">76 Expedia</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">77 ESPN</cell><cell>50M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">78 Pandora</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">79 Picsart</cell><cell>500M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">80 FileRecovery</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (report page)</cell></row><row><cell cols="2">81 Callapp</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">82 Tinder</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">83 Etsy</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">84 SiriusXM</cell><cell>10M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">85 AliExpress</cell><cell>500M+</cell><cell>Yes</cell><cell>State loss (scroll location)</cell></row><row><cell cols="2">86 NFL</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">87 Adobe</cell><cell>500M+</cell><cell>Yes</cell><cell>State loss (login page)</cell></row><row><cell cols="2">88 KJVBible</cell><cell>100K+</cell><cell>Yes</cell><cell>State loss (timer state)</cell></row><row><cell cols="2">89 HomeDepot</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">90 TacoBell</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (location page)</cell></row><row><cell cols="2">91 UberDriver</cell><cell>100M+</cell><cell>Yes</cell><cell>State loss (login page)</cell></row><row><cell cols="2">92 Booking.com</cell><cell>500M+</cell><cell>Yes</cell><cell>State loss (text box)</cell></row><row><cell cols="2">93 CCFileManager</cell><cell>5M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">94 SpeedBooster</cell><cell>5M+</cell><cell>Yes</cell><cell>State loss (report page)</cell></row><row><cell cols="2">95 Firefox</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">96 Twitch</cell><cell>100M+</cell><cell>No</cell><cell>No</cell></row><row><cell cols="2">97 Target</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (check box)</cell></row><row><cell cols="2">98 SmartBooster</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (report page)</cell></row><row><cell cols="2">99 Bumble</cell><cell>10M+</cell><cell>Yes</cell><cell>State loss (selection list)</cell></row><row><cell cols="2">100 Wish</cell><cell>500M+</cell><cell>Yes</cell><cell>No</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>The work described in this paper is partially supported by the grants from the <rs type="funder">Research Grants Council of the Hong Kong Special Administrative Region, China</rs> (<rs type="grantNumber">GRF 14219422</rs>), and Direct Grant for Research, The <rs type="affiliation">Chinese University of Hong Kong</rs> (Project No. <rs type="grantNumber">4055151</rs>).</p></div>
<div><head>A.6 Evaluation and Expected Results</head><p>We expect the reproduced results for Figure 7, Figure 8, Figure 9, Figure <rs type="grantNumber">10</rs>, and Figure <rs type="grantNumber">14</rs> to match the results in the paper.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_EZKFVjX">
					<idno type="grant-number">GRF 14219422</idno>
				</org>
				<org type="funding" xml:id="_quHhe8F">
					<idno type="grant-number">4055151</idno>
				</org>
				<org type="funding" xml:id="_sej2N7E">
					<idno type="grant-number">10</idno>
				</org>
				<org type="funding" xml:id="_MqAQEpB">
					<idno type="grant-number">14</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A ARTIFACT APPENDIX A.1 Abstract</head><p>The artifact provides the source code of RCHDroid, along with the instructions to generate the results. The artifact allows users to reproduce key results from the paper, including Figure <ref type="figure">7</ref>, Figure <ref type="figure">8</ref>, Figure <ref type="figure">9</ref>, Figure <ref type="figure">10</ref>, and Figure <ref type="figure">14</ref>. The hardware must contain the ROC-RK3399-PC-PLUS development board <ref type="bibr" target="#b35">[36]</ref> connected to a screen. We provide compiled images to simplify the experiment workflow. Users can also build images from the source code.</p><p>A.2 Artifact Check-List (Meta-Information) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Installation</head><p>The artifact can be downloaded from https://doi.org/10.5281/zenodo.7583154. Users can follow the following steps to build the image from the source code. Users can also directly use the compiled images in the ./imgs folder.</p><p>? The Android 10 source code for the ROC-RK3399-PC-PLUS development board is compressed as Firefly-RK3399_Andro-id10.0_git_20210114.7z. Users can follow README to decompress the source code. ? Replace parts of the code of Android 10 with the code inside ./source-code to build RCHDroid. README inside ./sourcecode presents which parts should be replaced. ? Compile the image through the following commands:</p><p>./rk3399_Android10.0/FFTools/make.sh -d rk3399-roc-pcplus -j8 -l rk3399_roc_pc_plus-userdebug ./rk3399_Android10.0/FFTools/mkupdate/mkupdate.sh -l rk3399_roc_pc_plus-userdebug When the image is ready, users can flash the image to the ROC-RK3399-PC-PLUS development board through ./tools/RKDev-Tool. Before that, users should use ./tools/DriverAssitant to set up the USB driver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.5 Experiment Workflow</head><p>Users can reproduce the runtime change handling time with 27 apps in Figure <ref type="figure">7</ref> and memory usage in Figure <ref type="figure">8</ref>, and reproduce the runtime change handling time and memory usage with the Top 100 Android Apps in Figure <ref type="figure">14</ref> as follows:</p><p>? For each app, users should first start it in landscape mode (i.e., 1920x1080), and then wait a few seconds for the app to start up and enter a stable state. ? Users can measure the memory usage of the app before runtime changes by the following command: dumpsys meminfo.</p><p>Users can find the memory usage of the app in the Total PSS by process list. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Systematic execution of Android test suites in adverse conditions</title>
		<author>
			<persName><forename type="first">Christoffer</forename><surname>Quist Adamsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gianluca</forename><surname>Mezzetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>M?ller</surname></persName>
		</author>
		<idno type="DOI">10.1145/2771783.2771786</idno>
		<ptr target="https://doi.org/10.1145/2771783.2771786" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Symposium on Software Testing and Analysis</title>
		<editor>
			<persName><forename type="first">Michal</forename><surname>Young</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tao</forename><surname>Xie</surname></persName>
		</editor>
		<meeting>the 2015 International Symposium on Software Testing and Analysis<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015-07-12">2015. 2015. July 12-17, 2015</date>
			<biblScope unit="page" from="83" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Why does the orientation change mess up my Android application? From GUI failures to code faults</title>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Amalfitano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincenzo</forename><surname>Riccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><forename type="middle">C R</forename><surname>Paiva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><forename type="middle">Rita</forename><surname>Fasolino</surname></persName>
		</author>
		<idno type="DOI">10.1002/stvr.1654</idno>
		<ptr target="https://doi.org/10.1002/stvr.1654" />
	</analytic>
	<monogr>
		<title level="j">Softw. Test. Verification Reliab</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Do Memories Haunt You? An Automated Black Box Testing Approach for Detecting Memory Leaks in Android Apps</title>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Amalfitano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincenzo</forename><surname>Riccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Porfirio</forename><surname>Tramontana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><forename type="middle">Rita</forename><surname>Fasolino</surname></persName>
		</author>
		<idno type="DOI">10.1109/ACCESS.2020.2966522</idno>
		<ptr target="https://doi.org/10.1109/ACCESS.2020.2966522" />
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="12217" to="12231" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Modular performance modelling for mobile applications</title>
		<author>
			<persName><forename type="first">Niaz</forename><surname>Arijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reiko</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mirco</forename><surname>Tribastone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Gilmore</surname></persName>
		</author>
		<idno type="DOI">10.1145/1958746.1958793</idno>
		<ptr target="https://doi.org/10.1145/1958746.1958793" />
	</analytic>
	<monogr>
		<title level="m">ICPE&apos;11 -Second Joint WOSP/SIPEW International Conference on Performance Engineering</title>
		<editor>
			<persName><forename type="first">Samuel</forename><surname>Kounev</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vittorio</forename><surname>Cortellessa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Raffaela</forename><surname>Mirandola</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Lilja</surname></persName>
		</editor>
		<meeting><address><addrLine>Karlsruhe, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011-03-14">2011. March 14-16, 2011</date>
			<biblScope unit="page" from="329" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">R-Droid: Leveraging Android App Analysis with Static Slice Optimization</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Bugiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><surname>Derr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Gerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Hammer</surname></persName>
		</author>
		<idno type="DOI">10.1145/2897845.2897927</idno>
		<ptr target="https://doi.org/10.1145/2897845.2897927" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security</title>
		<editor>
			<persName><forename type="first">Xiaofeng</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Xiaofeng</forename><surname>Wang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Xinyi</forename><surname>Huang</surname></persName>
		</editor>
		<meeting>the 11th ACM on Asia Conference on Computer and Communications Security<address><addrLine>Xi&apos;an, China</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016-05-30">2016. 2016. May 30 -June 3, 2016</date>
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">EnergyPatch: Repairing Resource Leaks to Improve Energy-Efficiency of Android Apps</title>
		<author>
			<persName><forename type="first">Abhijeet</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lee</forename><forename type="middle">Kee</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cl?ment</forename><surname>Ballabriga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhik</forename><surname>Roychoudhury</surname></persName>
		</author>
		<idno type="DOI">10.1109/TSE.2017.2689012</idno>
		<ptr target="https://doi.org/10.1109/TSE.2017.2689012" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="470" to="490" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Performance Modeling and Analysis of Context-Aware Mobile Software Systems</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Berardinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vittorio</forename><surname>Cortellessa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antinisca</forename><surname>Di</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-12029-9_25</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-12029-9_25" />
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering, 13th International Conference, FASE 2010, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2010</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Rosenblum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gabriele</forename><surname>Taentzer</surname></persName>
		</editor>
		<meeting><address><addrLine>Paphos, Cyprus</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-03-20">2010. March 20-28, 2010</date>
			<biblScope unit="volume">6013</biblScope>
			<biblScope unit="page" from="353" to="367" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">NV-Heaps: making persistent objects fast and safe with next-generation, non-volatile memories</title>
		<author>
			<persName><forename type="first">Joel</forename><surname>Coburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><forename type="middle">M</forename><surname>Caulfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ameen</forename><surname>Akel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><forename type="middle">M</forename><surname>Grupp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rajesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><surname>Swanson</surname></persName>
		</author>
		<idno type="DOI">10.1145/1950365.1950380</idno>
		<ptr target="https://doi.org/10.1145/1950365" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS 2011</title>
		<editor>
			<persName><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Todd</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</editor>
		<meeting>the 16th International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS 2011<address><addrLine>Newport Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011-03-05">2011. March 5-11, 2011. 1950380</date>
			<biblScope unit="page" from="105" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">RuntimeDroid: Restarting-Free Runtime Change Handling for Android Apps</title>
		<author>
			<persName><forename type="first">Umar</forename><surname>Farooq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhijia</forename><surname>Zhao</surname></persName>
		</author>
		<idno type="DOI">10.1145/3210240.3210327</idno>
		<ptr target="https://doi.org/10.1145/3210240.3210327" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual International Conference on Mobile Systems, Applications, and Services, MobiSys</title>
		<editor>
			<persName><forename type="first">J?rg</forename><surname>Ott</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Falko</forename><surname>Dressler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefan</forename><surname>Saroiu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Prabal</forename><surname>Dutta</surname></persName>
		</editor>
		<meeting>the 16th Annual International Conference on Mobile Systems, Applications, and Services, MobiSys<address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018-06-10">2018. 2018. June 10-15, 2018</date>
			<biblScope unit="page" from="110" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Androi-dLeaks: Automatically Detecting Potential Privacy Leaks in Android Applications on a Large Scale</title>
		<author>
			<persName><forename type="first">Clint</forename><surname>Gibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-30921-2_17</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-30921-2_17" />
	</analytic>
	<monogr>
		<title level="m">Trust and Trustworthy Computing -5th International Conference, TRUST 2012</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Stefan</forename><surname>Katzenbeisser</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Edgar</forename><forename type="middle">R</forename><surname>Weippl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">Jean</forename><surname>Camp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Melanie</forename><surname>Volkamer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mike</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Xinwen</forename><surname>Zhang</surname></persName>
		</editor>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012-06-13">2012. June 13-15, 2012</date>
			<biblScope unit="volume">7344</biblScope>
			<biblScope unit="page" from="291" to="307" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://www.android.com/android-10/" />
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://developer.android.com/guide/components/activities/activity-lifecycle" />
		<title level="m">Android App Life-Cycle</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://developer.android.com/studio/profile/android-profiler" />
		<title level="m">Android Profiler</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://developer.android.com/guide/fragments" />
		<title level="m">Fragments</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://play.google.com/" />
		<title level="m">Google Play</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Handle configuration changes</title>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://developer.android.com/guide/topics/resources/runtime-changes" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">SQCK: A Declarative File System Checker</title>
		<author>
			<persName><forename type="first">S</forename><surname>Haryadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhishek</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Rajimwale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<ptr target="http://www.usenix.org/events/osdi08/tech/full_papers/gunawi/gunawi.pdf" />
	</analytic>
	<monogr>
		<title level="m">8th USENIX Symposium on Operating Systems Design and Implementation</title>
		<editor>
			<persName><forename type="first">Richard</forename><surname>Draves</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Robbert</forename><surname>Van Renesse</surname></persName>
		</editor>
		<meeting><address><addrLine>San Diego, California, USA, Proceedings</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12-08">2008. 2008. December 8-10, 2008</date>
			<biblScope unit="page" from="131" to="146" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Characterizing and detecting resource leaks in Android applications</title>
		<author>
			<persName><forename type="first">Chaorong</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiqiang</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanli</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1109/ASE.2013.6693097</idno>
		<ptr target="https://doi.org/10.1109/ASE.2013.6693097" />
	</analytic>
	<monogr>
		<title level="m">2013 28th IEEE/ACM International Conference on Automated Software Engineering, ASE 2013</title>
		<editor>
			<persName><forename type="first">Ewen</forename><surname>Denney</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tevfik</forename><surname>Bultan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
		</editor>
		<meeting><address><addrLine>Silicon Valley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013-11-11">2013. November 11-15, 2013</date>
			<biblScope unit="page" from="389" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Bluetooth radio system</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jaap</surname></persName>
		</author>
		<author>
			<persName><surname>Haartsen</surname></persName>
		</author>
		<idno type="DOI">10.1109/98.824570</idno>
		<ptr target="https://doi.org/10.1109/98.824570" />
	</analytic>
	<monogr>
		<title level="j">IEEE Wirel. Commun</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="28" to="36" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Security in near field communication (NFC)</title>
		<author>
			<persName><forename type="first">Ernst</forename><surname>Haselsteiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klemens</forename><surname>Breitfu?</surname></persName>
		</author>
		<ptr target="https://www.academia.edu/download/27719227/security_in_nfc.pdf" />
	</analytic>
	<monogr>
		<title level="m">Workshop on RFID security</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">517</biblScope>
			<biblScope unit="page">517</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Race detection for event-driven mobile applications</title>
		<author>
			<persName><forename type="first">Chun-Hung</forename><surname>Hsiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristiano</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ziyun</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Flinn</surname></persName>
		</author>
		<idno type="DOI">10.1145/2594291.2594330</idno>
		<ptr target="https://doi.org/10.1145/2594291.2594330" />
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;14</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Michael</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Keshav</forename><surname>O'boyle</surname></persName>
		</editor>
		<editor>
			<persName><surname>Pingali</surname></persName>
		</editor>
		<meeting><address><addrLine>Edinburgh, United Kingdom</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014-06-09">2014. June 09 -11, 2014</date>
			<biblScope unit="page" from="326" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automating GUI testing for Android applications</title>
		<author>
			<persName><forename type="first">Cuixiong</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iulian</forename><surname>Neamtiu</surname></persName>
		</author>
		<idno type="DOI">10.1145/1982595.1982612</idno>
		<ptr target="https://doi.org/10.1145/1982595" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Workshop on Automation of Software Test</title>
		<editor>
			<persName><forename type="first">Antonia</forename><surname>Bertolino</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Howard</forename><surname>Foster</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">Jenny</forename><surname>Li</surname></persName>
		</editor>
		<meeting>the 6th International Workshop on Automation of Software Test<address><addrLine>Waikiki, Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011-05-23">2011. 2011. May 23-24, 2011. 1982612</date>
			<biblScope unit="page" from="77" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficiently, effectively detecting mobile app bugs with AppDoctor</title>
		<author>
			<persName><forename type="first">Gang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xinhao</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
		</author>
		<idno type="DOI">10.1145/2592798.2592813</idno>
		<ptr target="https://doi.org/10.1145/2592798.2592813" />
	</analytic>
	<monogr>
		<title level="m">Ninth Eurosys Conference 2014, EuroSys</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Dick</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Herbert</forename><surname>Bulterman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Antony</forename><forename type="middle">I T</forename><surname>Bos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Peter</forename><surname>Rowstron</surname></persName>
		</editor>
		<editor>
			<persName><surname>Druschel</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014-04-13">2014. 2014. April 13-16, 2014</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Detecting Energy Bugs in Android Apps Using Static Analysis</title>
		<author>
			<persName><forename type="first">Hao</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongli</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shengchao</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhendong</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Yan</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-68690-5_12</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-68690-5_12" />
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Software Engineering -19th International Conference on Formal Engineering Methods</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Zhenhua</forename><surname>Duan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Luke</forename><surname>Ong</surname></persName>
		</editor>
		<meeting><address><addrLine>Xi&apos;an, China</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017-11-13">2017. 2017. November 13-17, 2017</date>
			<biblScope unit="volume">10610</biblScope>
			<biblScope unit="page" from="192" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">HybriDroid: static analysis framework for Android hybrid applications</title>
		<author>
			<persName><forename type="first">Sungho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Dolby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sukyoung</forename><surname>Ryu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2970276.2970368</idno>
		<ptr target="https://doi.org/10.1145/2970276.2970368" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering, ASE 2016</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Lo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sven</forename><surname>Apel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sarfraz</forename><surname>Khurshid</surname></persName>
		</editor>
		<meeting>the 31st IEEE/ACM International Conference on Automated Software Engineering, ASE 2016<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016-09-03">2016. September 3-7, 2016</date>
			<biblScope unit="page" from="250" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Caiipa: automated large-scale mobile app testing through contextual fuzzing</title>
		<author>
			<persName><forename type="first">Chieh-Jan Mike</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">D</forename><surname>Lane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niels</forename><surname>Brouwers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B?rje</forename><forename type="middle">F</forename><surname>Karlsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiang</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranveer</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Zhao</surname></persName>
		</author>
		<idno type="DOI">10.1145/2639108.2639131</idno>
		<ptr target="https://doi.org/10.1145/2639108.2639131" />
	</analytic>
	<monogr>
		<title level="m">The 20th Annual International Conference on Mobile Computing and Networking, MobiCom&apos;14</title>
		<editor>
			<persName><forename type="first">Sung-Ju</forename><surname>Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ashutosh</forename><surname>Sabharwal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Prasun</forename><surname>Sinha</surname></persName>
		</editor>
		<meeting><address><addrLine>Maui, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014-09-07">2014. September 7-11, 2014</date>
			<biblScope unit="page" from="519" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Tracking Load-Time Configuration Options</title>
		<author>
			<persName><forename type="first">Max</forename><surname>Lillack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>K?stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Bodden</surname></persName>
		</author>
		<idno type="DOI">10.1109/TSE.2017.2756048</idno>
		<ptr target="https://doi.org/10.1109/TSE.2017.2756048" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="1269" to="1291" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">MAR-VIN: Efficient and Comprehensive Mobile App Classification through Static and Dynamic Analysis</title>
		<author>
			<persName><forename type="first">Martina</forename><surname>Lindorfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Neugschwandtner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Platzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Carl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">C</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivica</forename><surname>Crnkovic</surname></persName>
		</author>
		<idno type="DOI">10.1109/COMPSAC.2015.103</idno>
		<ptr target="https://doi.org/10.1109/COMPSAC.2015.103" />
	</analytic>
	<monogr>
		<title level="m">39th IEEE Annual Computer Software and Applications Conference</title>
		<editor>
			<persName><surname>Pao-Ann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gang</forename><surname>Hsiung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jingwei</forename><surname>Huang</surname></persName>
		</editor>
		<editor>
			<persName><surname>Yang</surname></persName>
		</editor>
		<meeting><address><addrLine>Taichung, Taiwan</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015-07-01">2015. 2015. July 1-5, 2015</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="422" to="433" />
		</imprint>
	</monogr>
	<note>Sheikh Iqbal Ahamed</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Characterizing and detecting performance bugs for smartphone applications</title>
		<author>
			<persName><forename type="first">Yepang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shing-Chi</forename><surname>Cheung</surname></persName>
		</author>
		<idno type="DOI">10.1145/2568225.2568229</idno>
		<ptr target="https://doi.org/10.1145/2568225.2568229" />
	</analytic>
	<monogr>
		<title level="m">36th International Conference on Software Engineering, ICSE &apos;14</title>
		<editor>
			<persName><forename type="first">Pankaj</forename><surname>Jalote</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lionel</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andr?</forename><surname>Van Der Hoek</surname></persName>
		</editor>
		<meeting><address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014-05-31">2014. May 31 -June 07, 2014</date>
			<biblScope unit="page" from="1013" to="1024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Dynodroid: an input generation system for Android apps</title>
		<author>
			<persName><forename type="first">Aravind</forename><surname>Machiry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rohan</forename><surname>Tahiliani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<idno type="DOI">10.1145/2491411.2491450</idno>
		<ptr target="https://doi.org/10.1145/2491411.2491450" />
	</analytic>
	<monogr>
		<title level="m">Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE&apos;13</title>
		<editor>
			<persName><forename type="first">Bertrand</forename><surname>Meyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Luciano</forename><surname>Baresi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mira</forename><surname>Mezini</surname></persName>
		</editor>
		<meeting><address><addrLine>Saint Petersburg, Russian Federation</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013-08-18">2013. August 18-26, 2013</date>
			<biblScope unit="page" from="224" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Race detection for Android applications</title>
		<author>
			<persName><forename type="first">Pallavi</forename><surname>Maiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Kanade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rupak</forename><surname>Majumdar</surname></persName>
		</author>
		<idno type="DOI">10.1145/2594291.2594311</idno>
		<ptr target="https://doi.org/10.1145/2594291.2594311" />
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;14</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Michael</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Keshav</forename><surname>O'boyle</surname></persName>
		</editor>
		<editor>
			<persName><surname>Pingali</surname></persName>
		</editor>
		<meeting><address><addrLine>Edinburgh, United Kingdom</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014-06-09">2014. June 09 -11, 2014</date>
			<biblScope unit="page" from="316" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Cross-checking semantic correctness: the case of finding file system bugs</title>
		<author>
			<persName><forename type="first">Changwoo</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanidhya</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<idno type="DOI">10.1145/2815400.2815422</idno>
		<ptr target="https://doi.org/10.1145/2815400.2815422" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP 2015</title>
		<editor>
			<persName><forename type="first">Ethan</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Steven</forename><surname>Hand</surname></persName>
		</editor>
		<meeting>the 25th Symposium on Operating Systems Principles, SOSP 2015<address><addrLine>Monterey, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015-10-04">2015. October 4-7, 2015</date>
			<biblScope unit="page" from="361" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">ThyNVM: enabling software-transparent crash consistency in persistent memory systems</title>
		<author>
			<persName><forename type="first">Jishen</forename><surname>Jinglei Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samira</forename><forename type="middle">Manabi</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jongmoo</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongwei</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><surname>Mutlu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2830772.2830802</idno>
		<ptr target="https://doi.org/10.1145/2830772.2830802" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture</title>
		<editor>
			<persName><forename type="first">Milos</forename><surname>Prvulovic</surname></persName>
		</editor>
		<meeting>the 48th International Symposium on Microarchitecture<address><addrLine>Waikiki, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015-09">2015. 2015. December 5-9, 2015</date>
			<biblScope unit="page" from="672" to="685" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Finding resume and restart errors in Android applications</title>
		<author>
			<persName><forename type="first">Zhiyong</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tanzirul</forename><surname>Azim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iulian</forename><surname>Neamtiu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2983990.2984011</idno>
		<ptr target="https://doi.org/10.1145/2983990.2984011" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2016, part of SPLASH 2016</title>
		<editor>
			<persName><forename type="first">Eelco</forename><surname>Visser</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yannis</forename><surname>Smaragdakis</surname></persName>
		</editor>
		<meeting>the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2016, part of SPLASH 2016<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016-10-30">2016. October 30 -November 4, 2016</date>
			<biblScope unit="page" from="864" to="880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Impact of disk corruption on open-source DBMS</title>
		<author>
			<persName><forename type="first">Sriram</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yupu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajiv</forename><surname>Vaidyanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Haryadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Remzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">F</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feifei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mirella</forename><forename type="middle">M</forename><surname>Moro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shahram</forename><surname>Ghandeharizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jayant</forename><forename type="middle">R</forename><surname>Haritsa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabio</forename><surname>Casati</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2010.5447821</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2010.5447821" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Data Engineering, ICDE 2010</title>
		<editor>
			<persName><forename type="first">Edward</forename><forename type="middle">Y</forename><surname>Chang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sharad</forename><surname>Mehrotra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Umeshwar</forename><surname>Dayal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vassilis</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</editor>
		<meeting>the 26th International Conference on Data Engineering, ICDE 2010<address><addrLine>Long Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010-03-01">2010. March 1-6, 2010</date>
			<biblScope unit="page" from="509" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Welcome to ROC-RK3399-PC-PLUS Manual</title>
		<author>
			<persName><forename type="first">T-Firefly</forename></persName>
		</author>
		<ptr target="https://wiki.t-firefly.com/en/ROC-RK3399-PC-PLUS/index.html" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">API change and fault proneness: a threat to the success of Android apps</title>
		<author>
			<persName><forename type="first">Mario</forename><forename type="middle">Linares</forename><surname>V?squez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriele</forename><surname>Bavota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Bernal-C?rdenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimiliano</forename><surname>Di Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rocco</forename><surname>Oliveto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denys</forename><surname>Poshyvanyk</surname></persName>
		</author>
		<idno type="DOI">10.1145/2491411.2491428</idno>
		<ptr target="https://doi.org/10.1145/2491411.2491428" />
	</analytic>
	<monogr>
		<title level="m">Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE&apos;13</title>
		<editor>
			<persName><forename type="first">Bertrand</forename><surname>Meyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Luciano</forename><surname>Baresi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mira</forename><surname>Mezini</surname></persName>
		</editor>
		<meeting><address><addrLine>Saint Petersburg, Russian Federation</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013-08-18">2013. August 18-26, 2013</date>
			<biblScope unit="page" from="477" to="487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A measurement study of google play</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Viennot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Nieh</surname></persName>
		</author>
		<idno type="DOI">10.1145/2591971.2592003</idno>
		<ptr target="https://doi.org/10.1145/2591971.2592003" />
	</analytic>
	<monogr>
		<title level="m">ACM SIGMETRICS / International Conference on Measurement and Modeling of Computer Systems, SIGMETRICS 2014</title>
		<editor>
			<persName><forename type="first">Sujay</forename><surname>Sanghavi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sanjay</forename><surname>Shakkottai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Lelarge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bianca</forename><surname>Schroeder</surname></persName>
		</editor>
		<meeting><address><addrLine>Austin, TX, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014-06-16">2014. June 16-20, 2014</date>
			<biblScope unit="page" from="221" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">IntelliDroid: A Targeted Input Generator for the Dynamic Analysis of Android Malware</title>
		<author>
			<persName><forename type="first">Michelle</forename><forename type="middle">Y</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Lie</surname></persName>
		</author>
		<ptr target="http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2017/09/intellidroid-targeted-input-generator-dynamic-analysis-android-malware.pdf" />
	</analytic>
	<monogr>
		<title level="m">23rd Annual Network and Distributed System Security Symposium, NDSS 2016</title>
		<meeting><address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-02-21">2016. February 21-24, 2016</date>
		</imprint>
	</monogr>
	<note>The Internet Society</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Systematic testing for resource leaks in Android applications</title>
		<author>
			<persName><forename type="first">Dacong</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shengqian</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atanas</forename><surname>Rountev</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISSRE.2013.6698894</idno>
		<ptr target="https://doi.org/10.1109/ISSRE.2013.6698894" />
	</analytic>
	<monogr>
		<title level="m">IEEE 24th International Symposium on Software Reliability Engineering, ISSRE 2013</title>
		<meeting><address><addrLine>Pasadena, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013-11-04">2013. November 4-7, 2013</date>
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Using model checking to find serious file system errors</title>
		<author>
			<persName><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Twohey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawson</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1189256.1189259</idno>
		<ptr target="https://doi.org/10.1145/1189256.1189259" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="393" to="423" />
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Testing for poor responsiveness in android applications</title>
		<author>
			<persName><forename type="first">Shengqian</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dacong</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atanas</forename><surname>Rountev</surname></persName>
		</author>
		<idno type="DOI">10.1109/MOBS.2013.6614215</idno>
		<ptr target="https://doi.org/10.1109/MOBS.2013.6614215" />
	</analytic>
	<monogr>
		<title level="m">2013 1st International Workshop on the Engineering of Mobile-Enabled Systems (MOBS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Automated Generation of Oracles for Testing User-Interaction Features of Mobile Apps</title>
		<author>
			<persName><forename type="first">Razieh</forename><surname>Nokhbeh Zaeem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mukul</forename><forename type="middle">R</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarfraz</forename><surname>Khurshid</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICST.2014.31</idno>
		<ptr target="https://doi.org/10.1109/ICST.2014.31" />
	</analytic>
	<monogr>
		<title level="m">Seventh IEEE International Conference on Software Testing, Verification and Validation</title>
		<meeting><address><addrLine>Cleveland, Ohio, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014-03-31">2014. 2014. March 31 2014-April 4, 2014</date>
			<biblScope unit="page" from="183" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A comparison of energy bugs for smartphone platforms</title>
		<author>
			<persName><forename type="first">Jack</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ayemi</forename><surname>Musa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Le</surname></persName>
		</author>
		<idno type="DOI">10.1109/MOBS.2013.6614219</idno>
		<ptr target="https://doi.org/10.1109/MOBS.2013.6614219" />
	</analytic>
	<monogr>
		<title level="m">2013 1st International Workshop on the Engineering of Mobile-Enabled Systems (MOBS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Zizhan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zili</forename><surname>Shao</surname></persName>
		</author>
		<idno type="DOI">10.5281/zenodo.7594872</idno>
		<ptr target="https://doi.org/10.5281/zenodo.7594872" />
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
	<note>RCHDroid Appendix</note>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Zizhan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zili</forename><surname>Shao</surname></persName>
		</author>
		<idno type="DOI">10.5281/zenodo.7583154</idno>
		<ptr target="https://doi.org/10.5281/zenodo.7583154" />
		<imprint>
			<date type="published" when="2022-10-20">2023. 2022-10-20</date>
			<biblScope unit="page" from="2023" to="2024" />
		</imprint>
	</monogr>
	<note>RCHDroid Artifact</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
