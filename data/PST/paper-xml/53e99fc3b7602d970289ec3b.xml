<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Selecting elliptic curves for cryptography: an efficiency and security analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Joppe</forename><forename type="middle">W</forename><surname>Bos</surname></persName>
							<email>joppe.bos@nxp.com</email>
							<affiliation key="aff0">
								<orgName type="institution">NXP Semiconductors</orgName>
								<address>
									<settlement>Leuven</settlement>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">•</forename><surname>Craig Costello</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Redmond</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Patrick</forename><surname>Longa</surname></persName>
							<email>plonga@microsoft.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Redmond</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Naehrig</surname></persName>
							<email>mnaehrig@microsoft.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Redmond</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Craig</forename><surname>Costello</surname></persName>
							<email>craigco@microsoft.com</email>
						</author>
						<title level="a" type="main">Selecting elliptic curves for cryptography: an efficiency and security analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B646618F90051E4E06F73A62564033F4</idno>
					<idno type="DOI">10.1007/s13389-015-0097-y</idno>
					<note type="submission">Received: 25 October 2014 / Accepted: 8 April 2015</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Elliptic curves</term>
					<term>Weierstrass form</term>
					<term>Twisted Edwards form</term>
					<term>Secure scalar multiplication</term>
					<term>Constant-time execution</term>
					<term>Transport layer security (TLS) protocol</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We select a set of elliptic curves for cryptography and analyze our selection from a performance and security perspective. This analysis complements recent curve proposals that suggest (twisted) Edwards curves by also considering the Weierstrass model. Working with both Montgomery-friendly and pseudo-Mersenne primes allows us to consider more possibilities which help to improve the overall efficiency of base field arithmetic. Our Weierstrass curves are backwards compatible with current implementations of prime order NIST curves, while providing improved efficiency and stronger security properties. We choose algorithms and explicit formulas to demonstrate that our curves support constant-time, exception-free scalar multiplications, thereby offering high practical security in cryptographic applications. Our implementation shows that variable-base scalar multiplication on the new Weierstrass curves at the 128-bit security level is about 1.4 times faster than the recent implementation record on the corresponding NIST curve. For practitioners who are willing to use a different curve model and sacrifice a few bits of security, we present a collection of twisted Edwards curves with particularly efficient arithmetic that are up to 1.42, 1.26 and 1.24 times faster than the new Weierstrass curves at the 128-, 192-and 256-bit</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The first release of a cryptographic standard specifying elliptic curves for use in practice dates back to 2000 <ref type="bibr" target="#b21">[21]</ref>. Nowadays, roughly one out of ten systems on the publicly observable Internet offers cipher suites in the Secure Shell (SSH) and Transport Layer Security (TLS) protocols that contain elliptic-curve-based cryptographic algorithms <ref type="bibr" target="#b16">[16]</ref>. Most elliptic curve standards recommend curves for different perceived security levels that are either defined over prime fields or binary extension fields; on the Internet, however, the deployed curves are mostly defined over prime fields <ref type="bibr" target="#b16">[16]</ref>. This can be partially explained by the increasing skepticism towards the security of elliptic curves defined over binary extension fields (justified by recent progress on solving the discrete logarithm problem on such curves <ref type="bibr" target="#b26">[26]</ref>). Therefore, in this work, we only consider elliptic curves defined over prime fields.</p><p>Recently, part of the cryptographic community has been looking for alternatives to the currently deployed elliptic curves that may offer better performance and provide stronger overall security (see for example an evaluation of recent curve candidates in <ref type="bibr" target="#b12">[12]</ref>). Most notably, the TLS working group has issued a formal request to the Crypto Forum Research Group (CFRG) asking for recommendations for new elliptic curves. The urge to change curves has been fueled by the recently leaked NSA documents, which suggest the existence of a back door in the Dual Elliptic Curve Deterministic Random Bit Generator <ref type="bibr">[55]</ref>. Although cryptographers have suspected this at least as early as in 2007 <ref type="bibr" target="#b52">[52]</ref>, these recent revelations have accelerated a controversy on whether the widely deployed NIST curves <ref type="bibr" target="#b56">[57]</ref> should be replaced by curves with a verifiably deterministic generation. Besides such security concerns, there has been significant progress related to both efficiency and security since the initial standardization of elliptic curve cryptography. Notable examples are algorithms protected against certain side-channel attacks, different "special" prime shapes which allow faster modular arithmetic, and a larger set of curve models from which to choose. For example, Edwards <ref type="bibr" target="#b25">[25]</ref> discovered an interesting normal form for elliptic curves, now called the Edwards model, which was introduced to cryptographic applications by Bernstein and Lange <ref type="bibr" target="#b11">[11]</ref>. A generalization of this curve model, known as the twisted Edwards model <ref type="bibr" target="#b7">[7]</ref>, facilitates the most efficient curve arithmetic <ref type="bibr" target="#b35">[35]</ref>. Such (twisted) Edwards curves also have other attractive properties: they may be selected to support a complete addition law and are compatible with the Montgomery model, which supports efficient Montgomery ladder computations <ref type="bibr" target="#b47">[47]</ref>. However, twisted Edwards curves cannot have a prime number of rational points over the base field, and they are therefore incompatible with the prime-order Weierstrass curves used in all of the current cryptographic standards <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b48">48,</ref><ref type="bibr" target="#b56">57]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work</head><p>The NIST curves <ref type="bibr" target="#b56">[57]</ref> have been included in numerous standards (e.g., <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b48">48]</ref>) and are deployed in many security protocols. The most recent speed record on the NIST curve which aims to provide 128-bit security is due to Gueron and Krasnov <ref type="bibr" target="#b31">[31]</ref>. Alternatives to the NIST curves have been suggested by the German working group Brainpool <ref type="bibr" target="#b24">[24]</ref>; their curve choices followed additional security requirements, one of which demands verifiably pseudo-random curve generation. Another alternative curve has been proposed by Bernstein <ref type="bibr" target="#b4">[5]</ref>; this is a Montgomery curve, called Curve25519, which allows efficient computation of ECDH using the Montgomery ladder at the 128-bit security level. It was later shown by Bernstein et al. <ref type="bibr" target="#b9">[9]</ref> that a twisted Edwards curve, birationally equivalent to Curve25519, can be used for efficient elliptic curve signature generation and verification. Recently, Bernstein and Lange started a project to select and analyze secure elliptic curves for use in cryptography: see <ref type="bibr" target="#b12">[12]</ref> for a list of the security assessments the project performs and the requirements it imposes. A range of curves, targeting different security levels, is also presented in <ref type="bibr" target="#b12">[12]</ref>. Following this, several new curves satisfying the requirements from <ref type="bibr" target="#b12">[12]</ref>, which facilitate both the twisted Edwards and Montgomery form, were proposed by Aranha et al. <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation and rationale</head><p>The new curves presented in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">12]</ref> are all efficient and secure elliptic curves ready to be used in cryptography. This prompts the question as to why we should perform an efficiency and security analysis for a set of new curves. It is our opinion that not all options for prime fields and elliptic curve models have been considered in the recent curve proposal projects (either because they are overlooked or do not fit the requirements set by the project). Our goal is to rigorously analyze all of these different aspects from both a security and efficiency perspective, in hope that this paper helps practitioners better understand (and correctly implement) the choices that lie in front of them. Abandoning a set of standard curves demands a judicious selection of new curves, since this cannot be done too frequently if widespread adoption is desired. In that light, it is our opinion that one should consider all of the options available. For example, in contrast to <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">12]</ref>, our selection includes prime order Weierstrass curves. Just as the almost-prime order twisted Edwards curves have their practical advantages, we argue that there are also benefits to choosing prime order Weierstrass curves: the absence of small torsion simplifies the point/input validation process, and (over a prime field of fixed length) does not sacrifice any bits of security with respect to attacks on the underlying elliptic curve discrete logarithm problem (ECDLP). In addition, such curves are backwards compatible with current implementations supporting NIST curves over prime fields (i.e., no changes are required in protocols), and could be integrated into existing implementations by simply changing the curve constant and (in some cases) field arithmetic. <ref type="foot" target="#foot_0">1</ref>We investigate the selection of prime moduli that allow efficient modular arithmetic. As in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b41">41]</ref>, we study pseudo-Mersenne primes of the form 2 α -γ , but also primes of the form 2 α (2 β -γ ) -1 that can be used to accelerate Montgomery arithmetic <ref type="bibr" target="#b46">[46]</ref> as used in <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b32">32]</ref>. Following the deterministic selection requirement from <ref type="bibr" target="#b12">[12]</ref>, we pick two primes of each shape for a given targeted security level: one prime is selected to be slightly smaller than the other, which sacrifices a small amount of ECDLP security in favor of enhanced performance. Note that, as explained in Sect. 2, for practical considerations we require all primes to be congruent to 3 modulo 4. These primes are used to construct cryptographically suitable curves focusing on (arguably) the two most relevant curve models: short Weierstrass curves with the curve parameter a set to -3 and twisted Edwards curves with the curve parameter a set to -1. The prime order Weierstrass curves give full ECDLP security over prime fields of a fixed bitlength, while offering good practical performance. On the other hand, the twisted Edwards curves sacrifice a small amount of ECDLP security but facilitate the fastest realization of curve arithmetic <ref type="bibr" target="#b35">[35]</ref>. Both types of curves are selected in a deterministic fashion (see Sect. 3 for the full details) and offer twist-security <ref type="bibr" target="#b4">[5]</ref>, a property which is useful in certain scenarios. We note that our prime and curve selection is meant to cover a wide range of options exhibiting attractive features. Nevertheless, there are other design alternatives that might offer different trade-offs between security, rigidity and performance on different platforms. We leave the investigation of other options as future work.</p><p>An important requirement for implementations of modern cryptographic algorithms is a constant runtime when the algorithm computes on secret data to guard against timing attacks <ref type="bibr" target="#b38">[38]</ref>. In particular, this potential threat exists for two basic elliptic curve operations: variable-base and fixed-base scalar multiplication. One solution is to use a complete addition law. However, a complete addition law is typically less efficient compared to the dedicated formulas which can fail for certain inputs. In Sect. 4 we outline another solution to this problem for the variable-base case. We show that our algorithms which compute on secret data, can never run into any exceptional cases (i. e. produce incorrect results) while using the faster dedicated formulas and ensuring a constant runtime (with the exception of the very last addition; see Sect. 4.1 for the details). Hence, this solution results in faster implementations compared to the complete solution.</p><p>In the fixed-base case the situation is more complicated: most efficient algorithms in the literature may potentially run into exceptions. While the use of a complete addition formula suffices to solve the problem on twisted Edwards curves, the high cost of complete additions on Weierstrass curves would degrade performance significantly <ref type="bibr" target="#b18">[18]</ref> (see Appendix C.1). To solve this problem, we propose a new formula that works for all possible inputs by exploiting masking techniques. This pseudo-complete addition requires the same number of multiplications and squarings as the unprotected dedicated addition formula and drastically reduces the overhead of protecting scalar multiplication. We comment that the formula is also useful in the context of secure, exception-free multi-scalar multiplications. The reader is referred to Appendix C.1 for more details on the new formula.</p><p>We do not claim full security against other attacks such as simple power analysis (SPA); this is left for future work. Nevertheless, we remark that all the selected algorithms have a regular structure as required when implementing countermeasures against certain simple side-channel attacks. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of contributions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposed curves</head><p>Tables <ref type="table" target="#tab_3">1</ref> and<ref type="table" target="#tab_2">2</ref> show the curves that we have chosen deterministically according to our security and efficiency criteria. The tables show the target security level, which gives a rough estimate for the desired security in each case. Curve names indicate the curve model [w for the Weierstrass model and ed for the (twisted) Edwards model], the bitlength of the underlying base field prime and the type of prime (mont for Montgomery-friendly and mers for pseudo-Mersenne primes). In Appendix D, we provide the trace of Frobenius t for each curve, so the number of F p -rational points for the curve E and its quadratic twist E can be computed as #E(F p ) = p + 1t and #E (F p ) = p + 1 + t. More details on the curve choices and their properties are given in Sect. 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Modular arithmetic: choosing primes</head><p>Over a prime field F p (with p &gt; 3 prime), the computation of the elliptic curve group operation boils down to numerous computations modulo p. In this section, we outline the types of primes that we prefer for efficiency and security consider-  ations, and discuss how the primes are uniquely determined from a fixed security level. We have not experimented with using a smaller radix system to accumulate the intermediate carries, at the cost of increasing the number of multiplications. We leave the investigation of such approaches as future work.</p><p>Primes of the form 2 α -γ Selecting primes of a special form to enhance the performance of the modular reduction is not new. The primes standardized in the digital signature standard <ref type="bibr" target="#b56">[57]</ref> have a special form allowing fast reduction based on the work by Solinas <ref type="bibr" target="#b53">[53]</ref>. Even faster modular reduction can be achieved by selecting primes of the form p = 2 α -γ , known as pseudo-Mersenne primes. In this case, the value α is determined by the security parameter and is typically a multiple of 64 (or slightly smaller). The integer γ is chosen to be a small positive integer, i.e., significantly smaller than 2 32 . Given two integers x and y such that 0 ≤ x, y &lt; 2 α -γ , one can compute x • y mod (2 α -γ ) by first computing the product and writing this in a radix-2 α system as x • y = z h •2 α +z . A first reduction step, based on the shape of the modulus, is</p><formula xml:id="formula_0">z h • 2 α + z ≡ z + z h • γ (mod 2 α -γ ) = z, where 0 ≤ z &lt; (γ + 1)2 α</formula><p>. If this step is repeated, the result is such that 0 ≤ z &lt; 2 α + γ 2 , which can finally be brought into the desired range by applying an additional correction modulo p using subtractions. A standard way of enhancing the performance is to use a redundant representation: instead of reducing z to the range [0, 2 α -γ ), one can often more efficiently reduce z to the range [0, 2 α ), or to the range [0, 2 2s ) if α is a few bits smaller than 2s (at a target security level of s bits). The latter case can be optimized further by computing exclusively in such a redundant form and performing a sole correction at the end of the scalar multiplication. Given a security level of s bits, we consider the parameter α ∈ {2s, 2s -1}. Taking α = 2s makes the prime as large as possible, matching one of the requirements to achieve maximal ECDLP security at the s-bit security level. Taking α = 2s -1 sacrifices half a bit of ECDLP security in favor of potential enhancements in efficiency, as described above. Thus, fixing s results in two possible values for α and subsequently two primes of the form 2 α -γ : for a fixed α, we choose the smallest γ such that 2 α -γ is both prime and congruent to 3 modulo 4 (the rational behind this congruence condition is discussed below). Following our curve selection criteria, the values γ for the curves under analysis are always smaller than 2 10 , which makes them attractive for efficient implementation on 16, 32 and 64-bit platforms.</p><p>Primes of the form 2 α (2 β -γ ) -1 Another approach to select primes is inspired by Montgomery arithmetic <ref type="bibr" target="#b46">[46]</ref>. The idea behind Montgomery multiplication is to replace the relatively expensive divisions by computationally inexpensive logical shifts when computing the modular reduction. Some computations (and storage) can be avoided when primes of the form p = 2 α (2 β -γ ) -1 are used for positive integers α, β and γ (cf. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b37">37,</ref><ref type="bibr" target="#b39">39]</ref>). When the prime p is two bits short of a multiple of the word size w (i.e., w | α +β +2), one can avoid a conditional subtraction in every multiplication <ref type="bibr" target="#b57">[58]</ref>.</p><p>There are different ways to construct Montgomeryfriendly primes: for example, <ref type="bibr" target="#b32">[32]</ref> prefers γ to be a power of two, while <ref type="bibr" target="#b15">[15]</ref> sets β = 64 and γ as small as possible to specifically target 64-bit platforms. We make choices of α, β and γ such that the modular arithmetic can be implemented efficiently on a wide range of platforms. Given a security level of s bits, we consider α = 8δ and β ∈ {2s -α, 2s -2 -α}, and choose γ and δ as the smallest positive integers such that p = 2 α (2 β -γ ) -1 is prime and log 2 ( p) = 2s (resp. log 2 ( p) = 2s -2) in the setting of β = 2s -α (resp. β = 2s -2 -α). We start with δ = 1 and increment it by 1 (if necessary) until γ is found. For instance, for s = 192 and β = 2s -α, we observe that (δ, γ ) = (1, 79) results in a prime which can be written as 2 376 (2 8 -79) -1 = 2 352 (2 32 -2 24 • 79) -1 = 2 320 (2 64 -2 56 • 79) -1, for usage on 8-, 32-and 64-bit platforms, respectively. This has the advantage that the reduction step, which has to be computed at every iteration inside the interleaved Montgomery algorithm, can be computed using only a multiply-and-add and an addition instruction. Note that, by construction, primes of this form are always congruent to 3 modulo 4.</p><p>Constant-time modular arithmetic One of the measures to guard software implementations against various types of side-channel analysis such as timing attacks <ref type="bibr" target="#b38">[38]</ref> is to ensure a constant running time. In practice, this often means writing code which does not contain branches depending on secret data. For instance, the interleaved Montgomery multiplication algorithm requires a conditional subtraction at the end.</p><p>To remove this, we always compute the subtractions and select (mask) the correct value depending on the conditional flag. In the setting of primes of the shape 2 α -γ , one must always compute the worst-case number of reduction rounds in order to ensure constant runtime.</p><p>Besides the "standard" modular operations, there is also the need for constant-time methods to compute the modular inversion and the modular square roots. In order to compute the inversion modulo a prime p, one can use Fermat's little theorem: i.e., compute a p-2 ≡ a -1 (mod p). Since our chosen primes all have a special shape, finding efficient addition chains for this exponentiation is not difficult. For the n-bit primes considered in this work, we found that we can always compute the modular inversion using at most 1.11 log 2 ( p) modular multiplications and modular squarings. If p ≡ 3 (mod 4), then one can compute a modular square root x (if it exists) of an element a using x ≡ a p+1 4</p><p>(mod p). Since this can be performed efficiently, and in constant-time, we require all of our primes to be congruent to 3 modulo 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Curve selection</head><p>In this section we explain how the curves in Tables <ref type="table" target="#tab_3">1</ref> and<ref type="table" target="#tab_2">2</ref> were chosen based on the selection of primes that is outlined in Sect. 2. For each chosen prime p ≡ 3 (mod 4), we provide two curves: one is a prime order short Weierstrass curve, while the other is an almost-prime order twisted Edwards curve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Curve selection for Weierstrass curves</head><p>For a fixed prime p, a specific curve E b : y 2 = x 3 -3x +b is uniquely determined by the curve parameter b ∈ F p \{±2, 0}. Note that, since p ≡ 3 mod 4, its non-trivial quadratic twist E b has the curve equation E b : y 2 = x 3 -3xb. In order to guarantee twist-security <ref type="bibr" target="#b4">[5]</ref>, we require both the group orders r = #E b (F p ) and r = #E b (F p ) to be prime. We have r = p + 1t and r = p + 1 + t for |t| ≤ 2 √ p and demand |t| &gt; 1 because curves with t ∈ {0, 1} are weak. Thus, depending on the sign of the trace t, either r &gt; p, r &lt; p or r &lt; p, r &gt; p. To ease implementation, we demand that r &lt; p for all curves, i.e., we choose the curve with positive trace. To leave no room for manipulating the curve choice, we select all curve parameters deterministically, namely by choosing the integer b with the smallest absolute value that yields a curve with the above properties. Based on these considerations, the selection process is completely explained in accordance with the rigidity condition of <ref type="bibr" target="#b12">[12]</ref>. Specifically, we search for a suitable coefficient b by starting with b = 1 and incrementing b by one until both r and r are prime.</p><p>For each value of b, we use the Schoof-Elkies-Atkin (SEA) point counting algorithm <ref type="bibr" target="#b51">[51]</ref> in Magma <ref type="bibr" target="#b17">[17]</ref> to compute the trace t of E b , such that r = p + 1t and r = p + 1 + t.</p><p>We use the implementation's 'early abort' feature that abandons the computation when small factors are found either in the curve's or the twist's group order. Because of the curve model for E b , the search only considers positive values of b and we select the sign of b to ensure that r &lt; p. The resulting curves are summarized in Table <ref type="table" target="#tab_1">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Curve selection for twisted Edwards (and Montgomery) curves</head><p>For a fixed prime p, a specific twisted Edwards curve E d : -x 2 + y 2 = 1 + dx 2 y 2 is uniquely determined by the curve parameter d ∈ F p \{0, -1}. Let A = 2 1-d d+1 , and B = -(A + 2). Theorem 3.2 of <ref type="bibr" target="#b7">[7]</ref> shows that the twisted Edwards curve E and the Montgomery curve By 2 = x 3 + Ax 2 + x are birationally equivalent. If B is a square in F p (which it is for all our curves), then E d is birationally equivalent to E A : y 2 = x 3 + Ax 2 +x. As for the Weierstrass curves, we demand t &gt; 1 to exclude the weak curves with t ∈ {0, 1} and to ensure that 4r &lt; p.</p><p>Ideally, it would be desirable to have a curve with minimal parameter d in the twisted Edwards form and minimal parameter A in the Montgomery form. Unfortunately, existing curve proposals have been forced to pick one form and optimize it at the expense of the other one. We show in Sect. 3.3 below, that a search minimizing the absolute value of the parameter d would find curves with the same group orders for curve and twist, where the latter corresponds to -(d + 1). This means that a search for minimal absolute value of d will always find positive d first, which corresponds to negative A. Our search thus minimizes the absolute values of A and d at the same time.</p><p>For each fixed p, we start with A = -6 and search for A ∈ 2 + 4Z (subtracting 4 each time) until #E A = 4r and #E A = 4r , where r and r are both prime. Note that the discussion in Sect. 3.3 also shows that B = -(A + 2) is always a square in F p , which means that E A : y 2 = x 3 -Ax 2 + x is a model for the non-trivial quadratic twist of E A . Again, for each A, we use the SEA algorithm <ref type="bibr" target="#b51">[51]</ref> in Magma <ref type="bibr" target="#b17">[17]</ref> to compute the trace t of E, which determines #E A = p + 1t and #E A = p + 1 + t. Section 3.3 also shows that A 2 -4 is non-square in F p , which simplifies notions of completeness on E (see <ref type="bibr" target="#b4">[5]</ref>). Furthermore, we check that the curve satisfies all conditions posed by <ref type="bibr" target="#b12">[12]</ref>, if one of them is not met, 2 we continue with the next value for A. We note that the cofactors of 4 are minimal when insisting on an F p -rational twisted Edwards and/or Montgomery form. The resulting curves are summarized in Table <ref type="table" target="#tab_2">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Correspondence between minimal A and d for twisted Edwards curves</head><p>Table <ref type="table" target="#tab_2">2</ref> contains a column with values for the parameter d 0 = -(A + 2)/4, which can be used for implementing twisted Edwards curves defined over our prime fields. The curve</p><formula xml:id="formula_1">E d 0 /F p : -x 2 + y 2 = 1 + d 0 x 2 y 2 has the same number of F p -rational points as the curve E d /F p : -x 2 + y 2 = 1 + dx 2 y 2 with d = -(A -2)/(A + 2) and the Montgomery curve E A /F p : y 2 = x 3 + Ax 2 + x. Furthermore, the curve E -(d 0 +1) /F p : -x 2 + y 2 = 1 -(d 0 + 1)</formula><p>x 2 y 2 has the same number of F p -rational points as the quadratic twist E d and the quadratic twist E -A . In this section, we show that this is true in general, and that therefore, the relation between d 0 and A shows that the value d 0 is the minimal value for d defining E d such that all the criteria in our curve selection are satisfied if and only if A is the minimal such value for the Montgomery form. This shows that it is not necessary to search for a new set of twisted Edwards curves if one wants to minimize the parameter d instead of the Montgomery parameter A. One can simply use the curve defined by d 0 .</p><p>The following lemma connects the two twisted Edwards curves E d and E d 0 via an isogeny whenever d 0 = -1/(d +1). It also gives a condition on d 0 which determines whether the map is defined over F p . If this is the case, both curves have the same number of F p -rational points.</p><formula xml:id="formula_2">Lemma 1 Let E d : -x 2 + y 2 = 1 + dx 2 y 2 be</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>a twisted Edwards curve defined over a prime field F p and let d</head><formula xml:id="formula_3">0 = -1/(d + 1) ∈ F p . Then there exists a 4-isogeny φ : E d → E d 0 . If d 0 is a square in F p , the isogeny is defined over F p , in particular #E d (F p ) = #E d 0 (F p ).</formula><p>Proof The isogeny φ is one of the isogenies described in Section 3 of <ref type="bibr" target="#b1">[2]</ref>. This means, it is the composition of maps 2 The only instance where the first twisted Edwards curve we found did not fulfill all of the SafeCurves requirements was in the search for ed-383-mers: the constant A = 1629146 corresponds to a curve-twist pair with #E A = 4r and E A = 4r , where r and r are both prime, but the embedding degree of E A with respect to r is (r -1)/188, which fails to meet the minimum requirement of (r -1)/100 imposed in <ref type="bibr" target="#b12">[12]</ref>.</p><formula xml:id="formula_4">φ = ψ-1,-1/(d+1) • σ • ψ -1,d .</formula><formula xml:id="formula_5">The map ψ -1,d is the 2-isogeny ψ -1,d : E d → L -d to the Legendre form curve L -d : y 2 = x(x -1)(x +d) given in [2, Theorem 3.2], and ψ-1,-1/(d+1) : L 1/(d+1) → E -1/(d+1) is the dual of the corresponding isogeny for 1/(d + 1). The map σ is equal to the isomorphism σ 2 σ 1 : L -d → L 1/(d+1)</formula><p>given in [2, Section 3.2]. The composition φ is defined over F p if d 0 and thus -(d + 1) is a square in F p . This proves the lemma.</p><p>The next result uses the previous isogeny to show that the original curve E d and its twist E d each have corresponding curves with small parameters d 0 and -(d 0 + 1), respectively, which have the same number of F p -rational points, provided that both these small parameters are squares in F p .</p><formula xml:id="formula_6">Lemma 2 Let A ∈ F p \{-2, 2}, d = -(A -2)/(A + 2) and d 0 = -(A + 2)/4 such that both d 0 and -(d 0 + 1) are squares in F p . Then #E d (F p ) = #E d 0 (F p ). Moreover, #E d (F p ) = #E -(d 0 +1) (F p ).</formula><p>Proof The first part follows from Lemma 1 because d 0 = -1/(d + 1). Since the twist E d = E 1/d , the second part follows from Lemma 1 with d replaced by 1/d, which means that d 0 is replaced by -(d 0 + 1).</p><p>Finally, we show that indeed our search criteria, in particular the facts that p ≡ 3 (mod 4) and that both group orders are not divisible by 8, imply that d 0 and -(d 0 + 1) as given in our setting are squares in F p , which shows that the correspondence above holds. Proof We first prove that d 0 is a square in F p . Assume that it is not a square. Section 3 in <ref type="bibr" target="#b8">[8]</ref> provides an exhaustive description of all points of order 2 and 4 on a twisted Edwards curve. If d 0 is not a square, then -1/d 0 is a square because p ≡ 3 (mod 4). Then the full 2-torsion is defined over F p , it consists of the affine point (0, -1) and two points at infinity ((1 : 0), (± √ -1/d 0 )) (written as completed points in projective space P 1 × P 1 , see [8, Section 2.7]). Let s ∈ F p with s 2 = -1/d 0 , then exactly one of ±s is a square, assume without loss of generality that it is s. Then this value gives 4 affine points (± √ s, ± √ s) (signs chosen independently) of order 4 defined over F p . The group structure of the 4-torsion on E d 0 that is defined over F p is thus Z 2 × Z 4 and has order 8. Therefore 8 must divide #E d 0 (F p ), which contradicts our assumption that the group order is 4r for r prime. Hence, d 0 is a square.</p><p>We know that the twist E d 0 is birationally equivalent to E 1/d 0 , and we have already shown that d 0 is a square, so 1/d 0 is a square. We can apply Lemma 1 with d 0 replaced by 1/d 0 , which means that d = -(d 0 + 1), and obtain that #</p><formula xml:id="formula_7">E -(d 0 +1) (F p ) = #E 1/d 0 (F p ) = 4r</formula><p>. Now looking at the 4torsion defined over F p as above yields that -(d 0 + 1) is a square in F p .</p><p>The minimality of d 0 All our selected twisted Edwards curves satisfy the conditions of the previous two lemmas. Therefore, one can choose to work with the isogenous curves defined by d 0 or -(d 0 + 1), whichever is more convenient. The isogenous curves and their twists have the same orders as the original curves and their twists. Therefore all conditions required in the curve selection are satisfied with the added benefit of a small d-value.</p><p>We argue that d 0 is of minimal absolute value defining a curve that satisfies the search criteria. Assume that A is a coefficient with minimal absolute value that yields a desired curve when minimizing for the Montgomery parameter (like the values for A in our examples). A search that minimizes the absolute value of the parameter d in the twisted Edwards model E d , must find the value d 0 (or</p><formula xml:id="formula_8">-(d 0 + 1)) first since A = -(4d 0 + 2). Without loss of generality, let |d 0 | &lt; |d 0 +1|, i.e., d 0 &gt; 0, otherwise interchange d 0 and -(d 0 +1). Indeed, assume that a d 1 with |d 1 | &lt; |d 0 | leads to a curve that satisfies all criteria. Let A 1 = -(4d 1 + 2). By Lemma 3, d 1 and -(d 1 + 1) are squares, then by Lemma 2, #E d 1 (F p ) = #E d1 (F p ) = #E A 1 (F p ), where d1 = -(A 1 -2)/(A 1 +2) and #E d 1 (F p ) = E -(d 1 +1) (F p ) = #E 1/ d1 (F p ) = #E -A 1 (F p ).</formula><p>This means that the curve E A 1 satisfies the search criteria.</p><p>Since we fixed d 0 &gt; 0, we have A &lt; 0. By assumption, we have</p><formula xml:id="formula_9">-A = 4d 0 + 2 = 4|d 0 | + 2 &gt; 4|d 1 | + 2. Now consider the two cases d 1 &gt; 0 and d 1 &lt; 0. If d 1 &gt; 0, then A 1 = -(4d 1 + 2) &lt; 0, and |A| = -A &gt; 4|d 1 | + 2 = 4d 1 + 2 = -A 1 = |A 1 |, contradicting the minimality of A. Similarly, if d 1 &lt; 0, then A 1 &gt; 0 and |A| = -A &gt; 4|d 1 |+2 &gt; 4|d 1 + 1|+2 = -4(d 1 + 1) + 2 = -(4d 1 + 2) = A 1 = |A 1 |,</formula><p>again a contradiction. Overall, this means that d 0 must be the coefficient with minimal absolute value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Curve properties</head><p>In both families of curves, note that for primes of the form 2 α -γ , the bitlengths of r and r differ by 1, since |t| γ in general; for primes of the form 2 α (2 β -γ )-1, the bitlengths of r and r are always equal when γ = 0. The curves in Table <ref type="table" target="#tab_2">2</ref> can be used in different curve models: in the twisted Edwards model, in the Montgomery model for implementing Montgomery ladders, and also in the original Edwards model allowing complete addition formulas <ref type="bibr" target="#b11">[11]</ref>. The latter can be seen as follows. Since p ≡ 3 (mod 4), E A is birationally equivalent to an Edwards curve by <ref type="bibr" target="#b7">[7,</ref><ref type="bibr">Theorem 3.4]</ref>. Using the maps discussed in [7, <ref type="bibr">Section 3]</ref>, one can show that E A :</p><formula xml:id="formula_10">y 2 = x 3 + Ax 2 + x is birationally equivalent to E -1/d : x 2 + y 2 = 1 -(1/d)x 2 y 2 .</formula><p>For all of our curves, d is a square in F p , so -1/d is not a square, which means that the addition law on E -1/d is complete. All of the curves in Table <ref type="table" target="#tab_2">2</ref> allow for an efficient map from a subset of their F prational points to bit strings of a certain length, such that they are indistinguishable from uniform random bitstrings of the same length (see <ref type="bibr" target="#b10">[10]</ref>, which is based on <ref type="bibr" target="#b29">[29]</ref>). However, note that curves defined over pseudo-Mersenne primes are more suitable for achieving indistinguishability than those over Montgomery-friendly primes because for the latter primes p, the value ( p + 1)/2 is further away from a power of 2 (see <ref type="bibr">[10, §2.6]</ref>). The prime-order Weierstrass curves presented in Table <ref type="table" target="#tab_1">1</ref> are similar in their basic properties to the NIST curves, as they have the same curve model, share the parameter a = -3, and include prime fields of the same bit lengths as the ones for the NIST curves <ref type="bibr" target="#b56">[57]</ref>. However, we stress that the curves in Table <ref type="table" target="#tab_1">1</ref> do not allow any room for manipulations, which can be the case when the curve parameter b is allowed to be chosen "randomly". Our curves are twist-secure, do not allow transfers, and have large discriminants (notions used to guard against certain attacks; e.g., see <ref type="bibr" target="#b12">[12]</ref>). The work in <ref type="bibr" target="#b55">[56]</ref> shows that indistinguishability can also be achieved for our prime-order Weierstrass curves in Table <ref type="table" target="#tab_1">1</ref>, however the resulting bit strings are twice as large as those that result from applying <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b29">29]</ref> to the twisted Edwards curves in Table <ref type="table" target="#tab_2">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Efficient, constant-time, and exceptionless scalar multiplications</head><p>To protect against certain types of side-channel attacks <ref type="bibr" target="#b38">[38]</ref>, it is essential that scalar multiplications are computed in constant-time. This means that the running time of the algorithm for computing a scalar multiplication k P must be independent of the scalar k and the point P. Classical curve arithmetic formulas have exceptional cases, i.e., they do not work for all points. Having conditional statements in the code that check for these cases means the algorithms have a variable running time depending on different input cases, but simply leaving them out might lead to exceptional point attacks that produce wrong results or cause other implementation errors. In this section we outline how constant-time algorithms can be achieved efficiently for our chosen Weierstrass and twisted Edwards curves in two different settings: the variable-and fixed-base scenarios. The variable-base scenario refers to the case in which the base point P can be different for each execution of the algorithm. In the fixed-base case, multiples of a public constant point can be precomputed, which allows different optimization possibilities. In Appendix A we present an algorithm for the double-scalar scenario, which carries out a computation of the form k 1 P 1 + k 2 P 2 (see Algorithm 9). This occurs for example in the verification of ECDSA signatures. In this setting the verification algorithm operates on public inputs only, and one can profit from more efficient variable-time algorithms since the implementation does not require sidechannel protection or constant-time execution. We discuss the various cases for implementing scalar multiplication for the different curve models and algorithm choices. We list all algorithms as pseudo-code in Appendix A (scalar multiplication, point validation, precomputation and recoding) and in Appendix B (point operations). The reader is referred to Appendix C for complete details on the selection of explicit formulas. Note that several of these algorithms contain if-statements, which are marked in the pseudo-code according to their nature. For example, some of these statements occur in algorithms that are only run on public inputs and do not need to run in constant time; some of them are implemented in constant time via masking techniques; and some of them are there merely to allow us to represent several algorithms in one pseudo-code algorithm environment and to re-use the different variants in different scenarios. As soon as a specific scenario is chosen, these statements are always executed under the same condition. The remaining if-statements are the ones that when implemented introduce data-dependent branches into the algorithms. They occur only in algorithms for point doubling, point addition and merged point doubling/addition, where they correspond to exceptions, i.e., the exceptional cases for which the given formulas are not valid. But, whenever the implementation needs to be constant-time, the conditions for entering these if-statements are always false such that they are never executed (and can be removed in the code). Below, we argue that indeed no exceptional cases occur and that the proposed algorithms can be implemented to run in constant time (when used as described in the algorithms in Appendix A). Note that the neutral element on Weierstrass curves is the point at infinity, i.e., the point (0 : 1 : 0) in projective coordinates, while on twisted Edwards curves the neutral element is the rational point (0, 1), and in the Montgomery ladder the neutral element is (X : Z ) = (0 : 0). In this paper, they are all denoted by O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Weierstrass scalar multiplications</head><p>Let E b /F p be any of the Weierstrass curves in Table <ref type="table" target="#tab_1">1</ref>, with r = #E b (F p ) prime. Let k be an integer scalar and P = (x 1 , y 1 ) ∈ F p × F p . We consider the computation of efficient, constant-time and exception-free scalar multiplications in two scenarios.</p><p>The variable-base scenario On input of the scalar k and variable point P = (x 1 , y 1 ), perform the following steps.</p><formula xml:id="formula_11">1. Validation Validate that k ∈ [1, r ) and that P = (x 1 , y 1 ) ∈ E b (F p )\{O} by checking that y 2 1 = x 3 1 - 3x 1 + b. Otherwise, return false (see Algorithm 2).</formula><p>2. Precomputation For a fixed window size 2 ≤ w &lt; 10, compute the 2 w-2 multiples {P, 3P, . . . , (2 w-1 -1)P} of P, and store them in a lookup table. This precomputation can be achieved using one point doubling and 2 w-2 -1 point additions 3 (see Algorithm 4). 3. Scalar recoding Convert the scalar k to odd by replacing k with rk (if even) and recode it into exactly log 2 (r )/(w -1) + 1 odd, signed, non-zero digits in {±1, ±3, . . . , ±(2 w-1 -1)} (see Algorithm 6). 4. Evaluation Compute k P using a fixed window with the precomputed values from the previous step. This requires exactly (w -1) log 2 (r )/(w -1) point doublings and log 2 (r )/(w -1) point additions, or (w -2) log 2 (r )/(w -1) + 1 point doublings, log 2 (r )/(w -1) -1 point doubling-additions and one addition when w &gt; 2. Note that every time an addition is performed, we also negate the selected point in the look-up table, and choose the correct one according to the sign of the digit in the recoded scalar. This is repeated until the last iteration, when crucially, the final addition is performed via a "complete masked" addition (see Appendix C.1). The final result is negated if the original value of k was even.</p><p>This can be computed as outlined in Algorithm 1 in Appendix A. <ref type="table" target="#tab_1">1</ref> using Algorithm 1 to implement the steps above, no exceptions occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1 When computing variable-base scalar multiplications on any of the Weierstrass curves in Table</head><p>Before proving the proposition, we fix notation to partition the non-zero points in a prime order subgroup of the group E b (F p ). For a fixed point Proof To exclude any exceptions in the course of Algorithm 1, we consider all of its doubling, addition and merged doubling/addition operations. First of all, it is easy to see that all doubling and addition steps for building the look-up table are exception-free. Note that the look-up table consists exactly of the points in the set T defined above. The precomputation as shown in Algorithm 4 starts by doubling P with Algorithm 10. The algorithm works for the point at infinity O when defined as (0 : Y 1 : 0) with Y 1 = 0, but the case 3 Except for when w = 2, where this comes for free. P = O is excluded by point validation, and it does not have any exceptions since there are no points of order 2 in the group E(F p ). The points for the look-up table are then computed by adding 2P ∈ S even to points from T ⊂ S odd only, i.e., the input points to the additions are always different and do not include O. Also -2P = (r -2)P is not among these points because 2 w-1 -1 &lt; r -2 (note 2 ≤ w &lt; 10).</p><formula xml:id="formula_12">P ∈ E b (F p )\{O}, the map [1, r ) → E b (F p )\{O}, k → k P is a bijection. It</formula><p>The operations in the evaluation stage depend on the recoding of the scalar k, which at this point in the algorithm satisfies 0 &lt; k &lt; r . Let t = log 2 (r )/(w -1) , then with notation as in Algorithm 1, the scalar can be written as</p><formula xml:id="formula_13">k = t i=0 s i |k i |2 (w-1)i ,</formula><p>where s i ∈ {-1, 1} and k i ∈ Z with 0 &lt; |k i | &lt; 2 w-1 . The recoding used here guarantees k t &gt; 0 such that s t = 1 and |k t | = k t . Throughout the evaluation stage, the variable Q is used to denote the running value during the algorithm. At any stage, there is some z ∈ [0, r ) such that Q = z P. Let z 1 &gt; 0 and z 2 = 2 w-1 z 1 ±z 0 with z 0 ∈ {1, 3, . . . , 2 w-1 -1}, then z 2 ≥ z 1 . If z 1 &gt; 1, we even have z 2 &gt; z 1 . This means that whenever a positive integer is doubled w -1 times and then an integer corresponding to one of the elements in the look-up table is either added or subtracted, the result cannot be smaller than the original integer. Thus, in the evaluation stage of Algorithm 1, after each sequence of w -1 doublings and one addition step, the value z of the running point Q cannot decrease.</p><p>The evaluation stage begins with choosing an element from the lookup table T and assigning it to Q. After the first assignment, we have z ∈ {1, 3, . . . , 2 w-1 -1}. All the doubling operations in Lines 11, 14 and 18 of Algorithm 1 are done using Algorithm 10. Therefore, for the same reasons as explained above there are no exceptions possible in these steps. The last addition in Line 19 is done with a complete addition formula and hence also does not have any exceptional cases. It now suffices to ensure that all remaining addition steps (i.e., in Lines 12 and 15) do not run into exceptions.</p><p>First, assume that an exceptional case occurs in one of the additions in Step 15, which computes Q + R for R ∈ T ∪T -1 using Algorithm 2. Note that none of the doubling steps can ever output O because there are no points of order 2 and O is never input to any of them since the running value Q always has 1 &lt; z &lt; r for all points input to doubling steps prior to any of the additions in Step 15. Thus the only exceptional cases that could occur in this algorithm, are the cases where Q = ±R. This means that either</p><formula xml:id="formula_14">Q ∈ T or Q ∈ T -1 .</formula><p>Since Q is the output of a non-trivial doubling operation, we have Q ∈ S even which excludes Q ∈ T and means that Q ∈ T -1 . Therefore, Q = z P with z ≥ r -(2 w-1 -1). After each addition in Step 15 there are always w -1 doublings that follow. Hence, the minimal value for z that can occur after the exceptional addition and the following doublings is 2 w-1 (r -2(2 w-1 -1)). The addition of a table element immediately after these doublings, can bring down this value to the minimal</p><formula xml:id="formula_15">z min = 2 w-1 (r -2(2 w-1 -1)) -(2 w-1 -1) = 2 w-1 r -(2 w + 1)(2 w-1 -1)</formula><p>. This value is larger than r , because otherwise, it follows that r ≤ 2 w + 1, which is not true for any of our curves. Given the observation that a positive integer does not decrease after any sequence of w -1 doublings and a following addition of an integer corresponding to a look-up table element, the scalar k cannot be reached any more as the final value for z after the exceptional addition. This contradicts any exceptions in the additions of <ref type="bibr">Step 15.</ref> Next, assume that an exception occurs in one of the steps in Line 12 of Algorithm 1. This step is a merged doubling and addition step and is computed via Algorithm 11. The algorithm computes 2Q+ R for R ∈ T ∪T -1 as (Q+ R)+ Q. For the same reasons as above, the input point Q cannot be equal to O. Since R ∈ T ∪ T -1 , we have R = O. The first addition Q + R could have the same exceptions as the additions in Step 15 treated in the previous paragraph. This means that an exception can only be Q ∈ T -1 as above and again we look at the minimal value z min after carrying out the exceptional addition, the addition of Q and the following w-1 doublings and subsequent addition (also the steps including the merged doubling and addition algorithm can be treated as such). This value is</p><formula xml:id="formula_16">z min ≥ 2 w-1 • (2r -3(2 w-1 -1)) - (2 w-1 -1) = 2 w r -(3 • 2 w-1 + 1)(2 w-1 -1)</formula><p>. Again, this value is larger than r , because otherwise we would have r ≤ 3 • 2 w-1 + 1, which does not hold for our curve parameters. As above this means that the scalar k &lt; r cannot be reached as the final value of z, contradicting any exception in the first addition in (Q + R) + Q. Finally, we assume that there is an exception in the second addition. We have already excluded Q = O and Q + R = O. Hence, the only two possibilities for an exception are</p><formula xml:id="formula_17">Q + R = Q or Q + R = -Q. The first condition means that R = O which is not possible since R ∈ T ∪ T -1 .</formula><p>We are thus left with the condition 2Q = -R and hence either 2Q ∈ T or 2Q ∈ T -1 . Since 2Q ∈ S even , it cannot be in T , which leaves 2Q ∈ T -1 . This means that 2z ≥ r -(2 w-1 -1). The minimal value z min after the computation (Q + R)+ Q and the following w -1 doublings and another addition is</p><formula xml:id="formula_18">z min ≥ 2 w-1 (r -2(2 w-1 -1)) - (2 w-1 -1) = 2 w-1 r -(2 w +1)(2 w-1 -1).</formula><p>Again, this value is larger than r , leaving no way to achieve the scalar k during the remaining computation. This excludes all exceptions in Line 12 and therefore all exceptions in Algorithm 1.</p><p>Given that the recoding always produces a fixed length for the scalar, this means that after a successful validation step, we do not execute any conditional statements.</p><p>The fixed-base scenario In this setting, the point P is fixed (e.g., as a public parameter of the system), so multiples of P can be precomputed offline and used to speedup the online computation of k P. In terms of performance, it might be difficult to select the "optimal" size of the precomputed table. A larger table with more multiples of P typically means a reduced number of elliptic curve operations at runtime, but such tables might result in cache-misses which can result in a performance penalty. Moreover, when one wants to extract elements from this table in a cache-attack resistant manner, one should access every element and mask out the correct value to avoid leaking access patterns. Hence, using a larger table implies an increased access cost for every table-lookup. This is not the only problem with large precomputed tables. As far as we know, one cannot show (for all inputs) that a current active point in the fixed-base scalar multiplication will not be the same (or have an opposite sign) as one of the many precomputed values. Although this might happen only with extremely low probability, such that honest parties may never encounter this by accident, active adversaries could manipulate such scalar/point combinations to force exceptions. This means that, unlike the variable-base multiplication, the implementation of the group law must cover exceptional cases. One solution is to use complete formulas (which have no exceptional cases). Unfortunately, the complete Weierstrass formulas from <ref type="bibr" target="#b18">[18]</ref> (see Appendix C.1) are expensive compared to their incomplete counterparts, and using these would incur a much larger relative penalty than the complete formulas on (twisted) Edwards curves do. Another possible solution is to always compute two candidates for the addition, C 1 = 2P and C 2 = P + L, and select (in a constant time manner)</p><formula xml:id="formula_19">C 1 if P = L , O if P = -L , L if P = O, P if L = O,</formula><p>and C 2 otherwise. At a first glance this approach seemingly increases the cost of an addition to be at least that of computing both an addition and a doubling. However, as noted by Chevallier-Mames et al. <ref type="bibr" target="#b22">[22]</ref> for the case of binary affine operations, doubling and addition share several similarities in their formulas. By observing that these similarities naturally reflect to the projective formulas, we present a solution that achieves the required behavior explained above without increasing the number of modular multiplications or squarings required in a dedicated point addition (see Algorithms 18 and 19). The idea is to exploit the similarities in the doubling and addition routines by masking out the correct operands first, and using these as inputs to the arithmetic operations.</p><p>Hence, Algorithms 18 and 19 work for any input points, do not have any exceptional cases and have roughly the same run-time as their corresponding dedicated point additions. We note that Chevallier-Mames et al.'s approach tries to address a different problem and hence produces different formulas. In particular, they exploit similarities in the affine formulas to build (separate) routines for doubling and addition with the same pattern of field operations. This is done in order to eliminate differences in the power traces of the doubling and addition executions. In projective coordinates, however, the same approach would not work because of the extra operations required by addition in comparison to doubling (in this case, point operations are partitioned into smaller atomic units, each with the same pattern of field operations. Thus, this technique does not exploit similarities between doubling and addition).</p><p>For a scalar k and the fixed point P = (x 1 , y 1 ), we make use of these formulas to perform the following steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Offline computation</head><formula xml:id="formula_20">1. Point validation Validate that P = (x 1 , y 1 ) ∈ E b (F p )</formula><p>\{O} by checking that y 2 1 = x 3 1 -3x 1 + b. Otherwise, return false (see Algorithm 2). 2. Precomputation For a fixed window size 2 ≤ w &lt; 10, compute v &gt; 0 tables of 2 w-1 points (each) for the mLSB-set comb method (see Line 2 of Algorithm 7). Convert all points in the lookup table to affine form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Online computation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Scalar validation Validate that the scalar k ∈ [1, r ).</head><p>Let the maximum bit-length of all valid scalars be t = log 2 (r ) . 4. Recoding Convert the scalar k to odd by replacing it with rk (if even) and recode it into the mLSB-set representation (see Algorithm 8). 5. Evaluation Using the precomputed values from the offline precomputation, compute k P with exactly t w•v -1 point doublings and v t w•v -1 point additions. <ref type="foot" target="#foot_1">4</ref>All point additions are computed using the "complete masked" approach in Algorithm 18 in Appendix C.1. The final result is negated if the original value of k was even. This approach is outlined in Algorithm 7 in Appendix A. <ref type="table" target="#tab_1">1</ref> using Algorithm 7 to implement the steps above, no exceptions occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2 When computing fixed-base scalar multiplications on any of the Weierstrass curves in Table</head><p>Proof Following the proof of Proposition 1, point doublings computed via Algorithm 10 do not fail for any rational points in E b (F p ) for any of the curves E b in Table <ref type="table" target="#tab_1">1</ref>. Furthermore, Algorithm 10 also correctly computes doublings at the point at infinity, O. Thus, no exceptions can arise in point doublings; and, since all online additions are implemented using the "complete" masking technique described in Appendix C.1, it follows that no exceptions can arise at any stage of the online computation (offline computations can also make use of this technique if necessary).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Twisted Edwards scalar multiplications</head><p>Let E d /F p :x 2 + y 2 = 1 + dx 2 y 2 be any of the twisted Edwards curves in Table <ref type="table" target="#tab_2">2</ref>, with #E(F p ) = 4r for r prime. In a similar vein to <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b34">34]</ref>, we avoid small subgroup attacks by requiring all scalar multiplications to include a cofactor 4. Thus, let the integer k be defined as k := 4k with k ∈ [1, r ), and let P = (x 1 , y 1 ) be in F p × F p .</p><p>The variable-base scenario On input of k and (variable) P = (x 1 , y 1 ) ∈ F p × F p , we perform the following steps. </p><formula xml:id="formula_21">Q = O.</formula><p>If not, reject. 4. Precomputation Compute the 2 w-2 odd, positive multiples {Q, 3Q, . . . , (2 w-1 -1)Q} of Q, and store them in a lookup table. This precomputation can be achieved using one point doubling and 2 w-2 -1 point additions <ref type="foot" target="#foot_2">5</ref>(see Algorithm 4). 5. Scalar recoding Using a window size of 2 ≤ w &lt; 10, convert the updated scalar k := k/4 ∈ [1, r -1] to odd by setting k to rk (if even) and recode it into exactly log 2 (r )/(w -1) + 1 odd, signed, non-zero digits in {±1, ±3, . . . , ±(2 w-1 -1)} (see Algorithm 6). 6. Evaluation Compute k P as k Q, using exactly (w -1) log 2 (r )/(w -1) point doublings and log 2 (r )/(w -1) point additions. Note that every time an addition is performed, we also negate the selected point in the lookup table, and choose the correct one according to the sign of the digit in the recoded scalar. This is repeated until the last iteration, when crucially, the final addition is performed using the unified formula in [35, Eq. ( <ref type="formula">5</ref>)]. The final result is negated if the original value of k was even.</p><p>This computation is given in Algorithm 1 in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3 When computing variable-base scalar multiplications on any of the twisted Edwards curves in Table 2</head><p>using Algorithm 1 to implement the steps above, no exceptions occur.</p><p>Proof The first three steps (validation, clear torsion, and revalidation) detailed in Sect. 4.2 ensure that the point Q has large prime order r . Furthermore, only elements of Q are encountered after the revalidation stage, meaning that Corollary 1 from <ref type="bibr" target="#b35">[35]</ref> can be invoked to say that the additions in Algorithm 15 (from <ref type="bibr" target="#b35">[35]</ref>, but extended according to the representation suggested in <ref type="bibr" target="#b32">[32]</ref>) will never fail to add points P and Q of odd order, except when P = Q. This corollary also tells us that the formulas for point doubling in Algorithm 14 never fail for points of odd order. Similar to the addition formulas, these doubling formulas, which are from <ref type="bibr" target="#b7">[7]</ref>, are extended according to <ref type="bibr" target="#b32">[32]</ref>. Thus, the proof from this point is identical to the proof of Proposition 1: we partition the elements in Q \{O} into S odd and S even to categorize the elements in the look-up table, and use this to show that the running value that is input into point additions can never be equal to an element in the look-up table, except possibly in the final addition, where we use the formula in [35, Eq. ( <ref type="formula">5</ref>)], which is slightly slower, but is exception-free in Q .</p><p>The fixed-base scenario Let P = (x 1 , y 1 ) ∈ F p × F p be a fixed point and let k = 4k be an integer scalar, which is a multiple of the cofactor 4. Then perform the following steps.</p><p>Offline computation  <ref type="foot" target="#foot_3">6</ref> Every one of these additions is computed using the unified formulas from [35, Eq. ( <ref type="formula">5</ref>)]. The final result is negated if the original value of k was even.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 7 in Appendix A outlines this computation. Proposition 4 When computing fixed-base scalar multiplications on any of the twisted Edwards curves in Table 2 using Algorithm 7 to implement the steps above, no exceptions occur.</head><p>Proof As in the proof of Proposition 3, we start by noting that the (updated) point Q has odd order r , and that we only compute on elements in Q . The only algorithm we use for online additions corresponds to the formulas in [35, Eq. ( <ref type="formula">5</ref>)], which do not fail for any pair of inputs in Q . Additionally, the only algorithm we use for doublings is Algorithm 14 (from <ref type="bibr" target="#b7">[7]</ref>), which is also exception-free on all inputs from Q .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Montgomery ladder</head><p>Let E A /F p : y 2 = x 3 + Ax 2 + x be the Montgomery form of any of the curves in Table <ref type="table" target="#tab_2">2</ref>, with #E A (F p ) = 4r , for r a large prime. Since the Montgomery ladder is not compatible with the recoding techniques discussed in Sect. 4, we take the following route to guarantee a fixed length scalar. For all k ∈ [1, r -1], we use the updated scalar k = 4(αr +k), where α is the smallest positive integer such that αr +1 and (α +1)r -1 have the same bitlength; α is specific to r , but for each of the curves in Table <ref type="table" target="#tab_2">2</ref> we have α ∈ {1, 2, 3}. Note that scalar multiplication by k corresponds to scalar multiplication by 4k on E A , which thwarts small subgroup attacks in the same way as the twisted Edwards scalar multiplications in Sect. 4.2.</p><p>On input of k and x 1 ∈ F p , we perform the following steps. Notice that there is no validation of the input coordinate x 1 ∈ F p , i.e., that we do not check whether x 3 1 + Ax 2 1 +x 1 is a square in F p , so that x 1 corresponds to a point (or points) on E A . Avoiding this check in the presence of twist-security is due to Bernstein (cf. <ref type="bibr" target="#b4">[5]</ref>), since even if x 1 corresponds to a point on the quadratic twist E A , the output of the Montgomery ladder corresponds to a scalar multiplication on E A , because scalar multiplications on both curves use the same constant (A + 2)/4. In this case, multiplication by k = 4(αr + k) on E A no longer corresponds to the scalar 4k, but rather to the scalar 4k , where k ≡ (αr + k) mod r for #E A (F p ) = 4r . This is not a problem in practice since the cofactor of 4 still clears torsion on the twist, and the twist-security ensures that the discrete logarithm problem has a similar difficulty in E A (F p ) as it does in E A (F p ). Following the arguments developed in <ref type="bibr" target="#b3">[4]</ref> (see also <ref type="bibr" target="#b4">[5,</ref><ref type="bibr">App.</ref> A-B]), it could be possible to prove that no exceptions can occur in Montgomery ladder implementations of the curves in Table <ref type="table" target="#tab_2">2</ref> that follow Steps 1-3 above, subject to addressing the issues below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Scalar validation</head><p>It should first be pointed out that the lack of validation means that there are some scalar/point combinations which could produce exceptions. For example, suppose k is chosen as the unique integer less than r such that k ≡ -αr mod r . If k is also less than r , then k := 4(αr + k) is a valid scalar according to Step 1 above. But, if an unvalidated x-coordinate, say x 1 , corresponds to a point P 1 on E A , then k P 1 = O, because (αr + k) ≡ 0 mod r ; note that outputting O in Step 3 above could leak information to an attacker. Furthermore, in practice these ladder implementations are often used in conjunction with non-ladder implementations on (most likely a twisted Edwards model of) the same curve-see Sect. <ref type="bibr" target="#b6">6</ref>. In such a scenario, the refined forms of the scalars in this section do not match the forms of the scalars in Sect. 4.2, so if the scalars above were to be used on the twisted Edwards form of E A , then Proposition 3 and Proposition 4 no longer provide any guarantees. More specifically, if an implementation synchronizes the inherently larger Montgomery ladder scalars above to also be used on the twisted Edwards curve, then the argument of k ∈ [4, 8, . . . , 4(r -1)] that was used in the proof of Proposition 3 no longer holds when α &gt; 0. Roughly speaking, the fact that k/4 is now outside the range [1, r -1] means that the running multiple of an input point can now reach the dangerous stage of a scalar multiplication (which we handle by using complete additions) before the final addition.</p><p>In the Montgomery ladder implementation of Curve25519 <ref type="bibr" target="#b4">[5]</ref>, and in the complementary Edwards "Ed25519" implementation <ref type="bibr" target="#b9">[9]</ref>, it seems that the above problems are overcome by restricting the set of permissible scalars to be of a lesser cardinality than the prime subgroup order. Namely, Curve25519 has r, r &gt; 2 252 , with all scalars being of the form k = 8 • (2 251 + k) for k ∈ [0, 2 251 -1]. As well as guaranteeing that all of the possible scalars k have the same bitlength, this prevents the existence of a k such that k ≡ 0 mod r or k ≡ 0 mod r . On the other hand, it also means that for a fixed base point P of order r on Ed25519, less than half of the elements in P are possible outputs when computing scalar multiplications of P.</p><p>As one potential alternative, we remark that a hybrid solution which uses both Montgomery and twisted Edwards scalar multiplications could parse scalars differently: k ∈ [0, r -1] could be modified to k := 4(αr + k) in the Montgomery implementation, but modified to k := 4k in the twisted Edwards implementation. If, in addition, all xcoordinates were validated in Step 1 of the Montgomery ladder routine, 7 then this may well be enough to prove that all 7 Validating that x 1 ∈ F p corresponds to E A would incur the small relative cost of an exponentiation and a few multiplications: namely, we reject</p><formula xml:id="formula_22">x 1 if (x 3 1 + Ax 2 1 + x 1 ) ( p-1)/2 = -1.</formula><p>scalar multiplications compute correctly and without exception: Proposition 3 would then apply directly to the twisted Edwards part, while the techniques in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> could be used to prove the Montgomery ladder part.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation results</head><p>To evaluate the performance of the selected curves, we developed a software library<ref type="foot" target="#foot_4">8</ref> that includes support for three scenarios: variable-base, fixed-base and double-scalar multiplication. The library can perform arithmetic on a = -1 twisted Edwards, a = -3 Weierstrass and Montgomery curves, and supports all of the new curves from Sect. 3, with exception of the Weierstrass curves with reduced bitlength (see Tables <ref type="table" target="#tab_3">1,</ref><ref type="table" target="#tab_2">2</ref>). The implementation of the library is largely in the C-programming language with the modular arithmetic implemented in x64 assembly for Windows.</p><p>Taking the above into account, we remark that the purpose of the library is to allow the comparison and evaluation of a large number of curve options, using a generic design that is flexible, reduces code size, and eases maintenance effort. Nevertheless, the library achieves good performance in comparison with standalone implementations that are tailored towards speed records.</p><p>It is well known that it is non-trivial to create an efficient and secure implementation of cryptographic primitives (for use in elliptic curve cryptography). Complete formulas might avoid certain pitfalls to the programmer, but this can come at a performance cost. As illustrated in Sect. 4, and by our software library, it is possible to have efficient, constant-time, and exceptionless scalar multiplications with a reasonable easy implementation strategy.</p><p>Table <ref type="table" target="#tab_5">3</ref> shows the performance details of scalar multiplication in the three scenarios of interest. Variable-base scalar multiplication is computed with the fixed-window method (see Algorithm 1 in Appendix A) using window width w = 6. Fixed-base scalar multiplication was computed using the mLSB-set method (see Algorithm 7 in Appendix A) using parameters w = 5 and v = 4 for the twisted Edwards curves at the 128-bit security level; all other cases use w = 6 and v = 3. These values correspond to precomputed tables of sizes: 6, 9 and 12 KB for Weierstrass curves at the 128-, 192-and 256-bit security levels, respectively, and 6, 13.5 and 18 KB for twisted Edwards curves at the 128-, 192-and 256-bit security levels, respectively. Double scalar multiplication was computed using the wNAF method with interleaving (see Algorithm 9 in Appendix A) using window width w 1 = 6 for the variable base and w 2 = 7 The results (rounded to thousand cycles) are the average of 10 4 runs of the scalar multiplication including the final modular inversion to convert the result to its affine form. These results have been obtained on a 3.4 GHz Intel Core i7-2600 Sandy Bridge processor with Intel's Turbo Boost and Hyper-Threading disabled.</p><p>The library was compiled with Visual Studio 2012 on Windows 8 OS for the fixed base. The latter corresponds to precomputed tables with sizes: 2, 3 and 4 KB for Weierstrass curves at the 128-, 192-and 256-bit security levels, respectively, and 3, 4.5 and 6 KB for twisted Edwards curves at the 128-, 192-and 256-bit security levels, respectively. The results (expressed in terms of computer cycles) were obtained by running and averaging 10 4 iterations of each computation on an Intel Core i7-2600 (Sandy Bridge) processor with Intel's Turbo Boost and Hyper-Threading disabled. The variableand fixed-base scalar multiplication routines have a constant running time which guards against various types of timing attacks <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b38">38]</ref>, including cache attacks <ref type="bibr" target="#b50">[50]</ref> (e.g., see <ref type="bibr" target="#b19">[19]</ref> in the asymmetric setting). This means that no conditional branches on secret data or secret indexes for table lookups are allowed in the implementations.</p><p>Our results suggest that reducing the size of the pseudo-Mersenne primes does not have a significant effect on the performance: below a factor 1.04 reduction of the running time at the expense of roughly half a bit of ECDLP security. However, using slightly smaller moduli in the setting of the Montgomery-friendly primes does pay off: a reduction of the running time by a factor 1.20, 1.11, and 1.09 at the 128-, 192-, and 256-bit security level, respectively. This performance difference between pseudo-Mersenne and Montgomery-friendly primes can be explained by the fact that the final constant-time conditional subtraction in Montgomery multiplication can be omitted when reducing the modulus size appropriately. The size-reduced Montgomeryfriendly primes are the best choice (with respect to performance) at the 128-and 192-bit security levels while the size-reduced pseudo-Mersenne prime is faster for the 256-bit security level. For full-word length moduli, Montgomeryfriendly and pseudo-Mersenne primes achieve similar performance at the 128-bit security level, whereas full-word length pseudo-Mersenne moduli are the best option for the 192-and 256-bit security levels. The better performance of pseudo-Mersenne primes at high security levels can be explained by the inherent higher register pressure in our Montgomeryfriendly implementations which results in more load and store operations for large moduli sizes. The faster arithmetic operations in the base field translate directly to optimizations in the different scenarios for the scalar multiplication.</p><p>In the setting of variable-base scalar multiplication the twisted Edwards implementation and the Montgomery ladder achieve similar performance at the 128 and 192-bit security levels. At the 256-bit security level the gap increases in favor of twisted Edwards which outperforms the Montgomery ladder by a factor 1.05.</p><p>Note that our best results using the twisted Edwards and Montgomery forms at the 128-bit security level are virtually equivalent to the state-of-the-art Montgomery ladder implementation of Curve25519 <ref type="bibr" target="#b4">[5]</ref> (194, 000 cycles on the benchmark machine "sandy0" <ref type="bibr" target="#b13">[13]</ref>). Given the significant level of code optimization applied on the Curve25519 implementation which includes full use of assembly for the curve and field arithmetic, this comparison demonstrates the high efficiency of the chosen 254-bit Montgomery-friendly prime.</p><p>The state-of-the-art implementation of the NIST P-256 curve <ref type="bibr" target="#b31">[31]</ref> can compute a variable-base scalar multiplication in 400, 000 cycles on a Sandy Bridge CPU. Our curve w-256-mont offers better security properties and results in a 1.43 times reduction of the running time compared to <ref type="bibr" target="#b31">[31]</ref>. When switching from prime order Weierstrass curves using full size moduli to composite order twisted Edwards curves with size-reduced moduli one can expect a reduction in the running time by a factor between 1.25 and 1.44 at the price of a slight decrease in ECDLP security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Real-world protocols</head><p>Although significant research has been devoted to optimize the most popular ECC operation (the variable-base scalar multiplication), in real-world cryptographic solutions it is often not as simple as computing just a single scalar multiplication with an unknown base. Cryptographic protocols typically require a combination of different types of scalar multiplications including fixed-, variable-base and multiple-scalar operations. In this section we study the TLS protocol, more specifically the computation of the TLS handshake using the ECDHE-ECDSA cipher suite. We outline the impact of using different curve and coordinate systems in practice.</p><p>TLS with perfect forward secrecy Support for using elliptic curves in the TLS protocol is specified in RFC 4492 <ref type="bibr" target="#b14">[14]</ref>. The cipher suites specified in this RFC use the elliptic curve Diffie-Hellman (ECDH) key exchange, whose keys may either be long-term or ephemeral. We focus our analysis on the latter case (denoted by ECDHE) since it offers perfect forward secrecy. Besides the usage of elliptic curves in the DH key exchange, TLS certificates contain a public key that the server uses to authenticate itself: this is an ECDSA public key for the case of the ECDHE-ECDSA cipher suite. The TLS handshake, using the ECDHE-ECDSA cipher suite, consists of three main components. The ECDSA signature generation (fixed-base scalar multiplication), ECDSA signature verification (double scalar multiplication), and ECDHE (one fixed-and one variable-base scalar multiplication). <ref type="foot" target="#foot_5">9</ref> We consider Weierstrass and twisted Edwards curves separately, with and without point compression. The cost of decompressing a point in Weierstrass and twisted Edwards form is stated in Table <ref type="table">7</ref> (where we follow the approach described in <ref type="bibr" target="#b9">[9]</ref> to decompress points on twisted Edwards curves).</p><p>When using Weierstrass curves the situation is not complicated: transmitting compressed points costs a single conversion while no additional cost is needed when transmitting uncompressed points. In the setting of twisted Edwards curves there are more possibilities. The simplest approach is to only use the Montgomery form; however, this is expensive since the Montgomery ladder cannot take advantage of the fixed-base setting. One might consider a hybrid solution: computing the fixed-base scalar multiplication using the birationally equivalent twisted Edwards curve while computing the variable-base scalar multiplication using the Montgomery ladder. In such a hybrid solution the protocol should specify if the coordinates are transmitted in (compressed) twisted Edwards or Montgomery coordinates (which are already in compressed form). When using such a hybrid solution in the setting of ECDHE, transmitting the points in Montgomery form is best (see Table <ref type="table">7</ref>). The cost for the conversion (between Montgomery and twisted Edwards) is roughly the same as when only using twisted Edwards curves and transmitting compressed points.</p><p>Table <ref type="table" target="#tab_6">4</ref> gives the cost estimates for the separate components and total cost of the TLS handshake using the ECDHE-ECDSA cipher suite for different security levels. It includes the options with the best results for the cases of Weierstrass curves, twisted Edwards curves and the hybrid approach combining the use of the Montgomery ladder and twisted Edwards. The results suggest that the approach using only twisted Edwards achieves similar performance to the hybrid approach using the Montgomery ladder, while it avoids conversions between coordinate systems (the performance gap between both approaches is below 4 % in all the cases, compressed or uncompressed form). Furthermore, our Montgomery ladder implementations do not include the extra validation step discussed at the end of Sect. 4.3; if incorporated, this would incur additional overhead.</p><p>The results in Table <ref type="table" target="#tab_6">4</ref> also show that the use of twisted Edwards for the ECDHE and full ECDHE-ECDSA computations are approximately a factor 1.46, 1.26 and 1.24 faster in comparison to the Weierstrass curves at the 128-, 192and 256-bit security levels, respectively. We also include the Costs in cycles are estimated using the performance numbers from Table <ref type="table" target="#tab_5">3</ref>. These estimates do not include the modular inversion required outside scalar multiplication during ECDSA signing and verification. Estimates for the total cost correspond to the full handshake ECDHE-ECDSA involving authentication in both the server and client side. We assume the use of precomputed tables with 96 points to accelerate fixed-base scalar multiplication (64 points for twisted Edwards curves at the 128-bit security level). Similarly, we assume the use of precomputed tables with 32 points to accelerate double scalar multiplication (where one base is fixed). For comparison we state performance numbers for NIST P-256 <ref type="bibr" target="#b31">[31]</ref> which uses 150 KB of storage, and performance numbers when using the Ed25519 signature scheme <ref type="bibr" target="#b9">[9]</ref> (obtained from the benchmark machine "sandy0" <ref type="bibr" target="#b13">[13]</ref>). We consider that point transmission (T) in the key-exchange can be performed in uncompressed (U) or compressed (C) form results from <ref type="bibr" target="#b31">[31]</ref> when using NIST P-256. In <ref type="bibr" target="#b31">[31]</ref> the fixedbase scalar multiplication is implemented using a relatively large (slightly over 150 KB) lookup table for the fixed-base scalar multiplication. It is unclear if this implementation accesses the table-lookup elements in a cache-attack resistant manner and if the dedicated addition formula used takes care of exceptions, and if so if this is done in constant time. This might explain the faster implementation results.</p><p>As a reference we also include the results for Ed25519 [9] (obtained from the "sandy0" benchmark machine <ref type="bibr" target="#b13">[13]</ref>), which is a Schnorr-like signature scheme based on a twisted Edwards curve isomorphic to Curve25519. Note that <ref type="bibr" target="#b9">[9]</ref> only computes signatures; when computing ECDH one could use the approach as described in <ref type="bibr" target="#b4">[5]</ref> which uses the Montgomery ladder. In order to achieve perfect forward secrecy (ECDHE), the implementation can compute the fixed-base scalar multiplication using the Montgomery ladder (which is slow) or convert the point and compute the fixed-base scalar multiplication using the corresponding twisted Edwards curve (using a hybrid approach).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>In this paper we have presented new elliptic curves for cryptography targeting the 128-, 192-, and 256-bit security levels. By considering different choices for the base field arithmetic, pseudo-Mersenne and Montgomery-friendly primes, we deterministically selected efficient twisted Edwards curves as well as traditional Weierstrass curves. Instead of resorting to the slower complete formulas, we show how to compute efficient scalar multiplications by using constant-time, exceptionless, dedicated group operations. For the cases in which they are not guaranteed to be exceptionless, we have proposed an efficient "complete" addition formula based on masking techniques for Weierstrass curves. Our implementation of the scalar multiplication in the three most-widely deployed scenarios show that our new backwards compatible Weierstrass curves offer enhanced security properties while improving the performance compared to the standard NIST Weierstrass curves. At the expense of at most a few bits of ECDLP security, our new twisted Edwards curves offer a per-formance increase of a factor 1.2-1.4 compared to our new Weierstrass curves. We demonstrated the potential cryptographic impact by showing cost estimates for these curves inside the TLS handshake protocol.</p><p>The main computation the evaluation stage consists of t = log 2 )/(w -1) iterations each computing (w -1) doublings and one addition a from the precomputed table. For a = Weierstrass curves, the use of Jacobian coordinates is a popular choice for efficiency sons. If this used, Algorithm 1 can use an efficient merged doubling-addition formula <ref type="bibr" target="#b42">[42]</ref> when w &gt; 2 by setting DBLADD = true. Other cases, including Weierstrass curves with = 2 or twisted Edwards curves, should use DBLADD = f alse. Note that the evaluation of DBLADD is used to simplify the description of the algorithm. An implementation might choose for having separate functions for twisted Edwards and curves. Following the recommendations from Sect. 4, the last addition should be performed with a unified formula (denoted by ⊕) order to avoid exceptions and it has been separated from the main loop; see Steps 18 and 19. To constant-time execution, the points from the precomputed table should extracted by doing a full pass over all the points in the lookup table and masking the correct value with the index (|k i | -1)/2. Finally, a suitable conversion to affine coordinates may be computed at Step 21 (if required).</p><p>Algorithm 7 computes scalar multiplication for the fixedbase scenario using the modified LSB-set method <ref type="bibr" target="#b27">[27]</ref> (denoted by mLSB-set), which combines the comb method <ref type="bibr" target="#b40">[40]</ref> and LSB-set recoding <ref type="bibr" target="#b28">[28]</ref>. Refer to Sects. 4.1 and 4.2 for details on the use of the method with Weierstrass and twisted Edwards curves, respectively. This operation consists of computations executed offline, which involve point validation and precomputing multiples of the known input point, and computations executed online, which involve scalar validation, recoding and evaluation stages. As before, point validation for twisted Edwards using Algorithm 3 during the offline phase performs two doublings over the input point to ensure that the computation takes place in the large prime order subgroup. Again, it is the protocol implementer's responsibility to ensure that timing differences during the detection of errors do not leak sensitive information to an attacker. The implementer should choose a window width 2 ≤ w &lt; 10 and a table parameter v ≥ 1 according to efficiency and/or memory constraints, taking into account that the mLSB-set method requires v • 2 w-1 precomputed points. For example, selecting w = 6 and v = 3 for 256-bit scalar multiplication was found to achieve optimal performance in our implementations of Weierstrass curves when storage is constrained to 6 KB. During the online computation, the recoded scalar obtained from Algorithm 8 has a fixed length, which enables a fully regular execution when the representation is set up as described at Step 7. Since Algorithm 8 only recodes odd integers, we include a conversion step at Step 6 to deal with even values. The corresponding correction is performed at Step 13. In the evaluation stage, the main computation consists of e -1 = log 2 (r ) /(wv) -1 iterations each computing one doubling and v additions with a value from the precomputed table. Following Sect. 4, the additions should be performed with a unified formula (denoted by ⊕) to avoid exceptions. Note that, as described in the variable-base case, all the conditional computations using "if" statements as well as the extraction of points from the precomputed table should be executed in constant time in order to protect against timing attacks (with the exception of Step 3, which depends on public parameters; any potential leak through the detection of errors at Step 4 should be assessed by the protocol's implementer). Finally, a suitable conversion to affine coordinates may be computed at Step 14 (if required).</p><p>Algorithm 9 computes double-scalar multiplication, which is typically found in signature verification schemes, and uses the width-w non-adjacent form <ref type="bibr" target="#b54">[54]</ref> with interleaving <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b45">45]</ref>. We assume that one of the input points is known in advance (P 2 ) whereas the other one is a vari-able base (P 1 ). Hence, we distinguish two phases: offline, which involves validation of P 2 and a precomputation stage using the value w 2 ; and online, which involves scalar validation, point validation of P 1 and precomputation (using w 1 ), recoding and evaluation stages. Again, point validation for twisted Edwards curves with Algorithm 3 performs two doublings over the input points to ensure computation in the large prime order subgroup. The precomputation for both input points are performed as in the variable-base scenario using Algorithms 4 and 5 for a = -3 Weierstrass and a = -1 twisted Edwards curves, respectively. However, the implementer has additional freedom in the selection of w 2 since the precomputation for the fixed-base is done offline.</p><p>For example, we found that using w 1 = 6 and w 2 = 7 results in optimal performance in our implementations of Weierstrass curves when storage was restricted to 2, 3 and 4 KB for 128-, 192-and 256-bit security levels. In the online computation, recoding of the scalars is performed using <ref type="bibr" target="#b34">[34,</ref><ref type="bibr">Algorithm 3.35]</ref>. Accordingly, the evaluation stage consists of log 2 (r ) + 1 iterations, each consisting of one doubling and at most two additions (one per precomputed table). As in the variable-base case, for a = -3 Weierstrass curves using Jacobian coordinates one may use the merged doublingaddition formula <ref type="bibr" target="#b42">[42]</ref> by setting DBLADD = true. A suitable conversion affine coordinates may be computed at Step 39 (if Twisted Edwards curves Hisil et al. <ref type="bibr" target="#b35">[35]</ref> derive efficient formulas for additions on (special) twisted Edwards curves <ref type="bibr" target="#b7">[7]</ref> by representing affine points (X/Z , Y/Z ) on E d :x 2 + y 2 = 1 + dx 2 y 2 by the projective tuple (X : Y : Z : T ), where T = XY/Z . Hamburg <ref type="bibr" target="#b32">[32]</ref> proposes to represent such a projective point using five elements: (X : Y : Z : T 1 : T 2 ), where T = T 1 T 2 . This has the advantage of avoiding a required look-ahead when computing the elliptic curve scalar multiplication using the techniques from <ref type="bibr" target="#b35">[35]</ref>.</p><p>If the addition formulas are "dedicated" they do not work for doubling but are usually more efficient. The details of the dedicated additions used in our implementation are outlined in Algorithms 15 and 16. For settings that might trigger exceptions in the formulas (e.g., fixed-based scalar multiplication), one can use the unified addition formula proposed by <ref type="bibr" target="#b35">[35]</ref> (see <ref type="bibr">Algorithm 17)</ref>. The algorithm for point doubling on E d is given in Algorithm 14: this extends the formula from <ref type="bibr" target="#b7">[7]</ref> by using the five element representation as suggested in <ref type="bibr" target="#b32">[32]</ref>.</p><p>When storing precomputed points, we follow the caching techniques described in <ref type="bibr" target="#b35">[35]</ref>: we store affine points as (x + y, yx, 2t) with t = x y, or projective points as (X + Y : Y -X : 2Z : 2T ) with T = XY/Z , both of which can speed up the scalar multiplication computation. Just as in the case of the Weierstrass curves above, it is usually advantageous to leave the precomputed points in projective form for variable-base computations, and to convert them (offline) to their affine form for fixed-base computations. The explicit routine that performs the precomputation for the variablebase scenario is outlined in Algorithm 5. The costs of the different formulas used in our implementation are displayed in Table <ref type="table" target="#tab_7">5</ref>. The Weierstrass point doubling works on Jacobian coordinates while the point addition formula takes as input one Jacobian (Jac) coordinate and the other in either affine (aff) or (projective) Chudnovsky coordinates. We also show a merged double-and-add approach which computes R = 2P + Q where R and P are in Jacobian and Q in Chudnovsky coordinates. The complete addition formulas also include the number of table look-ups (denoted by #lut) that are required for their realization. The Edwards doubling uses the five-element projective coordinates (X : Y : Z : T 1 : T 2 ). The Edwards addition adds a five-element projective coordinate (X : Y : Z : T 1 : T 2 ) to a four-element projective coordinate (X + Y : Y -X : 2Z : 2T ) (proj.) or a three-element extended affine coordinate (x + y, yx, 2t) (aff.) resulting in a five-element coordinate as a result. The performance of a single step of the Montgomery ladder (which computes a doubling and a differential addition) is stated as well additions in this way is much more costly than computing incomplete additions.</p><p>For the sake of comparison, we present the simplified version of the complete formulas 10 from <ref type="bibr" target="#b18">[18]</ref>, which are specialized to short Weierstrass curves of the form E : y 2 = x 3 + ax + b. For two input points P 1 = (X 1 : Y 1 : Z 1 ) and P 2 = (X 2 : Y 2 : Z 2 ) in homogeneous projective space, the two candidate sums P 3 = (X 3 : Y 3 : Z 3 ) and P 3 = (X 3 : Y 3 : Z 3 ) are computed as 10 We also corrected some typos in <ref type="bibr" target="#b18">[18]</ref> that were pointed out in <ref type="bibr" target="#b6">[6]</ref>.</p><formula xml:id="formula_23">X 3 = (X 1 Y 2 -X 2 Y 1 )(Y 1 Z 2 + Y 2 Z 1 ) -(X 1 Z 2 -X 2 Z 1 )(a(X 1 Z 2 + X 2 Z 1 ) + 3bZ 1 Z 2 -Y 1 Y 2 ); Y 3 = -(3X 1 X 2 + a Z 1 Z 2 )(X 1 Y 2 -X 2 Y 1 ) +(Y 1 Z 2 -Y 2 Z 1 )(a(X 1 Z 2 + X 2 Z 1 ) + 3bZ 1 Z 2 -Y 1 Y 2 ); Z 3 = (3X 1 X 2 + a Z 1 Z 2 )(X 1 Z 2 -X 2 Z 1 ) -(Y 1 Z 2 + Y 2 Z 1 )(Y 1 Z 2 -Y 2 Z 1 ); X 3 = -(X 1 Y 2 + X 2 Y 1 )(a(X 1 Z 2 + X 2 Z 1 ) +3bZ 1 Z 2 -Y 1 Y 2 ) -(Y 1 Z 2 + Y 2 Z 1 ) (3b(X 1 Z 2 + X 2 Z 1 ) + a(X 1 X 2 -a Z 1 Z 2 )); Y 3 = Y 2 1 Y 2 2 + 3a X 2 1 X 2 2 -2a 2 X 1 X 2 Z 1 Z 2 -(a 3 + 9b 2 )Z 1 Z 2 2 + (X 1 Z 2 + X 2 Z 1 ) (3b(3X 1 X 2 -a Z 1 Z 2 ) -a 2 (X 2 Z 1 + X 1 Z 2 ));</formula><formula xml:id="formula_24">Z 3 = (3X 1 X 2 + a Z 1 Z 2 )(X 1 Y 2 + X 2 Y 1 ) +(Y 1 Z 2 + Y 2 Z 1 )(Y 1 Y 2 + 3bZ 1 Z 2 +a(X 1 Z 2 + X 2 Z 1 )).<label>(1)</label></formula><p>In the case of a = -3 short Weierstrass curves, like the prime order curves in this paper, we found that the computations in (1) require at most <ref type="foot" target="#foot_6">11</ref> 22 multiplications, 3 multiplications by b, and one multiplication by b 2 -3. The adaptation of the formulas to points in Jacobian coordinates can be achieved in the obvious way at an additional cost of 6 multiplications and 3 squarings: preceding (1), we can transform from Jacobian coordinates to homogeneous coordinates by taking X i ← X i • Z i and then Z i ← Z 3 i for i = 1, 2; and, following the correct choosing of P 3 = (X 3 : Y 3 : Z 3 ), we can move back to Jacobian coordinates by taking X 3 ← X 3 • Z 3 and then Y 3 ← Y 3 • Z 2  3 . Although the formulas in (1) are mathematically satisfactory, their computation costs around twice as much as an incomplete addition (see Table <ref type="table" target="#tab_7">5</ref>), which renders them far from satisfactory in cryptographic applications. On the other hand, the work-around we present in Algorithm 19 and Algorithm 18, while perhaps not as mathematically elegant, is equivalent for all practical purposes and incurs a much smaller overhead over incomplete formulas. In particular, there are no additional multiplications or squarings (on top of those incurred during an incomplete addition) required when performing a complete addition via this masking approach (Tables <ref type="table">6,</ref><ref type="table">7</ref>).</p><p>As briefly discussed in Sect. 4.1, the idea is to exploit the similarity between the sequences of operations computed in a doubling and an addition. On input of P and Q, one would ordinarily compute the doubling 2P and the (non-unified) addition P + Q and mask out the correct result at the end, depending on whether P = Q. However, the detection of P = Q (or not) can be achieved much earlier in projective space using only a few operations that are common to both doublings and non-unified additions-see Line 17 (resp. Line 12) in Algorithm 19 (resp. <ref type="bibr">Algorithm 18)</ref>. After this detection, the required operation (doubling or addition) is achieved by masking correct inputs and outputs through a sequence of subsequent computations, those which overlap in the explicit formulas for point doublings and additions. Of course, in the case that one or both of P or Q is O, or that P = -Q, these superfluous computations are still computed in constant-time such that the correct result is masked out in a cache-attack resistant manner.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Lemma 3</head><label>3</label><figDesc>Let p ≡ 3 (mod 4), d 0 ∈ F p and let E d 0 : -x 2 + y 2 = 1 + d 0 x 2 y 2 be a twisted Edwards curve such that #E d 0 (F p ) = 4r and #E d 0 (F p ) = 4r for primes r and r . Then d 0 and -(d 0 + 1) are both squares in F p .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>induces a partition of E b (F p )\{O} = S odd ∪ S even into two equally sized sets, where S odd = {k P | k ∈ [1, r ) odd} and S even = {k P | k ∈ [1, r ) even}. Let T = {P, 3P, . . . , (2 w-1 -1)P} ⊂ S odd and T -1 = {(r -1)P, (r -3)P, . . . , (r -(2 w-1 -1))P} ⊂ S even . The set T -1 contains the inverses of the points in the set T .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 .</head><label>2</label><figDesc>First validate that k ∈ 4Z, and then that the integer k/4 ∈ [αr + 1, (α + 1)r -1]. Otherwise, reject. Evaluation Process the scalar by inputting k and (x 1 : 1) into the standard (X : Z )-only Montgomery ladder routine [47, §10], with constant (A + 2)/4 in the addition formula. Since k = 4(αr + k), this can be done by inputting the fixed-length scalar k/4 = αr +k and (x 1 : 1) into the Montgomery ladder to give (X 1 : Z 1 ), before finishing with two repeated, standalone Montgomery doublings of (X 1 : Z 1 ) to give ( X : Ẑ ) = 4(X 1 : Z 1 ) 3. Normalize: If Ẑ = 0, return O, otherwise return x1 = X / Ẑ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>-Analysis of a new set of deterministically selected primeorder Weierstrass curves (see Table1) which are defined over pseudo-Mersenne and Montgomery-friendly primes whose bitlengths match those of the NIST primes.</figDesc><table><row><cell>See</cell></row><row><cell>Sects. 2 and 3.</cell></row><row><cell>-Analysis of a new set of deterministically selected</cell></row><row><cell>composite-order twisted Edwards curves (see Table 2</cell></row><row><cell>and Sect. 3). In contrast to existing curve proposals,</cell></row><row><cell>the selected curves present (simultaneously) minimal</cell></row><row><cell>parameter d in the twisted Edwards form and minimal</cell></row><row><cell>parameter A in isogenous Montgomery form (minimal</cell></row><row><cell>in absolute value). See Sect. 3.3.</cell></row><row><cell>-A new, (pseudo-)complete addition algorithm for general</cell></row><row><cell>curves in short Weierstrass form. This algorithm works</cell></row><row><cell>for all pairs of inputs and its execution incurs only a</cell></row><row><cell>small overhead compared to the dedicated addition law.</cell></row><row><cell>See Sect. C.1.</cell></row></table><note><p><p>-We demonstrate how to use the scalar multiplication algorithms and prove that they become exception-free and facilitate constant-time implementations when used this way. This allows one to use the more efficient dedicated formulas whenever possible, resulting in an efficient and secure solution for elliptic curve scalar multiplication. See Sect. 4.</p>-A comprehensive software implementation providing timings for various scenarios; this includes performance estimates for the above curves when used in the context of the TLS protocol. See Sects. 5 and 6.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>Summary of our chosen Weierstrass curves of the form E b /F p : y 2 = x 3 -3x + b defined over F p with quadratic twist E b /F p : y 2 = x 3 -3xb and target security level λThe group orders r = #E b (F p ) and r = #E b (F p ) are both prime, and r &lt; p for all curves. The value under ρ complexity is an estimate for the actual security of the ECDLP against Pollard's ρ method, it is log</figDesc><table><row><cell>Target security λ</cell><cell>Curve name</cell><cell>p</cell><cell>b</cell><cell>ρ complexity</cell></row><row><cell>128</cell><cell>w-256-mont</cell><cell>2 240 (2 16 -88) -1</cell><cell>85,610</cell><cell>127.8</cell></row><row><cell></cell><cell>w-254-mont</cell><cell>2 240 (2 14 -127) -1</cell><cell>-12,146</cell><cell>126.8</cell></row><row><cell></cell><cell>w-256-mers</cell><cell>2 256 -189</cell><cell>152,961</cell><cell>127.8</cell></row><row><cell></cell><cell>w-255-mers</cell><cell>2 255 -765</cell><cell>-20,925</cell><cell>127.3</cell></row><row><cell>192</cell><cell>w-384-mont</cell><cell>2 376 (2 8 -79) -1</cell><cell>27,798</cell><cell>191.5</cell></row><row><cell></cell><cell>w-382-mont</cell><cell>2 368 (2 14 -5) -1</cell><cell>-133,746</cell><cell>190.8</cell></row><row><cell></cell><cell>w-384-mers</cell><cell>2 384 -317</cell><cell>-34,568</cell><cell>191.8</cell></row><row><cell></cell><cell>w-383-mers</cell><cell>2 383 -421</cell><cell>97,724</cell><cell>191.3</cell></row><row><cell>256</cell><cell>w-512-mont</cell><cell>2 496 (2 16 -491) -1</cell><cell>99,821</cell><cell>255.8</cell></row><row><cell></cell><cell>w-510-mont</cell><cell>2 496 (2 14 -290) -1</cell><cell>39,053</cell><cell>254.8</cell></row><row><cell></cell><cell>w-512-mers</cell><cell>2 512 -569</cell><cell>121,243</cell><cell>255.8</cell></row><row><cell></cell><cell>w-511-mers</cell><cell>2 511 -481</cell><cell>555,482</cell><cell>255.3</cell></row></table><note><p>2 ( √ π/4 • √ r ) rounded to one decimal</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>Summary of our chosen twisted Edwards curves of the form E</figDesc><table><row><cell>Target security</cell><cell>Curve name</cell><cell>p</cell><cell>A</cell><cell>d 0</cell><cell>ρ complexity</cell></row><row><cell>128</cell><cell>ed-256-mont</cell><cell>2 240 (2 16 -88) -1</cell><cell>-54,314</cell><cell>13578</cell><cell>126.8</cell></row><row><cell></cell><cell>ed-254-mont</cell><cell>2 240 (2 14 -127) -1</cell><cell>-55,790</cell><cell>13,947</cell><cell>125.8</cell></row><row><cell></cell><cell>ed-256-mers</cell><cell>2 256 -189</cell><cell>-61,370</cell><cell>15,342</cell><cell>126.8</cell></row><row><cell></cell><cell>ed-255-mers</cell><cell>2 255 -765</cell><cell>-240,222</cell><cell>60,055</cell><cell>126.3</cell></row><row><cell>192</cell><cell>ed-384-mont</cell><cell>2 376 (2 8 -79) -1</cell><cell>-113,758</cell><cell>28439</cell><cell>190.5</cell></row><row><cell></cell><cell>ed-382-mont</cell><cell>2 368 (2 14 -5) -1</cell><cell>-2,870,790</cell><cell>717,698</cell><cell>189.8</cell></row><row><cell></cell><cell>ed-384-mers</cell><cell>2 384 -317</cell><cell>-1,332,778</cell><cell>333,194</cell><cell>190.8</cell></row><row><cell></cell><cell>ed-383-mers</cell><cell>2 383 -421</cell><cell>-2,095,962</cell><cell>523,990</cell><cell>190.3</cell></row><row><cell>256</cell><cell>ed-512-mont</cell><cell>2 496 (2 16 -491) -1</cell><cell>-305,778</cell><cell>76,444</cell><cell>254.8</cell></row><row><cell></cell><cell>ed-510-mont</cell><cell>2 496 (2 14 -290) -1</cell><cell>-2,320,506</cell><cell>580,126</cell><cell>253.8</cell></row><row><cell></cell><cell>ed-512-mers</cell><cell>2 512 -569</cell><cell>-2,550,434</cell><cell>637,608</cell><cell>254.8</cell></row><row><cell></cell><cell>ed-511-mers</cell><cell>2 511 -481</cell><cell>-4,390,390</cell><cell>1,097,597</cell><cell>254.3</cell></row></table><note><p><p><p>d /F p : -x 2 + y 2 = 1 + dx 2 y 2 defined over F p , where d = -(A -2)/(A + 2), and the target security level is λ</p>A model for the quadratic twist is E d /F p : -x 2 + y 2 = 1 + (1/d)x 2 y 2 . The curve E d is birationally equivalent to the Montgomery curve E A /F p : y 2 = x 3 + Ax 2 + x with quadratic twist E -A /F p : y 2 = x 3 -Ax 2 + x.</p>The group orders are #E d (F p ) = 4r and #E d (F p ) = 4r , where r and r are both prime, and 4r &lt; p for all curves. The value d 0 = -(A + 2)/4 = -1/(d + 1) defines a curve with the same group order as that given by d, i.e., #E d0 (F p ) = 4r and #E d0 (F p ) = 4r = #E -(d0+1) . The ρ complexity is an estimate for the actual security of the ECDLP against Pollard's ρ method, it is log 2 ( √ π/4 • √ r ) rounded to one decimal</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>1 .</head><label>1</label><figDesc>Validation Validate that k ∈ [4 • 1, 4 • 2, . . . , 4(r -1)].</figDesc><table><row><cell>Validate that P = (x 1 , y 1 ) ∈ E d (F p )\{O} by checking</cell></row><row><cell>that -x 2 1 + y 2 1 = 1 + dx 2 1 y 2 1 and that P = (0, 1) = O</cell></row><row><cell>(see Algorithm 3). Otherwise, return false.</cell></row><row><cell>2. Clear torsion Compute Q ← [4]P using two consecu-</cell></row><row><cell>tive doublings (as in Algorithm 3).</cell></row><row><cell>3. Revalidation Validate that (the projective point)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3</head><label>3</label><figDesc>Experimental results for variable-base, fixed-base and double-scalar multiplication</figDesc><table><row><cell>Security level</cell><cell>Curve name</cell><cell>Variable-base</cell><cell>Fixed-base</cell><cell>Double scalar</cell></row><row><cell>128</cell><cell>w-256-mont</cell><cell>280,000</cell><cell>110,000</cell><cell>287,000</cell></row><row><cell></cell><cell>w-256-mers</cell><cell>278,000</cell><cell>113,000</cell><cell>288,000</cell></row><row><cell></cell><cell>ed-256-mont</cell><cell>233,000</cell><cell>87,000</cell><cell>237,000</cell></row><row><cell></cell><cell>ed-254-mont</cell><cell>194,000</cell><cell>73,000</cell><cell>198,000</cell></row><row><cell></cell><cell>ed-256-mers</cell><cell>228,000</cell><cell>89,000</cell><cell>236,000</cell></row><row><cell></cell><cell>ed-255-mers</cell><cell>223,000</cell><cell>88,000</cell><cell>228,000</cell></row><row><cell></cell><cell>m-254-mont</cell><cell>196,000</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell></cell><cell>m-255-mers</cell><cell>219,000</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>192</cell><cell>w-384-mont</cell><cell>795,000</cell><cell>279,000</cell><cell>812,000</cell></row><row><cell></cell><cell>w-384-mers</cell><cell>744,000</cell><cell>271,000</cell><cell>761,000</cell></row><row><cell></cell><cell>ed-384-mont</cell><cell>657,000</cell><cell>228,000</cell><cell>672,000</cell></row><row><cell></cell><cell>ed-382-mont</cell><cell>590,000</cell><cell>211,000</cell><cell>605,000</cell></row><row><cell></cell><cell>ed-384-mers</cell><cell>610,000</cell><cell>220,000</cell><cell>624,000</cell></row><row><cell></cell><cell>ed-383-mers</cell><cell>596,000</cell><cell>213,000</cell><cell>607,000</cell></row><row><cell></cell><cell>m-382-mont</cell><cell>632,000</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell></cell><cell>m-383-mers</cell><cell>580,000</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>256</cell><cell>w-512-mont</cell><cell>1,762,000</cell><cell>573,000</cell><cell>1,821,00</cell></row><row><cell></cell><cell>w-512-mers</cell><cell>1,538,000</cell><cell>513,000</cell><cell>1,592,000</cell></row><row><cell></cell><cell>ed-512-mont</cell><cell>1,461,000</cell><cell>467,000</cell><cell>1,507,000</cell></row><row><cell></cell><cell>ed-510-mont</cell><cell>1,335,000</cell><cell>432,000</cell><cell>1,369,000</cell></row><row><cell></cell><cell>ed-512-mers</cell><cell>1,282,000</cell><cell>420,000</cell><cell>1,320,000</cell></row><row><cell></cell><cell>ed-511-mers</cell><cell>1,240,000</cell><cell>411,000</cell><cell>1,274,000</cell></row><row><cell></cell><cell>m-510-mont</cell><cell>1,437,000</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell></cell><cell>m-511-mers</cell><cell>1,299,000</cell><cell>N/A</cell><cell>N/A</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4</head><label>4</label><figDesc>Cost estimates for the TLS handshake using the ECDHE-ECDSA cipher suite for different security levels where we consider the elliptic curve scalar multiplications</figDesc><table><row><cell>Security level</cell><cell>Curve names</cell><cell>T</cell><cell cols="2">Estimated cost (in cycles)</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>ECDHE</cell><cell>ECDSA sign</cell><cell>ECDSA ver</cell><cell>Total cost</cell></row><row><cell>128</cell><cell>w-256-mont</cell><cell>U</cell><cell>390,000</cell><cell>110,000</cell><cell>287,000</cell><cell>787,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell>412,000</cell><cell></cell><cell></cell><cell>809,000</cell></row><row><cell></cell><cell>ed-254-mont</cell><cell>U</cell><cell>267,000</cell><cell>73,000</cell><cell>198,000</cell><cell>538,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell>283,000</cell><cell></cell><cell></cell><cell>554,000</cell></row><row><cell></cell><cell>Hybrid ed-254-mont + m-254-mont</cell><cell>U</cell><cell>269,000</cell><cell>73,000</cell><cell>198,000</cell><cell>540,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>NIST P-256 [31]</cell><cell>U</cell><cell>490,000</cell><cell>90,000</cell><cell>530,000</cell><cell>1,110,000</cell></row><row><cell></cell><cell>Ed25519 signature scheme [9]</cell><cell>C</cell><cell>N/A</cell><cell>69,000</cell><cell>225,000</cell><cell>N/A</cell></row><row><cell>192</cell><cell>w-384-mers</cell><cell>U</cell><cell>1,015,000</cell><cell>271,000</cell><cell>761,000</cell><cell>2,047,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell>1,072,000</cell><cell></cell><cell></cell><cell>2,104,000</cell></row><row><cell></cell><cell>ed-382-mont</cell><cell>U</cell><cell>801,000</cell><cell>211,000</cell><cell>605,000</cell><cell>1,617,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell>854,000</cell><cell></cell><cell></cell><cell>1,670,000</cell></row><row><cell></cell><cell>Hybrid ed-382-mers + m-382-mers</cell><cell>U</cell><cell>793,000</cell><cell>213,000</cell><cell>607,000</cell><cell>1,613,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>256</cell><cell>w-512-mers</cell><cell>U</cell><cell>2,051,000</cell><cell>513,000</cell><cell>1,592,000</cell><cell>4,156,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell>2,159,000</cell><cell></cell><cell></cell><cell>4,264,000</cell></row><row><cell></cell><cell>ed-511-mers</cell><cell>U</cell><cell>1,651,000</cell><cell>411,000</cell><cell>1,274,000</cell><cell>3,336,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell>1,753,000</cell><cell></cell><cell></cell><cell>3,438,000</cell></row><row><cell></cell><cell>Hybrid ed-511-mers + m-511-mers</cell><cell>U</cell><cell>1,710,000</cell><cell>411,000</cell><cell>1,274,000</cell><cell>3,395,000</cell></row><row><cell></cell><cell></cell><cell>C</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5</head><label>5</label><figDesc>An overview of the number of modular operations required to implement the group law for a = -3 Weierstrass, a = -1 twisted Edwards and Montgomery curves using different coordinate systems</figDesc><table><row><cell></cell><cell>Refs.</cell><cell>#mul</cell><cell>#sqr</cell><cell>#mulc</cell><cell>#add</cell><cell>#sub</cell><cell>#div2</cell><cell>#lut</cell><cell>See</cell></row><row><cell>Weierstrass double</cell><cell>[41]</cell><cell>4</cell><cell>4</cell><cell>0</cell><cell>2</cell><cell>5</cell><cell>1</cell><cell>0</cell><cell>Algorithm 10</cell></row><row><cell>Weierstrass add:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Jac + Chud → Jac</cell><cell>[23]</cell><cell>11</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>7</cell><cell>0</cell><cell>0</cell><cell>Algorithm 12</cell></row><row><cell>Jac + aff. → Jac</cell><cell>[34]</cell><cell>8</cell><cell>3</cell><cell>0</cell><cell>1</cell><cell>6</cell><cell>0</cell><cell>0</cell><cell>Algorithm 13</cell></row><row><cell>Weierstrass dbl-add</cell><cell>[42]</cell><cell>16</cell><cell>5</cell><cell>0</cell><cell>2</cell><cell>11</cell><cell>0</cell><cell>0</cell><cell>Algorithm 11</cell></row><row><cell>(Complete) Jac + aff → Jac</cell><cell>This work</cell><cell>8</cell><cell>3</cell><cell>0</cell><cell>2</cell><cell>8</cell><cell>1</cell><cell>1</cell><cell>Algorithm 18</cell></row><row><cell>(Complete) Jac + Jac → Jac</cell><cell>This work</cell><cell>12</cell><cell>4</cell><cell>0</cell><cell>2</cell><cell>8</cell><cell>1</cell><cell>1</cell><cell>Algorithm 19</cell></row><row><cell>Edwards doubling</cell><cell>[7]</cell><cell>4</cell><cell>3</cell><cell>0</cell><cell>3</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell>Algorithm 14</cell></row><row><cell>Edwards addition proj.</cell><cell>[35]</cell><cell>8</cell><cell>0</cell><cell>0</cell><cell>3</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>Algorithm 15</cell></row><row><cell>Edwards addition aff.</cell><cell>[35]</cell><cell>7</cell><cell>0</cell><cell>0</cell><cell>4</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>Algorithm 15</cell></row><row><cell>(Unified) Edwards addition proj.</cell><cell>[35]</cell><cell>9</cell><cell>0</cell><cell>0</cell><cell>3</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>Algorithm 17</cell></row><row><cell>(Unified) Edwards addition aff.</cell><cell>[35]</cell><cell>8</cell><cell>0</cell><cell>0</cell><cell>4</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>Algorithm 17</cell></row><row><cell>Montgomery ladder step double-and-add</cell><cell>[47]</cell><cell>5</cell><cell>4</cell><cell>1</cell><cell>4</cell><cell>4</cell><cell>0</cell><cell>0</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Cryptographic libraries with support for generic-prime field arithmetic (e.g., using Montgomery arithmetic) are fully compatible with the proposed curves.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>We note that this cost increases by a single point addition when wv | t, since an extra precomputed point is needed in this case.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Again, except for when w = 2, where this comes for free.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>Again, we note that when wv | t, an extra precomputed point is needed.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>A version of the library (known as MSR ECCLib<ref type="bibr" target="#b44">[44]</ref>) which supports a subset of the curves presented in this work is publicly available at http://research.microsoft.com/en-us/downloads/ 149804d4-b5f5-496f-9a17-a013b242c02d/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_5"><p>This cost assumes the use of the simplest, most secure implementation approach, i.e., each ephemeral key is used once and then discarded.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_6"><p>We did not optimize (1) aggressively; we simply grouped common subexpressions and employed obvious operation scheduling-it is likely that there are faster routes.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments We thank Niels Ferguson, Thorsten Kleinjung, Dan Shumow and Greg Zaverucha for their valuable feedback, comments, and help. We also would like to thank the anonymous reviewers of JCEN which helped to improve the quality of the paper.</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Table <ref type="bibr" target="#b6">6</ref> The traces of Frobenius t for the curves in Tables <ref type="table">1</ref> and<ref type="table">2</ref> Curve E b Trace w-256-mont 0x3AE8AEC191AF8B462EF3A1E5867A815 w-254-mont 0x147E7415F25C8A3F905BE63B507207C1 w-256-mers 0x1BC37D8A15D9A39FDF54DFD6B8AE571F w-255-mers 0x79B5C7D7C52D4C2054705367C3A6B219 w-384-mont 0x456480EB358AEDAC85B1232C7583BE25D641B76B4D671145 w-382-mont 0x5914E300B421DEB28C4CDE002717D32E9F54797FC144CFE3 w-384-mers 0x29E150E114A2977E412562C2B3C81D859FB27E0984F19D0B w-383-mers 0x563507EB575EE952604F4BFCABE8550CE6D6803F4485BABD w-512-mont 0x9C757286D118AFD67F9B550F47B6719E20C2C66AF9B128C46C69D70E81670237 w-510-mont 0x46EB93321EAF10CC8B854D62E19A8C272DD216A1CDDCFC0C5FF4DFF6790565D3 w-512-mers 0xA4C35B046B187CE4B03DA712682F4239C4A974C99F832DBC31EAC0C6FBCCA86B w-511-mers 0x724105C0A12627C65D2B01900AE91780572C19A95F06605E0FEFA08C4C462C81 Curve E d Trace ed-256-mont 0x13AAD11411E6330DA649B44849C4E1154 ed-254-mont 0x51AB3E4DD0A7413C5430B004EE459CE4 ed-256-mers 0x106556A94BD650E6C691EC643BB752C90 ed-255-mers 0x8C3961E84965F3454ED8B84BEF244F30 ed-384-mont 0x2A4BE076C762D8C9825225944DFC2407E406C7167336DD94 ed-382-mont 0xB394157AB7C8FA209CFA7E8EDF87E5F659DFF2586830167C ed-384-mers 0x4CA0BB84A976997697B17EE9C7182C6EB8A4A3823EF64630 ed-383-mers 0x3BBDA3EC630981110CAA5E0D854D777E40050C4F9160DDE8 ed-512-mont 0xCCC0A98C8F32E3CBBF3E7EBB024842CB2099437935363F81733ADE04D1C927EC ed-510-mont 0xA0C4BB860F4395023A482F564F6E7DFD280CF7DBA06996F4DE9F78C8324AB93C ed-512-mers 0x1606BDFD840951119676E1EC2EDAAE83C8C56803CD1FFC1DAC61CB8D3D283F7A4 ed-511-mers 0x560F2F9F46F87459155B3C6E1CEDD9236AF63E504E83379AC20F45C1CBAF41DC Compute group orders as #E(F p ) = p + 1t and #E (F p ) = p + 1 + t for E ∈ {E b , E d }</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A: Algorithms for scalar multiplication</head><p>Algorithms for variable-base scalar multiplication Algorithm 1 computes scalar multiplication for the variable-base scenario using the fixed-window method from <ref type="bibr" target="#b49">[49]</ref>. We refer to Sects. 4.1 and 4.2 for details on its usage with Weierstrass and twisted Edwards curves, respectively. The computation of this operation mainly consists of four different stages: input and point validation, precomputation, recoding and evaluation. Input and point validation are computed at the very beginning of the execution using Algorithm 2 for Weierstrass curves and Algorithm 3 for twisted Edwards curves. In particular, Algorithm 3 performs two doublings over the input point in twisted Edwards to ensure that subsequent computations are performed in the large prime order subgroup (avoiding small subgroup attacks). We remark that it is the protocol implementer's responsibility to ensure that timing differences during the detection of errors do not leak sensitive information to an attacker. In the precomputation stage, the implementer should first select a window width 2 ≤ w &lt; 10 according to efficiency and/or memory considerations. For example, selecting w = 6 for 256-, 384-and 512-bit scalar multiplication was found to achieve optimal performance in our implementations of Weierstrass curves. Precomputation is then computed by successively executing P + 2P + 2P + • • • + 2P with 2 w-2 -1 point additions and storing the intermediate results. Explicit schemes are given in Algorithms 4 and 5 for a = -3 Weierstrass and a = -1 twisted Edwards curves, respectively. In the recoding stage, we use a variant of the regular recoding by <ref type="bibr" target="#b36">[36]</ref> that ensures fixed length (see <ref type="bibr">Algorithm 6)</ref>. Since Algorithm 6 only recodes odd integers, we include a conversion step at Step 6 to deal with even values. The corresponding correction is performed at Step 20. These computations should be executed in constant time to protect against timing attacks. For example, a constant time execution of Step 6 could be implemented as follows (assuming a two's complement representation in which -1 ≡ 0xFF. . .FF, and bitlength(odd) = bitlength(k)):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B: Algorithms for point operations</head><p>Refer to Algorithms 10-17.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C: Implementing the group law</head><p>Weierstrass curves It is standard to represent points on E b : y 2 = x 3 -3x +b using Jacobian coordinates <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b48">48,</ref><ref type="bibr" target="#b56">57]</ref>: for non-zero Z ∈ F p , the tuple (X : Y : Z ) is used to represent the affine point (X/Z 2 , Y/Z 3 ) on E b . There are many different variants of the Jacobian formulas originally proposed in <ref type="bibr" target="#b23">[23]</ref>. In our implementation we use the doubling formula from <ref type="bibr" target="#b41">[41]</ref> (see <ref type="bibr">Algorithm 10)</ref>. Point additions are usually performed between a running point and a point from a (precomputed) 'look-up' table. Typically, it is advantageous to leave the precomputed points in projective form for variable-base computations, and to convert them (offline) to their affine form for fixed-base computations. When elements in the table are stored in affine coordinates, point addition is performed using mixed Jacobian/affine coordinates using, for example, the formula presented in <ref type="bibr" target="#b34">[34]</ref> (see <ref type="bibr">Algorithm 13)</ref>.</p><p>There are cases in which exceptions in the formulas might arise. This is the case, for example, for fixed-base scalar multiplication. To achieve constant-time execution, we devised a complete formula based on masking that works for point addition, doubling, inverses and the point at infinity (see <ref type="bibr">Algorithm 18)</ref>. If points from the precomputed table are stored in projective coordinates, we use Chudnovsky coordinates to represent the affine point (X/Z 2 , Y/Z 3 ) ∈ E b by the projective tuple (X : Y : Z : Z 2 : Z 3 ). The corresponding addition formula is given as Algorithm 12. More efficiently, whenever a doubling is followed by an addition (as in the main loop of the variable-base scalar multiplication; see Algorithm 1) one can use a merged doubling-addition formula <ref type="bibr" target="#b42">[42]</ref> that is based on the special addition with the same Z -coordinate from <ref type="bibr" target="#b43">[43]</ref> (see <ref type="bibr">Algorithm 11)</ref>. The different costs of the point formulas used in our implementation can be found in Table <ref type="table">5</ref>. Finally, the exact routine to perform the precomputation for the variable-base scenario is outlined in Algorithm 4. The scheme uses a straightforward variant of the general formulas, including the special addition from <ref type="bibr" target="#b43">[43]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C.1: Complete addition laws</head><p>An elliptic curve addition law is said to be complete if it correctly computes the group operation regardless of the two input points. Although employing such an addition law on its own can simplify the task of the implementer, it usually incurs a performance penalty. This is because the fastest formulas available for a particular curve model, which work fine for most input pairs, tend to fail on certain inputs. However, it is often the case that implementers can safely exploit the speed of such incomplete formulas by correctly dealing with all possible exceptions, or by designing the scalar multiplication routine such that exceptions can never arise. All of the twisted Edwards curves presented in this paper can make use of the complete addition law in <ref type="bibr" target="#b11">[11]</ref> by working on the birationally equivalent Edwards model E -1/d :</p><p>However, the complete formulas are slower compared to the fastest formulas on the twisted Edwards curve <ref type="bibr" target="#b35">[35]</ref>. But even when working on an Edwards curve with complete formulas, an implementation of the scalar multiplication could still be sped up by mapping to a different curve, while remaining with the complete formulas for all other operations. One could for example follow the approach suggested in <ref type="bibr" target="#b33">[33]</ref>, and use an isogeny to the twisted Edwards curve E -1/d-1 :</p><p>The situation for the prime order Weierstrass curves in this paper is more complicated. As pointed out by Bosma and Lenstra <ref type="bibr" target="#b18">[18]</ref>, the best that we can do for general elliptic curves is as follows: on input of two points P 1 and P 2 , we must compute two candidate sums, P 3 and P 3 , for which we can only be guaranteed that at least one of them is a correct projective representation for P 1 + P 2 . In the case that precisely one of P 3 and P 3 correctly corresponds to P 1 + P 2 , the other candidate has all of its coordinates as zero; although this makes it straightforward to write a constant-time routine complete additions, it also means that computing complete Table <ref type="table">7</ref> The cost of converting points when using the curves from Tables <ref type="table">1</ref> and<ref type="table">2</ref> Conversion Formula Cost Edwards to Montgomery (x, y) to (u)</p><p>Weierstrass to Weierstrass (x) to (x, y) y = (x 3 -3x + b) p-2 1 exp, 1 mul, 1 squ This is for point decompressing and converting between twisted Edwards and Montgomery (and vice versa). The cost is expressed in the number of exponentiations (exp), multiplications (mul), multiplication by constants (mulc) and squarings (squ). Let E A /F p : v 2 = u 3 + Au 2 + u and E d /F p : -x 2 + y 2 = 1 + dx 2 y 2 with B = -(A + 2) a square in F p and d = -(A -2)/(A + 2). Let (X : Y : Z ) be the projective coordinates for E. We follow the approach described in <ref type="bibr" target="#b9">[9]</ref> to decompress twisted Edwards points</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D: Traces of Frobenius</head><p>Refer to Table <ref type="table">6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix E: Costs of point conversion</head><p>Refer to Table <ref type="table">7</ref>.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Modular reduction without pre-computation for special moduli</title>
		<author>
			<persName><forename type="first">T</forename><surname>Acar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shumow</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On isogeny classes of edwards curves over finite fields</title>
		<author>
			<persName><forename type="first">O</forename><surname>Ahmadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Granger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Number Theory</title>
		<imprint>
			<biblScope unit="volume">132</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1337" to="1358" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A note on high-security general-purpose elliptic curves</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Aranha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S L M</forename><surname>Barreto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C C F</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Ricardini</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">647</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Can we avoid tests for zero in fast elliptic-curve arithmetic?</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<ptr target="http://cr.yp.to/papers.html#curvezero" />
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Curve25519: New Diffie-Hellman speed records</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography-PKC 2006</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3958</biblScope>
			<biblScope unit="page" from="207" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Slides of a talk given at Counting Points: Theory, Algorithms and Practice</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<ptr target="http://cr.yp.to/talks/2010.04.19/slides.pdf" />
		<imprint>
			<date type="published" when="2010-04-19">2010. April 19</date>
		</imprint>
		<respStmt>
			<orgName>University of Montreal</orgName>
		</respStmt>
	</monogr>
	<note>Counting points as a video game</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Twisted Edwards curves</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Birkner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AFRICACRYPT</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5023</biblScope>
			<biblScope unit="page" from="389" to="405" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">ECM using Edwards curves</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Birkner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">282</biblScope>
			<biblScope unit="page" from="1139" to="1179" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">High-speed high-security signatures</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Duif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schwabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-Y</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptogr. Eng</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="77" to="89" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Elligator: elliptic-curve points indistinguishable from uniform random strings</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krasnova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM conference on computer and communications security</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Faster addition and doubling on elliptic curves</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4833</biblScope>
			<biblScope unit="page" from="29" to="50" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">SafeCurves: choosing safe curves for elliptic-curve cryptography</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<ptr target="http://safecurves.cr.yp.to" />
		<imprint>
			<date type="published" when="2013-10-16">16 Oct 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<ptr target="http://bench.cr.yp.to" />
		<title level="m">eBACS: ECRYPT benchmarking of cryptographic systems</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2014-02-03">3 Feb 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Elliptic curve cryptography (ECC) cipher suites for transport layer security (TLS)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blake-Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bolyard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hawk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">4492</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast cryptography in genus 2</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Costello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hisil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lauter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EUROCRYPT</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7881</biblScope>
			<biblScope unit="page" from="194" to="210" />
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Elliptic curve cryptography in practice</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Halderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Wustrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography and Data Security</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Christin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8437</biblScope>
			<biblScope unit="page" from="157" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Magma algebra system. I. The user language</title>
		<author>
			<persName><forename type="first">W</forename><surname>Bosma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Playoust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational algebra and number theory</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1997. 1993</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="235" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Complete systems of two addition laws for elliptic curves</title>
		<author>
			<persName><forename type="first">W</forename><surname>Bosma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Number Theory</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="229" to="240" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cache-timing template attacks</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">B</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hakala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="667" to="684" />
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Remote timing attacks are practical</title>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX security symposium</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Mangard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</editor>
		<meeting>the 12th USENIX security symposium</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">6225</biblScope>
			<biblScope unit="page" from="80" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Standards for efficient cryptography 2: recommended elliptic curve domain parameters</title>
		<author>
			<persName><forename type="first">Certicom</forename><surname>Research</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Standard SEC2, Certicom</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Low-cost solutions for preventing simple side-channel analysis: side-channel atomicity</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chevallier-Mames</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ciet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="760" to="768" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Sequences of numbers generated by addition in formal groups and new primality and factorization tests</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chudnovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chudnovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="385" to="434" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><surname>Ecc Brainpool</surname></persName>
		</author>
		<ptr target="http://www.ecc-brainpool.org/download/Domain-parameters.pdf" />
		<title level="m">ECC Brainpool Standard Curves and Curve Generation</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A normal form for elliptic curves</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Edwards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. Am. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="393" to="422" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Improving the complexity of index calculus algorithms in elliptic curves over binary fields</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Faugère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Perret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Petit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Renault</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EUROCRYPT</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="27" to="44" />
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient and secure algorithms for GLV-based scalar multiplication and their implementation on GLV-GLS curves (extended version)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Faz-Hernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Longa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sánchez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptogr. Eng</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="52" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient comb elliptic curve multiplication methods resistant to power analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2005/222" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">222</biblScope>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Injective encodings to elliptic curves</title>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tibouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACISP</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Simpson</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7959</biblScope>
			<biblScope unit="page" from="203" to="218" />
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Faster point multiplication on elliptic curves with efficient endomorphisms</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Gallant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lambert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="190" to="200" />
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Fast prime field elliptic curve cryptography with 256 bit primes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gueron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Krasnov</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">816</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Fast and compact elliptic-curve cryptography. Cryptology ePrint Archive</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Report</title>
		<imprint>
			<date type="published" when="2012">2012/309 (2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Twisting Edwards curves with isogenies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Guide to Elliptic Curve Cryptography</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hankerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Twisted Edwards curves revisited</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hisil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dawson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asiacrypt 2008</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="326" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Exponent recoding and regular exponentiation algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tunstall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Africacrypt 2003</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</editor>
		<meeting>Africacrypt 2003<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5580</biblScope>
			<biblScope unit="page" from="334" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Speeding up bipartite modular multiplication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Knežević</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Arithmetic of Finite Fields-WAIFI 2010</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Hasan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Helleseth</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin/Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6087</biblScope>
			<biblScope unit="page" from="166" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and other systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto 1996</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer, Heidelberg</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="104" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Generating RSA moduli with a predetermined portion</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asiacrypt&apos;98</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Ohta</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Pei</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1514</biblScope>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">More flexible exponentiation with precomputation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Desmedt</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">839</biblScope>
			<biblScope unit="page" from="95" to="107" />
			<date type="published" when="1994">1994</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Efficient techniques for high-speed elliptic curve cryptography</title>
		<author>
			<persName><forename type="first">P</forename><surname>Longa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gebotys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHES 2010</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Mangard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</editor>
		<meeting>CHES 2010<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6225</biblScope>
			<biblScope unit="page" from="80" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">New composite operations and precomputation scheme for elliptic curve cryptosystems over prime fields</title>
		<author>
			<persName><forename type="first">P</forename><surname>Longa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PKC 2008</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting>PKC 2008<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4939</biblScope>
			<biblScope unit="page" from="229" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">New point addition formulae for ECC applications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Meloni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Arithmetic of Finite Fields (WAIFI)</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Sunar</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4547</biblScope>
			<biblScope unit="page" from="189" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<ptr target="http://research.microsoft.com/en-us/projects/nums" />
		<title level="m">MSR Elliptic Curve Cryptography Library</title>
		<imprint>
			<publisher>Microsoft Research</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
		<respStmt>
			<orgName>MSR ECCLib</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Algorithms for multi-exponentiation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Selected Areas in Cryptography</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Youssef</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2259</biblScope>
			<biblScope unit="page" from="165" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Modular multiplication without trial division</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Montgomery</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">170</biblScope>
			<biblScope unit="page" from="519" to="521" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Speeding the Pollard and elliptic curve methods of factorization</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Montgomery</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">177</biblScope>
			<biblScope unit="page" from="243" to="264" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<ptr target="http://www.nsa.gov/ia/programs/suiteb_cryptography/index.shtml" />
		<title level="m">Fact sheet NSA Suite B Cryptography</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>National Security Agency</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">The width-w NAF method provides small memory and fast elliptic curve scalars multiplications against sidechannel attacks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Okeya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takagi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CT-RSA 2003</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</editor>
		<meeting>CT-RSA 2003<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2612</biblScope>
			<biblScope unit="page" from="328" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Cache attacks and countermeasures: the case of AES</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Osvik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3860</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Counting points on elliptic curves over finite fields</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schoof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal de théorie des nombres de Bordeaux</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="219" to="254" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">On the possibility of a back door in the NIST SP800-90 dual ec prng</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shumow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ferguson</surname></persName>
		</author>
		<ptr target="http://rump2007.cr.yp.to/15-shumow.pdf" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Generalized Mersenne numbers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Solinas</surname></persName>
		</author>
		<idno>CORR 99-39</idno>
	</analytic>
	<monogr>
		<title level="j">Centre for Applied Cryptographic Research</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>University of Waterloo</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Solinas</surname></persName>
		</author>
		<ptr target="http://bits.blogs.nytimes.com/2013/09/10/government-announces-steps-to-restore-confidence-on-encryption-standards" />
		<title level="m">The New York Times: Government announces steps to restore confidence on encryption standards</title>
		<imprint>
			<publisher>Efficient arithmetic on Koblitz curves. Des. Codes Cryptogr</publisher>
			<date type="published" when="2000">2000. 2013</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="195" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Elligator squared: uniform points on elliptic curves of prime order as uniform random strings</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tibouchi</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/043. 2014</date>
		</imprint>
	</monogr>
	<note>Report</note>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<idno>DSS). FIPS-186-4</idno>
		<ptr target="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf" />
		<title level="m">Digital signature standard</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>U.S. Department of Commerce/National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Montgomery exponentiation needs no final subtractions</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Walter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron. Lett</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">21</biblScope>
			<biblScope unit="page" from="1831" to="1832" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
