<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Program sketching</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012-08-02">2 August 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Massachussets Institute of Technology</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Massachussets Institute of Technology</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Program sketching</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-08-02">2 August 2012</date>
						</imprint>
					</monogr>
					<idno type="MD5">C54DDAF5274836EFAA66BFCD6E72D9C8</idno>
					<idno type="DOI">10.1007/s10009-012-0249-7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>SAT/SMT applications</term>
					<term>Constraint-based synthesis</term>
					<term>Sketching</term>
					<term>Synthesis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Sketching is a synthesis methodology that aims to bridge the gap between a programmer's high-level insights about a problem and the computer's ability to manage low-level details. In sketching, the programmer uses a partial program, a sketch, to describe the desired implementation strategy, and leaves the low-level details of the implementation to an automated synthesis procedure. In order to generate an implementation from the programmer provided sketch, the synthesizer uses counterexample-guided inductive synthesis (CEGIS). Inductive synthesis refers to the process of generating candidate implementations from concrete examples of correct or incorrect behavior. CEGIS combines a SATbased inductive synthesizer with an automated validation procedure, a bounded model-checker, that checks whether the candidate implementation produced by inductive synthesis is indeed correct and to produce new counterexamples. The result is a synthesis procedure that is able to handle complex problems from a variety of domains including ciphers, scientific programs, and even concurrent data-structures.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Sketching is a synthesis methodology that is designed to help programmers with small but very complex routines, the kind of routines one finds in low-level system's code or high-performance computational kernels. What distinguishes sketching from some of the other forms of synthesis presented in this issue is that all the information that flows from the programmer to the synthesizer is expressed as code. This has important implications for usability, because it means that programmers do not need to master additional formalisms in order to use the synthesizer, giving it the feel of a programming assistant as opposed to that of a formal verification tool.</p><p>The starting point of sketching is the sketch itself-a partial program where difficult expressions and statements are left unspecified. In their place, the programmer uses generators to describe a space of possible code fragments which the synthesizer can use to complete the missing code. The hypothesis behind sketching is that programmers often have an idea about the general form of a solution; a high-level strategy that will solve the problem at hand. To turn the strategy into a program, however, they have to orchestrate many low-level details; a process that is difficult and error prone. It therefore makes sense to focus the synthesizer on those low-level details, leaving control of the high-level strategy in the hands of the programmer. For many domains, partial programs offer a natural way to achieve this division of labor. The programmer controls the implementation strategy by defining the space of solutions the synthesizer can consider, while the synthesizer is responsible for discovering the low-level details of individual expressions in the program. Partial programs allow programmers to interact with the synthesizer without having to resort to separate formalisms, allowing synthesis to be embedded directly into a standard programming language.</p><p>In addition to providing the sketch, the user needs to define the expected behavior of the program. In keeping with the philosophy of Sketch, the programmer defines this behavior through code, either in the form of a reference implementation, or as a set of parameterized unit tests that the synthesized code must pass. The synthesizer must ensure that the synthesized code passes its unit tests or matches the reference implementation for all possible inputs, although in practice it can only guarantee that the specification will be satisfied for all inputs up to a given bound. Writing unit tests and reference implementations are both regarded as best practices in traditional software development, but with Sketch programmers can leverage this effort to get parts of their code synthesized.</p><p>The basic strategy for resolving sketches is based on search. The goal is to find the contents of all the unspecified code in the sketch such that the resulting program will behave correctly under all inputs. The space of possible code fragments defined by the generators in the program is bounded, as is the space of inputs that the synthesizer considers, so the synthesis problem is decidable. However, a naïve search is bound to fail given the astronomical sizes of both spaces. For example, even simple sketches can have input spaces in the range of 2 32 , and even going up to 2 128 elements. Similarly, the solution spaces for some sketches easily reach beyond 2 300 . These scales can only be tackled by means of symbolic search mechanisms inspired by those originally developed for model checking in the early 1990s <ref type="bibr" target="#b8">[10]</ref>.</p><p>The sketch synthesizer uses counterexample-guided inductive synthesis (cegis). The cegis algorithm relies on an important empirical hypothesis; for most sketches, only a small set of inputs is needed to fully constrain the solution.</p><p>In other words, it is possible to find a small set of inputs covering all the corner cases in the sketch, such that only a valid solution to the sketch can work correctly for all these inputs. cegis uses an efficient SAT-based inductive synthesis procedure to produce candidate solutions from small sets of inputs. The crucial observation behind the cegis algorithms is that the set of corner cases can be discovered automatically by coupling the inductive synthesizer with a validation procedure. Initially, the set of inputs contains only a random input, but once the inductive synthesizer produces its first candidate solution, the solution is checked by the validation procedure. If the candidate is incorrect, the counterexample produced by the validation procedure is fed to the inductive synthesizer, so the next candidate it produces will be guaranteed to work correctly for this corner case. After only a few iterations, the inductive synthesizer will have gathered a representative set of counterexample inputs and will produce a valid candidate which the validation procedure will accept and deliver to the user.</p><p>It is possible to construct sketches that violate the empirical hypothesis, and where the algorithm will have to explore every possible input in the worst case. In practice, however, the counterexample-based approach works remarkably well even for sketches with very large candidate and input spaces, converging to a solution after only a handful of iterationsand therefore a handful of calls to the validation procedure. For example, in one sketch for the AES encryption cipher, shown in Sect. 9, the synthesizer was able to derive the contents of over 1,024 32-bit integer constants after analyzing only 600 candidates. A second important property of cegis is that it separates the synthesis and verification tasks, making it possible to use off-the-shelf validation procedures, including incomplete but highly scalable procedures such as automated test generation <ref type="bibr" target="#b12">[14]</ref>.</p><p>The rest of the paper provides an overview of the sketch language and a detailed description of the algorithms that make it possible, and concludes with a discussion of our experience with the system and some of its limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The sketch language</head><p>Sketching extends a simple procedural language with the ability to leave holes in place of code fragments that are to be derived by the synthesizer. Each hole is marked by a generator which defines the set of code fragments that can be used to fill a hole. Sketch offers a rich set of constructs to define generators, but all of these constructs can be described as syntactic sugar over a simple core language that contains only one kind of generator: an unknown integer constant denoted by the token ??.</p><p>From the point of view of the programmer, the integer generator is a placeholder that the synthesizer must replace with a suitable integer constant. The synthesizer ensures that the resulting code will avoid any assertion failures under any input in the input space under consideration. For example, the following code snippet can be regarded as the "Hello World" of sketching. harness void main(int x){ int y = x * ??; assert y == x + x; } This program illustrates the basic structure of a sketch. It contains three elements you are likely to find in every sketch: (a) a harness procedure, (b) holes marked by generators, and (c) assertions.</p><p>The harness procedure is the entry point of the sketch, and together with the assertion it serves as an operational specification for the desired program. The goal of the synthesizer is to derive an integer constant C such that when ?? is replaced by C, the resulting program will satisfy the assertion for all inputs in the input space of the harness. <ref type="foot" target="#foot_0">1</ref> For the sketch above, the synthesized code will look like this. void main(int x){ int y = x * 2; assert y == x + x; }</p><p>The semantics of the sketch can also be framed in game theoretic terms. The inputs to the test harness correspond to non-deterministic choices available to a demonic adversary who is trying to get the program to fail. The ?? operator corresponds to a non-deterministic choice available to an angelic player who is trying to keep the program from failing. The job of the synthesizer is to find a memoryless strategy that guarantees that the angelic player always wins the game. Our restriction on the strategy is stronger than just being memoryless; the semantics of the sketch require that the value produced by the strategy depend only on the current program location (as opposed to the current state, which is what a memoryless strategy guarantees). This strong requirement means that the synthesizer can just replace the non-deterministic choice with a constant value, resulting in a fully deterministic program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sketching with integer generators</head><p>When combined with other language constructs, integer generators are remarkably expressive; they can even be used to define arbitrary context-free grammars of program fragments. Even by themselves, however, integer generators can be useful in turning a high-level insight into an efficient implementation.</p><p>As a small but realistic example of this, consider the problem of isolating the least significant 0-bit in a word x. For example, for the word 01010011, the desired output is a word containing a 1 in the position of the least significant 0; i.e. 00000100. There is a trick to do this using only three instructions. You may remember it: the trick takes advantage of the fact that adding a 1 to a string of ones preceded by a zero turns all the ones into zeros and turns the next zero into a one (i.e. 000111 + 1 = 001000). You may not remember the details, but with sketching you do not have to; you can let the synthesizer discover them. All you need to remember is the general form of the solution to encode the problem as a sketch. Specifically, you need to remember that the solution involved the addition of a constant to x, a negation, and a bitwise and. The expression ∼(x + ??) &amp; (x + ??) encodes most of the expressions matching this criteria, and when given a suitable specification, the synthesizer can easily find the correct expression.</p><formula xml:id="formula_0">int W = 32; bit[W] least_sig0(bit[W] x){ return ∼(x + ??) &amp; (x + ??); } bit[W] simple_least_sig0(bit[W] x){ bit[W] ret = 0; for (int i = 0; i &lt; W; i++) if (!x[i]) { ret[i] = 1; return ret; } return ret; } harness void main(bit[W] x){ assert least_sig0(x) == simple_least_sig0(x); }</formula><p>In less than a second, the synthesizer is able to discover that the correct expression is ∼(x+0) &amp; (x + 1). If you think this problem was too easy given the initial hint, consider this question: can the same trick be used to find the least significant 1? Without thinking too hard about the problem, one can ask the sketch synthesizer:</p><formula xml:id="formula_1">int W = 32; bit[W] least_sig1(bit[W] x){ // same sketch as before return ∼(x + ??) &amp; (x + ??); } bit[W] simple_least_sig1(bit[W] x){ bit[W] ret = 0; for (int i = 0; i &lt; W; i++) if (x[i]) { ret[i] = 1; return ret; } return ret; } harness void main(bit[W] x){ assert least_sig1(x) == simple_least_sig1(x); }</formula><p>It again takes less than a second for the synthesizer to tell us that yes, the same basic trick applies, but now the expression is ∼(x + 0xFFFFFFFF) &amp; (x+0).</p><p>Notice that both examples used as a specification a simple operational description for the task at hand, what one would normally refer to as a reference implementation. All the harness is doing is running the sketch and the reference implementation side-by-side and comparing the result. Since this is a common idiom, the sketch language provides syntactic sugar for it. Instead of writing a harness, the user simply states that least_sig1 implements the functionality of sim-ple_least_sig1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>bit[W] least_sig1(bit[W] x) implements simple_least_sig1{</head><p>return ∼(x + ??) &amp; (x + ??); } In the above example, it was relatively clear that the tricky details in the implementation involved discovering a few constants. In many cases, however, the details in question do not involve any missing constants. For example, consider the problem of swapping two bit-vectors x and y without using a temporary register. The insight is that the numbers can be swapped by assigning x xor y to x and y repeatedly in a clever way. The challenge is to find the right sequence of assignments. The insight, therefore, involves no integer constants, but the integer generator can still be used to encode it: The sketch above uses the integer generator to encode the choice between assigning x ^y to x or to y. The synthesizer uses the usual convention of using 0 to represent false and 1 to represent true, and in less than a second, it is able to discover that the three holes should evaluate to false, true and false, respectively. After replacing the generators with constants, the synthesizer will perform a small amount of cleanup, eliminating the unnecessary conditionals to produce the code shown below. void swap(ref bit <ref type="bibr">[W]</ref> x, ref bit[W] y){ y = x ^y; x = x ^y; y = x ^y; }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Higher level generators</head><p>The language provides some syntactic sugar that makes sketches like the one above significantly easier to write. Two of the most important constructs are repeat blocks and regular expression generators.</p><p>The construct repeat(N) c allows programmers to define a repeating algorithmic pattern. If N is a constant, the synthesizer will create N copies of the statement c and solve for the unknowns in each copy of c independently. Using this construct, the swap sketch can be expressed concisely as</p><formula xml:id="formula_2">void swap(ref bit[W] x, ref bit[W] y){ repeat(3)</formula><p>if(??){ x = x ^y; }else{ y = x ^y; } }</p><p>The repeat construct also allows the number of copies to be left unspecified by writing repeat(??), and if a minimal number of steps is desired, one can use min-re-peat instead. As was said before, all generators represent finite spaces of possible code fragments, and repeat is no exception; even when using repeat(??), the synthesizer will only consider up to a bounded number of repetitions, where the bound is determined by a command line flag.</p><p>Regular expression generators (Re-generators) are another constructs that allows the choice of expressions to be expressed more concisely without resorting to messy if statements. The Re-generator construct has the form {|e|}, where e is a regular expression literal. The semantics of the construct are that the synthesizer substitutes the syntactic occurrence of the construct with a string in the language L(e) such that the substitution resolves the sketch. Using Re-generators, the example can be written even more concisely as:</p><formula xml:id="formula_3">void swap(ref bit[W] x, ref bit[W] y){ minrepeat {| x | y |} = x ^y; }</formula><p>In designing the language we made a design decision to support only two regular expression operators: choices e 1 | e 2 and optional expressions e?. Kleene closure is excluded for two reasons: first, we never found a situation where we needed to have an expression exhibiting the kind of unbounded repetition that Kleene closures imply. Moreover, since generators can only represent bounded sets of expressions, the Kleene closure would still have to be bounded in an arbitrary way. If the user needs to use Kleene closure, it can always be expressed using the repeat construct, so adding Kleene closure would have increased the number of constructs involving artificial bounds, and it would not have produced any significant programmability benefits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Abstraction in Sketch</head><p>Procedures allow the programmer to hide the details of a computation behind a simple interface, and are one of the most commonly used forms of abstraction in production languages. Sketch supports procedures exactly as one would expect: generators within them are syntactically replaced with code fragments that ensure the correctness of the generated program. int linexp(int x, int y){ return ?? * x + ?? * y + ??; } harness void main(int x, int y){ assert linexp(x,y) &gt;= 2 * x + y; assert linexp(x,y) &lt;= 2 * x + y+2; } For example, for the routines above, there are many different solutions for the holes in lin-exp that will satisfy the first assertion, and there are many that will satisfy the second assertion, but the synthesizer will chose one of the candidates that satisfies them both. int linexp(int x, int y){ return 2 * x + y; } The procedure lin-exp originally had holes, and therefore corresponded to a set of functions. However, the synthesizer completed the holes to give the procedure a single concrete meaning to be used across all calling sites. This gives procedures the same power of abstraction that they would have in the absence of sketching. But, as the following example illustrates, sketching creates the need for a mechanism to abstract sets of functions. In the above sketch, trans-pose is a procedure which abstracts the matrix transpose function for N × N matrices. However, within the transpose procedure, the expression |??|N|*i + |??|N|*j+|??|N|! is repeated twice. This expression is quite big, so one would like to abstract it into its own procedure to avoid the repetition. However, one cannot abstract this expression into a procedure because each use of the expression has to resolve to a different linear expression. Therefore, an abstraction mechanism is needed to represent the entire set of functions encoded by |??|N|*i + |??|N|*j+|??|N|!, rather than a single one like the procedure does.</p><p>The Sketch language allows programmers to abstract sets of functions into custom generators. For each use of the generator, the synthesizer is free to choose a different function. For the above example, the expression |??|N|*i + |??|N|*j+|??|N|! can be abstracted into a generator that represents the set of linear expressions involving i and j with either constants or N  Programmers are encouraged to think of generators as procedures which are inlined into their calling context before the sketch is synthesized, so each call to the generator will be resolved independently from other calls.</p><p>Generators derive much of their expressive power from their ability to recursively define a space of expressions. For example, consider again the least_sig1 example; as presented earlier, the example assumed considerable knowledge about the shape of the solution. If the user lacks that knowledge, he can rely on a very general generator to leverage the synthesizer more heavily as illustrated by the code below.</p><p>generator bit <ref type="bibr">[W]</ref>  The user-defined generator gen recursively defines the space of all expressions involving x, bit-vector constants, and the operators +, &amp;, ^and the bitwise negation ∼. The parameter bnd controls the depth of recursion, limiting the synthesizer to expressions of a certain size. Without this bound, a solver flag limiting the depth of recursion of generators would determine the maximum size of expressions that the synthesizer is allowed to consider.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Putting it all together</head><p>To illustrate the use of sketching, consider the problem of reversing a linked list. It is relatively easy to write a recursive solution to this problem, but the performance of the simple implementation is likely to be unacceptable. A more efficient implementation must use a loop instead of recursion, and must construct the new list backwards to avoid the linear storage. Sketching allows the programmer to express these insights as a partial program without having to think too much about the details of the implementation.</p><p>The sketch for this problem is shown in Fig. <ref type="figure">1</ref>. The body of reverseEfficient encodes the basic structure of the solution: allocate a new list, and perform a series of conditional pointer assignments inside a while loop. In order to define the space of possible conditionals and assignments, the sketch uses regular expression notation to define sets of expressions in lines 1-3. The sketch, in short, encodes everything that can be easily said about the implementation, and constrains the search space enough to make synthesis tractable.</p><p>Together with the sketch, the programmer must provide a specification that describes the correct behavior of the reversal routine. The Sketch synthesizer allows the user to provide specifications in the form of parameterized or non-deterministic test harnesses. Figure <ref type="figure">1</ref> shows the test harness for the list reversal; the synthesizer will guarantee that the harness succeeds for all values of n &lt; N. Specifically, the synthesizer guarantees that none of the inputs within the given bound will trigger any assertions or cause any illegal memory accesses. Additionally, the system also guarantees that the unbounded while loop whose condition is left unspecified will terminate for all n &lt; N. On a laptop, the complete synthesis process takes less than a minute for N = 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Semantic of sketches</head><p>A sketch can be understood as a set of programs, each corresponding to a different valuation of the holes. This section defines the synthesis semantics of sketches in a way that makes it easy to characterize the set of correct solutions to the sketch and the relationship between the values of holes and the state of the program at a given point in the execution.</p><p>To illustrate the key ideas behind the formalism, consider the following example.</p><p>generator int linexp(int t){ return t * ?? 0 + ?? 1 ; } generator int linexp2(int t1, int t2){ return linexp g1 (t1) + linexp g2 (t2); } harness void HelloWorldGen(int x, int z){ int y = linexp2 g0 (x, z); assert y == x + x + z; } The example is a simple variation of the "Hello World" program that uses generators. The holes and the call sites for the generators have been labeled with identifiers to help us to refer to them in the text. Now, recall that the goal of synthesis is to assign a value to every hole. Moreover, in the case of generators, the synthesizer needs to assign different values to the same hole depending on the calling context. In order to model these value assignments, we use a control function φ : H ×T → Z that assigns a value to each hole in the program at a given calling context τ . In the example above, there are two holes Fig. <ref type="figure">1</ref> Complete sketch and specification for the linked list reversal problem and two different valid calling contexts for these holes: τ 1 = g 0 • g 1 and τ 2 = g 0 • g 2 . Therefore, any φ for this sketch must define a value for each of the following four pairs of holes and calling contexts: (?? 0 , τ 1 ), (?? 0 , τ 2 ), (?? 1 , τ 1 ), (?? 1 , τ 2 ).</p><p>In the synthesis semantics, every value in the program is modeled as a function of the control. We call these functions parameterized values, and we use the Greek letter Ψ to designate the set of all such values. For example, in sketch above, y has the parameterized value λφ.x * φ(?? 0 , τ 1 )+φ(?? 1 , τ 1 )+ z * φ(?? 0 , τ 2 )+φ(?? 1 , τ 2 ). The state of the program is modeled with an environment σ that maps variable names to parameterized values, as summarized in Fig. <ref type="figure">2</ref>.</p><p>The formalism is very different from that used in automata-based synthesis. The main motivation for choosing this formalism in place of a more traditional one is to simplify reasoning about some of the higher level features in the language. For example, in this formalism it is relatively easy to describe the difference between a user-defined generator and a function, or to reason about the semantics of high-order functions, or even high-order functions that take generators as parameters. It also makes it relatively easy to prove the correctness of program transformations, such as the partial evaluation mechanism used to produce code from a sketch <ref type="bibr" target="#b14">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basic rules</head><p>The synthesis semantics are described formally through a very simple model language described by the abstract syntax Fig. <ref type="figure">2</ref> Notation for the synthesis semantics of Sketch Fig. <ref type="figure">3</ref> Abstract syntax for a simplified subset of the Sketch language in Fig. <ref type="figure">3</ref>. The language has been simplified in a few cosmetic ways to make the presentation simpler. For example, the operator is used to denote an arbitrary binary operator. Expressions are assumed to have no side effects; expressions that might lead to an error, such as out of bounds array accesses or division by zero, are assumed to be preceded by an appropriate assertion so the expressions themselves can be modeled as being side effect free. Procedure calls are assumed to be statements rather than expressions; they return values by writing to a special variable @, and they have no other side effects besides writing to this variable and possibly causing assertion failures.</p><p>Parameterized values allow us to define the synthesis semantics following many of the formalisms of standard denotational semantics. As in denotational semantics, the meaning of an expression is defined recursively through a denotation function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A[[•]]</head><formula xml:id="formula_4">τ : Aexp → (Σ → Ψ ). (<label>3.1)</label></formula><p>The denotation function defines the meaning of any expression as a function from a state to a parameterized value. The state σ : L → Ψ of the program is a mapping from the set of variable names L to parameterized values. The τ in the denotation function indicates the calling context under which the interpretation is taking place.</p><p>The denotation function is defined recursively for various types of expressions, quite similar to the way these functions are defined in denotational semantics. The only new rule is the rule for evaluating a hole, which produces a function that takes in a control φ, and produces the value of the hole on that control under the current calling context τ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A[[x]]</head><formula xml:id="formula_5">τ σ = σ (x) A[[?? i ]] τ σ = λφ.φ(?? i , τ ) A[[e 1 e 2 ]] τ σ = λφ. A[[e 1 ]] τ σ φ A[[e 2 ]] τ σ φ.</formula><p>Unlike expressions, commands have side effects. To model these, the denotation function defines the meaning of a command as a transformation on a state and a set of candidate controls. From the initial state and control set, the command produces an updated state and a subset of the original control set containing only those controls which are valid for that command, i.e. those that do not cause assertion failures. Expressions do not need to track these sets because, as was said earlier, we have assumed that evaluation of expressions will never lead to errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C[[•]]</head><formula xml:id="formula_6">τ : Command → ( Σ , P(Φ) → Σ , P(Φ) ) (3.2)</formula><p>The two most basic rules are those for assertions and assignments.</p><formula xml:id="formula_7">C[[x := e]] τ σ , Φ = σ [x → A[[e]] τ σ ] , Φ C[[assert e]] τ σ , Φ = σ , {φ ∈ Φ : A[[e]] τ σ φ = 1} .</formula><p>Assignments modify only the state while leaving the set of candidate controls unmodified. Assertions, on the other hand, narrow the set of valid controls, to include only those that will cause the assertion to succeed.</p><p>Sequencing of commands is easy to define; it is just a composition of two functions.</p><formula xml:id="formula_8">C[[c 1 ; c 2 ]] τ σ , Φ = C[[c 2 ]] τ ( C[[c 1 ]] τ σ , Φ )</formula><p>Example To illustrate how these rules operate, consider the denotation function for the body of the Hello-World example in the previous section. int y = x * ??; assert y == x + x;</p><p>For this example, the initial state will just map the input variable x to a symbolic input value x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C[[y</head><formula xml:id="formula_9">= x * ?? 0 ; assert y == x + x;]] τ [x → x] , Φ = C[[assert y == x + x]] τ C[[y = x * ?? 0 ]] τ [x → x] , Φ In that equation, C[[y = x * ?? 0 ]] τ [x → x] , Φ evaluates to the following pair. C[[y = x * ?? 0 ]] τ [x → x] , Φ = [x → x, y → ( A[[x * ?? 0 ]] τ [x → x])] , Φ = [x → x, y → λφ.x * φ(?? 0 , τ ∅ )] , Φ Therefore, C[[assert y == x + x]] τ C[[y = x * ?? 0 ]] τ [x → x] , Φ = C[[assert y == x + x]] τ [x → x, y → λφ.x * φ(?? 0 , τ ∅ )] , Φ = [x → x, y → λφ.x * φ(?? 0 , τ ∅ )], {φ ∈ Φ : x * φ(?? 0 , τ ∅ ) == x + x}</formula><p>The resulting pair tells us what we needed to know about the semantics of the Hello-World program. On the one hand, it shows the exact relationship between the state and the choice of value for the hole. On the other hand, it constrains the set of valid control functions to those satisfying the relationship x * φ(?? 0 , τ ∅ ) == x + x.</p><p>The rules for control statements are somewhat more complicated due to the handling of Φ. In an if statement, each branch is evaluated under the subset of Φ that would cause the program to take that branch, and the resulting sets of controls are combined through set union. In the rules below we use the notational shortcut a?b:c to represent the function that returns b if a is true and c otherwise.</p><formula xml:id="formula_10">C[[if e then c 1 else c 2 ]] τ σ , Φ = σ , Φ ,</formula><p>where σ and Φ are defined through the following equations:</p><formula xml:id="formula_11">Φ t = {φ ∈ Φ : A[[e]] τ σ φ = true} Φ f = {φ ∈ Φ : A[[e]] τ σ φ = f alse} σ 1 , Φ 1 = C[[c 1 ]] τ σ , Φ t σ 2 , Φ 2 = C[[c 2 ]] τ σ , Φ f Φ = (Φ 1 ) ∪ (Φ 2 ) σ = λx.λφ. A[[e]] τ σ φ ? σ 1 xφ : σ 2 xφ.</formula><p>while loops are handled in a similar way as they are handled in regular denotational semantics, by defining their denotation function recursively.</p><formula xml:id="formula_12">W ( σ , Φ ) = C[[while e do c]] τ σ , Φ = σ , Φ Φ t = {φ ∈ Φ : A[[e]] τ σ φ = true} Φ f = {φ ∈ Φ : A[[e]] τ σ φ = f alse} σ 1 , Φ 1 = W ( C[[c]] τ σ , Φ t ) Φ = (Φ 1 ) ∪ (Φ f ) σ = λx.λφ. A[[e]] τ σ φ ? σ 1 xφ : σ xφ</formula><p>For some loops, it is possible to solve the equation above to derive a closed form expression for W . For example, consider the loop below. wihile i &lt; N do assert ?? 0 &gt; i i = i+1</p><p>For this loop, the closed form solution for W (σ, Φ) is</p><formula xml:id="formula_13">σ (i) &lt; N σ [i → N ] , Φ ∩ {φ : φ(?? 0 ) &gt; N -1)} else σ , Φ</formula><p>One can check that this function satisfies the recursive constraints for W . Unfortunately, the problem of finding a closed form for the W function of a loop is undecidable in general. In our synthesizer, we will get around this problem by bounding the number of iterations of loops. For states σ that cause the loop to iterate more than the allowed number of times, we define W (σ, Φ) = (σ , ∅). In practice, this will mean that our synthesizer may fail to find a solution to a sketch when one actually exists, or more commonly, that the user will have to make sure that the bounds in the number of iterations are enough to handle all the inputs that the synthesizer may consider.</p><p>There are still some semantics left to describe, namely the semantics of procedures and generators, and the current limited support for language features such as arrays and heap allocated objects. However, this covers the major ideas behind the synthesis semantics, which will allow us to define the set of valid solutions to a sketch and subsequently to reason formally about our novel counterexample guide inductive synthesis algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Procedures and generators</head><p>Procedure calls behave as we would expect from standard denotational semantics. For a function defined as def f(x) c, the semantics of a call to f(e) are defined by evaluating the body of the function under the empty calling context τ ∅ , and the initial state</p><formula xml:id="formula_14">σ ⊥ [x → A[[e]] τ σ ],</formula><p>where σ ⊥ is the empty state.</p><formula xml:id="formula_15">σ , Φ = C[[c]] τ ∅ σ ⊥ [x → A[[e]] τ σ ] , Φ C[[ f (e)]] τ σ , Φ = σ [@ → σ (@)] , Φ</formula><p>In the definition, the return value of f is stored in the special variable @ as explained before.</p><p>The evaluation of generators is only slightly different. Instead of evaluating the body under the empty calling context, the body is evaluated under the calling context τ • g i , where g i identifies the current call site for the generator. Therefore, the semantics for a call to a generator defined as defgen g(x) c from a call site g i are defined by the formulas below.</p><formula xml:id="formula_16">σ , Φ = C[[c]] τ •g i σ ⊥ [x → A[[e]] τ σ ] , Φ C[[g(e)]] τ σ , Φ = σ [@ → σ (@)] , Φ</formula><p>An interesting observation is that procedure calls have the effect of forgetting the calling context, so generators called from a procedure will behave the same regardless of the calling context of the procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Bounded semantics for generators</head><p>As we saw in Sect. 2.3, a generator represents a set of functions, and the synthesizer is free to select any of these functions to replace a call to the generator. However, there is a problem with the way we defined the synthesis semantics for generators: they make generators too powerful. So powerful, in fact, that they can represent sets which include functions that are not even computable, a clear problem if we expect to synthesize code from them.</p><p>The problem is that the semantics defined so far allow programmers to write sketches which can only be resolved with an infinite φ. A trivial example of this would be the universal generator:</p><p>generator int univ(int x){ if( abs(x) &gt; 0 ){ return univ(abs(x)-1); } else { return ??; } } According to the synthesis semantics, the generator above can be made to represent any function in the set N → Z, even though we know some functions in this set are not computable.</p><p>To address this problem, we provide a slight modification to the semantics which we call bounded generator semantics. Bounded generator semantics bounds the recursion of generators by specifying a bounded set of call stacks τ . Thus, for a generator defined as defgen g(x) c, the semantics of a call to g at call site g i now involve a check of whether τ ∈ τ .</p><formula xml:id="formula_17">σ , Φ = C[[c]] τ •g i σ ⊥ [x → A[[e]] τ σ ], Φ C[[g(e)]] τ σ, Φ = σ [@ → σ (@)], Φ if τ ∈ τ σ, ∅</formula><p>One can see from the formulas that trying to evaluate a generator when the current stack does not belong to τ has the same effect as an assertion failure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The sketch resolution equation</head><p>In Sketch, it is required that all sketches have at least one harness procedure h. The semantics of a program P are thus defined in terms of the effect of calling the harness procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C[[</head><formula xml:id="formula_18">P]] τ σ , Φ = C[[h(in)]] τ ∅ σ , Φ .</formula><p>From this definition, we can define a set of valid controls Φ to be one which satisfies the sketch resolution equation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Equation 1 (Sketch Resolution) The set of controls Φ is said to be valid if it is invariant under C[[ P]</head><p>] τ ∅ for any initial state, as expressed in the equation below.</p><formula xml:id="formula_19">∀ σ C[[ P]] τ ∅ σ , Φ = σ , Φ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now, let Φ * denote the maximal set of valid controls, or maximal solution to the sketch.</head><p>The sections that follow will explain how to use the synthesis semantics to symbolically approximate Φ * .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Solving sketches with CEGIS</head><p>The synthesis semantics from the previous section allow the search for a valid control to be framed as a constraint satisfaction problem. Specifically, the synthesis semantics define the meaning of a program P through a denotation function C[[ P]] τ ∅ σ in , Φ → σ out , Φ . The function describes how an initial set Φ of candidate solutions is constrained down to a subset Φ containing only those solutions which are correct for input σ in . Therefore, a valid candidate φ ∈ Φ * is one that satisfies the constraints imposed by each of the possible inputs.</p><p>The synthesis semantics allow us to derive a set of constraints on φ in terms of the input state σ . If we use the predicate Q(φ, σ ) to represent these constraints, the synthesis problem becomes a doubly quantified constraint system. ∃φ ∀σ Q(φ, σ ).</p><p>(5.1)</p><p>Solving constraint systems involving such universally quantified variables is difficult, and many existing approaches do not scale to the size and complexity of the sketches we want to solve. Fortunately, sketches are not arbitrary constraint systems; they are partial programs written to convey the high level structure of a solution while leaving the details unspecified. Therefore, a decision procedure that takes advantage of the structure embodied in sketches can succeed where the general solution strategies fail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Solving sketches with inductive synthesis</head><p>The crucial observation that makes sketch synthesis possible is that for many sketches, an implementation that works correctly for the common case and for all the different corner cases is likely to work correctly for all inputs. For example, consider the sketch of a remove method for a doubly linked list. The sketch may have a large number of possible solutions, and a very large space of inputs; however, in addition to the common case where an element is removed from the middle of the list, there are only a handful of corner cases that can cause problems, such as the cases involving removal of the head, the tail, and removal from a list of size one. Therefore, the synthesis problem can be simplified enormously by focusing only on a handful of inputs that are representative of the common case and of the problematic corner cases. This insight can be made more formal through the following empirical hypothesis.</p><p>Hypothesis 1 (Bounded Observation Hypothesis) For a given sketch P, it is possible to find a small set of inputs E that fully represents the entire domain of inputs Σ such that any set of controls Φ satisfying</p><formula xml:id="formula_20">∀ σ ∈ E C[[ P]] τ ∅ σ , Φ = σ , Φ (5.2)</formula><p>will also be a solution to the sketch resolution equation of Sect. 4.</p><p>The hypothesis implies that we can frame the sketch synthesis problem as an inductive synthesis problem. Induc-Fig. <ref type="figure">4</ref> Counterexample driven synthesis algorithm tive synthesis is the process of generating a program from concrete observations of its behavior, where an observation describes the expected behavior of the program on a specific input <ref type="bibr" target="#b2">[3]</ref>. The inductive synthesizer uses each new observation to refine its hypothesis about what the correct program should be until it converges to a solution. Inductive synthesis had its origin in the work by Gold <ref type="bibr" target="#b6">[8]</ref> on language learning, and the pioneering work by Shapiro <ref type="bibr" target="#b13">[15]</ref> on inductive synthesis and its application to algorithmic debugging among others (e.g. <ref type="bibr" target="#b19">[21]</ref>).</p><p>Three important problems must be resolved in order to apply inductive synthesis to the problem of sketch resolution. First, it is necessary to have a mechanism to generate observations to drive the inductive synthesis. This mechanism should be able to generate inputs that exercise the corner cases in the implementation so the inductive synthesis quickly converges to a correct candidate. Second, the system needs a mechanism to determine convergence, i.e. to decide when the candidate derived from the set of observations actually generalizes to work correctly for all inputs. And finally, the system needs an inductive synthesis procedure capable of efficiently solving Eq. (5.2) for realistic sketches.</p><p>To address the first two problems, we designed a counterexample-guided inductive synthesis algorithm (cegis). This algorithm handles convergence checking and observation generation by coupling the inductive synthesizer with a validation procedure as illustrated in Fig. <ref type="figure">4</ref>. In the algorithm, a validation procedure checks the candidate implementation produced by the inductive synthesizer. If the validation succeeds, the candidate is considered correct, and is returned to the user. If validation fails, then the validation procedure is expected to produce a bounded and concrete input which exhibits the bug in the candidate program. The witness to the bug can then be used as an observation for the inductive synthesizer.</p><p>The cegis algorithm owes an intellectual debt to the idea of counterexample-guided abstraction refinement (cegar) introduced by Clarke et al.CEGARClarke03 to cope with the state explosion problem in model checking. cegar exploits the observation that a counterexample is much easier to find in an abstract model, but abstract models can produce spurious counterexamples which are infeasible in the concrete model. This drawback can be alleviated by combining the abstract model checker with a validation procedure that can check whether a counterexample is indeed feasible for the original model. If it is not, the validation procedure can refine the abstraction to disallow the spurious counterexample, and the cycle can be repeated. If we view the input set E as an abstraction of the original input domain, the cegis algorithm can be seen as an application of the cegar idea to the problem of program synthesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Formalization of algorithm</head><p>The algorithm illustrated in Fig. <ref type="figure">4</ref> can be succinctly expressed in terms of the synthesis semantics. In the algorithm below, Φ i is the set of all controls which satisfy the specification for the input states E = {σ 0 , . . . , σ i-1 }. The control φ i is a candidate selected non-deterministically from Φ i , and it constitutes the result of the inductive synthesis, as it is guaranteed to work correctly for all inputs in E. The state σ i is an input which exposes an error in the candidate program represented by φ i . The initial control set Φ 0 is initialized to Φ, the set of all controls, while σ 0 is initialized to a random initial state.</p><p>Each iteration of the cegis loop starts with the inductive synthesis phase. In this phase, a new set Φ i is computed by removing from Φ i-1 those controls which cause the specification to be violated for the input σ i-1 . Φ i is represented symbolically as a set of constraints, and it is derived by applying C[[ P]] τ ∅ to σ i-1 and to the symbolic representation of Φ i-1 . The symbolic representation is then queried for an element φ i ∈ Φ i which is the result of the inductive synthesis phase. It is important to note that while the set represented by Φ i is shrinking after every iteration, the representation is actually growing, since every iteration of the cegis loop is adding more constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 (CEGIS Algorithm)</head><p>.</p><formula xml:id="formula_21">σ 0 := σ random Φ 0 = Φ i := 0 do i = i + 1 (σ , Φ i ) := C[[ P]] τ ∅ (σ i-1 , Φ i-1 ) if Φ i = ∅ then return UNSAT_SKETCH def φ i ∈ Φ i ⎫ ⎬ ⎭ Inductive Synthesis def σ i s.t. C[[ P]] τ ∅ (σ i , {φ i }) = (σ , ∅) Validation while σ i = null return P E(P, φ i )</formula><p>The validation phase of the algorithm checks whether the candidate solution associated with φ i satisfies the specifica-tion for all possible inputs. If it does, then the candidate generated from control φ i is the solution that the algorithm was looking for; if it does not, then the process is repeated until either a solution is found or Φ i becomes empty. In the latter case, we can assert that the sketch has no valid solutions.</p><p>The sets Φ i generated by the cegis algorithm form a series that approaches Φ * , the maximal solution of the sketch equation, in strictly monotonic fashion. This means that if Φ is bounded, then the procedure above is guaranteed to terminate, and Φ i will converge towards Φ * . In fact, because the algorithm is only looking for a single φ ∈ Φ * , it can actually terminate before Φ i has converged to Φ * if the φ i selected from Φ i also happens to be in Φ * .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Convergence</head><p>The theoretical convergence properties of the algorithm are not great. The number of iterations is bounded by the maximum of the size of the control space and the size of the input space. Even for bounded sketches, these sizes can be astronomical. Moreover, if we do not bound Φ, the cegis algorithm can easily iterate forever. A curious example of this is the sketch below, which requires that the ith bit of ?? 0 be equal to i mod 2.</p><p>void main(int i){ int z = (?? 0 / pow(2, i) ) % 2; assert z == i % 2; } If we did not bound the set of possible values for ?? 0 , then the CEGIS algorithm would iterate forever on this sketch which actually has no solution according to the synthesis semantics.</p><p>However, the cegis algorithm was design to exploit our intuition that a few inputs covering all the relevant corner cases should allow us to infer the correct solution to the sketch. As Fig. <ref type="figure">5</ref> shows the convergence properties for sketches representing more useful functions are surprisingly good. The largest number of iterations was for the tableBasedAddition benchmark, which implements an addition of two 4-bit numbers as a single table lookup, where all the entries in the table are left empty for the synthesizer to discover. For this benchmark, the number of iterations was, as we would expect, equal to the size of the input space, since each input provides information about only one entry in the table. For less contrived benchmarks, however, the cegis algorithm was very good at abstracting the entire input space into a few representative inputs. for a given benchmark comes from the non-deterministic choice the cegis algorithm makes in selecting a φ i ∈ Φ i , and from the choice of the σ i that the validation phase decides to produce. However, you may notice that the number of iterations was fairly stable for each of the benchmarks. Of the 30 problems we tested, only 5 had a standard deviation of more than 2 iterations, and only 3 had a standard deviation larger than 4 iterations. This consistency suggests that there is something intrinsic to each benchmark that determines the number of observations needed for inductive synthesis to converge, irrespective of the non-deterministic choices made by the synthesizer. We hypothesize that the number of iterations in the cegis loop is related to the number of candidates solutions to the sketch. Figure <ref type="figure">6</ref> shows the relationship between the number of cegis iterations and the logarithm of the size of the candidate space of the benchmark. The correlation is fairly strong, with an R 2 slightly over 0.66. The log of the size of the candidate space is not the same as the number of bits of holes, because some sketches exhibit a lot of redundancy: there are many combinations of hole values that after partial evaluation produce the same program. For example, the benchmark tuto-rial3, had a single generator which represented a family of 4×10 14 ≈ 2 49 syntactically distinct expressions, but used 259 integer holes, each represented with 5-bits. The fact that the number of iterations is better predicted by the number of unique candidates than the number of holes points to one of the strengths of the cegis approach: the ability to eliminate large classes of equivalent candidates with a single representative input.</p><p>These experiments support the bounded observation hypothesis; specifically, they demonstrate that for many interesting problems, the number of observations needed to find a valid control is quite small. Moreover, they show that the each new iteration is able to eliminate a fraction of the remaining candidate space, including huge numbers of equivalent solutions. Having shown this, it remains to be shown how effectively the inductive synthesis procedure is able to generate candidate solutions from sets of observations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">SAT-based inductive synthesis</head><p>The cegis procedure depends on an inductive synthesizer to generate candidate implementations from a small set of inputs, and a validation procedure to produce counterexample inputs exposing problems in invalid candidates. The previous section showed how the inductive synthesizer and the validator could be expressed in terms of the synthesis semantics through the following two equations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C[[</head><formula xml:id="formula_22">P]] τ ∅ (σ i-1 , Φ i-1 ) = (σ , Φ i ) (6.1) C[[ P]] τ ∅ (σ i , {φ i }) = (σ , ∅)<label>(6.2)</label></formula><p>Inductive synthesis is defined using Eq. (6.1), which describes how a set of candidate controls Φ i-1 is constrained to a set Φ i by removing from it those controls that are invalid for input σ i-1 . The inductive synthesizer must then select a control φ i ∈ Φ i which represents the solution to the inductive synthesis problem. Validation is defined through Eq. (6.2); it requires the synthesizer to select an input σ i that shows that control φ i cannot be in the set of solutions to the sketch synthesis equation, i.e. input σ i causes an assertion failure on the candidate represented by control φ i .</p><p>These two equations describe inductive synthesis and validation, respectively, but they are not algorithmic; the semantic rules describe manipulations on sets and functions in the abstract, but they do not tell us how these objects should be represented, or how the manipulations should be implemented. This section describes an implementation of the synthesis semantics that turns the inductive synthesis and validation problems into constraint satisfaction problems. The implementation is based on the well-known idea of representing sets symbolically as constraints; specifically, a set Φ of controls is represented as constraints that must be satisfied by all the controls in Φ. For example, the constraint (φ(?? 0 ) = 5 ∧ φ(?? 1 ) &lt; 3) represents the set of all controls that assign 5 to the hole ?? 0 and a value less than 3 to hole ?? 1 . By representing sets of controls symbolically, we are able to derive systems of constraints for Φ i by manipulating the constraints representing Φ i-1 according to the rules of  To show how the constraint systems are constructed, we begin by describing the representations of controls. The number of holes in the program is bounded, and because we are restricting ourselves to bounded semantics, so is the number of calling contexts. Therefore, if we assume there are k distinct pairs of holes and calling contexts, we can represent φ as a control vector, h 0 , . . . , h k , where each control value h i corresponds to the value of a specific hole under a specific calling context. The notation h i,τ will sometimes be used to make explicit the exact hole and calling context for a given control value. Now, recall that the values of expressions and variables are represented in the semantics as parameterized values, which are functions mapping controls to concrete values ψ : Φ → Z. The synthesizer represents parameterized values symbolically as expressions in the language described in Table <ref type="table" target="#tab_3">1</ref>. These expressions are represented in the synthesizer as dags, rather than trees, to allow sharing of common subexpressions. The base expressions in this language can be of three types:</p><p>-Controls h i,τ indicating a specific component in the control vector. -Integer constants.</p><p>-Input nodes in i , which serve as place holders for concrete inputs.</p><p>The state σ is a mapping of variable names to parameterized values. Through the derivation process, the state is read and updated according to the synthesis semantics. For example, consider the various rules for evaluating expressions. Those rules are easily adapted to construct expressions in the intermediate language of Table <ref type="table" target="#tab_3">1</ref>.</p><formula xml:id="formula_23">A[[x]] τ σ = σ (x) A[[?? i ]] τ σ = h i,τ A[[e 1 + e 2 ]] τ σ = +( A[[e 1 ]] τ σ, A[[e 2 ]] τ σ )</formula><p>For example, the expression t * ?? 0 + ?? 1 is translated into an expression in the intermediate language through the following syntax directed translation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A[[t *</head><formula xml:id="formula_24">?? 0 + ?? 1 ]] τ σ = +( A[[t * ?? 0 ]] τ σ, A[[?? 1 ]] τ σ ) = +( * ( A[[t]] τ σ, A[[?? 0 ]] τ σ ), h 1,τ ) = +( * (σ (t), h 0,τ ), h 1,τ ).</formula><p>The final expression is a function of the control values h 0,τ and h 1,τ , and the input value of variable t.</p><p>Sets of controls are represented as constraints on the control values. To represent and manipulate these constraints, we exploit the intermediate language used to represent parameterized values by associating with each set Φ a characteristic function ψ Φ related to Φ through the following equation.</p><formula xml:id="formula_25">Φ = {φ : ψ Φ (φ) = 0}.</formula><p>In other words, a control φ belongs to Φ if and only if it satisfies the constraint ψ Φ (φ) = 0. For example, if Φ is the set of controls satisfying φ(?? 0 ) = 5 and φ(?? 1 ) &lt; 3, this set will be represented with the characteristic function ∧(= (h 0 , 5), &lt; (h 1 , 3)), shown graphically below.</p><p>Most standard set operations are easy to perform on the symbolic representation. For example, if ψ Φ 1 and ψ Φ 2 are the characteristic functions for the sets Φ 1 and Φ 2 , respectively, then the characteristic functions for the complement, intersection, and union of these sets are easy to construct from ψ Φ 1 and ψ Φ 2 as illustrated below.</p><formula xml:id="formula_26">Complement ¬Φ 1 = ¬(ψ Φ 1 ) Intersection Φ 1 ∩ Φ 2 = ∧(ψ Φ 1 , ψ Φ 2 ) Union Φ 1 ∪ Φ 2 = ∨(ψ Φ 1 , ψ Φ 2 )</formula><p>The rules of the synthesis semantics are used to construct the characteristic functions through syntax-directed translation. For example, the basic statements of assignment and assertion manipulate the state and the set of valid controls according to the following rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C[[x</head><formula xml:id="formula_27">:= e]] τ σ , ψ Φ = σ [x → A[[e]] τ σ ] , ψ Φ C[[assert e]] τ ∅ σ , ψ Φ = σ , ∧( A[[σ ]] e , ψ Φ )</formula><p>The same is true of the if statement; for the statement if e then c 1 else c 2 , we can follow the synthesis semantics to evaluate the two branches of the conditional.</p><formula xml:id="formula_28">ψ e = A[[e]] τ σ ψ Φ t = ∧(ψ Φ , ψ e ) ψ Φ f = ∧(ψ Φ , ¬(ψ e )) σ 1 , ψ Φ 1 = C[[c 1 ]] τ σ , ψ Φ t σ 2 , ψ Φ 2 = C[[c 2 ]] τ σ , ψ Φ f .</formula><p>Then, the rule for the if statement becomes</p><formula xml:id="formula_29">C[[if e then c 1 else c 2 ]] τ σ , ψ Φ = λx.mux 2 (ψ e , σ 2 (x), σ 1 (x)) , ∨(ψ Φ 1 , ψ Φ 2 )</formula><p>The rules for loops and procedure calls follow the same logic; the symbolic representations are manipulated according to the synthesis semantics, replacing set operations with operations on the characteristic functions. Because we are using bounded semantics, we do not have to worry about termination of loops or recursion.</p><p>An important advantage of representing sets as a constraint on the value of a characteristic function is that it is possible to query for a control in the set through a constraint satisfaction procedure. Any solution φ to the constraint ψ Φ (φ) = 0 is guaranteed to belong to Φ; if the constraints are unsatisfiable, then it means that Φ is empty.</p><p>This property allows us to implement inductive synthesis by a straightforward application of the semantics; the synthesizer can simply evaluate C[[ P]] τ (σ i-1 , Φ i-1 ) from its symbolic representation of Φ i-1 , and then query the representation for a control φ i ∈ Φ i .</p><p>The idea of representing sets as systems of constraints is not new. In fact, it was one of the major advances behind symbolic model checking <ref type="bibr" target="#b8">[10]</ref>. However, Sketch was the first system to represent the set of candidate solution to a synthesis problem as a SAT problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Validation</head><p>One of the advantages of separating inductive synthesis from validation is that any validation procedure that produces a counterexample input can be plugged into the algorithm. However, the Sketch synthesizer exploits the symbolic machinery of inductive synthesis to perform bounded symbolic model-checking on the candidate solution.</p><p>The validation problem can be framed directly in terms of the synthesis semantics as the problem of finding an input σ i that shows that the control φ i is not a solution to the sketch equation, so</p><formula xml:id="formula_30">C[[ P]] τ ∅ (σ i , {φ i }) = (σ , ∅). (6.</formula><p>3)</p><p>The Sketch synthesizer uses symbolic reasoning to search for an input state σ i satisfying the equation above using the exact same satisfiability procedure used for inductive synthesis.</p><p>Interestingly, the validation procedure that results from this symbolic manipulation is equivalent to the SAT-based bounded model checker developed by Clarke et al. <ref type="bibr" target="#b5">[6]</ref>. Their tool, called CBMC, also translates a program into a set of Boolean constraints and uses SAT to solve the system for a counterexample. Some of their low-level encodings to SAT are different from outs, but the high-level ideas are the same.</p><p>Saturn <ref type="bibr" target="#b21">[23]</ref> is another SAT-based validation tool that operates through similar principles. One of the key features of Saturn is that it is able to abstract procedures into summaries, allowing for modular verification, which our system does not support. What is most interesting about the similarity between our procedure with Saturn and CBMC is that the same techniques that proved successful for bug finding can be effective for inductive synthesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experience</head><p>This section provides an overview of some of the problems that can be solved with sketch and gives some idea of the overall performance of the synthesizer. All the experiments described were performed on a very modest ThinkPad laptop with a single core Intel T1300 at 1.66GHz with 2MB of L2 cache and 1GB of memory. All the performance numbers in this section are averages from 4 to 7 different executions using different random seeds for the initial counterexample and the random restart in the SAT solver.</p><p>Figure <ref type="figure" target="#fig_3">7</ref> shows the solution times for several variations of 18 representative benchmarks. The exact quantities in the chart should be taken with a grain of salt, because they vary quite a bit from machine to machine, and with different versions of the solvers. However, they give a good idea of the relative complexity of solving different problems and of the scale of problems that can be solved at interactive speeds. The benchmarks were chosen to be representative of real programming problems which the synthesizer can solve in less than 15 min. Many of these benchmarks were written by our group, but nine of them were developed by students from a graduate introductory programming languages class held at UC Berkeley in the fall of 2007. The benchmarks can be roughly categorized into three groups: bit manipulations, integer manipulations and linked data structures.</p><p>Bit manipulations What characterizes these benchmarks is that they treat machine words as bit-vectors. All these benchmarks use the imple-ments directive to provide specifications in the form of reference implementations that manipulate each bit individually. The sketches contain the necessary insight to take advantage of bit-level parallelism. These benchmarks were our first application of sketching because the low-level details almost always involve discovering bitmasks and precise shift amounts, so we could write sketches for them using only the integer holes, even before we had any of the higher level sketching constructs.</p><p>Example A typical benchmark of this category is the morton benchmark, written by graduate student Jacob Burnim. A 32-bit morton number is computed by interleaving the bits of two 16 bit integers x and y, so that bit r 2 * i of the result equals bit x i of x, and bit r 2 * i+1 corresponds to bit y i of y. According to Anderson, "Morton numbers are useful for linearizing 2D integer coordinates, so x and y are combined into a single number that can be compared easily and has the property that a number is usually close to another if their x and y values are close" <ref type="bibr" target="#b1">[2]</ref>.</p><p>It is easy to interleave the bits of two 16-bit integers by selecting the bits one by one, but it is possible to do it more efficiently by taking advantage of the ability to shift all the bits in a word with a single instruction; while the bit-by-bit approach takes O(W ) operations for a word of size W , the task can be achieved with O(log(W )) operations using bitvector parallelism. The high-level insight can be stated as follows.</p><p>First, scatter the 16 bits of each of the two inputs across the even bits of a 32 bit word. Then, or together the resulting two words, shifting one of the words by one to align its bits with the gaps in the other word. The scatter can be done with log-shifting, a technique for efficiently scattering or gathering bits by shifting many bits at a time as illustrated in Fig. <ref type="figure">8</ref>. A logshifter can be implemented by repeatedly shifting some bits, oring them with the original word, and then masking the result.</p><p>The insight can be expressed succinctly in a sketch. The log-shift generator encapsulates the basics of logshifting, but leaves unspecified the tricky details of exactly what bits to mask and how much to shift on each step; this means that the generator could actually be reused to implement other scattering patterns different from the one required for this Fig. <ref type="figure">8</ref> Examples of log-shifting for scattering and gathering bits problem. The sketch also leaves unspecified the number of steps required for the logshifter; this is a potential problem because it gives the synthesizer the freedom to include more steps than necessary. The student produced a second version of this benchmark (morton_easiest) that specifies that on each iteration the shift amount should be reduced by half. This version of the benchmark is guaranteed to produce the desired answer, and resolves much faster because of the added information. All the benchmarks in the second group in Fig. <ref type="figure" target="#fig_3">7</ref> are bit manipulation benchmarks. These benchmarks are difficult to solve despite their relatively small size (compress is the largest one of these sketches and it is only 47 lines of code). There are two reasons for this. First, their candidate spaces are often huge; a single 32-bit mask will have billions of possible solutions. Moreover, the holes are often very tightly coupled, in the sense that every bit in the output potentially depends on the value of every single hole, as was the case in the morton example. This makes these benchmarks very challenging for the solver. On the other hand, they are a great domain for sketching because it is very challenging to program by hand, and there is often a very good match between the insight and the sketch. Moreover, because these benchmarks are inherently bounded, the SAT-based validation procedure can provide absolute correctness guarantees.</p><p>Integer manipulations These benchmarks manipulate integers or arrays of integers; with the manipulations typically involving some arithmetic. Their specifications also consist of reference implementations, while the sketches often must take advantage of some mathematical principle to achieve better performance at the expense of clarity. All the benchmarks in the first group in Fig. <ref type="figure" target="#fig_3">7</ref> are integer manipulation benchmarks.</p><p>Example A great example from this domain is the Karatsuba multiplication algorithm for large integers (karatsuba). The algorithm is a building block of many public key cipher implementations. It uses a divide and conquer approach to multiply integers with N digits in O(N 1.585 ), as opposed to the standard O(N 2 ) from the grade school multiplication algorithm.</p><p>The algorithm starts by decomposing two N -digit numbers x and y into two halfs: x = x 1 b N /2 + x 0 , y = y 1 b N /2 + y 0 , where b is the base. The standard multiplication can be defined recursively in terms of the two halfs.</p><p>x * y = b N x 1 * y 1 + b N /2 (x 1 * y 0 + x 0 * y 1 ) + x 0 * y 0</p><p>The expensive (big-integer) multiplication is denoted with the * operator. The multiplication with the base terms is implemented with shifts, so it is not an expensive operation.</p><p>Let us illustrate how Karatsuba might have been able to invent (and implement) his algorithm with the assistance of sketching. He would first observe that it may be possible to replace the four expensive multiplications with three expensive multiplications. He would guess that one cannot avoid computing terms x 0 * y 0 and x 1 * y 1 , so he would focus on replacing the term x 1 * y 0 + x 0 * y 1 with a one-multiplication term. This optimization would be performed at the expense of adding big-integer additions or subtractions, a good trade-off since their complexity is linear rather than quadratic. In mathematical notation, the idea can be expressed in the following sketch, where the generator poly(n, x 1 , . . . , x k ) produces a polynomial in k variables of degree n.</p><p>x * y = poly(??, b) * (x 1 * y 1 )</p><p>+ poly(??, b) * ( poly(1, x 1 , x 0 , y 1 , y 0 ) * poly(1, x 1 , x 0 , y 1 , y 0 ))</p><p>+ poly(??, b) * (x 0 * y 0 )</p><p>It turns out that the idea for this optimization is correct and the correct formula is shown below.</p><formula xml:id="formula_31">x * y = (b 2 + b) * (x 1 * y 1 ) + b * ((x 1 -x 0 ) * (y 1 -y 0 )) + (b + 1) * (x 0 * y 0 )</formula><p>Creating an implementation using the Sketch system is just as simple. The sketch in Fig. <ref type="figure">9</ref> contains the same insight expressed above, but it also addresses the representation issues for the integers and their operations. Integers are represented as N element arrays of ints; addition, complement and shifting are all provided through separate routines. The half ranges are read from the original input array using special array notation available in the language, where A[a::b] Fig. <ref type="figure">9</ref> Sketch for Karatsuba's multiplication correspond to a range of b elements in A starting with the element at position a. Multiplications by the base term are encoded through a shift operation.</p><p>Ideally, we would like for the routine to be parametrized by N , and the solver to guarantee the result for all N . Unfortunately, the Sketch solver cannot reason about unbounded operations, so the correct answer was derived by setting N to 4, and limiting the range of integer values to two bits.</p><p>The karatsuba benchmark illustrates many relevant aspects of integer benchmarks. First, because we use bounded model checking as our correctness criteria, we cannot provide strong correctness guarantees. For most of these benchmarks, validation was performed for all integer inputs in the range [0, 8]. Only the tutorial benchmarks were validated for inputs in the range [0, 32]. For these benchmarks these ranges happened to be sufficient in the sense that the programs that were correct for all inputs between 0 and 8 turned out to be correct programs, but this could only be ascertained through hand examination of the result.</p><p>The ranges of inputs are fairly small even by the standards of bounded model checking. This is partly a consequence of the use of the unary representation of integers used internally by the solver. This representation is very efficient when representing integers ranging over a small set of values, but it grows very quickly, making it impractical to validate sketches over a wide range of input values. It is very likely that the growing power and availability of SMT solvers capable of reasoning about integers will have a big impact on these benchmarks. In spite of this, the synthesizer is able to quickly produce correct implementations from sketches with a lot of freedom for many interesting kernels.</p><p>Linked data structures These benchmarks involve manipulation of data structures in the heap. The linked list reversal from the introduction is an example of this class of benchmark.</p><p>Example Another interesting benchmark in this category is the Set-Test benchmark. This benchmark implements a treebased set using a hash table as a reference implementation. One of the problems that make tree manipulation tricky is symmetry: the code for the different cases is very similar except some cases have to use the left child and some have to use the right child, and it is easy to get confused about which child should be used where. Sketching allowed us to eliminate this redundancy using generators. The fragment of the Set-Test sketch shown below uses a generator to produce the code that decides whether to add a new node as a child of the current node or to continue traversing. The generator will produce the correct code both for the case when n.val is less than v and when it is not. Like the integer manipulation benchmarks, data-structure benchmarks also have to cope with the limitations of the validation procedure. Our validation procedure cannot guarantee the absolute correctness of the synthesized implementation, only its correctness against a bounded test harness. For example, the test harness for the enqueue benchmark checks the equivalence of the sketched queue with an array implementation on an input-directed sequence of operations.</p><p>This type of test harness is often referred to in the verification literature as a "most general client" <ref type="bibr" target="#b0">[1]</ref> because it verifies that the data-structure works correctly for all sequences of up to N operations, which is a very good, but it is not the same as verifying that the queue is correct.</p><p>Another interesting feature of the data-structure benchmarks, especially when compared with the bit manipulations, is that one can leave a great amount of code unspecified while keeping the search space relatively small. For example, in the listReverseHard benchmark, the assignments in the body of the loop specified remarkably little, leaving a lot of freedom to the synthesizer, but the synthesizer only had 60 different possibilities to search through for each assignment. By contrast, a single bit-mask in the morton benchmark can have 2 32 different possible values. This means that sketches can be allowed to have a lot of freedom without overwhelming the synthesizer. At the same time, we can see that the solution times for these benchmarks can be quite large given their small input and candidate spaces, which seem to suggest that our very naïve representation of the heap may have a lot of room for improvement.</p><p>Overall, these benchmarks are not such a good match for sketching, in the sense that there is a lot of boilerplate that programmers have to write before the synthesizer is able to synthesize an implementation. At the same time, programmers often have strong intuitions about how these data-structure manipulations work, which are not reflected in the sketch. Nevertheless, these benchmarks provide a good stress test of the capabilities of the sketch synthesizer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Comparison with QBF</head><p>One of the original motivations for the cegis algorithm was the difficulty of solving constraint systems with multiple quantifiers. Specifically, we have seen that the synthesis problem reduces to a 2QBF problem of the form shown below.</p><formula xml:id="formula_32">∃φ ∀σ Q(φ, σ ). (<label>8.1)</label></formula><p>The predicate Q is a boolean formula, so the equation above is a satisfiability problem on a quantified boolean formula (QBF). Over the last few years, there has been a lot of interest in QBF solvers. Every year, there is even a QBF competition held side by side with the annual SAT competition at the International Conference on Theory and Applications of Satisfiability Testing. Therefore, an important question is: How does the cegis algorithm compare with general QBF solvers?</p><p>To answer this question, we generated QBF problems for four representative benchmarks of varying degrees of difficulty: polynomial, doublyLinkedList, lss_hardest and parity. The QBF problems were generated from the optimized constraint system, so the QBF solver could benefit from all the highlevel optimizations available to the Sketch synthesizer. It is worth noting that even though there are only two quantifiers in Eq. (8.1), this is actually a 3-QBF problem, because converting Q to conjunctive normal form requires the introduction of temporary variables which are existentially quantified.</p><formula xml:id="formula_33">∃φ ∀σ ∃t Q cn f (φ, σ, t) (8.2)</formula><p>The QBF formulas from the four benchmarks were fed to 2clsQ, the winner of the 2006 QBF competition <ref type="bibr" target="#b11">[13]</ref>, and quantor version 3.0, the winner of the 2008 competi-tion <ref type="bibr" target="#b3">[4]</ref>. In both cases the results support the cegis approach to resolving sketches.</p><p>In the case of 2clsQ, the performance difference was overwhelming. Of the four benchmarks, 2clsQ was only able to resolve polynomial, the easiest one. For this benchmark, 2clsQ took 94 s to find a solution, compared to 0.1 s it took Sketch with MiniSat. 2clsQ was unable to solve any of the other three benchmarks in the 20 min of allotted time, while Sketch was able to solve par-ity, the hardest of these benchmarks, in 257 s using MiniSat, and in only 11 s using ABC. quantor did much better on the easier benchmarks, but it was still unable to compete with cegis on the harder problems. For polynomial and doublyLinkedList, quantor finished in about the same time as Sketch. For both parity and lss_hard, however, quantor exhausted all available memory after the first 2 min of execution. After this, the system started thrashing and became unresponsive, so the execution had to be stopped. By contrast, Sketch was able to solve both of these benchmarks using less than 150MB of memory. There is an alternative encoding into a QBF problem with avoids the third quantifier; the idea is to negate Eq. (8.1) before converting the predicate into CNF.</p><formula xml:id="formula_34">∀φ ∃σ Q(φ, σ ). (8.3)</formula><p>Then, Q, the negation of Q, can be converted to CNF without introducing an additional quantifier alternation. ∀φ ∃σ ∃t Qcn f (φ, σ, t).</p><p>(8.4)</p><p>Now, the QBF solver must find a φ that falsifies the equation above. However, this encoding proved to be even worse than the previous one; with this encoding, quantor was unable to solve even the polynomial problem without running out of memory.</p><p>8.1 2QBF solvers and quantifier elimination in SMT Ranjan et al. <ref type="bibr" target="#b10">[12]</ref> have shown that for 2QBF problems, specialized algorithms can be more efficient than the algorithms used by general QBF solvers. In <ref type="bibr" target="#b10">[12]</ref>, they present two algorithms that are also based on two interacting solvers where one produces candidate solutions and the other one checks them. However, the interaction between the two algorithms is more limited than in our approach. In particular, every iteration of both algorithms adds a single clause to the solver in charge of producing candidate solutions. This clause is computed by taking the failed solution and computing a cover set for it, i.e. a partial assignment that is computed by eliminating those variables whose values were not used in determining that the solution had failed. The new clause rules out this partial assignment from appearing again in a candidate solution. By contrast, our approach does not require us to compute a cover set, and the clauses added after each iteration of our approach are a strictly stronger than the single clause added by these algorithms, so we can expect our algorithm to converge in fewer iterations.</p><p>Very recently, Wintersteiger et al. <ref type="bibr" target="#b20">[22]</ref> have worked on adding support for quantifiers to their SMT solver. Their approach combines a basic counterexample-guided refinement approach similar to cegis with other techniques such as substitution and term rewriting. Their approach is more recent than our original cegis algorithm <ref type="bibr" target="#b17">[19]</ref> and is targeted towards a more general use of quantifiers in SMT problems. Their approach was actually inspired by the work of Jha et al. <ref type="bibr" target="#b7">[9]</ref> and Srivastava et al. <ref type="bibr" target="#b18">[20]</ref>, both of whom were influenced by our earlier work.</p><p>The cegis approach is unlikely to beat the QBF solvers on arbitrary QBF problems. However, on sketching problems, the cegis algorithm is able to exploit the bounded observation hypothesis and efficiently synthesize a correct candidate from only a small set of inputs. Moreover, the cegis approach has the useful property of separating synthesis and validation, allowing the best techniques to be used for each of these two functions. For example, in another paper <ref type="bibr" target="#b16">[18]</ref> we used cegis to do synthesis in the context of concurrent algorithms. For that domain, we were able to get significant scalability benefits from using an explicit state model-checker (SPIN) in place of SAT for the verification phase. This important flexibility is lost if we see the problem as a monolithic 2QBF problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Case study: sketching AES</head><p>As a case study <ref type="bibr" target="#b17">[19]</ref>, we used the Sketch synthesizer to create a full implementation of the AES cipher [7] by syn-thesizing its most difficult fragments. For this experiment, we created a reference implementation by directly transcribing the NIST standard into code. The NIST standard defines the cipher in terms of 14 rounds which take a 128-bit input block and a round key and processes it, followed by a final round. The NIST standard determines that every round starts with a ByteSub transformation that performs a set of table lookups to do a substitution on each byte; ShiftRows permutes the bytes in the block; and MixColumns transforms each word by treating it as a 4 element vector in the Galois field G F(2 8 ), then multiplying it with a matrix whose elements are also in G F (2 8 ). The final round is like the other rounds but without the MixColumns transformation.</p><p>In the optimized version, all the operations in the round are folded into a set of table lookups. A programmer implementing AES by traditional means would have to derive the formula for generating the table entries; this may be difficult if one is not familiar with the algebra involved. The programmer would then have to write an ad hoc code generator to produce the table from the specification through some algebraic manipulation, and then would have to incorporate the generated table into the code and check the correctness of the cipher using known input/output pairs. By contrast, Sketch is able to synthesize the tables automatically and verify their correctness against the reference implementation. Figure <ref type="figure" target="#fig_6">10</ref> shows the sketch for the regular round. The sketch for the final round is similar, except that it uses only one table instead of four, and it combines outputs from the tables using masks-which are left unspecifiedinstead of xors.</p><p>The roundSK sketch places a lot of stress on the solver since there are 32,768 bits in the table that have to be generated. Furthermore, each input considered by the solver helps complete only a small number of table entries, so the synthesize/verify loop has to iterate 655 times. Nonetheless, the solver is able to complete the sketch in about an hour. Table <ref type="table" target="#tab_7">2</ref> shows the exact times spent by the two SAT solvers involved. All instances of synthesis were solved using MiniSat. For verification, we used MiniSat for the first 645 iterations. For the last 10 iterations we switched our SAT solver to ABC <ref type="bibr" target="#b9">[11]</ref> because it provides much better performance for hard SAT problems.  The difference between the hand coded AES and the sketched version is less than 10 %, the difference due to the fact that the hand optimized code was written in a way that caused the compiler to do a better job at register allocation. We can also see that the original specification, which is very close to the specification of AES [7], is over 1,000 times slower.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusions</head><p>The paper has explored the power of the Sketch system to synthesize the low-level details for small but complex programs in a variety of domains. In addition to that, it has shown some potential avenues for significant improvement in the synthesizer's performance.</p><p>There are a number of other strategies that could significantly improve the performance of the solver. For example, using constraint solvers that can reason about integers could make a big difference for integer problems. Similarly, improved search strategies that take advantage of more semantic information about the sketch could make the search more efficient. Additionally, there is great room for improvement in the encoding of higher-level sketching constructs and advanced language features; the current encoding is very simple and naïve.</p><p>Beyond performance, however, it is important to keep in mind that a synthesizer is a productivity tool. The ultimate test for any optimization is the extent to which it is able to improve programmer productivity. A detailed analysis of how improvements in performance affect programmer productivity is one of the great omissions in this work. Quantifying this impact requires user studies and analysis of the use of sketching in the field. Overall, some of the bigger open issues in sketching involve the following areas:</p><p>Improving programmability While the sketch language provides a handful of high-level constructs to help programmers express their insight without having to reason about the low-level details, the language is still too low-level for many domains. For example, for the body of the loop in the sketch from Fig. <ref type="figure">1</ref>, the programmer had to go through the very mechanical process of describing the set of memory locations that could be reached from the lists l and nl. We have found this process to be error prone, as it is easy for programmers to forget choices which turn out to be necessary to construct the solution; for example, many programmers might forget to include null in the set LOC. Moreover, when programmers make mistakes and their sketches cannot be solved, it can be difficult for them to find the problems, since debugging a partial program can be more difficult than debugging a concrete one.</p><p>A solution to these challenges will have to involve multiple facets, including higher level mechanisms for expressing insights so programmers make fewer errors, language constructs that allow for more interactive exploration of the space of solutions, and diagnostic mechanisms that can pinpoint errors in a sketch.</p><p>Exploiting higher level insight Another big challenge is improving the performance of synthesis by harnessing highlevel insights, either about a specific program or about an entire domain. In the case of individual programs, we want to exploit high-level invariants that the programmer might know, in order to reduce the search space and make the synthesis more tractable.</p><p>In our PLDI 07 paper <ref type="bibr" target="#b15">[17]</ref>, we showed how synthesis could be made much more effective for programs in a particular domain by incorporating domain-specific insight into the synthesizer. We believe such domain-specific insight can make an enormous difference. This will be particularly true in the case of parallelism. For parallel programs, reasoning about concurrency, and about the effect of all possible interleavings is extremely expensive. However, large classes of parallel programs are written in a very disciplined manner that prevents threads from non-deterministically modifying shared memory. Exploiting this discipline should allow for dramatic performance improvements in the synthesis of many concurrent programs.</p><p>Moving beyond semantic equivalence and safety In many situations, programmers care about many other factors that go beyond functional correctness. Performance, for example, is a central consideration in many domains. Another closely related property involves statistical properties of an implementation. For example, a hash table will be correct regardless of the implementation of the hash function, but we would like the synthesizer to find an implementation that leads to a good distribution of keys. In some cases, some implementations may be preferred on purely aesthetic grounds; they are easier to read, or contain simpler control flow. The challenge is to develop synthesis strategies that can optimize on these non-functional criteria while still remaining tractable.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>int W = 32; void swap(ref bit[W] x, ref bit[W] y){ if(??){ x = x ^y; }else{ y = x ^y; } if(??){ x = x ^y; }else{ y = x ^y; } if(??){ x = x ^y; }else{ y = x ^y; } } harness void main(bit[W] x, bit[W] y){ bit[W] xold = x, yold = y; swap(x,y); assert y == xold &amp;&amp; x == yold; }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5 Fig. 6</head><label>56</label><figDesc>Fig. 5 Iterations per benchmark</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>i f c (e ind , e = , e = ) := (e ind = c) ? e = : e = the synthesis semantics. Extracting a control φ ∈ Φ i then becomes a constraint satisfaction problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 Solution time and memory consumption for selected benchmarks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>int W = 16; generator bit[2 * W] logshift(bit[2 * W] in){ int pt = 4 * W; repeat(??){ // Shift some of the bits, and mask // their original positions. in = (in | (in &lt;&lt; ??)) &amp; ??; } } bit[2 * W] morton(bit[W] x, bit[W] y) implements mortonSpec{ bit[2 * W] x2 = logshift(x); bit[2 * W] y2 = logshift(y); return x2 | (y2 &lt;&lt; 1); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>bit[W] round(bit[W] in, bit[W] rkey){ bit [W] t1 = ByteSub(in); bit [W] t2 = ShiftRows(t1); bit [W] t3 = MixColumns(t2); return t3 ^rkey; }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10</head><label>10</label><figDesc>Fig. 10 Sketch for one round of AES</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1</head><label>1</label><figDesc>Intermediate language used to represent parameterized values</figDesc><table /><note><p>Base e ::= c | h i,τ | in i Arithmetic e ::= +(e 1 , e 2 ) | -(e) | * (e 1 , e 2 ) | div(e 1 , e 2 ) | mod(e 1 , e 2 ) Comparison e ::=&lt; (e 1 , e 2 ) | &gt; (e 1 , e 2 ) | ≥ (e 1 , e 2 ) | ≤ (e 1 , e 2 ) | = (e 1 , e 2 ) Boolean e ::= ∨(e 1 , e 2 ) | ∧ (e 1 , e 2 ) | ⊕ (e 1 , e 2 ) | ¬(e) Selection e ::= mux n (e idx , e 1 , . . . , e n ) := e e idx</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 2</head><label>2</label><figDesc>Solution time for roundSK in AES benchmarkThe times for Synth and Verify hard correspond to the times for the last 10 iterationsPerformance of generated code. The resulting code was run against a hand optimized AES implementation from open SSL. The runtime for 50,000 encryptions was as follows:</figDesc><table><row><cell>Total Synth:</cell><cell>791 s</cell><cell>=13.183 min</cell></row><row><cell>Total Verify:</cell><cell>3,942 s</cell><cell>=65.7 min</cell></row><row><cell>Synth easy:</cell><cell>1.17 s</cell><cell>Avg time per SAT problem</cell></row><row><cell>Synth hard:</cell><cell>3.4 s</cell><cell>Avg time per SAT problem</cell></row><row><cell>Verify easy:</cell><cell>5.33 s</cell><cell>Avg time per SAT problem</cell></row><row><cell>Verify hard:</cell><cell>50 s</cell><cell>Avg time per SAT problem</cell></row><row><cell>OpenSSL AES</cell><cell>19.652 ms</cell><cell></cell></row><row><cell>Sketch</cell><cell>21.307 ms</cell><cell></cell></row><row><cell>Spec</cell><cell>19936.100 ms</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The synthesizer relies on bounded decision procedures, so for harnesses with integer inputs, the input space is the set of all integers within a given bound determined by a command line flag.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Comparison under abstraction for verifying linearizability</title>
		<author>
			<persName><forename type="first">D</forename><surname>Amit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rinetzky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th International Conference on Computer Aided Verification (CAV)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Bit twiddling hacks</title>
		<author>
			<persName><forename type="first">Anderson</forename></persName>
		</author>
		<ptr target="http://www-graphics.stanford.edu/~seander/bithacks.html" />
		<imprint>
			<date type="published" when="1997">1997-2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Inductive inference: theory and methods</title>
		<author>
			<persName><forename type="first">D</forename><surname>Angluin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="237" to="269" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Resolve and expand</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing, SAT&apos;04</title>
		<meeting>the 7th International Conference on Theory and Applications of Satisfiability Testing, SAT&apos;04<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement for symbolic model checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="752" to="794" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Behavioral consistency of c and verilog programs using bounded model checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yorav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual Design Automation Conference, DAC &apos;03</title>
		<meeting>the 40th Annual Design Automation Conference, DAC &apos;03<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="368" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Language identification in the limit</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Gold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Control</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="447" to="474" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Oracle-guided component-based program synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering, ICSE &apos;10</title>
		<meeting>the 32nd ACM/IEEE International Conference on Software Engineering, ICSE &apos;10<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Symbolic Model Checking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dag-aware AIG rewriting: a fresh look at combinational logic synthesis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC &apos;06: Proceedings of the 43rd Annual Conference on Design Automation</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="532" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A comparative study of 2qbf algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Ranjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Seventh International Conference on Theory and Applications of Satisfiability Testing (SAT 2004)</title>
		<imprint>
			<date type="published" when="2004-05">May (2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Binary clause reasoning in qbf</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samulowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bacchus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Conference on Theory and Applications of Satisfiability Testing, SAT&apos;06</title>
		<meeting>the 9th International Conference on Theory and Applications of Satisfiability Testing, SAT&apos;06<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="353" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Cute: a concolic unit testing engine for c</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/SIGSOFT FSE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Algorithmic Program Debugging</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Y</forename><surname>Shapiro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Program Synthesis By Sketching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>EECS, UC Berkeley</publisher>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Sketching stencils</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Saraswat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;07: Proceedings of the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sketching concurrent datastructures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation<address><addrLine>Tucson</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06">June. 2008</date>
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Combinatorial sketching for finite programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Saraswat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS&apos;06</title>
		<meeting><address><addrLine>San Jose</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">From program verification to program synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">POPL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Madrid</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A methodology for lisp program construction from examples</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Summers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="161" to="175" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Efficiently solving quantified bit-vector formulas</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Wintersteiger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hamadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>De Moura</surname></persName>
		</author>
		<editor>Bloem, R., Sharygina, N.</editor>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="239" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scalable error detection using boolean satisfiability</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)</title>
		<meeting>the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="351" to="363" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
