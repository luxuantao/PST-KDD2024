<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How to Bid the Cloud</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Liang</forename><surname>Zheng</surname></persName>
							<email>liangz@princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University † National University of Singapore ‡ City University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Carlee</forename><surname>Joe-Wong</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University † National University of Singapore ‡ City University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Chee</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University † National University of Singapore ‡ City University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><surname>Tan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University † National University of Singapore ‡ City University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mung</forename><surname>Chiang</surname></persName>
							<email>chiangm@princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University † National University of Singapore ‡ City University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xinyu</forename><surname>Wang</surname></persName>
							<email>xinywang@cityu.edu.hk</email>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University † National University of Singapore ‡ City University of Hong Kong</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">How to Bid the Cloud</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2785956.2787473</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Cloud pricing</term>
					<term>spot instance</term>
					<term>optimization</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Amazon's Elastic Compute Cloud (EC2) uses auctionbased spot pricing to sell spare capacity, allowing users to bid for cloud resources at a highly reduced rate. Amazon sets the spot price dynamically and accepts user bids above this price. Jobs with lower bids (including those already running) are interrupted and must wait for a lower spot price before resuming. Spot pricing thus raises two basic questions: how might the provider set the price, and what prices should users bid? Computing users' bidding strategies is particularly challenging: higher bid prices reduce the probability of, and thus extra time to recover from, interruptions, but may increase users' cost. We address these questions in three steps: (1) modeling the cloud provider's setting of the spot price and matching the model to historically offered prices, (2) deriving optimal bidding strategies for different job requirements and interruption overheads, and (3) adapting these strategies to MapReduce jobs with master and slave nodes having different interruption overheads. We run our strategies on EC2 for a variety of job sizes and instance types, showing that spot pricing reduces user cost by 90% with a modest increase in completion time compared to on-demand pricing.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Cloud providers face an increasingly complicated problem of allocating their resources to different users. These</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Spot Pricing to Shape User Demand</head><p>While many works have considered the operational problem of scheduling jobs within a datacenter <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b31">33]</ref>, most have taken user demands as a given input. Yet user demand can be partially controlled by cloud providers' pricing <ref type="bibr" target="#b5">[6]</ref>. The majority of today's pricing plans for cloud resources are variants on usage-based pricing, in which users pay a static per-unit price (per workload or per hour) to access cloud resources <ref type="bibr" target="#b19">[21]</ref>. Usage-based pricing can affect overall demand levels, but does not even out short-term fluctuations <ref type="bibr" target="#b11">[13]</ref>. To manage these fluctuations in demand for a fixed amount of available datacenter capacity, cloud providers could introduce more flexible pricing plans in which resources are priced according to real-time market demand <ref type="bibr" target="#b38">[40]</ref>. Amazon's Elastic Compute Cloud (EC2) spot pricing <ref type="bibr" target="#b1">[2]</ref> is an example of such a strategy.</p><p>Spot pricing creates an auction-based market for available cloud computing resources. Users can submit bids to the market at any time, using the spot price history to help decide how much to bid (i.e., their bid prices). The cloud provider sets the spot price at regular time intervals, e.g., every five minutes, depending on the number of bids received from users (demand) and how many resources are available (supply) at each time slot. <ref type="foot" target="#foot_0">1</ref> In each time slot, users' bids above the spot price are accepted, and those below it rejected. Running spot instances are terminated if their original bid prices fall below the new spot price, and re-launched only when their bids again exceed the spot price. Given that these interruptions may affect user utility, two natural questions then arise: how might the provider set the spot price, and what prices should users bid ?</p><p>We answer these questions in this work. Unlike most works on spot pricing, which consider only the provider's viewpoint <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b36">38]</ref>, we aim to develop both a reasonable model for how the provider sets the spot prices and optimal bidding strategies for the user. We do not seek to design the auction mechanism used by the provider, only to systematically model and estimate how the provider might set the spot prices before we develop users' optimal bidding strategies. These bidding strategies, in turn, depend not on the specific model of how providers choose the spot prices, but rather on the chosen spot prices themselves. They can thus be applied to other provider pricing models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Research Challenges and Contributions</head><p>We can gain a basic statistical understanding of Amazon's prevailing spot prices by studying the two-month history made available by Amazon <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">15]</ref>. Though these statistics alone are sufficient for the user to deduce a bid price, they also give us some insights into how the provider sets the spot prices. By developing a model that relates the spot price to users' submitted bids, we can better understand the different factors considered by the provider in setting the spot prices.</p><p>Users' job completion times consist of three components: the time to execute the job, idle time while the spot price exceeds the user bid price, and the time to recover from job interruptions. A lower bid price reduces the cost of running the job during its execution time, but can extend the recovery time by inducing more job interruptions. This extra recovery runtime can result in a higher overall job cost, depending on the recovery time from each interruption (i.e., the job's "interruptibility") and the spot prices offered by the provider. Complicating this tradeoff is the fact that user jobs can have long runtimes spanning many changes in the spot price <ref type="bibr" target="#b13">[15]</ref>. Users then face two key challenges: 1) Users must predict the spot prices in order to optimize their bids for a given job, not only in the next time slot but also for all future time slots until the job is completed.</p><p>2) Different jobs may have different degrees of interruptibility. Even within a single user job that requires many computational nodes, e.g., MapReduce's master/slave node model, different nodes can have different interruptibility requirements.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows the basic architecture of a user client and its interaction with the cloud provider. The client calculates its bid price based on two inputs: user inputs on job characteristics and the historical distribution of the spot prices offered by the cloud provider. A price monitor keeps the spot price distribution up to date, and a job monitor at the provider tracks whether the job is ever outbid. The monitor also restarts users' jobs when the spot price falls below their bids.</p><p>We first give a brief overview of related work in Section 2 and relevant background on Amazon's EC2 in Section 3 before developing the following results:</p><p>A framework for understanding spot prices (Section 4): We develop a model to understand how the provider sets the spot price, using it to bound users' quality of service and testing it against empirical data.</p><p>Users' optimal bidding strategies (Section 5): Given a predicted spot price distribution, we derive optimal bidding strategies for different degrees of job interruptibility.</p><p>Adaptation to MapReduce jobs (Section 6): We adapt our bidding strategies for the master and slave nodes of MapReduce jobs and implement our bidding strategy for a MapReduce job.</p><p>Experiment on Amazon EC2 (Section 7): We run our client on a variety of EC2 instances and job types. The proposed bidding strategies substantially lower users' costs in exchange for modestly higher running times.</p><p>Our work considers spot pricing from the point of view of both the cloud provider and users, allowing us to better understand how providers set the spot prices and to develop bidding strategies customized to different user requirements. We discuss some limitations of our work in Section 8 before concluding the paper in Section 9. All proofs can be found in the Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Cloud scheduling and pricing. Many works have considered resource allocation in the cloud from a purely operational perspective <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b31">33]</ref>. Others incorporate pricing considerations, e.g., dynamically allocating cloud resources, so as to maximize the provider's revenue <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b32">34]</ref> or social welfare <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b36">38]</ref>. We construct a similar model but relate it to empirical bid prices and use it to develop bidding strategies for users. Joint userprovider interactions for cloud services are considered in <ref type="bibr" target="#b24">[26]</ref>, but auction-specific works on both provider and user actions are limited to statistical studies of historical spot prices <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">15]</ref>.</p><p>Game theoretic pricing. Spot pricing is a distributed solution to the problem of allocating cloud resources to users, which can be treated as a game between users. Some works have considered the Nash equilibrium of such a pricing game in cloud scenarios <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b30">32]</ref>, although they do not consider optimal bids in a resource auction. More generally, auctions have been proposed as a solution to generic distributed allocation games over multiple time slots <ref type="bibr" target="#b18">[20]</ref>. Users' optimal bidding strategies in such auctions can be quite complex, particularly if multiple users try to optimize their bids at the same time <ref type="bibr" target="#b34">[36]</ref>. We assume in this paper that users' bid optimizations do not significantly affect the distribution of the spot prices, and discuss the consequences of relaxing this assumption in Section 8.</p><p>Auctions and bidding. User bidding strategies for cloud auctions are much less studied than provider strategies. While some works have shown that users can reduce their costs by using spot rather than on-demand instances <ref type="bibr" target="#b26">[28,</ref><ref type="bibr" target="#b35">37]</ref>, they only consider heuristic bidding strategies for single-instance jobs.</p><p>In general, auction frameworks assume that users' bids are determined by their valuations of the auctioned resource. Indeed, many works have studied the problem of designing online auctions to ensure truthful user bids <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">11,</ref><ref type="bibr" target="#b25">27,</ref><ref type="bibr" target="#b27">29]</ref>, including improvements to Amazon's spot pricing <ref type="bibr" target="#b33">[35]</ref>. However, in cloud scenarios, user valuations for the instance in a given time slot depend on (unknown) future spot prices. While users may know their valuations for completing a job, job interruptions will increase the number of instance-time slots required to complete the job. This dependence differentiates our work from other auctions for computing or utility resources, e.g., auctions for smart grid electricity <ref type="bibr" target="#b7">[9]</ref>, secondary spectrum access <ref type="bibr" target="#b14">[16]</ref>, grid computing <ref type="bibr" target="#b17">[19]</ref>, or Internet data <ref type="bibr" target="#b22">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">User Jobs and Instance Types</head><p>Throughout this work, we consider Infrastructure-asa-service (IaaS) cloud services, which are essentially remote virtual machines (VMs) with CPU, memory, and storage resources <ref type="bibr" target="#b1">[2]</ref>. We follow Amazon's terminology and use the term "instance" to denote the use of a single VM. Instances can be divided into several discrete types, each of which may have different resource capacities; users generally submit resource requests, or bids, separately for different instance types.</p><p>The simplest types of user jobs require only one instance and can be served by placing a single bid request for a given instance type. Parallelizable jobs, on the other hand, might require multiple instances running in parallel. The MapReduce framework is a common realization of this job structure. MapReduce divides job functions among a master node and several slave nodes. The master node assigns computational tasks to slave nodes and reschedules the tasks whenever a slave node fails. After all the tasks are finished on the slave nodes, the master node returns a result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">EC2 Pricing</head><p>Amazon offers three types of pricing for instances: reserved, on-demand, and spot instances. Reserved instances guarantee long-term availability (e.g., over a year), and on-demand instances offer shorter-term usage (e.g., one hour on an instance). Both reserved and on-demand instances charge fixed usage-based prices. Spot instances, however, do not guarantee availability; users can use spot instances only if their bids exceed the spot price. Amazon generally updates the spot price every five minutes and encourages users to run interruptible jobs on spot instances. <ref type="foot" target="#foot_1">2</ref>Spot instances allow two types of bids: one-time and persistent. One-time bids are submitted once and then exit the system once they fall below the current spot price. Thus, submitting a one-time bid runs the risk of having the job interrupted without completing. Persistent bids, however, are resubmitted in each time period until the job finishes or is manually terminated by the user. One-time bids allow for better control over bid completion times (e.g., users may default to on-demand instances if the jobs are not completed), while persistent bids allow the user to submit a bid request and then simply wait until the job finishes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CLOUD PROVIDER MODEL</head><p>In this section, we develop an explanatory model for a cloud provider's offered spot prices. Though the model's primary utility for users is in explaining the spot price distribution used in Sections 5 and 6, we also derive some insights into the provider's behavior. In particular, since users' persistent requests are continually reconsidered if not satisfied, the provider might experience unsustainably large numbers of pending bids. We show that the number of pending bids remains bounded under reasonable conditions by formulating a model for a cloud provider to choose the spot prices in Section 4.1 and considering the effects on pending bids in Section 4.2. We validate our model in Section 4.3 by fitting it to two months' history of spot prices offered by Amazon.</p><p>Let us consider a series of discrete time slots t ∈ {1, 2, . . . }. At time slot t, the demand for a spot instance type is L(t), and we use π(t) to denote the spot price at time slot t. We restrict the spot price to not exceed the on-demand price π of the same instance type. We also impose the constraint π(t) ≥ π, where π ≥ 0 represents the provider's marginal cost of running a spot instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Revenue Maximization</head><p>When setting the spot price π(t) in each time slot t, the cloud provider wishes to maximize its revenue π(t)N (t), where N (t) is the number of accepted bids (i.e., the system workload) and each successful bidder is charged only the spot price π(t), regardless of the bid (s)he placed. <ref type="foot" target="#foot_2">3</ref> Other objectives, such as clearing the market, are also possible <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b37">39]</ref>; in fact, some stud-ies have suggested that Amazon does not use revenuemaximizing spot prices <ref type="bibr" target="#b0">[1]</ref>. Thus, we also include a capacity utilization term β log (1 + N (t)), which increases with N (t). This term models the fact that the provider incurs a machine on/off cost for idle spot instances, giving it an incentive to accept more bids. We use a strictly concave function to penalize extremely heavy workloads, which can incur additional capacity costs.</p><p>At each time slot t, the provider chooses the spot price π(t) so as to maximize the sum of the utilization term and revenue, β log 1 + N (t) + π(t)N (t), subject to the constraint that π(t) lie between the minimum and maximum prices (π ≤ π(t) ≤ π). 4 We denote this optimal price by π (t).</p><p>We now formulate the provider's optimization problem by using the probability distribution f p to denote the distribution of bids received by the provider. For instance, if users' bid prices follow a uniform distribution, then f p (x) = 1/(π − π). Defining L(t) as the total number of bids submitted, the number of accepted bids is</p><formula xml:id="formula_0">N (t) = L(t) π−π(t)</formula><p>π−π , or the fraction of submitted bids that exceed the spot price. 5 The provider then maximizes the sum of its revenue and utilization term: maximize π(t)</p><formula xml:id="formula_1">β log 1 + L(t) π − π(t) π − π +π(t)L(t) π − π(t) π − π subject to π ≤ π(t) ≤ π.<label>(1)</label></formula><p>In the rest of the paper, we use a uniform distribution for f p , as is often used to model distributions of user valuations for computing services <ref type="bibr" target="#b28">[30]</ref>.</p><p>We solve (1) to find that the optimal spot price π (t) satisfies</p><formula xml:id="formula_2">L(t) = π − π π − π (t) β π − 2π (t) − 1 .<label>(2)</label></formula><p>We can thus solve for the optimal solution to (1):</p><formula xml:id="formula_3">π (t) = max π, 3 4 π + 1 2 (π − π) 1 L(t) − 1 4 π + 2 π − π 1 L(t) 2 + 8β π − π 1 L(t)</formula><p>.</p><p>(3) More weight on the utilization term (a higher β) leads to a lower spot price and more accepted bids. Since β will generally be small, we assume that β ≤ (L(t) + 4 In practice, we can emphasize the revenue over the utilization term by choosing a small scaling factor β. The provider can keep the number of accepted bids below its available capacity by increasing the minimum spot price π so that fewer bids are accepted. 5 A higher spot price may cause more users to choose the more reliable on-demand instead of spot instances, which in turn affects user demand L(t). Since the spot price is generally much lower than the on-demand price (cf. Section 7), we expect this effect to be negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pending</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>New arrivals</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Running</head><p>Finished 1)(π − 2π) and thus that π (t) &gt; π (the optimal spot price is above the minimum) in the rest of the paper.</p><formula xml:id="formula_4">(1-)N(t) N(t) Terminated (t) N(t) L(t)</formula><p>In the above analysis, we considered user bids in a single time slot. However, bid resubmission may cause the spot price at time t to affect the prices in future time slots. We consider this dependency next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Stable Job Queues</head><p>The dynamics of user requests (i.e., bids for an instance) consist of four distinct states: new arrivals, pending, running and finished, as shown in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>At the beginning of time slot t, there are L(t) bids for the spot resource remaining in the system, and Λ(t) new bid arrivals. After the spot price is determined for this time slot, the N (t) spot requests with the highest bid prices are successfully launched. The new arrivals with lower bid prices are then pended, and some pending requests remain pended until the next time slot.</p><p>After time slot t, we assume that a portion θN (t) of the running instances are finished (including instances that have completed their jobs and terminated instances with one-time requests), while the other (1 − θ)N (t) instances are still running and will be considered together along with the pended bids as bids at the next time slot. If terminated, running instances with persistent requests revert to the pending state; hence, the requests in the pending state come from three sources: i) failed new arrivals, ii) failed pending requests, and iii) terminated running instances. The number of requests in the next time slot, L(t + 1), can thus be written in terms of the number of requests L(t) in the previous time slot, along with Λ(t) new arrivals and θN (t) exiting spot instances:</p><formula xml:id="formula_5">L(t + 1) = L(t) − θN (t) + Λ(t).</formula><p>Note that (1 − θ)N (t) running instances are included in these L(t + 1) requests. All requests compete with one another via bid prices. After solving (1) with L(t + 1), the cloud provider will terminate the running spot instances whose bid prices are lower than the optimal solution π (t + 1), the spot price of the next time slot.</p><p>We assume that the Λ(t) are independent and identically distributed (i.i.d.), following a distribution f Λ with expected value λ and variance σ <ref type="bibr" target="#b32">[34]</ref>. Writing N (t) in terms of the spot price π (t), i.e., N (t) = L(t) π−π (t) π−π , the number of submitted bids in each time slot satisfies</p><formula xml:id="formula_6">L(t + 1) = 1 − θ π − π (t) π − π L(t) + Λ(t).<label>(4)</label></formula><p>Note that 0 ≤ θ ≤ 1 and π ≤ π (t) ≤ π ensure a positive value of L(t + 1). Depending on the value of Λ(t), L(t + 1) may be larger or smaller than L(t).</p><p>If too many user bids are continually re-submitted, the number of submitted bids L(t) might diverge to infinity. To show that such a scenario does not occur, we first define the conditional Lyapunov drift as follows:</p><formula xml:id="formula_7">Δ(t) 1 2 L 2 (t + 1) − 1 2 L 2 (t),<label>(5)</label></formula><p>or the change in the Lyapunov function 1 2 L 2 (t) over one time slot. Taking the conditional expectation, we have an upper bound on the Lyapunov drift (5):</p><p>Proposition 1. Suppose Λ(t) follows a distribution with expected value λ and variance σ, and suppose that the spot prices π (t) are chosen according to <ref type="bibr" target="#b2">(3)</ref>. Then the conditional expectation of the Lyapunov drift is up-</p><formula xml:id="formula_8">per bounded: E Δ(t) | L(t) ≤ (π − π)λ 2 /(2θπ) + σ/2 − L(t), where = θλπ 4(π−π) .</formula><p>Proposition 1 implies that when ( <ref type="formula" target="#formula_1">1</ref>) is used to compute the spot price, the queuing system is stable in the sense that the time-averaged queue size at any time t is uniformly bounded <ref type="bibr" target="#b21">[23]</ref>. In fact, the number of requests can ultimately reach an equilibrium:</p><p>Proposition 2. The queue sizes of consecutive time slots are in equilibrium, i.e., L(t+1) = L(t), if and only if the optimal spot prices π (t) satisfy</p><formula xml:id="formula_9">π (t) = h Λ(t) = 1 2 π − β 1 + 1 θ Λ(t) .<label>(6)</label></formula><p>We observe from (6) that π (t) is only in terms of the request arrivals at that time slot, so π (t), like Λ(t), is i.i.d. at the equilibrium. Using this result, we can derive the probability density function (PDF) of the spot price in terms of f Λ , the distribution (i.e., PDF) of Λ(t).</p><p>Proposition 3. The probability density function of the spot price is given by:</p><formula xml:id="formula_10">f π (π) f Λ (h −1 (π)), (<label>7</label></formula><formula xml:id="formula_11">)</formula><formula xml:id="formula_12">where h −1 (π) = θ β π−2π − 1 is the inverse function of the function given in (6).</formula><p>We can thus use the distribution of Λ(t) at different time slots, f Λ , to derive the distribution of the spot prices, f π . Since we do not know the distribution of the bid arrivals, in the next section we instead test different distributions and compare their spot price predictions to the empirically observed spot prices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Validation from Historical Spot Prices</head><p>We collected the spot price data for four instance types over August 14 -October 13, 2014, in the US Eastern region; we limit ourselves to a two-month dataset since Amazon only provides user access to spot price history for the previous two months. The PDF of these prices is shown by the blue bars in Figure <ref type="figure" target="#fig_3">3</ref>. We observe that they approximately follow a power-law or exponential pattern, indicating that the arrival process Λ(t) is non-Poisson. <ref type="foot" target="#foot_3">6</ref> Furthermore, the shape of the PDFs across different instance types is consistent, though the spot prices are different, agreeing with <ref type="bibr" target="#b0">[1]</ref>'s findings.</p><p>We next estimate the spot price PDF with ( <ref type="formula" target="#formula_9">6</ref>) and (7) by assuming Pareto and exponential distributions for Λ(t); other distributions could be used in a similar manner. We verify that the spot price distribution does not vary significantly over the day, e.g., due to more jobs submitted during the day, indicating that Λ(t) can reasonably be assumed i.i.d. as in Section 4.2. The Kolmogorov-Smirnov test indicates that the distributions of the prices during the daytime and nighttime are similar with p-value &gt; 0.01.</p><p>Pareto distribution. The PDF of a Pareto distribution is</p><formula xml:id="formula_13">f Λ (Λ) = αΛ α min Λ α+1 , for Λ ≥ Λ min ,</formula><p>where Λ min = θ β π−2π − 1 is derived from the monotonic relation between π (t) and Λ(t) in <ref type="bibr" target="#b5">(6)</ref>.</p><p>Exponential distribution. The PDF of an exponential distribution is</p><formula xml:id="formula_14">f Λ (Λ) = 1 η e − 1 η Λ , for Λ ≥ 0.</formula><p>We show the distribution fits in Figure <ref type="figure" target="#fig_3">3</ref>; the η, α, β, and θ parameters were chosen to minimize the leastsquares divergence between the estimated and empirical PDFs. We use the same β and θ values for each instance type since these parameters do not depend on the distribution of Λ. We observe that the two distributions fit the empirical data well, with a mean-squared error less than 10 −6 . The small θ values indicate that few instances finish in each time slot due to the long running times of most jobs. For all instance types, the fitted Pareto and exponential distributions have finite mean and variance (α &gt; 1, η &gt; 0). Thus, the conditions in Proposition 1 hold and the system is stable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">USER BIDDING STRATEGIES</head><p>We now derive users' bidding strategies for jobs running on a single instance, using the spot price PDF from Section 4 to predict future spot prices.<ref type="foot" target="#foot_4">7</ref> Though time series forecasting may be used instead, we note that users' job runtimes generally exceed one time slot, requiring predictions far in advance. Since the spot prices' autocorrelation drops off rapidly with a longer    lag time <ref type="bibr" target="#b0">[1]</ref>, such predictions are likely to be difficult. We discuss this point further in Section 8.</p><p>In this section, we first consider one-time requests (Section 5.1) and then persistent requests (Section 5.2) for a single instance; we consider jobs requiring multiple parallel instances in Section 6. We assume that users wish to minimize the cost of running their jobs. Users thus face a tradeoff between bidding lower prices and experiencing more interruptions, which lead to a longer runtime and potentially higher cost. We obtain the optimal bid prices by minimizing the user's cost subject to job interruptibility constraints (cf. Section 8). <ref type="foot" target="#foot_5">8</ref> As in Section 4, we consider a series of discrete time slots t and suppose the spot prices π(t) = h Λ(t) , t = 0, 1, . . . are i.i.d. as in Proposition 2. We use p to denote the user's bid price and F π to denote the cumulative distribution function of each spot price π(t), corresponding to the PDF f π in (7): F π (p) gives the probability that p ≥ π(t), i.e., the user's bid is accepted.</p><p>We summarize our model's notation in Table <ref type="table" target="#tab_1">1</ref>. Each job is characterized by its execution time t s , or time required to complete without interruptions. We use T to denote the job's total completion time, i.e., the length of time between its submission and the time it finishes and exits the system. Since jobs with persistent requests may be interrupted, we suppose that persistent jobs are configured to save their data to a separate volume once interrupted and recover it upon resuming. Writing and transferring this data introduces a delay of t r seconds per interruption. All prices are assumed to be in units of instance/hour, and all times given in units of hours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">One-time Requests</head><p>Since one-time requests are terminated as soon as the bid price falls below the spot price, we assume that users wish to minimize their expected job cost, subject to the constraint that jobs are not interrupted.</p><p>Job non-interruptibility. We first find the expected amount of time that a job will continue running without being interrupted:</p><formula xml:id="formula_15">t k ∞ i=1 iF π (p) i−1 1 − F π (p) = t k 1 − F π (p) . (<label>8</label></formula><formula xml:id="formula_16">)</formula><p>Here the F π (p) terms represent the probability that p ≥ π(t), i.e., the request continues to run, and 1−F π (p) the probability that the job will be terminated. We thus find that t s ≤ t k / (1 − F π (p)): the expected amount of time that a job will keep running must exceed its execution time.</p><p>The optimal price. To find the expected cost of a job with a one-time request, we need to find the expected price that a user must pay to use an instance in each time slot. If a user's bid at price p is accepted, this expected price is simply the expected spot price, or the expected value of all possible spot prices that are less than or equal to p:</p><formula xml:id="formula_17">E(π | π ≤ p) = p π xf π (x)dx p π f π (x)dx = p π xf π (x)dx F π (p) ,<label>(9)</label></formula><p>which monotonically increases with p (cf. Proposition 4's proof in the Appendix). Thus, as we would intuitively expect, the user must pay more as his/her bid price increases. The user's expected cost for this job is then the expected spot price, multiplied by the number of time slots it takes for the job to complete. Hence, we have the following cost minimization problem with </p><formula xml:id="formula_18">subject to Φ so (p) ≤ t s π, t s ≤ t k (1−Fπ(p)) , π ≤ p ≤ π. (<label>10</label></formula><p>) Since the expected spot price is monotonically increasing in the bid price, the user can minimize his or her expected cost by choosing the lowest possible bid price that satisfies the constraint that the job completes before being terminated: Proposition 4. The optimal bid price for a onetime request is</p><formula xml:id="formula_19">p = max π, F −1 π 1 − t k t s .<label>(11)</label></formula><p>We essentially wish to bid at the appropriate percentile of the spot price distribution F π . As we would expect, the bid price increases as the number of time slots required to complete the job, t s /t k , increases: the job then needs to run for more consecutive time slots, which becomes more likely with a higher bid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Persistent Requests</head><p>We now consider a job that places a persistent spot instance request. We begin by finding the total time that the job runs on the system, given a bid price, and then briefly discuss the implications of a job's interruptibility before deriving the user's optimal bid price.</p><p>Job running time. A job's total completion time T comprises two types of time slots: the running time, in which the job's bid price exceeds the spot price and the job actually runs on the instance, and the idle time. For a bid price p, the job's expected running time is T F π (p) (recall that F π (p) denotes the probability that the bid price p ≥ π(t), the spot price), and the idle time is then T (1−F π (p)). The running time can be further split into the execution time, t s , and the additional running time required to recover from interruptions. We illustrate the job completion time in Figure <ref type="figure" target="#fig_4">4</ref>, in which the bid price of p = 0.0323 is represented by an orange dashed line. The grey double-arrowed line represents the total running time. Since the job is interrupted twice, the total recovery time is 2t r . Thus, for this example, we have T F π (0.0323) = 2t r + t s .</p><p>To determine the total recovery time, we want to find the expected number of interruptions, i.e., times t in which the job runs on the system but was idle in the previous time slot (p ≥ π(t), p &lt; π(t−1)). Note that the number of interruptions equals half of the total number of times the job's state changes between running and idle: each interruption requires both an idle-to-running and running-to-idle transition. We can thus find the expected total number of transitions and divide it by two. To do so, we define I π π(t) as an indicator function:</p><formula xml:id="formula_20">I π π(t) = 1 if p ≥ π(t); otherwise, I π π(t) = 0. We then consider I π π(t) − I π π(t + 1)</formula><p>2 , which equals</p><formula xml:id="formula_21">1 if I π π(t) = I π π(t + 1) (i.</formula><p>e., a transition happens) and 0 otherwise. The number of idle-to-running transitions in T /t k time slots is then</p><formula xml:id="formula_22">1 2 T /t k −1 k=0 I π π(t) − I π π(t + 1) 2 .</formula><p>We take expectation to obtain</p><formula xml:id="formula_23">E ⎛ ⎝ 1 2 T /t k −1 k=0 I π π(t) − I π π(t + 1) 2 ⎞ ⎠ (a) = T t k E I π π(t) − E I π π(t) I π π(t + 1) = T t k F π (p) 1 − F π (p) ,<label>(12)</label></formula><p>where (a) is due to I π π(t) 2 = I π π(t) since the value of I π π(t) is either 1 or 0. We now write the expected running time of the job as the sum of the recovery and execution times:</p><formula xml:id="formula_24">T F π (p) = T t k F π (p) 1 − F π (p) − 1 t r + t s .</formula><p>Simplifying the terms, the running time becomes</p><formula xml:id="formula_25">T F π (p) = t s − t r 1 − tr t k 1 − F π (p) ,<label>(13)</label></formula><p>which decreases with p. As the bid price p increases, the job is less likely to be interrupted and will therefore have a shorter expected running time. Job interruptibility. We can use the expected running time <ref type="bibr" target="#b11">(13)</ref> to observe the effect of the recovery time parameter, t r , on a job's feasibility for spot instances. Intuitively, spot instances are more effective for more "interruptible" jobs that can quickly recover from interruptions. In fact, a job's running time is finite only if the recovery time is sufficiently small:</p><formula xml:id="formula_26">t r &lt; t k 1 − F π (p) . (<label>14</label></formula><formula xml:id="formula_27">)</formula><p>The result in ( <ref type="formula" target="#formula_26">14</ref>) can be obtained by requiring the denominator in (13) to be positive. We note that the upper bound to t r is exactly the expected running time of a job without interruptions (cf. ( <ref type="formula" target="#formula_15">8</ref>)): intuitively, the time to recover from an interruption should be smaller than the expected time on an instance between job in-terruptions. We take ( <ref type="formula" target="#formula_26">14</ref>) as a constraint on the bid price: if the job recovery time is high, the user should bid at a higher bid price in order to ensure that the job can complete. However, if the job recovery time is less than one time slot length, t r &lt; min p t k 1−Fπ(p) = t k , and a spot instance is feasible at any price.</p><p>The optimal bid price. We can now multiply the expected running time <ref type="bibr" target="#b11">(13)</ref> with the expected spot price <ref type="bibr" target="#b7">(9)</ref> to find that the cost of a job with a persistent request is Φ sp (p) = T F π (p)E(π | π ≤ p). The user's optimal bid price then solves the optimization problem</p><formula xml:id="formula_28">minimize p Φ sp (p) = ts−tr 1− tr t k 1−Fπ (p) p π xfπ(x)dx Fπ(p) subject to Φ sp (p) ≤ t s π, t r &lt; t k 1−Fπ(p) , π ≤ p ≤ π,<label>(15)</label></formula><p>where the first constraint ensures that the cost of running the spot instance is lower than the cost of running the job on an on-demand instance, and the second constraint ensures that the job is sufficiently interruptible. We use p to denote the optimal bid price to <ref type="bibr" target="#b13">(15)</ref>.</p><p>We now observe that the expected running time in <ref type="bibr" target="#b11">(13)</ref> decreases with the bid price, while the expected spot price increases with the bid price. We find that the expected cost Φ sp (p) first decreases and then increases with the bid price p, thus allowing us to solve for the optimal bid price p : Proposition 5. If the probability density function of the spot price monotonically decreases, i.e., F π (p) is concave, the optimal bid price solving <ref type="bibr" target="#b13">(15)</ref> </p><formula xml:id="formula_29">is p = ψ −1 t k t r − 1 ,<label>(16)</label></formula><p>where ψ −1 (•) is the inverse function of</p><formula xml:id="formula_30">ψ(p) = F π (p) p π xf (x)dx p π (p − x)f (x)dx − 1 .</formula><p>We can observe from ( <ref type="formula" target="#formula_29">16</ref>) that the optimal bid price does not depend on the execution time t s : the cost is instead determined by the number of time slots needed for each recovery, t r /t k . While the execution time is fixed, a longer recovery time lengthens the total running time and thus the job cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">BIDDING FOR MAPREDUCE JOBS</head><p>We now adapt Section 5's bidding strategies for single instances to parallelized MapReduce jobs, in which users bid for multiple instances at the same time. We first consider running only the slave nodes on spot instances and then consider running the full job (i.e., both master and slave nodes) on spot instances. <ref type="foot" target="#foot_6">9</ref> Though the job structure introduces an additional requirement on the master node's running time-the master node should keep running as long as the slave nodes are running-we show that this condition does not change the optimal bid for the master node as long as the job is sufficiently parallelized (i.e., multiple slave nodes run in parallel for a short amount of time).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Bidding for Slave Nodes Only</head><p>We first consider running only the slave nodes of a MapReduce job on several spot instances in parallel. We suppose that the job is split into M sub-jobs of equal size, each corresponding to one instance request. We now wish to calculate the optimal (i.e., cost-minimizing) bid prices for these sub-jobs; since we assume that all sub-jobs are bidding for the same type of spot instance, the bid price should be the same for all of them. We again find the total cost by multiplying the expected running time of the job by the expected spot price.</p><p>To find a job's expected running time, we denote each sub-job i's total time in the system as T i . Since splitting a job results in additional overhead, e.g., due to message passing between the sub-jobs, we use t o to represent a constant additional overhead time from splitting the job. <ref type="foot" target="#foot_7">10</ref> Then the total running time satisfies:</p><formula xml:id="formula_31">M i=1 T i F π (p) = M i=1 T i F π (p) 1 − F π (p) t k − 1 t r +t s +t o ,</formula><p>i.e., it is the sum of the recovery, execution, and overhead times. Hence, we can extend the result for a single persistent bid in <ref type="bibr" target="#b11">(13)</ref> as</p><formula xml:id="formula_32">M i=1 T i F π (p) = t s + t o − M t r 1 − tr t k 1 − F π (p) . (<label>17</label></formula><formula xml:id="formula_33">)</formula><p>Since all of the sub-jobs run simultaneously, the overall time of the parallelized job execution is max i=1,...,M</p><formula xml:id="formula_34">T i F π (p).</formula><p>All of the M sub-jobs are of equal size, so max i=1,...,M</p><formula xml:id="formula_35">T i F π (p) = t s + t o − M t r M 1 − tr t k 1 − F π (p) . (<label>18</label></formula><formula xml:id="formula_36">)</formula><p>Users can minimize this cost by choosing the optimal number of slave nodes, M . Although the job is split into smaller pieces, the overall running time max i=1,...,M</p><formula xml:id="formula_37">T i F π (p)</formula><p>is larger than t s /M , or the running time without interruptions or overhead. Thus, distributing the job across M instances shortens the completion time as compared to a single instance only if the overhead time is sufficiently small. Comparing the completion times in both cases, we find that using multiple instances shortens the completion time if</p><formula xml:id="formula_38">t o &lt; (M − 1)t k /(1 − F π (p)).</formula><p>As in Section 5, the expected cost of running a job on M simultaneous instances is the sum of each instance's expected running time, multiplied by the expected spot price:</p><formula xml:id="formula_39">Φ mp = M i=1 T i F π (p)E(π | π ≤ p).</formula><p>The user then minimizes this cost by solving the following optimization problem:</p><formula xml:id="formula_40">minimize p Φ mp (p) = ts+to−Mtr 1− tr t k 1−Fπ (p) p π xfπ(x)dx Fπ(p) subject to Φ mp (p) ≤ t s π, π ≤ p ≤ π, (<label>19</label></formula><formula xml:id="formula_41">)</formula><p>where the first constraint ensures that the cost is lower than that of running the job on an on-demand instance. Comparing <ref type="bibr" target="#b17">(19)</ref> to bidding for a single persistent request in <ref type="bibr" target="#b13">(15)</ref>, we see that <ref type="bibr" target="#b17">(19)</ref> can be solved similarly to <ref type="bibr" target="#b13">(15)</ref> in Proposition 5.</p><p>By comparing the costs for multiple bids and for a single bid at the optimal bid prices, we find that when the overhead time is sufficiently small (t o &lt; (M − 1)t r ), bidding for multiple spot instances can both lower the cost and shorten the job's overall running time. In contrast, running the job on an on-demand instance will reduce the running time but increase the cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Bidding for Master and Slave Nodes</head><p>Running a MapReduce job entirely on spot instances requires us to treat master and slave nodes separately; for instance, we might bid on different instance types for the master and slave nodes, since the slave nodes will likely have higher computing requirements. We thus develop two separate bidding strategies: 1) Master node: Since the master node has to be available at all times to manage slave node failures and to periodically check the status of tasks at the slave nodes, we do not allow any interruptions for the master node. We thus place a one-time request for a single spot instance, as in Section 5.1.</p><p>2) Slave nodes: MapReduce requires many slave nodes to process large jobs, but allows slave nodes to be interrupted. Thus, we place a persistent request for each slave node using the strategy in Section 6.1. The bid prices for the slave nodes must be determined jointly with that of the master node, since the master node's running time should exceed the slave nodes'. We note from Section 6.1 that if many simultaneous bids are submitted, the slave nodes' running time will decrease, shortening the required master node running time.</p><p>We can formally describe these strategies in the following optimization problem: where p m and p v denote the bid prices of the master node and slave nodes respectively, and F m π (•) and F v π (•) denote the spot prices' cumulative distribution functions for the master and slave node instance types. The first constraint in <ref type="bibr" target="#b18">(20)</ref> ensures that the master node runs longer than any of the slave nodes (cf. ( <ref type="formula" target="#formula_15">8</ref>) and ( <ref type="formula" target="#formula_35">18</ref>)), where the righthand side of the inequality represents the worst-case completion time of the M parallel sub-jobs. We use p m and p v to denote the optimal bid prices for (20)'s optimization problem.</p><formula xml:id="formula_42">minimize pv ,pm Φ so (p m ) + Φ mp (p v ) subject to t k 1−F m π (pm) ≥ 1 F v π (pv ) ts+to−Mtr 1− tr t k 1−F v π (pv ) − (M−1)t k 1−F v π (pv) , π ≤ p v ≤ π, π ≤ p m ≤ π,<label>(20)</label></formula><p>We can solve (20) by noting that, aside from the first constraint, p m and p v are independent variables. Thus, we can set their optimal values p m and p v respectively as the optimal bid prices for a one-time single instance request (Proposition 4) and for multiple persistent requests (as in <ref type="bibr" target="#b17">(19)</ref>). The first constraint is satisfied if the user submits sufficiently many simultaneous requests for the slave nodes. In practice, this minimum number of nodes, which we denote as M , can be as low as 3 or 4, as we show in Section 7's experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTAL RESULTS</head><p>In this section, we first examine the optimal bid prices derived in Section 5 on Amazon EC2 spot instances. By comparing the price charged per hour, total job completion time and final cost, we illustrate the tradeoff of using different bidding strategies. We then run a MapReduce example on spot instances to further highlight that our proposed bidding strategy in Section 6 is adaptable to parallelized MapReduce jobs and can substantially lower their costs. Table <ref type="table" target="#tab_2">2</ref> summarizes the instance types that we use in our experiments. The m3, r3, and c3 prefixes denote balanced, memory-optimized, and compute-optimized instances respectively. We test a variety of instance types and sizes and repeat each experiment ten times for each instance type; all performance graphs are shown as averages. <ref type="foot" target="#foot_8">11</ref> We do not include the runtime of the bid price calculations in our measurements since it is much smaller than one minute, and can thus be easily run within one five-minute time slot. For example, the bid price calculations for the c3.4xlarge instance with around 1MB of spot price history take 11.305 seconds for a one-time and 4.365 seconds for a persistent bid on a standard laptop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Single-Instance Bids</head><p>Parameter setting: We consider a job that needs one hour (i.e., t s = 1h) to be executed without interruption. The optimal bid prices of five Amazon spot instances (r3.xlarge, r3.2xlarge, r3.4xlarge, c3.4xlarge and c3.8xlarge) are listed in Table <ref type="table">3</ref> for a onetime request and persistent requests with recovery times t r = 10s and t r = 30s. We used the spot price history for the two months immediately prior to the experiments to calculate these prices.</p><p>Experiment setup: To simulate an exact one hour running time of a spot instance, we created an Amazon Machine Image (AMI), where a shell script was added to /etc/rc.local so that a one-hour count-down program will run once the instance is launched using this AMI. In addition, this program writes instance launched time as a sequence of items into Amazon DynamoDB, from which we can obtain the instance status (first run or restarted from interruption) and simulate a recovery time if the instance is interrupted. We then placed all spot requests using this AMI.</p><p>Results: We used the optimal bid prices for one-time requests (Table <ref type="table">3</ref>) to bid the associated spot instance at random times of the day. None of our experiments were interrupted, verifying that our bidding strategy for one-time requests can ensure reliability. Our bills show that this bidding strategy can reduce user costs by up to 91% compared to running the job on an on-demand instance. Figure <ref type="figure" target="#fig_6">5</ref> compares the cost of one-time requests on spot instances to that of on-demand instances for the instance types in Table <ref type="table">3</ref>. We also compare the actual costs (with actual spot price π) to the expected cost from our analytical model; the analytical predictions closely match the experimental results.</p><p>We additionally compare against a heuristic called the best offline price in retrospect (shown as p in Table <ref type="table">3</ref> and the grey bars in Figure <ref type="figure" target="#fig_6">5</ref>), in which we numerically search the spot price history of the last 10 hours for the minimal price that consistently exceeds the spot prices for one hour. This retrospective price is lower than the actual bid price in some cases, meaning the one-time spot instance would have been terminated if we had bid using this price: 10 hours of history is insufficient to predict the future prices.</p><p>We now use the results of the one-time requests for each instance type as a baseline to illustrate that users can further lower their cost in exchange for longer completion times by placing persistent requests. In Figure <ref type="figure">6</ref>, we plot the percentage difference in performance between the persistent and one-time bids.</p><p>Figure <ref type="figure">6</ref>(a) shows the percentage difference in price between the one-time and persistent requests for the five instance types. The negative values in this figure illustrate a lower optimal bid price for persistent requests: persistent requests can be interrupted. As we would expect from Section 5's analysis, longer recovery times (t r = 30s rather than 10s) yield higher bid prices, since   <ref type="table">3</ref>). a higher bid price ensures that the job has sufficient time to execute after recovering from interruptions.</p><p>Conversely, as shown in Figure <ref type="figure">6</ref>(b), the completion time of a one-hour job with a persistent request is longer than that of a one-time request. The difference in these completion times includes both the recovery time after the instance is interrupted and the idle time during which the user's bid price is lower than the spot price. Interestingly, the job with longer recovery time t r has a shorter completion time, though it is still longer than the completion time with a one-time request. We can observe from Table <ref type="table">3</ref> that a longer recovery time leads to a higher optimal bid price, which can consequently increase the likelihood of satisfying the spot price and lead to less idle time.</p><p>As shown in Figures <ref type="figure">6(a</ref>) and 6(b), the price charged per hour is slightly lower, but the completion time is longer for the persistent requests compared to the onetime requests. This makes the final cost underdetermined: Figure <ref type="figure">6</ref>(c) demonstrates that persistent bids lead to lower overall costs. Smaller recovery times (t r = 10s versus 30s) have higher completion times but yield lower costs due to their lower bid prices (the higher completion time is mostly due to more idle time, for which the user is not charged, rather than extra time running on the instance). Thus, persistent requests can reduce user cost but lengthen the job completion time.</p><p>We also compare against simply bidding the 90th percentile spot price. Compared to our optimal prices, bidding the (larger) 90th percentile price yields a much smaller decrease in cost, despite slightly higher bid prices in Figure <ref type="figure">6</ref>(a) and lower completion times in Figure <ref type="figure">6(b)</ref>. The jobs running on r3.4xlarge with recovery time t r = 30s instead have a longer completion time and lower bid price, but higher cost, with the 90th percentile spot price. This comparison is consistent with the fact that our bid prices are chosen to minimize users' costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">MapReduce Jobs</head><p>We implemented our optimal bidding strategy to run Hadoop MapReduce jobs on the Common Crawl Dataset [7] using Amazon Elastic MapReduce (EMR). This dataset, which is hosted on Amazon's Simple Storage Service, maintains an open repository of web crawl data that is accessible to the public for free. In this experiment, we ran the well-known "Common Crawl Word Count" example that counts the frequency of words appearing on the Common Crawl Corpus.</p><p>Parameter setting: We consider a word count job with recovery time t r = 30s and overhead time t o = 60s. Using the bidding strategy proposed in Section 6, we list in Table <ref type="table">4</ref> the optimal bid prices and the number of slave nodes for five client settings with different instance types for the master node and the slave nodes.</p><p>Experiment setup: We placed a one-time request for a single spot instance for the master node and persistent requests for multiple spot instances for the slave nodes. Since the master node just distributes the raw data and tracks the status of each task, it does not require a high-performance instance; we therefore bid on instances with better CPU performance for the slave nodes.</p><p>Results: We compare the completion time and cost of running MapReduce jobs on on-demand and spot instances for the five client settings. We use the optimal bid prices listed in Table <ref type="table">4</ref> to place the spot instance bids. Using the on-demand instance as a baseline, our bills from Amazon show that the bidding strategy for MapReduce jobs can reduce up to 92.6% of user cost with just a 14.9% increase of completion time.</p><p>In Figure <ref type="figure" target="#fig_8">7</ref>, we show the completion time and the cost of the five client settings for on-demand and spot instances. Again, our experimental results closely approximate the analytical results from our model. As we would expect, the job completion time is longer on the spot instances than on the on-demand instances (Figure <ref type="figure" target="#fig_8">7(a)</ref>), while the costs of the jobs running on the spot instances are much lower than those on the on-demand instances (Figure <ref type="figure" target="#fig_8">7(b)</ref>).</p><p>In Table <ref type="table">4</ref>, we break down the actual costs of the master and slave nodes for each client setting of the MapReduce job. The cost of the master node is 10% to 25% of the slave node cost, indicating that users may wish to pay a higher spot price for the master node: this price does not significantly affect the overall cost, and helps ensure that the master node is not interrupted.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">DISCUSSION</head><p>Like all work based on analytical models, our work has some limitations. We discuss five important ones here and suggest ways to address them in future work.</p><p>Provider objectives. We have assumed that the cloud provider optimizes the sum of a concave utilization term and its revenue, where the concave shape of the utilization term is due to the cost of running large numbers of instances while maintaining users' qualityof-service. We could more explicitly account for user satisfaction by taking the social welfare to be the provider's objective function <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b36">38]</ref>. While our current formulation matches well with the observed spot prices, including other factors in the provider's spot price optimization problem may shed more light on the provider's behavior. We emphasize, however, that our bidding strategies depend only on the spot prices, not on the provider's objectives or optimization problem.</p><p>Temporal correlations. We assume i.i.d. job arrivals that induce i.i.d. spot prices at the equilibrium. However, empirical studies have found temporal correlation in cloud workloads, possibly inducing positive temporal correlation in the spot prices <ref type="bibr" target="#b10">[12]</ref>. In fact, a study of the spot prices in 2010 shows the presence of limited autocorrelation for consecutive time slots <ref type="bibr" target="#b0">[1]</ref>. Incorporating these correlations into users' spot price predictions may improve their bidding strategies and outcomes: this correlation would likely reduce the degree to which the spot price changes in consecutive time slots. Thus, the user's job would be interrupted less often, leading to lower job running times and costs.</p><p>Risk-averseness. We suppose that users choose their bid prices so as to minimize their expected costs, subject to constraints on the expected runtimes. Risk-averse users may also wish to minimize the variance in costs and runtimes, so as to ensure that particularly bad outcomes do not occur. For example, we might choose the bid price so as to minimize the expected cost subject to an upper bound on the cost variance. Other users might allow their jobs' completion time to have a small probability of exceeding a job deadline. Instead of bounding the expected completion time, we could constrain the user's bid price so that the probability of exceeding this deadline is lower than a given small threshold.</p><p>Task dependence. Some tasks within a job cannot proceed before other tasks have been completed. While we do not account for such dependent tasks in our model, we can in practice bid on these tasks only after the tasks that they depend on have been completed. Thus, we will not bid on idle tasks that are waiting for other tasks to finish.</p><p>Collective user behavior. The bidding strategies that we have developed in Sections 5 and 6 assume that an individual user's bid price will not measurably affect the provider's spot price. While our experiments in Section 7 show that this assumption holds for a single user, it may not hold if multiple users begin to optimize their bidding strategies, which might affect the distribution of the submitted bids. To study this scenario, we can assume that users with a distribution of jobs optimize their bids and use Section 4's model to derive the effect on the provider's offered spot price.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>Spot pricing opens up an auction-based market in which cloud providers can dynamically provision data center resources to meet user demand and users can develop bidding strategies that lower their cloud resource costs. In this work we first consider providers' setting of the spot prices, developing an optimization model for the provider and comparing its results to observed spot prices. We then answer the question of how users should bid for cloud resources. Since spot instances do not guarantee their availability, we consider the tradeoff between bidding higher prices to avoid interruptions (for one-time requests) and bidding lower prices to save money (for persistent requests).</p><p>We adapt these bidding strategies to MapReduce jobs with master and slave nodes. Finally, we run our bidding client on Amazon EC2 to verify that our analytical results accurately approximate the real-time experimental results. Our bidding strategies can reduce users' costs by around 90% on a variety of instance types, with modest increases in the job completion times.</p><p>Spot pricing has been offered by Amazon for many years, yet the heavy-tailed spot price distributions that we observe suggest that few users bid for spot instances. We thus conjecture that many users are concerned by the possibility of too many job interruptions. Our paper suggests that these concerns might be misplaced: by tailoring their bids to their jobs' interruption constraints, users can save a substantial amount of money with spot instances without excessive job interruption. Proof. We first prove that ( <ref type="formula" target="#formula_9">6</ref>) is a necessary condition for L(t + 1) = L(t). We rewrite (4) as</p><formula xml:id="formula_43">L(t) = π − π θ(π − π (t)) Λ(t).<label>(21)</label></formula><p>Solving the system of equations ( <ref type="formula" target="#formula_2">2</ref>) and ( <ref type="formula" target="#formula_43">21</ref>) yields <ref type="bibr" target="#b5">(6)</ref>.</p><p>We then prove that ( <ref type="formula" target="#formula_9">6</ref>) is a sufficient condition for L(t + 1) = L(t). From (4), we can derive L(t + 1) − L(t) Combining the fact that g(π) = −πf π (π) + πF π (π) = 0, the nonnegativity and monotonic increasing of g(p) lead to ∂Φ so (p)/∂p &gt; 0. Therefore, Φ so (p) also increases with p. Minimizing Φ so (p) is equivalent to finding the minimum p in its feasible set. From t k / 1 − F π (p) , we have p ≥ F −1 π 1 − t k ts due to the monotonic property of F π (p). Thus, the minimum of the feasible set is the larger one of π and F −1 π 1 − t k ts .</p><p>Proof of Proposition 5.</p><p>Proof. By taking the first-order derivative of Φ(p) in <ref type="bibr" target="#b13">(15)</ref>  <ref type="figure" target="#fig_3">3</ref>), F π (p) is concave and F π (p)− pf π (p) ≥ 0. We then have ∂g(p)/∂p ≥ 0. Thus, g(p) monotonically increases with p, so is ∂Φ sp (p)/∂p. By the fact that g(π) &lt; 0 and g(π) &gt; 0, ∂Φ sp (p)/∂p increases monotonically from a negative value to a positive value, i.e., Φ sp (p) first decreases and then increases with p. Hence, Φ sp (p) is minimized when ∂Φ sp (p)/∂p = 0, i.e., g(p) = 0. Letting g(p) = 0, we thus deduce which leads to <ref type="bibr" target="#b14">(16)</ref>. In addition, Φ(p ) &lt; Φ(π) = (t s − t r )E(π | π ≤ π) ≤ t s π so the constraints in ( <ref type="formula" target="#formula_28">15</ref>) are satisfied at optimality.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Client and cloud provider interaction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: State transitions of spot instances. The solid and dashed arrow lines respectively represent the transitions at the start of the current and next time slots.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(d) m1.xlarge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Fitting the probability density function of Amazon spot prices in the US Eastern region by assuming Pareto and exponential distributions for Λ(t). The fitted parameter values are (β, θ, α, η) = (0.6, 0.02, 5, 0.00013), 1.2, 0.02, 8, 7.1 × 10 −5 , (0.3, 0.02, 9.5, 0.000108), and (0.3, 0.02, 5.2, 0.000204) for (a), (b), (c), and (d) respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An example of job running times for the spot prices of an r3.xlarge-type instance in the US Eastern region on September 09, 2014. a completion time constraint: minimize p</figDesc><graphic url="image-1.png" coords="7,59.21,90.44,245.53,92.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: One-time spot instance requests substantially lower user cost compared to on-demand instances (ondemand and bid prices are as in Table3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>MapReduce jobs can save about 90% of user cost but have a 15% longer completion time on spot compared to on-demand instances.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>L(t), where (a) is due to π(t) ≤ 1 2 π, (b) is due to E(Λ 2 (t)) = Var(Λ(t)) + E(Λ(t))2 and the equality in (c) holds when L(t) = π−π θ π λ. Proof of Proposition 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>− 1 +</head><label>1</label><figDesc>Λ(t) = 0, where (a) and (b) are obtained by respectively substituting (2) and<ref type="bibr" target="#b5">(6)</ref>. Thus, L(t + 1) = L(t).Proof of Proposition 4.Proof. By taking the first-order derivative of Φ so (p) in the objective of (10), we have∂Φ so (p)/∂p = ts (Fπ(p)) 2 f π (p) − p π xf π (x)dx + pF π (p) .By letting g(p) = − p π xf π (x)dx + pF π (p), we have ∂g(p)/∂p = F π (p) &gt; 0. So g(p) increases with p.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>2 ( 1</head><label>21</label><figDesc>x)dx = p (1 − tr t k )F π (p) + tr t k F π (p) − tr t k ) + 2 tr t k F π (p) ⇒ ψ(p) = F π (p)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Key terms and symbols.</figDesc><table><row><cell cols="2">Symbol Definition</cell></row><row><cell>p</cell><cell>User bid price</cell></row><row><cell>π</cell><cell>Spot price</cell></row><row><cell>π</cell><cell>On-demand price</cell></row><row><cell>π</cell><cell>Minimum spot price</cell></row><row><cell>L</cell><cell>Demand for the spot instance</cell></row><row><cell>N</cell><cell>Number of launched spot instances</cell></row><row><cell>Λ</cell><cell>New request arrivals</cell></row><row><cell>t k</cell><cell>Length of one time slot</cell></row><row><cell>T</cell><cell>Total job completion time</cell></row><row><cell>ts</cell><cell>Job execution time (w/o interruptions)</cell></row><row><cell>tr</cell><cell>Recovery time from an interruption</cell></row><row><cell>to</cell><cell>Overhead time to run multiple sub-jobs</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>EC2 instance types. Sizes are given as (vCPU, memory in GiB, SSD storage in GB).</figDesc><table><row><cell></cell><cell>m3</cell><cell>r3</cell><cell>c3</cell></row><row><cell cols="2">.xlarge 4, 15, 1x32</cell><cell>4, 30.5, 1x80</cell><cell>4, 7.5, 2x40</cell></row><row><cell cols="2">.2xlarge 8, 30, 2x80</cell><cell>8, 61, 1x160</cell><cell>8, 15, 2x80</cell></row><row><cell>.4xlarge</cell><cell>-</cell><cell cols="2">16, 122, 1x320 16, 30, 2x160</cell></row><row><cell>.8xlarge</cell><cell>-</cell><cell>-</cell><cell>32, 60, 2x320</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>, we have ∂Φ sp (p)/∂p = Note that first three terms before g(p) in ∂Φ sp (p)/∂p are positive. To show the positivity of ∂Φ sp (p)/∂p, we take first-order derivative of g(p) and then have ∂g(p)/∂p = )+2 tr t k F π (p)−pf π (p) . Due to the positivity and monotonic decreasing property of f π (p) (cf.Figure</figDesc><table><row><cell></cell><cell></cell><cell cols="4">(ts−tr)fπ (p) (1− tr t k (1− tr t k )Fπ(p)+ tr t k</cell><cell>)+2 tr t k Fπ(p) Fπ(p) 2 2</cell><cell>g(p),</cell></row><row><cell>where</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>g(p) = −</cell><cell>p π</cell><cell cols="3">xf π (x)dx + p</cell><cell cols="2">(1 − tr t k )F π (p) + tr t k F π (p) (1 − tr t k ) + 2 tr t k F π (p)</cell><cell>2</cell><cell>.</cell></row><row><cell cols="3">(1− tr t k (1− tr )Fπ(p)+ tr t k t k )+2 tr t k Fπ(p) Fπ(p) 2</cell><cell>2</cell><cell cols="2">(1− tr t k</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">These available resources include idle resources and those in use by launched spot instances.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">Amazon charges users separately for ingress and egress bandwidth to EC2. Since the required bandwidth is determined by the user job rather than the instance on which the job is run, we do not consider these costs.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2">In practice N is a discrete integer, but for tractable analysis we take N continuous in our model.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3">This observation is consistent with the findings in<ref type="bibr" target="#b16">[18]</ref>. Thus, we can expect the cumulative distribution functions to have a knee, as was observed in<ref type="bibr" target="#b0">[1]</ref>.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4">  7  As noted in Section 1, the bidding strategies do not explicitly depend on the provider model in Section 4 but rather on the spot price's PDF.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5">Including deadlines on the job completion times does not materially change our model, but we do not explicitly model this constraint. Users with hard job deadlines are more likely to use on-demand instances with guaranteed availability.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6">While master nodes are often run on on-demand instances to guarantee that they will not be interrupted, our experiments in Section 7 show that, with sufficiently high bids, interruptions are rare even on spot instances.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_7">This overhead time may depend on M , the (fixed) number of sub-jobs.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_8">To ensure accuracy, we use our bills from Amazon to calculate the job costs. Since Amazon does not break the bills into individual jobs, we do not report the cost of each job.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank our shepherd, Michael Schapira, and Sudipta Sengupta for helpful comments. This work was in part supported by the Waterman Award CNS-1347234, the Research Grants Council of Hong Kong Project No. RGC 11212114 and the National Research Foundation Fellowship NRF-NRFF2015-07.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(c) Total job cost. Figure <ref type="figure">6</ref>: Persistent requests yield lower costs but longer completion times compared to one-time requests. The bid prices for each instance type are given in Table <ref type="table">3</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>Proof of Proposition 1.</p><p>Proof. Substituting (4) into ( <ref type="formula">5</ref>), the Lyapunov drift can be expressed as Δ(t) = 1 2 (1 − θ π−π (t) π−π )L(t) + Λ(t)</p><p>2 − 1 2 L 2 (t). We now bound the expectation of this quantity by:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Deconstructing Amazon EC2 spot instance pricing</title>
		<author>
			<persName><forename type="first">Agmon</forename><surname>Ben-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ben-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tsafrir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Economics and Computation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">EC2 spot instance</title>
		<author>
			<persName><surname>Amazon</surname></persName>
		</author>
		<ptr target="http://aws.amazon.com/ec2/purchasing-options/spot-instances/" />
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A game theoretic formulation of the service provisioning problem in cloud systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ardagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Panicucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Passacantando</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of WWW</title>
				<meeting>of WWW</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="177" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A view of cloud computing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Armbrust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Griffith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Konwinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rabkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="50" to="58" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Online algorithms for market clearing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sandholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zinkevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="845" to="879" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Market-oriented cloud computing: Vision, hype, and reality for delivering IT services as computing utilities</title>
		<author>
			<persName><forename type="first">R</forename><surname>Buyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Yeo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venugopal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE HPCC</title>
				<meeting>of IEEE HPCC</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="5" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Decentralized task-aware scheduling for data center networks</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Dogar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Karagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCOMM</title>
				<meeting>of ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Smart grid -The new and improved power grid: A survey</title>
		<author>
			<persName><forename type="first">X</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Surveys &amp; Tutorials</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="944" to="980" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Revenue maximization using adaptive resource provisioning in cloud computing environments</title>
		<author>
			<persName><forename type="first">G</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Buyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM/IEEE Grid</title>
				<meeting>of ACM/IEEE Grid</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="192" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Pricing WiFi at Starbucks: Issues in online mechanism design</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Parkes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM EC</title>
				<meeting>of ACM EC</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="240" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Managing cost, performance, and reliability tradeoffs for energy-aware server provisioning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Guenter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
				<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1332" to="1340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">TUBE: time-dependent pricing for mobile data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Joe-Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Im</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCOMM</title>
				<meeting>of ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Near-optimal scheduling mechanisms for deadline-sensitive jobs in large computing clusters</title>
		<author>
			<persName><forename type="first">N</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Menache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yaniv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Statistical modeling of spot instance prices in public cloud environments</title>
		<author>
			<persName><forename type="first">B</forename><surname>Javadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Thulasiram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Buyya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE/ACM UCC</title>
				<meeting>of IEEE/ACM UCC</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="219" to="228" />
		</imprint>
	</monogr>
	<note>IEEE/ACM</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Revenue generation for truthful spectrum auction in dynamic spectrum access</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MobiHoc</title>
				<meeting>of ACM MobiHoc</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Towards optimized fine-grained pricing of IaaS cloud platform</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Di</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Cloud Computing</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Beyond poisson: Modeling inter-arrival time of requests in a datacenter</title>
		<author>
			<persName><forename type="first">D.-C</forename><surname>Juan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-K</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marculescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Knowledge Discovery and Data Mining</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="198" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A decentralized auction framework to promote efficient resource allocation in open computational grids</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Parkes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Joint Workshop on The Economics of Networked Systems and Incentive-Based Computing</title>
				<meeting>Joint Workshop on The Economics of Networked Systems and Incentive-Based Computing</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On combinatorial auction and Lagrangean relaxation for distributed resource scheduling</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kutanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIE Trans</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="813" to="826" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pricing in infrastructure clouds-an analytical and empirical examination</title>
		<author>
			<persName><forename type="first">U</forename><surname>Lampe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seliger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pauly</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Information Systems Conference</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Heterogeneity-aware resource allocation and scheduling in the cloud</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of HotCloud</title>
				<meeting>of HotCloud</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Bounds on average delays and queue size averages and variances in input-queued cell-based switches</title>
		<author>
			<persName><forename type="first">E</forename><surname>Leonardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mellia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Neri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ajmone Marsan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
				<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1095" to="1103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Pricing the Internet</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mackie-Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Varian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Access to the Internet</title>
				<editor>
			<persName><forename type="first">B</forename><surname>Kahin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Keller</surname></persName>
		</editor>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Socially optimal pricing of cloud computing resources</title>
		<author>
			<persName><forename type="first">I</forename><surname>Menache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ozdaglar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shimkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VALUETOOLS</title>
				<meeting>of VALUETOOLS</meeting>
		<imprint>
			<publisher>ICST</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On competitive provisioning of cloud services</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wierman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMETRICS Performance Evaluation Review</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="30" to="32" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Virtual worlds: Fast and strategyproof auctions for dynamic resource allocation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Parkes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM EC</title>
				<meeting>of ACM EC</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="238" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Fault-tolerant workflow scheduling using spot instances on clouds</title>
		<author>
			<persName><forename type="first">D</forename><surname>Poola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramamohanarao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Buyya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Procedia Computer Science</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="523" to="533" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Mechanism design for online real-time scheduling</title>
		<author>
			<persName><forename type="first">R</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM EC</title>
				<meeting>of ACM EC</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Modeling the dynamics of network technology adoption and the role of converters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hosanagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1793" to="1805" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A new game theoretical resource allocation algorithm for cloud computing</title>
		<author>
			<persName><forename type="first">F</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Magoulès</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Grid and Pervasive Computing</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="321" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">How to price shared optimizations in the cloud</title>
		<author>
			<persName><forename type="first">P</forename><surname>Upadhyaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the VLDB Endowment</title>
				<meeting>of the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="562" to="573" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Cost-optimal scheduling in hybrid IaaS clouds for deadline constrained workloads</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Den Bossche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vanmechelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Broeckhove</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE CLOUD</title>
				<meeting>of IEEE CLOUD</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="228" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Present or future: Optimal pricing for spot instances</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE ICDCS</title>
				<meeting>of IEEE ICDCS</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">When cloud meets eBay: Towards effective pricing for cloud computing</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Meng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
				<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="936" to="944" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Exploring bidding strategies for market-based scheduling</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Wellman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Mackie-Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Reeves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swaminathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM EC</title>
				<meeting>of ACM EC</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="115" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Monetary cost-aware checkpointing and migration on Amazon cloud spot instances</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Andrzejak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kondo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Services Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="512" to="524" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dynamic resource provisioning in cloud computing: A randomized auction approach</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
				<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Dynamic resource allocation for spot markets in cloud computing environments</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Boutaba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE/ACM UCC</title>
				<meeting>of IEEE/ACM UCC</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="178" to="185" />
		</imprint>
	</monogr>
	<note>IEEE/ACM</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The sharing architecture: sub-core configurability for IaaS clouds</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wentzlaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM ASPLOS</title>
				<meeting>of ACM ASPLOS</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="559" to="574" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
