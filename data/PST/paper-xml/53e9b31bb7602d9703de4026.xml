<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Concise Papers __________________________________________________________________________________________ An Instance-Weighting Method to Induce Cost-Sensitive Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kai</forename><forename type="middle">Ming</forename><surname>Ting</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Gippsland School of Computing and Information Technology</orgName>
								<orgName type="institution">Monash University</orgName>
								<address>
									<postCode>3842</postCode>
									<settlement>Churchill</settlement>
									<region>Victoria</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Concise Papers __________________________________________________________________________________________ An Instance-Weighting Method to Induce Cost-Sensitive Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8B3EEEEE0033E8ABE391C6551C5E173B</idno>
					<note type="submission">received 28 June 1999; revised 13 Sept. 2000; accepted 4 Jan. 2001; posted to Digital Library 7 Sept. 2001.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index TermsÐCost-sensitive</term>
					<term>decision trees</term>
					<term>induction</term>
					<term>greedy divide-andconquer algorithm</term>
					<term>instance weighting</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>AbstractÐWe introduce an instance-weighting method to induce cost-sensitive trees. It is a generalization of the standard tree induction process where only the initial instance weights determine the type of tree to be inducedÐminimum error trees or minimum high cost error trees. We demonstrate that it can be easily adapted to an existing tree learning algorithm. Previous research provides insufficient evidence to support the idea that the greedy divide-and-conquer algorithm can effectively induce a truly cost-sensitive tree directly from the training data. We provide this empirical evidence in this paper. The algorithm incorporating the instance-weighting method is found to be better than the original algorithm in terms of total misclassification costs, the number of high cost errors, and tree size in two-class data sets. The instance-weighting method is simpler and more effective in implementation than a previous method based on altered priors.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>COST-SENSITIVE classifications have received much less attention than minimum error classifications in empirical learning research. Classifiers that minimize the number of misclassification errors are inadequate in problems with variable misclassification costs. Many practical classification problems have different costs associated with different types of error. For example, in medical diagnosis, the errors committed in diagnosing someone as healthy when they have a life-threatening disease is usually considered to be far more serious (thus, higher cost) than the opposite type of errorÐdiagnosing someone as ill when they are in fact healthy.</p><p>A line of research in cost-sensitive tree induction employing the greedy divide-and-conquer algorithm demands further investigation. Breiman et al. <ref type="bibr" target="#b2">[3]</ref> describe two different methods of incorporating variable misclassification costs into the process of tree induction. These methods adapt the test selection criterion in the tree growing process. Pazzani et al. <ref type="bibr" target="#b7">[8]</ref> reported negative empirical results when using one of Breiman et al.'s <ref type="bibr" target="#b2">[3]</ref> formulations to induce cost-sensitive trees. They found that the costsensitive trees do not always have lower misclassification costs, when presented with unseen test data, than those trees induced without cost consideration. Using a postprocessing approach, Webb <ref type="bibr" target="#b16">[17]</ref> showed that applying a cost-sensitive specialization technique to a minimum error tree can reduce its misclassification costs by about 3 percent on average. Employing the greedy divideand-conquer algorithm, the research so far does not show convincingly whether a truly cost-sensitive tree can be effectively learned directly from the training data. We investigate this issue specifically in this paper.</p><p>This paper presents the instance-weighting method to induce cost-sensitive trees that seeks to minimize the number of high cost errors and, as a consequence of that, leads to minimization of the total misclassification costs in most cases. This method is inspired by instance weight modification in boosting decision trees developed by Quinlan <ref type="bibr" target="#b9">[10]</ref>. Boosting generates multiple classifiers in sequential steps. At the end of each step, the weight of each instance in the training set is adjusted to reflect its importance for the next induction step. These weights cause the learner to concentrate on different instances in each step and so leads to different classifiers. These classifiers are then combined by voting to form a composite classifier. Boosting begins with equal initial weights in the first step. The intuition for the cost-sensitive induction in this paper is to have different initial weights which reflect the (given) costs of misclassification. This effectively influences the learner to focus on instances which have high misclassification costs. We demonstrate that this is a viable method and can be easily adapted to an existing learning algorithm. We show convincingly that a truly cost-sensitive tree can be effectively learned using this methodÐan algorithm incorporating the instance-weighting method achieves a substantial reduction in misclassification costs, the number of high cost errors, and tree size over the same algorithm without it in two-class domains. It is also found to be competitive with a recent program C5 <ref type="bibr" target="#b10">[11]</ref> and better in some aspects.</p><p>The proposed instance-weighting method changes the class distribution such that the tree so induced is in favor of the class with high weight/cost and is less likely to commit errors with high cost. This usually reduces the total misclassification costs as a consequence. Smaller trees are a natural product of the tree induction procedure when presented with training data sets of skewed class distribution, which is a result of weighting instances in data sets with relatively balanced class distribution. We present the proposed instance-weighting method in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">COST-SENSITIVE TREE INDUCTION VIA INSTANCE-WEIGHTING</head><p>Let N be the total number of instances from the given training set and N j be the number of class j instances. Similarly, let Nt and N j t be the number of instances and class j instances in node t of a decision tree. The probability that an instance is in class j given that it falls into node t is given by the ratio of the total number of class j instances to the total number of instances in this node.</p><formula xml:id="formula_0">pjjt N j t P i N i t :<label>1</label></formula><p>When node t contains instances that belong to a mixture of classes, the standard greedy divide-and-conquer procedure for inducing trees (e.g., <ref type="bibr" target="#b2">[3]</ref> and <ref type="bibr" target="#b8">[9]</ref>) uses a test selection criterion to choose a test at this node such that the training instances which fall into each branch, as a result of the split, become more homogeneous. One of the commonly used criteria is entropy, that is, À P j pjjtlogpjjt. At each node, the tree growing process selects a test which has the maximum gain in entropy until the node contains only a singleclass collection of instances.</p><p>To avoid overfitting, a pruning process is employed to reduce the size of the tree such that the estimated error is a minimum. In short, the standard tree induction procedure seeks to produce a minimum error tree.</p><p>Our intuition for cost-sensitive tree induction is to modify the weight of an instance proportional to the cost of misclassifying the class to which the instance belonged, leaving the sum of all training instance weights still equal to N. The last condition is important because there is no reason to alter the size of the training set, which is equivalent to the sum of all training instance weights, The standard greedy divide-and-conquer procedure for inducing minimum error trees can then be used without modification, except that W j t is used instead of N j t in the computation of the test selection criterion in the tree growing process and the error estimation in the pruning process. Thus, both processes are affected due to this change. We modified C4.5 <ref type="bibr" target="#b8">[9]</ref> to create C4.5CS. We only need to initialize the training instance weights to wj since C4.5 has already employed W j t for the computation discussed above. 1  This modification effectively converts the standard tree induction procedure that seeks to minimize the number of errors, regardless of cost, to a procedure that seeks to minimize the number of errors with high weight or cost. Note that minimizing the latter does not guarantee that the total misclassification cost is minimized; this is because the number of low cost errors is usually increased as a result.</p><p>The advantage of this approach is that the whole process of tree growing and tree pruning is the same as that used to induce minimum error trees. This can be viewed as a generalization of the standard tree induction process where only the initial instance weights determine the type of tree to be inducedÐminimum error trees or minimum high cost error trees.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> shows an example of a split on the same attribute test using unit instance weights (in the left figure) and different instance weights (in the right figure). The sum of the instance weights for each class are shown in each node. With unit weights, each sum is equivalent to the number of instances for each class N j t. This example has two equiprobable classes, where N 1 N 2 50 at the root of the tree. The right figure shows the result of the same split when C1 3 and C2 1. Employing (1), the weights of all instances are modified to w1 1:5 and w2 0:5. As a result, the sums of the class j instance weights at the root are W 1 75 and W 2 25. This example shows that initializing the instance weights to wj amounts to changing the class distribution of the training data.</p><p>To classify a new instance, C4.5CS predicts the class which has the maximum weight at a leaf, as in C4.5.</p><p>Here, we describe how the cost of misclassification can be specified in a cost matrix and how the cost matrix is related to Cj in <ref type="bibr" target="#b1">(2)</ref>. In a classification task of I classes, the misclassification costs can be specified in a cost matrix of size I Â I. The rows of the matrix indicate the predicted class and the column indicates the actual class. The off-diagonal entries contain the costs of misclassifications; and on the diagonal lie the costs for correct classifications, which are zero in this case since our main concern here is total misclassification costs of an induced tree. <ref type="foot" target="#foot_0">2</ref>Let costi; j be the cost of misclassifying a class j instance as belonging to class i. In all cases, costi; j 0:0 for i j. A cost matrix must be converted to a cost vector Cj in order to use <ref type="bibr" target="#b1">(2)</ref> for instance-weighting. In this paper, we employ the form of conversion suggested by Breiman et al. <ref type="bibr" target="#b2">[3]</ref>:</p><formula xml:id="formula_1">Cj X I i costi; j:<label>4</label></formula><p>In our experiments, without loss of generality, we impose a unity conditionÐat least one costi; j 1:0, which is the minimum misclassification cost. The only reason to have this unity condition or normalization <ref type="foot" target="#foot_1">3</ref> is to allow us to measure the number of high cost errors, which is defined as the number of misclassification errors that have costs more than 1.0. Note that the cost matrix to cost vector conversion is expected to work well with the cost-sensitive tree induction, as described in this section, when there are only two classes. But, it might be inappropriate when there are more than two classes because it collapses I Â I numbers to I. In order to investigate the potential problem due to this conversion, we explicitly divide the experimental data sets into two groups: two-class and multiclass. Any performance discrepancy between these two groups is due to this conversion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXPERIMENTS</head><p>Four measures are used to evaluate the performance of the costsensitive tree induction algorithm in this paper. They are total misclassification costs (i.e.,</p><formula xml:id="formula_2">X N H l costpredicted-classl; actual-classl;</formula><p>where N H is the number of instances in the unseen test set), pruned tree size (i.e., total number of internal nodes and leaves), the number of high cost errors, and the total number of misclassification errors on unseen data. The first and the third are the most important measures. While the aim of cost-sensitive classification is to minimize the total misclassification costs, it is important to measure the number of high cost errors since the instance-1. C4.5 uses fractional weights for the treatment of missing values. See <ref type="bibr" target="#b8">[9]</ref> for details. weighting method is designed to achieve the aim through high cost error minimization. All other factors being equal, one tree induction algorithm is better than another if it induces smaller trees.</p><p>We conduct experiments using 20 data sets obtained from the UCI repository of machine learning databases <ref type="bibr" target="#b0">[1]</ref> and two data sets with specified cost matrices (i.e., Heart_S and German) used in the Statlog project <ref type="bibr" target="#b4">[5]</ref>. The data sets are selected to cover a wide variety of different domains with respect to data set size, the number of classes, the number of attributes, and the types of attributes. They consist of 12 two-class data sets and 10 multiclass data sets. The details of these data sets are given in Table <ref type="table">1</ref>.</p><p>Ten 10-fold cross-validations 4 <ref type="bibr" target="#b2">[3]</ref> are carried out in each data set, except in the Waveform data set where randomly generated training data size of 300 and test data size of 5,000 are used in the 100 trials.</p><p>Random cost assignments with the unity condition are used in all data sets except the Heart_S and German data sets. In the latter cases, the costs (i.e., cost1; 2 1:0 and cost2; 1 5:0) specified in <ref type="bibr" target="#b4">[5]</ref> are used. In the former cases, a cost matrix is randomly generated at the beginning of each trial. Each nondiagonal entry in the cost matrix is assigned an integer randomly generated between 1 to 10.</p><p>We first compare C4.5CS with C4.5 to evaluate whether trees induced by C4.5CS are more cost sensitive than those produced by C4.5. Note that the only difference between C4.5CS and C4.5 is the initial weight setting, so any performance differences are due to this initial weight setting. Then, we compare C4.5CS to C5 <ref type="bibr" target="#b10">[11]</ref> and other algorithms reported in the Statlog project.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Can C4.5CS Induce Cost-Sensitive Trees Effectively?</head><p>Given a training set and a cost matrix, C4.5CS induces a costsensitive tree which seeks to minimize the number of high cost errors and total misclassification costs. C4.5 produces a tree which seeks to minimize the total misclassification errors. Both trees are then tested using a separate test set and the total misclassification costs are measured according to the given cost matrix.</p><p>Table <ref type="table" target="#tab_2">2</ref> presents averages, over 100 trials, for the misclassification costs, the tree size, the number of high cost errors, and the total errors for both C4.5CS and C4.5 in each data set . The ratio (C4.5CS/C4.5) for each of these measures is also presentedÐa value less than 1 represents an improvement due to C4.5CS. The means of these ratios are given for the 12 two-class data sets as well as the 10 multiclass data sets.</p><p>In terms of misclassification costs, C4.5CS achieves a mean reduction of 38 percent compared to C4.5 in two-class data sets, but a mean reduction of only 2 percent in multiclass data sets.</p><p>In terms of tree size, C4.5CS produces trees 34 percent smaller than those produced by C4.5 in two-class data sets, and 15 percent smaller in multiclass data sets. In only two data sets (Hypothyroid and Euthyroid) does C4.5CS produce trees which are larger than those produced by C4.5. This is because the two data sets have very skewed class distribution; 95.2 percent and 90.7 percent of the total instances belong to one of the two classes in these two data sets, respectively. A high cost Cj assigned to the class which has a small number of instances effectively reduces the class distribution skewness, leading to larger trees. Although the costs are randomly assigned without reference to the original class distribution, reduction in skewness seems to have a larger effect than increase in skewness in these two data sets.</p><p>C4.5CS makes 65 percent fewer high cost errors than C4.5 in two-class data sets, but 2 percent more high cost errors in multiclass data sets. On the other hand, C4.5CS has 41 percent more errors than C4.5 in two-class data sets, but only 6 percent more errors in multiclass data sets.</p><p>Hypothyroid is the only two-class data set in which C4.5CS has higher misclassification costs (by 3 percent) than C4.5. While C4.5CS is able to reduce the number of high cost errors by 19 percent in this highly skewed class distribution data set, the 74 percent increase in total errors outweighs this reduction, resulting in a net increase in total misclassification costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Minimum Expected Cost Criterion</head><p>A simple method of using a minimum error tree for cost-sensitive classifications is to employ the minimum expected cost criterion in selecting a predicted class during classification <ref type="bibr" target="#b4">[5]</ref>. It is interesting to find out how the proposed method compares to this simple method.</p><p>The expected misclassification cost for predicting class i with respect to the instance x is given by:</p><formula xml:id="formula_3">EC i x G X j W j txcosti; j;<label>5</label></formula><p>where tx is the leaf of the tree that instance x falls into and W j t is the total weight of class j training instances in node t.</p><p>To classify a new instance x using a minimum error tree with the minimum expected cost criterion, EC i x is computed for every class. The instance x is assigned to class i with the smallest value for EC i x; that is, EC i x &lt; EC i H x for all i H T i.</p><p>A comparison between C4.5CS_mc and C4.5_mc, both using the minimum expected cost criterion, is presented here. The results in Table <ref type="table" target="#tab_3">3</ref> show that it is still better to induce a cost-sensitive tree than a minimum error tree for cost-sensitive classifications in two-class data sets, even using the minimum expected cost criterion. Note that this criterion affects only the classification process, not the induction process. Thus, the tree size does not change for C4.5CS and C4.5CS_mc, as well as for C4.5 and C4.5_mc.</p><p>It is interesting to know what the effect of the criterion is on C4.5CS. An experiment using the 12 two-class data sets shows that the criterion increases, average misclassification cost of C4.5CS by 5 percent but significantly reduces the average number of high cost 4. In a 10-fold cross-validation, the given data set is randomly divided into 10 equal size subsets. In each fold, nine subsets are used as the training and the remaining subset as the test set. This is repeated 10 times and each subset is used as the test set only once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE 1 Details of the Data Sets Used in the Experiment</head><p>errors by 60 percent. A direct comparison between C4.5CS and C4.5_mc shows, that to minimize cost, the instance-weighting method does more than substitute the minimum expected cost criterion as the cost ratio for C4.5CS versus C4.5_mc stays at about the same level shown in Table <ref type="table" target="#tab_3">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">MultiClass Problems</head><p>In this section, we study the behavior of C4.5CS using three different types of cost matrix in the 10 multiclass data sets. We first define three types of cost matrix, which give rise to different definitions of Cj. They are defined as follows:</p><p>1. costi; j &gt; H only for a single value of i I and costi T I; j H for all i T j. We define Cj costI; j for j T I and CI H:</p><p>2. This type of cost matrix has a constant misclassification cost for each class, i.e., costi; j H j ! 1:0 for each j T i. Thus, it can be expressed as a cost vector Cj H j :</p><p>3. In this more general case, costi; j ! 1:0 for all i T j. This is the type of matrix we used for the previous experiments and a possible form of Cj is defined earlier in ( <ref type="formula" target="#formula_1">4</ref>). Examples of these matrices are shown in Table <ref type="table" target="#tab_4">4</ref>.</p><p>For experiments in this section, without loss of generality, we impose the following unity condition: For Type 1 cost matrix, H 1:0, for Type 2 cost matrix, at least one H j 1:0, and for Type 3 cost matrix, at least one costi; j 1:0, where the unit cost is the minimum cost.     <ref type="table" target="#tab_6">5</ref> presents the mean ratios for C4.5CS against C4.5 using the three types of cost.</p><p>In comparison to C4.5, C4.5CS performs better in terms of misclassification costs, tree size, and the number of high cost errors for all three types of cost matrix, except that it is making 2 percent more high cost errors when using Type 3 cost matrix. Among these cost matrices, C4.5, and its cost-sensitive counterpart seem to be performing most similarly using Type 3 cost matrix, and least similarly using Type 1 cost matrix. This is evident since the mean ratios for misclassification costs and the number of high cost errors increase from Type 1 to Type 2 and to Type 3 cost matrices. This suggests that the conversion from costi; j to Cj is most effective for Type 1 cost matrix but least effective for Type 3 cost matrix.</p><p>To maintain generality, we have used Type 3 cost matrix as the default cost matrix in other parts of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Summary</head><p>We summarize the findings so far as follows:</p><p>.</p><p>In terms of misclassification costs and the number of high cost errors, C4.5CS performs better than C4.5 in two-class data sets, but is only comparable for multiclass data sets. .</p><p>The relatively poor performance of C4.5CS in multiclass data sets is due to the conversion of cost matrix to cost vector. . C4.5CS always makes fewer high cost errors than C4.5 in two-class data sets, but, in data sets with highly skewed class distribution, C4.5CS might have higher total misclassification costs than C4.5. . C4.5CS produces smaller trees than C4.5 because instance weighting effectively increases the skewness of the otherwise more balanced class distribution. . Even using the minimum expected cost criterion, it is better to induce a cost-sensitive tree than to induce a minimum error tree for cost-sensitive classifications in two-class data sets. The instance-weighting method produces an effect that is significantly better than simply applying the criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">How Does C4.5CS Compare to C5?</head><p>In this experiment, we compare C4.5CS to the improved version of C4.5, C5 <ref type="bibr" target="#b10">[11]</ref>, which can produce a cost-sensitive tree when given a cost matrix. The results in Table <ref type="table" target="#tab_7">6</ref> show that C4.5CS performs comparably to C5 in terms of misclassification costs; the mean ratio is .99 over 22 data sets. In only six data sets are the ratios for misclassification costs outside the range 1:00 AE :10.</p><p>In terms of tree size, C4.5CS produces smaller trees than those produced by C5 in 20 out of the 22 data sets. On average, C4.5CS induces trees which are 14 percent smaller. It is important to note that the two exceptions, the Annealing and Nettalk(s) data sets, are due to a simpler C5 representation for nominal attribute tests next to the leaves of the tree. In C4.5, when a decision node next to the leaves is a test using a nominal attribute, the number of leaves is the same as the number of possible values for this attribute. This usually results in many leaves with no covered instance, especially when the nominal attribute has many values. C5 simplifies the representation by collecting all zero-instance leaves into a single leaf with a subset branch. When we simplify the C4.5CS representation, as in C5, the tree sizes reduce from 76.7 to 55.5 for the Annealing data set and from 1650.4 to 566.2 for the Nettalk(s) data set , which are both smaller than the trees produced by C5. Taking these new figures into account, the mean ratio for tree size is reduced from .86 to .80. Although trees produced by C4.5CS have more misclassification errors (i.e., 7 percent on average) than those by C5, C4.5CS is less likely to make high cost errors. This feature is particularly important when the aim is to minimize the number of high cost errors. C4.5CS makes 14 percent fewer high cost errors than C5 on average. This effect is apparent in 16 out of the 22 data sets.</p><p>Unfortunately, no description is given of the cost-sensitive induction method employed in C5 <ref type="bibr" target="#b10">[11]</ref> and we have no access to source code, except that used for classifying from an induced tree which is in the public domain. The latter reveals that C5 predicts a class which has the minimum expected costs, whereas C4.5CS (like C4.5) predicts a class which has the maximum weights. The significantly smaller trees produced by C4.5CS are also another indication that the cost-sensitive induction method used in C5 is different from that in C4.5CS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Comparison with the Results from the Statlog Project</head><p>The Statlog project <ref type="bibr" target="#b4">[5]</ref> studied a number of classifiers for costsensitive classification in the Heart and GermanCredit data sets. We restate their results for three classifiers for comparison. The classifiers are CART <ref type="bibr" target="#b2">[3]</ref>, linear discriminant (Discrim), and NaiveBayes. The Statlog project uses average misclassification costs (the ratio of the total misclassification costs and the total number of test instances) for evaluation. We convert our results for C4.5CS and C5 to this measure and the results for the five classifiers are tabulated in Table <ref type="table" target="#tab_8">7</ref>.</p><p>The results show that C4.5CS performs better than CART in both data sets. It performs marginally worse than Discrim and NaiveBayes in the Heart data set , but significantly better than both classifiers in the GermanCredit data set .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RELATION TO ALTERED PRIORS</head><p>Breiman et al. <ref type="bibr" target="#b2">[3]</ref> discuss a method of incorporating variable misclassification costs via altered priors for cost-sensitive tree induction. Let priors j N j =N and Cj as defined in (4); then, the altered priors are given by <ref type="bibr" target="#b2">[3]</ref> H j Cjj P i Cii CjN j P i CiN i :</p><p>In the instance-weighting method, every instance is weighted proportional to Cj. The weight of a class j instance is computed as</p><formula xml:id="formula_4">wj CjN P i CiN i H jN=N j H j j :</formula><p>Thus, the instance weight is a ratio of the altered prior and the original prior. Both methods share the same idea of changing the class distribution according to the given misclassification costs, but one implementation is simpler and more effective than the other. Implementation using altered priors or by merely modifying instance weights will produce the same tree at the end of the tree growing process, but the former would require an equivalent modification in the pruning process; otherwise, it will perform poorly. This is demonstrated by modifying C4.5 accordingly to yield C4:5 H . Because instance weights are not altered, the tree induced by C4:5 H will be pruned according to unit instance weights.</p><p>The mean ratios C4:5CS=C4:5 H for misclassification cost and the number of high cost errors are .70 and .43, respectively, averaged over the 12 two-class data sets. C4:5 H is significantly worse than C4.5CS for the two important measures in costsensitive classifications. The poor result of C4:5 H is due to the inconsistent use of instance weights from the tree growing process to the tree pruning process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>The results presented in Table <ref type="table" target="#tab_2">2</ref> clearly show that the greedy divide-and-conquer algorithm can effectively induce a costsensitive tree directly from the training set, given a cost matrix. A previous reported methodÐcost-sensitive specialization <ref type="bibr" target="#b16">[17]</ref>, which also applied to C4.5, only achieves a cost reduction of 3 percent on average over 20 data sets. 5 This method maintains the same size of the tree produced by C4.5. In comparison, the instance-weighting method achieves a 38 percent reduction in costs and produces trees which are 34 percent smaller in the twoclass data sets.</p><p>The idea of using fractional instance weights in decision tree induction has been applied in C4.5 <ref type="bibr" target="#b8">[9]</ref>. In the case of missing value, C4.5 partitions the training set using fractional weights in evaluating a test during tree induction and classification. Quinlan <ref type="bibr" target="#b9">[10]</ref> further develops the idea to boosting decision tree algorithms. In both cases, equal initial weights are used. We extend this idea to different initial weights, which we demonstrate to be a simple and viable approach for extending the tree induction algorithm to include cost-sensitive classifications.</p><p>Indeed, the instance-weighting method only requires the weights to be proportional to the misclassification cost. For example, instead of (2), one can use wj Cj to weight the instances and induce the same cost-sensitive tree as that produced by C4.5CS. This is fine if the task requires only one tree to be produced. However, in the case where multiple trees are needed, as in the case of boosting ( <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b13">[14]</ref>) in which it is important to maintain identical total initial weight for each tree induction, then (2) is essential to the process.</p><p>Pazzani et al. <ref type="bibr" target="#b7">[8]</ref> show that trees induced using the Gini criterion (the test selection criterion as used in CART) with altered priors perform worse than those induced using only the Gini criterion in terms of misclassification costs in both two-class and multiclass data sets. Pazzani et al. <ref type="bibr" target="#b7">[8]</ref> attribute the negative result to the conversion of cost matrix costi; j to cost vector Cj. We disagree with this explanation, suspecting that their negative result is due to the use of two different priors in the tree growing and pruning processes, as shown in our experiment in Section 4. Our results indicate that a tree induced with altered priors, together with the corresponding modification in the pruning method, should perform better than those without. Also, we think the difference is not due to the test selection criterion employed (C4.5 uses the entropy criterion rather than the Gini criterion).</p><p>However, the conversion does result in a weakness in the instance-weighting method. This method will induce the same tree for different cost matrices whenever these matrices convert to the same cost vector Cj. This is undesirable for multiclass problems. While other forms of conversion are possible (for example, Cj max i costi; j), they suffer from the same problem. One possible remedy is to conduct tree pruning using costi; j directly. However, so far we have not found an effective method for this kind of pruning. Bradford et al. <ref type="bibr" target="#b1">[2]</ref> and Knoll et al. <ref type="bibr" target="#b3">[4]</ref> studied several cost-sensitive pruning methods and reported that no pruning method dominated over all the data sets they studied. One way to mitigate this problem is to generate multiple trees and then combine them to produce a final prediction. We have suggested a cost-sensitive version of boosting <ref type="bibr" target="#b11">[12]</ref> to address both this weakness and the problem with skew class distribution reported in <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b13">[14]</ref>. There are several tree induction algorithms that consider the costs of tests, such as EG2 <ref type="bibr" target="#b6">[7]</ref>, CS-ID3 <ref type="bibr" target="#b12">[13]</ref>, and IDX <ref type="bibr" target="#b5">[6]</ref>. Turney <ref type="bibr" target="#b15">[16]</ref> investigates both the costs of tests and misclassifications using a genetic algorithmic search in tree induction. We do not consider costs of tests in this paper to avoid complicating the issue under investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>We have introduced an instance-weighting method to induce costsensitive trees and demonstrated that it is a viable approach, which is simple to implement or adapt to an existing learning algorithm. It is a generalization of the standard tree induction process to include both minimum error trees and minimum high cost error trees. The instance-weighting method is simpler and more effective in implementation than an existing method based on altered priors.</p><p>Our empirical results show convincingly that the greedy divide-and-conquer procedure can effectively induce a truly costsensitive tree directly from the training data. This work refutes an earlier negative result <ref type="bibr" target="#b7">[8]</ref> with regard to cost-sensitive tree induction employing the greedy divide-and-conquer procedure in two-class data sets.</p><p>The algorithm incorporating the instance-weighting method is found to be better than the original algorithm in two-class data sets in terms of the number of high cost errors, total misclassification costs, and tree size. The instance weighting which changes the class distribution directly contributes to this improved performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Splitting on the same testÐusing unit instance weights (left) and different instance weights (right).</figDesc><graphic coords="2,46.09,69.17,211.37,114.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="3,29.14,97.06,245.21,216.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="4,72.91,97.06,420.68,347.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="5,298.43,97.06,232.76,334.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING, VOL. 14, NO. 3, MAY/JUNE 2002 while the individual instance weights are adjusted to reflect the relative importance of instances for making future prediction with respect to cost-sensitive classification.Let Cj be the cost of misclassifying a class j instance; the weight of a class j instance can be computed as</figDesc><table><row><cell cols="3">wj Cj</cell><cell>P</cell><cell cols="2">N i CiN i</cell><cell>2</cell></row><row><cell cols="6">such that the sum of all instance weights is Cj ! 1, wj has the smallest value 0 &lt; N P i CiNi P j wjN j N. For 1 when Cj 1 and the largest value</cell></row><row><cell cols="2">wj</cell><cell cols="3">Cj P i CiN i P i N i</cell><cell>! 1</cell></row><row><cell>when Cj max i Ci.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="6">Similar to pjjt, p w jjt is defined as the ratio of the total weight</cell></row><row><cell cols="6">of class j instances to the total weight in node t:</cell></row><row><cell>p w jjt</cell><cell cols="3">W j t P i W i t</cell><cell cols="2">wjN j t P i wiN i t</cell><cell>:</cell><cell>3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 2 C4</head><label>2</label><figDesc>.5CS vs. C4.5 in Terms of Misclassification Cost, Tree Size, Number of High Cost Errors and Total Number of Errors</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 3 Mean</head><label>3</label><figDesc>Ratios for C4.5CS_mc against C4.5_mc</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 4 Examples</head><label>4</label><figDesc></figDesc><table /><note><p>of Three Types of Cost Matrix, costi; j</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE 5 Mean</head><label>5</label><figDesc>Ratios for C4.5CS against C4.5 Over 10 Multiclass Data Sets</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE 6</head><label>6</label><figDesc>Ratios for C4.5CS vs. C5</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE 7 Average</head><label>7</label><figDesc>Misclassification Costs for Five Classifers5. There are 10 same data sets which are used in both Webb's and our experiments. We use nine data sets of size more than 900, whereas Webb uses only two.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>In general, the costs of correct classifications can be nonzero. Minimizing the costs of correct classifications is a different issue outside the scope of this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Note that an arbitrary cost matrix can be normalized to become a cost matrix satisfying this unity condition.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The author would like to thank the anonymous reviewers, Zijian Zheng, Geoff Webb, and Albert Goodman for providing helpful suggestions to improve this paper. The author also would like to thank Ross Quinlan for providing C4.5.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Blake</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Keogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Merz</surname></persName>
		</author>
		<ptr target="http://www.ics.uci.edu/~mlearn/MLRepository.html" />
		<title level="m">ªUCI Repository of Machine Learning Databases</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of California, Dept. Information and Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Bradford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kunz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kohavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Brunk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Brodley</surname></persName>
		</author>
		<title level="m">ªPruning Decision Trees with Misclassification Costs,º Proc. 10th European Conf. Machine Learning</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="131" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Classification and Regression Trees</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Olshen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Stone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Wadsworth</publisher>
			<pubPlace>Belmont, Cailf</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">U</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nakhaeizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Tausend</surname></persName>
		</author>
		<title level="m">ªCost-Sensitive Pruning of Decision Trees,º Proc. Eighth European Conf. Machine Learning</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="383" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Spiegelhalter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Taylor</surname></persName>
		</author>
		<title level="m">Machine Learning, Neural and Statistical Classification</title>
		<imprint>
			<publisher>Ellis Horwood Limited</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Norton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªGenerating Better Decision Trees,º Proc. 11th Int&apos;l Joint Conf</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="800" to="805" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Nu Â N Ä Ez</surname></persName>
		</author>
		<title level="m">ªThe Use of Background Knowledge in Decision Tree Induction,º Machine Learning</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="231" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Pazzani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Merz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Brunk</surname></persName>
		</author>
		<title level="m">ªReducing Misclassification Costs,º Proc. 11th Int&apos;l Conf. Machine Learning</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="217" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<title level="m">C4.5: Program for Machine Learning</title>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<title level="m">ªBoosting, Bagging, and C4.5,º Proc. 13th Nat&apos;l Conf. Artificial Intelligence</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="725" to="730" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<ptr target="http://rulequest.com" />
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
		<title level="m">ªBoosting the Margin: A New Explanation for the Effectiveness of Voting Methods,º Proc. 14th Int&apos;l Conf. Machine Learning</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="322" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Tan</surname></persName>
		</author>
		<title level="m">ªCost-Sensitive Learning of Classification Knowledge and Its Applications in Robotics,º Machine Learning</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="7" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">ªA Comparative Study of Cost-Sensitive Boosting Algorithms</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Ting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Machine Learning</title>
		<meeting>17th Int&apos;l Conf. Machine Learning</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="983" to="990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Ting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zheng</surname></persName>
		</author>
		<title level="m">ªBoosting Cost-Sensitive Trees,º Proc. First Int&apos;l Conf. Discovery Science</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="244" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">ªCost-Sensitive Classification: Empirical Evaluation of a Hybrid Genetic Decision Tree Induction Algorithm</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Turney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="369" to="409" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">ªCost-Sensitive Specialization,º Proc. 1996 Pacific Rim Int&apos;l Conf</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">I</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="page" from="23" to="34" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">For more information on this or any computing topic</title>
		<ptr target="http://computer.org/publications/dlib" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
