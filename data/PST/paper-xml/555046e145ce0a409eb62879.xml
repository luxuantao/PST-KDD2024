<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Tolerating SDN Application Failures with LegoSDN</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Balakrishnan</forename><surname>Chandrasekaran</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Theophilus</forename><surname>Benson</surname></persName>
							<email>tbenson@cs.duke.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Duke University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">HotNets-XIII</orgName>
								<address>
									<addrLine>October 27-28</addrLine>
									<postCode>2014</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Tolerating SDN Application Failures with LegoSDN</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F840FDFD5ADD2CCD2DAA4A8FDBAAED0A</idno>
					<idno type="DOI">10.1145/2670518.2673880</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2 [Computer Communication Networks]: Network Architecture and Design</term>
					<term>C.4 [Performance of Systems]: Reliability, availability and serviceability Software-Defined Networking</term>
					<term>Fault Tolerance</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Despite Software Defined Network's (SDN) proven benefits, there remains significant reluctance in adopting it. Among the issues that hamper SDN's adoption two stand out: reliability and fault tolerance. At the heart of these issues is a set of fate-sharing relationships: The first between the SDN-Apps and controllers, where-in the crash of the former induces a crash of the latter, and thereby affecting availability; and, the second between the SDN-App and the network, where-in a byzantine failure e.g., black-holes and networkloops, induces a failure in the network, and thereby affecting network availability. The principal position of this paper is that availability is of utmost concern -second only to security. To this end, we present a re-design of the controller architecture centering around a set of abstractions to eliminate these fate-sharing relationships, and make the controllers and network resilient to SDN-App failures. We illustrate how these abstractions can be used to improve the reliability of an SDN environment, thus eliminating one of the barriers to SDN's adoption.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Software Defined Networking (SDN) has made great strides in the past few years, with active involvement from both academia and the industry. Inspite of SDN's benefits and the industry endorsements, however, there remains significant reluctance in SDN's adoption. Amongst the factors impeding the adoption of SDN, two stand out: reliability and fault tolerance. In an SDN deployment, there are four main failure scenarios: controller server failures (hardware failures), controller crashes (bugs in the controller code), network device failures (switch, end-host or link failures), and SDN application (SDN-App) crashes (bugs in the application code). While much focus has been on overcoming hardware and network device failures <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b20">21]</ref>, and debugging SDN-Apps and the ecosystem <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b21">22]</ref>, little has been done to protect SDN-Apps against failures.</p><p>Fault-tolerant design has been studied extensively in different contexts, viz., operating systems and applicationservers. Unfortunately, techniques like reboot <ref type="bibr" target="#b8">[9]</ref> or replay <ref type="bibr" target="#b29">[30]</ref> cannot be applied directly to the SDN control plane: certain fundamental assumptions of these techniques do not hold true in the SDN ecosystem. First, both the network and the SDN-Apps contain state, and rebooting <ref type="bibr" target="#b8">[9]</ref> the SDN-App will result in loss of state and consequently, introduce inconsistency issues (the SDN-App's view of the network and the actual network state might no longer be the same). Second, the state of an SDN-App might be possibly interdependent on the state of other SDN-Apps. Reboots of an SDN-App, hence, can potentially affect this entire ecosystem. Third, naïvely replaying events <ref type="bibr" target="#b29">[30]</ref> to recover this state implicitly assumes that the bugs are nondeterministic (or transient) and thus would not be encountered during replay. However, we argue that given the eventdriven nature of SDN-Apps, bugs will most likely be deterministic.</p><p>In this work, we focus on SDN-App failures, fail-stop crashes and byzantine failures, and not on controller failures because the controller code represents a common layer that is highly reused and, thus, has a lesser likelihood of containing bugs. The principal position of this paper is that availability is of upmost concern -second only to security.</p><p>We argue that the availability of an SDN controller is reduced by the existence of two fate-sharing relationships in the SDN ecosystem: The first between the SDN-Apps and controllers, where-in the crash of the former induces a crash of the latter, and thereby affecting availability; and the second between the SDN-App and the network, where-in a byzantine failure within an SDN-App may lead to the violation of a network safety property, and thereby affecting network availability. The issue is symptomatic of the lack of proper abstractions between the controller and the SDN-Apps, and also between the SDN-Apps and the network. Our solution to this issue is a re-design of the controller architecture centering around a set of abstractions that enable two new features:</p><p>• Isolating the SDN-Apps from the Controller. Promote isolation and eliminate the two fate-sharing relationships.</p><p>• Isolating the SDN-Apps from the Network. Support the notion of network-wide transactions to manage the explicit and implicit relationships between various SDN-Apps running on a controller; transactions in conjunction with roll-backs help in guaranteeing consistency across SDN-Apps and undoing the impact of byzantine and fail-stop bugs.</p><p>The re-design allows us to safely run SDN-Apps with a best-effort model that overcomes SDN-App failures by detecting failure triggering events, and ignoring or transforming these events. Ignoring or transforming events, however, compromises the SDN-Apps' correctness (ability to completely implement its policies). The challenge lies in (1) detecting faults, i.e., determining when to compromise correctness, <ref type="bibr" target="#b1">(2)</ref> in determining how to overcome the faults, i.e., how much to compromise, and (3) in ensuring safety while performing fault recovery (compromising correctness).</p><p>Our proposal calls for a re-design of the controller to support three key abstractions:</p><p>1. An isolation layer between SDN-Apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A transaction layer that bundles operations issued by</head><p>the controller or SDN-Apps, with implicit or explicit dependencies, into one atomic update that facilitates roll-back or recovery operations without sacrificing consistency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head><p>. A network roll-back mechanism that accurately and efficiently undoes transformations to network state.</p><p>In this paper, we present LegoSDN a straw-man that embodies the described abstractions by providing AppVisor -an isolation layer between SDN-Apps, and NetLog -a network-wide transaction system that supports atomic updates and efficient roll backs. We exemplify the strength of these abstractions by using them to build Crash-Pad -a fault tolerance layer that detects crash triggering events and overcomes them through event transformations. LegoSDN does not require any modifications to the SDN controller<ref type="foot" target="#foot_0">1</ref> or the SDN-Apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MOTIVATION AND RELATED WORKS</head><p>In this section, we review the properties of a canonical SDN environment, focusing on the salient interactions between applications and controllers. We follow up with an overview of the fault model within SDN environments coupled with a discussion of related works and relevant techniques from other domains, most notably, operating systems and distributed systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Properties of the SDN Ecosystem</head><p>Software-Defined Networking separates the network control logic from the switches and centralizes it; therefore, failure of the controller or controller services significantly impacts the network. Table <ref type="table" target="#tab_0">1</ref> illustrates the layers in a canonical SDN control platform. In platforms such as NoX <ref type="bibr" target="#b30">[31]</ref> and FloodLight <ref type="bibr">[7]</ref>, failures of any component in the stack renders the control plane unavailable. Perhaps surprisingly, in a FloodLight stack, Table <ref type="table" target="#tab_0">1</ref>, an un-handled exception (fault) in one SDN-App will result in the failure of other SDN-Apps and the controller itself. Similarly, a segmentation fault in a NoX SDN-App takes down both the controller and SDN-App. The crashes of SDN-Apps have a disastrous effect on the entire platform because of a lack of isolation, both between the SDN-Apps and the controller, and between the SDN-Apps themselves.</p><p>While certain companies, such as BigSwitch [1], aim to provide the entire SDN stack as a single vertical, monolithic bundle, most of the popular controller platforms are released as open-source software precisely to decouple the stack and to promote the creation a rich ecosystem of third-party SDN-Apps. For example, FloodLight <ref type="bibr">[7]</ref>, a Java controller platform released by BigSwitch, boasts a diverse spectrum of SDN-Apps ranging from performance enhancing <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b12">13]</ref>, to security enforcement <ref type="bibr" target="#b12">[13]</ref>. In Table <ref type="table" target="#tab_1">2</ref>, we present a small list of FloodLight SDN-Apps, their purpose, and indicate whether they are developed by a third-party or developed (in-house) by the developers of the controller.</p><p>Table <ref type="table" target="#tab_1">2</ref> reinforces the notion that the SDN ecosystem embodies an à la carte system, where-in different portions of the stack are developed by different entities. Furthermore, we expect the diversity at each layer to only increase as SDN grows in popularity. In fact, movements such as the Open-DayLight Consortium <ref type="bibr" target="#b5">[6]</ref> and the SDN-hackathons hosted by SDN-Hub are already promoting this diversity.</p><p>Given the infancy of these SDN-Apps, unfortunately, many lack a public-facing support forum or bug-tracker. Luckily, we were able to find a public bug-tracker for the SDN-App FlowScale <ref type="bibr" target="#b4">[5]</ref>. Upon examination of this bugtracker, we discovered that 16% of the reported bugs resulted in catastrophic exceptions. Furthermore, careful analysis showed that even now, at the submission of this paper, one of these bugs still remains open. While these numbers do not generalize to other SDN-Apps, we note that extensive studies on software engineering practices show that bugs are prevalent in most applications and, even worse, most bugs in production quality code do not have fixes at the time they are encountered <ref type="bibr" target="#b33">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Application Developer Purpose</head><p>RouteFlow <ref type="bibr" target="#b26">[27]</ref> Third-Party Routing FlowScale <ref type="bibr" target="#b3">[4]</ref> Third-Party Traffic Engineering BigTap <ref type="bibr" target="#b1">[2]</ref> BigSwitch Security Stratos <ref type="bibr" target="#b12">[13]</ref> Third-party Cloud Provisioning  <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b16">17]</ref> in the context of handling controller failures focus on recovery from hardware failures, applying Paxos <ref type="bibr" target="#b22">[23]</ref> to ensure robustness to controller server failures. Unfortunately, such techniques do not protect the controller against deterministics bugs. Researchers have also focused on shielding developers from writing application code to handle switch failures <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b21">22]</ref>, link failures, or application server failures <ref type="bibr" target="#b32">[33]</ref>. But, surprisingly little has been done to shield the network and the controller from application failure, and it is precisely this shortcoming that LegoSDN addresses. Most specifically, LegoSDN offers a solution to handle failures induced by bugs within the SDN-Apps. We plan on handling failures arising out of bugs in controller code in future work.</p><p>Bugs in SDN Code: Research efforts in the past few years <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b14">15]</ref>, have addressed the problem of detecting bugs that violate network consistency, defined through a set of network invariants. In an effort more relevant to debugging of SDN-Apps, STS <ref type="bibr" target="#b27">[28]</ref> offers a solution to determine the minimal set of events required to trigger a bug. These efforts can prevent bugs in an SDN-App from installing a faulty rule <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b14">15]</ref>, or help in reproducing the bug to triage the issue <ref type="bibr" target="#b27">[28]</ref>, but restoring an application once it has crashed is, for the most part, out of their scope. While we leverage these efforts, we attack an orthogonal problem, that of overcoming crashes of SDN-Apps that lead to controller crashes or violation of network invariants. Our approach allows the network to maintain availability in the face of SDN-App failures.</p><p>OS Fault Tolerance: LegoSDN builds on several key operating system techniques, namely, isolation <ref type="bibr" target="#b8">[9]</ref>, speculative fixes <ref type="bibr" target="#b25">[26]</ref>, changes to the operating environment <ref type="bibr" target="#b23">[24]</ref>, and checkpoint replay <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b28">29]</ref>. These techniques, nevertheless, assume that bugs are non-deterministic and, thus, can be fixed by a reboot <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b28">29]</ref>, or that safety and correctness can be compromised to improve availability <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b23">24]</ref>. While LegoSDN compromises correctness for availability, unlike the previous techniques <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b28">29]</ref>, it does not, by default, assume non-determinism. Unlike previous approaches <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b23">24]</ref>, our system provides network operators with control over the extent to which correctness can be compromised to guarantee availability. Furthemore, unlike previous approaches we are able to roll-back the SDN-App's output (e.g. the rules installed) by utilizing SDN's programmatic control and we are able to modify the failure inducing input (event or message) by leveraging domain specific knowledge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RE-THINKING SDN CONTROLLERS</head><p>The controller's inability to tolerate crashes of SDN-Apps is symptomatic of a larger endemic issue in the design of the controller's architecture. In this section, we present LegoSDN-a system that allows the controller to run in spite of SDN-App crashes. LegoSDN transparently<ref type="foot" target="#foot_1">2</ref> modifies the application-controller interface via two components: AppVisor ( §3.1) and NetLog ( §3.2). AppVisor is a regular SDN-App running within the controller, while NetLog is a standalone program that provides support for rolling back changes to the network's state. To offer a glimpse of the new capabilities that LegoSDN provides, we discuss the design of Crash-Pad ( §3.3), a system that provides failure detection and recovery support. Crash-Pad serves to demonstrate the benefits of a controller re-design supporting our abstractions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Isolation and Modularity: AppVisor</head><p>The SDN controller should be designed and architected like any platform that allows third-party code to execute, with SDN-Apps running as isolated modules with clearly defined fault and resource allocation boundaries. Further, we make the fundamental assumption that SDN-Apps may become momentarily unavailable due to failures; bug-free or crash-free SDN-Apps should be treated exactly as what they are -an exception, and not the norm.</p><p>The AppVisor builds on well-studied isolation techniques used in Operating Systems. AppVisor's objective is to separate the address space of the SDN-Apps from each other, and more importantly, from that of the controller, by running them in different processes. The address space separation enables containment of SDN-App crashes to the processes (or containers) in which they are running in. Aside from improving availability, this design opens itself to a wide range of novel use cases: per-application resource limits, application migration, multi-version software testing, and allows for certain seamless controller upgrades.</p><p>Not surprisingly, this design calls for a simple communication protocol between the controller and the isolated SDN-Apps. We note that serialization and de-serialization of messages, and the communication protocol overhead introduce additional latency into the control-loop (between the switch and the SDN-Apps). The additional latency, however, is acceptable as introducing the controller into the critical-path (of flow setup or packet processing) already slows down the network by a factor of four <ref type="bibr" target="#b10">[11]</ref>.</p><p>In the context of fault-tolerance AppVisor ensures, beyond any doubt, that failures in any SDN-App do not affect other SDN-Apps, or the controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Network Transactions: NetLog</head><p>Network policies often span multiple devices, and hence, mechanisms to implement a policy may comprise many network actions (e.g. OpenFlow messages). Controllers treat these as independent actions. We propose that the actions associated with any policy must be executed in an atomic fashion, with all-or-nothing semantics. Failure of either an SDN-App or an action generated by an SDN-App should trigger a network-wide roll-back of all related actions of the concerned policy.</p><p>NetLog leverages the insight that each control message that modifies network state is invertible: for every state altering control message, A, there exists another control message, B, that undoes A's state change. Not surprisingly, undoing a state change is imperfect as certain network state is lost. For instance, while it is possible to undo a flow delete event, by adding the flow back to the network, the flow timeout and flow counters cannot be restored. Consequently, NetLog, stores and maintains the timeout and counter information of a flow table entry before deleting it. Therefore, should NetLog need to restore a flow table entry, it adds it with the appropriate time-out information. For counters, it stores the old counter values in a counter-cache and updates the counter value in messages (viz., statistics reply) to the correct one based on values from its counter-cache.</p><p>In the context of fault-tolerance NetLog ensures that the network-wide state remains consistent regardless of failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Surviving amidst failures: Crash-Pad</head><p>Consider the following three trends: (1) 80% of bugs in production quality software do not have fixes at the time they are encountered <ref type="bibr" target="#b33">[34]</ref>, (2) bugs have been found in three of the dominant controllers <ref type="bibr" target="#b27">[28]</ref> (not all controllers were written in the same programming language), and (3) bugs in SDN-Apps are mostly deterministic. We envision Crash-Pad to leverage these trends and overcome SDN-App failures by detecting failure-inducing events, and ignoring or transforming these events. To achieve this, Crash-Pad exploits the fault isolation (or containment) provided by AppVisor, and the support for atomic updates provided by NetLog.</p><p>The act of ignoring or transforming events compromises an SDN-App's ability to completely implement its policies (correctness), and through the design of Crash-Pad, we aim to explore and provide insight into certain key design questions in this context.</p><p>How to detect a bug? (When to compromise correctness?)</p><p>SDN-Apps are largely event-driven and in most situations, the cause of an SDN-App's failure is simply the last event processed by the SDN-App before failure. We classify failures as follows:</p><p>• Fail-stop failures: the SDN-App crashes and it can be detected using techniques described in Section §4.1.</p><p>• Byzantine failures: the output of the SDN-App violates network invariants, which can be detected using policy checkers <ref type="bibr" target="#b19">[20]</ref>.</p><p>Crash-Pad takes a snapshot of the state of the SDN-App prior to its processing of an event and should a failure occur, it can easily revert to this snapshot. Replay of the offending event, however, will most likely cause the SDN-App to fail. Therefore, Crash-Pad either ignores or transforms the event, referred to as a correctness-compromising operation on the offending event, prior to the replay.</p><p>How to overcome a bug? (How much correctness to compromise?) Crash-Pad can provide a simple interface through which operators can specify policies (correctnesscompromising transformations) that dictate how to compromise correctness when a crash is encountered. In this initial straw-man, we aim to expose three basic policies:</p><p>• Absolute Compromise ignores the offending event (sacrificing correctness) and makes SDN-Apps failure oblivious</p><p>• No Compromise allows the SDN-App to crash, thus sacrificing availability to ensure correctness.</p><p>• Equivalence Compromise transforms the event into an equivalent one, e.g. a switch down event can be transformed into a series of link down events. Alternatively, a link down event may be transformed into a switch down event. This transformation exploits the domain knowledge that certain events are super-sets of other events and vice versa.</p><p>How to specify the availability-correctness trade-off ? For security applications, network operators may be unwilling to compromise on the correctness of certain SDN-Apps, depending on the nature of the event. To account for this, Crash-Pad can support a simple policy language that allows operators to specify, on a per application basis, the set of events, if any, that they are willing to compromise on.</p><p>How to alert operators of failures or compromises? Our research agenda is to make the SDN-Apps and not the SDN-App developers oblivious to failures. When subverting a failure, Crash-Pad will generate a problem ticket from the captured stack-traces generated by the SDN-App, controller logs and the offending event. The problem ticket can help developers to triage the SDN-App's bug.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Enabling novel techniques</head><p>Besides providing an environment where SDN operators can deploy SDN-Apps without fear of crashing the controller or other SDN-Apps, LegoSDN addresses the following usecases that are not achievable in today's SDN environments:</p><p>Enabling Software and Data Diversity in SDNs: A popular software engineering technique is to have multiple teams develop identical versions of the same application. The idea being that most teams will implement the functionality correctly; the correct output for any given input can be chosen using a majority vote on the outputs from the different versions. LegoSDN can be used to distribute events to the different versions of the same SDN-App, and compare the outputs.</p><p>Per Application Resource Limits: Currently, there is no way to limit the resource consumption of individual SDN-Apps. Consequently, a rogue SDN-App can consume all of the server's resources. With the isolation provided by LegoSDN, however, an operator can define resource limits for each SDN-App, thus limiting the impact of misbehaving applications.</p><p>Controller Upgrades: Upgrades to the controller codebase must be followed by a controller reboot. Such events also cause the SDN-App to unnecessarily reboot and lose state. Some SDN-Apps may incorrectly recreate this state <ref type="bibr" target="#b31">[32]</ref>. Furthermore, this state recreation process can result in network outages lasting as long as 10 seconds <ref type="bibr" target="#b31">[32]</ref>. The isolation provided by LegoSDN shields the SDN-Apps from such controller reboots. Although, designing SDN-Apps to be stateless can also alleviate this problem, currently, several SDN-Apps are stateful.</p><p>Atomic Network Updates: Katta et al. <ref type="bibr" target="#b18">[19]</ref> present a mechanism to support consistent network updates; they support all-or-nothing semantics in the context of network updates made by SDN-Apps. LegoSDN's support for transactions supports similar semantics, and does not require any support from SDN-App developers. When an application crashes after installing a few rules, it is not clear whether the few rules issued were part of a larger set (in which case the transaction is incomplete), or not. LegoSDN can easily detect such ambiguities and roll back only when required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION</head><p>Motivated by its lush support ecosystem 3 , we decided to build LegoSDN to run on the FloodLight stack and demonstrate the utility of our abstractions. The architectural changes discussed and the abstractions demonstrated are easily generalizable to other controllers such as NOX <ref type="bibr" target="#b13">[14]</ref>, OpenDay-Light <ref type="bibr" target="#b5">[6]</ref> and Beacon <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Prototype</head><p>We present an overview of the proposed LegoSDN architecture and compare it with existing FloodLight architecture in Figure <ref type="figure">1</ref>. Although FloodLight's monolithic architecture is simpler to manage and visualize, the fate-sharing relationships clearly manifest themselves in the schematic. By running all components within a single process, the monolithic 3 FloodLight project boasts the world's largest SDN ecosystem <ref type="bibr" target="#b7">[8]</ref> architecture makes it infeasible to provide any fault isolation; failure of any one component, implies failure of the entire stack. In LegoSDN, there are two parts to the AppVisor: AppVisor Proxy and AppVisor Stub. The former runs as an SDN-App in the controller, while the latter runs as a stand-alone application hosting an SDN-App, as shown in Figure <ref type="figure">1</ref>. The proxy and stub communicate with each other using UDP. The proxy dispatches the messages it receives from the controller to the stub, which in turn delivers it to the SDN-App. The message processing order in LegoSDN is, for all purposes, identical to that in the FloodLight architecture.</p><p>The stub is a stand-alone Java application that launches an SDN-App. Once started the stub connects to the proxy and registers the SDN-App, and its subscriptions (what message types it intends to process) with the proxy. The proxy in turn registers itself for these message types with the controller and maintains the per-application subscriptions in a table.</p><p>The stub is a light-weight wrapper around the actual SDN-App and converts all calls from the SDN-App to the controller to messages which are then delivered to the proxy. The proxy processes these messages, calls the appropriate methods in the controller and returns the responses. In other words, the stub and proxy implement a simple RPC-like mechanism. The proxy uses communication failures with the stub to detect that the SDN-App has crashed. To further help the proxy in detecting crashes quickly, the stub also sends periodic heart beat messages.</p><p>For checkpointing and recovery, we use Checkpoint and Restore In Userspace (CRIU) <ref type="bibr" target="#b2">[3]</ref>. The proxy creates a checkpoint of an SDN-App process (or JVM) prior to dispatching every message. In a normal scenario where the SDN-App processes the message and returns the responses, the proxy simply ignores the checkpoint created. In the event of crash, however, the proxy restores the SDN-App to the checkpoint (last known state prior to the processing of the message). Assuming the last message delivered to an SDN-App is the reason behind the crash, the AppVisor records the message along with the stack traces and other diagnostic information gathered during the crash, to help in triaging bugs.</p><p>The current prototype is based on the design described earlier, in Section §3, except that pertaining to NetLog. In the place of NetLog, our prototype contains a simple buffer that delays the actions generated by an application from being installed on the switch, until it is confirmed that the processing completed without failure. We note that this is not practical in a real-world environment and are working on a better implementation of NetLog that can guarantee performance and consistency.</p><p>As far as the applications are considered, we were able to successfully move applications like the LearningSwitch, Hub, Flooder, bundled with Floodlight to run within the stub with very minimal changes; we had to comment out use of services, viz., counter-store, the support for which is still a work-in-progress.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DISCUSSION &amp; ON-GOING WORK</head><p>As part of ongoing efforts, we plan to extend LegoSDN to address the following challenges.</p><p>Handling failures that span multiple transactions: Currently, LegoSDN can easily overcome failure induced by the most recently processed event. If the failure is induced as a cumulation of events, we plan on extending LegoSDN to read a history of snapshots (or checkpoints of the SDN-App) and use techniques like STS <ref type="bibr" target="#b27">[28]</ref> to detect the exact set of events that induced the crash. STS allows us to determine which checkpoint to roll back the application to.</p><p>Dealing with concurrency: SDN-Apps, being eventdriven, can handle multiple events in parallel if they from multiple switches. Fortunately, these events are often handled by different threads and thus we can pin-point which event causes the thread to crash. Furthermore, we can correlate the output of this thread to the input.</p><p>Tackling non-deterministic bugs: The approaches presented in Section §3.3 can be easily modified to overcome non-deterministic bugs. For instance, LegoSDN can spawn a clone of an SDN-App, and let it run in parallel to the actual SDN-App. LegoSDN can feed both the SDN-App and its clone the same set of events, but only process the responses from the SDN-App and ignore those from its clone. This allows for an easy switch-over operation to the clone, when the primary fails. Since the bug is assumed to be nondeterministic, the clone is unlikely to be affected.</p><p>Avoiding violations of network invariants: Ignoring events such as switch-down, to overcome an SDN-Appcrash, can result in black-holes. We argue that, in general, sacrificing the availability a few flows dependent on a switch is better than sacrificing availability of all flows dependent on the network. When unacceptable, a host of policy checkers <ref type="bibr" target="#b19">[20]</ref> can be used to ensure that the network maintains a set of "No-Compromise" invariants. If any of these "No-Compromise" invariants are indeed affected, then the network shuts down.</p><p>Surviving deterministics controller failures: By providing fault isolation, our re-design also ensures that an application can persist despite a controller crashing. In this situation, however, the application cannot continue to function since communication with the network only happens through the controller. We, however, believe some of the techniques embodied in the design of Crash-Pad can be used to harden the controller itself against failures.</p><p>Minimizing checkpointing overheads: Crash-Pad creates a checkpoint after every event, and this can be prohibitively expensive. Thus, we plan to explore a combination of checkpointing and event replay. More concretely, rather than checkpointing after every event, we can checkpoint after every few events. When we do roll back to the last checkpoint, we can replay all events since that checkpoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>Today, SDN applications are bundled and executed with the controller code as a single monolithic process; crash of any one SDN-App brings down the entire controller. Furthermore, an SDN-App crash may result in an inconsistent network, as the controller is unable to roll back network changes made by the SDN-App. We argue that these problems are symptomatic of a lack of proper abstractions between the controller and the SDN-Apps, and also between the SDN-Apps and the network In this paper, we propose a set of abstractions for improving controller availability: AppVisor (fault isolation) and NetLog (network transactions). We demonstrate the efficacy of our abstractions by building a system, LegoSDN, that retrofits an existing controller platform to support these abstractions without any changes to either the controller or SDN-Apps. Our system allows SDN operators to readily deploy new SDN-Apps in their networks without fear of crashing the controller, and this is key to enable a thriving SDN ecosystem. We believe this system represents the first step towards a controller framework that epitomizes availability as a first-class citizen.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>SDN Stack Illustration</figDesc><table><row><cell>Generic Controller Stack Floodlight Stack</cell></row><row><cell>Application RouteFlow</cell></row><row><cell>Controller FloodLight</cell></row><row><cell>Server Operating System Ubuntu</cell></row><row><cell>Server Hardware Dell Blade</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Survey of Popular SDN Applications 2.2 Fault Tolerance in SDN Networks and OS SDN Fault Tolerance: Fault tolerance within the SDN environment has been a subject of research for quite some time. Recent efforts</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The current LegoSDN prototype is designed to work with Flood-Light.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Neither the controller nor the SDN-App require any code change.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://goo.gl/UHDqjT" />
		<title level="m">Big Tap Monitoring Fabric</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://goo.gl/OMb5K" />
		<title level="m">Checkpoint/Restore In Userspace (CRIU)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://goo.gl/WewH1U" />
		<title level="m">FlowScale</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Flowscale</forename><surname>Bug</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tracker</forename></persName>
		</author>
		<ptr target="http://goo.gl/4ChWa4" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="http://goo.gl/1uobC" />
		<title level="m">OpenDaylight: A linux foundation collaborative project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://goo.gl/aV1E40" />
		<title level="m">Project Floodlight</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<ptr target="http://goo.gl/xTslJ1" />
	</analytic>
	<monogr>
		<title level="j">Project Floodlight Grows to the World&apos;s Largest SDN Ecosystem</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Microreboot -A Technique for Cheap Recovery</title>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kawamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fujiki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A NICE Way to Test Openflow Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Venzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Perešíni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kostić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tourrilhes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yalagandula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<title level="m">DevoFlow: Scaling Flow Management for High-performance Networks. SIGCOMM &apos;11</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The beacon openflow controller</title>
		<author>
			<persName><forename type="first">D</forename><surname>Erickson</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;13</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Gember</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Grandl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<title level="m">Stratos: Virtual Middleboxes as First-Class Entities</title>
		<imprint>
			<date type="published" when="2012">2012 2012</date>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
	<note>TR1771)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">NOX: towards an operating system for networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">I Know What Your Packet Did Last Hop: Using Packet Histories to Troubleshoot Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Handigol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Leveraging SDN Layering to Systematically Troubleshoot Networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wundsam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Whitlock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Handigol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mccauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zarifis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kazemian</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;13</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Experience with a globally-deployed software defined wan</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mandal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Poutievski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wanderer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hölzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stuart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM &apos;13</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Fine-grained Fault Tolerance Using Device Checkpoints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<idno>ASPLOS &apos;13</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Katta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<title level="m">Incremental Consistent Updates. HotSDN &apos;13</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">VeriFlow: Verifying Network-wide Invariants in Real Time</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Godfrey</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;12</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Onix: A Distributed Control Platform for Large-scale Production Networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Poutievski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<idno>OSDI&apos;10</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Automatic Failure Recovery for Software-defined Networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kuźniar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Perešíni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vasić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kostić</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;13</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Reaching Agreement in the Presence of Faults</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="228" to="234" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><surname>Rx</surname></persName>
		</author>
		<title level="m">Treating bugs as allergies-a safe method to survive software failures. SOSP &apos;05</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">FatTire: Declarative Fault Tolerance for Software-defined Networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Reitblatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;13</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dumitran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Beebee</surname><genName>Jr</genName></persName>
		</author>
		<title level="m">Enhancing Server Availability and Security Through Failure-oblivious Computing. OSDI&apos;04</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Revisiting Routing Control Platforms with the Eyes and Muscles of Software-defined Networking</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Rothenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Nascimento</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Salvador</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N A</forename><surname>Corrêa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cunha De Lucena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raszuk</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;12</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wundsam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Whitlock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>El-Hassany</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zarifis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<title level="m">Troubleshooting SDN Control Software with Minimal Causal Sequences. SIGCOMM &apos;14</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Recovering device drivers</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Annamalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Improving the Reliability of Commodity Operating Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="77" to="110" />
			<date type="published" when="2005-02">Feb. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Applying NOX to the Datacenter</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tavakoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotNets &apos;09</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">HotSwap: Correct and Efficient Controller Upgrades for Software-defined Networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Vanbever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;13</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Cementing High Availability in Openflow with RuleBricks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jamjoom</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>HotSDN &apos;13</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Software Reliability from the Customer View</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="37" to="42" />
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
