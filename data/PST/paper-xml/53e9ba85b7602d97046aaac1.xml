<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NEAR OPTIMAL SEPARATION OF TREE-LIKE AND GENERAL RESOLUTION</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Russell</forename><surname>Impagliazzo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Avi</forename><surname>Wigderson</surname></persName>
						</author>
						<title level="a" type="main">NEAR OPTIMAL SEPARATION OF TREE-LIKE AND GENERAL RESOLUTION</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3D788B4C8A42A978F879C3062BB0FC8D</idno>
					<note type="submission">Received January 17, 2000</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present the best known separation between tree-like and general resolution, improving on the recent exp(n ) separation of <ref type="bibr" target="#b1">[2]</ref>. This is done by constructing a natural family of contradictions, of size n, that have O(n)-size resolution refutations, but only exp(Ω(n/ log n))size tree-like refutations. This result implies that the most commonly used automated theorem procedures, which produce tree-like resolution refutations, will perform badly on some inputs, while other simple procedures, that produce general resolution refutations, will have polynomial run-time on these very same inputs. We show, furthermore that the gap we present is nearly optimal. Specifically, if S (ST ) is the minimal size of a (tree-like) refutation, we prove that ST = exp(O(S log log S/ log S)).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction and Main Results</head><p>The resolution refutation system is one of the oldest and most commonly methods for proving the unsatisfiability of CNF formulas, and is interesting from a theoretical as well as practical point of view. From the theoretical point of view, this system is fairly simple, as it has a single derivation rule, and all proof-lines are clauses. Still, in spite of its simplicity, we do not understand it fully, and there remain several interesting and important open problems regarding this system. One such natural question, solved in this paper, is the following: Question: What is the largest possible gap between the minimal number of lines (=clauses) in a refutation, versus the minimal number of lines in a tree-like refutation?</p><p>"Tree-like" means that each non-axiom line is a premise for at most one other line in the refutation.</p><p>In order to understand the appeal of resolution to automated theorem proving (ATP) let us recall the ATP problem: Given a contradiction T , try to find a refutation of T in the most efficient way, in terms of time and space. Let us look at the following couple of natural methods for finding such a refutation.</p><p>Recursion: pick a variable x, and recursively try to refute T 0 and T 1 , which are the restrictions of T to x = 0, (x = 1 resp.). Such methods are called DLL-Procedures. Dynamic Programming (also known as Davis-Putnam): Start from the axioms T , arbitrarily derive new clauses T , using the resolution rule, and set T ←T ∪T . Repeat this procedure until the empty clause is derived.</p><p>If one picks a variable x and performs all possible resolutions on it, the method is called a DP-procedure.</p><p>Let us briefly describe the pros and cons of these methods, and their natural connection to resolution. The recursive procedure has recursion depth that is bounded by the number of variables, thus it is extremely spaceefficient -the space required is at most linear in the input size. Its main flaw is that it corresponds to a decision-tree for the problem of finding a clause falsified by an assignment to the variables. It turns out that such a decision-tree is a tree-like resolution refutation of T (see <ref type="bibr">lemma 7)</ref>. Thus, the recursive method will be time-costly on inputs that do not have short tree-like resolution refutations.</p><p>The dynamic programming method, on the other hand, produces general resolution refutations. Thus, if T has a short refutation, one might hope to find such a refutation by using such a method. Indeed, we shall see that for certain contradictions, there exist dynamic programming proof search methods that are extremely efficient (polynomial time). The main disadvantage of the method is the large space it might use. If we wish to save all possible resolution consequences we might require space that is exponential in n.</p><p>We conclude that understanding the relation between (minimal) general and tree-like refutation size will help us understand the relative efficiency of these two proof search methods. Formally, for a fixed contradiction T let S(T ) (S T (T ) resp.) be the number of lines in a minimal general (tree-like resp.) refutation of T , and let w(T 0) be the size of the largest clause in a refutation of T . We are interested in measuring the gap between S and S T , and in this paper deliver the following couple of messages. The first message is that the gap can be very large. Let |T | be the number of clauses in T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Lower Bound). There exists an infinite family of explicitly constructible contradictions {T</head><formula xml:id="formula_0">n } such that |T n | = O(n), S(T n ) = O(n), w(T n 0) = O(1) and S T (T )= exp(Ω( n log n )).</formula><p>It is easy to see that S T ≤ 2 S . Our second message is that there is a non-trivial upper bound on the gap, and it is almost tight:</p><formula xml:id="formula_1">Theorem 2 (Upper Bound). S T (T ) = exp O S(T )log log S(T ) log S(T )</formula><p>, for all CNF contradictions T .</p><p>Theorem 1 is proved by giving a construction which associates to every circuit (fan-in 2 DAG) G on n edges a contradiction T (G) with the following properties. The pebbling measure of a circuit G is the minimal memory size needed to carry out the computation described in the circuit G, on an input x, (both G and x are given as inputs), assuming each gate output costs one memory unit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">T (G) has O(n) variables and O(n) clauses. 2. T (G) has general Resolution refutations of length O(n).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">T (G) has</head><p>The construction of the contradictions is motivated by a special case of it for the Pyramid graph of <ref type="bibr" target="#b1">[2]</ref>, which was in turn motivated by <ref type="bibr" target="#b16">[17]</ref>. We show that the pebbling measure of the graph G is an exponential lower bound on the tree-like size of refuting T (G). The connection of pebbling to tree-like size allows us to use graphs that have a high pebbling measure. Specifically, <ref type="bibr" target="#b9">[10]</ref> explicitly construct for every n a graph G n of size O(n) satisfying P (G n )= Ω(n/ log n). This, combined with (1) and the upper bound (2), gives a truly exponential separation between general and treelike Resolution systems (the previous best bound being the recent exp( √ n) separation of <ref type="bibr" target="#b1">[2]</ref>. Finally, (3) means that for these contradictions, the natural "restricted-width" dynamic programming algorithm <ref type="bibr" target="#b6">[7]</ref>, that searches for a minimal width refutation, has polynomial time, which is exponentially faster than any recursive method.</p><p>Theorem 2 uses techniques from <ref type="bibr" target="#b9">[10]</ref>, who showed that if a Boolean function has a circuit of size S then it has a circuit of depth S/ log S. We use similar techniques to show that one can "cut" any general refutation roughly in half, by removing some of the middle lines. Then we construct a small tree-like refutation, depending on the relative size of the "middle part" that was removed.</p><p>The paper is organized as follows. After presenting the essential definitions in section 2, we start by proving the lower bound (section 3), followed by the upper bound (section 4). We end with a discussion of the applications of these bounds to automated theorem proving (section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Definitions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">General</head><p>x will denote a Boolean variable, ranging over {0, 1}. Throughout this paper we shall identify 1 with T rue and 0 with F alse. A literal over x is either x (denoted also as x 1 ) or x (denoted also as x 0 ). A clause is a set of literals, and a CNF formula is a set of clauses. A clause is viewed as the Boolean function that is the disjunction of its literals. It is customary to write a clause { 1 ,... , t } as 1 ∨ ... ∨ t . Analogously, a CNF formula is viewed as the Boolean function that is the conjunction of its clauses. It is customary to write a CNF {C 1 ,... ,C m } as C 1 ∧ ... ∧ C m . We say that a variable x appears in a clause C (denoted x ∈ C) if a literal over x is an element of C. A CNF formula T is said to be satisfiable if there exists some assignment to the Boolean variables, that sets it to 1. Otherwise the formula is said to be unsatisfiable. Let T = {C 1 ,C 2 ... C m } be a CNF formula over n variables, a Resolution derivation π of a clause A from T is a sequence of clauses π = (D 1 ,D 2 ... D S ) such that the last clause is A and each line D i is either some initial clause C j ∈ T or is derived from previous lines using one of the following rules. A resolution refutation 1 of T is a resolution derivation of the empty clause 0 from T . The following theorem is the fundamental property of the resolution proof system. A CNF T implies a clause C (denoted T |= C) if all assignments that fix T to 1 also fix C to 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 (Implicational Completeness).</head><p>For any CNF T and any clause C, T |= C iff there is a resolution derivation of C from T . In particular, T is unsatisfiable iff it has a resolution refutation.</p><p>A circuit is a Directed Acyclic Graph, in which each vertex has fan-in 2 or 0. A vertex with fan-in 0 is called a source, and a vertex with fan-out 0 is called a target. All non-source vertices are called internal vertices.</p><p>A derivation π yields a circuit G π with |π| vertices. Each vertex of G π is labeled by a clause of π, and for derivation steps edges are added from the vertices labeled by the assumptions to the vertex labeled by the consequence. A derivation π is called tree-like if G π is a tree; a tree-like derivation may have multiple sources labeled by the same initial clause in T . The size of the derivation π is the number of lines (clauses) in it, denoted S π . S(T ) (S T (T )) is the minimal size of a (tree-like) refutation of T . Notice that since every tree-like derivation is also a general derivation, we have S(T ) ≤ S T (T ). On the other hand, it is not hard to see that any general derivation of size S can be converted to a tree-like derivation of size at most 2 S , giving the trivial upper bound S T (T ) ≤ 2 S(T ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Restrictions</head><p>For C a clause, x a variable and a ∈ {0, 1}, the unit restriction of C setting x to a is:</p><formula xml:id="formula_2">C| x=a def =    C if x does not appear in C, 1 i ft h eliteral x a appears in C, C \ {x 1-a } otherwise.</formula><p>A restriction is a set of distinct unit restrictions. Namely, a restriction ρ of size k is set of ordered pairs ρ = {(x i 1 ,a 1 ),... ,(x i k ,a k )}, where i j = i j for all distinct j, j ∈ {1,... ,k}, and a j ∈ {0, 1}. For ρ a restriction of size k, we define</p><formula xml:id="formula_3">C| ρ def = C| x i 1 =a 1 | x i 2 =a 2 . . . | x i k =a k</formula><p>1 Throughout this paper we will only discuss derivations and refutations in the Resolution proof system. Hence a derivation is always a resolution derivation and a refutation is always a resolution refutation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Similarly, T |</head><formula xml:id="formula_4">ρ def = {C| ρ : C ∈ T }. For π = (C 1 ,... ,C s ) a derivation of C s from T</formula><p>and ρ a restriction, let π| ρ = (C 1 ,... ,C s ) be the restriction of π on ρ, defined inductively by:</p><formula xml:id="formula_5">C i =          C i | ρ C i ∈ T , C j 1 ∨ C j 2 C i was derived from C j 1 ∨ y and C j 2 ∨ ȳ via one resolution step, for j 1 &lt; j 2 &lt; i, C j ∨ A| ρ C i = C j ∨ A via the weakening rule, for j &lt; i.</formula><p>The consequence of resolving a clause B with 1 is defined to be B. We shall assume w.l.o.g. that π| ρ does not contain the clause 1, by removing all such clauses from π| ρ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Width Definition 4 (Clause width).</head><p>The width of a clause C, denoted w(C), is the number of literals appearing in it. The width of a set of clauses is the maximal width of a clause in the set, i.e. w(T )= max C∈T {w(C)}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Proof width).</head><p>The width of deriving a clause A from the formula T , denoted w(T A) is min π {w(π)}, where the minimum is taken over all derivations π of A from T . We also use the notation T w A to mean that A can be derived from T in width w. We will be mainly interested in the width of refutations, namely in w(T 0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Decision Trees</head><p>Let T be a CNF formula. A search problem for T is the following: given an assignment α to the variables, find a clause C ∈ T such that C(α) = 0, if there is such a clause, and otherwise (i.e. T (α) = 1) answer 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (Decision Trees for CNF Search Problems). A Decision</head><p>Tree is a binary tree, with internal vertices labeled by variables, edges labeled by 0 or 1, and leaves labeled with the possible outputs. Every assignment to the variables defines a path through the tree in the natural way, and the label at the end of the path is said to be the output of the decision tree on that assignment.</p><p>We say that D is a Decision Tree for the Search problem for T if it correctly solves it on every input.</p><p>For T a CNF formula, let S D (T ) denote the minimal size of a Decision Tree solving the CNF Search Problem for T . Decision trees for CNF search problems are closely related to tree-like resolution, as the following lemma shows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7. For T an unsatisfiable CNF, S T (T )= S D (T )</head><p>Proof. The Tree of the resolution refutation is a decision tree, where each internal vertex is labeled by the variable resolved upon at that step. Hence S T (T ) ≤ S D (T ).</p><p>For the opposite direction, we claim that given a decision tree, we can derive from it a tree like refutation without increasing its size. Notice that if T is unsatisfiable, every leaf is labeled by a clause, since 1 is not a legitimate answer. We look at two leaves labeled C i ,C j , with their father v labeled x. If x does not appear in one of the two clauses (w.l.o.g. C i ), then we may label v with C i , erase its sons, and make the tree smaller. Otherwise, w.l.o.g. x must appear in C i in positive form and in C j in negative form. In this case we may label v with the consequence of resolving C i ,C j on x. Continuing in this way up through the decision tree we conclude that S T (T ) ≥ S D (T ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Pebbling</head><p>The pebbling measure of a circuit is, intuitively, the space needed for simulating the computation of the circuit on a Turing machine. For a thorough introduction to results regarding pebbling, see the game excellent survey <ref type="bibr" target="#b17">[18]</ref>. In this section we briefly state the essential definitions and facts that will be used later on in our discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (Pebbling).</head><p>Let G a circuit, and let S and T be subsets of the vertices such all sources of G are included in S and the target is included in T . S is called the set of starting points and T is the set of terminal points for the following 1-player game. At any point in the game, some vertices of G will have pebbles on them (1 pebble per vertex), while the remaining vertices will not. A configuration is a subset of vertices, comprising just those vertices that have pebbles on them. The rules of the pebble game are as follows.</p><p>1. At any time, a pebble may be placed on any vertex in S.</p><p>2. If all immediate predecessors of a vertex have a pebble on them, a pebble may be placed on that vertex. 3. A pebble may be removed from any vertex. 4. If a pebble is placed on a vertex in T , the player wins and the game ends.</p><p>A legal pebbling of T on G from S is a sequence of configurations, the first being the empty set, the last containing some element of T , and in which each configuration follows from the previous configuration by one of the rules. The number of pebbles used in such a pebbling is the maximum number of pebbles in any configuration. The pebbling price of T on G from S, denoted P G (S, T ), is the minimal number of pebbles needed in any legal pebbling of T from S on G.</p><p>Notice that P G (S, T ) = 1 iff S and T intersect, and that P G (S, T ) = P G (S, {t}) for some t ∈ T . We remark that in this paper all vertices of the DAGs considered have fan-in either 0 or 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.">A game for proving lower bounds on tree-like resolution</head><p>Lower bounds for size of tree-like resolution proofs can be given in terms of a 2-player game; this description is due to <ref type="bibr" target="#b18">[19]</ref>. Any small tree-like proof will give a good strategy for one of the players, so a good strategy for the other player yields a corresponding lower bound on proofs.</p><p>Let T be an inconsistent set of clauses. Consider the following game between two players, the Prover, and the Delayer. In each round, the Prover chooses a variable to be assigned a value. Then the Delayer chooses one of 0, 1, or * . If 0 or 1 is chosen, no points are scored, the variable is set to the chosen bit, and the next round begins. If * is chosen, then the Delayer scores one point, but the Prover then can choose the value for the variable. The game ends when one of the clauses in T is forced to false by the assigned values, i.e., when all the literals in the clause are assigned false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 9.</head><p>If T has a tree-like resolution refutation of size S, then the Prover has a strategy where the Delayer can win at most log S points.</p><p>Proof. Fix a proof of size S. The Prover will maintain the following invariant after each round: If the Delayer has scored t points, then the partial assignment will falsify a clause in the proof, and the sub-tree rooted at this clause will be of size at most S/2 t . In particular, this will show the claimed bound on the number of points the Delayer can score.</p><p>Let C be the clause from the invariant at the previous round. If C is a leaf, then the game halts, since a clause in T has been falsified. Otherwise, the Prover picks the variable x resolved on to derive C from C 0 and C 1 in the proof. If the Delayer assigns the variable a value, at least one of the two clauses C 0 ,C 1 is falsified, and this is the new clause for the invariant. If the Delayer chooses * , and scores a point, then the Prover chooses the value to falsify the clause with the smaller sub-tree. This is at most half the size of the sub-tree for the current clause, so the invariant is maintained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 10.</head><p>If the Delayer has a strategy which always scores r points, then S T (T ) ≥ 2 r .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Lower Bound</head><p>In this section we prove the lower bound of theorem 1, by explicitly presenting a family of contradictions that achieves the lower bound. The family of contradictions is a generalization of <ref type="bibr" target="#b16">[17]</ref> and <ref type="bibr" target="#b1">[2]</ref>. For these contradictions we expose a connection between pebbling and tree-like Resolution. We start by defining these contradictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 11 (Pebbling Contradictions).</head><p>Let G be a circuit, and S and T subsets of vertices. Associate a pair of Boolean variables x(v) 0 ,x(v) 1 with every vertex v ∈ V (G). P eb G,S,T , the Pebbling Contradiction of G is the Boolean formula consisting of the following clauses: Source Axioms: x(s) 0 ∨ x(s) 1 for each s ∈ S. Target Axioms: x(t) 0 and x(t) 1 for each t ∈ T . Pebbling Axioms: (</p><formula xml:id="formula_6">x(u 1 ) a ∧ x(u 2 ) b ) → (x(v) 0 ∨ x(v) 1 ) for u 1 ,u 2 the two pre- decessors of v, and all a, b ∈ {0, 1}. This is equivalent to the clause x(u 1 ) a ∨ x(u 2 ) b ∨ x(v) 0 ∨ x(v) 1 .</formula><p>Notice that P eb G,S,T is a 4-CNF over 2|V | variables, with O(|V |) clauses. Since by definition all sources of G appear in S, and the target of G appears in T , it is not hard to see that P eb G,S,T is unsatisfiable. Furthermore, it has a short, constant width resolution refutation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 12. For G a circuit, S(P eb G,S,T )= O(|V |) and w(P eb</head><formula xml:id="formula_7">G,S,T 0) ≤ 6.</formula><p>Proof. Fix a topological sort of G. In order of this sort, we derive x(v) 0 ∨ x(v) 1 for each v ∈ V . If v has no predecessors, v ∈ S, so this is an axiom. If v has two predecessors, u 1 and u 2 , we have inductively derived x(u 1 ) 0 ∨ x(u 1 ) 1 , and x(u 2 ) 0 ∨ x(u 2 ) 1 . Together with the four Pebbling Axioms for v, these imply the clause x(v) 0 ∨ x(v) 1 . By the implicational completeness of Resolution (theorem 3) there is a derivation of x(v) 0 ∨ x(v) 1 from the above mentioned clauses. This derivation has constant width and size, since it involves at most 6 variables. Hence, starting from the Source Axioms, one can infer x(t) 0 ∨ x(t) 1 , for a target t ∈ T , in constant width and size O(|V |). Then, resolving with the Target Axioms, one derives 0.</p><p>The following theorem is the main result presented in this section, and it immediately implies theorem 1.</p><p>Theorem 13. S T (P eb G,S,T )= 2 Ω(P G (S,T )) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof [Theorem 1].</head><p>Lemma 12 shows that for any circuit G, the pebbling contradiction based on G has a linear size, constant width, general resolution refutation. <ref type="bibr" target="#b9">[10]</ref> present an infinite family of explicitly constructible circuits {G n }, with |V (G)| = n and P G (S, T )= Ω(n/ log n). Taking the Pebbling contradictions of these graphs, theorem 13 implies a lower bound of 2 Ω(n/ log n) on the tree-like refutation size, completing the proof of theorem 1.</p><p>The rest of this section is devoted to the proof of theorem 13. We use Corollary 10; we give a strategy for the Delayer that achieves at least P G (S, T ) -3 points on P eb G,S,T .</p><p>The strategy is as follows: Set S = S, T = T . On each round, the Prover proposes a variable x(v) i .</p><p>The Delayer's response is as follows: We prove that the strategy above earns the Delayer at least P G (S, T )-3 points by showing that P G (S ,T ) only decreases by the number of points earned, and is at most 3 at the end of the game. Lemma 14. When the game terminates, P G (S ,T ) ≤ 3.</p><p>Proof. Note that, if any variable x(v) i is set to 1, it happened either in Case 2 or Case 4, and in either case v ∈ S . Similarly, if both x(v) 0 and x(v) 1 are assigned 0, the first to be assigned was either via Case 1 or Case 3, and so v ∈ T . (If the first to be assigned fell under Case 4, v would be put in S , and the second variable would have been assigned 1 via Case 2.) So a source axiom will never be violated for s ∈ S ⊆ S , because both variables will not be set to 0, and similarly, a target axiom will never be violated for t ∈ T ⊆ T . So at the end of the game, a a pebbling axiom is violated, say for node v with predecessors u and u . To be violated, both x(v) 0 and x(v) 1 must be set to 0, so v ∈ T . Also, at least one of x(u) 0 and x(u) 1 must be set to 1, so u ∈ S . Similarly, u ∈ S . So to pebble T from S using three pebbles, simply place a pebble on both u and u , and then on t.</p><p>Lemma 15. For any v ∈ V and any sets S, T , P G (S, T ) ≤ max{P G (S, T ∪ {v}),P G (S ∪ {v},T )+ 1}.</p><p>Proof. One way to pebble T from S is to first pebble T ∪{v} from S, using P G (S, T ∪ {v}) pebbles. If the result is a pebble in T , stop, otherwise the final configuration has a pebble on v. Keeping that pebble on v, remove the other pebbles, then simulate a pebbling of T from S∪{v}. This second stage uses a total of P G (S ∪ {v},T ) + 1 pebbles. Lemma 16. After any round, if the Delayer has scored p points, P G (S ,T ) ≥ P G (S, T )p.</p><p>Proof. At the beginning of the game, both sides are P G (S, T ). Note that the only case when P G (S ,T ) changes is in Case 4. In this case, P G (S ,T ∪ {v}) &lt; P G (S ,T ) at the beginning of the round. By Lemma 15, this means P G (S ∪{v},T ) ≥ P G (S ,T )-1. Since in Case 4, the Delayer scores a point, and v is added to S , this preserves the invariant.</p><p>Corollary 17. Using the strategy described, the Delayer scores at least P G (S, T ) -3 points.</p><p>Corollary 18. Any tree-like resolution proof of P eb G,S,T has size Ω(2 P eb G (S,T ) ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Upper Bound</head><p>In this section we prove that the gap presented in the previous section cannot be "too large". Specifically, we prove theorem 2. This shows that the lower bound stated in theorem 1 is nearly optimal.</p><p>The theorem will be proved by explicitly constructing a small size tree like refutation of T given a small size general refutation. We shall limit our attention only to "hard" contradictions, for which the gap between tree-like and general size is maximal, and bound from above the refutation size for these inputs.</p><p>In order to prove theorem 2, we shall work with a different size measure, hereby defined. This measure, inspired by <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b9">10]</ref>, counts the number of internal edges in the graph of a minimal refutation, and is closely connected to the standard size measure S defined above. For technical reasons we will restrict ourselves to proofs π such that G π has maximal fan-out 2. This is not a big limitation, because any proof π can be converted to a proof π such that G π has fan-out 2, where the size of π is at most twice the size of π. (If C is used as an assumption in k derivation steps, make k copies of C using the weakening rule).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 19 (Internal Size</head><p>). An internal vertex of a DAG is any nonsource vertex. An internal edge in a DAG connects two internal vertices. For G a DAG, e(G) is the number of internal edges in G. For T a CNF contradiction, define the internal size of refuting T to be: e(T ) def = min{e(G π ): π is a refutation of T and G π has maximal fan-out 2}.</p><p>We define f (e) to be the maximal tree-like size of refuting T , given that T has a refutation with internal size e. Formally:</p><formula xml:id="formula_8">f (e) def = max{S T (T ) : e(T ) ≤ e};</formula><p>T is called e-maximal if e(T ) = e, S T (T ) = f (e), and removing any clause from T enlarges e or makes T satisfiable.</p><p>We start by proving two lemmas that will be used in the proof of the main theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 20. f (e + 1)≤ 2f (e).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof [Lemma 20].</head><p>Let T be an e+1-maximal contradiction, and let π be a refutation of T having e+1 internal edges. Let C be a clause of π that is a consequence of resolving two axioms A, B ∈ T , and is involved in at least one internal edge. (The proof has at least one internal edge. Repeatedly backing from the current node to any internal predecessor, starting at the source of this edge, we eventually get to a minimally internal vertex, which must be labeled by such a C.) Let T = T ∪{C}. T has a tree like refutation T of size at most f (e), since deleting the derivation of C from π gives a refutation of T with ≤ e internal edges. Adding the derivation A B C to T whenever C appears as an axiom in T , will be a refutation of T which is at most double the size of T . In every step, we have a partial assignment ρ , we query a variable, and add its value to ρ. If at the beginning of a step, ρ has forced any clause to be false, we stop and output that clause. If ρ has forced all clauses to be true, we stop and output "true". Otherwise, we choose the first clause whose value is not forced, and query the first variable in that clause whose value is not assigned.</p><p>In each step of the above strategy, there is one value for the query that satisfies the current clause. Along any path of the decision tree, the satisfying value can be chosen at most m times before all clauses are forced to true, and the decision tree terminates. Thus, a path in the tree can be described by a sequence of n bits with at most m 1's, where 1 means, assign the satisfying value, and 0, assign the other value. Therefore, there are at most n ≤m such paths.</p><p>Next, we wish to show that any G π can be split "in half", into two derivations, each having roughly half the number of internal edges appearing in the original G π .</p><p>Definition 22 (Topological Partition). Let v 1 ... v S be a topological ordering of the vertices of a circuit G. For 0</p><formula xml:id="formula_9">≤ i ≤ S, let V 0 (i) = {v 1 ,... ,v i }, and let V 1 (i) = {v i+1 ,... ,v S }. Let G 0 (i) (G 1 (i) resp.) be the subgraph of G induced by V 0 (i) (V 1 (i) resp.</formula><p>). Let e 0 (i) (e 1 (i) resp.) be the number of internal edges in G 0 (i) (G 1 (i) resp.). Let M i be the set of internal vertices of V 0 (i) that are connected to vertices in V 1 (i), and define</p><formula xml:id="formula_10">m i = |M i |. An internal vertex of G 0 (i) is also an internal vertex in G, thus M i is a subset of the internal vertices of G. Notice that π = (C 1 ,... ,C S ) is a topological ordering of G π . If V 0 (i),V 1 (i) is a topological partition of G π , then V 0 (i)</formula><p>is a resolution derivation from T , and V 1 (i) is a resolution refutation of T ∪M i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 23 (Existence of an Equal Topological Partition</head><p>). <ref type="bibr" target="#b9">[10]</ref> For v 1 ... v S a topological ordering of the vertices of a single-target circuit G with maximal fan-out 2, there exists a partition of G such that |e 0 (i)-e 1 (i)|≤ 2. Such a partition is called equal, and for an equal partition, e 0 (i) &lt; e-m i 2 +2. Proof. e 0 (0) = 0, e 0 (S) = e and e 0 (i + 1) ≤ e 0 (i) + 2, since adding the vertex v i+1 to V 0 (i) increases the number of internal edges in V 0 (i) by at most 2 (G has maximal fan-in 2). The fan-out of G is at most 2, so e 1 (i+1)≥ e 1 (i)-4, since removing v i+1 from V 1 (i) can transform at most 2 internal vertices of G 1 (i) into source vertices of G 1 (i+1), and each of these two new sources has fan-out at most 2, meaning at most 4 internal edges are removed from G 1 (i) when v i+1 is removed. Hence, there exists an i such that |e 0 (i)e 1 (i)|≤ 3.</p><p>G has a single target, so every vertex in M i is connected to at least one vertex in V 1 (i). Hence e(G) ≥ e 0 (i)+ e 1 (i)+ m i , and e 0 (i) ≤ e-m i +3 2 .</p><p>We are ready to prove the main theorem of this section: Theorem 24. There exists a constant c&gt; 0, such that for all integers k ≥ 4,</p><formula xml:id="formula_11">f (k2 k ) ≤ 2 c•2 k •log k .</formula><p>Proof. By induction on k. Let c ≥ 8 be large enough that the claim is true for all k &lt; 4, and assume the claim holds for all values smaller than some fixed k ≥ 4. Let e = k2 k . We assume T is a CNF in n variables which has a refutation with at most e internal edges, and show how to construct a tree-like refutation of size 2 c•2 k •log k .</p><p>First, if n &gt; e, there is some variable x never resolved on in the proof. Deleting x and any clause containing x from the proof makes it only smaller, and keeps it a refutation. So without loss of generality, we assume n ≤ e.</p><p>Let π = (C 1 ,C 2 ,... ,C S ) be a refutation of T , such that G π has e internal edges. Let π 0 ,π 1 be the equal partitioning of π at some 1 ≤ i ≤ S, denote e 0 = e 0 (i),e 1 = e 1 (i) and m = |M i |.</p><p>Given the partition, we present two alternative methods for constructing tree-like refutations of T . We choose our method according to the size of m: m ≥ 2 k -The Brute Force method. Each clause C ∈ M i was derived by a derivation with at most e 0 ≤ e-m 2 + 2 ≤ (k -1)2 k-1 + 2 internal edges (by lemma 23), hence it has a tree like derivation of size at most f ((k -1)2 k-1 + 2) ≤ 4f ((k -1)2 k-1 ) (by lemma 20). We replace π 1 with a tree-like derivation, that, similarly, has size at most 4f ((k -1)2 k-1 ), and then replace each axiom C ∈ M i by the tree-like derivation of size at most 4f ((k -1)2 k-1 ). The total size of this derivation is at most 16f 2 ((k -1)2 k-1 ). Using induction we get:</p><formula xml:id="formula_12">16f 2 (k -1)2 k-1 ≤ 2 4+c2 k log(k-1) ≤ 2 c2 k log k .</formula><p>The last inequality is true for c ≥ 8 and k ≥ 4. m &lt; 2 k -The Intelligent method. By lemma 21, there is a decision tree D of size at most n ≤m solving the CNF search problem over M i (M i may be satisfiable). Look at a leaf v of D. If v is labeled C ∈ M i , using lemma 23 we claim C can be derived from T by a tree like derivation of size at most f ( e-m 2 +2) ≤ 4f ( e-m 2 ) (the previous inequality uses lemma 20 again), and we plug into v this "small" tree-like derivation. Otherwise v must be labeled 1. This means that the restriction ρ defined by the path leading to v, satisfies M i , and hence π 1 | ρ is a refutation of T | ρ with at most e-m 2 + 2 internal edges (lemma 23). Hence, there is a tree like refutation of T | ρ of size at most 4f ( e-m</p><p>2 ) (lemma 20). This can be transformed into a derivation from T of C ρ , the clause which contains all literals set to 0 by ρ, without increasing its size. Plugging the tree-like derivation of C ρ into v, for every v labeled 1 in D, transforms D into a tree-like refutation of T . We need only show that the new tree-like refutation is not too large.</p><p>Its size is bounded by:</p><formula xml:id="formula_13">≤ n ≤ m • 4f k2 k -m 2 . (<label>1</label></formula><formula xml:id="formula_14">)</formula><p>n ≤ e + 1, so</p><formula xml:id="formula_15">≤ k2 k + 1 ≤ m • 2f k2 k -m 2 . (<label>2</label></formula><formula xml:id="formula_16">)</formula><p>k ≥ 4 and m &lt; 2 k , so</p><formula xml:id="formula_17">≤ 2 k+1 k2 k m • f k2 k -2 k 2 + 2 k -m 2 . (<label>3</label></formula><formula xml:id="formula_18">)</formula><p>By lemma 20 </p><formula xml:id="formula_19">≤ 2 k+1 k2 k m • 2 2 k -m 2 f (k -1)2 k-1 , (4) ≤ 2 k+1 k2 k 2 k f (k -1)2 k-1 ,<label>(5)</label></formula><formula xml:id="formula_20">≤ 2 k+1 (4k) 2 k • 2 c•2 k-1 •log k-1 , (6) ≤ 2 k+1+2•2 k +2 k •(log k)+(1/2)c(2 k log k) , (7) = 2 k+1+2 k •(2+log k(1+c/2)) ≤ 2 c2 k •log k . (<label>8</label></formula><formula xml:id="formula_21">)</formula><p>The last inequality follows for k ≥ 4 and c ≥ 8.</p><p>We are now set to prove theorem 2. Since the run time of any DLL procedure is bounded from below by the size of its output, which is a tree-like refutation, the theorem follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Open Problems</head><p>One result of this paper is that for all CNFs S T ≤ exp S log log S log S .</p><p>Another result is that for some CNFs exp S log S ≤ S T .</p><p>Can the gap between the two bounds be closed? Hopcroft, Paul and Valiant proved that any circuit with n vertices can be pebbled with O(n/ log n) pebbles <ref type="bibr" target="#b14">[15]</ref>. Thus, one cannot hope to find "harder" graphs whose pebbling measure will match our upper bound. The analysis we perform is locally tight, so it seems that using our techniques one cannot obtain better results. Finally, we do not have good intuition as to which of the two bounds (if any) is the right one.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Resolution refutations of width O(1) (i.e. all clauses in the refutation have a constant number of variables). 4. Every tree-like Resolution refutation of T (G) has length at least exp(P (G)), where P (G) is the classical pebbling number of the circuit G.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Resolution Rule: If C, D are clauses and x is a variable such that x ∈ C and x ∈ D, we say C, D are resolvable on x and their resolvent is C∪D-{x, x}. C, D are called the assumptions of the derivation and C ∪ D -{x, x} is the consequence. Weakening Rule: If C, D are clauses then C ∪ D is a weakening of C. C is the assumption and C ∪ D is the consequence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Case 1 .</head><label>1</label><figDesc>If v ∈ T , assign the variable 0. Case 2. If v ∈ S assign the variable 1. Case 3. If v ∈ S ∪T , and if P G (S ,T ∪{v})= P G (S ,T ), assign the variable 0 and add v to T . Case 4. If v ∈ S ∪ T , and if P G (S ,T ∪ {v}) &lt; P G (S ,T ), respond * (letting the Prover assign a value) and add v to S .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Lemma 21 .</head><label>21</label><figDesc>Given a CNF formula with m clauses and n variables, there is a decision tree solving the CNF search problem, with size at most n ≤m .Proof [Lemma 21].Consider the following strategy for the CNF search problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>(because r m 2 -m 2 is</head><label>22</label><figDesc>monotonically increasing in m for m ≤ r/4, and m &lt; 2 k ≤ k2 k /4, we can substitute m = 2 k to upper bound the quantity);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>[</head><label></label><figDesc>Theorem 2]. Let T be a contradiction, and π be its minimal size refutation, with S(π) = S(T ) = S. Let π be the minimal size refutation for which G π has maximal fan-out 2. By our discussion in the beginning of this section, |π | ≤ 2S. Hence e def = e(G π ) ≤ 4 • S, because at most two internal edges enter a vertex of G π . Set k def = log 2e log e . Clearly e ≤ k2 k , and recall that f (e) is monotonically increasing, hence:S T (T ) ≤ f (e) ≤ f (k2 k ) = 2 O( S log log S log S ) .By theorem 1, any tree-like refutation of T , must have size at least 2</figDesc></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was supported by Clore Foundation Doctoral Scholarship. † Research supported by NSF Award CCR-0098197 and USA-Israel BSF Grant 97-00188. ‡ This research was supported by grant number 69/96 of the Israel Science Foundation, founded by the Israel Academy for Sciences and Humanities.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Applications to Automated Theorem Proving</head><p>Some of the most extensively used and investigated methods for proving unsatisfiability of CNF formulas, are called Davis-Putnam procedures. Actually, these procedures are derived from a system devised by Davis, Logemann and Loveland <ref type="bibr" target="#b12">[13]</ref>, and hence we will refer to them as DLL Procedures. A DLL procedure relies on choosing a variable x (called the splitter), and trying to refute T | x=T and T | x=F recursively.</p><p>If T is unsatisfiable, DLL(T ) terminates providing a tree-like resolution refutation of T . The DLL procedure is actually a family of algorithms; an algorithm in the family is specified by a rule that determines the choice of splitter at each recursive step.</p><p>A different method is to seek a minimal width refutation. Algorithms for finding such refutations are well-known in the AI community ( <ref type="bibr" target="#b23">[24]</ref>), but were given additional theoretical motivation by <ref type="bibr" target="#b6">[7]</ref>. (See also <ref type="bibr" target="#b3">[4]</ref>). One algorithm to do such a search can be described as follows:</p><p>Else { increase w repeatedly derive from T all clauses of width ≤ w and add to T } } Algorithm A has running time bounded by n O(w(T 0)) , because this is the maximal number of different clauses that will be encountered. A simple consequence of this observation, is that the pebbling contradictions provide concrete examples for which algorithm A exponentially outperforms any DLL-procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 25. Let DLL be any implementation of a DLL procedure. There exists an infinite family of unsatisfiable CNF formulas T such that T ime(DLL(T )) is exponentially larger than T ime(A(T )), i.e., exp(T ime Ω(1) T ime(A(T ))).</head><p>Proof. We use the notation of section 3. Take T = P eb G,S,T a circuit G with high pebbling measure P G (S, T )= |V |/ log |V |. By lemma 12 (1) . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Eli Ben-Sasson</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Minimal Non-Two-Colorable Hypergraphs and Minimal Unsatisfiable Formulas</title>
		<author>
			<persName><forename type="first">R</forename><surname>Aharoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Combinatorial Theory, Series A</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="196" to="204" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Exponential Separations between Restricted Resolution and Cutting Planes Proof Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Bonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Esteban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Galesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Johannsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">39th Symposium on Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="638" to="647" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the Complexity of Unsatisfiability Proofs for Random k-CNF Formulas</title>
		<author>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pitassi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Saks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proceedings of the 30th Annual ACM Symposium on Theory of Computing</title>
		<meeting><address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-05">May 1998. 2002</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1048" to="1075" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pitassi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Simplified and Improved resolution lower bounds, Preliminary version in 37th Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Burlington, VT</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-10">October 1996. 2002</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1048" to="1075" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Resolution and the Weak Pigeonhole Principle</title>
		<author>
			<persName><forename type="first">S</forename><surname>Buss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pitassi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Springer-Verlag Lecture Notes in Computer Science</title>
		<imprint/>
	</monogr>
	<note>Proceedings from Computer Science Logic &apos;97)</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Resolution Proof of generalized Pigeonhole principles</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Buss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gy</forename><surname>Turán</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Comp. Sci</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="311" to="317" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Short Proofs are Narrow -Resolution made Simple</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="169" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>Preliminary version in STOC99</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An Observation on Time-Storage Trade-Off</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Comp. and Sys. Sci</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="308" to="316" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Using the Groebner Basis algorithm to find proofs of unsatisfiability</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clegg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Edmonds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM symposium on Theory of Computing</title>
		<meeting>the 28th ACM symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="174" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Celoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Space Bounds for a Game on Graphs, Math. Systems Theory</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="239" to="251" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The relative efficiency of propositional proof systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Reckhow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="36" to="50" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Many Hard Examples for Resolution</title>
		<author>
			<persName><forename type="first">V</forename><surname>Chvátal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Szemerédi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="759" to="768" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Machine program for theorem proving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Logemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Loveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="394" to="397" />
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Intractability of Resolution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Haken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="297" to="308" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On Time vs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="332" to="337" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
	<note>Space</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Lower Bounds for the Polynomial-Calculus and the Groebner Basis Algorithm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pudlák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sgall</surname></persName>
		</author>
		<idno>TR97-042</idno>
		<ptr target="http://www.eccc.uni-trier.de/eccc/" />
	</analytic>
	<monogr>
		<title level="m">Electronically at Electronic Colloquium on Computational Complexity Reports Series 1997</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="127" to="144" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mckenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proceedings of the 38th FOCS 1997</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="234" to="243" />
		</imprint>
	</monogr>
	<note>Separation of the Monotone NC Hierarchy</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
		<imprint>
			<publisher>Pebbling</publisher>
		</imprint>
		<respStmt>
			<orgName>IBM Watson Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Pudlák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<title level="m">Lower bounds for DLL algorithms for k-SAT, Proceedings of SODA 2000</title>
		<imprint>
			<biblScope unit="page" from="128" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Unprovability of Lower Bounds on Circuit Size in Certain Fragments of Bounded Arithmetic</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Izvestia of the RAN</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="201" to="222" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Lower Bounds for the Polynomial Calculus</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="291" to="324" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Natural Proofs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proc. of the 26th STOC 1994</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="204" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Read-Once Branching programs, rectangular proofs of the pigeonhole principle and the transversal calculus</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Razborov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 29th STOC 1997</title>
		<meeting>of the 29th STOC 1997</meeting>
		<imprint>
			<biblScope unit="page" from="739" to="748" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Selman: personal communication</title>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the Complexity of Derivation in Propositional Calculus</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Tseitin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Constructive Mathematics and Mathematical Logic</title>
		<meeting><address><addrLine>New-York-London</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1968">1968</date>
			<biblScope unit="page" from="115" to="125" />
		</imprint>
	</monogr>
	<note>Part 2, Consultants Bureau</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hard Examples for Resolution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Urquhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="209" to="219" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The Complexity of Propositional Proofs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Urquhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Bulletin of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="425" to="467" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
