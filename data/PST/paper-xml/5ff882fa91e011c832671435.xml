<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SAVIOR: Towards Bug-Driven Hybrid Testing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yaohui</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<settlement>Baidu</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peng</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jun</forename><surname>Xu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Stevens Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shengjian</forename><surname>Guo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rundong</forename><surname>Zhou</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yulong</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Tao</forename><surname>Wei</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Long</forename><surname>Lu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<settlement>Baidu</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SAVIOR: Towards Bug-Driven Hybrid Testing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DA8EA88F5644F805D6EFDE22D3C98AED</idno>
					<idno type="DOI">10.1109/SP40000.2020.00002</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Hybrid testing combines fuzz testing and concolic execution. It leverages fuzz testing to test easy-to-reach code regions and uses concolic execution to explore code blocks guarded by complex branch conditions. As a result, hybrid testing is able to reach deeper into program state space than fuzz testing or concolic execution alone. Recently, hybrid testing has seen significant advancement. However, its code coverage-centric design is inefficient in vulnerability detection. First, it blindly selects seeds for concolic execution and aims to explore new code continuously. However, as statistics show, a large portion of the explored code is often bug-free. Therefore, giving equal attention to every part of the code during hybrid testing is a non-optimal strategy. It slows down the detection of real vulnerabilities by over 43%. Second, classic hybrid testing quickly moves on after reaching a chunk of code, rather than examining the hidden defects inside. It may frequently miss subtle vulnerabilities despite that it has already explored the vulnerable code paths.</p><p>We propose SAVIOR, a new hybrid testing framework pioneering a bug-driven principle. Unlike the existing hybrid testing tools, SAVIOR prioritizes the concolic execution of the seeds that are likely to uncover more vulnerabilities. Moreover, SAVIOR verifies all vulnerable program locations along the executing program path. By modeling faulty situations using SMT constraints, SAVIOR reasons the feasibility of vulnerabilities and generates concrete test cases as proofs. Our evaluation shows that the bug-driven approach outperforms mainstream automated testing techniques, including state-of-the-art hybrid testing systems driven by code coverage. On average, SAVIOR detects vulnerabilities 43.4% faster than DRILLER and 44.3% faster than QSYM, leading to the discovery of 88 and 76 more unique bugs, respectively. According to the evaluation on 11 well fuzzed benchmark programs, within the first 24 hours, SAVIOR triggers 481 UBSAN violations, among which 243 are real bugs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Software inevitably contains defects <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b64">64]</ref>. A large amount of these defects are security vulnerabilities that can be exploited for malicious purposes <ref type="bibr" target="#b54">[54]</ref>. This type of vulnerable code has become a fundamental threat against software security. Contributed from both academia and industry, automated software testing techniques have gained remarkable advances in finding software vulnerabilities. In particular, people have widely used fuzz testing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b68">68]</ref> and concolic execution <ref type="bibr" target="#b51">[51,</ref><ref type="bibr" target="#b59">59]</ref> to disclose a great amount of vulnerabilities every year. Nevertheless, the inherent limitations of these two techniques impede their further applications. On one hand, fuzz testing quickly tests a program, but it hardly explores code regions guarded by complex conditions. On the other hand, concolic execution excels at solving path conditions but it frequently directs the execution into code branches containing a large number of execution paths (e.g., loop). Due to these shortcomings, using fuzz testing or concolic execution alone often ends with large amounts of untested code after exhausting the time budget. To increase code coverage, recent works have experimented the idea of hybrid testing, which combines both fuzz testing and concolic execution <ref type="bibr" target="#b47">[47,</ref><ref type="bibr" target="#b66">66,</ref><ref type="bibr" target="#b73">73]</ref>.</p><p>The goal of hybrid testing is to utilize fuzzing in path exploration and leverage concolic execution to solve hardto-resolve conditions. A hybrid approach typically lets fuzz testing run as much as possible. When the fuzzer barely makes any progress, the hybrid controller switches to the concolic executor which re-runs the generated seeds from fuzzing. During the run, the concolic executor checks each conditional branch to see whether its sibling branches remain untouched. If so, the concolic executor solves the constraints of the new branch and contributes a new seed for fuzzing. In general, this hybrid approach guides the fuzzer to new regions for deeper program space exploration.</p><p>As shown in recent works <ref type="bibr" target="#b66">[66,</ref><ref type="bibr" target="#b73">73]</ref>, hybrid testing creates new opportunities for higher code coverage. However, its coverage-driven principle unfortunately results in inefficiency when the end goal is vulnerability detection. Two key issues cause such inefficiency. First, existing approaches value all the seeds from fuzzing equally. However, the code regions reachable by a number of seeds might lack vulnerabilities and testing them is expensive (e.g., constraint solving and extra fuzzing). Consequently, hybrid testing often exhausts the assigned time budget way before it finds any vulnerability. Second, hybrid testing could fail to identify a vulnerability even if it reaches the vulnerable code via the correct path. This is because hybrid testing primarily concentrates on covering the encountered code blocks in the manner of random exercise. This strategy oftentimes has low chances to satisfy the subtle conditions to reveal a vulnerability.</p><p>In this work, we design and implement SAVIOR (abbreviation for Speedy-Automatic-Vulnerability-Incentivized-ORacle), a hybrid, bug-driven testing method. To fulfill this goal, we use two novel techniques in SAVIOR:</p><p>Bug-driven prioritization: Instead of running all seeds without distinction in concolic execution, SAVIOR prioritizes those that have higher possibilities of leading to vulnerabilities. Specifically, before the testing, SAVIOR analyzes the source code and statically labels the potentially vulnerable locations in the target program. Here SAVIOR follows existing methods <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b34">35]</ref> to conservatively label all suspicious locations. Moreover, SAVIOR computes the set of basic blocks reachable from each branch. During dynamic testing, SAVIOR call void @llvm.memset.p0i8.i64(i8* bitcast (void (%struct.msg_ds*)* @bug to i8*), i8 0, i64 %7, i32 4, i1 false) (a) A simplified version of the packet-parsing code in tcpdump-4.9.2, in which pcap_handler2 contains vulnerabilities. (c) The path followed by a seed that matches neither LINKTYPE1 nor LINKTYPE2.</p><note type="other">,</note><p>Fig. <ref type="figure">1:</ref> A demonstrative example of hybrid testing. Figure <ref type="figure">1a</ref> presents the code under test. Figure <ref type="figure">1b</ref> and 1c are the paths followed by two seeds from the fuzzer. Their execution follows the red line and visits the grey boxes. Note that the white boxes connected by dotted lines are non-covered code.</p><p>prioritizes the concolic execution seeds that can visit more important branches (i.e., branches whose reachable code has more vulnerability labels). Intuitively, those branches may guard higher volumes of vulnerabilities and hence, prioritizing them could expedite the discovery of new vulnerabilities. As we will show in Section V, this prioritization enables SAVIOR to outperform DRILLER <ref type="bibr" target="#b66">[66]</ref> and QSYM <ref type="bibr" target="#b73">[73]</ref> with a 43.4% and 44.3% increase in bug discovering rate, respectively.</p><p>Bug-guided verification: Aside from accelerating vulnerability detection, SAVIOR also verifies the labeled vulnerabilities along the program path traversed by the concolic executor. Specifically, SAVIOR synthesizes the faulty constraint of triggering each vulnerability on the execution path. If such constraint under the current path condition is satisfiable, SAVIOR solves the constraint to construct a test input as the proof. Otherwise, SAVIOR proves that the vulnerability is infeasible on this path, regardless of the input. This SMTsolving based strategy, as demonstrated in Section V, enables DRILLER, QSYM, and SAVIOR to disclose not only all the listed bugs but also an additional group of bugs in LAVA-M <ref type="bibr" target="#b35">[36]</ref>. Besides, it facilitates the three hybrid tools to find at least 22.2%, 25%, 4.5% more UBSan violations. This work is not the first one that applies hybrid testing to vulnerability detection. However, to the best of our knowledge, SAVIOR is the first work that explores bug-driven hybrid testing. On one hand, SAVIOR concentrates on software code that contains more potential vulnerabilities. This design not only brings faster coverage of vulnerabilities but also decreases the testing cost of the code that is less likely vulnerable. On the other hand, SAVIOR validates the vulnerabilities by the objective proofs of existence. In contrast, traditional hybrid testing methods can easily miss subtle cases. Moreover, the two proposed techniques are not limited to SAVIOR itself since they are general enough for other systematic software analysis methods. We will discuss the details in Section III. In summary, we make the following contributions.</p><p>• We design SAVIOR, a bug-driven hybrid testing technique. It substantially enhances hybrid testing with bugdriven prioritization and bug-guided verification.</p><p>• We build SAVIOR and show that our implementation can scale to a diverse set of real-world software.</p><p>• We demonstrate the effectiveness of SAVIOR by a comprehensive evaluation. In total, SAVIOR discovers 481 unique security violations in 11 well-studied benchmarks. On average, SAVIOR detects vulnerabilities 43.4% faster than DRILLER and 44.3% faster than QSYM, leading to the discovery of 88 and 76 more security violations in 24 hours. The rest of this paper is organized as follows. Section II states the background of hybrid testing and motivates our research. Section III and Section IV present the design and implementation of SAVIOR in detail. Section V evaluates the core techniques of SAVIOR. Section VI summarizes the related work. Finally, we conclude this work in Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND AND MOTIVATION</head><p>This work is motivated by the limitations of hybrid testing in vulnerability detection. In this section, we first introduce the background of hybrid testing and then demonstrate the limitations by two examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Hybrid Testing</head><p>Hybrid testing combines fuzz testing and concolic execution to achieve high code coverage. For the ease of understanding, we use the example in Figure <ref type="figure">1</ref> to explain how it works. The explanation is based on Driller <ref type="bibr" target="#b66">[66]</ref> since it has been the de facto implementation of hybrid testing.</p><p>The example in Figure <ref type="figure">1</ref> is taken from tcpdump-4.9.2. Figure <ref type="figure">1a</ref> shows the code -it first uses the link-layer type from input to select a pcap handler and then uses the handler to dissect packets. Our objective is to test the entry function parse_pcap and reach the vulnerable function pcap_handler2.</p><p>In the test, we assume hybrid testing starts with a seed that executes the path shown in Figure <ref type="figure">1b</ref>. After that, the fuzzer mutates the seed to run a second path shown in Figure <ref type="figure">1c</ref>. It then, however, fails to synthesize inputs that match the packet type at line 20 and the link-layer type at line 10, due to the huge mutation space (2 32 possibilities). This situation prevents the fuzzer from testing the remaining code and makes hybrid testing switch to concolic execution.</p><p>After executing the seed that covers the path in Figure <ref type="figure">1b</ref>, the concolic executor backtracks to the branch statement at line 20. Solving the input packet_type to PACKET1 by a SMT solver, the executor generates a new seed to cover that branch. Then, the hybrid controller suspends the concolic execution and resumes the fuzzer. Guided by the new seed, the fuzzer tests packet_handler1 and switches back to concolic execution after that. This time, the concolic executor runs the seed, following the path in Figure <ref type="figure">1c</ref>. After solving the branch condition at line 10, it generates a seed for the flow from line 10 to line 11. Further fuzz testing can finally reach the vulnerable code in pcap_handler2.</p><p>Note that the testing processes by different hybrid tools may vary from the above description. For instance, QSYM <ref type="bibr" target="#b73">[73]</ref> keeps running concolic execution instead of invoking it in an interleaved manner. Despite those implementation differences, existing tools share a similar philosophy on scheduling the seeds to concolic execution. That is, they treat the seeds indiscriminately <ref type="bibr" target="#b66">[66,</ref><ref type="bibr" target="#b73">73]</ref>, presumably assuming that these seeds have equal potentials in contributing to new coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Motivation</head><p>Inefficiency in Covering Vulnerable Code: Although hybrid testing specializes in coverage-driven testing, it still needs substantial time to saturate hard-to-reach code compartments, which often overspends the time budget. To discover more vulnerabilities in a limited time frame, an intuitive way is to prioritize the testing of vulnerable code. However, the current hybrid testing method introduced in Section II-A does not meet this requirement.</p><p>Consider the example in Figure <ref type="figure">1</ref>, where concolic execution chronologically runs the seeds to explore the paths shown in Figure <ref type="figure">1b</ref> and Figure <ref type="figure">1c</ref>. This sequence indeed postpones the testing of the vulnerable function pcap_handler2. The delay can be significant, because concolic execution runs slowly and the fuzz testing on packet_handler1 may last a long time. In our experiments 1 , DRILLER spends minutes on reaching pcap_handler2 with the aforementioned schedule. However, if it performs concolic execution first on the path in Figure <ref type="figure">1c</ref>, the time can reduce to seconds.</p><p>Not surprisingly, the delayed situations frequently happen in practice. As we will show in Section V, on average this defers DRILLER and QSYM to cover vulnerabilities by 43.4% and 44.3%, leading to reduced efficiency in vulnerability finding. Fig. <ref type="figure">2:</ref> A demonstrative example of limitation in finding defects by existing hybrid testing. This defect comes from objdump-2.29 <ref type="bibr" target="#b14">[15]</ref>.</p><p>Deficiency in Vulnerability Detection: Hybrid testing often fails to identify a vulnerability even if it approaches the vulnerable location along the right path. Figure <ref type="figure">2</ref> demonstrates an integer overflow in objdump-2.29. At line 12, the program copies a value from sec to section→size. Next, this value is used as the size of a memory allocation request at line 15. By carefully handcrafting the input, an adversary can make section→size be the value 2 32 -1 on 32-bit systems or 2 64 -1 on 64-bit systems. This wraps section→size+1 around to 0 and makes malloc return a zero-byte buffer. When the buffer is further used, a segfault or a memory leak would occur.</p><p>In this example, hybrid testing can quickly generate a seed to hit line 15. However, it could barely trigger the integer overflow. As the program enforces no constraints on the input bytes that propagate to section→size, hybrid testing can only do random mutation to synthesize the extreme value(s). Taking into account the tremendous possibility space (2 32 or 2 64 ), the mutation is unlikely to succeed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. DESIGN</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Core Techniques</head><p>The design of SAVIOR is bug-driven, aiming to find bugs faster and more thoroughly. We propose two techniques to achieve the goal: bug-driven prioritization and bug-guided verification. Below we present an overview of our techniques.</p><p>Bug-driven prioritization: Recall that classic hybrid testing blindly schedules the seeds for concolic execution, without weighing their bug-detecting potentials. This can greatly defer the discovery of vulnerabilities. To remedy this limitation, SAVIOR collects information from the target source code to prioritize seeds which have higher potentials to trigger vulnerabilities. This approach, however, needs to predict the amount of vulnerabilities that running concolic execution on a seed could expose. The prediction essentially depends on two prerequisites: R1 -A method to assess the reachable code regions after the concolic execution on a seed and R2 -A Fig. <ref type="figure">3</ref>: An example showing how to estimate the bug-detecting potential of a seed. In this example, the seed follows the path b1-&gt;b2-&gt;b3-&gt;b4. Basic block b5 and b7 are unexplored and they can reach L 1 and L 2 UBSan labels, respectively. They have been attempted by constraint solving for S 1 and S 2 times. The final score for this seed is e -0.05S 1 ×L1+e -0.05S 2 ×L2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>.</p><p>metric to quantify the amount of vulnerabilities in a chunk of code. SAVIOR fulfills them as follows.</p><p>To meet R1, SAVIOR approximates the newly explorable code regions based on a combination of static and dynamic analysis. During compilation, SAVIOR statically computes the set of reachable basic blocks from each branch. At runtime, SAVIOR identifies the unexplored branches on the execution path of a seed and calculates the basic blocks that are reachable from those branches. We deem that these blocks become explorable code regions once the concolic executor runs that seed.</p><p>To meet R2, SAVIOR utilizes UBSan <ref type="bibr" target="#b20">[21]</ref> to annotate three types of potential bugs (as shown in Table <ref type="table">I</ref>) in the program under testing. It then calculates the UBSan labels in each code region as the quantitative metric for R2. As UBSan's conservative instrumentation may generate dummy labels, SAVIOR incorporates a static filter to safely remove useless labels. We discuss the details of this method in Section III-B1.</p><p>The above two solutions together ensure a sound analysis for identifying potential bugs. First, our static reachability analysis, as described in Section III-B1, is built upon a sound algorithm. It over-approximates all the code regions that may be reached from a branch. Moreover, UBSan adopts a conservative design, which counts all the operations that may lead to the undefined behavior issues listed in Table I <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b34">35]</ref>. Facilitated by the two aspects of soundness, we can avoid mistakenly underrating the bug-detecting potential of a seed.</p><p>Following the two solutions, SAVIOR computes the importance score for each seed as follows. Given a seed with n unexplored branches {e 1 , e 2 , . . . , e n }, SAVIOR calculates the UB-San labels in the code that are reachable from these branches, respectively denoted as {L 1 , L 2 , . . . , L n }. Also note that, in the course of testing, SAVIOR has made {S 1 , S 2 , . . . , S n } attempts to solve those branches. With these pieces of information, SAVIOR evaluates the importance score of this seed with a weighted average 1 n × n i=1 e -0.05Si ×L i . L i represents the potential of the i th unexplored branch. We penalize L i with e -0.05Si to monotonically decrease its weight as the attempts to solve this branch grow. The rationale is that more failed Fig. <ref type="figure">4</ref>: Solving the integer overflow in Figure <ref type="figure">2</ref>. This shows the case in a 32-bit system, but it applies to 64-bit as well.</p><p>attempts (usually from multiple paths) indicate a low success possibility on resolving the branch. Hence, we decrease its potential so that SAVIOR can gradually de-prioritize hardto-solve branches. Lastly, SAVIOR takes the average score of each candidate branches in order to maximize the bug detection gain per unit of time. To better understand this scoring method, we show an example and explain the score calculation in Figure <ref type="figure">3</ref>. This scoring method is to ensure that SAVIOR always prioritizes seeds leading to more unverified bugs, while in the long run it would not trap into those with hard-to-solve branch conditions. First, it conservatively assesses a given seed by the results of sound reachability and bug labeling analysis. A seed which leads to more unexplored branches where more unverified bugs can be reached from will earn a higher score. Second, it takes into account runtime information to continuously improve the precision of the assessment. This online refinement is important because statically SAVIOR may hardly know whether a branch condition is satisfiable or not. Utilizing the history of constraint solving attempts, SAVIOR can decide whether a seemingly high-score branch is worth more resources in the future. As shown by our evaluation in Section V, this scoring scheme significantly accelerates the detection of UBSan violations, which empirically supports the effectiveness of our design. Referring to our motivating example in Figure <ref type="figure">1</ref>, the function packet_handler1 has few UBSan labels while pcap_handler2 contains hundreds of labels. Hence, the seed following Figure <ref type="figure">1b</ref> has a lower score compared to the other seed which runs the path in Figure <ref type="figure">1c</ref>. This guides SAVIOR to prioritize the latter seed, which can significantly expedite the exploration of vulnerable code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bug-guided verification:</head><p>This technique also ensures a sound vulnerability detection on the explored paths that reach the vulnerable sites. Given a seed from fuzz testing, SAVIOR executes it and extracts the label of each vulnerability along the execution path. After that, SAVIOR verifies the predicates implanted in each label by checking the satisfiability under the current path condition -if the predicate is satisfiable then its corresponding vulnerability is valid. This enables SAVIOR to generate a proof of either vulnerability or non-existence along a specific program path. Note that in concolic execution, many new states with new branch constraints will be created.</p><p>q Analysis q Instrument (AFL) q Fuzzing q Coverage Test q Bug-driven Prioritization Fig. <ref type="figure">5</ref>: System architecture of SAVIOR.</p><formula xml:id="formula_0">(KLEE) q Constraint Solving q Bug-</formula><p>SAVIOR will prioritize the constraint solving for states who require bug-guided verification. Going back to the example in Figure <ref type="figure">2</ref>, classic hybrid testing misses the integer overflow at line 15. In contrast, SAVIOR is able to identify it with bug-guided verification. Aided by the Clang sanitizer <ref type="bibr" target="#b20">[21]</ref>, SAVIOR instruments the potential overflows in a solver-friendly way (i. e., the predicate of triggering this overflow is section-&gt;size + 1 &gt; 0xffffffff). Due to the limited space, we present the instrumented IR code in Figure <ref type="figure">10</ref> at Appendix A. As demonstrated in Figure <ref type="figure">4</ref>, following a seed to reach the integer overflow location, SAVIOR tracks that the value of section-&gt;size relies on a four-byte field in the input. By solving the vulnerability predicate, SAVIOR generates a witness value 0xffffffff and triggers the vulnerability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. System Design</head><p>Figure <ref type="figure">5</ref> depicts the overall architecture of SAVIOR. It consists of a compiling tool-chain built upon Clang and LLVM, a fuzzer derived from AFL, a concolic executor ported from KLEE, and a hybrid coordinator responsible for the orchestration. We explain these components in details in the following sections.</p><p>1) The Compilation Tool-chain: SAVIOR's compilation tool-chain has multiple purposes including vulnerability labeling, control flow reachability analysis, and the targets building of different components.</p><p>Sound Vulnerability Labeling: In our design, we use Clang's Undefined Behavior Sanitizer (UBSan) <ref type="bibr" target="#b20">[21]</ref> to label different families of potential bugs 2 . Table <ref type="table">I</ref> summarizes those families used in SAVIOR and the operations pertaining to them.</p><p>We ignore other bug types listed in UBSan (e.g., misaligned reference) since they are less likely to cause security issues. For each inserted label, we patch the Clang front-end to attach a !saviorBugNum metadata, aiding the reachability analysis that we will shortly discuss.</p><p>As explained in Section III-A, UBSan over-approximates the potential vulnerabilities. This approximation ensures soundness since it never misses true bugs. UBSan also models the conditional triggers of the labeled bugs as shown in Table <ref type="table">I</ref>. E.g., out-of-bound (OOB) array access happens when the index x is not between zero and array size minus 1. At the time of bug-guided verification, SAVIOR solves each triggering condition to produce a witness of the bug or, prove that the bug never happens on current path in terms of the unsatisfiable 2 Clang supports enabling checks on each individual bug family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UB Families</head><p>UBSan Labeling Details Operation Condition Out-of-bound array access array</p><formula xml:id="formula_1">[x] x &lt; 0 ∨ x ≥ size(array) Oversized shift x y, x y y &lt; 0 ∨ y ≥ n Signed integer overflow x ops y x ops y / ∈ [-2 n-1 , 2 n-1 -1] Unsigned integer overflow x opu y x opu y &gt; 2 n -1</formula><p>TABLE I: Families of potential bugs that SAVIOR enables UBSan to label. Here, x, y are n-bit integers; array is an array, the size of which is specified as size(array); op s and op u refers to binary operators +, -, ×, ÷, % over signed and unsigned integers, respectively. condition. In Figure <ref type="figure">10</ref> at Appendix A, we present the IR with instrumented UBSan checks for the defect shown in Figure <ref type="figure">2</ref>. SAVIOR uses UBSan by default, while other labeling methods may also apply if they meet the following two properties. First, they can comprehensively annotate the potential vulnerabilities. Second, they can synthesize the triggering condition of each labeled vulnerability. Note that such condition must have data dependency on the program input. Otherwise, our concolic execution cannot correlate the input with the vulnerable conditions and hence, has no guidance for bugguided verification. For instance, the AddressSanitizer <ref type="bibr" target="#b62">[62]</ref> builds checks upon the status of its own red-zone, which is not applicable to SAVIOR at the moment.</p><p>UBSan's conservative approximation inevitably introduces false positives and might mislead SAVIOR's prioritization. In practice, we incorporate a static counter-measure to reduce fake labels. Specifically, we trim a label when all the following requirements hold: 1) The label's parent (basic block) is its immediate dominator <ref type="bibr" target="#b65">[65]</ref>; 2) The IR variables involved in the vulnerability conditions are not re-defined between the label and its parent; 3) The parent basic block has constraints that conflict with the vulnerability conditions, and these constraints are enforced by constant values. The first two points ensure that the constraints added by the parent will persist upon reaching the label, and the third point indicates that the conflict always arises, regardless of the input and the execution path. Therefore, we can safely remove this label. For instance, the code above has two labels that meet the three requirements. In this example, the variable i ranges from 0 to MAX, meaning that neither the array access at line 3 can be out-of-bound nor the self increment at line 4 can cause an integer overflow. SAVIOR hence removes the two labels. In Table <ref type="table" target="#tab_18">IX</ref> at Appendix A, we summarize the number of labels that are removed from each of our benchmark programs. On average, we can conservatively reduce 5.36% of the labels.</p><p>Reachability Analysis: This analysis counts the number of vulnerability labels that can be forwardly reached by each basic block in the program control flow graph (CFG). It proceeds with two phases. The first step constructs an inter-procedure CFG. The construction algorithm is close to the method implemented in SVF <ref type="bibr" target="#b67">[67]</ref>. It individually builds intraprocedure CFGs for each function and then bridges functionlevel CFGs by the caller-callee relation. To resolve indirect calls, our algorithm iteratively performs Andersen's point-to analysis and expands the targets of the calls. This prevents SAVIOR from discarding aliasing information of indirect calls and therefore, our prioritization would not miscount the number of vulnerability labels. By examining the CFGs, we also extract the edge relations between a basic block and its children for further use in the hybrid coordinator.</p><formula xml:id="formula_2">BB Bug#: 3 UBSan … … UBSan … UBSan … …</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R e a c h a b le c o d e</head><p>Fig. <ref type="figure">6</ref>: A demonstrative example of reachability analysis. The target BB can "reach" 3 UBSan labels.</p><p>The second step is to calculate the UBSan labels that are reachable from each basic block in the constructed inter-procedure CFG. Specifically, we identify the regions of code that a basic block can reach and count the number of UB-San labels in those regions. In SAVIOR, we deem this number as the importance metric of that basic block and use it for bug-driven prioritization. For example, in Figure <ref type="figure">6</ref> the basic block BB can reach 8 other basic blocks while 3 of them have UBSan labels. Thereby we output 3 as the number of reachable UBSan labels for BB. Note that each basic block at most has one label after Clang's compilation.</p><p>Target Building: After the labeling and the reachability analysis, SAVIOR's compiling tool-chain begins its building process. It compiles three binaries from the source code -a fuzzing-binary for the fuzzer, a SAVIOR-binary for the coordinator, and a LLVM bitcode file for the concolic executor. In particular, the SAVIOR-binary is instrumented to print the unique IDs of the executed basic blocks. With this design, SAVIOR completely decouples the fuzzer, the concolic executor and the coordinator, thus it supports quick replacement of any components.</p><p>2) The Coordinator: The coordinator bridges the fuzzer and the concolic executor. It keeps polling seeds from the fuzzer's queue and prioritizes those with higher importance for concolic execution. We explain the details as follows.</p><p>Bug-driven Prioritization: In a polling round, the coordinator operates the new seeds in the fuzzer's queue after last round. Each seed is fed to the SAVIOR-binary and the coordinator updates two pieces of information based on the execution result. First, it updates the global coverage information. The coverage computation here follows AFL's original approach. That is, we take the hit counts of an edge in the following ranges as different coverage: <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7]</ref>, <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b14">15]</ref>, <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b30">31]</ref>, <ref type="bibr" target="#b31">[32,</ref><ref type="bibr">127]</ref>, [128, ∞). Second, the coordinator records the sequence of basic blocks visited by each seed. Using the updated coverage information, the coordinator assigns a score to each seed following the scheme presented in Section III-A. Here, we re-score all the seeds except those already tested by our concolic executor, since the coverage information is dynamically adjusted.</p><p>Finally, the coordinator selected the top-ranked seeds and feed them into the input queue of the concolic executor. If two seeds have the same score, the coordinator prefers the seed with the +cov property. +cov indicates that the seed brings new code coverage.</p><p>Post-processing of Concolic Execution: Going beyond seed scheduling for concolic execution, the coordinator also need to triage the new seeds generated by the concolic executor for the fuzzer. First, it re-runs the new seeds and retains those who provide new coverage or can reach uncovered bug labels. As a result, SAVIOR transfers the valuable test cases from the concolic executor to the fuzzer.</p><p>Second, the coordinator updates the number of solving attempts upon uncovered branches. If a branch remains uncovered, its solving attempts would be increased by 1. As such, a branch having a much higher solving attempt value will be de-prioritized.</p><p>3) The Concolic Executor: The concolic executor replays the seeds scheduled by the coordinator and chooses to solve branch conditions based on coverage information. In addition, it also performs bug-guided verification.</p><p>Independent Coverage Scheme: When encountering a branch instruction the concolic executor needs to decide whether to solve this branch's condition. An intuitive design is to reuse the coverage information from the coordinator. However, since our coverage scheme is ID based, yet as KLEE invokes a group of transformations on the target bitcode, this leads to numerous mismatches between the edge IDs in the SAVIORbinary and the KLEE bitcode. To tackle this problem, we opt to use KLEE's internal coverage information to better decouple the concolic executor and other components.</p><p>Fork Server Mode: Before running a seed, KLEE needs to perform a group of initialization, including bitcode loading, library bitcode linking, and global data preparation to place the program under testing into the virtual machine. This initialization process, however, typically takes a long time on large bitcode files. For instance, the initialization time for tcpdump is usually several times longer than the actual concolic execution time. To address this issue, we introduce an optimization named fork server mode for the KLEE concolic executor (as shown in Figure <ref type="figure" target="#fig_3">7</ref>). Technical details are explained in Section IV.</p><p>Bug-guided Verification: Our concolic executor also performs bug-guided verification. Once an non-covered vulnerability label is reached, we endeavor to solve the triggering constraint following the current path. If the solving succeeds, KLEE generates a seed as the proof of the vulnerability.</p><p>In certain cases, the path constraints may conflict with the vulnerability triggering conditions, while that vulnerability can indeed happen following the same path (with fewer constraints). QSYM <ref type="bibr" target="#b73">[73]</ref> summarizes this issue as the overconstraint problem. We adopt QSYM's optimistic solving strategy only on solving the vulnerability conditions. However, the relaxed-constraint may also produce a false positive, and we do not count a vulnerable label as being covered through relaxed-constraint solving.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Timeout on Concolic Execution:</head><p>To prevent the concolic execution from hanging on localized code regions (e.g., , deep loops and blocking IO), the concolic executor usually needs a time threshold while running a seed. QSYM adjusts this timing budget by watching AFL's status. If the number of hanging seeds increases, QSYM increases the timeout (up to 10 minutes). We set the timeout to be proportional to the number of uncovered branches that a seed can reach. The rationale is that those seeds need more time for constraint solving and such setting benefits higher bug coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. IMPLEMENTATION</head><p>We have implemented SAVIOR, which can be applied to software as sophisticated as Baidu's Apollo Autonomous Driving System <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b36">37]</ref>. SAVIOR consists of four major components: a compiling tool-chain built on top of Clang and LLVM-4.0, a fuzzing component based on AFL-2.5b <ref type="bibr" target="#b1">[2]</ref>, a concolic executor built atop KLEE <ref type="bibr" target="#b26">[27]</ref> (with LLVM-3.6), and a python middle-ware which coordinates the fuzzing component and the concolic executor. In total, our implementation has about 3.3K lines of python code and 4K lines of C/C++ code. SAVIOR can run on both 32-bit and 64-bit systems, and it can support both 32-bit and 64-bit targets. In the following, we discuss the important implementation details.</p><p>Concolic Executor: We develop our concolic executor based on KLEE-3.6. The original KLEE aims at full symbolic execution, and it does not support concolic execution. We port a concolic executor from KLEE's symbolic executor. Specifically, the concolic executor attaches the concrete input as the assignment property in the initial state. It then symbolically interprets each instruction as KLEE originally does. On reaching a conditional statement, it always follows the branch that matches the concrete input. For the other branch, if not covered, the concolic executor solves the conditions and generate a corresponding testcase. The state following that branch is then immediately terminated. When generating the seed, our concolic executor copies the un-constrained bytes from the input, instead of padding with random values.</p><p>Another limitation of KLEE is that the initialization phase is notoriously time-consuming. To overcome this, we introduce a fork server mode. In a run, KLEE first sets up the environments with bitcode loading, library linking, and preparing for globals and constants. These are then followed by the initialization of an Executor. By default, the Executor executes one seed and then destructs itself. In our implementation, after the execution of one seed, we clean up any stateful changes introduced in last execution (including destructing the memory manager, clearing the global data objects, and erasing all the remaining states). Then we reuse the Executor to run a new seed from the input queue. In this mode, we avoid repeating the lengthy environments setup.</p><p>Recall that we invoke UBSan to label potentially vulnerable operations. At the IR level, UBSan replaces those operations with LLVM intrinsic functions, which are incomprehensible by KLEE. We replace those intrinsic functions with general LLVM IR so that KLEE can execute without exceptions. The replacements follow those that KLEE already enforced <ref type="bibr" target="#b9">[10]</ref>.</p><p>By default, KLEE redirects un-modeled external functions (e.g., system calls) to the native code. This causes two issues. First, KLEE is unaware of their effects on the symbolic address space, which can interrupt memory operations. For instance, the function strdup allocates a new buffer and copies data from the source to this buffer. However, KLEE cannot capture this allocation due to the lack of modeling. On future accesses to this buffer, KLEE will throw an out-of-bound access error. There are many similar cases, such as getenv. We extend KLEE's environment model to include the symbolic versions of those functions. Second, KLEE concretizes the data passed to the external functions and adds constant constraints on such data for future execution. However, this may over-constraint the concretized variables. For instance, KLEE concretizes the data written to standard output or files. This leads to overconstraints -When the concretized data is later used in constraint solving, KLEE will not be able to find a satisfying solution. To address this issue, we prevent KLEE from adding constraints on concretization. This scheme, following the design of S2E <ref type="bibr" target="#b30">[31]</ref> and QSYM <ref type="bibr" target="#b73">[73]</ref>, ensures that we never miss solutions for non-covered branches.</p><p>Last but not least, stock KLEE provides limited support for software written in C++. Since a lot of the C++ programs rely on the standard C++ library (e.g., libstdc++ on Linux) but KLEE neither models this library nor supports the semantics of calls to this library. Therefore, KLEE frequently aborts the execution in the early stage of running a C++ program. We customize the GNU libstdc++ library to make it compilable and linkable to KLEE. Considering that many libstdc++ functions also access in-existent devices (e.g., Random), we also build models of those devices.  V. EVALUATION SAVIOR approaches bug-driven hybrid testing with the key techniques of bug-driven prioritization and bug-guided verification. In this section, we evaluate these techniques and our evaluation centers around two questions:</p><p>• With bug-driven prioritization, can hybrid testing find vulnerabilities quicker? • With bug-guided verification, can hybrid testing find vulnerabilities more thoroughly? To support our evaluation goals, we prepare two groups of widely-used benchmarks. The first group is the LAVA-M data-set <ref type="bibr" target="#b35">[36]</ref>. This data-set comes with artificial vulnerabilities, and the ground truth is provided. The second group includes a set of 8 real-world programs. Details about these programs are summarized in Table <ref type="table" target="#tab_10">V</ref>. All these programs have been extensively tested in both industry <ref type="bibr" target="#b15">[16]</ref> and academia <ref type="bibr" target="#b57">[57,</ref><ref type="bibr" target="#b66">66,</ref><ref type="bibr" target="#b73">73]</ref>. In addition, they represent a higher level of diversity in functionality and complexity.</p><p>Using the two benchmarks, we compare SAVIOR with the most effective tools from related families. To be specific, we take AFL <ref type="bibr" target="#b1">[2]</ref> as the baseline of coverage-based testing. As SAVIOR performs testing in a directed manner, we also include the state-of-the-art directed fuzzer, AFLGO <ref type="bibr" target="#b24">[25]</ref>. To handle complex conditions, recent fuzzing research introduces a group of new techniques to improve code coverage. From this category, we cover TFUZZ <ref type="bibr" target="#b56">[56]</ref> and ANGORA <ref type="bibr" target="#b28">[29]</ref>, because they are open-sourced and representatives of the state-ofthe-art. Finally, we also consider the existing implementations of hybrid testing, DRILLER <ref type="bibr" target="#b66">[66]</ref> and QSYM <ref type="bibr" target="#b73">[73]</ref>.</p><p>Note that the original DRILLER has problems of running many of our benchmarks, due to lack of system-call modeling or failure to generate test cases (even with the patch <ref type="bibr" target="#b5">[6]</ref> to support input from files). This aligns with the observations in <ref type="bibr" target="#b73">[73]</ref>. In the evaluation, we re-implement DRILLER on the top of SAVIOR. More specifically, it runs AFL as the fuzzing component and it invokes the concolic executor once the pending_favs attribute in AFL drops to 0. These implementations strictly follow the original DRILLER <ref type="bibr" target="#b6">[7]</ref>. Similar to the Angr-based concolic executor in DRILLER, our KLEE-based concolic executor focuses on generating new seeds to cover untouched branches. In addition, we keep the relaxed constraint solving and the fork-server mode. These two features increase the effectiveness and efficiency of DRILLER without introducing algorithmic changes.</p><p>In the following, we will explain the experimental setups and evaluation results for the two groups of benchmarks.</p><p>A. Evaluation with LAVA-M 1) Experimental Setup: In this evaluation, we run each of the fuzzers in Table <ref type="table" target="#tab_5">II</ref> with the four LAVA-M programs and we use the seeds shipped with the benchmark. For consistency, we conduct all the experiments on Amazon EC2 instances (Intel Xeon E5 Broadwell 64 cores, 256GB RAM, and running Ubuntu 16.04 LTS), and we sequentially run all the experiments to avoid interference. In addition, we assign each fuzzer 3 free CPU cores to ensure fairness in terms of computation resources. Each test is run for 24 hours. To minimize the effect of randomness in fuzzing, we repeat each test 5 times and report the average results.</p><p>In Table <ref type="table" target="#tab_5">II</ref>, we also summarize the settings specific to each fuzzer, including how we distribute the 3 CPU cores and the actions we take to accommodate those fuzzers. In LAVA-M, each artificial vulnerability is enclosed and checked in a call to lava_get (in-lined in our evaluation). We use these calls as the targets to guide AFLGO and we mark them as vulnerability labels to enable bug-driven prioritization in SAVIOR. In addition, as the vulnerability condition is hardcoded in the lava_get function, we naturally have support for bug-guided verification. Finally, for ANGORA, we adopt the patches as suggested by the developers <ref type="bibr" target="#b17">[18]</ref>.</p><p>2) Evaluation Results: In the left column of Figure <ref type="figure" target="#fig_4">8</ref>, we show how many vulnerabilities are reached over time by different fuzzers. The results demonstrate that all the fuzzers can instantly cover the code with LAVA vulnerabilities. However, as presented in the right column of Figure <ref type="figure" target="#fig_4">8</ref>, TFUZZ, ANGORA, DRILLER, QSYM, and SAVIOR are able to trigger most (or all) of the vulnerabilities while AFL and AFLGO can trigger few. The reason behind is that the triggering conditions of LAVA vulnerabilities are all in the form of 32-bit magic number matching. Mutation-based fuzzers, including AFL and AFLGo, can hardly satisfy those conditions while the other fuzzers are all featured with techniques to solve them.</p><p>Vulnerability Finding Efficiency: Despite TFUZZ, ANGORA, DRILLER, QSYM, and SAVIOR all trigger large numbers of LAVA vulnerabilities, they differ in terms of efficiency. TFUZZ quickly covers the listed vulnerabilities in base64 and uniq. This is attributable to that (1) TFUZZ can reach all the vulnerabilities with several initial seeds and (2) TFUZZ can transform the program to immediately trigger the encountered vulnerabilities. Note that we do not show the results of TFUZZ on md5sum and who, because TFUZZ gets interrupted because of a broken dependency <ref type="foot" target="#foot_1">3</ref> . For all the cases, ANGORA triggers the vulnerabilities immediately after its start. The main reason is that the "black-box function" pertaining to all LAVA vulnerabilities is f(x) = x and the triggering conditions are like f(x) == CONSTANT. ANGORA always starts evaluating such functions with x = CONSTANT and hence, it can instantly generate seeds that satisfy the vulnerability conditions. In the case of who, ANGORA does not find all the vulnerabilities because of its incomplete dynamic taint analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fuzzers</head><p>Fuzzing   Regarding the three hybrid tools, they trigger every vulnerability that their concolic executors encounter. In the cases of base64, uniq, and md5sum, their concolic executors can reach all the vulnerabilities with initial seeds. This explains why they all quickly trigger the listed vulnerabilities, regardless of their seed scheduling.</p><p>In the case of who, even though the fuzzing component quickly generates seeds to cover the vulnerable code, the concolic executor takes much longer to run those seeds. For instance, while executing the inputs from AFL, QSYM needs over 72 hours of continuous concolic execution to reach all the LAVA bugs in who. Differing from DRILLER and QSYM, SAVIOR prioritizes seeds that have a higher potential of leading to Lava bugs. As demonstrated by the results of who in Table <ref type="table" target="#tab_7">III</ref>, our technique of bug-driven prioritization indeed advances the exploration of code with more vulnerabilities. Note that DRILLER (with a random seed scheduling) moves faster than QSYM. This is because QSYM prioritizes concolic execution on small seeds, while reaching the vulnerabilities in who needs seeds with a larger size.</p><p>Vulnerability Finding Thoroughness: We further evaluate our bug-guided verification design. Specifically, we run the seeds generated by all the fuzzers with our concolic executor. In this experiment, we only perform constraint solving when a vulnerability condition is encountered. As shown in Table <ref type="table" target="#tab_8">IV</ref>, bug-guided verification facilitates all the fuzzers to not only cover the listed LAVA bugs but also disclose an extra group of Lava bugs. Due to limited space, those additionally identified bugs are summarized in   <ref type="bibr" target="#b15">[16]</ref> and academic researches <ref type="bibr" target="#b57">[57,</ref><ref type="bibr" target="#b66">66,</ref><ref type="bibr" target="#b73">73]</ref>. Since different seed inputs and execution options could lead to varying fuzzing results <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b58">58]</ref>, we follow existing works to use the seeds shipping with AFL or the vendors, as well as to configure the fuzzing options. Similar to our evaluation with LAVA-M, we conduct all the experiments on Amazon EC2 instances. To reduce randomness during testing, we run each test 5 times and report the average results. In addition, we leverage Mann Whitney U-test <ref type="bibr" target="#b53">[53]</ref> to measure the significance of our improvements, following the suggestion by George etc <ref type="bibr" target="#b49">[49]</ref>.</p><p>In this evaluation, we also prepare the setups that are specific to each fuzzing tool. These setups mostly follow Table <ref type="table" target="#tab_5">II</ref> except the following. First, we use UBSan labels as the target locations for AFLGO and as the guidance of bugdriven prioritization in SAVIOR. Second, to prevent ANGORA from terminating the fuzzing process once it encounters uninstrumented library functions, we follow suggestions from the developers and add the list of un-instrumented functions into ANGORA's dfsan_abilist.txt configuration file. Third, we do not include TFUZZ, because it does not function correctly on our benchmark programs due to issues in the aforementioned third-party component. Furthermore, we prepare these benchmark programs such that they are instrumented with UBSan for all fuzzers to ensure a fair comparison. This also means that bug-guided verification is enabled by default in DRILLER, QSYM, and SAVIOR.</p><p>2) Evaluation Results: In Figure <ref type="figure" target="#fig_15">9</ref>, we summarize the results of our second experiment. It shows the outputs over time from two metrics, including the number of triggered UBSan bugs and basic block coverage. In addition, we calculate the p-values for Mann Whitney U-test of SAVIOR vs. DRILLER and SAVIOR vs. QSYM. Note that we use the IDs of UBSan labels for de-duplication while counting the UBSan bugs, as each UBSan label is associated with a unique potential defect. In the following, we delve into the details and explain how these results testify our design hypotheses.</p><p>Vulnerability Finding Efficiency: As shown in Figure <ref type="figure" target="#fig_15">9</ref> (the left column of each program), SAVIOR triggers UBSan violations with a pace generally faster than all the other fuzzers. In particular, it outperforms DRILLER and QSYM in all the cases except djpeg. On average, SAVIOR discovers vulnerabilities 43.4% faster than DRILLER and 44.3% faster than QSYM. The low p-values (&lt; 0.05) <ref type="foot" target="#foot_2">4</ref> of Mann Whitney U-test well support that these improvements are statistically significant. Since the three hybrid tools only differ in the way of seed scheduling, these results strongly demonstrate that the scheduling scheme in SAVIORbug-driven prioritizationaccelerates vulnerability finding. In the case of djpeg, all six fuzzers trigger the same group of UBSan violations. This is because djpeg has a tiny code base, with which these fuzzers quickly saturate on code exploration. In addition, the conditions of those UBSan violations are simple that even mutation-based approaches can solve. For a better reference, we also summarize the number of triggered violations at the end of 24 hours in Table XII at Appendix A-D.</p><p>Going beyond, we examine the number of labels that are reached by different fuzzers. In Table <ref type="table" target="#tab_12">VI</ref>, we list the average results from our 24-hour tests. Not surprisingly, the hybrid tools cover higher volumes of UBSan labels than the ordinary fuzzers. This is likely because a hybrid tool can solve complex conditions, enabling the coverage on the code and labels behind. Among the hybrid tools, SAVIOR reaches 19.68% and 15.18% more labels than DRILLER and QSYM, respectively. Such results are consistent with the number of triggered UBSan violations. This also signifies that our bugdriven prioritization guides SAVIOR to spend more resources on code with richer UBSan labels. In the case of djpeg, SAVIOR nearly ties with the other tools. This is due to a similar reason as explained above.</p><p>We further find that the efficiency boost of SAVIOR in vulnerability finding is not due to high code coverage. As shown in Figure <ref type="figure" target="#fig_15">9</ref> (the right column for each program), we compare the code coverage of the six fuzzers. As demonstrated by the results, the efficiency of code coverage and UBSan violation discovery are not positively correlated. Particularly, in the case of tcpdump, libxml, tiff2pdf, objdump and jasper, SAVIOR covers code in a similar or even slower pace than DRILLER and QSYM (the high p-values also support that SAVIOR is not quicker). However, SAVIOR triggers UBSan violations significantly quicker in these cases. Such results validate the above hypothesis with high confidence.</p><p>Vulnerability Finding Thoroughness: In this experiment, we also measure the performance of bug-guided verification in enhancing the thoroughness of vulnerability finding. Specifically, we re-run the seeds from all the fuzzers with our concolic executor. In this test, we enable SAVIOR to do constraint solving only when encountering un-solved UBSan labels.</p><p>In Table <ref type="table" target="#tab_13">VII</ref>, we summarize the comparison results. For all the 8 programs, bug-guided verification facilitates different           fuzzers to trigger new violations. The average increase ranges from 4.5% (SAVIOR) to 61.2% (ANGORA). In particular, it aids ANGORA to trigger 82 new UBSan bugs in total. In the case of djpeg bug-guided verification does not help much. This is because djpeg has a relatively smaller code base and contains fewer vulnerability labels, making bug-guided verification less utilized. These results are further evidence that bug-guided verification can truly benefit fuzzing in terms of vulnerability finding thoroughness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Vulnerability Triage</head><p>The UBSan violations triggered by SAVIOR could lead to various consequences and some of them might be harmless. Therefore, we manually examine all the UBSan violations triggered by SAVIOR. These violations include those triggered in the 8 programs in Table V and also those from mjs, catdoc, and c++filt. We do not include the results of mjs, catdoc, and c++filt in the evaluation above, as all fuzzers trigger fewer than 10 UBSan violations. A small difference would result in a big variance in comparison.    Those logic errors consist of different categories, such as incorrect computation, wrong outputs, and polluted conditional variables. Among the 243 OOB and logic errors, 16 of them have been confirmed by the developers. Our further analysis so far reveals at least 25 of them are exploitable for goals such as information leak and control flow manipulation.</p><p>The remaining 238 cases are likely harmless according to our triage result. They mainly consist of the following categories: (1) the variables triggering UBSan violations are used as storage (e.g., int as char <ref type="bibr" target="#b3">[4]</ref>) instead of computationrelated objects; (2) the affected variables expire immediately after the violations; (3) the program already considers the case of UBSan violations and has handlers.</p><p>Case Studies: From each of the three categories (OOB, logic errors, and those without harm), we pick a case and explain the details here. All the cases have been fixed.</p><p>The first case is an OOB in readelf. The code is shown below. The variable inote.namesz is copied from input. By making it equal to 0, (inote.namesz -1) under-flows to the maximal unsigned value. It causes an OOB access to inote.namedata. The last case is harmless, as the program already considers overflow. This case locates in libxml. As shown below, with a special input, the variable okey can be overflowed. However, the program modulo okey with dict-&gt;size before using it, making the overflow harmless. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORKS</head><p>The lines of works mostly related to our work include advanced fuzzing, concolic execution, the state-of-the-art hybrid testing techniques, and those that facilitate guided testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Advanced Fuzzing</head><p>Many recent works focus on improving the capability of code exploration in fuzzing. CollAFL <ref type="bibr" target="#b39">[39]</ref> aims to reduce hash collision in coverage feedback to decrease false negatives. PTrix <ref type="bibr" target="#b29">[30]</ref> enables path-sensitive fuzzing based on efficient hardware tracing. TFUZZ <ref type="bibr" target="#b56">[56]</ref> transforms tested programs to bypass complex conditions and improve code coverage, and later uses a validator to reproduce the inputs that work for the original program. To generate high-quality seeds, ProFuzzer <ref type="bibr" target="#b72">[72]</ref> infers the structural information of the inputs. Along the line of seed generation, Angora <ref type="bibr" target="#b28">[29]</ref> assumes a black-box function at each conditional statement and applies gradient descent to find satisfying input bytes. This method is later improved by NEUZZ <ref type="bibr" target="#b63">[63]</ref> with a smooth surrogate function to approximate the behavior of the tested program. Compared with these approaches, SAVIOR takes the bugdriven guidance to maximize bug coverage and verifies the (non-)existence of these bugs in the explored paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Concolic Execution</head><p>Symbolic execution, a systematic approach introduced in the 1970s <ref type="bibr" target="#b46">[46,</ref><ref type="bibr" target="#b48">48]</ref> for program testing, has attracted new attention due to the advances in satisfiability modulo theory <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b40">40]</ref>. However, classic symbolic execution has the problems of high computation cost and path explosion. To tackle these issues, Sen proposes concolic execution <ref type="bibr" target="#b59">[59]</ref>, which combines the constraint solving from symbolic execution and the fast execution of concrete testing. Concolic execution increases the coverage of random testing <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b42">42]</ref> while also scales to large software. Hence, it has been adopted in various frameworks <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b60">60,</ref><ref type="bibr" target="#b61">61]</ref>. Recently, concolic execution is also widely applied in automated vulnerability detection and exploitation, in which the concolic component provides critical inputs by incorporating security-related predicates <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b27">28]</ref>.</p><p>However, concolic execution operates based on emulation or heavy instrumentation, incurring tremendous execution overhead. Purely relying on concolic execution for code exploration is less practical for large software that involves large amounts of operations. In contrast, hybrid testing runs fuzzing for code exploration and invokes concolic execution only on hard-to-solve branches. This takes advantage of both fuzzer's efficiency and concolic executor's constraint solving.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Hybrid Testing</head><p>Majundar et al. <ref type="bibr" target="#b51">[51]</ref> introduce the idea of hybrid concolic testing a decade ago. This idea offsets the deficiency of both random testing and concolic execution. Specifically, their approach interleaves random testing and concolic execution to deeply explore a wide program state space. Subsequent development reinforces hybrid testing by replacing random testing with guided fuzzing <ref type="bibr" target="#b55">[55]</ref>. This approach could rapidly contributing more high-quality seeds to concolic execution.</p><p>Recently, DRILLER <ref type="bibr" target="#b66">[66]</ref> engineers the state-of-the-art hybrid testing system. It more coherently combines fuzzing and concolic execution and can seamlessly test various software systems. Despite the advancement, DRILLER still achieves unsound vulnerability detection. DigFuzz <ref type="bibr" target="#b74">[74]</ref> is a more recent work that tries to better coordinate the fuzzing and concolic execution components. Using a Monte Carlo algorithm, Dig-Fuzz predicts the difficulty for a fuzzer to explore a path and prioritizes to explore seeds with a higher difficulty score.</p><p>Moreover, motivated by the growing demands in software testing, researchers have been reasoning the performance of hybrid testing. As commonly understood, hybrid testing is largely restricted by the slow concolic execution. To this end, QSYM <ref type="bibr" target="#b73">[73]</ref> implements a concolic executor that tailors the heavy but unnecessary computations in symbolic interpretation and constraint solving. It leads to times of acceleration.</p><p>Differing from the above works that bring code-coverage improvement, SAVIOR changes the philosophy of hybrid testing. It drives the concolic executor on seeds with higher potential and guides the verification of the encountered vulnerabilities. This leads to quicker and better bug coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Guided Software Testing</head><p>This line of research <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b52">52]</ref> aims to guide the testing towards exploring specific code locations. Katch <ref type="bibr" target="#b52">[52]</ref> prioritizes the seeds that approach patches to guide the symbolic executor. Together with three other guiding schemes, Katch can efficiently cover the target code. With a similar goal, AFLGO <ref type="bibr" target="#b24">[25]</ref> calculates the distance from each code region to the targets (e.g., vulnerable code regions or patches). In fuzz testing, AFLGO favors seeds that exercise code regions with smaller distances. Christakis et al. <ref type="bibr" target="#b31">[32]</ref> proposes to prune paths in dynamic symbolic execution. It discards paths that carry properties that have been verified. However, the existing works generally prefer seeds that approach the targets quicker, which oftentimes carry shallow contexts. Instead, SAVIOR values all the seeds with high potential, creating various contexts to exercise the target code. This enables SAVIOR to outperforms these existing guided testing techniques in bug finding. Some other works use static analysis to label potential vulnerabilities, such as using data flow analysis to pinpoint data leaks <ref type="bibr" target="#b22">[23]</ref>, using slicing to mark use-after-free paths <ref type="bibr" target="#b37">[38]</ref>, and using taint analysis to mark possible races <ref type="bibr" target="#b50">[50]</ref>. they then rely on subsequent symbolic execution to confirm detection. These analyses are complementary to SAVIOR. In addition, SAVIOR relies on fuzz testing to stably approach the to-beverified paths, while others use heuristic based approaches to guide symbolic execution towards the marked label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>We introduce SAVIOR, a new hybrid testing approach in this work. Unlike the mainstream hybrid testing tools which follow the coverage-driven design, SAVIOR moves towards being a bug-driven. We accordingly propose in SAVIOR two novel techniques, named bug-driven prioritization and bugguided verification, respectively. On one hand, SAVIOR prioritizes the concolic execution to run seeds with more potentials of leading to vulnerabilities. On the other hand, SAVIOR examines all vulnerable candidates along the running program path in concolic execution. By modeling the unsafe conditions in SMT constraints, it solves for proofs of valid vulnerabilities or proves that the corresponding vulnerabilities do not exist. SAVIOR significantly outperforms the existing coveragedriven tools. On average, it detects vulnerabilities 43.4% faster than DRILLER and 44.3% faster than QSYM, resulting in the discovery of 88 and 76 more security violations in 24 hours.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. LAVA-M Evaluation</head><p>In the evaluation with LAVA-M, bug-guided verification helps identify a group of LAVA bugs that are not listed. Table <ref type="table" target="#tab_19">X</ref> shows the IDs of these LAVA bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Real World Benchmark Evaluation</head><p>For a better reference of our evaluation with real-world programs, we summarize the number of triggered violations at the end of 24 hours in Table <ref type="table" target="#tab_21">XII</ref>.</p><p>In addition, we also compare the UBSan violations triggered by SAVIOR and the other 5 fuzzers. The results are summarized in Table <ref type="table" target="#tab_20">XI</ref>. In general, these fuzzers are exploring a similar group of UBSan violations. More importantly, for most of the cases, SAVIOR triggers a super-set of the violations that are made by the other fuzzers (in particular AFL and AFLGO). This indicates that SAVIOR has a better thoroughness in vulnerability finding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX B TECHNICAL DISCUSSION AND FUTURE WORK</head><p>In this section, we discuss the limitations of our current design, insights we learned and possible future directions.</p><p>Over-approximation in Vulnerability Labeling: As explained in Section III, SAVIOR leverages sound algorithms to label vulnerabilities where the over-approximation may introduce many false-positive labels. This imprecision can   consequently weaken the performance of SAVIOR's prioritization. A straightforward reaction to this issue is to eliminate as many dummy labels as possible. In our design, we utilize a rule-based scheme to filter those false-positive labels in Section III-B. In the future, we plan to include more precise static analysis for finer-grained label pruning. For instance, the STACK system developed by Wang et. al <ref type="bibr" target="#b69">[69,</ref><ref type="bibr" target="#b70">70]</ref> and the approach proposed by Hathhorn et. al <ref type="bibr" target="#b45">[45]</ref> can be incorporated into SAVIOR, which are complementary to UBSan in identifying code snippets that may lead to undefined behavior.</p><p>Prediction in Vulnerability Detection: Once reaching a potentially vulnerable program location in concolic execution, SAVIOR extracts the guarding predicates of the vulnerability label. However, these predicates may contradict the current path condition. In case of such contradiction, SAVIOR terminates the exploration of the labeling site immediately, since continuing the analysis cannot contribute to any valuable test input. Moreover, in many cases, we can predict whether an execution path can trigger a vulnerability or not by studying the runtime information of previous executions. Also, more importantly, before that execution arrives the vulnerability site. To achieve this goal, we need a method to backwardly summarize path constraints from the labeled site to its predecessors in the explored paths. The core technique of this summary is the weakest precondition <ref type="bibr" target="#b44">[44]</ref> (derived from the Hoare Logic) which has been applied to both sequential and concurrent program analysis domains <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b71">71]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>link-layer type from input*/ read(input_fd, &amp;link_type, sizeof(int)); /*select a handler based on link_type*/</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 7 :</head><label>7</label><figDesc>Fork server mode in KLEE. In this mode, KLEE only performs initialization once and reuses the same executor for all the received seeds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 8 :</head><label>8</label><figDesc>Fig.8: Evaluation results with LAVA-M. The left column shows the number of Lava bugs reached by different fuzzers and the right column shows the number of LAVA bugs triggered by the fuzzers. For TFUZZ, we only present the number of triggered bugs in base64 and uniq, as the other results are not reliable due to a broken third-party dependency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Number of UBSan violations triggered in tcpdump (p1=0.029, p2=0.047).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>tcpdump (p1=0.106,p2=0.999).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Number of UBSan violations triggered in tiff2ps (p1=0.005, p2=0.046).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Number of UBSan violations triggered in readelf (p1=0.098, p2=5.63 * e -5 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Number of basic blocks reached in readelf (p1=0.042, p2=0.726).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Number of UBSan violations triggered in libxml (p1=7.04 * e -5 , p2=2.15 * e -7 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>djpeg (p1=0.777,p2=0.203).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Number of basic blocks reached in djpeg (p1=3.28 * e -7 ,p2=3.79 * e -6 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Number of UBSan violations triggered in tiff2pdf (p1=0.002,p2=3.95 * e -6 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Number of UBSan violations triggered in objdump (p1=0.096, p2=0.003). objdump (p1=0.0001, p2=0.125).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: Evaluation results with real-world programs. Each program takes two columns, respectively showing the number of triggered UBSan violations and the amount of covered basic blocks by the fuzzers over 24 hours. p 1 and p 2 are the p-values for the Mann Whitney U-test of SAVIOR vs. DRILLER and SAVIOR vs. QSYM, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>%25= 9 ; 3 Fig. 10 :</head><label>9310</label><figDesc>Fig. 10: SAVIOR instrumentation of UBSan label.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE II :</head><label>II</label><figDesc>Fuzzer specific settings in evaluation with Lava-M.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE III :</head><label>III</label><figDesc>LAVA-M Bugs triggered by different fuzzers (before bug-guided verification). "X%" indicates that X% of the listed LAVA bugs are triggered.</figDesc><table><row><cell>Fuzzers</cell><cell>base64</cell><cell cols="2">Fuzzing results uniq md5sum</cell><cell>who</cell></row><row><cell>AFL AFLGO TFUZZ ANGORA DRILLER QSYM SAVIOR</cell><cell>48 (100%) 48 (100%) 47 (100%) 48 (100%) 48 (100%) 48 (100%) 48 (100%)</cell><cell>29 (100%) 29 (100%) 29 (100%) 29 (100%) 29 (100%) 29 (100%) 29 (100%)</cell><cell>59 (100%) 59 (100%) N/A 59 (100%) 59 (100%) 59 (100%) 59 (100%)</cell><cell>2357 (96.3%) 2357 (96.3%) N/A 2357 (96.3%) 2357 (96.3%) 2357 (96.3%) 2357 (96.3%)</cell></row><row><cell>Listed</cell><cell>44</cell><cell>28</cell><cell>57</cell><cell>2136</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE IV :</head><label>IV</label><figDesc>LAVA-M Bugs triggered by different fuzzers (after bug-guided verification). "X%" indicates that X% of the listed LAVA bugs are triggered.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>Table X at Appendix. Such results strongly demonstrate the promising potential of bug-guided verification to benefit fuzzing tools in vulnerability findings.</figDesc><table><row><cell></cell><cell cols="2">Programs</cell><cell></cell><cell></cell><cell>Settings</cell></row><row><cell>Name</cell><cell>Version</cell><cell>Driver</cell><cell>Source</cell><cell>Seeds</cell><cell>Options</cell></row><row><cell>libpcap libtiff libtiff binutils binutils libxml2 libjpeg jasper</cell><cell>4.9.2/1.9.0 4.0.10 4.0.10 2.31 2.31 2.9.7 9c master</cell><cell>tcpdump tiff2ps tiff2pdf objdump readelf xmllint djpeg jasper</cell><cell>[20] [12] [12] [8] [8] [13] [11] [9]</cell><cell>build-in AFL AFL AFL AFL AFL AFL AFL</cell><cell>-r @@ @@ @@ -D @@ -A @@ @@ -f @@ -T pnm</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>TABLE V :</head><label>V</label><figDesc>Real-world benchmark programs and evaluation settings. In the column for Seeds, AFL indicates we reuse the testcases provided in AFL and build-in indicates that we reuse the test cases shipped with the program. In this evaluation, we prepare 8 programs. Details about these programs and the test settings are summarized in TableV. All the programs have been extensively tested by both industry</figDesc><table><row><cell>B. Evaluation with Real-world Programs</cell></row><row><cell>1) Experimental Setup:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>TABLE VI :</head><label>VI</label><figDesc>Number of unique UBSan labels reached by different fuzzers in 24 hours. On average SAVIOR reaches 19.68% and 15.18% more labels than DRILLER and QSYM.</figDesc><table><row><cell>Prog. tcpdump tiff2ps readelf libxml tiff2pdf djpeg objdump jasper</cell><cell>Improvements by bug-guided verification AFLGO ANGORA DRILLER QSYM +10/11% +22/41.5% +29/76.3% +9/9.9% AFL +4/4% +4/133% +0/0% +3/42.9% +0/0% +0/0% +10/82% +9/72.2% +16/107% +9/68.4% +8/63.2% +7/29.2% SAVIOR +8/7% +0/0% +4/33.3% +4/33.3% +5/166.7% +4/33.3% +4/33.3% +0/0% +5/50% +1/7.7% +4/44.4% +3/27.2% +5/62.5% +0/0% +0/0% +7/5.2% +7/5.2% +0/0% +0/0% +0/0% +7/10.9% +7/11.7% +11/17.2% +7/11.7% +6/9.5% +0/0% +0/0% +0/0% +7/30.4% +7/26.9% +7/26.9% +0/0%</cell></row><row><cell>Ave.</cell><cell>+5/40.1% +6/21.5% +10/61.2% +5/22.2% +4.3/25% +1.8/4.5%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>TABLE VII :</head><label>VII</label><figDesc>New UBSan violations triggered with bugguided verification in the evaluation with real-world programs. "+X/Y%" means "X" new violations are triggered, increasing the total number by "Y%".</figDesc><table><row><cell>Program tcpdump libjpeg objdump readelf libtiff jasper mjs catdoc c++filt</cell><cell cols="2">Defect categories OOB Logic Error 6 102 8 23 41 4 1 9 20 0 21 2 1 0 3 0 1 1</cell><cell>Note Exploitable * 6+ 0+ 4+ 10+ 0+ 2+ 0+ 3+ 0</cell><cell>Confirmed 7 N/A N/A 3 N/A 2 1 1 2</cell></row><row><cell>Total</cell><cell>102</cell><cell>141</cell><cell>25+</cell><cell>16</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>TABLE VIII :</head><label>VIII</label><figDesc>Triage of UBsan violations triggered by SAV-IOR in 24 hours. In total, we collect 481 UBSan violations and we manually classify them based on their consequences and present the results in Table VIII. Specifically, 102 of them lead to OOB reads/writes and 141 of them result in logic errors.</figDesc><table><row><cell>Triage Result:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>The second case is a logic error in libtiff. Variable twobitdeltas[delta] is controlled by user. With a specially crafted input, one can cause an overflow in the result of lastpixel + twobitdeltas[delta], making SETPIXEL set the wrong pixel value to the decoded image.</figDesc><table><row><cell cols="2">1 static bool process_notes_at(...){</cell></row><row><cell>2</cell><cell>//readelf.c:18303</cell></row><row><cell>3</cell><cell>if(inote.namedata[inote.namesz-1] != '\0')</cell></row><row><cell>4</cell><cell>...</cell></row><row><cell cols="2">5 }</cell></row><row><cell cols="2">1 static int ThunderDecode(...){</cell></row><row><cell>2</cell><cell>//tif_thunder.c:125</cell></row><row><cell>3</cell><cell>if((delta = ((n &gt;&gt; 4) &amp; 3)) != DELTA2_SKIP)</cell></row><row><cell>4</cell><cell>SETPIXEL(op, lastpixel + twobitdeltas[</cell></row><row><cell></cell><cell>delta]);</cell></row><row><cell>5</cell><cell>...</cell></row><row><cell cols="2">6 }</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head>TABLE IX :</head><label>IX</label><figDesc>Number of UBSan labels removed in our benchmark programs. On average, 5.36% of the labels are reduced.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19"><head>TABLE X :</head><label>X</label><figDesc>IDs of unlisted bugs in LAVA-M that are triggered with bug-guided verification.</figDesc><table><row><cell>Prog. tcpdump tiff2ps readelf xmllint djpeg tiff2pdf jasper objdump</cell><cell>AFL +5/-43 +0/-13 +0/-7 +0/-6 +0/-0 +0/-7 +2/-13 +14/-18</cell><cell>Difference of triggered UBSan violations AFLGO ANGORA DRILLER QSYM +0/-61 +0/-76 +7/-30 +15/-28 +0/-6 +0/-9 +0/-8 +0/-8 +1/-7 +4/-13 +2/-7 +2/-7 +0/-6 +0/-15 +0/-6 +0/-6 +0/-7 +0/-7 +0/-0 +0/-0 +0/-4 +5/-13 +0/-6 +0/-9 +0/-13 +1/-22 +0/-18 +0/-8 +10/-18 +16/-20 +10/-18 +12/-17</cell><cell>SAVIOR +0/-0 +0/-0 +0/-0 +0/-6 +0/-0 +0/-0 +0/-0 +0/-0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head>TABLE XI :</head><label>XI</label><figDesc>Difference between violations triggered by SAV-IOR and other fuzzers. (+X/-Y) means X violations are triggered by the fuzzer but not by SAVIOR and Y violations are triggered by SAVIOR but not by that fuzzer.</figDesc><table><row><cell>Prog. tcpdump tiff2ps readelf xmllint djpeg tiff2pdf jasper objdump</cell><cell>AFL 87 3 14 12 141 13 33 64</cell><cell cols="4">Number of triggered UBSan violations AFLGO ANGORA DRILLER QSYM 59 43 102 113 10 7 8 8 16 14 15 16 12 3 12 12 134 134 141 141 13 9 13 10 31 23 26 26 60 64 60 63</cell><cell>SAVIOR 128 16 22 18 141 17 44 79</cell></row><row><cell>Total</cell><cell>367</cell><cell>335</cell><cell>297</cell><cell>377</cell><cell>389</cell><cell>465</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21"><head>TABLE XII :</head><label>XII</label><figDesc>Number of unique UBSan violations triggered by different fuzzers in 24 hours. In particular, 43.4% and 44.3% more violations than DRILLER and QSYM, respectively.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Authorized licensed use limited to: UNIVERSITY OF ROCHESTER. Downloaded on September 22,2020 at 07:45:18 UTC from IEEE Xplore. Restrictions apply.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The broken component is the QEMU based tracer in Angr<ref type="bibr" target="#b3">[4]</ref>. This has been confirmed with the developers.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>The p-values of readelf and objdump are larger than 0.05 but they are at the level of quasi-significance. In the two programs, the variances are mainly due to randomness.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We would like to thank our shepherd Mathias Payer and the anonymous reviewers for their feedback. This project was supported by the Office of Naval Research (Grant#: N00014-17-1-2891, N00014-18-1-2043, and N00014-17-1-2787). Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the views of the funding agency.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SUPPLEMENTARY FIGURES AND EVALUATION DATA</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Program Instrumentation</head><p>Figure <ref type="figure">10</ref> shows the UBSan-instrumented LLVM IR for the objdump defect in our motivating example, of which source code is presented in Figure <ref type="figure">2</ref>. In Figure <ref type="figure">10</ref>, we highlight the instrumentation with !saviorBugNum metadata for bugdriven prioritization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. UBSan Label Reduction</head><p>In the process of vulnerability labelling, SAVIOR also reduces labels that can be confirmed as false positives. Table <ref type="table">IX</ref> shows the results of label reduction on our benchmark programs. ; load value of section-&gt;size ,! 5</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Aflgo source code</title>
		<ptr target="https://github.com/aflgo/aflgo" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">American fuzzy lop</title>
		<ptr target="http://lcamtuf.coredump.cx/afl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Angora source code</title>
		<ptr target="https://github.com/AngoraFuzzer/Angora" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">angr/tracer: Utilities for generating dynamic traces</title>
		<ptr target="https://github.com/angr/tracer" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Apollo: an open autonomous driving platform</title>
		<ptr target="https://github.com/ApolloAuto/apollo" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Driller reading file patch</title>
		<ptr target="https://github.com/shellphish/driller/issues/48" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Driller stuck heuristic</title>
		<ptr target="https://github.com/shellphish/driller#the-stuck-heuristic" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Index of /gnu/binutils</title>
		<ptr target="https://ftp.gnu.org/gnu/binutils/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">jasper source code</title>
		<ptr target="https://github.com/mdadams/jasper/archive/master.zip" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Klee intrinsiccleaner</title>
		<ptr target="https://github.com/klee/klee/blob/master/lib/Module/IntrinsicCleaner.cpp" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">libjpeg source code</title>
		<ptr target="https://www.ijg.org/files/jpegsrc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Libtiff source code</title>
		<ptr target="https://download.osgeo.org/libtiff/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">libxml2 source code</title>
		<ptr target="http://xmlsoft.org/libxml2/libxml2-git-snapshot.tar.gz" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The myth of bug free software</title>
		<ptr target="https://www.betabreakers.com/the-myth-of-bug-free-software/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Objdump overflow patch</title>
		<ptr target="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb" />
		<imprint/>
	</monogr>
	<note>git;a=commitdiff;h=f2023ce7</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Oss-fuzz -continuous fuzzing for open source software</title>
		<ptr target="https://github.com/google/oss-fuzz" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Qsym source code</title>
		<ptr target="https://github.com/sslab-gatech/qsym" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Run angora on lava dataset</title>
		<ptr target="https://github.com/AngoraFuzzer/Angora/blob/master/docs/lava.md" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">T-fuzz source code</title>
		<ptr target="https://github.com/HexHive/T-Fuzz" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Tcpdump source code</title>
		<ptr target="http://www.tcpdump.org/release/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Undefined behavior sanitizer -clang 9 documentation</title>
		<ptr target="http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#ubsan-checks" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Method and apparatus for analyzing computer code using weakest precondition</title>
		<author>
			<persName><forename type="first">A</forename><surname>Afifi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Comuzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pizzarello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">US Patent</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2000">Feb. 22 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Using targeted symbolic execution for reducing false-positives in dataflow analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th ACM SIGPLAN International Workshop on State Of the Art in Program Analysis, SOAP@PLDI 2015</title>
		<meeting>the 4th ACM SIGPLAN International Workshop on State Of the Art in Program Analysis, SOAP@PLDI 2015<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">June 15 -17, 2015, 2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">AEG: automatic exploit generation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L T</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium, NDSS 2011</title>
		<meeting>the Network and Distributed System Security Symposium, NDSS 2011<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-02-09">6th February -9th February 2011, 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Directed greybox fuzzing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V.-T</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-D</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2329" to="2344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Heuristics for scalable dynamic test generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burnim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd IEEE/ACM International Conference on Automated Software Engineering</title>
		<meeting><address><addrLine>L&apos;Aquila, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-09-19">15-19 September 2008. 2008</date>
			<biblScope unit="page" from="443" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation. USENIX Association</title>
		<meeting>the 8th USENIX Conference on Operating Systems Design and Implementation. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Unleashing mayhem on binary code</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>San Francisco, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-05-23">2012, 21-23 May 2012. 2012</date>
			<biblScope unit="page" from="380" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Angora: Efficient fuzzing by principled search</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="711" to="725" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Ptrix: Efficient hardware-assisted fuzzing for cots binary</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 ACM on Asia Conference on Computer and Communications Security</title>
		<meeting>the 2019 ACM on Asia Conference on Computer and Communications Security</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">S2E: A platform for in-vivo multi-path analysis of software systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Chipounov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="265" to="278" />
			<date type="published" when="2011">2011</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Guiding dynamic symbolic execution toward unverified program executions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Christakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Wüstholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th International Conference on Software Engineering</title>
		<meeting>the 38th International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="144" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Satisfiability modulo theories: introduction and applications</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="69" to="77" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A tutorial on satisfiability modulo theories</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Dutertre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="20" to="36" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Understanding integer overflow in c/c++</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering, ser. ICSE&apos;12</title>
		<meeting>the 34th International Conference on Software Engineering, ser. ICSE&apos;12</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="760" to="770" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Lava: Large-scale automated vulnerability addition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Dolan-Gavitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hulin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mambretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ulrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Whelan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2016 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="110" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Baidu apollo em motion planner</title>
		<author>
			<persName><forename type="first">H</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Kong</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1807.08048</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Finding the needle in the heap: combining static analysis and dynamic symbolic execution to trigger useafter-free</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bardin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Workshop on</title>
		<meeting>the 6th Workshop on</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m">SSPREW@ACSAC 2016</title>
		<meeting><address><addrLine>Los Angeles, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">December 5-6, 2016, 2016</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
		<respStmt>
			<orgName>Software Security, Protection, and Reverse Engineering</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Collafl: Path sensitive fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<biblScope unit="volume">00</biblScope>
			<biblScope unit="page" from="660" to="677" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A decision procedure for bit-vectors and arrays</title>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="519" to="531" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">DART: directed automated random testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation</title>
		<meeting>the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">June 12-15, 2005, 2005</date>
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Automated whitebox fuzz testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NDSS</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="151" to="166" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Assertion guided symbolic execution of multithreaded programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kusano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering, ESEC/FSE 2015</title>
		<meeting>the 2015 10th Joint Meeting on Foundations of Software Engineering, ESEC/FSE 2015<address><addrLine>Bergamo, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-09-04">August 30 -September 4, 2015, 2015</date>
			<biblScope unit="page" from="854" to="865" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Dynamic logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tiuryn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of philosophical logic</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="99" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Defining the undefinedness of C</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hathhorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ellison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">June 15-17, 2015, 2015</date>
			<biblScope unit="page" from="336" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Symbolic testing and the DISSECT symbolic evaluation system</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Howden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="266" to="278" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">jfuzz: A concolic whitebox fuzzer for java</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jayaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harvison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kiezun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First NASA Formal Methods Symposium -NFM 2009</title>
		<meeting><address><addrLine>Moffett Field, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">April 6-8, 2009. 2009</date>
			<biblScope unit="page" from="121" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="385" to="394" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Klees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1808.09700</idno>
		<title level="m">Evaluating fuzz testing</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Practical symbolic race checking of GPU programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference for High Performance Computing, Networking, Storage and Analysis</title>
		<meeting><address><addrLine>SC; New Orleans, LA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-11-16">2014. November 16-21, 2014, 2014</date>
			<biblScope unit="page" from="179" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Hybrid concolic testing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering, 2007. ICSE 2007. 29th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="416" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">KATCH: high-coverage testing of software patches</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Marinescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE&apos;13</title>
		<meeting><address><addrLine>Saint Petersburg, Russian Federation</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">August 18-26, 2013. 2013</date>
			<biblScope unit="page" from="235" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Mann-whitney u test</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Mcknight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Najab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Corsini encyclopedia of psychology</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Understanding the reproducibility of crowd-reported security vulnerabilities</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cuevas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Conference on Security Symposium. USENIX Association</title>
		<meeting>the 27th USENIX Conference on Security Symposium. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="919" to="936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Hybrid fuzz testing: Discovering software bugs via fuzzing and symbolic execution</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Pak</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>School of Computer Science Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">T-fuzz: fuzzing by program transformation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="697" to="710" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Vuzzer: Application-aware evolutionary fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cojocar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Optimizing seed selection for fuzzing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Warren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Grieco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd USENIX Conference on Security Symposium. USENIX Association</title>
		<meeting>the 23rd USENIX Conference on Security Symposium. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="861" to="875" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Concolic testing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twentysecond IEEE/ACM international conference on Automated software engineering</title>
		<meeting>the twentysecond IEEE/ACM international conference on Automated software engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="571" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">CUTE and jcute: Concolic unit testing and explicit path model-checking tools</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification, 18th International Conference</title>
		<meeting><address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">August 17-20, 2006, Proceedings, 2006</date>
			<biblScope unit="page" from="419" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">CUTE: a concolic unit testing engine for C</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Software Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<meeting>the 10th European Software Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09-05">2005. September 5-9, 2005, 2005</date>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Addresssanitizer: A fast address sanity checker</title>
		<author>
			<persName><forename type="first">K</forename><surname>Serebryany</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Potapenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vyukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference. USENIX Association</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="309" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Neuzz: Efficient fuzzing with neural program smoothing</title>
		<author>
			<persName><forename type="first">D</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NEUZZ: Efficient Fuzzing with Neural Program Smoothing</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Gödel&apos;s incompleteness theorems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Smullyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Smullyan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Oxford University Press on Demand</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Incremental computation of dominator trees</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C</forename><surname>Sreedhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-F</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Driller: Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName><forename type="first">N</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Corbetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Svf: interprocedural static value-flow analysis in llvm</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Compiler Construction</title>
		<meeting>the 25th International Conference on Compiler Construction</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="265" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Fuzzing for software security testing and quality assurance</title>
		<author>
			<persName><forename type="first">A</forename><surname>Takanen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Demott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Miller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Artech House</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Undefined behavior: what happened to my code?</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asia-Pacific Workshop on Systems, APSys &apos;12</title>
		<meeting><address><addrLine>Seoul, Republic of Korea</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">July 23-24, 2012, 2012</date>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Towards optimization-safe systems: analyzing the impact of undefined behavior</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGOPS 24th Symposium on Operating Systems Principles, SOSP &apos;13</title>
		<meeting><address><addrLine>Farmington, PA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">November 3-6, 2013. 2013</date>
			<biblScope unit="page" from="260" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Eliminating path redundancy via postconditioned symbolic execution</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="43" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Profuzzer: On-the-fly input type probing for better zero-day vulnerability discovery</title>
		<author>
			<persName><forename type="first">W</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pro-Fuzzer: On-the-fly Input Type Probing for Better Zero-Day Vulnerability Discovery</title>
		<imprint>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">QSYM : A practical concolic execution engine tailored for hybrid fuzzing</title>
		<author>
			<persName><forename type="first">I</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Conference on Security Symposium. USENIX Association</title>
		<meeting>the 27th USENIX Conference on Security Symposium. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">APPENDIX A Program Bugs unlisted by LAVA-M but exposed by bug-guided verification base64 274</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">521</biblScope>
			<biblScope unit="page">287</biblScope>
		</imprint>
	</monogr>
	<note>Send hardest problems my way: Probabilistic path prioritization for hybrid fuzzing. 527 uniq 227 md5sum 281</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
