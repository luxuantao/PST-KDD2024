<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Priced Oblivious Transfer: How to Sell Digital Goods</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Bill</forename><surname>Aiello</surname></persName>
							<email>aiello@research.att.com</email>
						</author>
						<author>
							<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
						</author>
						<title level="a" type="main">Priced Oblivious Transfer: How to Sell Digital Goods</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CA5CD2B68E608BDE3BD666FD188950C3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the question of protecting the privacy of customers buying digital goods. More specifically, our goal is to allow a buyer to purchase digital goods from a vendor without letting the vendor learn what, and to the extent possible also when and how much, it is buying. We propose solutions which allow the buyer, after making an initial deposit, to engage in an unlimited number of priced oblivioustransfer protocols, satisfying the following requirements: As long as the buyer's balance contains sufficient funds, it will successfully retrieve the selected item and its balance will be debited by the item's price. However, the buyer should be unable to retrieve an item whose cost exceeds its remaining balance. The vendor should learn nothing except what must inevitably be learned, namely, the amount of interaction and the initial deposit amount (which imply upper bounds on the quantity and total price of all information obtained by the buyer). In particular, the vendor should be unable to learn what the buyer's current balance is or when it actually runs out of its funds. The technical tools we develop, in the process of solving this problem, seem to be of independent interest. In particular, we present the first one-round (two-pass) protocol for oblivious transfer that does not rely on the random oracle model (a very similar protocol was independently proposed by Naor and Pinkas [21]). This protocol is a special case of a more general "conditional disclosure" methodology, which extends a previous approach from <ref type="bibr" target="#b10">[11]</ref> and adapts it to the 2-party setting.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Consider a scenario where a buyer wishes to purchase digital goods from a vendor without disclosing what it is buying, or even when exactly it is buying. For instance, the buyer may wish to subscribe to a pay-per-view service, where different costs are associated with different channels, or get an up-to-date information on its stock portfolio. In both cases buyers may wish to hide from vendors what items they are buying, or even whether at a given moment they are buying anything at all.</p><p>In the realm of physical goods, it is inherently impossible to hide from the vendor what, when, and how much it is selling. Being bounded to a limited inventory, the vendor must keep track of how many items of each kind it has in stock. However, unlike physical goods, digital goods are typically of unlimited supply. The purpose of this paper is to exploit the difference between the physical and the digital worlds in order to obtain privacy of buyers in the following electronic commerce scenario. Assume that a buyer first deposits a pre-payment at the hands of a vendor. <ref type="foot" target="#foot_0">1</ref> The buyer should then be able to engage in a virtually unlimited number of interactions with the vendor in order to obtain digital goods (also referred to as items) at a total cost which does not exceed its initial deposit amount. After spending all of its initial credit, the buyer should be unable to obtain any additional items before depositing an additional pre-payment. This paper provides efficient ways to implement this, rather standard, e-commerce task with the added requirement of maintaining the buyer's privacy. That is, the vendor should learn nothing except what must inevitably be learned: the amount of interaction and the initial deposit amount (which imply upper bounds on the quantity and total price of all information obtained by the buyer). In particular, the vendor should be unable to learn what the buyer's current balance is or when it actually runs out of its funds.</p><p>Traditional approaches for protecting the privacy of buyers, such as anonymous digital payments (e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>), do not address the problem of hiding which goods are being bought and when. This information, possibly combined with additional information from other sources (such as traffic analysis), may facilitate attacks on the privacy of individual buyers. <ref type="foot" target="#foot_1">2</ref> Moreover, strong anonymity is not only difficult to implement and prone to various types of attacks <ref type="bibr" target="#b1">[2]</ref>, but in some contexts it is also undesirable <ref type="bibr" target="#b25">[26]</ref>. We stress that our solutions do not require anonymity of buyers and do not attempt to achieve this property. On the contrary, our work provides an alternative approach for protecting individual buyers engaging in e-commerce activities, which promises a different (and in a sense stronger) type of security. This approach is most beneficial when anonymity is insufficient, undesirable, or difficult to achieve.</p><p>Priced Oblivious Transfer. The well-known oblivious transfer primitive <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b14">15]</ref> provides a partial solution to our problem. If all items are identically priced, then the buyer's initial deposit determines the number of items it is entitled to obtain. In this case, the vendor may allow the buyer to retrieve just the right number of items using multiple invocations of oblivious transfer. However, this solution is not applicable in the realistic scenario where the items are not identically priced. Moreover, coping with differently priced items may be highly beneficial even in the case that all "real" items have the same price. By adding a single dummy item with price 0, the buyer has the option of "buying" this item an arbitrary number of times for the sole purpose of hiding when it is buying real items. This added privacy feature is impossible to achieve with a standard use of oblivious transfer, unless the buyer is willing to pay for all the dummy items it retrieves.</p><p>Obtaining a complete solution to our problem requires a more general protocol that we call priced oblivious transfer. Assume that at the beginning of each phase of interaction the vendor holds an encryption of the buyer's current balance. A phase of interaction (also referred to as a transaction) should allow the buyer to privately retrieve a single item. This in itself is an oblivious transfer protocol. However, in this case we have the following additional requirements:</p><p>(1) The buyer can only retrieve an item if its current balance is larger than the item's price; <ref type="bibr" target="#b1">(2)</ref> The price of the item the buyer retrieves should be decreased from the buyer's (encrypted) balance. Broadcast Encryption. A prime motivating example for priced oblivious transfer is as follows. A vendor is broadcasting n different data streams. The data streams may be video, audio, or text and the content may be news, entertainment, technical and professional information, etc. To accomplish private buying in this setting, the vendor encrypts each of the n streams with a different key. The buyer and vendor then engage in a priced oblivious transfer protocol where the keys are the items being transferred. The buyer is then able to decrypt the data stream that it paid for, but as it does not have knowledge of the other keys, it is unable to gain access to the content of the other data streams.</p><p>Subscriptions. An important extension to enabling the purchase of a single digital good per transaction is to allow subscriptions. In a subscription scenario, the vendor changes the database periodically. Denote the ith data item at time j as x i j . The sequence of the ith data items over time, x i 0 , x i 1 , . . ., is called the ith channel or channel stream. For example, a channel may be a daily financial white paper or a daily decryption key for a broadcast stream as above. In this setting the buyer is allowed to subscribe to a channel. As with a single data item from a static database, the channel to which a buyer subscribes should remain private. While the buyer is subscribed to a channel, it receives the sequence of data items of the channel and its balance is deducted by the appropriate amount each time period of the channel. The buyer remains subscribed to the channel until it explicitly unsubscribes or until its balance becomes negative. It is clear that the operation of subscribing to a channel can be simulated by repeated operations of purchasing an item. The issue however is one of efficiency and in particular it is a question of the communication pattern: While buying inherently requires some non-trivial interaction, maintaining a subscription should ideally require only efficient one-way communication from the vendor to the buyer. Allowing an efficient subscription implementation (with one-way communication) seems to be vital in many of the applications we have in mind. We therefore extend our solutions to handle this additional requirement. A note concerning efficiency. The main goals of this work are to put forward a new problem, establish a "practical feasibility" result for this problem, and in the process develop some useful general tools. We do not attempt at minor optimizations which would complicate the presentation. Our solution should be mainly viewed as a feasible framework which may be the basis for further optimizations. Additional Contributions. Several ingredients of our construction seem to be of independent interest. In particular, we obtain the first implementation of a 1-round oblivious transfer protocol satisfying a "reasonable" security definition and provably secure under a "reasonable" security assumption. The security of our protocol can be based on the decisional Diffie-Hellman (DDH) assumption. A similar protocol has been independently obtained by Naor and Pinkas <ref type="bibr" target="#b20">[21]</ref>. The oblivious transfer protocol follows from a more general conditional disclosure methodology, which can be used in some contexts as a light-weight alternative to zero-knowledge proofs. In this we extend an "information-theoretic" technique from <ref type="bibr" target="#b10">[11]</ref> (see Section 2.3) and adapts it to the 2-party setting. In the course of addressing the case of subscriptions, we propose efficient solutions for the problem of privately retrieving a chosen prefix of a long stream of information. Related Work. General techniques for secure 2-party computation <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b12">13]</ref> may be used to solve our problem. However, similarly to most other works in this area, our goal is to use the specific structure of the problem at hand for providing far more efficient solutions than those obtained via general techniques.</p><p>The current work has been greatly inspired by previous works on specific secure computation tasks such as private information retrieval (PIR) and oblivious transfer. In Section 2.3 we describe some relevant techniques from these works which we rely on or extend. A restricted "off-line" variant of our problem may be viewed as a special case of a generalized oblivious transfer primitive studied in <ref type="bibr" target="#b13">[14]</ref>. In a distributed multi-vendor setting, an off-line variant of our problem has been considered in <ref type="bibr" target="#b10">[11]</ref>. Adapting the solutions from <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b10">11]</ref> to our setting would result in very inefficient protocols. We stress that unlike the PIR-related context of <ref type="bibr" target="#b10">[11]</ref>, where the main concern is that of minimizing the asymptotic complexity as a function of the number of data items, most aspects of our problem are equally interesting even when the number of items is as small as 2.</p><p>Organization. The remainder of the paper is organized as follows. In Section 2 we specify the problem and its security requirements, and review the tools we will use. In Section 3 we describe our basic protocol and its properties. We also discuss some efficiency improvements. In Section 4 we discuss an extension to the subscription scenario. Finally, in Section 5 we present the one-round OT protocol which is a special case of our methodology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem Specification</head><p>As discussed in the introduction, our goal is to construct an "on-line" protocol between a buyer B and a vendor V which allows the buyer and the vendor to engage in multiple transactions. Both the buyer and the vendor are allowed to store a (short) state information between transactions. Before specifying the security aspects of the protocol, we will first describe its desired functionality. Initialization: At time 0, the buyer initializes its balance with a pre-payment to the vendor. Main Protocol: At time t, t = 1, 2, . . .</p><p>-The vendor may choose a database x = (x 0 , x 1 , . . . , x n-1 ) of n items for sale and some public information P concerning the identity of these items. P contains a price list p = (p 0 , p 1 , . . . , p n-1 ). By convention, x 0 is a dummy item with p 0 = 0. -The buyer may then decide either to:</p><p>• Buy the i-th item, where 0 ≤ i &lt; n; if the buyer's remaining balance is sufficiently large (i.e., the combined price of all items previously received and the current price p i does not exceed the initial deposit), the buyer receives x i .</p><p>• Subscribe to the i-th channel; by subscribing, the buyer indicates that it wishes to continue buying the i-th item until overriding the subscription with a new request. We assume that throughout the subscription, the buyer is charged the price p i effective when initiating the subscription (even though p may change). • Unsubscribe, i.e., terminate a previous "subscribe" request.</p><p>• Do nothing, i.e., maintain its default subscription if such exists, and otherwise keep idle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Security Requirements</head><p>Efficiency considerations dictate some compromises we make in comparison to full-fledged simulation-based definitions for secure computation (e.g., those of <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12]</ref>). Nonetheless, our solutions are provably secure under standard security assumptions. Our formal security requirements, which are only sketched below, can be found in the full version. Both B and V are modeled by efficient randomized algorithms, and are initially given a security parameter 1 κ and a number of items 1 n as inputs. We assume that subsequent "inputs" are dynamically chosen by B, V as the protocol proceeds. The protocol is assumed to terminate after a polynomial number of transactions. An honest buyer is restricted to choose items such that their total price does not exceed the initial deposit amount b (0) . We first address a default scenario which only allows the buyer to issue "buy" requests. A protocol (B, V) as above is considered secure if it satisfies the following requirements: Correctness. If both B and V are honest, then B outputs the correct item x i at the end of each transaction. Buyer's security. A malicious vendor should not learn the choices made by an honest buyer. More formally, the view of any efficient (and possibly malicious) V * in the interaction (B, V * )(1 κ ) can be efficiently simulated. We note that this requirement is weaker than that of general security definitions in that it does not address the effect V * may have on the output of B. In particular, V * does not need to "know" a database x which is effectively determined by its strategy in a given transaction. This is consistent with other definitions of related primitives (such as PIR, see Section 2.3, or even some definitions of oblivious transfer). Vendor's security. A malicious buyer should not obtain more information than what its initial deposit allows. This is formalized by requiring that the interaction of B * with an honest vendor V could be efficiently simulated in the natural idealized model.</p><p>Our security definitions for the general case, where the buyer may take any of the four actions, are more subtle. In a nutshell, the vendor's security requirement remains unchanged, and can be defined as above. The buyer's security in this setting, may also be defined similarly to the above. However, such a definition will only be satisfied when the buyer's action type is oblivious to the received items, i.e. depends only on public data (yet its specific selections i may also depends on received items). The reader is referred to the full version of the paper for a more detailed discussion.</p><p>Finally, while we do not explicitly address issues of robustness or recovery from faults, our protocols can be extended in a straightforward manner to deal with these issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Tools</head><p>Homomorphic Encryption. Our constructions rely on the widely used tool of homomorphic encryption. Loosely speaking, an encryption scheme is said to be homomorphic if: <ref type="bibr" target="#b0">(1)</ref> The plaintexts are taken from a group (H, +); (2) From encryptions of group elements h 1 , h 2 it is possible to efficiently compute a random encryption of h 1 +h 2 . A useful consequence is that given an encryption of a group element h and an integer c in binary representation, one can efficiently compute a random encryption of c • h. This is done in a similar fashion to the repeated squaring procedure for modular exponentiation.</p><p>In what follows H will always be a group of a (large) prime order Q. It is important to note that by "+" we denote an abstract group operation. Hence, our notation applies both in a case where H = Z Q is an additive group, and where H ⊂ Z * P is a multiplicative group. A useful example of a multiplicative homomorphic encryption is the El-Gamal scheme. (We refer the reader to, e.g., <ref type="bibr" target="#b21">[22]</ref> for relevant definitions.) In this case, H is a subgroup of Z * P , where Q is a prime of length κ that divides P -1.</p><p>We prefer an additive notation over a multiplicative one due to its more intuitive nature in our context. However, our protocols can be instantiated with both types of encryption. We note that all of our constructions can be based on the El-Gamal encryption (whose security is equivalent to the DDH assumption, cf. <ref type="bibr" target="#b21">[22]</ref>) and most on any other homomorphic encryption scheme candidate, e.g. <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref>. An additional property enjoyed by the El-Gamal encryption, which explains the above distinction, is discussed below.</p><p>Verifiability. It is sometimes required to verify the validity of a public key k and the validity of a ciphertext c relative to a valid k. Luckily, the latter verification task is typically easy, and we can therefore assume it as part of our default requirements. However, in most encryption schemes the validity of the public key itself is difficult to verify. To this end a special zero-knowledge proof procedure may be employed during the initialization stage of our protocols. This step, however, is not always needed. A useful added feature of the El-Gamal scheme is that its public keys are easily verifiable: to verify that (P, Q, g, h) constitutes a valid public key, it is enough to verify that P, Q are prime, Q divides P -1, and</p><formula xml:id="formula_0">g Q ≡ h Q ≡ 1 (mod Q).</formula><p>PIR. A Private Information Retrieval (PIR) protocol <ref type="bibr" target="#b8">[9]</ref> allows a user to retrieve a selected item from a database while hiding the identity of this item from the server holding the database. PIR only requires the protection of the user, and makes no requirement on the privacy of the database. Thus, a naive solution to the PIR problem is to send the entire database to the user. When the database is large, this solution is very expensive in terms of communication. The main goal of PIR-related research has been to minimize the communication complexity of PIR, which is measured by default as the cost of retrieving one out of n bits. The current state of the art can be briefly summarized as follows. Assuming either a general homomorphic encryption <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b26">27]</ref> or a stronger number theoretic assumption <ref type="bibr" target="#b4">[5]</ref>, the asymptotic communication complexity of PIR can be made very small. In practice, however, the naive solution is still preferable when the database does not contain too many items. Thus, when we use PIR as a building block in our protocols, one should always keep in mind that the naive solution can be used in a case where the number of items is small.</p><p>Naor-Pinkas Pseudo-Random Sequence. A variant of PIR where the user is restricted to learn no more than a single data item has been referred to in the literature as symmetrically private information retrieval (SPIR) <ref type="bibr" target="#b10">[11]</ref>. <ref type="foot" target="#foot_2">3</ref> In <ref type="bibr" target="#b18">[19]</ref> (followed by <ref type="bibr" target="#b19">[20]</ref>), Naor and Pinkas suggested the following reduction from SPIR to PIR. Suppose that there is an efficient method allowing the user to retrieve exactly one out of n pseudo-random items (r 0 , . . . , r n-1 ) chosen by the server. Then, SPIR can be solved by applying such a procedure and concurrently applying PIR on (x 0 ⊕ r 0 , . . . , x n-1 ⊕ r n-1 ). The pseudo-random sequence (r 0 , . . . , r n-1 ) is created in the following way. Represent i as a length-binary string (in this case, = log n). Let (s 0 1 , s 1 1 ), (s 0 2 , s 1 2 ), . . . , (s 0 , s 1 ) be pairs of independent keys to a pseudo-random function f , and define</p><formula xml:id="formula_1">r i = ⊕ j=1 f sj (i)</formula><p>where s j = s ij j . By letting the user choose one key from each pair (s 0 j , s 1 j ), the user can learn any selected r i , but no more than one r i . A SPIR protocol constructed via the above method keeps all but a single data item x i semantically secure from the user. More precisely, it is possible to simulate the view of a user, whose log n selections define an index i, based on x i alone (up to computational indistinguishability).</p><p>Conditional Disclosure of Secrets. Motivated by the problem of constructing efficient SPIR protocols in the multi-server setting, Gertner et al. <ref type="bibr" target="#b10">[11]</ref> suggested the following conditional disclosure primitive. An input string y to a public Boolean predicate C is partitioned among k servers, such that no server knows the entire string y. In addition, one of the servers holds a secret s. The goal of the servers is to each send a single message to a user, who knows y, such that the user will learn s if C(y) = 1 and otherwise will learn no information on s. To make this possible, the servers have a common random input r which is unknown to the user. In <ref type="bibr" target="#b10">[11]</ref>, the problem is reduced to linear secret-sharing. It is shown that the communication complexity of conditional disclosure as above is linear in the span program size of C (and in particular in the formula size of C). If the user is allowed to "help" the servers by secret-sharing a witness to the validity of F (y) between them (without letting individual servers learn additional information on y), the communication can be made linear in the circuit size of C. Moreover, these solutions were efficiently extended to the non-Boolean case, where y is a string over a large field, and the condition C tests whether y satisfies some linear equation over F (or more complicated predicates over such atomic conditions).</p><p>A main ingredient of our protocol is an almost exact adaptation of the above conditional disclosure scenario to the single-server setting. In our setting, y will always be viewed as a vector over a large field F = Z Q . Instead of partitioning y = (y 1 , . . . , y m ) among several servers, a single server holds a public key k, the encryptions E k (y 1 ), . . . , E k (y m ), and a secret s ∈ F . The user holds both y and the secret key corresponding to k. An important observation regarding the solutions to the multi-server conditional disclosure problem mentioned above is that the joint messages sent by the servers may be expressed as a random linear function of (y, s), where the distribution of this linear function depends only on C. Therefore, if the encryption scheme E is homomorphic, the server may compute an encryption of these messages from E k (y). Instead of formulating our solutions in a general complexity-theoretic terminology, we will solve the required instances along the way in an intuitive way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Solving The Problem</head><p>In this section we describe our solutions for the priced oblivious transfer problem. For the sake of presentation, we develop our solutions gradually and improve their efficiency along the way. In particular, the only operation we consider at first is 'buy'. We deal with subscription operations in Section 4. Establishing a Public-Key Meta Structure. As described in introduction, during the entire run of our protocol the vendor will maintain an encryption of the buyer's current balance (using the public key of the buyer). Let E, D and G be the encryption, decryption and key-generation algorithms respectively. In the initialization phase of the protocol (time 0), the buyer applies G to sample a public-key, secret-key pair (k, sk) and sends the public-key k to the vendor. The vendor needs to verify that k is indeed a valid public-key and that the buyer knows a private-key sk that corresponds to k. Therefore, the buyer also proves in zero-knowledge that it knows an input of G that generates the public key k. <ref type="foot" target="#foot_3">4</ref> Finally, the vendor sets the current balance b (0) to the initial deposit of the buyer and creates an encryption E k (b (0) ) of the balance.</p><p>The first challenge in designing our protocol is that, at each transaction, the vendor needs to update the encrypted balance E k (b) by some value p without knowing either b or p. It should not be surprising that in order to do so it is useful to let E be a homomorphic encryption. Recall that we assume that the plaintexts are taken from a group G Q of order Q, where Q is a prime of length κ. Under our additive notation, it is convenient to view G Q as the field F = Z Q . Representations. We assume for simplicity that the length of each data item x i is smaller than the security parameter κ. Even if this is not the case, our problem can be reduced to that of selling keys which encrypt the actual data. We take B = 2 to be an upper bound on the initial balance, where B &lt; Q. This allows to represent prices and balances as elements of F by identifying (in the natural way) each integer i in the interval [B -Q, B -1] with the corresponding element of F . Thus, the elements 0, 1, . . . , B -1 ∈ F will be referred to as non-negative, and B, . . . , Q -1 as negative. In all of our protocols we will view a positive balance as being valid, and a negative balance as being invalid. If the buyer's balance is negative, it should not be allowed to learn any additional information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basic Solution</head><p>We present a solution where each transaction (here, a single 'buy' operation) requires two passes of communications: (1) A message from the buyer; (2) The vendor's reply. This is optimal since even without privacy the buyer still needs to specify the item it wants to retrieve and the vendor needs to send this item.</p><p>Assume without loss of generality that all item prices are distinct. (This assumption can be easily dispensed with at a moderate efficiency cost, e.g. by replacing each price p i by B p i -i for a sufficiently large B , and scaling the initial deposit by a factor of B .) The most essential part of the buyer's message is an encryption E k (p) where p is the price of the item it wants to retrieve. The vendor needs to perform two operations: (1) Update the balance; (2) Send back (in some encrypted form) the item x i such that p = p i .</p><p>Updating the Balance. Since the vendor has an encryption of the current balance E k (b) and it received an encryption E k (p) of the retrieved item's price, it seems that updating the balance is not a problem. Simply create an encryption E k (b-p) of the new balance using the homomorphism of E. However, we should be careful: By setting p to be negative (e.g. b -B + 1), the buyer can arbitrarily increase its balance (this is of course undesirable, regardless of whether in this specific transaction the buyer gains any information).</p><p>One way to prevent the buyer from cheating in this manner is to require it to prove in a zero-knowledge fashion that 0 ≤ p ≤ b. Such a solution requires more passes of interaction than desired. A better solution in this respect is for the buyer to use non-interactive zero-knowledge proofs of this claim (for that the buyer and vendor can agree upon a random string in the initialization phase of the protocol). However, non-interactive zero-knowledge proofs are usually very inefficient and we therefore give in Section 3.3 an alternative (more efficient) solution. Jumping ahead, the vendor in the revised protocol will not try to verify that p is in the right range but will rather make sure that any such violation on the part of the buyer will cripple all future interactions. We note that <ref type="bibr" target="#b2">[3]</ref> gives an efficient zero-knowledge proof to a related problem, of proving that a committed number lies in a an interval. However, the problem we solve (and hence our machinery for solving it) is easier.</p><p>Sending an Item. We now assume that 0 ≤ p ≤ b and that the balance was updated by the vendor. All that is left is for the vendor to "send" an item x i such that p = p i (if such an item exists).</p><p>The vendor's message is composed of n (parallel) messages m 0 , m 1 , . . . , m n-1 . For every j, the message m j allows the buyer to compute x j in case p = p j and gives the buyer no information if p = p j . Note that for a fixed j, what we have is in a sense an instance of conditional disclosure in a computational setting. The vendor wants to disclose the value x j conditioned on p = p j . For this simple condition (equality) the solution is very simple: For every j, the vendor uniformly samples α j ∈ Z Q and sets m j to be a (random) encryption E(β j ) of β j = α j (p -p j ) + x j . It is immediate that β j = x j in case p = p j and is random in Z Q if p = p j (therefore, in this case the buyer gets no information on x j in an information theoretic sense).</p><p>Adapting the conditional disclosure methodology of <ref type="bibr" target="#b10">[11]</ref> to the computational setting is one of the main tools of our solution. In addition to the example above, it is used extensively in Sections 3.3 and 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Reducing the Communication</head><p>The protocol of Section 3.1 has the disadvantage that the vendor's message is of linear length as a function of n (the number of items). This in itself is a nontrivial task and for some applications may be sufficient. We now give a simple method for reducing the communication. In Section 3.5 we provide a method for reducing the communication which is superior in most settings of the parameters (but is slightly more involved).</p><p>The main observation for reducing the communication is simple: If the buyer wants to retrieve item x i then the only part of the vendor's message it needs is the value m i (in fact, the rest of the message is useless). Therefore, instead of getting the entire sequence, m 0 , m 1 , . . . , m n-1 , the buyer can just retrieve m i using a PIR protocol (where we view the vendor's message as a database of n records). Note that in this case PIR is sufficient since security is preserved even if the buyer learns the entire sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Avoiding Zero-Knowledge Proofs</head><p>In the protocol of Section 3.1, the buyer sends an encryption E k (p) and proves in zero-knowledge that 0 ≤ p ≤ b. This was important for two reasons: (1) To prevent the buyer from learning x i with p i &gt; b in the current transaction; (2) To prevent the buyer from increasing its balance (in order to gain additional information in future transactions). However, as discussed above, both interactive and non-interactive zero-knowledge proofs are not efficient enough for our needs, and are in a sense an overkill. We now show how to replace zero-knowledge proofs with conditional disclosures. In these solutions, the vendor will not be able to detect a value p that is outside of the range [0, b]. Nevertheless, each such violation will prevent the buyer from learning any additional information.</p><p>The idea is simple. At the t-th transaction, the vendor will sample a random mask v t and a random receipt u t . The vendor will disclose v t and u t under the condition that 0 ≤ p ≤ b. The value v t will be used to mask the interaction in the current transaction (i.e. instead of retrieving x i the buyer will retrieve x i + v t ). The value u t will be used as a receipt for future interaction -knowing u t implies that the buyer behaved correctly until now.</p><p>A naive way to use the receipt u t is to require the buyer to send it at the beginning of the next transaction. As it turns out, this solution may compromise the privacy of the buyer against a malicious vendor. We therefore use a chaining technique: at the t-th transaction the buyer will also send an encryption E k (u). The vendor will disclose v t and u t under the condition (0 ≤ p ≤ b) ∧ (u = u t-1 ). We note that other methods of chaining are possible in this scenario. However, we find this particular solution appealing, both from a conceptual point of view and because it allows to maintain statistical vendor's security.</p><p>One may view this kind of chaining as an ongoing proof of the buyer that it behaves correctly, where the proof never gets to its conclusion (i.e. convincing the vendor). This kind of a technique may be useful in other scenarios.</p><p>It remains to show how to perform the more involved conditional disclosure needed here. We already saw how to perform conditional disclosure for equality. This also implies a recursive way to perform conditional disclosure under any condition that can be described as a monotone formula where the leaves are equalities: Assume we know how to perform conditional disclosure under the conditions A 1 and A 2 . To perform conditional disclosure of x under (A 1 ∨ A 2 ), just perform two independent conditional disclosures of x -One under A 1 and the other under A 2 . To perform conditional disclosure of x under (A 1 ∧ A 2 ), sample a random mask r, disclose r under A 1 and x + r under A 2 .</p><p>To perform a conditional disclosure under the condition (0 ≤ p ≤ b) ∧ (u = u t-1 ) it is enough to describe the condition 0 ≤ p ≤ b by a small monotone formula as above. For this purpose we will need some help from the buyer. Recall that B = 2 is an upper bound on a valid balance. In its message, the buyer will send separate encryptions of the bits b -1 , . . . , b 0 and p -1 , . . . , p 0 where b -1 . . . b 0 is supposed to be the binary representation of the current balance b and p -1 . . . p 0 defines the price p (i.e. p = j p j 2 j ). Note that the vendor can create an encryption of p from the encryptions of the bits p i . The condition 0 ≤ p ≤ b is implied by the conjunction of the following conditions: (1) b = j b j 2 j ;</p><p>(2) b -1 , . . . , b 0 and p -1 , . . . , p 0 are all bits; (3) p ≤ b when p and b are viewed as integers. It is well known (and rather simple) that (3) can be represented as a monotone formula of size O( ) with leaves that are equalities (in the bits b -1 , . . . , b 0 , p -1 , . . . , p 0 and the constants 0 and 1). We may therefore conclude that 0 ≤ p ≤ b can also be represented as such a monotone formula of size O( ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Putting the Pieces Together</head><p>The ideas presented so far already combine into a protocol that satisfies the specification of Section 2.1, has the desired communication pattern, and is relatively efficient. This protocol is still not the most efficient we propose (significant improvements are described in Section 3.5) and it does not handle subscriptions (which are dealt with in Section 4). Nevertheless, since most of the ideas already appear in this solution, we now give a short summary of the protocol and informally discuss its properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Protocol</head><p>Initialization. The buyer applies the key generator G to sample a public-key, secret-key pair (k, sk) and sends the public-key k to the vendor. The buyer also proves in zero-knowledge that it knows an input of G that generates the public key k. The vendor creates an encryption E k (b (0) ) of the initial balance b (0) . Finally, both set u 0 to be some predefined string (e.g. the all zero string).</p><p>Buyer (time t &gt; 0). The buyer's message is composed of (1) E k (u) (u is supposed to be u t-1 ); (2) E k (b -1 ), . . . , E k (b 0 ) and E k (p -1 ), . . . , E k (p 0 ), where b -1 . . . b 0 is supposed to be the binary representation of the current balance b (t-1) and p -1 . . . p 0 the binary representation of the price p i ; (3) A PIR query q for the index i.</p><p>Vendor. The vendor computes an encryption of p = j p j 2 j and creates an encryption of the new balance b (t) = b (t-1) -p. It samples two keys v t and u t uniformly at random in F and discloses both under the condition (b = j b j 2 j )∧ (0 ≤ p ≤ b) ∧ (u = u t-1 ). For every j, the vendor computes m j which is the conditional disclosure of x j + v t under the condition p j = p. Finally, the vendor answers with the PIR answer to the query q for the database (m 0 , . . . , m n-1 ).</p><p>Buyer's output. The buyer retrieves m i and computes x i (which is its output for this transaction). In addition, the buyer recovers and stores u t for future interaction and also remembers the new balance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Properties</head><p>Correctness. For honest buyer and vendor is straightforward.</p><p>Buyer's security. Follows from the semantic security of E since all the (even malicious) vendor sees at each transaction is a fixed number of encryptions. That is, a simulator for the view of V * may first simulate the initialization stage, and then produce an appropriate number of encryptions for each transaction.</p><p>Vendor's security. For any buyer B * , even malicious and unbounded, there exists an efficient simulator S, with black-box access to B * , that produces an output which is statistically close to the view of B * . The simulator invokes B * and simulates its conversation with V. The first step is to extract (using the zero-knowledge extractor) the secret-key sk that corresponds to k. Given this information, the rest of the simulation is fairly trivial. The only point that needs arguing is that starting at the first time t for which the condition</p><formula xml:id="formula_2">(b = j b j 2 j ) ∧ (0 ≤ p ≤ b) ∧ (u = u t-1</formula><p>) is violated it will be violated at all subsequent transactions (with overwhelming probability).</p><p>Efficiency. Excluding the PIR protocol, the buyer performs O( ) public-key operations and its message consists of O( ) encryptions. The vendor however is much less efficient -it performs O(n) public-key operations (to create the messages m j ). The vendor's message consists of a PIR reply for the database containing the strings m j . This in itself already seems optimal: Any solution to our problem will in particular give a PIR protocol for the database x 0 , x 1 , . . . , x n-1 . Therefore, we cannot expect to have communication which is smaller than that of a PIR protocol. However, here the strings m j can be significantly longer than the strings x j , which may result in a communication blowout. In Section 3.5 we show how to achieve savings in both the communication and work on the part of the vendor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Additional Improvements</head><p>We now describe a modification of the protocol of Section 3.4 that typically improves its performance. The alternative approach is especially natural in the case where the vendor only sells keys encrypting the data, and the encrypted data is accessed by other means (e.g., via broadcast, or a PIR protocol). We assume that these keys are refreshed at each transaction (in particular, we would not like the buyer to get all values of x i after buying it once) and describe the modification in this setting.</p><p>The keys that the vendor will sell are a carefully chosen subsequence of the Naor-Pinkas pseudo-random sequence (see Section 2.3). Let be as above (i.e. the length of the binary representation of prices). Let (s 0 0 , s 1 0 ), (s 0 1 , s 1 1 ), . . . , (s 0 -1 , s 1 -1 ) be pairs of independent keys to a pseudo-random function f , and let {k z } z∈{0,1} be the Naor-Pinkas sequence that is generated by these key pairs. The idea is the following. Let the j-th key that the vendor sells be the element of the Naor-Pinkas sequence indexed by the price p j of this key (i.e. the element k p j ). This slightly unusual choice (the more natural choice seems to be taking the j-th key to simply be k j ) is the main observation of the revised protocol. To make it even more compatible with our solution, we let the j-th key at time t be k p j + v t (recall that the sequence {k z } z∈{0,1} is refreshed at each transaction). We can now consider the following adjustment in the protocol.</p><p>The buyer sends almost the same message as before (there is no need to send the PIR query). Recall that as part of its message, the buyer sends encryptions of the bits of the price E k (p -1 ), . . . , E k (p 0 ). The vendor updates the balance and discloses v t and u t as before. In addition, for every 0 ≤ j &lt; and σ ∈ {0, 1}, the vendor discloses s σ j conditioned on p j = σ. Recall that given the keys s p -1 -1 . . . s p0 0 , the buyer can compute k p whereas the rest of the sequence (i.e. k z for z = p) remains pseudo-random. This implies the security of the protocol.</p><p>As for efficiency, we have that the O(n + ) public-key operations of the previous protocol are reduced to O( ) public-key operations, plus at most n private-key operations. The above excludes the computational cost of PIR, which depends on its specific implementation. In terms of communication, both the buyer and the vendor need only to send O( ) encryptions, and in addition to invoke a PIR protocol on a database which is now of an optimal size (since here each item is masked with a pseudo-random string of the same size).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Subscription</head><p>Recall that our motivation for letting the buyer issue a "subscribe" request is to allow efficient one-way communication from the vendor to the buyer. In this abstract we will sketch a relatively simple solution to this problem. A more efficient solution, whose details can be found in the full version, will be briefly discussed at the end of this section. Subscribing. As in the previous protocol, B sends to V encryptions of the bits of p = p i and b. In addition, B picks a value τ , 0 ≤ τ &lt; 2 , which is assumed to be a length of a prefix of the i-th channel it is entitled to buy, and sends encryptions of the bits of τ . An honest buyer can let τ = b/p , regardless of the intended subscription length. V discloses a mask v and a receipt u subject to the condition (0 ≤)τ • p &lt;= b, and a key k p encrypting the future contents of the channel indexed by p. An efficient implementation of the former disclosure, which requires some additional help from B, will be described later. As before, k p and v will be used to encrypt the received data during the current subscription, and the receipt to cripple future transactions in a case of cheating. Maintaining a subscription. At the t-th transaction following a subscription, each channel will further be masked with a key v t , which will be disclosed subject to the condition t ≤ τ . Note that this does not require the help of B, since the encrypted bits of τ are given to the vendor during the initialization. Unsubscribing. If B unsubscribes after T transactions, V deducts from its balance the amount T • p (note that this can be done efficiently from the public value T and the encrypted values of p, b). If the buyer's balance turns negative (by failing to unsubscribe before depleting its balance), all its future transactions will automatically be crippled. <ref type="foot" target="#foot_4">5</ref>It remains to describe the implementation of the conditional disclosure in the subscription procedure described above, namely a disclosure subject to the condition τ • p ≤ b. The fact that the underlying field F is large allows to obtain much greater efficiency than that obtained by emulating a Boolean multiplication circuit. The disclosure procedure proceeds as follows. B will provide, as additional help, encryptions of a -1 = (τ -1 2 -1 ) • p, . . . , a 0 = (τ 0 2 0 ) • p. If B acts honestly, these should sum up to the product τ • p. To guarantee that each a j is valid, observe that V can compute the two possible valid values of a j , and disclose to B a mask subject to the condition that a j is indeed consistent with the value of τ j . That is, the j-th conjunct in the condition is of the form: (τ j = 0 ∧ a j = 0) ∨ (τ j = 1 ∧ a j = 2 j p). Finally, using the methods of the previous section, an additional mask will be disclosed subject to the condition a j ≤ p (note that an encryption of a j can be computed by the vendor alone). As before, the latter conditional disclosure will require B to send the encrypted bit representation of the sum. This concludes the description of the conditional disclosure procedure, and thus of the entire subscription protocol. Efficiency. Both initializing a subscription and each subsequent transaction require O( ) public-key operations, with communication consisting of O( ) encryptions. In comparison to the implementation of a "buy" operation from the previous section, initializing a subscription is more expensive, but maintaining it is significantly cheaper. A more efficient protocol. In a typical case where subscriptions are more frequently maintained than initialized, it is important to optimize the efficiency of the procedure for maintaining a subscription. In particular, it is desirable to avoid public-key operations altogether. In the full version of this paper we describe an implementation which achieves the above goal. In the core of this solution is an efficient subprotocol, performed during the subscription initialization stage, which allows B to effectively learn a prefix of length τ from a pseudo-random key sequence of length 2 . This subprotocol may be of independent interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">One-Round Oblivious Transfer</head><p>Oblivious Transfer (OT) <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b3">4</ref>] may be viewed as the simplest atomic building block for general secure computation <ref type="bibr" target="#b14">[15]</ref>. OT is a 2-party protocol between Alice and Bob. In its most common variant, also known as 2  1 -OT, Alice holds a selection bit b and Bob holds a pair of secrets x 0 , x 1 . At the end of the protocol, Alice should output x b and learn no information on x 1-b , and Bob should output and learn nothing.</p><p>As a special case of our general methodology, we obtain an efficient 1-round OT protocol which satisfies a reasonable security definition. Unlike a previous construction of <ref type="bibr" target="#b0">[1]</ref> which is not known to be secure under a standard computational assumption (i.e. without using the random oracle methodology), our construction can be based on the standard DDH assumption. A similar construction (and definition) has been independently proposed by Naor and Pinkas <ref type="bibr" target="#b20">[21]</ref>. For lack of space in this extended abstract, we only briefly describe the protocol and discuss its security features.</p><p>Our 2 1 -OT protocol naturally extends into a more general n 1 -OT protocol (where Alice retrieves one of n secrets held by Bob). We therefore directly describe our solution in this setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">n 1 -OT Protocol</head><p>Each transaction of a priced oblivious transfer protocol trivially implies an OT protocol. However, in our one-round implementations of such a transaction we assumed an initialization phase, which is not part of the setting in a standalone OT protocol. In fact, one part of the initialization phase will also be part of our OT protocol: Alice still needs to sample a public-key, secret-key pair (k, sk) and send the public-key k to Bob. Moreover, Bob still needs to verify that k is valid. However, in this case Alice cannot prove that k is valid (there is just not enough interaction). We therefore assume that the underlying homomorphic encryption scheme enjoys the verifiability property discussed in Section 2.3, as is the case for the El-Gamal scheme. For such an encryption scheme, Bob can verify on its own that k has a corresponding secret key sk (although Alice may not know this key). We can now define our basic n 1 -OT protocol: Alice invokes G to sample a public-key, secret-key pair (k, sk). She then sends to Bob the public-key k and a random encryption c = E k (i) of i. Bob verifies that k is a valid public key and c is a valid encryption. In such a case, for every j ∈ [n], Bob computes m j which is the conditional disclosure of x j conditioned on j = i (i.e. m j is a random encryption of α j (i -j) + x j for a uniformly distributed element α j of F ). Bob sends m 0 , . . . , m n-1 . Alice decrypts m i = E(x i ) and outputs x i . Security. Various definitions of security for OT have been proposed. The most widely accepted are those relying on a general framework for defining secure twoparty computation (cf., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12]</ref>). We are unable to obtain this level of security while preserving the minimal number of rounds in our protocol. In a nutshell, the security definition satisfied by the above protocol relaxes the simulationbased definition of <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12]</ref> in two ways. First, the simulator for Alice is allowed to be computationally unbounded (yet its simulation quality is perfect or statistical rather than computational). This may be interpreted as saying that Bob's security is purely information theoretic. Second, the simulator for Bob should simulate Bob's view alone, without considering its correlation with Alice's output. In particular, we do not require that a cheating Bob knows the input to which Alice's selection effectively applies. We feel however that the notion of security we achieve is perfectly suitable for OT, either as a standalone application, or in more general "information-retrieval" contexts such as the one studied in this work. Next we analyze the security of the above protocol.</p><p>The view of a possibly cheating Bob only contains a random public-key and a (random) encryption. Therefore, the semantic security of E implies that this view can be simulated. The view of a possibly cheating Alice (even an unbounded one) can be perfectly emulated by an unbounded simulator. The simulator first computes the private key sk that corresponds to k (if such a key does not exist, Bob would refuse to interact with Alice). Note that this requires the simulator to be unbounded. Now there exists at most a single i for which c = E k (i). If such an i exists the simulator queries for x i and defines m i to be a random encryption of x i . For all other j, the simulator defines m j to be a random encryption of a random element. It is easy to verify that this is a perfect simulation. <ref type="foot" target="#foot_5">6</ref>Efficiency and Improvements. Alice's work consists of sampling a key and a constant number of public-key operations. Bob performs O(n) public-key operations and its message contains n encryptions. However, the improvements in efficiency that are described in Sections 3.2 and 3.5 apply also in the contexts of the OT protocol. We omit the details in this preliminary version.</p></div>			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>By having the buyer pay to a third party, the vendor may be initialized with an encryption of the buyer's deposit and therefore not even learn the deposit amount.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>One may argue that without any such information, the vendor can hardly optimize the offered goods. However, marketing-related information can still be voluntarily provided to the vendor by potential buyers.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This problem is very similar to n 1 -OT, except for a different multi-server model and the focus on sublinear communication.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Suppose that the encryption scheme enjoys the verifiability property discussed in Section 2.3. In this case, if the vendor is willing to settle on a somewhat weaker notion of security, it can verify the validity of k on its own instead of letting the buyer prove this validity as above. We use this fact in our one-round oblivious transfer (where we cannot afford the additional rounds required for the zero-knowledge proof).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>We assume here that |F |/2 is sufficiently large to make a balance wraparound infeasible. This assumption holds for any reasonable choice of parameters.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>In this we assume that the verification process of E is never wrong (as is the case for the El-Gamal encryption). We also assume that the secrets are group elements</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We wish to thank Avi Rubin for discussions which initiated this work, and Moni Naor and Benny Pinkas for helpful discussions and pointers. We also thank the anonymous referees for their comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Non-interactive oblivious transfer and applications. CRYPTO &apos;89</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="547" to="557" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Anonymity and Unobservability in the Internet</title>
		<author>
			<persName><forename type="first">O</forename><surname>Berthold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Federrath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kohntopp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Freedom and Privacy</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="57" to="65" />
		</imprint>
	</monogr>
	<note>Project</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Efficient proofs that a committed number lies in an interval. EURO-CRYPT 2000</title>
		<author>
			<persName><forename type="first">F</forename><surname>Boudot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="431" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">All-or-nothing disclosure of secrets. CRYPTO &apos;86</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Robert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="234" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Computationally private information retrieval with polylogarithmic communication</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT &apos;99</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="402" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Security and composition of multiparty cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Cryptology</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Security without identification: Transaction systems to make big brother obsolete</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1030" to="1044" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Untraceable electronic cash. CRYPTO &apos;88</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<title level="m">Private information retrieval. FOCS &apos;95</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="41" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A randomized protocol for signing contracts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">C. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="637" to="647" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Protecting data privacy in private information retrieval schemes</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="592" to="629" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>Preliminary version in STOC &apos;98</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<ptr target="http://philby.ucsb.edu/cryptolib/BOOKS" />
		<title level="m">Secure multi-party computation</title>
		<imprint>
			<date type="published" when="1999-02">February 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">How to play any mental game</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC &apos;87</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Private simultaneous messages protocols with applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC &apos;97</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="174" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Basing cryptography on oblivious transfer</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC &apos;98</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="20" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Replication is not needed: Single database, computationally-private information retrieval</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS &apos;97</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="364" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Private access to distributed information</title>
		<author>
			<persName><forename type="first">E</forename><surname>Mann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Technion -Israel Institute of Technology, Haifa</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Naccache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
		<title level="m">A new public key cryptosystem. EUROCRYPT &apos;97</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="27" to="36" />
		</imprint>
	</monogr>
	<note>otherwise the simulated view can only be made statistically close to the actual view</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Oblivious transfer and polynomial evaluation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC &apos;99</title>
		<imprint>
			<biblScope unit="page" from="245" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Oblivious transfer with adaptive queries. CRYPTO &apos;99</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="573" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient oblivious transfer protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SODA</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Number theoretic constructions of efficient pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">97</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Uchiyama</surname></persName>
		</author>
		<title level="m">A new public key cryptosystem as secure as factoring. EUROCRYPT &apos;98</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="308" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residuosity classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pallier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT &apos;99</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">How to exchange secrets by oblivious transfer</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<idno>TR-81</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Harvard Aiken Computation Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On blind signatures and perfect crimes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Solms</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Naccache</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Security</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="581" to="583" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A new and efficient all-or-nothing disclosure of secrets protocol. ASI-ACRYPT &apos;98</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Stern</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="357" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS &apos;86</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="162" to="167" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
