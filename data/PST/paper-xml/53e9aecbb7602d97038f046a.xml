<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Differential Dynamic Logic for Hybrid Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2008-08-20">20 August 2008</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">André</forename><surname>Platzer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">University of Oldenburg</orgName>
								<address>
									<postCode>26111</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Science</orgName>
								<orgName type="institution">University of Oldenburg</orgName>
								<address>
									<postCode>26111</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Differential Dynamic Logic for Hybrid Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2008-08-20">20 August 2008</date>
						</imprint>
					</monogr>
					<idno type="MD5">839A129D8A74271FFBAC283793DC5113</idno>
					<idno type="DOI">10.1007/s10817-008-9103-8</idno>
					<note type="submission">Received: 23 August 2007 / Accepted: 27 June 2008 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Hybrid systems are models for complex physical systems and are defined as dynamical systems with interacting discrete transitions and continuous evolutions along differential equations. With the goal of developing a theoretical and practical foundation for deductive verification of hybrid systems, we introduce a dynamic logic for hybrid programs, which is a program notation for hybrid systems. As a verification technique that is suitable for automation, we introduce a free variable proof calculus with a novel combination of real-valued free variables and Skolemisation for lifting quantifier elimination for real arithmetic to dynamic logic. The calculus is compositional, i.e., it reduces properties of hybrid programs to properties of their parts. Our main result proves that this calculus axiomatises the transition behaviour of hybrid systems completely relative to differential equations. In a case study with cooperating traffic agents of the European Train Control System, we further show that our calculus is well-suited for verifying realistic hybrid systems with parametric system dynamics.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Ensuring correct functioning of complex physical systems is among the most challenging and most important problems in computer science, mathematics, and engineering. In addition to the underlying physical system dynamics, the behaviour of complex systems is determined increasingly by computerised control and automatic analog or digital decision-making, e.g., in aviation, railway, or automotive applications.</p><p>Hybrid Systems As a common mathematical model for complex physical systems, hybrid systems are dynamical systems <ref type="bibr" target="#b46">[45]</ref> where the system state evolves over time according to interacting laws of discrete and continuous dynamics <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b56">55]</ref>. Continuous dynamics is specified by differential equations. It results, e.g., from the continuous movement of a train along the track (train position z evolves with velocity v along the differential equation z = v where z is the time-derivative of z) or from the continuous variation of its velocity over time (v = a with acceleration a). Other behaviour can be modelled more naturally by discrete dynamics, for example, the instantaneous change of control variables like the acceleration (e.g., the changing of a by setting a := -b with braking force b &gt; 0) or change of status information in discrete controllers. Both kinds of dynamics interact, e.g., when measurements of the continuous state affect decisions of discrete controllers (the train switches to braking mode when v is too high). Likewise, they interact when the resulting control choices take effect by changing the control variables of the continuous dynamics (e.g., changing control variable a in z = a). The superposition of continuous dynamics with analog or discrete control causes complex system behaviour, which can neither be verified by purely continuous reasoning (because of the discontinuities caused by discrete transitions) nor by considering discrete change in isolation (because safety depends on continuous states).</p><p>Among several other models for hybrid systems <ref type="bibr" target="#b11">[11]</ref>, hybrid automata <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b37">36]</ref> are the most widely used notation. They specify discrete and continuous dynamics in a graph, see Fig. <ref type="figure" target="#fig_1">1</ref> for a (much too) simple train control example. Each node corresponds to a continuous dynamical system and is decorated by its differential equation and an invariant region specifying the maximum domain of evolution. In node brake of Fig. <ref type="figure" target="#fig_1">1</ref>, the differential equations z = v, v = a only apply within the invariant region v ≥ 0 (the train does not move backwards by braking). Edges specify the discrete switching behaviour between the respective modes of continuous evolution. They can be decorated with conditions (guards) that need to hold and with discrete state transformations (jumps) that take instantaneous effect when the system follows the edge. For example, the automaton in Fig. <ref type="figure" target="#fig_1">1</ref> can take an edge to leave node accel when train z passed point s, set the acceleration to braking by a := -b , and enter mode brake.</p><p>Model Checking As a standard verification technique, model checking <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b25">24]</ref> has been used successfully for verifying temporal logic properties <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b26">25,</ref><ref type="bibr" target="#b51">50]</ref> of finitestate abstractions of automata-based transition structures by exhaustive state space exploration <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b38">37,</ref><ref type="bibr" target="#b45">44]</ref>. The continuous state spaces of hybrid automata, however, do not admit equivalent finite-state abstractions <ref type="bibr" target="#b37">[36]</ref>. Because of this, model checkers for hybrid automata use various approximations <ref type="bibr">[3-5, 13, 14, 28, 36, 37, 44, 57]</ref> and Fig. <ref type="figure" target="#fig_1">1</ref> Hybrid automaton for an (overly) simplified train control system are still more successful in falsification than in verification. Furthermore, for hybrid systems with symbolic parameters in the dynamics, correctness crucially depends on the free parameters (e.g., b and s in Fig. <ref type="figure" target="#fig_1">1</ref>). It is, however, quite difficult to determine corresponding symbolic parameter constraints from concrete values of a counterexample trace produced by a model checker, especially if they rely on nonstructural state splitting <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b30">29]</ref>. Finally, in hybrid systems with nontrivial interaction of discrete and continuous dynamics, parameters also have a nontrivial impact on the system behaviour, leading to nonlinear parameter constraints and nonlinearities in the discrete and continuous dynamics. Thus, standard model checking approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b37">36]</ref> cannot be used, as they require at most linear discrete dynamics.</p><p>Deductive Verification Deductive approaches <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b36">35,</ref><ref type="bibr" target="#b39">38,</ref><ref type="bibr" target="#b60">59</ref>] have been used for verifying systems by proofs instead of by state space exploration and, thus, do not require finite-state abstractions. Davoren and Nerode <ref type="bibr" target="#b22">[21]</ref> further argue that deductive methods support formulas with free parameters. First-order logic, for instance, has widely proven its power and flexibility in handling symbolic parameters as free or quantified logical variables. However, first-order logic has no built-in means for referring to state transitions, which are crucial for verifying dynamical systems where states change over time.</p><p>In temporal logics <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b26">25,</ref><ref type="bibr" target="#b51">50]</ref>, state transitions can be referred to using modal operators. In deductive approaches, temporal logics have been used to prove validity of formulas in calculi <ref type="bibr" target="#b22">[21,</ref><ref type="bibr" target="#b60">59]</ref>. Valid formulas of temporal logic, however, only express generic facts that are true for all systems, regardless of their actual behaviour. Hence, the behaviour of a specific hybrid system would need to be characterised declaratively with temporal formulas to obtain meaningful results. Then, however, equivalence of declarative temporal representations and actual system operations needs to be proven separately using other techniques.</p><p>Dynamic logic (DL) <ref type="bibr" target="#b35">[34,</ref><ref type="bibr" target="#b36">35,</ref><ref type="bibr" target="#b52">51]</ref> is a successful approach for verifying infinite-state discrete systems deductively <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b36">35,</ref><ref type="bibr" target="#b39">38]</ref>. Like model checking, DL does not need declarative characterisations of system behaviour but can analyse the transition behaviour of actual operational system models directly. Yet, operational models are fully internalised within DL-formulas, and DL is closed under logical operators. Within a single specification and verification language, it combines operational system models with means to talk about the states that are reachable by following system transitions. DL provides parameterised modal operators [α] and α that refer to the states reachable by system α and can be placed in front of any formula. The formula [α]φ expresses that all states reachable by system α satisfy formula φ. Likewise, α φ expresses that there is at least one state reachable by α for which φ holds. These modalities can be used to express necessary or possible properties of the transition behaviour of α in a natural way. They can be nested or combined propositionally. In first-order DL with quantifiers, ∃ p[α] β φ says that there is a choice of parameter p such that for all possible behaviour of system α there is a reaction of system β that ensures φ. Likewise, ∃ p([α]φ ∧ [β]ψ) says that there is a choice of parameter p that makes both [α]φ and [β]ψ true, simultaneously.</p><p>On the basis of first-order logic over the reals, which we use to describe safe regions of hybrid systems and to quantify over parameter choices, we introduce a first-order DL over the reals with modalities that directly quantify over the possible transition behaviour of hybrid systems. Since hybrid systems are subject to both continuous evolution and discrete state change, we generalise DL so that operational models α of hybrid systems can be used in modal formulas like [α]φ.</p><p>Compositional Verification As a verification technology for our logic, we devise a compositional proof calculus for verifying properties of a hybrid system by proving properties of its parts. The calculus decomposes [α]φ symbolically into an equivalent formula, e.g., [α 1 ]φ 1 ∧ [α 2 ]φ 2 about subsystems α i of α and subproperties φ i of φ. With this, [α]φ can simply be verified by proving the [α i ]φ i separately and combining the results conjunctively. In particular, synthesised parameter constraints carry over from the latter to the former just by conjunction.</p><p>Unfortunately, hybrid automata are not suitably compositional for this purpose. Their graph structures cannot be decomposed into subgraphs α i so that [α 1 ]φ 1 ∧ [α 2 ]φ 2 is equivalent to [α]φ, because of the dangling edges between the subgraphs α i . For instance, the automaton in Fig. <ref type="figure" target="#fig_1">1</ref> cannot simply be verified by proving [accel]φ ∧ [brake]φ, because the effects of edges between the nodes need to be taken into account.</p><p>Consequently, we do not impose an automaton structure on the system. Instead, we introduce hybrid programs as a textual program notation for hybrid systems that allows for flexible programmatic combinations of elementary discrete or continuous transitions by structured control programs with a perfectly compositional semantics: The semantics of a compound hybrid program is a simple function of the semantics of its parts and does not further depend on automata graph structures. The resulting first-order DL for hybrid programs is called differential dynamic logic (dL) and constitutes a natural specification and verification logic for hybrid systems. With the goal of developing a solid theoretical, practical, and applicable foundation for deductive verification of hybrid systems by automated theorem proving, the focus of this paper is a thorough analysis of the logic dL and its calculus.</p><p>Lifting Quantifier Elimination When proving dL formulas, interacting hybrid dynamics causes interactions of arithmetic quantifiers and dynamic modalities, which both affect the values of symbols. For continuous evolutions, we have to prove formulas like ∀t[α] x≥0 expressing that, for all durations t of some evolution in α, x ≥ 0 holds after all executions of system α. Standard first-order quantifier rules <ref type="bibr" target="#b27">[26,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b34">33]</ref> are incomplete for handling these situations, because they are based on instantiation or unification, which is already insufficient for proving the tautology ∀z(z 2 ≥ 0). Unfortunately, decision procedures for real arithmetic like real quantifier elimination <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b55">54]</ref> cannot handle ∀t either, because of the modality <ref type="bibr">[α]</ref> . The actual algebraic constraints on t still depend on how the system variables evolve along the dynamics of α. This effect inherently results from the interacting dynamics of hybrid systems, where the duration t of a continuous evolution determines the resulting state and, hence, affects all subsequent discrete or continuous evolutions in α. Thus, the effect of α first needs to be analysed with respect to the arithmetical constraints it imposes on t for x ≥ 0 to hold, before the quantifier ∀t can be handled.</p><p>In our previous work <ref type="bibr" target="#b48">[47]</ref>, we used separate side deductions for reducing the unquantified kernel <ref type="bibr">[α]</ref>x ≥ 0 to some arithmetic formula ψ before returning to ∀tψ in the main proof. This is easy to understand and can be performed without much change in interactive theorem provers. It is, however, not necessarily well-suited for automation.</p><p>In this paper, we present an improved calculus that is suitable for automation and combines deductive and arithmetical quantifier reasoning within a single proof. It introduces real-valued free variables and Skolem terms to postpone quantifier elimination and continue reasoning beyond the occurrence of a real quantifier in front of a modality. Later, however, our calculus reintroduces a corresponding quantifier into the proof when its algebraic constraints have been discovered completely.</p><p>For ∀t <ref type="bibr">[α]</ref>x ≥ 0, our calculus will, for instance, continue with the unquantified kernel [α]x ≥ 0 after replacing t by a Skolem term s(x). Once all arithmetical constraints on s(x) are known, a quantifier for s(x) is reintroduced and handled by real quantifier elimination <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b55">54]</ref>. In a similar manner, our calculus combines quantifier elimination with deduction for handling existential real quantifiers using real-valued free variables.</p><p>We introduce a calculus that makes this intuition formally precise. Crucially, we exploit the relationship of Skolem terms and free variables in order to keep track of the lost quantifier nesting to prohibit unsound rearrangements of quantifiers when they are reintroduced. The corresponding calculus rules are perfectly natural and comply with the prerequisites of quantifier elimination over the reals. Further, the dL semantics and calculus are fully compositional so that properties of a hybrid program can be proven by reduction to properties of its parts following a structural symbolic decomposition within the dL calculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>Model checking approaches work by state space exploration and require <ref type="bibr" target="#b37">[36]</ref> various abstractions or approximations <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b29">28,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b38">37,</ref><ref type="bibr" target="#b45">44,</ref><ref type="bibr" target="#b58">57]</ref> for hybrid automata, including numerical approximations <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b13">13]</ref>.</p><p>Beyond standard approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b37">36]</ref> for linear systems with constant dynamics, Lafferriere et al. <ref type="bibr" target="#b42">[41]</ref> presented a decision procedure for o-minimal hybrid automata and classes of linear dynamics with a homogeneous eigenstructure. They analyse the discrete and continuous dynamics independently, which requires completely decoupled dynamics with forgetful jumps, i.e., where the outcome of a jump is completely independent of the continuous state.</p><p>Chutinan and Krogh <ref type="bibr" target="#b13">[13]</ref> presented polyhedral approximations of hybrid automata with polyhedral discrete dynamics, invariants, and initial state sets.</p><p>Fränzle <ref type="bibr" target="#b29">[28]</ref> showed that reachability is decidable for specific classes of robust polynomial hybrid automata, where the safe and unsafe states are sufficiently separate and the safe region is bounded.</p><p>Asarin et al. <ref type="bibr" target="#b5">[5]</ref> used piecewise linear numerical approximations in an approximate reachability algorithm for continuous systems with known Lipschitz bounds.</p><p>Mysore et al. <ref type="bibr" target="#b45">[44]</ref> showed decidability of bounded-time and bounded switching reachability prefixes of semi-algebraic hybrid automata.</p><p>Because hybrid systems do not admit equivalent finite-state abstractions <ref type="bibr" target="#b37">[36]</ref> and due to general limits of numerical approximation <ref type="bibr" target="#b50">[49]</ref>, model checkers are still more successful in falsification than in verification. To obtain a sound verification approach and for improved handling of free parameters <ref type="bibr" target="#b22">[21]</ref>, we follow a symbolic logic-based approach and support dL as a significantly more expressive specification language. Finally, we introduce hybrid programs as a more uniform model for hybrid systems that is amenable to compositional symbolic verification.</p><p>Zhou et al. <ref type="bibr" target="#b60">[59]</ref> extended duration calculus with mathematical expressions in derivatives of state variables. They use a multitude of calculus rules and a non-constructive oracle that requires external mathematical reasoning about the notions of derivatives and continuity.</p><p>Davoren and Nerode <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b22">21]</ref> presented a semantics of modal μ-calculus in hybrid systems and examine topological aspects. They provided Hilbert-style calculi to prove formulas that are valid for all hybrid systems simultaneously. With this, however, only limited information can be obtained about a particular system: In propositional modal logics, system behaviour needs to be axiomatised declaratively in terms of abstract actions a, b, c of unknown effect.</p><p>Inspired by He <ref type="bibr" target="#b40">[39]</ref>, Zhou et al. <ref type="bibr" target="#b12">[12]</ref> presented a hybrid variant of CSP as a language for describing hybrid systems. They gave a semantics in extended duration calculus <ref type="bibr" target="#b60">[59]</ref> but no verification technique.</p><p>Rönkkö et al. <ref type="bibr" target="#b53">[52]</ref> extended guarded command programs with differential relations and gave a weakest-precondition semantics in higher-order logic with built-in derivatives. Without providing a means for verification of this higher-order logic, this approach is still limited to providing a notational variant of classical mathematics.</p><p>The strength of our logic primarily is that it is an expressive first-order DL: It handles actual operational models of hybrid systems like a := a + 5; z = a instead of abstract propositional actions of unknown effect. The advantage of our calculus in comparison to others <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b60">59]</ref> is that it provides a constructive modular combination of arithmetic reasoning with reasoning about hybrid transitions and works by structural decomposition. With this, our calculus can be used easily for verifying actual operational hybrid system models, which is of considerable practical interest <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b45">44,</ref><ref type="bibr" target="#b50">49]</ref>. It supports free parameters and first-order definable flows, which are well-suited for verifying the coordination of train dynamics. Firstorder approximations of more general flows can be used according to <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b46">45,</ref><ref type="bibr" target="#b50">49]</ref>.</p><p>Manna et al. <ref type="bibr" target="#b41">[40,</ref><ref type="bibr" target="#b43">42]</ref> and Ábrahám et al. <ref type="bibr" target="#b0">[1]</ref> used theorem provers for checking invariants of hybrid automata in STeP <ref type="bibr" target="#b43">[42]</ref> or PVS <ref type="bibr" target="#b0">[1]</ref>, respectively. Their working principle is, however, quite different from ours. Given a hybrid automaton and given a global system invariant, they compile, in a single step, a verification condition expressing that the invariant is preserved under all transitions of the hybrid automaton. Hence, hybrid aspects and transition structure vanish completely before the proof starts. All that remains is a flat quantified mathematical formula. Which hybrid systems can be verified with this approach in practice strongly depends on the general mathematical proving capabilities of STeP and PVS, which typically require user interaction.</p><p>In contrast, we follow a fully symbolic approach using a genuine specification and verification logic for hybrid systems. Our DL works deductively by symbolic decomposition and preserves the transition structure during the proof, which simplifies traceability of results considerably. Further, the structure in this symbolic decomposition can be exploited for deriving invariants or parametric constraints. Consequently, in dL, invariants do not necessarily need to be given beforehand. Moreover, in practice, guiding quantifier elimination procedures along natural splitting possibilities of the structural decomposition performed by the dL calculus turns out to be important for successful automatic proof strategies <ref type="bibr" target="#b47">[46]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>Our main conceptual contribution is the differential dynamic logic dL for hybrid programs, which captures the logical quintessence of the dynamics of hybrid systems succinctly. Our main practical contribution is a concise free variable calculus for dL that axiomatises the transition behaviour of hybrid systems relative to differential equation solving. It is suitable for automated theorem proving and for verifying hybrid interacting discrete and continuous dynamics compositionally. Our main theoretical contribution is that we prove the dL calculus to be complete relative to the handling of differential equations. To the best of our knowledge, this is the first relative completeness proof for a logic of hybrid systems, and even the first formal notion of hybrid completeness. Our results fully align hybrid and continuous reasoning proof-theoretically and show that hybrid systems with interacting repetitive discrete and continuous evolutions can be verified whenever differential equations can. As an applied contribution, we further demonstrate that our logic and calculus can be used successfully for verifying collision avoidance in realistic train control applications.</p><p>This paper extends our previous results <ref type="bibr" target="#b48">[47]</ref> in various aspects. We generalise the logic to support systems of differential equations instead of one-dimensional change. We introduce a generalised free variable calculus that is significantly more suitable for automated theorem proving than previous calculi, and we prove our augmented calculus to be relatively complete. Finally, we extend our train case study to the general case with free acceleration and derive parameter constraints that are required for safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structure of this Paper</head><p>After introducing syntax and semantics of the differential dynamic logic dL in Section 2, we introduce a free variable sequent calculus for dL in Section 4 and prove soundness and relative completeness in Section 5. In Section 6, we use our calculus to prove an inductive safety property of a train control system presented in Section 3. We draw conclusions and discuss future work in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Syntax and Semantics of Differential Dynamic Logic</head><p>In this section, we introduce the differential dynamic logic dL in which operational models of hybrid systems are internalised as first-class citizens, so that correctness statements about the transition behaviour of hybrid systems can be expressed as formulas. As a basis, dL includes (nonlinear) real arithmetic for describing concepts like safe regions of the state space. Further, dL supports real-valued quantifiers for quantifying over the possible values of system parameters or durations of continuous evolutions. For talking about the transition behaviour of hybrid systems, dL provides modal operators like [α] or α that refer to the states reachable by following the transitions of hybrid system α.</p><p>The logic dL is a first-order DL over the reals for hybrid programs, which is a compositional program notation for hybrid systems. Hybrid programs provide: Discrete jump sets Discrete transitions are represented as instantaneous assignments of values to state variables, which are, essentially, difference equations. They can express resets a := -b or adjustments of control variables like a := a + 5, as occurring in the discrete transformations attached to edges in hybrid automata, see Fig. <ref type="figure" target="#fig_1">1</ref>. Likewise, implicit discrete state changes like the changing of evolution modes from one node of an automaton to the other can be expressed uniformly as, e.g., q := brake, where variable q remembers the current node. To handle simultaneous changes of multiple variables, discrete jumps can be combined to sets of jumps with simultaneous effect following corresponding techniques in the discrete case <ref type="bibr" target="#b8">[8]</ref>. For instance, the discrete jump set a := a + 5, A := 2a 2 expresses that a is increased by 5 and, simultaneously, variable A is set to 2a 2 , which is evaluated before a receives its new value.</p><p>Differential equation systems Continuous variation in system dynamics is represented using differential equation systems as evolution constraints. For example the differential equation z = -b describes deceleration and z = v, v = -b &amp; v ≥ 0 expresses that the evolution only applies as long as the speed is v ≥ 0, which represents mode brake of Fig. <ref type="figure" target="#fig_1">1</ref>. This is an evolution along the differential equation system z = v, v = -b that is restricted to remain within the region v ≥ 0, i.e., to stop braking before v &lt; 0. Such an evolution can stop at any time within v ≥ 0, it could even continue with transient grazing along the border v = 0, but it is never allowed to enter v &lt; 0.</p><p>Control structure Discrete and continuous transitions-represented as difference or differential equations, respectively-can be combined to form a hybrid program with interacting hybrid dynamics using regular expression operators (∪, * , ;) of regular programs <ref type="bibr" target="#b36">[35]</ref> as control structure. For example, q := accel ∪ z = -b describes a train controller that can either choose to switch to acceleration mode or brake by the differential equation z = -b , by a nondeterministic choice (∪). In conjunction with other regular combinations, control constraints can be expressed using tests like ?z ≥ s as guards for the system state.</p><p>With these operations, hybrid systems can be represented naturally as hybrid programs. For example, Fig. <ref type="figure" target="#fig_0">2</ref> depicts a hybrid program rendition of the hybrid automaton in Fig. <ref type="figure" target="#fig_1">1</ref>. We represent each discrete and continuous transition of the automaton as a sequence of statements with a nondeterministic choice between these transitions. Line 4 represents a continuous transition. It tests if the current node q is brake, and then follows a differential equation system restricted to the invariant region v ≥ 0. Line 3 characterises a discrete transition of the automaton. It tests the guard z ≥ s when in node accel, resets a := -b , and then switches q to node brake. By the semantics of hybrid automata <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b37">36]</ref>, an automaton in node accel is only allowed to make a transition to node brake if the invariant of brake is true when entering the node, which is expressed by the additional test ?v ≥ 0. In order to obtain a fully compositional model, hybrid programs make these implicit side-conditions explicit. Finally, the * -operator at the end of Fig. <ref type="figure" target="#fig_0">2</ref> expresses that the transitions of a hybrid automaton can repeat indefinitely.  The formulas of dL are built over a set V of real-valued logical variables and a (finite) signature of real-valued function and predicate symbols, with the usual function and predicate symbols for real arithmetic, such as 0, 1, +, -, •, /, =, ≤, &lt;, ≥, &gt;. System state variables are represented as real-valued constant symbols of . Unlike fixed symbols like 1, state variables are flexible <ref type="bibr" target="#b8">[8]</ref>, i.e., their interpretation can change from state to state during the execution of a hybrid program. Flexibility of symbols will be used to represent the progression of system values along states over time during a hybrid evolution. Rigid symbols like 1, instead, have the same value at all states.</p><p>There is no need to distinguish between discrete and continuous variables in dL. The distinction between logical variables in V, which can be quantified, and state variables in , which can change their value by discrete jumps and differential equations in modalities, is not strictly required. For instance, quantification of state variables is definable using auxiliary logical variables. The distinction makes the semantics less subtle, though. Our calculus assumes that V contains sufficiently many variables and contains additional Skolem function symbols, which are reserved for use by the calculus.</p><p>The set Trm( , V) of terms is defined as in classical first-order logic yielding polynomial (or rational) expressions over V and over additional Skolem terms s(t 1 , . . . , t n ) with terms t i . Our calculus only uses Skolem terms s(X 1 , . . . , X n ) with logical variables X i ∈ V. The set of formulas of first-order logic is defined as usual, giving first-order real arithmetic <ref type="bibr" target="#b55">[54]</ref> augmented with Skolem terms. We will show the relationship to standard first-order real arithmetic without Skolem terms in Lemma 2 of Section 4.2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Hybrid Programs</head><p>As uniform compositional models for hybrid systems, discrete and continuous transitions can be combined by structured control programs. Definition 1 (Hybrid programs) The set HP( , V) of hybrid programs, with typical elements α, β, is defined inductively as the smallest set such that</p><formula xml:id="formula_0">1. If x i ∈ is a state variable and θ i ∈ Trm( , V) for 1 ≤ i ≤ n, then the discrete jump set (x 1 := θ 1 , . . . , x n := θ n ) ∈ HP( , V) is a hybrid program. 2. If x i ∈ is a state variable and θ i ∈ Trm( , V) for 1 ≤ i ≤ n, then, x i = θ i is a differential equation in which x i represents the time-derivative of variable x i . If, further, χ is a first-order formula, then (x 1 = θ 1 , . . . , x n = θ n &amp;χ) ∈ HP( , V). 3. If χ is a first-order formula, then (?χ) ∈ HP( , V). 4. If α, β ∈ HP( , V), then (α ∪ β) ∈ HP( , V). 5. If α, β ∈ HP( , V), then (α; β) ∈ HP( , V). 6. If α ∈ HP( , V), then (α * ) ∈ HP( , V).</formula><p>The effect of jump set x 1 := θ 1 , . . . , x n := θ n is to simultaneously change the interpretations of the x i to the respective θ i by performing a discrete jump in the state space. In particular, the θ i are evaluated before changing the value of any x j . The effect of x 1 = θ 1 , . . . , x n = θ n &amp;χ is an ongoing continuous evolution respecting the differential equation system x 1 = θ 1 , . . . , x n = θ n while remaining within the region χ . The evolution is allowed to stop at any point in χ . It is, however, required to stop before it leaves χ . For unconstrained evolutions, we write x = θ in place of x = θ &amp; true. For structural reasons, we expect both difference equations (discrete jump sets) and differential equations to be given in explicit form, i.e., with the affected variable on the left. The dL semantics allows arbitrary differential equations. To retain feasible arithmetic, some of our calculus rules assume that, like in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b29">28,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b45">44]</ref>, the differential equations have first-order definable flows or approximations. We assume that standard techniques are used to determine corresponding solutions or approximations, e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b42">41,</ref><ref type="bibr" target="#b46">45,</ref><ref type="bibr" target="#b50">49,</ref><ref type="bibr" target="#b59">58]</ref>.</p><p>The test action ?χ is used to define conditions. Its semantics is that of a no-op if χ is true in the current state; otherwise, like abort, it allows no transitions. Note that, according to Definition 1, we only allow first-order formulas as tests. Instead, we could allow rich tests, i.e., arbitrary dL formulas χ with nested modalities as tests ?χ inside hybrid programs (and even in invariant regions χ of differential equations). The calculus and our meta-results directly carry over to rich test dL. To simplify the presentation, however, we refrain from allowing arbitrary dL formulas as tests, because that requires simultaneous inductive handling of hybrid programs and dL formulas in syntax, semantics, and completeness proofs, because dL formulas would then be allowed to occur in hybrid programs and vice versa.</p><p>The non-deterministic choice α ∪ β, sequential composition α; β, and nondeterministic repetition α * of programs are as usual but generalised to a semantics in hybrid systems. Choices α ∪ β are used to express behavioural alternatives between the transitions of α and β. The sequential composition α; β says that the hybrid program β starts executing after α has finished (β never starts if α does not terminate). Observe that, like repetitions, continuous evolutions within α can take longer or shorter, which already causes uncountable nondeterminism. This nondeterminism is inherent in hybrid systems and as such reflected in hybrid programs. Repetition α * is used to express that the hybrid process α repeats any number of times, including zero times. The control flow operations of choice, sequential composition, and repetition can be combined with ?χ to form all other control structures <ref type="bibr" target="#b36">[35]</ref>. For instance, (?χ ; α) * ; ?¬χ corresponds to a while loop that repeats α while χ holds and only stops when χ ceases to hold.</p><p>Hybrid programs are designed as a minimal extension of conventional discrete programs. They characterise hybrid systems succinctly by adding continuous evolution along differential equations as the only additional primitive operation to a regular basis of conventional discrete programs. To yield hybrid systems, their operations are interpreted over the domain of real numbers. This gives rise to an elegant syntactic hierarchy of discrete, continuous, and hybrid systems. Hybrid automata <ref type="bibr" target="#b37">[36]</ref> can be represented as hybrid programs using a straightforward generalisation of standard program encodings of automata. The fragment of hybrid programs without differential equations corresponds to conventional discrete programs generalised over the reals or to discrete-time dynamical systems <ref type="bibr" target="#b9">[9]</ref>. The fragment without discrete jumps corresponds to switched continuous systems <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b11">11]</ref>, whereas the fragment of differential equations gives purely continuous dynamical systems <ref type="bibr" target="#b54">[53]</ref>. Only the composition of mixed discrete jumps and continuous evolutions gives rise to truly hybrid behaviour.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Formulas of Differential Dynamic Logic</head><p>The formulas of dL are defined as in first-order dynamic logic <ref type="bibr" target="#b36">[35]</ref>. That is, they are built using propositional connectives ¬, ∧, ∨, →, ↔ and quantifiers ∀, ∃ (first-order part). In addition, if φ is a dL formula and α a hybrid program, then [α]φ, α φ are formulas (dynamic part).</p><p>Definition 2 (Formulas) The set Fml( , V) of formulas, with typical elements φ, ψ, is the smallest set such that 1. If p is a predicate symbol of arity n ≥ 0 and</p><formula xml:id="formula_1">θ i ∈ Trm( , V) for 1 ≤ i ≤ n, then p(θ 1 , . . . , θ n ) ∈ Fml( , V). 2. If φ, ψ ∈ Fml( , V), then ¬φ, (φ ∧ ψ), (φ ∨ ψ), (φ → ψ) ∈ Fml( , V). 3. If φ ∈ Fml( , V) and x ∈ V, then ∀xφ, ∃xφ ∈ Fml( , V). 4. If φ ∈ Fml( , V) and α ∈ HP( , V), then [α]φ, α φ ∈ Fml( , V).</formula><p>We consider φ ↔ ψ as an abbreviation for (φ → ψ) ∧ (ψ → φ) to simplify the calculus. When train denotes the hybrid program in Fig. <ref type="figure" target="#fig_0">2</ref>, the following dL formula states that the train is able to leave region z &lt; m when it starts in the same region:</p><formula xml:id="formula_2">z &lt; m → train z ≥ m .</formula><p>Note that, according to Definition 2, hybrid programs are fully internalised in dL and the logic is closed. That is, modalities can be combined propositionally, by quantifiers, or nested. For instance, [α] β x ≤ c says that, whatever α is doing, β can react in some way to reach a controlled state where x is less than some critical value c. Dually, β [α]x ≤ c expresses that β can stabilise x ≤ c, i.e., behave in such a way that x ≤ c remains true no matter how α reacts. Accordingly, ∃ p[α]x ≤ c says that there is a choice of parameter p such that α remains in x ≤ c.</p><p>During our analysis, we assume differential equations and discrete transitions to be well-defined. In particular, we assume that all divisions p/q are guarded by conditions that ensure q = 0 as, otherwise, the system behaviour is not welldefined due to an undefined value at a singularity. It is simple but tedious to augment the semantics and the calculus with corresponding side conditions to show that this is respected. For instance, we assume that x := p/q is guarded by ?q = 0 and that continuous evolutions are restricted such that the differential equations are well-defined as, e.g., x = p/q &amp; q = 0. Also see <ref type="bibr" target="#b8">[8]</ref> for techniques how such exceptional behaviour can be handled by program transformation while avoiding partial valuations in the semantics. In logical formulas, partiality can be avoided by writing, e.g., p = c • q ∧ q = 0 rather than p/q = c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Semantics of Differential Dynamic Logic</head><p>We define the semantics of dL as a Kripke semantics with worlds representing the possible system states and with reachability along the hybrid transitions of the system as accessibility relation. The interpretations of dL consist of states (worlds) that are essentially first-order structures over the reals. In particular, real values are assigned to state variables, possibly different values in each state. A potential behaviour of a hybrid system corresponds to a succession of states that contain the observable values of system variables during its hybrid evolution.</p><p>An interpretation I assigns functions and relations over the reals to the respective (rigid) symbols in . The function and predicate symbols of real arithmetic are interpreted as usual by I. A state is a map ν : fl → R; the set of all states is denoted by Sta( ). Here, fl denotes the set of (flexible) state variables in (they have arity 0). Finally, an assignment of logical variables is a map η : V → R. It contains the values for logical variables, which are not subject to change by modalities but only by quantification. Observe that flexible symbols (which represent state variables), are allowed to assume different interpretations in different states. Logical variable symbols, however, are rigid in the sense that their value is determined by η alone and does not depend on the state.</p><p>We will use ν x → d to denote the modification of a state ν that agrees with ν except for the interpretation of the symbol x ∈ fl , which is changed to d ∈ R. Similarly, η x → d agrees with the assignment η except on x ∈ V, which is assigned</p><formula xml:id="formula_3">d ∈ R.</formula><p>For terms and formulas, the valuation val I,η (ν, •) is defined as usual for first-order modal logic <ref type="bibr" target="#b28">[27,</ref><ref type="bibr" target="#b36">35]</ref> with a distinction of rigid and flexible functions <ref type="bibr" target="#b8">[8]</ref>. Modalities parameterised by a hybrid program α follow the accessibility relation spanned by the respective hybrid state transition relation ρ I,η (α), which is simultaneously inductively defined in Definition 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Valuation of terms)</head><p>The valuation of terms with respect to I, assignment η, and state ν is defined by</p><formula xml:id="formula_4">1. val I,η (ν, x) = η(x) if x ∈ V is a logical variable. 2. val I,η (ν, a) = ν(a) if a ∈ is a state variable (flexible function symbol of arity 0). 3. val I,η (ν, f (θ 1 , . . . , θ n )) = I( f )(val I,η (ν, θ 1 ), . . . , val I,η (ν, θ n )) when f ∈ is a rigid function symbol of arity n ≥ 0.</formula><p>Definition 4 (Valuation of formulas) The valuation, val I,η (ν, •), of formulas with respect to interpretation I, assignment, η and state ν is defined as</p><formula xml:id="formula_5">1. val I,η (ν, p(θ 1 , . . . , θ n )) = I( p)(val I,η (ν, θ 1 ), . . . , val I,η (ν, θ n )) 2. val I,η (ν, φ ∧ ψ) = true iff val I,η (ν, φ) = true and val I,η (ν, ψ) = true. Accordingly for ¬, ∨, → 3. val I,η (ν, ∀xφ) = true iff val I,η[x →d] (ν, φ) = true for all d ∈ R 4. val I,η (ν, ∃xφ) = true iff val I,η[x →d] (ν, φ) = true for some d ∈ R 5. val I,η (ν, [α]φ) = true iff val I,η (ω, φ) = true for all states ω with (ν, ω) ∈ ρ I,η (α) 6. val I,η (ν, α φ) = true iff val I,η (ω, φ) = true for some state ω with (ν, ω) ∈ ρ I,η (α)</formula><p>Now we can define the transition semantics, ρ I,η (α), of a hybrid program α. The semantics of a hybrid program is captured by its hybrid state transition relation. For discrete jumps this transition relation holds for pairs of states that respect the discrete jump set. For continuous evolutions, the transition relation holds for pairs of states that can be interconnected by a continuous flow respecting the differential equations and invariant throughout the evolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Transition semantics of hybrid programs)</head><p>The valuation, ρ I,η (α), of a hybrid program α, is a transition relation on states. It specifies which state ω is reachable from a state ν by operations of the hybrid program α and is defined as follows</p><formula xml:id="formula_6">1. (ν, ω) ∈ ρ I,η (x 1 := θ 1 , . . . , x n := θ n ) iffν[x 1 -→val I,η (ν, θ 1 )] . . . [x n -→val I,η (ν, θ n )]</formula><p>equals state ω. Particularly, the value of the other variables z ∈ {x 1 , . . . , x n } remains constant, i.e., val</p><formula xml:id="formula_7">I,η (v, z) = val I,η (ω, z) 2. (ν, ω) ∈ ρ I,η (x 1 = θ 1 , . . . , x n = θ n &amp;χ) iff there is a flow f of some duration r ≥ 0 from ν to ω along x 1 = θ 1 , . . . , x n = θ n &amp;χ , i.e., a function f : [0, r] → Sta( ) with f (0) = ν, f (r) = ω respecting the differential equations: for each x i , val I,η ( f (ζ ), x i ) is continuous in ζ on [0, r] and has a derivative of value val I,η ( f (ζ ), θ i ) at each time ζ ∈ (0, r). The value of other variables z ∈ {x 1 , . . . , x n } remains constant, i.e., val I,η ( f (ζ ), z) = val I,η (ν, z) for all ζ ∈ [0, r]. Further, the invariant is respected, i.e., val I,η ( f (ζ ), χ ) = true for each ζ ∈ [0, r]. 3. ρ I,η (?χ) = {(ν, ν) : val I,η (ν, χ ) = true} 4. ρ I,η (α ∪ β) = ρ I,η (α) ∪ ρ I,η (β) 5. ρ I,η (α; β) = {(ν, ω) : (ν, z) ∈ ρ I,η (α), (z, ω) ∈ ρ I,η (β) for a state z} 6. (ν, ω) ∈ ρ I,η (α * ) iff there are an n ∈ N and states ν = ν 0 , . . . , ν n = ω such that (ν i , ν i+1 ) ∈ ρ I,η (α) for all 0 ≤ i &lt; n.</formula><p>Note that the modifications of a discrete jump set are executed simultaneously in the sense that all terms θ i are evaluated in the initial state ν. For simplicity, we assume the x i to be different, and refer to previous work <ref type="bibr" target="#b8">[8]</ref> for a compatible semantics and calculus handling concurrent modifications of the same x i . For differential equations like x = θ, Definition 5 characterises transitions along a continuous evolution respecting the differential equation, see Fig. <ref type="figure" target="#fig_2">3a</ref>. A continuous transition along x = θ is possible from ν to ω whenever there is a continuous flow f of some duration r ≥ 0 connecting state ν with ω such that f gives a solution of the differential equation x = θ. That is, its value is continuous on [0, r] and differentiable with the value of θ as derivative on the open interval (0, r). Further, only variables subject to a differential equation change during such a continuous transition. Similarly, the continuous transitions of x = θ&amp;χ with invariant region χ are those where f always resides within χ during the whole evolution, see Fig. <ref type="figure" target="#fig_2">3b</ref>. For the semantics of differential equations, derivatives are well-defined on the open interval (0, r) as Sta(Σ) is isomorphic to some finite-dimensional real space spanned by the variables of the differential equations (derivatives are not defined on the closed interval [0, r] if r = 0). For the purpose of a differential equation system, states are fully determined by an assignment of a real value to each occurring variable, which are finitely many. Furthermore, the terms of dL are continuously differentiable on the open domain where divisors are non-zero, because the zero set of divisors is closed. Hence, solutions in dL are unique: Lemma 1 (Uniqueness) Differential equations of dL have unique solutions, i.e., for each differential equation system, each state ν and each duration r ≥ 0, there is at most one flow f : [0, r] -→ Sta(Σ) satisfying the conditions of Case 2 of Definition 5.</p><p>Proof Let x 1 = θ 1 , . . . , x n = θ n &amp;χ be a differential equation system with invariant region χ . Using simple computations in the field of rational fractions, we can assume the right-hand sides θ i of the differential equations to be of the form p i /q i for polynomials p i , q i . The set of points in real space where q i = 0 holds is closed. As a finite union of closed sets, the set where</p><formula xml:id="formula_8">q 1 = 0 ∨ • • • ∨ q n = 0 holds is closed.</formula><p>Hence, the valuations of the θ i are continuously differentiable on the complement of the latter set, which is open. Thus, as a consequence of Picard-Lindelöf's theorem <ref type="bibr" target="#b59">[58,</ref><ref type="bibr">Theorem 10</ref>.VI], which is also known as the Cauchy-Lipschitz theorem, the solutions are unique on each connected component of this open domain. Consequently, solutions are unique when restricted to χ , which, by assumption, entails</p><formula xml:id="formula_9">q 1 = 0 ∧ • • • ∧ q n = 0.</formula><p>For control-feedback loops α with a discrete controller regulating a continuous plant, transition structures involve all safety-critical states, hence, ψ → [α]φ is a natural rendition of the safety property that φ holds at all states reachable by α from initial states that satisfy ψ. Otherwise, dL can be augmented with temporal operators to refer to intermediate states or nonterminating traces. The corresponding calculus is compatible and reduces temporal properties to non-temporal properties at intermediate states of the hybrid program <ref type="bibr" target="#b49">[48]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Safety in the European Train Control System</head><p>As a case study to illustrate how dL can be used for specifying and verifying hybrid systems, we examine a scenario of cooperating traffic agents in the European Train Control System (ETCS) <ref type="bibr" target="#b19">[19]</ref>. The purpose of ETCS is to ensure that trains cannot crash into other trains or pass open gates. Its secondary objective is to maximise throughput and velocity without endangering safety. To achieve these objectives, ETCS discards the static partitioning of the track into fixed segments of mutually exclusive and physically separated access by trains, which has been used traditionally. Instead, permission to move is granted dynamically by decentralised Radio Block Controllers (RBC) depending on the current track situation and movement of other traffic agents within the region of responsibility of the RBC, see Fig. <ref type="figure">4</ref>.</p><p>This moving block principle is achieved by dynamically giving a movement authority (MA) to each traffic agent, within which it is obliged to remain. Before a train moves into a part of the track for which it does not have MA, it asks the RBC Fig. <ref type="figure">4</ref> ETCS train coordination protocol using dynamic movement authorities for an MA-extension (negotiation phase neg of Fig. <ref type="figure">4</ref>). Depending on the MA that the RBC has currently given to other traffic agents or gates, the RBC will grant this extension and the train can move on. If the newly requested MA is still in possession of another train which could occupy the track, or if the MA is still consumed by an open gate, the RBC will deny the MA-extension such that the requesting train needs to reduce speed or start braking in order to safely remain within its old MA. As the negotiation process with the RBC can take time because of possibly unreliable wireless communication and negotiation of the RBC with other agents, the train initiates negotiation well before reaching the end of its MA. When the rear end of a train has safely left a part of a track, the train can give that part of its MA back to RBC control such that it can be used by other traffic agents.</p><p>In addition to increased flexibility and throughput of this moving block principle, the underlying technical concept of movement authorities can be exploited for verifying ETCS. It can be shown that a system of arbitrarily many trains, gates, and RBCs, which communicate in the aforementioned manner, safely avoids collisions if each traffic agent always resides within its MA under all circumstances, provided that the RBCs grant MA mutually exclusive so that the MAs dynamically partition the track <ref type="bibr" target="#b18">[18]</ref>. This way, verification of a system of unboundedly many traffic agents can be reduced to an analysis of individual agents with respect to their specific MA.</p><p>For trains, speed supervision and automatic train protection are responsible for locally controlling the movement of a train such that it always respects its MA <ref type="bibr" target="#b18">[18]</ref>. Depending on the current driving situation, the train controller determines a point SB (for start braking) up to which driving is safe, and adjusts its acceleration a in accordance with SB. Before SB, speed can be regulated freely (to keep the desired speed and throughput of a track profile). Beyond SB (correcting phase cor in Fig. <ref type="figure">4</ref>), the train starts braking in order to make sure it remains within its MA if the RBC does not grant an extension in time.</p><p>We assume that an MA has been granted up to some track position, which we call m, and the train is located at position z, heading with initial speed v towards m. We represent the point SB as the safety distance s relative to the end m of the MA (i.e., ms = SB). In this situation, dL can analyse the following crucial safety property of ETCS:</p><formula xml:id="formula_10">ψ → [(ctrl; drive) * ]z ≤ m (1)</formula><p>where ctrl</p><formula xml:id="formula_11">≡ (?m -z ≤ s; a := -b ) ∪ (?m -z ≥ s; a := A) drive ≡ τ := 0; (z = v, v = a, τ = 1&amp;v ≥ 0 ∧ τ ≤ ε).</formula><p>It expresses that a train always remains within its MA, assuming some constraint ψ for its parameters. The operational system model is a control-feedback loop of the digital controller ctrl and the plant drive. In ctrl, the train controller corrects its acceleration or brakes on the basis of the remaining distance (mz). As a failsafe recovery manoeuvre <ref type="bibr" target="#b18">[18]</ref>, it applies brakes with force b if the remaining MA is less than s. Otherwise, speed is regulated freely. For simplicity, we assume the train uses a fixed acceleration A before having passed s. The verification is quite similar when the controller can dynamically choose any acceleration a ≤ A instead.</p><p>After acceleration a has been set in ctrl, the train continues moving in drive. There, the position z of the train evolves according to the system z = v, v = a (i.e., z = a). The evolution in drive stops when the speed v drops below zero (or earlier). Simultaneously, clock τ measures the duration of the current drive phase before the controllers react to situation changes again. Clock τ is reset to zero when entering drive, constantly evolves along τ = 1, and is bound by the invariant region τ ≤ ε. The effect is that a drive phase is interrupted for reassessing the driving situation after at most ε seconds, and the ctrl; drive feedback loop repeats. The corresponding transition structure ρ I,η ((ctrl; drive) * ) is depicted in Fig. <ref type="figure">5a</ref>. Figure <ref type="figure">5b</ref> shows a possible run of the train where speed regulation successively decreases velocity v because MA has not been extended in time. Finally, observe that the invariant region v ≥ 0 ∧ τ ≤ ε needs to be true at all times during continuous evolutions of drive, otherwise there is no corresponding transition in ρ I,η (drive). This not only restricts the maximum duration of drive, but also imposes a constraint on permitted initial states: The arithmetic constraint v ≥ 0 expresses that the differential equation only applies for non-negative speed. Hence, like in a test ?v ≥ 0, program drive allows no transitions when v is initially less than 0. In that case, ρ I,η ((ctrl; drive) * ) collapses to the trivial identity transition with zero repetitions.</p><p>Here, we explicitly take into account possibly delayed controller reactions to bridge the gap of continuous-time models and discrete-time control design. To get meaningful results, we need to assume a maximum reaction delay ε as safety cannot otherwise be guaranteed. Polling cycles of sensors and digital controllers as well as latencies of actuators like brakes contribute to ε. Instead of using specific estimates for ε for a particular train, we accept ε as a fully symbolic parameter. Further, instead of manually choosing specific values for the free parameters of (1) as in model checking approaches <ref type="bibr" target="#b19">[19]</ref>, we will use our calculus to synthesise constraints on the relationship of parameters that are required for a safe operation of train control. As they are of subordinate importance to the cooperation layer of train control <ref type="bibr" target="#b18">[18]</ref>, we do not model weather conditions, slope of track, or train mass.</p><p>Because of its nonlinear behaviour and nontrivial reset relations, system (1) is beyond the modelling capabilities of linear hybrid automata <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b37">36]</ref> and beyond o-minimal automata <ref type="bibr" target="#b42">[41]</ref>. Previous approaches need linear flows <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b37">36]</ref>, do not support the coupled dynamics caused by nontrivial resets <ref type="bibr" target="#b42">[41]</ref>, require polyhedral t z v Fig. <ref type="figure">5</ref> ETCS transition structure and speed regulation of train speed control initial sets and discrete dynamics <ref type="bibr" target="#b13">[13]</ref>, only handle robust systems with bounded regions <ref type="bibr" target="#b29">[28]</ref>, although parametric systems are not robust uniformly for all parameter choices, or they handle only bounded-time safety for systems with bounded switching <ref type="bibr" target="#b45">[44]</ref>. Finally, in addition to general numerical limits <ref type="bibr" target="#b50">[49]</ref>, numerical approaches <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b13">13]</ref> quickly become intractable due to the exponential impact of the number of variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Free Variable Calculus for Differential Dynamic Logic</head><p>In this section, we introduce a sequent calculus for verifying hybrid systems by proving corresponding dL formulas. The basic idea is to symbolically compute the effects of hybrid programs and successively transform them into logical formulas describing these effects by structural decomposition. The calculus consists of standard propositional rules, rules for dynamic modalities that are generalised to hybrid programs, and novel quantifier rules that integrate real quantifier elimination (or, in fact, any other quantifier elimination procedure) into the modal calculus using free variables and Skolemisation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Rules of the Calculus for Differential Dynamic Logic</head><p>A sequent is of the form Γ Δ, where the antecedent Γ and succedent Δ are finite sets of formulas. The semantics of Γ Δ is that of the formula φ∈Γ φ → ψ∈ ψ. For quantifier elimination rules, we make use of this fact by considering sequent Γ Δ as an abbreviation for the latter formula.</p><p>The dL calculus uses substitutions that take effect within formulas and programs. The result of applying to φ the substitution that simultaneously replaces x i by θ i (for 1 ≤ i ≤ n) is defined as usual; it is denoted by φ θ1 x1 . . . θn xn . We assume α-conversion for renaming as needed. In the dL calculus, only admissible substitutions are applicable, which is crucial for soundness. Definition 6 (Admissible substitution) An application of a substitution σ is admissible if no replaced term t occurs in the scope of a quantifier or modality binding a (logical or state) variable of t or of the replacement σ (t). A modality binds a state variable x iff it contains a discrete jump set assigning to x (like x := θ) or a differential equation containing x (like x = θ).</p><p>Observe that, for soundness, the notion of bound variables can be any overapproximation of the set of variables that possibly change their value during a hybrid program. In vacuous identity changes like x := x or x = 0, variable x will not really change its value, but we still consider x as a bound variable for simplicity. For a hybrid program α, we denote by ∀ α φ the universal closure of formula φ with respect to all state variables bound in α. Quantification over state variable x is definable as ∀X [x := X]Φ using an auxiliary logical variable X.</p><p>For handling quantifiers, we cannot use the standard rules <ref type="bibr" target="#b27">[26,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b34">33]</ref>, because these are for uninterpreted first-order logic and (ultimately) work by instantiating quantifiers, either eagerly as in ground tableaux or lazily by unification as in free variable tableaux <ref type="bibr" target="#b27">[26,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b34">33]</ref>. The basis of dL, instead, is first-order logic interpreted over the reals or in the theory of real-closed fields <ref type="bibr" target="#b55">[54]</ref>. A formula like ∃a ∀x(x 2 + a &gt; 0) cannot be proven by instantiation-based quantifier rules but is valid in the theory of real-closed fields. Unfortunately, quantifier elimination (QE) over the reals <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b55">54]</ref>, which is the standard decision procedure for real arithmetic, cannot be applied to formulas with modalities either. Hence, we introduce novel quantifier rules that integrate quantifier elimination in a way that is compatible with dynamic modalities (as we illustrate in Section 4.2). Definition 7 (Quantifier elimination) A first-order theory admits quantifier elimination if, to each formula φ, a quantifier-free formula QE(φ) can be associated effectively that is equivalent (i.e., φ ↔ QE(φ) is valid) and has no additional free variables or function symbols. The operation QE is further assumed to evaluate ground formulas (i.e., without variables), yielding a decision procedure for closed formulas of this theory.</p><p>As usual in sequent calculus rules-although the direction of entailment is from premisses (above rule bar) to conclusion (below)-the order of reasoning is goaldirected: Rules are applied in tableau-style, i.e., starting from the desired conclusion at the bottom (goal) to the resulting premisses (sub-goals). To highlight the logical essence of the dL calculus, Fig. <ref type="figure" target="#fig_3">6</ref> provides rule schemata to which the following definition associates the calculus rules that are applicable in dL proofs. The calculus consists of propositional rules (P-rules: P1-P10), first-order quantifier rules (F-rules: F1-F6), rules for dynamic modalities (D-rules: D1-D12), and global rules (G-rules: G1-G4).</p><p>Definition 8 (Rules) The rule schemata in Fig. <ref type="figure" target="#fig_3">6</ref> induce calculus rules by:</p><formula xml:id="formula_12">1. If Φ 1 Ψ 1 . . . Φ n Ψ n Φ 0 Ψ 0</formula><p>is an instance of a P, G, or F1-F5 rule schema in Fig. <ref type="figure" target="#fig_3">6</ref>, then</p><formula xml:id="formula_13">Γ, J Φ 1 J Ψ 1 , Δ . . . Γ, J Φ n J Ψ n , Δ Γ, J Φ 0 J Ψ 0 , Δ</formula><p>can be applied as a proof rule of the dL calculus, where Γ, Δ are arbitrary finite sets of additional context formulas (including empty sets) and J is a discrete jump set (including the empty set). Hence, the rule context Γ, Δ and prefix J remain unchanged during rule applications. 2. Symmetric schemata can be applied on either side of the sequent: If</p><formula xml:id="formula_14">φ 1 φ 0</formula><p>is an instance of one of the symmetric rule schemata (D-rules) in Fig. <ref type="figure" target="#fig_3">6</ref>, then</p><formula xml:id="formula_15">Γ J φ 1 , Δ Γ J φ 0 , Δ and Γ, J φ 1 Δ Γ, J φ 0 Δ</formula><p>can both be applied as proof rules of the dL calculus, where Γ, Δ are arbitrary finite sets of context formulas and J is a discrete jump set (including empty sets). In particular, symmetric schemata yield equivalence transformations, because the same rule applies in the antecedent as in the succedent. 3. Schema F6 applies to all goals containing X:</p><formula xml:id="formula_16">If Φ 1 Ψ 1 , .., Φ n Ψ n is the list of</formula><p>all open goals of the proof that contain free variable X, then an instance</p><formula xml:id="formula_17">QE(∃X i (Φ i Ψ i )) Φ 1 Ψ 1 . . . Φ n Ψ n</formula><p>of rule schema F6 can be applied as a proof rule of the dL calculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P-Rules</head><p>For propositional logic, standard rules P1-P9 with cut P10 are listed in Fig. <ref type="figure" target="#fig_3">6</ref>. They decompose the propositional structure of formulas. Rules P1 and P2 use simple dualities caused by the implicative semantics of sequents. P3 uses that formulas are combined disjunctively in succedents, P6 that they are conjunctive in antecedents. P4 and P5 split the proof into two cases, because conjuncts in the succedent can be proven separately (P5) and, dually, disjuncts of the antecedent can be assumed separately (P4). P7 and P8 can be derived from the equivalence of φ → ψ and ¬φ ∨ ψ. The axiom rule P9 closes a goal (there are no further sub-goals), because assumption φ in the antecedent trivially entails φ in the succedent. Rule P10 is the cut rule that can be used for case distinctions: The right sub-goal assumes any additional formula φ in the antecedent that the left sub-goal shows in the succedent. We only use cuts in an orderly fashion to derive simple rule dualities and to simplify metaproofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F-Rules</head><p>The quantifier rules F1 and F2 correspond to the liberalised δ + -rule of Hähnle and Schmitt <ref type="bibr" target="#b34">[33]</ref>. F4 and F5 resemble the usual γ -rule but, unlike in <ref type="bibr" target="#b27">[26,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b31">30,</ref><ref type="bibr" target="#b34">33]</ref>, they cannot be applied twice because the original formula is removed (∃xφ(x) in F4). The calculus still has a complete handling of quantifiers due to F3 and F6, which can reconstruct and eliminate quantifiers once QE is applicable as the remaining constraints are first-order in the respective variables. In the premiss of F3 and F6, we again consider sequents Φ Ψ as abbreviations for formulas. For closed formulas, we do not need other arithmetic rules. We defer illustrations and further discussion of F-rules to Section 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D-Rules</head><p>The rules for dynamic modalities transform a hybrid program into simpler logical formulas. Rules D1-D8 are as in discrete DL <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b36">35]</ref>. Sequential compositions are proven using nested modalities (D1-D2), and nondeterministic choices split into their alternatives (D3-D4). D5 and D6 are the usual iteration rules, which partially unwind loops. Tests are proven by showing (D7) or assuming (D8) that the test succeeds, because ?χ can only make a transition when χ holds true (Definition 5).</p><p>D9 uses simultaneous substitutions for handling discrete jump sets. To show that φ is true after a discrete jump, D9 shows that φ has already been true before, when replacing the x i by their new values θ i in φ by an admissible substitution. Instead, the discrete jump set can remain an unchanged prefix (J in Definition 8) for other dL rules applied to φ, until the substitution for D9 is admissible. D10 uses that discrete jump sets characterise a unique deterministic transition, hence, its premiss and conclusion are equivalent. Assuming the presence of vacuous identity jumps a := a for variables a that do not otherwise change (vacuous identity jumps can be added as they do not change state), we can further use D9 to merge subsequent discrete jumps into a single discrete jump set (see previous results <ref type="bibr" target="#b8">[8]</ref> for a compatible calculus detailing jump set merging, which works without the need to add vacuous identity jumps a := a): Given first-order definable flows for their differential equations, D11-D12 handle continuous evolutions (see <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b42">41,</ref><ref type="bibr" target="#b50">49]</ref> for flow approximation and solution techniques). These flows are combined in the jump set S t . Given a solution for the differential equation system with symbolic initial values x 1 , . . . , x n , continuous evolution along differential equations can be replaced by a discrete jump S t with an additional quantifier for the evolution time t. The effect of the constraint on χ is to restrict the continuous evolution such that its solution S t remains in the invariant region χ at all intermediate times t ≤ t. This constraint simplifies to true if χ is true. Similar simplifications can be made for convex invariant conditions (Section 6).</p><formula xml:id="formula_18">z := -b 2 t 2 + Vt, v := V + 1, a := -b [β]φ D9 a := -b, v := V z := a 2 t 2 + vt, v := v + 1, a := a [β]φ D10 a := -b, v := V [z := a 2 t 2 + vt, v := v + 1, a := a][β]φ D2 a := -b, v := V [z := a 2 t 2 + vt, v := v +</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G-Rules</head><p>The G-rules are global rules. They depend on the truth of their premisses in all states reachable by α, which is ensured by the universal closure ∀ α with respect to all bound state variables (Definition 6) of the respective hybrid program α. This universal closure is required for soundness in the presence of contexts Γ, Δ (Definition 8) or of free variables. The G-rules are given in a form that best displays their underlying logical principles. The general pattern for applying G-rules to prove that the succedent of their conclusion holds is to prove that both the antecedent of their conclusion and their premiss holds.</p><p>G1-G2 are generalisation rules and can be used to strengthen postconditions: Antecedent [α]φ is sufficient for proving succedent [α]ψ when postcondition φ entails ψ in all relevant states reachable by α, which are overapproximated by the universal closure ∀ α with respect to the bound variables of α. G3 is an induction schema with inductive invariant φ. Similarly, G4 is a generalisation of Harel's convergence rule <ref type="bibr" target="#b36">[35]</ref> to the hybrid case with decreasing variant ϕ. Both rules are given in a form that best displays their underlying logical principles and similarity. G3 says that φ holds after any number of repetitions of α, if it holds initially (antecedent) and, for all reachable states (as overapproximated by ∀ α ), invariant φ remains true after one iteration of α (premiss). G4 expresses that the variant ϕ(v) holds for some real number v ≤ 0 after repeating α sufficiently often, if ϕ(v) holds for some real number at all (antecedent) and, by premiss, decreases after every execution of α by 1 (or at least any other positive real constant).</p><p>For practical verification, rules G3 or G4 can be combined with generalisation (G1-G2) to prove a postcondition ψ of a loop α * by showing that (a) the antecedent of the respective goals of G3 and G4 holds initially, that (b) their sub-goals hold, which represent the induction step, and that (c) finally, the postcondition of the succedent in their goals entails ψ. The corresponding variants of G3 and G4 are derived rules:</p><formula xml:id="formula_19">(G3') φ ∀ α (φ → [α]φ) ∀ α (φ → ψ) [α * ]ψ (G4') ∃vϕ(v) ∀ α ∀v &gt;0 (ϕ(v) → α ϕ(v -1)) ∀ α (∃v ≤ 0 ϕ(v) → ψ) α * ψ</formula><p>For instance, using a cut with φ → [α * ]φ, rule G3' can be derived from G3 and G1:</p><formula xml:id="formula_20">G3 ∀ α (φ → [α]φ) G1 ∀ α (φ → ψ) P7 φ [α * ]φ P8 φ [α * ]φ [α * ]ψ P10 φ → [α * ]φ φ→ [α * ]φ [α * ]ψ [α * ]ψ</formula><p>The notions of derivations and proofs are standard, except that F6 produces multiple conclusions. Hence, we define derivations as finite acyclic graphs instead of trees: Definition 9 (Provability) A derivation is a finite acyclic graph labelled with sequents such that, for every node, the (set of) labels of its children must be the (set of) premisses of an instance of one of the calculus rules (Definition 8) and the (set of) labels of the parents of these children must be the (set of) conclusions of that rule instance. A formula ψ is provable from a set Φ of formulas, denoted by Φ dL ψ, iff there is a finite subset Φ 0 ⊆ Φ for which the sequent Φ 0 ψ is derivable, i.e., there is a derivation with a single root (i.e., node without parents) labelled Φ 0 ψ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Deduction Modulo with Invertible Quantifiers and Real Quantifier Elimination</head><p>The F-rules lift quantifier elimination to dL by following a generalised deduction modulo approach. They integrate decision procedures, e.g., for real quantifier elimination as a background prover <ref type="bibr" target="#b6">[6]</ref> into the deductive proof system. Yet, unlike in the approaches of Dowek et al. <ref type="bibr" target="#b24">[23]</ref> and Tinelli <ref type="bibr" target="#b57">[56]</ref>, the information given to the background prover is not restricted to ground formulas <ref type="bibr" target="#b57">[56]</ref> or atomic formulas <ref type="bibr" target="#b24">[23]</ref>. Further, real quantifier elimination is quite different from uninterpreted logic <ref type="bibr" target="#b27">[26,</ref><ref type="bibr" target="#b31">30,</ref><ref type="bibr" target="#b34">33]</ref> in that the resulting formulas are not obtained by instantiation but by intricate arithmetic recombination. The F-rules can use any theory that admits quantifier elimination (see <ref type="bibr">Definition 7)</ref> and has a decidable ground theory, for instance, the first-order theory of real arithmetic (i.e., the theory of real-closed fields <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b55">54]</ref>). A formula of real arithmetic is a first-order formula with +, -, •, /, =, ≤, &lt;, ≥, &gt; as the only function or predicate symbols besides constant symbols of and logical variables of V.</p><p>Integrating quantifier elimination to deal with statements about real quantities is quite challenging in the presence of modalities that influence the value of flexible symbols. In principle, quantifier elimination can be used to handle quantified constraints as arising for continuous evolutions. In dL, however, real quantifiers interact with modalities containing further discrete or continuous transitions, which is an effect that is inherent in the interacting nature of hybrid systems. A hybrid formula like ∃z z = -b ; ?mz ≥ s; z = 0 mz &lt; s is not first-order, hence quantifier elimination cannot be applied. Even more so, the effect of a modality depends on the solutions of the differential equations contained therein. For instance, it is hard to know in advance, which first-order constraints need to be solved by QE for the above formula. To find out how z evolves from ∃z to mz &lt; s, the system dynamics needs to be taken into account (similar for repetitions). Hence, our calculus first unwraps the first-order structure before applying QE to the resulting arithmetic formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Lifting Quantifier Elimination by Invertible Quantifier Rules</head><p>The purpose of the F-rules is to postpone QE until the actual arithmetic constraints become apparent. The idea is that F1,F2,F4, and F5 temporarily remove quantifiers by introducing new auxiliary symbols for quantified variables such that the proof can be continued beyond the occurrence of the quantifier to further analyse the modalities contained therein. Later, when the actual first-order constraints for the auxiliary symbol have been discovered, the corresponding quantifier can be reintroduced (F3, F6) and quantifier elimination QE is applied to reduce the sequents equivalently to a simpler formula with less (distinct) symbols. In F4-F6, the respective auxiliary symbols are free logical variables. In F1-F3, Skolem function terms are used instead for reasons that are crucial for soundness and will be illustrated in the sequel. In this context, we think of free logical variables as being introduced by γ -rules (F4 and F5), hence implicitly existentially quantified.</p><p>To illustrate how quantifier and dynamic rules of dL interact to combine arithmetic with dynamic reasoning in hybrid systems, we analyse the braking behaviour in train control. The proof in Fig. <ref type="figure">7</ref> can be used to analyse whether a train can violate its MA although it is braking. As the proof reveals, the answer depends on the initial velocity v. For notational convenience, we use the simplified D11 rule, as the differential equation is not restricted to an invariant region. Rule F4 introduces a new free variable T for the quantified variable t to postpone QE. Later, when F6 is applied in Fig. <ref type="figure">7</ref>, the conjunction of its two goals can be handled by QE and simplification, yielding the resulting sub-goal:</p><formula xml:id="formula_21">QE ∃T (v ≥ 0 ∧ z &lt; m → T ≥ 0) ∧ v ≥ 0 ∧ z &lt; m → - b 2 T 2 + vT + z &gt; m ≡ v ≥ 0 ∧ z &lt; m → v 2 &gt; 2b(m -z).</formula><p>The open branch with this formula reveals the speed limit and can be used to synthesise a corresponding parameter constraint. When v 2 &gt; 2b(mz) holds initially, m can be violated even in braking mode, as the velocity exceeds the braking power. Similarly, v 2 ≤ 2b(mz) guarantees that m can be respected by appropriate braking. The constraint so discovered thus forms a controllability constraint of ETCS, i.e., a constraint that characterises from which states control choices exist that guarantee safety. It is essentially equivalent to z = -b z ≤ m and to ∃a(-b ≤ a ≤ A ∧ z = a z ≤ m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Admissibility in Invertible Quantifier Rules</head><p>The requirement that substitutions in F3 are admissible implies that no occurrence of s(X 1 , . . . , X n ) is within the scope of a quantifier for any of these X i . This prevents F3 from rearranging the order of quantifiers from ∃X i ∀s to the weaker ∀s ∃X i , which would be unsound, because it is not sufficient to show the weak sub-goal ∀s ∃X i in order to prove the strong statement ∃X i ∀s saying that the same X i works for all s.</p><p>For the moment, suppose the rules did not contain QE. The requirement for admissible substitutions (Definition 6) ensures that the proof attempt of an invalid 7 Deduction modulo for analysis of MA-violation in braking mode formula in Fig. <ref type="figure" target="#fig_5">8a</ref> cannot close in the dL calculus. At the indicated position, F3, which would unsoundly invert the quantifier order to ∀S ∃X, cannot be applied: In F3, the substitution inserting s(X) gives ∃Y(2Y + 1 &lt; s(X)) by α-renaming, instead of ∃X(2X + 1 &lt; s(X)). Thus, F3 is not applicable, because the quantified formula is not of the form Ψ (s(X)). Now, we consider what happens in the presence of QE. The purpose of QE is to (equivalently) remove quantifiers like ∃X. Thus it is no longer obvious that the admissibility argument applies, because the blocking variable X would have disappeared after successful quantifier elimination. However, quantifier elimination over the reals is defined in the first-order theory of real arithmetic <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b55">54]</ref>. Yet, when eliminating X in Fig. <ref type="figure" target="#fig_5">8a</ref>, the Skolem term s(X) is no term of real arithmetic, as, unlike that of +, the interpretation of s is arbitrary. The truth value of ∃X(2X + 1 &lt; s(X)) depends on the interpretation of s. If I(s) is a constant function, the formula is true, if I(s)(a) = 2a, it is false. In general, such cases cannot be distinguished without quantifiers. Thus, in the presence of uninterpreted function terms, real arithmetic does not generally admit quantifier elimination. Consequently, F6 and F3 are only applicable if QE is defined. Yet, QE can be lifted to formulas with Skolem functions when these are instances of real arithmetic formulas: Lemma 2 (Quantifier elimination lifting) Quantifier elimination can be lifted to instances of formulas of first-order theories that admit quantifier elimination, i.e., to formulas that result from the base theory by substitution.</p><p>Proof Let formula φ be an instance of ψ, with ψ being a formula of the base theory, i.e., φ is ψ θ1 z1 . . . θn zn for some variables z i and arbitrary terms θ i . As QE is defined for the base theory, let QE(ψ) be the quantifier-free formula belonging to ψ according to Definition 7. Then QE(ψ) θ1 z1 . . . . However, QE is not defined in the premiss of F6 when Skolem-dependencies on X occur. In Fig. <ref type="figure" target="#fig_5">8a</ref>, ∃X (2X + 1 &lt; s(X)) is no instance of first-order real arithmetic, because, by α-renaming, (∃X (2X</p><formula xml:id="formula_22">+ 1 &lt; z)) s(X) z a.</formula><p>b. yields a different formula ∃Y (2Y + 1 &lt; s(X)). An occurrence of s(X), which corresponds to a quantifier nesting of ∃X ∀s, thus requires s(X) to be eliminated by F3 before F6 can eliminate X, see Fig. <ref type="figure" target="#fig_5">8b</ref>. Hence, inner universal quantifiers are handled first and unsound quantifier rearrangements are prevented even in the presence of QE.</p><p>Finally observe that F3 and F6 do not require quantifiers to be eliminated in the same order in which they occurred in the original formula. The elimination order within homogeneous quantifier blocks like ∀x 1 ∀x 2 is not restricted as there are no Skolem dependencies among the corresponding auxiliary Skolem terms. Yet, eliminating such a quantifier block is sound in any order (accordingly for ∃x 1 ∃x 2 ). Similarly, F6 and F3 could interchange the order of ∀x∃y to the stronger ∃y ∀x, because the resulting Skolem term s for x in the former formula does not depend on y. In this direction, however, the interchange is sound, as it amounts to proving a stronger statement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Quantifier Elimination and Modalities</head><p>Quantifier elimination over the first-order theory of reals cannot handle modal formulas. Hence, the dL calculus first reduces modalities to first-order constraints before applying QE. Yet, this is not necessary for all modalities. The modal subformula in the following example does not impose any constraints on X but its truth value only determines which first-order constraints are imposed on X:</p><formula xml:id="formula_23">QE(∃X (X &lt; 0 ∧ (( y := 2y + 1 y &gt; 0) → X &gt; y))) ≡ ( y := 2y + 1 y &gt; 0) → y &lt; 0.</formula><p>Modal formulas not containing elimination variable X can be handled by propositional abstraction in QE and remain unchanged. Syntactically, the reason for this is that dL rule applications on modal formulas that do not contain X will never produce formulas which do. The semantical reason for the same fact is a generalisation of the coincidence lemma to dL, which says that values of variables that do not occur will neither affect the transition structure of a hybrid program nor the truth value of formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Coincidence) If the interpretations (and assignments and states, respectively) I, η, ν and J, ε, ω agree on all symbols that occur free in the formula φ, then val I,η (ν, φ) = val J,ε (ω, φ).</head><p>Proof The proof is by a simple structural induction using the definition of val I,η (ν, •) and ρ I,η (•) in Definitions 3-5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Global Invertible Quantifier Rules</head><p>Rules F3 and F6 display an asymmetry. While F3 works locally on a branch, F6 needs to respect all branches that contain X. The reason for this is that branches are implicitly combined conjunctively in sequent calculus, as all branches have to close simultaneously for a proof to succeed (Definition 9). Universal quantifiers can be handled separately for conjunctions by ∀x(φ ∧ ψ) ≡ ∀xφ ∧ ∀xψ. Existential quantifiers, however, can only be dealt with separately for disjunctions but not for conjunctions. In calculi with a disjunctive proof structure, the roles of F3 and F6 would be interchanged but the phenomenon remains.</p><p>Rule F6 can be applied to the full proof (i.e., all open goals) like a global closing substitution in the tableau calculus <ref type="bibr" target="#b27">[26]</ref>. By Lemma 3 it only needs to consider the set of all open goals Φ i Ψ i that actually contain X. F6 resembles global closing substitutions in uninterpreted free variable tableaux <ref type="bibr" target="#b31">[30]</ref>. Both avoid the backtracking over closing substitutions that local closing substitutions require. Unlike closing substitutions, however, F6 uses the fixed semantics of function and predicate symbols of real arithmetic such that variables can already be eliminated equivalently by QE before the proof completes. Applying F3 or F6 early does not necessarily close the proof. Instead, equivalent constraints on the remaining variables will be revealed, which can simplify the proof or help deriving parametric constraints or invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Soundness and Completeness</head><p>In this section, we prove that the dL calculus is a sound and complete axiomatisation of the transition behaviour of hybrid systems relative to differential equations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Soundness</head><p>We prove that a successful deduction in the dL calculus always produces correct verification results about hybrid systems: The dL calculus is sound, i.e., all provable (closed) formulas are valid in all states of all interpretations. To reflect the interaction of free variables and Skolem terms, we adapt the notion of soundness for the liberalised δ + -rule in free variable tableau calculi <ref type="bibr" target="#b34">[33]</ref> to sequent calculus.</p><p>A formula φ is satisfiable <ref type="bibr" target="#b34">[33]</ref> (or has a model) if there is an interpretation I and a state ν such that for all variable assignments η we have I, η, ν |= φ. Closed tableaux prove the unsatisfiability of the negated goal. Sequent calculi work dually and show validity of the proof obligation. Consequently, we use the dual notion and say that ψ is a consequence of φ iff, for every I, ν there is an assignment η such that I, η, ν |= ψ, provided that, for every I, ν there is an assignment η such that I, η, ν |= φ. A calculus rule that concludes Ψ from the premisses Φ is sound if Ψ is a consequence of Φ. As usual, multiple branches in Ψ or Φ are combined conjunctively.</p><p>In this context, we think of free logical variables as being introduced by γ -rules, i.e., F4 and F5 (hence the implicit existential quantification of free logical variables by η). For closed formulas (without free logical variables), validity corresponds to being a consequence from an empty set of open goals. Hence, closed formulas that are provable with a sound deduction are valid (true in all states of all interpretations).</p><p>Theorem 1 (Soundness) The dL calculus is sound.</p><p>Proof The calculus is sound if each rule instance is sound. All rules of the dL calculus except F1,F2 and F6 are even locally sound, i.e., their conclusion is true at I, η, ν if all its premisses are true in I, η, ν, which implies soundness. It is also easy to show that locally sound rules remain sound when adding contexts Γ, , J as in Definition 8, since a discrete jump set J characterises a unique state transition. Local soundness proofs of D1-D8 and propositional rules are as usual. D9 Rule D9 is locally sound. Assume the premiss holds in I, η, ν, i.e., I, η, ν |= φ θ1 x1 . . . θn xn . We have to show that I, η, ν |= x 1 := θ 1 , . . . , x n := θ n φ, i.e., I, η, ω |= φ for a state ω with (ν, ω) ∈ ρ I,η (x 1 := θ 1 , . . . , x n := θ n ). This follows directly from the substitution lemma, which generalises to dynamic logic for admissible substitutions (Definition 6). Rule D10 uses that discrete jumps are deterministic. D11 The rule D11 is locally sound. Let y 1 , . . . , y n be a solution for the differential equation system x 1 = θ 1 , . . . , x n = θ n with symbolic initial values x 1 , .  Combining these results, we can conclude that f is a witness for I, η, ν |= D φ. The converse direction can be shown accordingly to prove the dual rule D12 using Lemma 1. F1 The proof is a sequent calculus adaptation of that in <ref type="bibr" target="#b34">[33]</ref>. By contraposition, assume that there are I, ν such that for all η it is the case that I, η, ν ∀x φ(x), hence I, η, ν |= ∃x¬φ(x). Then we construct an I that agrees with I except for the new function symbol s. Let b 1 , . . . , b n ∈ R be arbitrary elements and let η b assign b i to the respective X i for 1 ≤ i ≤ n. As I, η, ν |= ∃x¬φ(x) holds for all η, we pick a witness d for I, η b , ν |= ∃x¬φ(x) and choose</p><formula xml:id="formula_24">I (s)(b 1 , . . . , b n ) = d.</formula><p>For this interpretation I and state ν we have I , η, ν φ(s(X 1 , . . . , X n )) for all assignments η by Lemma 3, as X 1 , . . . , X n are all free variables determining the truth value of φ(s(X 1 , . . . , X n )). To see that the contexts Γ, Δ of Definition 8 can be added to instantiate this rule, consider the following. Since s is new and does not occur in the context Γ, Δ, the latter do not change their truth value by passing from I to I . Likewise, s is rigid so that it does not change its value by adding jump prefix J which concludes the proof. The proof of F2 is dual. F3 F3 is locally sound. Assume that I, η, ν |= QE(∀X (Φ(X) Ψ(X))). Since quantifier elimination yields an equivalence, we can conclude I, η, ν |= ∀X(Φ(X) Ψ(X)). Then if the antecedent of the conclusion is true, i.e., I, η, ν |= Φ(s(X 1 , . . . , X n ), we can conclude that I, η, ν |= Ψ (s(X 1 , . . . , X n )) by choosing val I,η (ν, s(X 1 , . . . , X n )) for X in the premiss. By admissibility of substitutions, variables X 1 , . . . , X n are free at all occurrences of s(X 1 , . . . , X n ), hence their value is the same in all occurrences. F4 F4 is locally sound by a simplified version of the proof in <ref type="bibr" target="#b34">[33]</ref>. For any I, η, ν with I, η, ν |= φ(X) we can conclude I, η, ν |= ∃xφ(x) according to the witness η(X). The proof of F5 is dual. F6 For any I, ν let η be such that I, η, ν |= QE(∃X i (Φ i Ψ i )). Again, this implies I, η, ν |= ∃X i (Φ i Ψ i ), because quantifier elimination yields an equivalence. We pick a witness d ∈ R for this existential quantifier. As X does not occur anywhere else in the proof, it disappears from all open premisses of the proof by applying F6. Hence, by the coincidence Lemma 3, the value of X does not change the truth value of the premise of F6. Consequently, η can be extended to η by changing the interpretation of X to the witness d such that I, η , ν |= i (Φ i Ψ i ). Thus, η extends I, η, ν to a simultaneous model of all conclusions. G2 Rules G1-G4 are locally sound by a variation of the usual proofs <ref type="bibr" target="#b36">[35]</ref> using universal closures for local soundness. G1-G2 are simple refinements of Lemma 3 using that ∀ α comprises all variables that change in α.  </p><formula xml:id="formula_25">I, η[v → d], ν |= v &gt; 0 ∧ ϕ(v) → α ϕ(v -</formula><formula xml:id="formula_26">I, η[v → d], ν |= v &gt; 0 ∧ ϕ(v) → α ϕ(v -1). As v &gt; 0 ∧ ϕ(v) holds true, we have for some ν with (ν, ν ) ∈ ρ I,η[v →d] (α) that I, η[v → d], ν |= ϕ(v -1). Thus, I, η[v → d -1], ν |= ϕ(v)</formula><p>satisfies the induction hypothesis for a smaller d and a reachable ν , because (ν, ν ) ∈ ρ I,η (α) as v does not occur in α. The induction is well-founded, because d decreases by 1 up to the base case d ≤ 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Completeness</head><p>Theorem 1 shows that all provable closed dL formulas are valid. The converse question is whether the dL calculus is complete, i.e., all valid dL formulas are provable. Combining completeness for first-order logic <ref type="bibr" target="#b34">[33]</ref> and decidability of realarithmetic <ref type="bibr" target="#b16">[16]</ref>, it is easy to see that our calculus is complete for closed formulas of first-order real arithmetic by chaining the quantifier rules F1,F2,F4,F5 with the respective inverse rules F3,F6, using P-rules as needed to unfold the propositional structure. In the presence of modalities, however, dL is not axiomatisable and, unlike its basis of first-order real arithmetic, dL is undecidable. Both unbounded repetition in the discrete fragment and unbounded evolution in the continuous fragment cause incompleteness. Beyond hybrid dynamics, where reachability is known to be undecidable <ref type="bibr" target="#b37">[36]</ref>, we show that even the purely discrete and purely continuous parts of dL are not effectively axiomatisable. Hence, valid dL formulas are not always provable.</p><p>Theorem 2 (Incompleteness) Both the discrete fragment and the continuous fragment of dL are not effectively axiomatisable, i.e., they have no sound and complete effective calculus, because natural numbers are definable in both fragments.</p><p>Proof We prove that natural numbers are definable among the real numbers of dL interpretations in both fragments. Then these fragments extend first-order integer arithmetic such that the incompleteness theorem of Gödel <ref type="bibr" target="#b32">[31]</ref> applies. Natural numbers are definable in the discrete fragment without continuous evolutions using repetitive additions:</p><formula xml:id="formula_27">nat(n) ↔ x := 0; (x := x + 1) * x = n.</formula><p>In the continuous fragment, an isomorphic copy of the natural numbers is definable using linear differential equations:</p><formula xml:id="formula_28">nat(n) ↔ ∃s∃c∃τ (s = 0 ∧ c = 1 ∧ τ = 0 ∧ s = c, c = -s, τ = 1 (s = 0 ∧ τ = n)).</formula><p>These differential equations characterise sin and cos as unique solutions for s and c, respectively. Their zeros, as detected by τ , correspond to an isomorphic copy of natural numbers, scaled by π , i.e., nat(n) holds iff n is of the form kπ for a k ∈ N.</p><p>The nonzero initial values for s and c prevent the trivial solution identical to 0.</p><p>The standard approach for showing adequacy of a calculus when its logic is not effectively axiomatisable is to analyse the deductive power of the calculus relative to a base logic or relative to an ineffective oracle rule for the base logic <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b36">35]</ref>. In calculi for discrete programs, completeness is proven relative to the handling of data <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b36">35]</ref>. For hybrid systems, this is inadequate: By Theorem 2, no sound calculus for dL can be complete relative to its data (the reals), because its basis, first-order real arithmetic, is a perfectly decidable and axiomatisable theory <ref type="bibr" target="#b55">[54]</ref>.</p><p>According to Theorem 2, continuous evolutions, repetitive discrete transitions, and their interaction cause non-axiomatisability of dL. Discrete transitions and repetition do not supersede the complexity of continuous transitions. Even relative to an oracle for handling properties of discrete jumps and repetition, the dL calculus is not complete, simply because not all differential equations have solutions that are definable in first-order arithmetic so that D12 can be used. For instance, the solutions of s = c, c = -s are trigonometric functions (like sin and cos), which are not first-order definable. The question is whether the converse is true, i.e., whether hybrid programs can be verified given that all required differential equations can be handled.</p><p>To calibrate the deductive power of the dL calculus in light of its inherent incompleteness, we analyse the quotient of reasoning about hybrid systems modulo differential equation handling. Using generalisations of the usual notions of relative completeness for discrete systems <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b36">35]</ref> to the hybrid case, we show that the dL calculus completely axiomatises dL relative to one single additional axiom about valid first-order properties of differential equations. Essentially, we drop the effectiveness requirement for one oracle axiom and show that the resulting dL calculus is sound and complete.</p><p>As a basis, we define FOD as the first-order logic of differential equations, i.e., firstorder real arithmetic augmented with formulas expressing properties of differential equations, that is, dL formulas of the form [x 1 = θ 1 , . . . , x n = θ n ]F with a first-order formula F. Dually,</p><formula xml:id="formula_29">x 1 = θ 1 , . . . , x n = θ n F is expressible as ¬[x 1 = θ 1 , . . . , x n = θ n ]¬F.</formula><p>Theorem 3 (Relative completeness) The dL calculus is complete relative to FOD, i.e., every valid dL formula can be derived from FOD-tautologies.</p><p>Proof (Outline) The (constructive) proof, which, in full, is contained in Appendix A, adapts the techniques of Cook <ref type="bibr" target="#b17">[17]</ref> and Harel <ref type="bibr" target="#b35">[34,</ref><ref type="bibr" target="#b36">35]</ref> to the hybrid case. The decisive step is to show that every valid property of a repetition α * can be proven by G3 or G4, respectively, with a sufficiently strong invariant or variant that is expressible in dL. For this, we show that dL formulas can be expressed equivalently in FOD, and that valid dL formulas can be derived from corresponding FOD axioms in the dL calculus. In turn, the crucial step is to construct a finite FOD formula that characterises the effect of unboundedly many repetitive hybrid transitions and just uses finitely many real variables. This main result completely aligns hybrid and continuous verification prooftheoretically. It gives a formal justification that reasoning about hybrid systems is possible to exactly the same extent to which it is possible to show properties of solutions of differential equations. Theorem 3 shows that superpositions of discrete jumps, continuous evolutions, and repetitions of hybrid processes, can be verified when corresponding (intermediate) properties of differential equations are provable. Moreover, in a proof-theoretical sense, our calculus completely lifts all verification techniques for dynamical systems to hybrid systems.</p><p>Summarising Theorems 1 and 3, the dL calculus axiomatises the transition behaviour of hybrid systems completely relative to the handling of differential equations!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Relatively Semidecidable Fragments</head><p>To strengthen the completeness result from Theorem 3, we consider fragments of dL where the required FOD tautologies are sufficiently simple as differential equations have first-order definable flows and the required loop invariants (or variants) are expressible in first-order logic over the reals. In these fragments, the only difficulty is to find the required invariants and variants for the proof. Relative to an (ineffective) oracle that provides first-order invariants and variants for repetitions, the dL calculus can be used as a semidecision procedure. That is, when we assume the oracle to provide suitable (in)variants, validity of formulas can be proven in the dL calculus. If an imperfect oracle chooses inadequate (in)variants, applying the dL calculus rules results in goals that are not valid, which is again decidable by quantifier elimination in the dL calculus.</p><p>Theorem 4 (Relatively semidecidable fragment) Relative to an oracle generating first-order invariants and variants, the dL calculus gives a backtracking-free semideci-sion procedure for (closed) dL formulas with differential equations having first-order definable flows. Proof (Outline) The (constructive) proof, which, in full, is contained in Appendix B, shows that there are always applicable dL rules that transform the formulas equivalently and that formulas in this dL proof descend along a well-founded order. For loops, we assume that suitable (in)variants are obtained from the oracle and we can guarantee termination when these (in)variants are first-order (or contain less loops).</p><p>As a consequence, enumerating first-order invariants or variants gives a semidecision procedure for the fragment of Theorem 4. As a corollary to Theorem 2 and Theorem 4, there are valid dL formulas that need proper dL (or FOD) invariants to be provable and cannot be proven just using (in)variants of first-order real arithmetic. Similarly, the fragment with first-order definable flows and bounded loops is decidable: When loops α * are decorated with natural numbers indicating the maximum number of repetitions of α, an effective oracle for Theorem 4 can be obtained by unrolling, e.g., by D5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Verifying Safety in the European Train Control System</head><p>Finding Inductive Candidates We want to prove safety statement (1) of the ETCS from Section 3. Using parametric extraction techniques, we identify both the requirement ψ for safe driving and the induction hypothesis φ that is required for the proof. Dually to the proof in Fig. <ref type="figure">7</ref>, an unwinding of the loop in (1) by D6 can be used to extract a candidate for a parametric inductive hypothesis. It expresses that there is sufficient braking distance at current speed v, which basically corresponds to the controllability constraint for ETCS:</p><formula xml:id="formula_30">φ ≡ v 2 ≤ 2b(m -z) ∧ b &gt; 0 ∧ A ≥ 0.<label>(2)</label></formula><p>Inductive Verification Using G3 to prove (1) by induction, we show that (a) invariant φ holds initially, i.e., ψ φ (implying antecedent of the conclusion of G3), that (b) the invariant is sustained after each execution of ctrl; drive, and that (c) invariant φ implies postcondition z ≤ m. Case (c) holds by QE as 0 ≤ v 2 ≤ 2b(mz) and b &gt; 0. The induction start (a) will be examined after the full proof has been given, since we want to identify the prerequisite ψ for safe driving by proof analysis. In the proof of the induction step φ → [ctrl; drive]φ, we omit condition mz ≤ s from ctrl, because it is not used in the proof (braking remains safe with respect to z ≤ m). The induction can be proven in dL as follows (for notational convenience, we assume F1 to call the Skolem constant for m again m etc., as there are no free logical variables):</p><formula xml:id="formula_31">. . . . . . φ,m -z ≥ s a := A [drive]φ φ a := -b [drive]φ D8,P7 φ [?m-z ≥ s; a := A][drive]φ D4,P5 φ [ctrl][drive]φ D2 φ [ctrl; drive]φ P7 φ → [ctrl; drive]φ F1 ∀ α (φ → [ctrl; drive]φ) G3 φ [(ctrl; drive) * ]φ</formula><p>The differential equation system in drive is linear with a constant coefficient matrix M. Its solution can be obtained by symbolically computing the exponential series e Mt η with symbolic initial value η = (z, v) and similar symbolic integration of the inhomogeneous part [58, §18.VI]. We abbreviate the solution z := -b 2 t 2 + vt + z, v := -bt + v thus obtained by S t . In this example, the invariant evolution conditions are convex, hence the constraint ∀0≤ t≤t S t X of D12 can be simplified to S t X to save space. Further, we leave out conditions which are unnecessary for closing the above proof. In the left branch, the constrained evolution of τ is irrelevant and will be left out. The left branch closes (marked as * ):</p><formula xml:id="formula_32">D9,F3 * D9 φ, t ≥ 0, -bt + v ≥ 0 S t φ P7,P7 φ, t ≥ 0, v := -bt + v v ≥ 0 S t φ F1 φ t ≥ 0 → ( v := -bt + v v ≥ 0 → S t φ) D12 φ ∀t ≥ 0 ( v := -bt + v v ≥ 0 → S t φ) D9 φ [z = v, v = -b &amp;v ≥ 0]φ D10 φ a := -b [drive]φ φ [a := -b ][drive]φ</formula><p>The right branch does not need v ≥ 0, because v does not decrease. To abbreviate solution z :</p><formula xml:id="formula_33">= A 2 t 2 + vt + z, v := At + v , we again use S t . . . . D9,F3 φ, m -z ≥ s s ≥ v 2 2b + A b + 1 A 2 ε 2 + εv P7,D9 φ, m -z ≥ s, 0 ≤ t ≤ ε S t φ F1 φ, m -z ≥ s t ≥ 0 → ( τ := t τ ≤ ε → S t φ) D9 φ, m -z ≥ s ∀t≥0 ( τ := t τ ≤ ε → S t φ) D12 φ, m -z ≥ s τ := 0 ∀t≥0 ( τ := t + τ τ ≤ ε → S t φ) D10 φ, m -z ≥ s τ := 0 [z = v, v = A, τ = 1&amp;τ ≤ ε]φ D9 φ, m -z ≥ s [τ := 0][z = v, v = A, τ = 1&amp;τ ≤ ε]φ D2 φ, m -z ≥ s a := A [τ := 0][z = v, v = a, τ = 1&amp;τ ≤ ε]φ D10 φ, m -z ≥ s a := A [drive]φ φ, m -z ≥ s [a := A][drive]φ</formula><p>Parameter Constraint Discovery The right branch only closes when the succedent of its open goal is guaranteed. That formula expresses that there will still be sufficient braking distance even after accelerating by ≤A for up to ε seconds:</p><formula xml:id="formula_34">s ≥ v 2 2b + A b + 1 A 2 ε 2 + εv .<label>(3)</label></formula><p>This constraint can be discovered automatically in the above proof by the indicated application of F3 using quantifier elimination with some simplifications. Constraint (3) is required to make sure invariant (2) still holds after accelerating. In fact, augmenting the case study with (3) makes the argument inductive, and the whole proof of the safety statement (1) closes when ψ is chosen identical to φ. Here, the conditions of ψ cannot be removed without leaving the proof open due to a counterexample, as the invariant ( <ref type="formula" target="#formula_30">2</ref>) is a controllability constraint, see Section 4.2.1. Quite unlike in the acceleration-free case <ref type="bibr" target="#b48">[47]</ref>, constraint (3) needs to be enforced dynamically as the affected variables change over time. That is, at the beginning of each ctrl-cycle, s needs to be updated in accordance with (3), which admits complex behaviour like in Fig. <ref type="figure">5b</ref>. Further, this constraint can be used to find out how dense a track can be packed with trains in order to maximise ETCS throughput without endangering safety. Using the dL calculus, similar constraints can be derived <ref type="bibr" target="#b49">[48]</ref> to find out how early a train needs to start negotiation in order to minimise the risk of having to reduce speed when the MA is not extendable in time, which is the ST parameter of Fig. <ref type="figure">4</ref>.</p><p>For the resulting ETCS system, liveness can be proven in the dL calculus by showing that the train can pass every point p by an appropriate choice of m by the RBC:</p><formula xml:id="formula_35">v = v 0 &gt; 0 ∧ ε &gt; 0 ∧ b &gt; 0 ∧ A ≥ 0 → ∀p∃m (ctrl; drive) * z ≥ p (4)</formula><p>The proof of property (4) uses the variant ϕ(n) ≡ z + nεv 0 ≥ p ∧ v ≥ v 0 for G4, which expresses that the speed does not decrease (until n &lt; 0) and that the remaining distance from z to target p can be covered after at most n iteration cycles.</p><p>In this example, we can see the effect of the dL calculus. It takes a specification of a hybrid system and successively identifies constraints on the parameters which are needed for correctness. These constraints can then be handled in a purely modular way by F3 and F6. As a typical characteristics of hybrid systems, further observe that intermediate formulas are significantly more complex than the original proof obligation, which can be expressed succinctly in dL. This reflects the fact that the actual complexity of hybrid systems originates from hybrid interaction, not from a single transition. Still, using appropriate proof strategies <ref type="bibr" target="#b47">[46]</ref> for the dL calculus, the safety statement <ref type="bibr" target="#b0">(1)</ref> with invariant (2) can be verified automatically in a theorem prover that invokes Mathematica for D11-D12, F3, and F6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Work</head><p>We have introduced a first-order dynamic logic for hybrid programs, which are uniform operational models for hybrid systems with interacting discrete jumps and continuous evolutions along differential equations. For this differential dynamic logic, dL, we have presented a concise generalised free variable proof calculus over the reals.</p><p>Our sequent calculus for dL is a generalisation of classical calculi for discrete dynamic logic <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b36">35]</ref> to the hybrid case. It is a compositional verification calculus for verifying properties of hybrid programs by decomposing them into properties of their parts. In order to handle interacting hybrid dynamics, we lift real quantifier elimination to the deductive calculus in a new modular way that is suitable for automation, using real-valued free variables, Skolem terms, and invertible quantifier rules over the reals.</p><p>As a fundamental result aligning hybrid and continuous reasoning prooftheoretically, we have proven our calculus to axiomatise the transition behaviour of hybrid systems completely relative to the handling of differential equations. More-over, we have demonstrated that our calculus is well-suited for practical automatic verification in a realistic case study of a fully parametric version of the European Train Control System.</p><p>Dynamic logic can be augmented <ref type="bibr" target="#b8">[8]</ref> to support reasoning about dynamically reconfiguring system structures, which we want to extend to hybrid systems in future work. Further, we will develop Lyapunov-like techniques to handle differential equations in dL without solving them. While the dL calculus is complete relative to the continuous fragment, it is a subtle open problem whether a converse calculus can exist that is complete relative to various discrete fragments.  ing at(Z, n, j, z), we use several auxiliary functions to improve readability, see Fig. <ref type="figure" target="#fig_9">9b</ref>. Note that these definitions need no recursion, hence, like in the notation φ(Z (n)  j ), we can consider occurrences of the function symbols as syntactic abbreviations for quantified variables satisfying the respective definitions.</p><p>The function symbol bit(a, i) gives the i-th bit of a ∈ R when represented with basis 2. For i &gt; 0, bit(a, i) yields fractional bits, and, for i ≤ 0, it yields bits of the integer part. For instance, bit(a, 1) yields the first fractional bit, bit(a, 0) is the leastsignificant bit of the integer part of a. The function intpart(a) represents the integer part of a ∈ R. The function frac(a) represents the fractional part of a ∈ R, which drops all integer bits. The last constraint in its definition implies that frac(a) keeps the sign of a (or 0). Consequently, intpart(a) and bit(a, i) also keep the sign of a (or 0). Exponentiation 2 i is definable using differential equations, using an auxiliary characterisation of the natural logarithm ln 2. The definition of 2 i splits into the case of exponential growth when i ≥ 0 and a symmetric case of exponential decay when i &lt; 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Expressibility and Rendition of Hybrid Program Semantics</head><p>In order to show that dL is sufficiently expressive to state the invariants and variants that are needed for proving valid statements about loops with G3 and G4, we prove an expressibility result. We give a constructive proof that the state transition relation of hybrid programs is definable in FOD, i.e., there is a FOD-formula S α ( x, v) characterising the state transitions of hybrid program α from the state characterised by the vector x of variables to the state characterised by vector v.</p><p>For this, we need to characterise hybrid processes equivalently by differential equations in FOD. Observe that the existence of such characterisations does not follow from results embedding Turing machines into differential equations <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b33">32]</ref>, because, unlike Turing machines, hybrid processes are not restricted to discrete values on a grid (like N k ) but work with continuous real values. Furthermore, Turing machines only have repetitions of discrete transitions on discrete data (e.g., N). For hybrid programs, instead, we have to characterise repetitive interactions of discrete and continuous transitions in continuous space (some R k ).</p><p>Lemma 5 (Program rendition) For every hybrid program α with variables x = x 1 , . . . , x k there is a FOD-formula S α ( x, v) with variables among the 2k distinct variables x = x 1 , . . . , x k and v = v 1 , . . . , v k such that</p><formula xml:id="formula_36">S α ( x, v) ↔ α x = v</formula><p>or, equivalently, for every I, η, ν,</p><formula xml:id="formula_37">I, η, ν |= S α ( x, v) iff (ν, ν[ x → val I,η (ν, v)]) ∈ ρ I,η (α) .</formula><p>Proof By Lemma 3, interpretations of the vectors x and v characterises the input and output states, respectively, as far as α is concerned. These vectors are finite because α is finite. Vectorial equalities like x = v or quantifiers ∃ v are to be understood component-wise. The program rendition is defined inductively in Fig. <ref type="figure" target="#fig_10">10</ref>. To simplify the notation, we assume that all variables x 1 , . . . , x k are affected in discrete jumps and differential equations by adding vacuous x i := x i or x i = 0 if x i does not change in the respective statement, otherwise.</p><p>Differential equations give FOD-formulas hence no further reduction is necessary. Evolution along differential equations with invariant regions is definable by following the unique flow (Lemma 1) backwards. Continuous evolution is reversible, i.e., the transitions of x i = -θ are inverse to those of x i = θ. Consequently, when using auxiliary variable t, all evolutions of [x 1 = -θ 1 , . . . , x k = -θ k , t = -1] follow the same flow as x 1 = θ 1 , . . . , x k = θ k , t = 1 but backwards. By also reverting To show reversibility, let (ν, ω) ∈ ρ I,η (x 1 = θ 1 , . . . , x k = θ k ), that is, let f : [0, r] → Sta(Σ) be a solution of x 1 = θ 1 , . . . , x k = θ k starting in ν and ending in ω. Then g : [0, r] → Sta(Σ), defined as g(ζ ) = f (r -ζ ), starts in ω and ends in ν. Thus, it only remains to show that g is a solution of x 1 = -θ 1 , . . . , x k = -θ k , which can be seen for 1 ≤ i ≤ k as follows:</p><formula xml:id="formula_38">dg(t)(x i ) dt (ζ ) = d f (r -t)(x i ) dt (ζ ) = d f (u)(x i ) du d(r -t) dt (ζ ) = - d f (u)(x i ) du (ζ ) = -val I,η ( f (ζ ), θ i ) = val I,η ( f (ζ ), -θ i ) .</formula><p>Unlike all other cases, case S x 1 =θ1,..,x k =θk&amp;χ ( x, v) in Fig. <ref type="figure" target="#fig_10">10</ref> uses nested FOD modalities. Yet nested modalities can be avoided in S α ( x, v) using an equivalent FOD formula without them, see Fig. <ref type="figure" target="#fig_11">11</ref>:</p><formula xml:id="formula_39">∃t∃r t = 0 ∧ x 1 = θ 1 , . . . , x k = θ k , t = 1 ( v = x ∧ r = t) ∧ ∀ x ∀t( x = v ∧ t = r → [x 1 = -θ 1 , . . . , x k = -θ k , t = -1](t ≥ 0 → χ)) .</formula><p>With a finite formula, the characterisation of repetition S β * ( x, v) in FOD needs to capture long sequences of intermediate real-valued states and the correct transition between successive states of such a sequence. To achieve this with firstorder quantifiers, we use the real Gödel encoding from Lemma 4 in Fig. <ref type="figure" target="#fig_10">10</ref> to map unbounded sequences of real-valued states reversibly to a single real number Z , which can be quantified over in first-order logic.</p><p>Using the program rendition from Lemma 5 to characterise modalities, we prove that every dL formula can be expressed equivalently in FOD by structural induction. Lemma 6 (Expressibility) dL is expressible in FOD: for all dL formulas φ ∈ Fml(Σ, V) there is a FOD-formula φ # ∈ Fml FOD (Σ, V) that is equivalent, i.e., |= φ ↔ φ # . The converse holds trivially. x Proof The proof follows an induction on the structure of formula φ for which it is imperative to find an equivalent φ # in FOD. Observe that the construction of φ # from φ is effective. 0. If φ is a first-order formula, then φ # := φ already is a FOD-formula such that nothing has to be shown. </p><formula xml:id="formula_40">|= α ψ ↔ ∃ v(S α ( x, v) ∧ ψ # v x ) .</formula><p>3. The case where φ is [α]ψ is again a consequence of Lemma 5:</p><formula xml:id="formula_41">|= α ψ ↔ ∀ v(S α ( x, v) → ψ # v x ) .</formula><p>The above proofs directly carry over to rich test dL, i.e., the logic where dL formulas are allowed in tests ?χ of hybrid programs and invariant regions χ of differential equations, when using χ # in place of χ in Fig. <ref type="figure" target="#fig_10">10</ref>. Accordingly, nested modalities can be avoided in FOD by using the following formula for S x 1 =θ1,..,x k =θk &amp;χ ( x, v):</p><formula xml:id="formula_42">∃t∃r t = 0 ∧ x 1 = θ 1 , .., x k = θ k , t = 1 ( v = x ∧ r = t) ∧ ∀ z(∃ x∃t( x = v ∧ t =r ∧ x 1 =-θ 1 , .., x k =-θ k , t =-1 (t ≥ 0 ∧ z = x)) → χ # z x ) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Relative Completeness of First-order Assertions</head><p>As special cases of Theorem 3, we first prove relative completeness for first-order assertions about hybrid programs. These first-order cases constitute the basis for the general completeness proof for arbitrary formulas of differential dynamic logic.</p><p>In the sequel, we use the notation D φ to indicate that a dL formula φ is derivable (Definition 9) from a set of FOD-tautologies, which is equivalent to saying that φ is derivable in the dL calculus augmented with a single oracle axiom D, that gives all valid FOD-instances. Likewise, we use the notation Γ D Δ to indicate that the sequent Γ Δ is derivable from D.</p><p>For the completeness proof, we use several simplifications. For uniform proofs, we assume formulas to use a simplified vocabulary. A formula φ is valid iff it is true in all I, η, ν. In particular, we can assume valid φ to use Skolem constants (or state variables) instead of free logical variables. Existential quantifiers can be represented as modalities: ∃x φ ≡ x = 1 φ ∨ x = -1 φ. For simplicity, we use cut (P10) and weakening to glue together subproofs propositionally. Weakening (i.e., from φ ψ infer φ 1 , φ ψ, ψ 1 ) can be emulated using contexts Γ, Δ from Definition 8, and we use it implicitly together with P10 in the following. Derivability of sequents and corresponding formulas is equivalent by the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7 (Derivability of sequents)</head><formula xml:id="formula_43">D φ → ψ iff φ D ψ.</formula><p>Proof When we consider sequents as abbreviations for formulas, both sides are identical. Otherwise, let D φ → ψ be derivable from D. Using P10 (and weakening) with φ → ψ, this derivation can be extended to one of φ D ψ:</p><formula xml:id="formula_44">P8 P9 * φ φ, ψ P9 * ψ, φ ψ P10 * φ φ → ψ, ψ φ, φ → ψ ψ φ ψ</formula><p>The converse direction is by an application of P7.</p><p>Lemma 8 (Generalisation) If D φ is provable without free logical variables, then so are D ∀xφ and D x 1 := θ 1 , . . . x n := θ n φ.</p><p>Proof For the second conjecture, let I abbreviate x 1 := θ 1 , . . . x n := θ n . We prefix each formula in the proof of φ with I and show that this gives a proof of I φ. F6 is not needed in the proof due to the absence of free logical variables. As an intermediate step, we first show that prefixing with I gives an (extended) proof with rule applications generalised to allowing for nested jump prefixes I J : By the argument in Theorem 1, it is easy to see for discrete jump sets I and J that the dL rules remain sound with nested jump prefix I J in place of only a single prefix J from Definition 8. Applicability conditions of rules do not depend on jump prefixes, as Definition 8 allows adding any jump prefix. Thus, we obtain a sound (extended) proof of I φ when replacing-with arbitrary unchanged context Γ, Δ, J -every rule application of the form</p><formula xml:id="formula_45">Γ, J Φ 1 J Ψ 1 , Δ . . . Γ, J Φ n J Ψ n , Δ Γ, J Φ 0 J Ψ 0 , Δ</formula><p>in the proof of φ by a rule application with additional unchanged prefix I for corresponding Γ, , J :</p><formula xml:id="formula_46">Γ, I J Φ 1 I J Ψ 1 , Δ . . . Γ, I J Φ n I J Ψ n , Δ Γ, I J Φ 0 I J Ψ 0 , Δ<label>(5)</label></formula><p>Next, we show that these nested jump prefixes can be reduced to a single jump prefix as Definition 8 allows for: Let IJ denote the discrete jump set obtained by merging I and J using D9 as in Section 4.1. We replace each rule application (with nested prefixes) of the form (5) by the following derivation with only a single prefix (assuming n = 1 for notational convenience):</p><formula xml:id="formula_47">P9 * . . . D9 Γ, IJ Φ 1 IJ Φ 1 , Δ P10 Γ, I J Φ 1 IJ Ψ 1 , Δ Γ, IJ Φ 1 I J Φ 1 , Δ Γ, IJ Φ 1 IJ Ψ 1 , Δ D9,D9 Γ, IJ Φ 0 IJ Ψ 0 , Δ Γ, I J Φ 0 I J Ψ 0 , Δ</formula><p>The bottom-most D9 applications merge I into J in the antecedent and succedent, respectively. The unmarked rule applies the same rule that has been used in <ref type="bibr" target="#b5">(5)</ref>, which is applicable on Φ 0 Ψ 0 for any context by Definition 8, including Γ, Δ, IJ . The subsequent cut with I J Φ 1 restores the form of the premiss in <ref type="bibr" target="#b5">(5)</ref>. The left branch continues using a dual argument to turn succedent IJ Ψ 1 into I J Ψ 1 , thereby yielding a set of non-extended rule applications with the same conclusions and premisses as the extended rule application (5):</p><formula xml:id="formula_48">P9 * D9 Γ, IJ Ψ 1 IJ Ψ 1 , Δ P10 Γ, I J Φ 1 I J Ψ 1 , Δ Γ, I J Ψ 1 IJ Ψ 1 , Δ Γ, I J Φ 1 IJ Ψ 1 , Δ</formula><p>For reducing the first conjecture of this lemma to the second, let s be a Skolem constant for state variable x. By the above proof, we derive D x := s φ. Using F1, we continue this derivation to a proof of ∀X x := X φ, which we abbreviate as ∀xφ (see text below Definition 6). Rule F1 is applicable for Skolem constant s as no free logical variables occur in the proof.</p><p>Proposition 1 (Relative completeness of first-order safety) For every hybrid program α ∈ HP( , V) and each F, G ∈ Fml FOL ( , V) of first-order logic <ref type="bibr">Lemma 7)</ref>.</p><formula xml:id="formula_49">|= F → [α]G implies D F → [α]G (and F D [α]G by</formula><p>Proof We generalise the relative completeness proof by Cook <ref type="bibr" target="#b17">[17]</ref> to dL and follow an induction on the structure of program α. In the following, IH is short for the induction hypothesis.</p><p>1. The cases where α is of the form x 1 := θ 1 . . . , x n := θ n , ?χ, β ∪ γ, or β; γ are consequences of the soundness of the symmetric rules D2, D4, and D8-D10. Since these rules are symmetric, they perform equivalent transformations. Consequently, whenever their conclusion is valid, their premiss is valid and of smaller complexity (the programs get simpler), hence derivable by IH. Thus, we can derive F → [α]G by applying the respective rule. We explicitly show the proof for β; γ as it contains an extra twist. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">|=</head><formula xml:id="formula_50">F → [β; γ ]G, which implies |= F → [β][γ ]G. By Lemma 6, there is a FOD- formula G # such that |= G # ↔ [γ ]G. From the validity of |= F → [β]G # , we can conclude by IH that F D [β]G # is derivable. Similarly, because of |= G # → [γ ]G, we conclude D G # → [γ ]G</formula><formula xml:id="formula_51">F → [β; γ ]G). 3. |= F → [x 1 = θ 1 . . . , x n = θ n ]</formula><p>G is a FOD-formula and hence derivable as a D axiom. Continuous evolution x 1 = θ 1 . . . , x n = θ n &amp;χ with invariant regions is definable in FOD by Lemma 5, which we consider as an abbreviation in this proof. 4. |= F → [β * ]G can be derived by induction. For this, we define the invariant as a FOD encoding of the statement that all potential poststates of β * satisfy G according to Lemma 6:</p><formula xml:id="formula_52">φ ≡ ([β * ]G) # ≡ ∀ v(S β * ( x, v) → G v x ).</formula><p>Since Proof We generalise the arithmetic completeness proof by Harel <ref type="bibr" target="#b35">[34]</ref> to the hybrid case. Most cases of the proof are simple adaptations of the corresponding cases in Proposition 1. What remains to be shown is the case of repetitions. Assume that F → β * G. To derive this formula by G4, we use a FOD-formula ϕ(n) as a variant expressing that, after n iterations, β can lead to a state satisfying G. This formula is obtained from Lemma 5-6 as</p><formula xml:id="formula_53">( β * G) # ≡ ∃ v(S β * ( x, v) ∧ G v</formula><p>x ), except that the quantifier on the repetition count n is removed such that n becomes a free variable (plus index shifting to count repetitions):</p><formula xml:id="formula_54">ϕ(n -1) ≡ ∃ v ∃Z Z (n) 1 = x ∧ Z (n) n = v ∧ ∀i : N (1 ≤ i &lt; n → S β (Z (n) i , Z (n) i+1 )) ∧ G v x .</formula><p>By Lemma 4, ϕ(n) can only hold true if n is a natural number.</p><p>According to the loop semantics, |= n &gt; 0 ∧ ϕ(n) → β ϕ(n -1) is valid by construction: If n &gt; 0 is a natural number then so is n -1, and if β reaches G after n repetitions, then, after executing β once, n -1 repetitions of β reach G. By IH, this formula is derivable, since β contains less loops. By Lemma 8, we extend this derivation to D ∀ β ∀n&gt;0(ϕ(n) → β ϕ(n -1)). Thus ∃v ϕ(v) D β * ∃v≤0ϕ(v) by G4. It only remains to show that the antecedent is derivable from F and β * G is derivable from the succedent. From our assumption, we conclude that the following are valid FOD-formulas, hence D-axioms:</p><formula xml:id="formula_55">- F → ∃v ϕ(v), because F → β * G, and - (∃v≤0ϕ(v)) → G, because<label>v≤0</label></formula><p>and the fact, that, by Lemma 4, ϕ(v) only holds true for natural numbers, imply ϕ(0). Further, ϕ(0) entails G, because zero repetitions of β have no effect.</p><p>From the latter we derive D ∀ β (∃v≤0 ϕ(v) → G) by Lemma 8 and extend the derivation to β * ∃v≤0 ϕ(v) D β * G by G2. From D F → ∃v ϕ(v) we conclude F D ∃v ϕ(v) by Lemma 7. Now, the above derivations can be combined propositionally by a cut with β * ∃v≤0 ϕ(v) and with ∃v ϕ(v) to yield F D β * G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Relative Completeness of the Differential Logic Calculus</head><p>Having succeeded with the proofs of the above statements we can finish the proof of the Theorem 3, which is the central result of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (of Theorem 3)</head><p>The proof follows a basic structure analogous to that of Harel's proof for the discrete case <ref type="bibr" target="#b35">[34,</ref><ref type="bibr">Theorem 3.1]</ref>. We have to show that every valid dL formula φ can be proven from FOD axioms within the dL calculus: from φ we have to prove D φ. The proof proceeds as follows: By propositional recombination, we inductively identify fragments of φ that correspond to φ 1 → [α]φ 2 or φ 1 → α φ 2 logically. Next, we express subformulas φ i equivalently in FOD by Lemma 6, and use Proposition 1 and 2 to resolve these first-order safety or liveness assertions. Finally, we prove that the original dL formula can be re-derived from the subproofs.</p><p>We can assume φ to be given in conjunctive normal form by appropriate propositional reasoning. In particular, we assume that negations are pushed inside over modalities using the dualities ¬ [α]φ ≡ α ¬φ and ¬ α φ ≡ [α]¬φ. The remainder of the proof follows an induction on a measure |φ| defined as the number of modalities in φ. For a simple and uniform proof, we assume quantifiers to be abbreviations for modal formulas by ∃x φ ≡ x = 1 φ ∨ x = -1 φ and ∀xφ ≡ x = 1 φ ∧ x = -1 φ. 0. |φ| = 0 then φ is a first-order formula, hence derivable by D. 1. φ is of the form ¬φ 1 , then φ 1 is first-order, as we assumed negations to be pushed inside. Hence, |φ| = 0 and Case 0 applies. 2. φ is of the form φ 1 ∧ φ 2 , then individually deduce the simpler proofs for D φ 1 and D φ 2 by IH, which can be combined by P5. 3. φ is a disjunction and-without loss of generality-has one of the following forms (otherwise use associativity and commutativity to select a different order for the disjunction):</p><formula xml:id="formula_56">φ 1 ∨ [α]φ 2 φ 1 ∨ α φ 2</formula><p>As a unified notation for those cases we use φ </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B: Relative Semidecidability Proof</head><p>As an auxiliary result for proving Theorem 4, we show that, in dL proofs, Skolem symbols occur in a uniform way, i.e., a Skolem symbol s always occurs with the same list of arguments.</p><p>Lemma 9 (Uniform Skolem symbols) Let φ be a dL formula without Skolem symbols. In any derivation of φ, Skolem symbols only occur with a unique list of free logical variables as arguments, provided that the formulas in cuts (P10) obey this restriction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>The proof is by induction on the structure of proofs in the dL calculus. For derivations of length zero, the conjecture holds, because φ does not contain Skolem symbols. We show that the conjectured Skolem occurrence property is preserved in all sub-goals when applying a rule to a goal that satisfies the conjecture. F1 The symbols s(X 1 , . . . , X n ) introduced by rules F1-F2 are of the required form as the X i are precisely the free logical variables. In addition, the symbol s(X 1 , . . . , X n ) does not occur nested in other Skolem terms, because, by induction hypothesis, the bound variable x does not occur in Skolem terms of the goal. F3 Rules F3 and F6 are only applicable to instances of first-order real arithmetic (Lemma 2), for which the equivalence transformations of quantifier elimination preserve the Skolem occurrence property, because they never introduce quantifiers to bind free variables. D11 Rule D11 preserves the property, as it only substitutes state variables x i ∈ not logical variables X i ∈ V. P10 Cuts preserve the Skolem occurrence property, as we assumed the formulas that P10 introduces to adhere to the Skolem occurrence property. -The other rules of the dL calculus preserve the property as they never replace arguments of Skolem function symbols (which are free variables by induction hypothesis).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (of Theorem 4)</head><p>The proof is by well-founded induction. We prove that there is a well-founded strict partial order ≺ such that:</p><p>IH: For all non-atomic formulas occurring in the sequents during a proof, there is an applicable series of dL rules such that all resulting sub-goals are simpler with respect to ≺, have no additional free variables or function symbols, and their conjunction is equivalent to the conclusion (for suitable oracle choices).</p><p>By applying these dL rules exhaustively, we obtain a decision procedure relative to the oracle, because the sub-goals descend along the well-founded order ≺, which has no infinite descending chain. Finally, validity of the remaining sequents with atomic formulas is decidable by evaluating ground instances (Definition 7), because, by IH, the resulting formulas have no free variables when the initial formula is closed (open formulas, instead, yield equivalent parameter constraints as results). We use the derived rules G3' and G4' in place of G3 and G4, see Section 4.1. To obtain a backtracking-free procedure, we remove rules D5-D6 and G1-G4 and P10 from the calculus: If a calculus with less rules gives a decision procedure, then so does the full calculus.</p><p>We define the order ≺ as the lexicographical order of, respectively, the numbers of: loops, differential equations, sequential compositions, choices, modalities, quantifiers, number of different variables and Skolem function symbols, and the number of logical connectives. As a lexicographical order of natural numbers, ≺ is wellfounded <ref type="bibr" target="#b23">[22]</ref>. It lifts to sequents in rule applications (Definition 8) when all sub-goals of all rule schemata are simpler than their goals with respect to ≺, which can be shown to retain well-foundedness as a multiset ordering <ref type="bibr" target="#b23">[22]</ref>. Now the proof of IH is by induction along ≺. Let φ be a non-atomic formula of a sequent in an open branch of the proof. We assume φ to occur in the succedent; the respective proofs for the antecedent are dual. Hence, we consider the sequent to be of the form Γ φ, Δ.</p><p>1. If φ is of the form ψ 1 ∧ ψ 2 , then P6 is applicable, yielding smaller sequents (with less logical connectives) that are equivalent. Other logical connectives are handled likewise using P1-P7, respectively. 2. If φ is of the form [α]ψ or α ψ and α is of the form ?χ , β; γ , or β ∪ γ the corresponding rule D1-D4 or D7-D8 is applicable, yielding a simpler yet equivalent formula. 3. If φ is of the form [x 1 = θ 1 , . . . , x n = θ n &amp;χ]ψ, then D12 is applicable, as we assumed differential equations to have first-order definable flows. The resulting formula is equivalent and simpler, because it contains less differential equations. It involves additional bound variables but not free variables. Case x 1 = θ 1 , . . . , x n = θ n &amp;χ ψ is similar, by D11. 4. If φ is of the form [α * ]ψ, then G3' is applicable with a first-order invariant F obtained from the oracle. The resulting sub-goals are simpler according to ≺, because they contain less loops (F does not contain loops). The resulting subgoals do not have additional free variables as all bound variables of α * remain bound by the universal closure ∀ α in the respective premisses. Finally, we assume the oracle to give an invariant such that the conjunction of the resulting subgoals is equivalent to the goal (otherwise we have nothing to show for inadequate choices by the oracle). The case α * ψ is similar, using G4' instead.</p><p>5. If φ is of the form x 1 := θ 1 , . . . , x n := θ n ψ, there are two cases. If D9 is applicable, it yields equivalent simpler sequents. Otherwise, we have ψ ≺ x 1 := θ 1 , . . . , x n := θ n ψ. Thus, by IH, there is a finite sequence of rule applications on ψ yielding equivalent sequents with atomic formulas. Prefixing the resulting proof with x 1 := θ 1 , . . . , x n := θ n , yields a corresponding proof for Γ φ, Δ by Lemma 8. The formulas of its open branches resulting from φ are of the form x 1 := θ 1 , . . . , x n := θ n G for atomic formulas G, where, at the latest, D9 is applicable, as substitutions are admissible on atomic formulas. Case [x 1 := θ 1 , . . . , x n := θ n ]ψ is similar, using D10 first. 6. If φ is of the form ∀xψ(x), we can apply F1 giving ψ(s(X 1 , . . . , X n )). Now, we have ψ(s(X 1 , . . . , X n )) ≺ ∀xψ(x), hence, by IH, ψ(s(X 1 , . . . , X n )) can be transformed equivalently to a set of sequents of the form Φ i (s(X 1 , . . . , X n )) Ψ i (s(X 1 , . . . , X n )) with atomic formulas (without loss of generality, we can assume s(X 1 , . . . , X n ) to occur in all branches). Hence, QE is defined for these atomic formulas and F3 can be applied on each branch, yielding QE(∀s( i (s) Ψ i (s))). Consequently, the original sequent Γ ∀xψ(x), Δ is equivalent to i QE(∀s(Φ i (s) Ψ i (s))), for the following reason: Γ ψ(s(X 1 , . . . , X n ), Δ is equivalent to i (Φ i (s(X 1 , . . . , X n )) Ψ i (s(X 1 , . . . , X n ))) by IH, using the equivalence QE(∀s(F ∧ G)) ≡ QE(∀sF)∧ QE(∀sG) and that s does not occur in Γ, Δ. After applying F3, the result has no additional free symbols, although intermediate formulas do. 7. If φ is of the form ∃xψ(x), then F4 is applicable giving ψ(X) for a fresh logical variable X. Then ψ(X) ≺ ∃xψ(x), hence, by IH, ψ(X) can be transformed equivalently to a set of sequents Φ i Ψ i with atomic formulas. If no Skolem dependency on X occurs in Φ i Ψ i , then QE is defined and F6 applicable, giving QE(∃X( i (Φ i Ψ i ))), which is equivalent to ∃X( i (Φ i Ψ i )). By IH, this is equivalent to Γ ∃X ψ(X), Δ, because X does not occur in Γ, Δ. Otherwise, if a Skolem term s(X 1 , . . . , X, . . . , X n ) occurs in a Φ i Ψ i , then, by IH, the Skolem function s already occurred in ψ(X). By Lemma 9, s(X 1 , . . . , X, . . . , X n ) itself must already have occurred in ψ(X), which contradicts the fact that X is fresh and that bound variable x does not occur in Skolem terms of ∃x ψ(x), again by Lemma 9. After applying F6 the additional free variable X disappears.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Hybrid program rendition of hybrid automaton from Fig. 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2. 1</head><label>1</label><figDesc>Syntax of Differential Dynamic Logic</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3</head><label>3</label><figDesc>Fig. 3 Continuous flow along differential equation x = θ over time t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6</head><label>6</label><figDesc>Fig.<ref type="bibr" target="#b6">6</ref> Rule schemata of the free variable calculus for differential dynamic logic</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>1, a := a; β]φ More generally, x 1 := θ 1 , . . . , x n := θ n x 1 := ϑ 1 , . . . , x n := ϑ n φ can be merged by D9 to x 1 := ϑ 1 θ1 x1 . . . θn xn , . . . , x n := ϑ n θ1 x1 . . . θn xn φ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8</head><label>8</label><figDesc>Fig. 8 Deduction modulo with invertible quantifiers. a Wrong rearrangement attempt. b Correct reintroduction order</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Thus it only remains to show that f respects the constraints of Definition 5 for D. In fact, f obeys the continuity and differentiability properties of Definition 5 by the corresponding properties of the y i . Moreover,val I,η r ( f (ζ ), x i ) = val I,η r (ν, y i (t)) has a derivative of value val I,η r ( f (ζ ), θ i ), because y i is a solution of the differential equation x i = θ i with corresponding initial value ν(x i ). Further, it can be shown that the evolution invariant region χ is respected along f as follows: By premiss, I, η r , ν |= χ holds for the initial state ν, thus val I,η r ( f (ζ ), χ ) = true for all ζ ∈ [0, r].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Let I, η, ν |= α φ, i.e., let (ν, ν ) ∈ ρ I,η (α) with I, η, ν |= φ. As α can only change its bound variables, which are quantified universally in ∀ α , the premiss implies I, η, ν |= φ → ψ, hence I, η, ν |= ψ and I, η, ν |= α ψ. The proof of G1 is accordingly. G3 For any I, η, ν with I, η, ν |= ∀ α (φ → [α]φ), we conclude that I, η, ν |= φ → [α]φ for all ν with (ν, ν ) ∈ ρ I,η (α). As these share the same η, we can further conclude I, η, ν |= φ → [α * ]φ by induction along the series of states ν reached from ν by repeating α. The universal closure is necessary as, otherwise, the premiss may yield different η in different states ν . G4 Assume that the antecedent and premiss hold in I, η, ν. By premiss, we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Characterising Gödel encoding of R-sequences in one real number. a Fractional encoding principle by bit interleaving. b Definition of R-Gödel encoding in FOD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10</head><label>10</label><figDesc>Fig. 10 Explicit rendition of hybrid program transition semantics in FOD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 11</head><label>11</label><figDesc>Fig. 11 Invariant region checks along backwards flow over time t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. . , x n . Let further S t be the jump set x 1 := y 1 (t), . . . , x n := y n (t) . Assume that I, η, ν are such that the premiss is true: I, η, ν |= ∃t≥0 ( χ ∧ S t φ) with ∀0≤ t≤t S t χ abbreviated as χ. For any ζ ∈ R, we denote by η ζ the assignment that agrees with η except that it assigns ζ to t. Then, by assumption, there is a real value r ≥ 0 such that I, η</figDesc><table /><note><p><p><p>r , ν |= χ ∧ S t φ. Let D abbreviate x 1 = θ 1 , . . . , x n = θ n &amp;χ. We have to show that I, η, ν |= D φ. Equivalently, by Lemma 3, we show I, η r , ν |= D φ, because t is a fresh variable that does not occur in D or φ. Let function f : [0, r] → Sta( ) be defined such that</p>(ν, f (ζ )) ∈ ρ I,η ζ (S t ) for all ζ ∈ [0, r].</p>By premiss, f (0) is identical to ν and φ holds at f (r).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1.  If φ is of the form ϕ ∨ ψ, then by induction hypothesis there are FOD-formulas ϕ # , ψ # such that |= ϕ ↔ ϕ # and |= ψ ↔ ψ # , from which we can conclude by congruence that|= (ϕ ∨ ψ) ↔ (ϕ # ∨ ψ # ) giving |= φ ↔ φ # by choosing ϕ # ∨ ψ # for φ # .Likewise reasoning concludes the other propositional connectives or quantifiers. 2. The case where φ is of the form α ψ is a consequence of the characterisation of the semantics of hybrid programs in FOD. The expressibility conjecture holds by induction hypothesis using the equivalence of explicit hybrid program renditions from Lemma 5:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>With an application of G1, the latter derivation can be extended to a derivation of [β]G # D [β][γ ]G. Combining the above derivations propositionally by a cut with [β]G # , we can derive F D [β][γ ]G, from which D2 yields F D [β; γ ]G as desired (and Lemma 7 or P7 yield D</figDesc><table /><note><p><p>by IH. Using Lemma 8, we conclude</p>D ∀ β (G # → [γ ]G).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>F → φ and φ→ G are valid FOD-formulas, they are derivable by D; so is F D φ by Lemma 7. By Lemma 8 and G1, [β * ]φ D [β * ]G is derivable. Likewise, φ→ [β]φ is valid according to the semantics of repetition, thus derivable by IH, since β is less complex. Using Lemma 8, we can derive D ∀</figDesc><table /><note><p>β (φ → [β]φ), from which G3 yields φ D [β * ]φ. Combining the above derivations propositionally by a cut with [β * ]φ and φ yields F D [β * ]G. Proposition 2 (Relative completeness of first-order liveness) For each hybrid program α ∈ HP( , V) and each F, G ∈ Fml FOL ( , V) of first-order logic F→ α G implies D F → α G (and F D α G by Lemma 7) .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>1 ∨ [α] φ 2 . Then, |φ 2 | &lt; |φ|, since φ 2 has less modalities. Likewise, |φ 1 | &lt; |φ| because [α] φ 2 contributes one modality to |φ| that is not part of φ 1 . According to Lemma 6 there are equivalent FOD-formulas φ # 1 , φ # 2 with |= φ i ↔ φ # i for i = 1, 2. By congruence, the validity |= φ yields that |= φ # 1 ∨ [α] φ # 2 , which directly implies |= ¬φ # 1 → [α] φ # 2 . Then by Proposition 1 or 2, respectively, we can derive Further φ 1 ↔ φ # 1 implies ¬φ 1 → ¬φ # 1 , which is derivable by IH, because |φ 1 | &lt; |φ|. By Lemma 7, we obtain ¬φ 1 D ¬φ # 1 , which we combine with (6) by a cut with ¬φ # 1 to ¬φ 1 D [α] φ # 2 . (7) Likewise φ 2 ↔ φ # 2 implies φ # 2 → φ 2 , which is derivable by IH, as |φ 2 | &lt; |φ|. We can extend the derivation of D φ # 2 → φ 2 to one of D ∀ α (φ # 2 → φ 2 ) by Lemma 8 and conclude [α] φ # 2 D [α] φ 2 by G1-G2. Finally we combine the latter propositionally with (7) by a cut with [α] φ # 2 to derive ¬φ 1 D [α] φ 2 , from which D φ 1 ∨ [α] φ 2 can be obtained, again using P10, to complete the proof.</figDesc><table><row><cell>¬φ # 1 D [α] φ # 2 .</cell><cell>(6)</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements I am grateful to the anonymous referees for their most valuable and helpful comments. I also thank Ernst-Rüdiger Olderog and Andreas Schäfer for their proofreading remarks. This research was partially supported by a fellowship of the German Academic Exchange Service (DAAD) during a research visit at the Carnegie Mellon University (CMU) and by the German Research Council (DFG) as part of the Transregional Collaborative Research Center "Automatic Verification and Analysis of Complex Systems" (SFB/TR 14 AVACS).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A: Relative Completeness Proof</head><p>In this section, we present a fully constructive proof of Theorem 3, which generalises the techniques of Harel <ref type="bibr" target="#b35">[34,</ref><ref type="bibr" target="#b36">35]</ref> and Cook <ref type="bibr" target="#b17">[17]</ref> to the hybrid case. It shows that for every valid dL formula, there is a finite set of valid FOD-formulas from which it can be derived in the dL calculus. See the proof outline in Section 5.2 for a road map of the proof.</p><p>Natural numbers are definable in FOD by Theorem 2. In this section, we abbreviate quantifiers over natural numbers, e.g., ∀x(nat(x) → φ) by ∀x : N φ and ∃x by ∃x : N φ. Likewise, we abbreviate quantifiers over integers, e.g., ∀x(nat(x) ∨ nat(-x)) → φ by ∀x : Z φ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Characterising Real Gödel Encodings</head><p>As the central device for constructing a FOD formula that captures the effect of unboundedly many repetitive hybrid transitions and just uses finitely many real variables, we prove that a real version of Gödel encoding is definable in FOD. That is, we give a FOD formula that reversibly packs finite sequences of real values into a single real number.</p><p>Observe that a single differential equation system is not sufficient for defining these pairing functions as their solutions are differentiable, yet, as a consequence of Morayne's theorem <ref type="bibr" target="#b44">[43]</ref>, there is no differentiable surjection R → R 2 , nor to any part of R 2 of positive measure. We show that real sequences can be encoded nevertheless by chaining the effects of solutions of multiple differential equations and quantifiers.</p><p>Lemma 4 (R-Gödel encoding) The formula at(Z , n, j, z), which holds iff Z is a real number that represents a Gödel encoding of a sequence of n real numbers with real value z at position j (for a position j with 1 ≤ j ≤ n), is definable in FOD. For a formula φ(z) we abbreviate ∃z(at(Z , n, j, z) ∧ φ(z)) by φ(Z (n)  j ).</p><p>Proof The basic idea of the R-Gödel encoding is to interleave the bits of real numbers as depicted in Fig. <ref type="figure">9a</ref> (for a pairing of n = 2 numbers a and b ). For defin-</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Verification of hybrid systems: formalization and proof rules in PVS</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ábrahám-Mumm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hannemann</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICECCS.2001.930163</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>IEEE Computer Society</publisher>
			<biblScope unit="page" from="48" to="57" />
			<pubPlace>Los Alamitos</pubPlace>
		</imprint>
		<respStmt>
			<orgName>ICECCS</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Model-checking for real-time systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="414" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The algorithmic analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(94)00202-T</idno>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="34" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reach set computations using real quantifier elimination</title>
		<author>
			<persName><forename type="first">H</forename><surname>Anai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Weispfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HSCC, LNCS</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">D D</forename><surname>Benedetto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2034</biblScope>
			<biblScope unit="page" from="63" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Berlin</forename><surname>Springer</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-45351-2_9</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reachability analysis of nonlinear systems using conservative approximation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Asarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Girard</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-36580-X_5</idno>
	</analytic>
	<monogr>
		<title level="j">Proceedings</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2623</biblScope>
			<biblScope unit="page" from="20" to="35" />
			<date type="published" when="2003-04-03">2003. April 3-5, 2003. 2003</date>
			<publisher>Springer</publisher>
			<pubPlace>Prague, Czech Republic; Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Equality and other theories</title>
		<author>
			<persName><forename type="first">B</forename><surname>Beckert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Tableau Methods</title>
		<editor>
			<persName><forename type="first">M</forename><surname>D'agostino</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Hähnle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Posegga</surname></persName>
		</editor>
		<meeting><address><addrLine>Deventer</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<author>
			<persName><forename type="first">B</forename><surname>Beckert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hähnle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Verification of Object-Oriented Software: The KeY Approach</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Schmitt</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4334</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dynamic logic with non-rigid functions: a basis for object-oriented program verification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Beckert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAR, LNCS</title>
		<editor>
			<persName><forename type="first">U</forename><surname>Furbach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4130</biblScope>
			<biblScope unit="page" from="266" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Branicky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in hybrid systems: modeling, analysis, and control</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Universal computation and other capabilities of hybrid and continuous dynamical systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Branicky</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(94)00147-B</idno>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="100" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A unified framework for hybrid control: model and optimal control theory</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Branicky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Mitter</surname></persName>
		</author>
		<idno type="DOI">10.1109/9.654885</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Contr</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="45" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A formal description of hybrid systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Chaochen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Sontag</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1066</biblScope>
			<biblScope unit="page" from="511" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Computational techniques for hybrid system verification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chutinan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
		<idno type="DOI">10.1109/TAC.2002.806655</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Automat. Contr</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="75" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Abstraction and counterexample-guided refinement in model checking of hybrid systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Stursberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="583" to="604" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Peled</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Model Checking</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Partial cylindrical algebraic decomposition for quantifier elimination</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Comput</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="299" to="328" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Soundness and completeness of an axiom system for program verification</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
		<idno type="DOI">10.1137/0207005</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="90" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Verification of cooperating travel agents</title>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hungar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Olderog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Control</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="395" to="421" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automating verification of cooperation, control, and design in traffic applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mikschl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Oehlerking</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Olderog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Segelken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wirtz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Hybrid Real-Time Systems</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Woodcock</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4700</biblScope>
			<biblScope unit="page" from="115" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On hybrid systems and the modal μ-calculus</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Davoren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Antsaklis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Kohn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Lemmon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Sastry</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1567</biblScope>
			<biblScope unit="page" from="38" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Berlin</forename><surname>Springer</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-49163-5_3</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Logics for hybrid systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Davoren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</author>
		<idno type="DOI">10.1109/5.871305</idno>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="985" to="1010" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Proving termination with multiset orderings</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<idno type="DOI">10.1145/359138.359142</idno>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="465" to="476" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Theorem proving modulo</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dowek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hardin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="33" to="72" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Using branching time temporal logic to synthesize synchronization skeletons</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="241" to="266" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Sometimes&quot; and &quot;Not Never&quot; revisited: on branching versus linear time temporal logic</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="151" to="178" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">First-Order Logic and Automated Theorem Proving, 2nd edn</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fitting</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">First-Order Modal Logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fitting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Mendelsohn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Norwell</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Analysis of hybrid systems: an ounce of realism can save an infinity of states</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fränzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Flum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rodríguez-Artalejo</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1683</biblScope>
			<biblScope unit="page" from="126" to="140" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>CSL</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">PHAVer: algorithmic verification of hybrid systems past HyTech</title>
		<author>
			<persName><forename type="first">G</forename><surname>Frehse</surname></persName>
		</author>
		<idno type="DOI">10.1007/b106766</idno>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Morari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3414</biblScope>
			<biblScope unit="page" from="258" to="273" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>HSCC</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Incremental closure of free variable tableaux</title>
		<author>
			<persName><forename type="first">M</forename><surname>Giese</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-45744-5_46</idno>
	</analytic>
	<monogr>
		<title level="m">IJCAR, LNCS</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Goré</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Leitsch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2083</biblScope>
			<biblScope unit="page" from="545" to="560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gödel</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF01700692</idno>
	</analytic>
	<monogr>
		<title level="j">Mon.hefte Math. Phys</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="173" to="198" />
			<date type="published" when="1931">1931</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Computability with polynomial differential equations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Graça</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Campagnolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Buescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="330" to="349" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The liberalized δ-rule in free variable semantic tableaux</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hähnle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Schmitt</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF00881956</idno>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="221" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">First-Order Dynamic Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dynamic Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tiuryn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The theory of hybrid automata</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="278" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Symbolic model checking for real-time systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="394" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Deduction in the verification support environment (VSE)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Langenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sengler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Siekmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Stephan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wolpers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FME, LNCS</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Gaudel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Woodcock</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1051</biblScope>
			<biblScope unit="page" from="268" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">From CSP to hybrid systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Classical Mind: Essays in Honour of</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</editor>
		<meeting><address><addrLine>Hertfordshire</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="171" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Verification of clocked and hybrid systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<idno type="DOI">10.1007/s002360050177</idno>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="837" to="912" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A new class of decidable hybrid systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lafferriere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Van Schuppen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1569</biblScope>
			<biblScope unit="page" from="137" to="151" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>HSCC</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Deductive verification of hybrid systems using STeP</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sipma</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-64358-3_47</idno>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Sastry</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1386</biblScope>
			<biblScope unit="page" from="305" to="318" />
			<date type="published" when="1998">1998</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>HSCC</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">On differentiability of Peano type functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Morayne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Colloq. Math</title>
		<imprint>
			<biblScope unit="volume">LIII</biblScope>
			<biblScope unit="page" from="129" to="132" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Algorithmic algebraic model checking II: Decidability of semialgebraic model checking and its applications to systems biology</title>
		<author>
			<persName><forename type="first">V</forename><surname>Mysore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Piazza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mishra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Tsay</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3707</biblScope>
			<biblScope unit="page" from="217" to="233" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>ATVA</note>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Differential equations and dynamical systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Perko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Combining deduction and algebraic constraints for hybrid system analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Beckert</surname></persName>
		</editor>
		<meeting><address><addrLine>Bremen, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">259</biblScope>
			<biblScope unit="page" from="164" to="178" />
		</imprint>
	</monogr>
	<note>VERIFY&apos;07 at CADE</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Differential dynamic logic for verifying parametric hybrid systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Olivetti</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4548</biblScope>
			<biblScope unit="page" from="216" to="232" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>TABLEAUX</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A temporal dynamic logic for verifying hybrid system invariants</title>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LFCS, LNCS</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Artëmov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4514</biblScope>
			<biblScope unit="page" from="457" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">The image computation problem in hybrid systems model checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Platzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Bemporad</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Bicchi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Buttazzo</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4416</biblScope>
			<biblScope unit="page" from="473" to="486" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>HSCC</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The temporal logic of programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<meeting><address><addrLine>Piscataway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="46" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Semantical considerations on Floyd-Hoare logic</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Pratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<meeting><address><addrLine>Piscataway</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="109" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Hybrid action systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rönkkö</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">290</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="937" to="973" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Introduction to Topological Dynamics</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Sibirsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Noordhoff</title>
		<imprint>
			<date type="published" when="1975">1975</date>
			<pubPlace>Leyden</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">A Decision Method for Elementary Algebra and Geometry, 2nd edn</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tarski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1951">1951</date>
			<publisher>University of California Press</publisher>
			<pubPlace>Berkeley</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Differential automata and their discrete simulators</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tavernini</surname></persName>
		</author>
		<idno type="DOI">10.1016/0362-546X(87)90034-4</idno>
	</analytic>
	<monogr>
		<title level="j">Nonlinear Anal</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="665" to="683" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Cooperation of background reasoners in theory reasoning by residue sharing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tinelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="31" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Hybrid Systems: Computation and Control, 6th International Workshop</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-36580-X_37</idno>
	</analytic>
	<monogr>
		<title level="j">Proceedings</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2623</biblScope>
			<biblScope unit="page" from="514" to="525" />
			<date type="published" when="2003-04-03">2003. April 3-5, 2003. 2003</date>
			<publisher>Springer</publisher>
			<pubPlace>Prague, Czech Republic; Berlin</pubPlace>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Ordinary Differential Equations</title>
		<author>
			<persName><forename type="first">W</forename><surname>Walter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">An extended duration calculus for hybrid real-time systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Grossman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Nerode</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Rischel</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">736</biblScope>
			<biblScope unit="page" from="36" to="59" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
