<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">54F0BCA007ABBE9337143DF15539B5C6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>congruence within it is signicant or not. More study is needed regarding the issue.</p><p>One remarkable point is the similarity in a way of deriving canonical congruences over processes between our construction and those found in -calculi <ref type="bibr" target="#b7">[2,</ref><ref type="bibr" target="#b6">1,</ref><ref type="bibr" target="#b3">18]</ref>, as was already noted. What is common in these constructions is that the canonical equality is obtained as the maximum element of a sizable family of \meaningful" equalities. The method is not only mathematically elegant but also provides a tractable proof method (cf. development in 4.1). Mathematical canonicity may suggest correspondence with important models of the concerned formalism; at least such are cases in strict and lazy -theories, though concrete results in the concurrency setting are still missing.</p><p>Finally, noting that reduction-closed equalities roughly correspond to bisimilarities, it is natural to ask what formulation would correspond to e.g. may and must equivalences <ref type="bibr" target="#b10">[5]</ref>. We can use \saturated" insensitive terms i.e. the set fP j = 3 `P = 3g, possibly combined with divergence notion. To nd more direct ways of deriving such theories (i.e. without deriving = 3 rst) remains as an important open question.</p><p>5. 1. Results on other calculi. CCS <ref type="bibr" target="#b17">[12]</ref> is the process calculus based on dyadic synchronization as the basic communication primitive. The structural equivalence and reduction relation for the calculus naturally follow. One essential issue in constructing reduction theories for CCS is that the summation is problematic in weak congruent theories in general. However we restore weak bisimilarity in our purely equational setting by considering the maximum sound theory where congruence is understood in terms of reduction contexts (see <ref type="bibr">3.2)</ref>. Then the maximum sound theory, denoted by = 3 ccsn+ , coincides with via an observability theorem (cf. <ref type="bibr" target="#b1">[16]</ref>). Finally the sound maximum strong theory whose base is = 3 ccsn+ , coincides with the strong bisimilarity in <ref type="bibr" target="#b17">[12]</ref>.</p><p>Equational theories based on reduction are extensively studied in terms of -calculus <ref type="bibr" target="#b7">[2]</ref>. Specically -equality is subsumed in our reduction-closure property as noted, not to say many of our formal constructions are inspired by -theories. A natural question is: can we get any (interesting) observables following our framework based on reduction-closure? It seems that soundness does not directly leads to observability, regarding strongly unsolvable terms <ref type="bibr" target="#b2">[17,</ref><ref type="bibr" target="#b6">1]</ref> as the insensitive terms. However if we also add identication of PO 1 terms <ref type="bibr" target="#b2">[17,</ref><ref type="bibr" target="#b3">18]</ref>, then we obtain the canonical theory after picking up head normal forms as generic observables, which coincides with K 3 , the theory of D 1 .</p><p>Note, with this canonical theory, we have restored -equality, reinforcing our standpoint to regard -equality as a special case of the reduction-closure property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">2. Related work and open issues.</head><p>There are two important precursors to our work. Boudol <ref type="bibr" target="#b9">[4]</ref> studied (in)equation over essentially the same system as -calculus based on Morris-like contextual precongruence. Milner and Sangiorgi <ref type="bibr" target="#b1">[16]</ref> have shown that their construction called barbed congruence coincides with strong bisimilarity in the case of CCS, also referring to the results in the weak case. An apparent dierence is that we do not positively stipulate a presupposed notion of convergence to derive a canonical equality, as opposed to two precursors. In this sense, it may be safe to say that the present construction depends on less subjective semantic commitment. Nevertheless we note that our approach, a posteriori, reveals the import of so-called convergence predicate in <ref type="bibr" target="#b1">[16,</ref><ref type="bibr" target="#b9">4]</ref>, see e.g. Proposition 3.13, by discovering such a notion without stipulating it beforehand. It is yet to see to what range of formal systems the insensitivity-based approach is eective, and how such eectiveness is related to semantic aspects of given calculi. The result in 4.2 is suggestive in this aspect.</p><p>Another (and possibly more important) dierence from other approaches lies in our crucial usage of reduction-closure. While <ref type="bibr" target="#b1">[16]</ref> uses a closure property on reduction relation, the property is used rather as a \minimized bisimulation", together with the convergence notion, for a usual relation. Taking the union of all such relations, one takes the maximum congruence within it. In contrast, our formulation regards the closure property as the essential criteria for equality over stateful processes, just as -equality over -terms. While to take the maximum congruence within non-congruent equivalence is already known in the case of observation congruence in CCS <ref type="bibr" target="#b17">[12]</ref>, we would like to note that the situation in <ref type="bibr" target="#b1">[16]</ref> is quite dierent from <ref type="bibr" target="#b17">[12]</ref>; the base relation, , in <ref type="bibr" target="#b17">[12]</ref> is behaviourally sound while this may not be the case in barbed bisimilarity in <ref type="bibr" target="#b1">[16]</ref> (where a:0 and a:b:0 are equated), so that we cannot know, at least a priori, that taking the 4. 3. Strong theories. Reduction theories are essentially incepted in the \weak" semantic framework, since they do not care the number of reduction steps, less the termination. Notably we have = 3 in any sound theories. The following construction now tells us that we can easily \derive" strong theories out of them. In fact to any reduction theory a certain canonical strong theory corresponds to, and, as later to be seen, one such theory (derived from = 3 ) corresponds to a strong bisimilarity introduced in Section 2. The framework goes from the weak semantics to the strong semantics, which might be contrary to the usual practice: the idea here is to rst try to capture the meaning of each term in the abstract setting, then rene the induced equations by considering exact steps a term need to reach possible semantic points. Cost is measured after sense is made, so to speak.</p><p>The basic denition of strong theories follows. Remember a theory is a subtheory of another theory if its equations are included in the latter's. Definition 4. 8 Given a reduction theory =, we say its subtheory = 0 is a strong reduction theory with a base =, if, whenever = 0 `P = Q, P ! P 0 implies, for some Q 0 , Q ! Q 0 with = 0 `P0 = Q 0 .</p><p>Put in other words, = 0 is a strong reduction theory if and only if, whenever = 0 `P = Q, P ! n P 0 implies, for some Q 0 , Q ! n Q 0 with = 0 `P0 = Q 0 , for all n 2 !, where equations are only those allowed in its base. Thus a strong theory is derived from a base theory by \counting reduction steps". The following is important to get a (relatively) canonical strong theory from a base theory. The result is easy from Chain Lemma. Proposition 4. 9 Let = i be a strong theory whose base is = for all i 2 I. Then P f= i g i2I is also a strong theory with = as its base.</p><p>Hence, given a reduction theory =, there is always the maximum strong theory with a base =. We also note that if the base is a strong theory, its maximum strong theory is the base itself. We call the maximum strong theory with the base = 3 , = 3 :s . For the theory, we have: if = 3 :s `P = Q and P l 0! a P 0 with l relevant w.r.t. P and Q, then there exists Q 0 such that Q l 0! a Q 0 and P 0 a Q 0 (for establishment of the property, the reasoning on the number of reduction steps is crucial; see <ref type="bibr" target="#b14">[9]</ref>). Thus j= 3 :s j a . But j= 3 j a a , so that = a is a strong theory with a base = 3 , i.e. j= 3 :s j a . Therefore: Proposition 4. 10 j= 3 :s j = a .</p><p>It is easy to know that the strong theory corresponding to = a is again = a . This is because some dierences in weak theories depend on the use of additional reduction steps (e.g. equators): if these should be counted, the additional equations disappear.</p><p>Hence restoration of values in messages without the match operator in = 3 :s , leading to the coincidence of the \strong core" in two dierent weak theories. Finally we note that = s is easily obtained from = s : the reasoning parallels the case of = 3 :s . Proposition 4. 5 = a is a congruence relation <ref type="foot" target="#foot_0">7</ref> .</p><p>For equational theories, \P = Q ) [u = v]P = [u = v]Q" is added, and, using the incompatible pairs similar to those in Lemma 3.8, we can prove common isolation sets for the sound theories. This guarantees the existence of the maximum element, which we shall call = 3 = . Regarding this, an interesting observability result is known (see <ref type="bibr" target="#b14">[9]</ref>). Proposition 4. 6 Suppose = 3 = `P = Q. Then, with l relevant w.r.t. P and Q, when- ever P l 0! a P 0 ) Q l =) a Q 0 for some Q 0 with P 0 = a Q 0 .</p><p>The proposition tells us strict semantic dierence the operator induces in the calculus, as already suggested by Boudol <ref type="bibr" target="#b9">[4]</ref>. In our context, the operator provides the capability to discriminate two locations (or names), which results in inability to abstract locations. Now Proposition 4.6 tells us = a j= 3 = j. But = a j= 3 = j is easy using Proposition 4.5, so that one gets = a = j= 3 = j. Then, together with = a \(T 2 T ) = a , which is easy, we obtain the following.</p><p>Proposition 4. 7 (restoration of a ) Let = 3 = jT def = fP = Q j = 3 = `P = Q P; Q 2 T g+, i.e. the restriction of = 3 = to the original -terms. Then j= 3 = jT j = a .</p><p>To obtain s , we rst enrich the original -calculus with capability of output synchronisation, which makes the system essentially the -calculus in <ref type="bibr" target="#b19">[14]</ref>. We add uv:P to the grammar, where the original uv is embedded as uv:3. We also replace (COM) in Denition 2.1 with c I(@; uv:P; ux:Q; @ 0 ) ! c I(@; P; Qfv=xg; @ 0 ) and (REP) with c I(@; uv:P; !ux:Q; @ 0 ) ! c I(@; P; Qfv=xg; !ux:Q; @ 0 ). Then we easily obtain both input and output observables. However (and interestingly) we still cannot observe values in this framework, so that we again add the match operator, with which we nally restore s , by the same technical development as we have had for a . Thus the lattice of enrichment of operators results in the lattice of observables, hence of canonical equalities. The following picture depicts the situation. Below observables are listed on the left of the name of the system and the operators added to the base calculus are on the right (\ = " stands for the extension of the fragmentary -calculus with match). A dotted line shows (upward) inclusion in canonical equations. Note the picture arises uniformly from a single equational scheme: a deep study on operators and their semantic signicance in process calculi is called for.</p><p>To clarify the essential point, we construct a small -theory using this special agent.</p><p>Let us write P v1w $ Q for P fv=wg Qfv=wg, i.e. P and Q only dier in their (free) occurrences of v and w. We dene:</p><p>= EQ def = f(P; EQ(vw)) = (Q; EQ(vw)) jv; w; P; Q arbitrary as far as P v1w $ Qg + :</p><p>We can show that = EQ is reduction-closed and isolates a set fP j P ! ! "a g for each a. This shows that = 3 + = EQ is a sound theory, thus we have:</p><formula xml:id="formula_0">Proposition 4. 1 = EQ is a subtheory of = 3 .</formula><p>By the proposition, we know = 3 allows all the equations derivable in = EQ . Specically:</p><p>Corollary 4. 2 = 3 `(EQ(vw); uv) = (EQ(vw); uw).</p><p>This explains why we only had observables which are without values to carry in the observability theorem. Since = a 6 `(EQ(vw); uv) = (EQ(vw); uw), together with Proposition 3.7, we obtain:</p><formula xml:id="formula_1">Proposition 4. 3 = a is a proper subtheory of = 3 .</formula><p>As to the exact dierence between = a and = 3 , we believe the following holds. Conjecture 4. 4 = a + f(EQ(vw); uv) = (EQ(vw); uw)g axiomatises = 3 .</p><p>The task of proving (or disproving) the statement is left as a future exercise.</p><p>4. 2. Operators and observability. In this subsection we investigate whether there is any systematic way of regaining a and s by reduction-based formulation. The method provides an interesting correspondence between the basic operators in a given calculus, on the one hand, and induced canonical equations, on the other hand. The basic idea is to increase the power of agents to discern dierence in behaviour by introducing additional syntactic operators.</p><p>To obtain a , we use the match operator <ref type="bibr" target="#b18">[13]</ref>. It has the form \[u = v]", used as \[u = v]P", with a structural rule:</p><p>[u = u]P P Note that the operator directly compares two names, so that it might well annihilate the power of the equators. We call the system extended with the new syntactic construct and the structural rule, = . The new set of terms is denoted by T = , which is a superset of T . We use the same denitions for reduction and transition, written again as ! ! and l 0! a . The asynchronous weak bisimilarity in this setting is written = a . For this relation we have: Proposition 3. 11 Let = i be sound for each i 2 I. Then P f= i g i2I is also sound.</p><p>The existence of the maximum sound theory follows.</p><p>Proposition 3. 12 Let P = Q , def = `P = Q for some sound =. We dene: = 3 def = f(P = Q) j P = Qg+. Then = 3 is the maximum sound theory.</p><p>Note that, by the construction of sound theories, = 3 is maximal among the whole family of consistent reduction-closed theories. By j= G j 6 j= 3 j, we also know there is no maximum element among the family. We also note that insensitive terms are not isolated in = 3 , e.g. = 3 `I(a) = 3 (for the equation use j= 3 j a ), unlike unsolvable terms in the -theories. This is natural since all we wanted to do is to start from the smallest semantic commitment to get the broadest meaningful equality over processes.</p><p>The following proposition suggests an interesting relationship between our framework and the theory in <ref type="bibr" target="#b6">[1,</ref><ref type="bibr" target="#b3">18]</ref>. We use the convergence predicate in the asynchronous regime: P + , def 9a: P ! ! "a . Proposition 3. 13 (Behavioural characterization of = 3 ) We dene a family of relations f' i g i2! , as follows.</p><p>P ' 0 Q , def 8C:</p><formula xml:id="formula_2">C[P ] + , C[Q] + P ' k+1 Q , def 8C: (C[P ] ! ! P 0 ) 9Q 0 : C[Q] ! ! Q 0 ' k P 0 ) (C[Q] ! ! Q 0 ) 9P 0 : C[P ] ! ! P 0 ' k Q 0 ) P ' ! Q , def P ' i Q for all i 2 ! Then we have: P ' ! Q , = 3 `P = Q.</formula><p>The proposition tells us that the asynchronous convergence, together with the reductionclosure property, fully characterises the canonical theory. Note that the theory thus characterised is obtained without presupposing any specic convergence notion, not to say \+" above. Apart from this, what we have obtained is the theory in the line of applicative bisimulation in <ref type="bibr" target="#b6">[1]</ref>, but closed under all possible branching of multi-step reduction, thus incorporating the statefulness.</p><p>4 Reduction Theories and Bisimilarities 4. 1. = 3 and equators. In the following we try to explicate the equations by = 3 in its dierence from = a , a theory based on bisimilarity introduced in 2.2. As we noted in 3.2, = s and = a are both sound, therefore are subtheories of = 3 . The fact gives us a tractable way of equating terms in = 3 . Moreover = a is based on asynchronous observables, and includes = s in its equations (i.e. j= 3 j a ) s ). So a natural question is whether there are any pairs of terms not equated by = a but equated by = 3 . Actually such pairs exist, and, interestingly, the additional equations capture one of the essential aspects of name passing operation in the asynchronous regime. It is related with equators in 2.1: by a chain of equators, which continuously forward messages, we can abstract locations.</p><p>We now formulate a notion of \generic observable" intrinsic in sound theories, by a simple transition system. c I(@; ab; @ 0 ) "a c I(@; @ 0 ) (a 6 2 fcg)</p><formula xml:id="formula_3">P P 0 P "a Q Q Q 0 P 0 "a Q 0</formula><p>Note the transition is only concerned with the output messages, and, as such, only their targets, not values. Based on the transition relation, we have one of the most essential results in the present paper. Theorem 3. 9 (Observability) Let = be a sound -theory and = `P = Q. Then P "a P 0 ) Q ! ! "a ! ! Q 0 for some Q 0 with = `P0 = Q 0 : Proof. First suppose = `P = Q for some sound theory =. We show if P "a P 0 then there should be some Q 0 such that Q ! ! "a ! ! Q 0 with = `P0 = Q 0 , as far as = is sound. Now take a context C[ ] def = (a: c; c:3; [ ]) with c fresh. Then easily C[P ] ! ( c; c:3; P 0 ) ! P 0 . Since = is reduction-closed, we should have, for some Q 00 , C[Q] ! ! Q 00 such that = `P0 = Q 00 . Now we show Q ! ! "a ! ! Q 00 . This is established by showing that Q 00 cannot contain a term c:3.</p><p>But suppose c:3 is in Q 00 . Then let b be such that f bg FN(P) [ FN(Q) and c 6 2 f bg. Since P 0 = Q 00 we have b IP 0 = b IQ 00 . But since Q 00 contains c:3 it either contains c or a: c concurrently composed with c:3 (note c:3 and c as originally contained in C[Q] can only interact with each other so c cannot occur anywhere other than these terms during reduction). Hence b IQ 00 = c:3 if a: c never interacts or, with some Q 000 , b IQ 00 ! ! b IQ 000 where b IQ 000 = (c:3; c). But from Lemma 3.8 this is contradiction, hence c:3 can not be in Q 00 . But if c:3 is not in Q 00 then there should be interaction between a: c and a term in Q so that we have Q ! ! "a ! ! Q 00 as required.</p><p>In the above proof, note how equation of two terms with discrepant behaviour results in inconsistency via the reduction-closure property and identication of insensitive terms. Thus soundness \generates sense" in equations. We also note that the result, which neglects input observable and values to carry, is basically the maximum observability we can derive from the soundness condition, see 4.1 and 4.2.</p><p>3. 4. The maximal theory. The essential technical consequence of observability is the existence of isolation sets. Let T be a proper subset of T . Then we say a theory = isolates T, or T is an isolation set in =, if = `P = Q and P 2 T then Q 2 T. Using Chain Lemma we easily obtain: Lemma 3. 10 (Isolation Lemma) Let = 0 be P f= i g i2I , a sum of a family of -theories.</p><p>Then if = i isolates T for all i 2 I, then = 0 also isolates T.</p><p>But Theorem 3.9 tells us a sound theory isolates a set fP j P ! ! "a g for each a, and isolation of some non-empty set implies that the theory is consistent. Hence we get: The proposition says that if an insensitive term is put in a reduction context, whatever reduction takes place in the conguration, we can collect no evidence that the term in a hole has participated in the change of the conguration at all. Remark that the characterization is given solely in terms of reduction relation and contextual closure, thus telling us the behavioural insignicance of insensitive terms independently of any \observational commitment".</p><p>The fundamental mechanism we are going to introduce into our equational construction is the identication of insensitive terms in reduction-closed -theories. Proposition 3.6 provides a good reason for the identication. Let us call consistent reduction theories which equate any two insensitive terms, sound. Among sound -theories one nds: Proposition 3. 7 = s and = a are both sound.</p><p>In contrast, = s and = a are not sound, though they are obviously reduction-closed (cf.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">later).</head><p>3. 3. Intrinsic observables. An essential fact about sound -theories is that sound -theories are, a posteriori, automatically equipped with observables. The induced observables are behaviourally signicant, and, as studied in depth in the next section, they well reect important aspects of operations of the calculus. The obtained observables in turn bring about a certain canonical -theory as we shall see soon.</p><p>Let a pair of terms be incompatible, written P == = Q, if for any sound =, = 6 `P = Q.</p><p>Some such pairs become useful in deriving observability. where G def = g I gg. Note that, since G is an utterly inactive term, an agent (P; G) behaves just like P in any context. Hence the fact that = G equates (P; G) and (Q; G) for any P and Q implies that the theory absurdly identify any two behaviour solely because both contain G. At the same time, the theory can be easily shown to be reduction-closed, and consistency is immediate. There are innitely many such theories.</p><p>Thus the reduction-closure property falls short of imposing satisfactory constraint on -theories, both mathematically and intuitively. What further condition should we impose on -theories, which should be as semantically neutral as possible and be faithful to reduction-based construction? Here we take the idea inspired by the equational scheme of sensible -theories, where identication of meaningless (unsolvable) terms internally lters o \unsound" equations, just because they would lead to inconsistency <ref type="bibr" target="#b7">[2]</ref>. A similar equational scheme is found to be eective in the lazy -calculus, see <ref type="bibr" target="#b6">[1,</ref><ref type="bibr" target="#b3">18]</ref>. Meaninglessness in our context, however, cannot be given by such notions as unsolvability or strong unsolvability which are specic to -calculi, but should be given in the way applicable to concurrency formalisms in general. The notion we introduce for the purpose is called insensitivity. Definition 3. 4 A closed term P is insensitive i, for all P 0 such that P ! ! P 0 , we have AN (P 0 ) = ;. An open term is insensitive i it is insensitive after any closing substitution. The set of insensitive terms is denoted by Ins .</p><p>Paraphrasing, an agent is insensitive if its subterm never participates in reduction with the outside (i.e. never becomes a part of a redex whose pair lies outside of the agent). It is easy to prove that Ins is closed under structural rules, multi-step reduction, and name substitution. Some examples of (non-)insensitive terms follow. The next proposition formally tells us that insensitive terms actually \do nothing." Let the set of reduction contexts<ref type="foot" target="#foot_2">6</ref> be given by: C r [ ] ::= [ ] j a IC r [ ] j (C r [ ]; P ) j (P; C r [ ]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We let C r [ ], C 0</head><p>r [ ], .. range over the set of contexts. Then we dene a generic reduction of a context as:</p><formula xml:id="formula_4">C r ! ! C 0 r , def 8P: C r [P ] ! ! C 0 r [P ]. When C r ! ! C 0</formula><p>r (which reads C r generically reduces to C 0 r ), the former context can reduce to the latter without any participation of the term in a hole. Using the idea we have: them by = s , = a , = s , and = a . Note we have j= s j = s (by s and congruence of s ) and similarly for other theories.</p><p>3 Basic Constructions 3. 1. Reduction closure property. The notion of states is essential in concurrency. A term may change its meaning during its reduction so that \equality" in this setting means that two equated terms can go to an equated state again. That is, if two terms are ever equated and one reduces to any term, then another should be able to reduce to an equated term again. What we want here is that the notion of equation is in harmony with the notion of reduction relation. The following formalises the idea 5 . Definition 3. 1 A -theory = is reduction-closed, if, whenever = `P = Q, P ! ! P 0 implies, for some Q 0 , Q ! ! Q 0 and = `P0 = Q 0 . Note if we have -equality, i.e. P ! ! P 0 ) P = P 0 , the closure property is satised vacuously: thus the property generalises -equality into the stateful regime (the usage of ! ! instead of ! is essential in this aspect; think of II = I with I def = x:x). Also note that, by Denition 3.1, = is reduction-closed if and only if, whenever = `P = Q, C[P ] ! ! P 0 implies, for some Q 0 , C[Q] ! ! Q 0 with = `P0 = Q 0 , where C[ ] is an arbitrary context. This makes one orientation of the above denition explicit, i.e. an aspect as a test on the internal consistency of an equational theory under arbitrary contexts, considering state changes during reduction. We shall often call reduction-closed -theories simply reduction theories.</p><p>Before stating one important property of reduction theories, we need a small but useful lemma. Lemma 3. 2 (Chain Lemma) Let = 0 be P f= i g i2I , a sum of a family of -theories and = 0 `P = Q. Then we have a chain of equations: = j0 `P = R 0 ; ::; = jk `Rk01 = R k ; :::; = j n `Rn01 = Q for some j i 2 I, 0 i n.</p><p>Using the lemma we get: Proposition 3. 3 Let = i be reduction-closed for all i 2 I. Then P f= i g i2I is also reduction-closed.</p><p>Note the proposition does not imply existence of the maximum consistent reductionclosed equality, since P f= i g i2I above can be inconsistent. In fact one unpleasant fact is that there is no maximum element in the family of consistent reduction-closed -theories (see 3.4). Moreover, though the reduction closure is intended to be the basic criteria for internal consistency of -theories, equations in some reduction theories are pathological even if they are consistent. One of examples is = G def = f(P; G) = (Q; G) j P; Q 2 T g+ 5 The closure property has a subtle yet crucial dierence from a seemingly similar notion in <ref type="bibr" target="#b1">[16,</ref><ref type="bibr" target="#b0">15]</ref> by Milner and Sangiorgi. See 5.2 for discussions.</p><p>We note that a dierentiating pair for the strong case is e.g. h(I(a); ) ; i, and for weak case, hI(a) ; 3i. Remark that reduction of I(a) in 2.1 shows I(a) does not give any eect to outside, though in fact it engages in interaction.</p><p>Finally an important remark is that we cannot decide which of these two paradigms of observation is more \basic" to the calculus as far as we rely on labelled transition relation or related notions. While this suggests an essential merit of the notion of observables, i.e. applicability to varied purposes, for canonical treatment of computational formalisms, some universal construction is called for. Note also that the notion of convergence as employed in <ref type="bibr" target="#b9">[4,</ref><ref type="bibr" target="#b1">16]</ref> cannot be the answer since we get dierent equivalences according to whether we take \asynchronous convergence" (where we only take output into account) or \synchronous convergence" (where we take both input and output into account). This is not what we can decide within the convergence-based semantic framework. These considerations motivate the construction in the subsequent sections.</p><p>2. 3. -theories. Equation among -terms is the central topic in the next two sections. While to directly deal with congruence relations among terms is possible, to treat equations as generated by a formal theory, is often convenient. Definition 2. 3 A -theory, or simply a theory, is a formal theory, their formulae of the form P = Q, with at least the following axioms and rules.</p><formula xml:id="formula_5">1. P = Q when P Q 4. P = Q ) P; R = Q; R 7. P = Q ) ux:P = ux:Q 2. P = Q ) Q = P 5. P = Q ) R; P = R; Q 8. P = Q ) !ux:P =!ux:Q 3. P = Q; Q = R ) P = R 6. P = Q ) c IP = c IQ 9. P = Q ) P fv=xg = Qfv=xg</formula><p>Rule 9 conveys the meaning of name variables. Some notations:</p><p>(i) =, = 0 .. range over -theories. The -theory with no additional axioms and rules is denoted = . (ii) If P = Q is provable in = then we write = `P = Q, or simply P = Q when the concerned theory is obvious from the context.</p><p>(iii) Given a set of equations E, E + = is the result of adding equations as axioms to =. E+ denotes E + = . = + = 0 is a result of adding the set of equations from two theories as axioms to the above rules <ref type="foot" target="#foot_3">4</ref> . We extend this to an arbitrary family of -theories, writing P f= i g i2I , I being an index set.</p><p>(iv) The relation induced by a theory = is denoted by j=j. Given a family oftheories, the maximum (resp. minimum) theories are those whose corresponding relations are the maximum (resp. minimum) in that family. We say a -theory = is a subtheory of another theory = 0 if j=j j= 0 j. If the inclusion is strict then the former is a proper subtheory of the latter. (v) We say a theory is consistent if it does not equate all possible pairs of terms. A theory is inconsistent if it is not consistent. Given the above denition, we can form theories corresponding to bisimilarities presented already, by adding equations from each bisimilarity to the minimum theory. We denote 2. 2. Labelled transitions and bisimilarities. Let l; l 0 ; :: range over labels given by: l = j #ab j "ab j "a(b) where \(b)" is the only bound occurrence. We write BN(l) and FN(l) for the sets of bound and free names in l. One important notion concerning labels is relevance: a label l is relevant to a pair of terms P and Q if BN(l) \ (FN (P ) [ FN(Q)) = ;. Now we give rules which induce transition relations over closed -terms each of which represents a particular notions of observation. In the following, we assume a; b 6 2 fcg in IN and OUT f , a 6 2 fcg ^b 2 fcg in OUT b , and each term as a whole is closed.</p><p>?INs: c I(@; ax:P; @ 0 ) #ab 0! c I(@; P fb=xg; @ 0 ) OUTb: c I(@; ab; @ 0 ) "a(b) 0! cnb I(@; @ 0 ) ? ? INa: c I(@; @ 0 ) #ab 0! c I(@; ab; @ 0 ) OUTf : c I(@; ab; @ 0 ) "ab 0! c I(@; @ 0 ) COM: c I(@; ax:P; ab; @ 0 ) 0! c I(@; P fb=xg; @ 0 ) STR: P 0 P; P l 0! Q; QQ 0 P 0 l 0! Q 0 ?IN 0 s : c I(@;!ax:P; @ 0 ) #ab 0! c I(@; !ax:P; P fb=xg; @ 0 ) REP: c I(@;!ax:P; ab; @ 0 ) 0! c I(@; !ax:P; P fb=xg; @ 0 )</p><p>Out of eight rules ve without marks are common to both transition relations, while two with ? are for synchronous transition, and one with ?? is for asynchronous transition. Intuitively IN s and IN 0 s rules assume the synchronization is essential in observation, while IN a assumes just asynchronous exchanges of messages suces. Two dierent transition relations are denoted by l 0! s (the synchronous case) and l 0! a (the asynchronous case).</p><p>Note in both cases transition coincides with one-step reduction. We also dene transition which ignores actions. l =) s (resp. l =) a ) stands for ! ! if l = , else for ! ! l 0! s ! ! (resp. ! ! l 0! a ! !). Note if P is closed then P l 0! P 0 implies P 0 is again closed.</p><p>Then synchronous strong (resp. weak) bisimulation is any symmetric relation over closed -terms, say R, such that, if P R Q, whenever P l 0! s P 0 with l relevant w.r.t.</p><p>P and Q, there exists Q 0 such that Q l 0! s Q 0 (resp. P l =) s Q) and P 0 R Q 0 . Some conventions: ab IP denotes a I(b IP ); \;" is the weakest in association, e.g. a IP; Q def = (a IP); Q, and associates to the left; we write c and c:P to mean we do not care the value to be communicated.</p><p>Reduction relation provides the basic notion of computing in the formalism. To formulate reduction we rst stipulate a set of structural rules following Milner <ref type="bibr" target="#b19">[14]</ref> (cf. <ref type="bibr" target="#b8">[3]</ref>). We dene to be the smallest congruence relation over -terms generated by the following rules.</p><p>(i) P Q if P Q (ii) P; Q Q; P (P; Q); R P; (Q; R) P; 3 P (iii) aa IP a IP ab IP ba IP a I3 3 a IP; Q a I(P; Q) if a 6 2 FN(Q).</p><p>Let @; @ 0 ; : : : range over a sequence of concurrent composition of terms of the forms uv, ux:P and !ux:P . The following simple denition of reduction relation relies on the fact that any P can be transformed to a form c I(@) using . Definition 2. 1 (Reduction relation) (i) One-step reduction, denoted by !, is the smallest relation over terms generated by the following rules.</p><p>COM: c I(@; ux:P; uv; @ 0 ) ! c I(@; P fv=xg;@ 0 ) REP: c I(@; !ux:P; uv; @ 0 ) ! cI(@; !ux:P; P fv=xg; @ 0 ) STR:</p><p>P 0 P; P ! Q; QQ 0 P 0 ! Q 0 (ii) Multi step reduction ! ! is dened: ! ! def = ! 3 [ . We call the pair of \ uv; ux:P " or \ uv; !ux:P ", a redex, and each term in one redex is called another's redex pair. Below we give some examples of reduction, along with several important expressions.</p><p>(i) Let P 8 Q def = c I( c; c:P; c:Q) with c fresh. Then: P 8 Q ! (P; c Ic:Q) and P 8 Q ! (Q; c Ic:P ). Note c Ic:Q never reduces nor interacts. (ii) Let FW(ab) def = ay: by. Then: FW(ab); ac ! bc. FW(ab) is called a forwarder.</p><p>(iii) Let EQ(ab) def = (!FW(ab); !FW(ba)). Then: EQ(ab); ac ! EQ(ab); bc ! EQ(ab); ac ! ::. EQ(ab) is called an equator. Note EQ(ab) EQ(ba). (iv) Let I(a) def = !FW(aa). Then: I(a); ac ! I(a); ac ! : : : . I(a) is called an identity receptor.</p><p>(v) Let def = o I(I(o); oo). Then: ! ! ! : : : . theories without committing ourselves to a specic notion of observation | we even do not employ convergence predicate in <ref type="bibr" target="#b1">[16,</ref><ref type="bibr" target="#b9">4]</ref>, which is considered to be the \minimised observability" in <ref type="bibr" target="#b1">[16]</ref>. Such development is important when it is dicult to identify a canonical notion of observation in given formalisms and programming languages (e.g. <ref type="bibr" target="#b16">[11,</ref><ref type="bibr" target="#b5">20,</ref><ref type="bibr" target="#b18">13,</ref><ref type="bibr" target="#b13">8]</ref>). A signicant example is -calculus <ref type="bibr" target="#b13">[8,</ref><ref type="bibr" target="#b12">7,</ref><ref type="bibr" target="#b15">10]</ref>, an ospring from -calculus <ref type="bibr" target="#b18">[13]</ref>, where we have two \natural" notions of observation which induce quite dierent transition relations and bisimilarities, as detailed in Section 2. Semantics for this small calculus is taken as the main object of study in the present exposition, showing that a behaviourally signicant equality over agents is obtained in the reduction-based framework. Results on other calculi are also mentioned at the end.</p><p>The structure of the paper follows. Section 2 gives a brief introduction to -calculus as far as necessary in the present paper. Section 3 develops basic construction of reductionbased equality for -calculus. Section 4 further studies the reduction-based equational construction for -calculus, restoring usual weak and strong bisimilarities in a purely reduction-based framework. Section 5 mentions results on other calculi, gives comparison with related work, and points out further issues.</p><p>Most of proofs are omitted, for which the reader would refer to <ref type="bibr" target="#b14">[9]</ref>.</p><p>2 -calculus 2. 1. Terms and reduction. -calculus, an ospring from -calculus <ref type="bibr" target="#b11">[6,</ref><ref type="bibr" target="#b18">13,</ref><ref type="bibr" target="#b19">14]</ref>, is a small formalism of concurrency with the notion of asynchronous name passing as the interaction primitive [8, 7, 10] (cf. <ref type="bibr" target="#b9">[4]</ref>). The simple primitive, coupled with capability to generate new names, gives -calculus enough power to construct versatile structures of interaction <ref type="bibr" target="#b13">[8,</ref><ref type="bibr" target="#b15">10]</ref>. Below we introduce basic notions of the calculus as far as needed in the present exposition.</p><p>Let N and V be countable sets of names and (name) variables<ref type="foot" target="#foot_5">2</ref> , ranged over by a; b; c; :: and by x; y; z; ::, respectively. u; v; w; :: range over their union, the set of identiers. The set of -terms T , ranged over by P; Q; :::, is given by the following grammar. P ::= uv j ux:P j P; Q j a IP j !ux:P j 3 Among terms, \ uv" denotes a message to a target u carrying a value v, while \ux:P " denotes a receptor which receives a message at u and instantiates the value in P . In ux:P , x binds free occurrences of x in P (just like x:M). \P; Q" is a concurrent composition of P and Q. \a IP " is a scope restriction where the initial a binds its free occurrences in P. !ux:P is a lazy replicator which replicates its body each time it interacts, where x is a binding occurrence. \3" is a syntactic convention to denote nothing. Free (resp. bound) names in P is denoted by FN(P) (resp. BN(P)). Free (resp. bound) variables in P is denoted by FV(P) (resp. BV(P)). We also assume the usual notion of (multiple) substitution, written fṽ=ũg where ũ and ṽ are strings of identiers (names or variables) with the same length and all identiers in ũ are distinct. ; 0 etc. range over substitutions. denotes -conversion. Closed and open terms are dened as usual (with respect to name variables). Thus ab and ax: xb are closed but yc and</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Proposition 3 . 6 (</head><label>36</label><figDesc>Characterization of insensitivity) 8P 2 Ins : C r [P ] ! ! R ) R C 0 r [P 0 ] ^Cr ! ! C 0 r ^P ! ! P 0 ^P0 2 Ins :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>rst we show = ` c = 3 ) = ` c 0 = 3 for any c 0 with = sound. Take a context: C[ ] def = c I(c: c 0 ; [ ]; 3) with c 0 6 = c. Then C[3] = 3 while C[ c] ! c I( c 0 ; 3) = ( c 0 ; c I3) = c 0 . Since c 0 6 ! we have c 0 = 3 for arbitrary c 0 , as required. Next we show c == = 3 for arbitrary c. Suppose = ` c = 3 in some sound theory. Let us be given any P 2 T . Then we can always nd some c 0 such that c 0 6 2 FN(P) (since FN(P) is always nite), and with this c 0 we construct a context C[ ] def = c 0 I([ ]; c 0 :P ). By assumption and the result above, we have c 0 = 3. Hence we should have C[3] = C[ c 0 ]. But C[ c 0 ] ! c 0 IP = c 0 I(P; 3) = (P; c 0 I3) = P while C[3] = 3 hence P = 3 for an arbitrary P , contradiction. Hence c == = 3. To prove c:3 == = 3, take C[ ] def = ([ ]; c) and reason similarly. For ( c; c:3) == = 3, take C[ ] def = c I(c: e; [ ]) with e fresh. Other notable incompatible pairs are ( a; b) 8 ( a; c) == = ( a; ( b8 c)), and ( a == = b) if a 6 = b. The former example tells us how sound theories are near to the usual (weak) bisimulation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 3 .</head><label>3</label><figDesc>5 3  and are insensitive, but neither ab, c I( ce; cx: be) nor I(a) are insensitive.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>). For open terms, we let P s Q with P or Q open when P s Q for any closing substitution , and similarly for other bisimilarities. , s , a and a are congruence relations 3 .(ii) s is a proper subset of a , and s is a proper subset of a .ax: cz are open. Then, for an open term P , from variables to names, is a closing substitution i FV(P) = ;.</figDesc><table><row><cell>The maximum relation among such relations exists and is called synchronous strong (resp. weak) bisimilarity, s (resp. s ). By changing l 0! s into l 0! a and l =) s into l =) a , one gets asynchronous strong (resp. weak) bisimulation and asynchronous strong (resp. weak) bisimilarity, written a (resp. Some properties of bisimilarities follow.</cell></row><row><cell>Proposition 2. 2</cell></row><row><cell>(i)</cell></row></table><note><p>a s</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_0"><p>This is mainly due to our proviso for bisimilarity over open terms in 2.2, cf.<ref type="bibr" target="#b18">[13]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>2. Insensitivity and sound theories. Insensitive terms are those which never interact with their enclosing contexts. The notion is intended to give a sucient condition for operational insignicance of a term in the weak regime. Below let AN(P) be dened as: AN( ab) = AN (ax:P) = AN(!ax:P) = fag, AN(a IP ) = AN(P)nfag, AN(P; Q) = AN(P) [ AN(Q), and AN (3) = ;.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>We can use ordinary contexts but the reduction-contexts make the formulation simpler without losing generality.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Essentially the sum is the congruent closure of the union of congruences (or the lub in the lattice of congruences).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_4"><p>As a consequence of introduction of name variables, we require a congruence over T , say =, should satisfy: P = Q ) P fv=xg = Qfv=xg for any v and x.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_5"><p>For discussions on variables for names, see<ref type="bibr" target="#b14">[9]</ref>.On Reduction-Based Process Semantics ?</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements.</head><p>We thank Professors Cli Jones and Robin Milner for fruitful discussions. We also thank anonymous referees and friends for providing valuable comments and pointing out errors. Our gratitude to Professor Mario Tokoro for his encouragement and support. The rst author is partially supported by JSPS Fellowships for Japanese Junior Scientists.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kohei Honda Nobuko Yoshida</head><p>Department of Computer Science, Keio University 3-14-1 Hiyoshi, Kohoku-ku, Yokohama, 223, Japan Abstract. A formulation of semantic theories for processes which is based on reduction relation and equational reasoning is studied. The new construction can induce meaningful theories for processes, both in strong and weak settings. The resulting theories in many cases coincide with, and sometimes generalise, observation-based formulation of behavioural equivalence. The basic construction of reduction-based theories is studied, taking a simple name passing calculus called -calculus as an example. Results on other calculi are also briey discussed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The aim of the present paper is to investigate a general formulation of process semantics which can induce canonical congruence over agents solely based on reduction relation and equational reasoning. Our starting point is the formulation of operational semantics for processes based on reduction relation and structural rules, introduced by Berry and Boudol <ref type="bibr" target="#b8">[3]</ref> and Milner <ref type="bibr" target="#b19">[14]</ref>. By regarding structural rules as the embedded algebra for processes (cf. -equality), we can view reduction relation as representing the basic mechanism of computation in a given formalism. Especially in the area of higher-order process calculi <ref type="bibr" target="#b18">[13,</ref><ref type="bibr" target="#b19">14,</ref><ref type="bibr" target="#b0">15,</ref><ref type="bibr" target="#b13">8]</ref>, it was found that the reduction-based formulation enjoys much more simplicity than the transition-based one. It remains open, however, whether we can have a general framework to derive meaningful process equivalences from the new construction, which are as signicant as well-known behavioural equivalences over agents e.g. bisimilarities <ref type="bibr" target="#b4">[19,</ref><ref type="bibr" target="#b17">12]</ref>.</p><p>What we are going to show in the subsequent sections, is that a general framework to derive signicant congruences over processes from the new construction in a mathematically elegant way, does exist. While works with the aim similar to ours appeared already <ref type="bibr" target="#b1">[16,</ref><ref type="bibr" target="#b9">4]</ref>, our construction has several signicant aspects not found in those precursors. Firstly, the basic formal apparatus is an extension of the well-studied method in both strict and lazy -theories <ref type="bibr" target="#b7">[2,</ref><ref type="bibr" target="#b6">1,</ref><ref type="bibr" target="#b3">18]</ref>, using the maximality condition among a certain family of congruences to derive canonical equality over agents. Specically a fundamental element of the construction is reduction-closure for equality, which generalises -equality into the stateful regime of concurrent processes. The congruence relations over processes obtained by the method turn out to be behaviourally signicant in varied process calculi, attaining intuitively sound notions of equality over agents. Secondly, one methodological appeal of the construction in the present paper is that we obtain those canonical ? Appeared in Proc. of 13th Conference on Foundations of Software Technology and Theoretical Computer Science, LNCS 761, pp.371{387, Springer-Verlag, 1993.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Polyadic -Calculus: a tutorial. Logic and Algebra of Specication</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Barbed Bisimulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICALP&apos;92</title>
		<meeting>of ICALP&apos;92</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">623</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Set Theoretical Models of Lambda Calculus: Theory, Expansions and Isomorphisms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Longo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="153" to="188" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The Lazy Lambda Calculus: An Investigation into the Foundation of Functional Programming</title>
		<author>
			<persName><forename type="first">C-H</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Imperial College</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Phd thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Concurrency and Automata on Innite Sequences</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">104</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A calculus of higher order communicating systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Thomsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th. Annual Symposium on Principles of Programming Languages</title>
		<meeting>16th. Annual Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Lazy Lambda Calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research topics in Functional Programming</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Turner</surname></persName>
		</editor>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The Lambda Calculus: Its Syntax and Semantics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barendregt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>North Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Chemical Abstract Machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th. Annual Symposium on Principles of Programming Languages</title>
		<meeting>17th. Annual Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Asynchrony and -calculus</title>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
		<idno>1702</idno>
	</analytic>
	<monogr>
		<title level="j">INRIA</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<pubPlace>Sophia Antipolis</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">INRIA Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Testing equivalences for processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A Calculus of Communicating Systems with Label Passing</title>
		<author>
			<persName><forename type="first">U</forename><surname>Engberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nielsen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
		<respStmt>
			<orgName>University of Aarhus</orgName>
		</respStmt>
	</monogr>
	<note>Research Report DAIMI PB-208</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Two bisimilarities in -calculus</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note>submitted. Also as Keio CS report 92-002</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An Object Calculus for Asynchronous Communication</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tokoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECOOP&apos;91</title>
		<title level="s">LNCS</title>
		<meeting>ECOOP&apos;91</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">512</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Reduction-based Process Semantics</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-10">October 1992</date>
		</imprint>
	</monogr>
	<note>to appear as a Keio CS technical report. A preliminary version as Keio CS technical report 92-003</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Combinatory Representation of Mobile Processes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21th. Annual Symposium on Principles of Programming Languages</title>
		<meeting>21th. Annual Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A pi-calculus Semantics for an Object-Based Design Notation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CONCUR &apos;93</title>
		<meeting>CONCUR &apos;93</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">715</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Calculus of Communicating Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<date type="published" when="1980">1980</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Walker</surname></persName>
		</author>
		<idno>ECS-LFCS-89-85/86</idno>
		<title level="m">A Calculus of Mobile Processes. Part I/II</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>Edinburgh University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Functions as Processes. Proc. of ICALP&apos;90</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">443</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
