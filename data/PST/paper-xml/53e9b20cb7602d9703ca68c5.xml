<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Zyzzyva: Speculative Byzantine Fault Tolerance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ramakrishna</forename><surname>Kotla</surname></persName>
							<email>kotla@cs.utexas.edu</email>
						</author>
						<author>
							<persName><forename type="first">Lorenzo</forename><surname>Alvisi</surname></persName>
							<email>lorenzo@cs.utexas.edu</email>
						</author>
						<author>
							<persName><forename type="first">Mike</forename><surname>Dahlin</surname></persName>
							<email>dahlin@cs.utexas.edu</email>
						</author>
						<author>
							<persName><forename type="first">Allen</forename><surname>Clement</surname></persName>
							<email>aclement@cs.utexas.edu</email>
						</author>
						<author>
							<persName><forename type="first">Edmund</forename><surname>Wong</surname></persName>
							<email>elwong@cs.utexas.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Sciences</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Stevenson, Washington</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Zyzzyva: Speculative Byzantine Fault Tolerance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8DBE3F8CF952F037B7AF27EA3440C6D5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.5 [Operating Systems]: Reliability-Fault-tolerance</term>
					<term>D.4.7 [Operating Systems]: Organization and Design-Distributed systems</term>
					<term>H.3.4 [Information Storage and Retrieval]: Systems and Software-Distributed systems Performance, Reliability Byzantine fault tolerance, Speculative execution, Replication, Output commit</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present Zyzzyva, a protocol that uses speculation to reduce the cost and simplify the design of Byzantine fault tolerant state machine replication. In Zyzzyva, replicas respond to a client's request without first running an expensive three-phase commit protocol to reach agreement on the order in which the request must be processed. Instead, they optimistically adopt the order proposed by the primary and respond immediately to the client. Replicas can thus become temporarily inconsistent with one another, but clients detect inconsistencies, help correct replicas converge on a single total ordering of requests, and only rely on responses that are consistent with this total order. This approach allows Zyzzyva to reduce replication overheads to near their theoretical minima.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Three trends make Byzantine Fault Tolerant (BFT) replication increasingly attractive for practical deployment. First, the growing value of data and and falling costs of hardware make it advantageous for service providers to trade increasingly inexpensive hardware for the peace of mind potentially provided by BFT replication. Second, mounting evidence of non-fail-stop behavior in real systems <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b39">39,</ref><ref type="bibr" target="#b40">40]</ref> suggest that BFT may yield significant benefits even without resorting to n-version programming <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b33">33]</ref>. Third, improvements to the state of the art in BFT replication techniques <ref type="bibr" target="#b3">[3,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref> make BFT replication increasingly practical by narrowing the gap between BFT replication costs and costs already being paid for non-BFT replication. For example, by default, the Google file system uses 3-way replication of storage, which is roughly the cost of BFT replication for f = 1 failures with 4 agreement nodes and 3 execution nodes <ref type="bibr" target="#b41">[41]</ref>.</p><p>This paper presents Zyzzyva<ref type="foot" target="#foot_0">1</ref> , a new protocol that uses speculation to reduce the cost and simplify the design of BFT state machine replication <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b35">35]</ref>. Like traditional state machine replication protocols <ref type="bibr">[9,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, a primary proposes an order on client requests to the other replicas. In Zyzzyva, unlike in traditional protocols, replicas speculatively execute requests without running an expensive agreement protocol to definitively establish the order. As a result, correct replicas' states may diverge, and replicas may send different responses to clients. Nonetheless, applications at clients observe the traditional and powerful abstraction of a replicated state machine that executes requests in a linearizable <ref type="bibr" target="#b13">[13]</ref> order because replies carry with them sufficient history information for clients to determine if the replies and history are stable and guaranteed to be eventually committed. If a speculative reply and history are stable, the client uses the reply. Otherwise, the client waits until the system converges on a stable reply and history.</p><p>The challenge in Zyzzyva is ensuring that responses to correct clients become stable. Ultimately, replicas are responsible for ensuring that all requests from a correct client eventually complete, but a client waiting for a reply and history to become stable can speed the process by supplying information that will either cause the request to become stable rapidly within the current view or trigger a view change. Note that because clients do not require requests to commit but only to become stable, clients act on requests in one or two phases rather than the customary three <ref type="bibr">[9,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>.</p><p>Essentially, Zyzzyva rethinks the sync <ref type="bibr" target="#b28">[28]</ref> for BFT: instead of pessimistically ensuring that replicas establish a final order on requests before communicating with a client, we move the output commit to the client. <ref type="bibr">Leveraging</ref>   <ref type="table">1</ref>: Properties of state-of-the-art and optimal Byzantine fault tolerant service replication systems tolerating f faults, using MACs for authentication <ref type="bibr">[9]</ref>, and using a batch size of b <ref type="bibr">[9]</ref>. Bold entries denote protocols that match known lower bounds or those with the lowest known cost. † It is not clear that this trivial lower bound is achievable. ‡ The distributed systems literature typically considers 3 one-way latencies to be the lower bound for agreement on client requests <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b25">25]</ref>; 2 one-way latencies is achievable if no concurrency is assumed. We include detailed discussion of this table in our extended technical report <ref type="bibr" target="#b17">[17]</ref>.</p><p>to state of the art protocols including PBFT <ref type="bibr">[9,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, Q/U <ref type="bibr" target="#b3">[3]</ref>, and HQ <ref type="bibr" target="#b10">[10]</ref>, Zyzzyva reduces cryptographic overheads and increases peak throughput by a factor of two to an order of magnitude for demanding workloads. In fact, Zyzzyva's replication costs, processing overheads, and communication latencies approach their theoretical lower bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Why another BFT protocol?</head><p>The state of the art for BFT state machine replication is distressingly complex. In a November 2006 paper describing Hybrid-Quorum replication (HQ replication) <ref type="bibr" target="#b10">[10]</ref>, Cowling et al. draw the following conclusions comparing three state-of-the-art protocols (Practical Byzantine Fault Tolerance (PBFT) <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, Query/Update (Q/U) <ref type="bibr" target="#b3">[3]</ref>, and HQ replication <ref type="bibr" target="#b10">[10]</ref>):</p><p>• "In the regions we studied (up to f = 5), if contention is low and low latency is the main issue, then if it is acceptable to use 5f + 1 replicas, Q/U is the best choice, else HQ is the best since it outperforms [P]BFT with a batch size of 1." <ref type="bibr" target="#b10">[10]</ref> • "Otherwise, [P]BFT is the best choice in this region: it can handle high contention workloads, and it can beat the throughput of both HQ and Q/U through its use of batching." <ref type="bibr" target="#b10">[10]</ref> • "Outside of this region, we expect HQ will scale best: HQ's throughput decreases more slowly than Q/U's (because of the latter's larger message and processing costs) and [P]BFT's (where eventually batching cannot compensate for the quadratic number of messages)." <ref type="bibr" target="#b10">[10]</ref> Such complexity represents a barrier to adoption of BFT techniques because it requires a system designer to choose the right technique for a workload and then for the workload not to deviate from expectations.</p><p>As Table <ref type="table">1</ref> indicates, Zyzzyva simplifies the design space of BFT replicated services by approaching the lower bounds in almost every key metric.</p><p>With respect to replication cost, Zyzzyva and PBFT match the lower bound both with respect to the total number of replicas that participate in the protocol and the number of replicas that must hold copies of application state and execute application requests. Both protocols hold cost advantages of 1.5-2.5 over Q/U and 1.0-1.5 over HQ depending on the number of faults to be tolerated and the relative cost of application vs. agreement node replication.</p><p>With respect to throughput, both Zyzzyva and PBFT use batching when load is high and thereby approach the lower bound on the number of authentication operations performed at the bottleneck node, and Zyzzyva approaches this bound more rapidly than PBFT. Q/U and HQ's inability to support batching increases the work done at the bottleneck node by factors approaching 5 and 4, respectively, when one fault is tolerated and by higher factors in systems that tolerate more faults.</p><p>With respect to latency, Zyzzyva executes requests in three one-way message delays, which matches the accepted lower bound in the distributed systems literature for agreeing on a client request <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b25">25]</ref> and improves upon both PBFT and HQ. Q/U sidesteps this lower bound by providing a service that is slightly weaker than state machine replication (i.e., it does not put a total order on all requests) and by optimizing for cases without concurrent access to any state. This difference presents a chink in Zyzzyva's armor, which Zyzzyva minimizes by matching the lower bound on message delays for full consensus. We believe that Zyzzyva's other advantages over Q/U-fewer replicas, improved throughput via batching, simpler state machine replication semantics, ability to support high-contention workloads-justify this "extra" latency.</p><p>With respect to fault scalability <ref type="bibr" target="#b3">[3]</ref>, the metrics that depend on f grow as slowly or more slowly in Zyzzyva as in any other protocol.</p><p>Note that as is customary <ref type="bibr" target="#b3">[3,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, Table <ref type="table">1</ref> compares the protocols' performance during the expected common case of fault-free, timeout-free execution. All of the protocols are guaranteed to operate correctly in the presence of up to f faults and arbitrary delays, but all of these protocols can pay significantly higher overheads and latencies in such scenarios. In §5.4, we consider the susceptibility of these protocols to faults and argue that Zyzzyva remains the most attractive choice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SYSTEM MODEL</head><p>We assume the Byzantine failure model where faulty nodes (replicas or clients) may behave arbitrarily. We assume a strong adversary that can coordinate faulty nodes to compromise the replicated service. We do, however, assume the adversary cannot break cryptographic techniques like collision-resistant hashes, encryption, and signatures. In the public-key version of our protocol, we denote a message X signed by principal Y 's public key as X σ Y . Our system ensures its safety and liveness properties if at most f repli-cas are faulty. We assume a finite client population, any number of which may be faulty.</p><p>Our system's safety properties hold in any asynchronous distributed system where nodes are connected by a network that may fail to deliver messages, corrupt them, delay them, or deliver them out of order. Liveness, however, is ensured only during intervals in which messages sent to correct nodes are processed within some fixed (but potentially unknown) worst case delay from when they are sent.</p><p>Our system implements a BFT service using state machine replication <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b35">35]</ref>. Traditional state machine replication techniques can be applied only to deterministic services. We cope with the non-determinism present in many real-word applications (such as file systems <ref type="bibr" target="#b26">[26]</ref> and databases <ref type="bibr" target="#b38">[38]</ref>) by abstracting the observable application state at the replicas and using the agreement stage to resolve divergences <ref type="bibr" target="#b33">[33]</ref>.</p><p>Services limit the damage done by Byzantine clients by authenticating clients, enforcing access control to deny clients access to objects they do not have a right to, and (optionally) by maintaining multiple versions of shared data (e.g., snapshots in a file system <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b16">16]</ref>) so that data can be recovered from older versions if a faulty client destroys data <ref type="bibr" target="#b14">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROTOCOL</head><p>Zyzzyva is a state machine replication protocol based on three sub-protocols: (1) agreement, (2) view change, and (3) checkpoint. The agreement protocol orders requests for execution by the replicas. The view change protocol coordinates the election of a new primary when the current primary is faulty or the system is running slowly. The checkpoint protocol limits the state that must be stored by replicas and reduces the cost of performing view changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principles and Challenges.</head><p>Zyzzyva focuses on safety properties as they are observed by the client. In Zyzzyva, replicas can become temporarily inconsistent with one another, but clients detect inconsistencies, drive replicas to converge on a single total ordering of requests, and only rely on responses that are consistent with this total order.</p><p>Given the duties BFT replication protocols already place on clients <ref type="bibr" target="#b3">[3,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, it is not a large step to fully move the output commit to the client, but this small step pays big dividends. First, Zyzzyva leverages speculative execution-replicas execute a request before its order is fully established. Second, Zyzzyva leverages fast agreement protocols <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b25">25]</ref> to establish a request ordering in as few as three message delays. Third, the agreement subprotocol stops working on a request once a client knows the request's order, thereby avoiding work that would otherwise be needed to establish this knowledge at the replicas.</p><p>These choices lead to two key challenges in designing Zyzzyva. First, we must specify carefully the conditions under which a request completes at a client and define agreement, checkpoint, and view change sub-protocols to retain the abstraction that requests execute on a single, correct state machine. Intuitively, a request completes when a correct client may safely act on the reply to that request. To help a client determine when it is appropriate to act on a reply, Zyzzyva appends history information to the replies received by a client so that the client can judge whether the replies are based on the same ordering of requests. Zyzzyva ensures the following safety condition: saf If a request with sequence number n and history hn completes, then any request that completes with a higher sequence number n ′ ≥ n has a history h n ′ that includes hn as a prefix.</p><p>Second, the view change sub-protocol must ensure liveness despite an agreement sub-protocol that never requires more than two phases to complete during a view. We shift work from the agreement sub-protocol to the view change subprotocol by introducing a new "I hate the primary" phase that guarantees that a correct replica only abandons the current view if it can ensure that all other correct replicas will join the mutiny. Zyzzyva ensures the following liveness condition under eventual synchrony<ref type="foot" target="#foot_1">2</ref>  <ref type="bibr" target="#b12">[12]</ref>: liv Any request issued by a correct client eventually completes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol Overview.</head><p>Zyzzyva is executed by 3f + 1 replicas, and execution is organized into a sequence of views. Within a view, a single replica is designated as the primary responsible for leading the agreement sub-protocol.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows the communication pattern for a single instance of our client-centric fast agreement sub-protocol. A client sends a request to the primary, the primary forwards the request to the replicas, and the replicas execute the request and send their responses to the client. A request completes at a client in one of two ways. First, if the client receives 3f + 1 mutually-consistent responses (including an application-level reply and the history on which it depends), then the client considers the request complete and acts on it. Second, if the client receives between 2f + 1 and 3f mutually-consistent responses, then the client gathers 2f + 1 responses and distributes this commit certificate to the replicas. Once 2f +1 replicas acknowledge receiving a commit certificate, the client considers the request complete and acts on the corresponding reply.</p><p>If a sufficient number of replicas suspect that the current primary is faulty, then a view change occurs and a new primary is elected.</p><p>In the rest of this section, we describe the basic protocol and outline the proof of its correctness <ref type="bibr" target="#b17">[17]</ref>. In §4 we describe a number of optimizations, all implemented in our prototype, that reduce encryption costs by replacing public key signatures with message authentication codes (MACs), improve throughput by batching requests, reduce the impact of lost messages by caching out-of-order messages, improve read performance by optimizing read-only requests, reduce bandwidth by having most replicas send hashes rather than full replies, reduce overheads by including MACs only for a preferred quorum, and improve performance in the presence of faulty nodes by including additional witness replicas.</p><p>In §4.1 we discuss Zyzzyva5, a variation of the protocol that requires 5f + 1 agreement replicas but that completes in three one-way message exchanges as in Figure <ref type="figure" target="#fig_1">2</ref>(a) even when up to f non-primary replicas are faulty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Node State and Checkpoint Protocol</head><p>To ground our discussion in definite terms, we begin by discussing the state maintained by each replica as summarized by Figure <ref type="figure" target="#fig_1">2</ref>. Each replica i maintains an ordered history of the requests it has executed and a copy of the max commit certificate, the commit certificate (defined below) seen by i that covers the largest prefix of i's stored history. The history up to and including the request with the highest sequence number covered by this commit certificate is the committed history, and the history that follows is the speculative history. We say that a commit certificate has sequence number n if n is the highest sequence number of any request in the committed history.</p><p>A replica constructs a checkpoint every CP INTERVAL requests. A replica maintains one stable checkpoint and a corresponding stable application state snapshot, and it may store up to one tentative checkpoint and corresponding tentative application state snapshot. The process by which a tentative checkpoint and application state become committed is similar to the one used by earlier BFT protocols <ref type="bibr">[9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, so we defer a detailed discussion to our extended technical report <ref type="bibr" target="#b17">[17]</ref>. However, to summarize briefly: when a correct replica generates a tentative checkpoint, it sends a signed checkpoint message to all replicas. The message includes the highest sequence number of any request included in the checkpoint and a digest of the corresponding tentative checkpoint and application snapshot. A correct Zyzzyva replica considers the checkpoint and corresponding application snapshot stable when it collects f + 1 matching checkpoint messages signed by different replicas.</p><p>To bound the size of the history, a replica (1) truncates the history before the committed checkpoint and (2) blocks processing of new requests after processing 2 × CP INTERVAL requests since the last committed checkpoint.</p><p>Finally, each replica maintains a response cache containing a copy of the latest ordered request from, and corresponding response to, each client. speculatively in the order proposed by the primary without communicating with other replicas, the key challenge is ensuring that clients only act upon replies that correspond to stable requests executed in a total order that is guaranteed to eventually commit at all correct servers. The protocol is constructed so that a request completes at a client when the client receives 3f + 1 matching responses or acknowledgements from 2f + 1 replicas that they have received a commit certificate comprising a local commit from 2f + 1 replicas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Agreement Protocol</head><p>Either of these conditions serves to prove that the request will eventually be committed at all correct replicas with the same sequence number and history of preceding requests observed by the client.</p><p>To describe how the system deals with this and other challenging, but standard, issues-lost messages, faulty primary, faulty clients, etc.-we follow a request through the system, defining the rules a server uses to process each message. The numbers in Figure <ref type="figure" target="#fig_0">1</ref> correspond to numbers in the text identifying major steps in the protocol and Table <ref type="table" target="#tab_1">2</ref> summarizes the labels we give fields in messages. Most readers will be happier if on their first reading they skip the text marked Additional Pedantic Details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Client sends request to the primary.</head><p>A client c requests an operation o be performed by the replicated service by sending a message request, o, t, c σc to the replica it believes to be the primary (i.e., the primary for the last response the client received).</p><p>Additional Pedantic Details: If the client guesses the wrong primary, the retransmission mechanisms discussed in step 4c below forwards the request to the current primary. The client's timestamp t is included to ensure exactly-once semantics of execution of requests.</p><p>2. Primary receives request, assigns sequence number, and forwards ordered request to replicas.</p><p>When the primary p receives message m = request, o, t, c σc from client c, the primary assigns a sequence number n in view v to the request and relays a message order-req, v, n, hn, d, N D σp , m to the backup replicas where v indicates the view in which the message is being sent, n is the proposed sequence number for m, d = H(m) is the digest of m, hn = H(hn-1, d) is a digest summarizing the history, and N D is a set of values for non-deterministic application variables (time in file systems, locks in databases, etc.) required for execution. Additional Pedantic Details: The primary only takes the above actions if t &gt; tc where tc is the highest timestamp previously received from c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Replica receives ordered request, speculatively executes it, and responds to the client.</head><p>Upon receipt of a message order-req, v, n, hn, d, N D σp , m from the primary p, replica i accepts the ordered request if m is a well-formed request message, d is a correct digest of m, n = maxn + 1 where maxn is the largest sequence number in i's history, and hn = H(hn-1, d). Upon accepting the message, i appends the ordered request to its history, executes the request using the current application state to produce a reply r, and sends to c a message spec-response, v, n, hn, H(r), c, t σ i , i, r, OR where OR = order-req, v, n, hn, d, N D σp .</p><p>Additional Pedantic Details: A replica may only accept and speculatively execute requests in sequence-number order, but message loss or a faulty primary can introduce holes in the sequence number space. Replica i discards the orderreq message if n ≤ maxn. If n &gt; maxn + 1, then i discards the message, sends a message fill-hole, v, maxn + 1, n, i σ i to the primary, and starts a timer. Upon receipt of a message fill-hole, v, k, n, i σ i from replica i, the primary p sends a order-req, v, n ′ , h n ′ , d, N D σp , m ′ to i for each request m ′ that p ordered in k ≤ n ′ ≤ n during the current view; the primary ignores fill-hole requests from other views. If i receives the valid order-req messages needed to fill the holes, it cancels the timer. Otherwise the replica broadcasts the fill-hole message to all other replicas and initiates a view change when the timer fires. Any replica j that receives a fill-hole message from i sends the corresponding order-req message, if it has received one. If, in the process of filling in holes in the replica sequence, replica i receives conflicting order-req messages then the conflicting messages form a proof of misbehavior as described in protocol step 4d.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Client gathers speculative responses.</head><p>The client receives messages spec-response, v, n, hn, H(r), c, t σ i , i, r, OR , where i identifies the replica issuing the response, from the replicas. spec-response messages from distinct replicas match if they have identical v, n, hn, H(r), c, t, and r fields. There are four cases to consider. The first three handle varying numbers of matching speculative replies without considering the OR field, while the last considers only the OR field.</p><p>4a. Client receives 3f + 1 matching responses and completes the request.</p><p>In the absence of faults, the client receives matching specresponse messages from all 3f + 1 replicas. The client then considers the request and its history to be complete and delivers the reply r to the application. Zyzzyva guarantees that even if there is a view change, all correct replicas will always execute this request at this point in their history to produce this response. Notice that although the client has a proof that the request's place in history is irrevocably set, no server has such a proof. Indeed, a server at this point cannot determine whether a request has completed in its final order or a roll-back of the server's state will be necessary because a faulty primary ordered the request inconsistently across replicas.</p><p>4b. Client receives between 2f + 1 and 3f matching responses, assembles a commit certificate, and transmits the commit certificate to the replicas.</p><p>If the network, primary, or some replicas are faulty, the client c may never receive responses from all 3f + 1 replicas. The client therefore sets a timer when it first issues a request: when this timer expires, if c has received matching speculative responses from between 2f + 1 and 3f replicas, then c sends a message commit, c, CC σc where CC is a commit certificate consisting of a list of 2f + 1 replicas, the replica-signed portions of the 2f + 1 matching specresponse messages from those replicas, and the corresponding 2f + 1 replica signatures.</p><p>Additional Pedantic Details: CC contains 2f + 1 signatures on the spec-response message and a list of 2f + 1 nodes, but, since all the responses received by c from repli-cas are identical, c only needs to include one replica-signed portion of the spec-response message. Also note that, for efficiency, CC does not include the body r of the reply but only the hash H(r). 4b.1. Replica receives a commit message from a client containing a commit certificate and acknowledges with a local-commit message.</p><p>When a replica i receives a message commit, c, CC σc containing a valid commit certificate CC proving that a request should be executed with a specified sequence number and history in the current view, the replica first ensures that its local history is consistent with the one certified by CC. If so, replica i (1) updates its max commit certificate state if this certificate's sequence number is higher than the stored certificate's sequence number and (2) sends a message local-commit, v, d, h, i, c σ i to c.</p><p>Additional Pedantic Details: If the local history simply has holes encompassed by CC's history, then i fills them as described in 3. If, however, the two histories contain different requests for the same sequence number, then i initiates the view change protocol. 4b.2. Client receives a local-commit messages from 2f + 1 replicas and completes the request.</p><p>The client resends the commit message until it receives corresponding local-commit messages from 2f + 1 distinct replicas. The client then considers the request and its history to be complete and delivers the reply r to the application. The system guarantees that even if there is a view change, all correct replicas will always execute this request at this point in their history to produce this response.</p><p>Additional Pedantic Details: When the client first sends the commit message to the replicas it starts a timer. If this timer expires before the client receives 2f + 1 localcommit messages then the client moves on to protocol step 4c described below. 4c. Client receives fewer than 2f + 1 matching specresponse messages and resends its request to all replicas, which forward the request to the primary in order to ensure the request is assigned a sequence number and eventually executed.</p><p>Client. If the network or primary is faulty, the client c may never receive matching spec-response messages from 2f +1 replicas. The client therefore sets a second timer when it first issues a request and resends the request message to all replicas when the second timer expires. It then resets its timers and continues gathering speculative responses.</p><p>Replica. When non-primary replica i receives a message request, o, t, c σc from client c there are two possible actions for i to take. If the request matches or has a lower client-supplied timestamp than the currently cached request for client c, then i resends the cached response to c. If instead the request has a higher timestamp than the currently cached response, then i sends a message confirm-req, v, m, i σ i where m = request, o, t, c σc to the primary p and starts a timer. If the replica accepts an order-req message for this request before the timeout, it processes the orderreq message as described above. If the timer fires before the primary orders the request, the replica initiates a view change.</p><p>Primary. Upon receiving the confirm request message confirm-req, v, m, i σ i from replica i, the primary p checks the client's timestamp for the request. If the request is new, p sends a new order-req message using the next sequence number to order as described in step 2; otherwise, p sends to i the cached order-req message for the most recent request from c.</p><p>Additional Pedantic Details: If replica i has received a commit certificate or stable checkpoint for a subsequent request, then the replica sends a local-commit to the client even if the client has not received a commit certificate for the retransmitted request. Additionally, if replica i does not receive the order-req message from the primary, the replica sends the confirm-req message to all other replicas. Upon receipt of a confirm-req message from another replica j, replica i sends the order-req message it received from the primary to j; if i did not receive the request from the client, i acts as if the request came from the client itself.</p><p>4d. Client receives responses indicating inconsistent ordering by the primary and sends a proof of misbehavior to the replicas, which initiate a view change to oust the faulty primary.</p><p>If client c receives a pair of spec-response messages containing valid messages OR = order-req, v, n, hn, d, N D σ j for the same request (d = H(m)) in the same view v with differing sequence number n or history hn, then the pair of order-req messages constitutes a proof of misbehavior (P OM ) against the primary. Upon receipt of a P OM , c sends a message pom, v, P OM σc to all replicas. Upon receipt of a valid pom message, a replica initiates a view change and forwards the pom message to all other replicas.</p><p>Note that cases 4b and 4c are not exclusive of 4d; a client may receive messages sufficient to complete a request or form a commit certificate and also a proof of misbehavior against the primary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">View Changes</head><p>Fast agreement and speculative execution have profound effects on Zyzzyva's view change sub-protocol. In this section we highlight the differences between the Zyzzyva view change sub-protocol and that of previous systems. For completeness we include the full view change sub-protocol in the appendix.</p><p>The view change sub-protocol must elect a new primary and guarantee that it will not introduce any changes in a history that has already completed at a correct client. To maintain this safety property, traditional view change subprotocols <ref type="bibr">[9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref> require a correct replica that commits to a view change to stop accepting messages other than checkpoint, view-change, and new-view messages. Also, to prevent faulty replicas from disrupting the system, a view change sub-protocol should never remove a primary unless at least one correct replica commits to the view change. Hence, a correct replica traditionally commits to a view change if either (a) it observes the primary to be faulty or (b) it has a proof that f + 1 replicas have committed to a view change. On committing to a view change a correct replica sends a signed view-change message that includes the new view, the sequence number of the replica's latest stable checkpoint (together with a proof of its stability), and the set of prepare certificates-the equivalent of commit certificates in Zyzzyva-collected by the replica.</p><p>The traditional view change completes when the new primary, using 2f + 1 view-change messages from distinct replicas, computes the history of requests that all correct replicas must adopt to enter the new view. The new primary includes this history, with a proof of validity, in a signed new-view message that it broadcasts to all replicas.</p><p>Zyzzyva maintains the overall structure of the traditional protocol, but it departs in two significant ways that together allow clients to accept a response before any replicas know that the request has been committed and allow the replicas to commit to a response after two phases instead of the traditional three.</p><p>1. First, to ensure liveness, Zyzzyva strengthens the condition under which a correct replica commits to a view change by adding a new "I hate the primary" phase to the view change sub-protocol. We explain the need for and details of this addition below by considering The Case of the Missing Phase.</p><p>2. Second, to guarantee safety, Zyzzyva weakens the condition under which a request appears in the history included in the new-view message. We explain the need for and details of this change below by considering The Case of the Uncommitted Request.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">The Case of the Missing Phase</head><p>As Figure <ref type="figure" target="#fig_0">1</ref> shows, Zyzzyva's agreement protocol guarantees that every request that completes within a view does so after at most two phases. This property may appear surprising to the reader familiar with PBFT. If we view a correct client that executes step 4b of Zyzzyva as implementing a broadcast channel between replicas, then Zyzzyva's communication pattern maps to only two of PBFT's three phases, one where communication is primary-to-replicas (pre-prepare) and the second involving all-to-all exchanges (either prepare or commit). Where did the third phase go? And why is it there in the first place?</p><p>The answer to the second question lies in the subtle dependencies between the agreement and view change subprotocols. No replicated service that uses the traditional view change protocol can be live without an agreement protocol that includes both the prepare and commit full exchanges. 3 To see how this constraint applies to Zyzzyva, consider a scenario with f faulty replicas, one of them the primary, and suppose the faulty primary causes f correct replicas to commit to a view change and stop sending messages in the view. In this situation, a client request may only receive f + 1 responses from the remaining correct replicas, not enough for the request to complete in either the first or second phase-and, because fewer than f + 1 replicas demand a view change, there is no opportunity to regain liveness by electing a new primary.</p><p>The third phase of traditional BFT agreement breaks this stalemate: by exchanging what they know, the remaining f +1 correct replicas can either gather the evidence necessary to complete the request after receiving only f + 1 matching responses or determine that a view change is necessary.</p><p>Back to the first question: How does Zyzzyva avoid the third phase in the agreement sub-protocol? The insight is that what compromises liveness in the previous scenario is 3 Unless a client can unilaterally initiate a view change. This option is unattractive when clients can be Byzantine. that the traditional view change protocol lets correct replicas commit to a view change and become silent in a view without any guarantee that their action will lead to the view change. Instead, in Zyzzyva, a correct replica does not abandon view v unless it is guaranteed that every other correct replica will do the same, forcing a new view and a new primary.</p><p>To ensure this property, the Zyzzyva view change subprotocol adds an additional phase to strengthen the conditions under which a replica stops participating in the current view. In particular, a correct replica i that suspects the primary of view v continues to participate in the view, but expresses its vote of no-confidence in the primary by multicasting to all replicas a message i-hate-the-primary, v σ i . If i receives f + 1 votes of no confidence in v's primary, then it commits to a view change: it becomes silent, and multicasts to all replicas a view-change message that contains a proof that f + 1 replicas have no confidence in the primary for view v. A correct replica that receives a valid viewchange message joins in the mutiny and commits to the view change. As a result, Zyzzyva's view change protocol ensures that if a correct replica commits to a view change in view v, eventually all correct replicas will. In effect, Zyzzyva shifts the costs needed to deal with a faulty primary from the critical path (the agreement protocol) to the view change sub-protocol, which is run only when the primary is faulty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">The Case of the Uncommitted Request</head><p>Zyzzyva replicas may never learn the outcome of the agreement protocol: only clients may know when a request has completed. How do Zyzzyva replicas identify a safe history prefix for a new view?</p><p>There are two ways in which a request r and its history may complete in Zyzzyva. Let us first consider the least problematic from the perspective of a view change: it occurs when r completes because a client receives 2f + 1 local-commit messages, implying that at least f + 1 correct replicas have stored a commit certificate for r. Traditional view change protocols already handle this case: the standard view-change message sent by a correct replica includes all commit certificates known to the replica since the latest stable checkpoint. The new primary includes in the new-view message all commit certificates that appear in any set of 2f + 1 view-change messages it receives: at least one of those view-change messages must contain a commit certificate for r.</p><p>The other case is more challenging: if r completes because the client receives 3f + 1 matching speculative responses, then no correct replica will have a commit certificate for r. We handle this case by modifying the view change subprotocol in two ways. First, correct replicas add to the information included in their view-change message all orderreq messages (without the corresponding client request) received since the latest stable checkpoint or commit certificate. Second, a correct new primary extends the history to be adopted in the new view to include all requests with an order-req message containing a sequence number higher than the largest sequence number in any commit certificate that appears in at least f + 1 of the 2f + 1 view-change messages the new primary collects.</p><p>This change weakens the conditions under which a request ordered in one view can appear in a new view: we no longer require a commit certificate but also allow a sufficient num-ber of order-req messages to support a request's ordering. This change ensures that the protocol continues to honor ordering commitments for any request that completes when a client gathers 3f + 1 matching speculative responses.</p><p>Notice that this change may have the side effect of assigning an order to a request that has not yet completed in the previous view. In particular, a curiosity of the protocol is that, depending on which set of 2f + 1 view-change messages the primary uses, it may, for a given sequence number, find different requests with f +1 order-req messages. This curiosity, however, is benign and cannot cause the system to violate safety. In particular, there can be two such candidate requests for the same sequence number only if at least one correct replica supports each of the candidates. In such a case, neither of the candidates could have completed by having a client receive 3f + 1 matching responses, and the system can safely assign either (or neither) request to that sequence number.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Correctness</head><p>This section sketches the proof that Zyzzyva maintains properties saf and liv defined above. Full proofs are available in the extended technical report <ref type="bibr" target="#b17">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Safety</head><p>We first show that our agreement sub-protocol is safe within a single view and then show that the agreement and view change protocols together ensure safety across views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Within a View.</head><p>The proof proceeds in two parts. First we show that no two requests complete with the same sequence number n. Second we show that hn is a prefix of h n ′ for n &lt; n ′ and completed requests r and r ′ .</p><p>Part 1: A request completes when the client receives 3f +1 matching spec-response messages in phase 1 or 2f + 1 matching local-commit messages in phase 2. If a request completes in phase 1 with sequence number n, then no other request can complete with sequence number n because correct replicas (a) send only one speculative response for a given sequence number and (b) send a local-commit message only after seeing 2f + 1 matching spec-response messages. Similarly, if a request completes with sequence number n in phase 2, no other request can complete since correct replicas only send one local-commit message for sequence number n.</p><p>Part 2: For any two requests r and r ′ that complete with sequence numbers n and n ′ and histories hn and h n ′ respectively, there are at least 2f + 1 replicas that ordered each request. Because there are only 3f + 1 replicas in total, at least one correct replica ordered both r and r ′ . If n &lt; n ′ , it follows that hn is a prefix of h n ′ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Across Views.</head><p>We show that any request that completes based on responses sent in view v &lt; v ′ is contained in the history specified by the new-view message for view v ′ . Recall that requests complete either when a correct client receives 3f + 1 matching speculative responses or 2f + 1 matching localcommits.</p><p>If a request r completes with 2f +1 matching local-commits, then at least f + 1 correct replicas have received a commit certificate for r (or for a subsequent request) and will send that commit certificate to the new primary in their view-change message. Because there are 3f + 1 replicas in the system and 2f + 1 view-change messages in a newview message, that commit certificate will necessarily be included in the new-view message and r will be included in the history. Consider instead a request r that completes with 3f +1 matching spec-response messages and does not complete with 2f + 1 matching local-commit messages. Every correct replica will include the order-req for r in its view-change message, ensuring that the request will be supported by at least f + 1 replicas in the set of 2f + 1 view-change messages collected by the primary of view v ′ and therefore be part of the new-view message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Liveness</head><p>Zyzzyva guarantees liveness only during periods of synchrony. To show that a request issued by a correct client eventually completes, we first show that if the primary is correct when a correct client issues the request, then the request completes. We then show that if a request from a correct client does not complete during the current view, then a view change occurs.</p><p>Part 1: If the client and primary are correct, then protocol steps 1 through 3 ensure that the client receives specresponse messages from all correct replicas. If the client receives 3f + 1 matching spec-response messages, the request completes-and so does our proof. A client that instead receives fewer than 3f + 1 such messages will receive at least 2f + 1 of them, since there are 3f + 1 replicas and at most f of which are faulty. This client then sends a commit message to all replicas (protocol step 4b). All correct replicas send a local-commit message to the client (protocol step 4b.1), and, because there are at least 2f + 1 correct replicas, the client's request completes in protocol step 4b.2.</p><p>Part 2: Assume the request from correct client c does not complete. By protocol step 4c, c resends the request message to all replicas when the request has not completed for a sufficiently long time. A correct replica, upon receiving the retransmitted request from c, contacts the primary for the corresponding order-req message. Any correct replica that does not receive the order-req message from the primary initiates the view change by sending an i-hate-theprimary message to all other replicas. Either at least one correct replica receives at least f + 1 i-hate-the-primary messages, or no correct replica receives at least f + 1 ihate-the-primary messages. In the first case, the replicas commit to a view change-QED. In the second case, all correct replicas that did not receive the order-req message from the primary receive it from another replica. After receiving an order-req message, a correct replica sends a spec-response to c. Because all correct replicas send a spec-response message to c, c is guaranteed to receive at least 2f + 1 such messages. Note that c must receive fewer than 2f + 1 matching spec-response messages: otherwise, c would be able to form a commit and complete the request, contradicting our initial assumption. If however, c does not receive 2f + 1 matching spec-response messages, then c is able to form a pom message: c relays this message to the replicas which in turn initiate and commit to a view change, completing the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION OPTIMIZATIONS</head><p>Our implementation includes several optimizations to improve performance and reduce system cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Replacing Signatures with MACs.</head><p>Like previous work <ref type="bibr" target="#b3">[3,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref>, we replace most signatures in Zyzzyva with MACs and authenticators in order to reduce the computational overhead of cryptographic operations. The only signatures that are not replaced with MACs are client request retransmissions and the messages of the view change protocol. The technical changes to each sub-protocol required by replacing signatures with authenticators are described in <ref type="bibr" target="#b17">[17]</ref>. The most noticeable difference in the agreement sub-protocol is the way Zyzzyva addresses the scenario in which replica i is unable to authenticate a client request; i cannot distinguish whether the fault lies with the primary or the client. Our procedure in this case is similar to a view change and results in correct replicas agreeing to accept the request or replace it with a no-op in the sequence. The checkpoint sub-protocol adds a third phase to ensure that stable checkpoints are consistent with requests that complete through speculative execution. Finally, the view change sub-protocol includes an additional phase for gathering checkpoint and commit certificate proofs as is done in PBFT <ref type="bibr">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Separating Agreement from Execution.</head><p>We separate agreement from execution <ref type="bibr" target="#b41">[41]</ref> by requiring only 2f + 1 replicas to be execution replicas. The remaining replicas serve as witness replicas <ref type="bibr" target="#b23">[23]</ref>, aiding in the process of ordering requests but not replicating the application. Clients accept a history based on the agreement protocol described in the previous section with a slight modification: a pair of responses are considered to match even if the response r and response hash H(r) fields are not identical. A client acts on a reply only after receiving the appropriate number of matching responses and f + 1 matching application replies from execution replicas. One consequence of this optimization is that a client may have to wait until it has received more than 2f + 1 responses before it can act in the second phase. We gain further benefit by biasing the primary selection criteria so that witness replicas are chosen as the primary more frequently than execution replicas. This favoritism reduces processor contention at the primary and allows requests to be ordered and processed faster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Request Batching.</head><p>We batch concurrent requests to reduce cryptographic and communication overheads like other agreement-based replicated services <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b37">37]</ref>. Batching requests amortizes the cost of replica operations across multiple requests and reduces the total number of operations per request. One key step in batching requests is having replicas compute a single history digest corresponding to the entries in the batch. This batch history is used in responses to all requests included in the batch. If the second phase completes for any request in the batch, the second phase is considered complete for all requests in the batch and replicas respond to the retransmission of any requests in the batch with localcommit messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Caching Out of Order Requests.</head><p>The protocol described in section 3.2 dictates that replicas discard order request messages that are received out of order. We improve performance when the network delivers messages out of order by caching these requests until the ap-propriate sequence number is reached. Similarly, the view change sub-protocol can order additional requests that are not supported by f + 1 speculative responses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Read-Only Optimization.</head><p>Like PBFT <ref type="bibr">[9]</ref>, we improve the performance of read-only requests that do not modify the system state. A client sends read-only requests directly to the replicas which execute the requests immediately, without recording the request in the request history. As in PBFT, clients wait for 2f +1 matching replies in order to complete read-only operations. In order for this optimization to function, we augment replies to read requests with a replica's maxn and maxCC . A client that receives 2f + 1 matching responses, including the maxn and maxCC fields, such that maxn = maxCC can accept the reply to the read. Furthermore, a client that receives 3f + 1 matching replies, even if the maxCC and maxn values are not consistent, can accept the reply to the read.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Single Execution Response.</head><p>The client specifies a single execution replica to respond with a full response while the other execution replicas send only a digest of the response. This optimization is introduced in PBFT <ref type="bibr">[9]</ref> and saves network bandwidth proportional to the size of responses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Preferred Quorums.</head><p>Q/U <ref type="bibr" target="#b3">[3]</ref> and HQ <ref type="bibr" target="#b10">[10]</ref> leverage preferred quorums to reduce the size of authenticators by optimistically including MACs for a subset of replicas rather than all replicas. We implement preferred quorums for the second phase; replicas authenticate speculative response messages for the client and a subset of 2f other replicas. Additionally, on the initial transmission, we allow the client to specify that replicas should authenticate speculative response messages to the client only. This optimization reduces the number of cryptographic operations performed by backup replicas to three while existing BFT systems <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref> require a linear number of cryptographic operations at each replica.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Making the Faulty Case Fast</head><p>We introduce a second protocol, Zyzzyva5, that uses 2f additional witness replicas (the number of execution replicas is unchanged at 2f +1) for a total of 5f +1 replicas. Increasing the number of replicas lets clients receive responses in three message delays even when f replicas are faulty <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b25">25]</ref>. Zyzzyva5 trades the number of replicas in the deployed system against performance in the presence of faults. Zyz-zyva5 is identical to Zyzzyva with a simple modificationnodes wait for an additional f messages, i.e. if a node bases a decision on a set of 2f + 1 messages in Zyzzyva, the corresponding decision in Zyzzyva5 is based on a set of 3f + 1 messages. The exceptions to this rule are the "I hate the primary" phase of the view change protocol and the fill-hole and confirm-request sub-protocols that serve to prove that another correct replica has taken an action-these phases still require only f + 1 responses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>This section examines the performance characteristics of Zyzzyva and compares it with existing approaches. We run our experiments on 3.0 GHz Pentium-4 machines with the Linux 2.6 kernel. We use MD5 for MACs and AdHash <ref type="bibr" target="#b7">[7]</ref> for incremental hashing. MD5 is known to be vulnerable, but we use it to make our results comparable with those in the literature. Since Zyzzyva uses fewer MACs per request than any of the competing algorithms, our advantages over other algorithms would be increased if we were to use the more secure, but more expensive, SHA-256.</p><p>For comparison, we run Castro et al.'s implementation of PBFT <ref type="bibr">[9]</ref> and Cowling et al.'s implementation of HQ <ref type="bibr" target="#b10">[10]</ref>; we scale up measured throughput for the small request/response benchmark by 9% <ref type="bibr" target="#b1">[1]</ref> to account for their use of SHA-1 rather than MD5. We include published throughput measurements for Q/U <ref type="bibr" target="#b3">[3]</ref>; we scale reported performance up by 7.5% to account for our use of 3.0 GHz rather than 2.8GHz machines. We also compare against measurements of an unreplicated server.</p><p>Unless noted otherwise, in our experiments we use all of the optimizations other than preferred quorums for Zyzzyva as described in §4. PBFT <ref type="bibr">[9]</ref> does not implement preferred quorum optimization. We run with preferred quorum optimization for HQ <ref type="bibr" target="#b10">[10]</ref>. We do not use the read-only optimization for Zyzzyva and PBFT unless we state so explicitly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Throughput</head><p>To stress-test Zyzzyva we use the micro-benchmarks devised by Castro et al. <ref type="bibr">[9]</ref>. In the 0/0 benchmark, a client sends a null request and receives a null reply. In the 4/0 benchmark, a client sends a 4KB request and receives a null reply. In the 0/4 benchmark, a client sends a null request and receives a 4KB reply.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> shows the throughput achieved for the 0/0 benchmark by Zyzzyva, Zyzzyva5, PBFT, and HQ (scaled as noted above). For reference, we also show the peak throughput reported for Q/U <ref type="bibr" target="#b3">[3]</ref> in the f = 1 configuration, scaled to our environment as described above. As the number of clients increases, Zyzzyva and Zyzzyva5 scale better than PBFT with and without batching. Without batching, Zyzzyva achieves a peak throughput that is 2.7 times higher than PBFT due to PBFT's higher cryptographic overhead (PBFT performs about 2.2 times more crypto operations than Zyzzyva) and message overhead (PBFT sends and receives about 3.7 times more messages than Zyzzyva). When the batch size is increased to 10, Zyzzyva's and Zyzzyva5's peak throughputs increase to 86K ops/sec suggesting that the protocol overhead at the primary is 12µs per batched request. With batching, PBFT's throughput increases to 59K ops/sec. The 45% difference between Zyzzyva and PBFT's peak throughput are largely accounted for PBFT's higher cryptographic overhead (about 30%) and message overhead (about 30%) compared to Zyzzyva. Zyzzyva provides over 3 times the reported peak throughput of Q/U and over 9 times the measured throughput of HQ. This difference stems from three sources. First, Zyzzyva requires fewer cryptographic operations per request compared to HQ and Q/U. Second, neither Q/U nor HQ is able to use batching to reduce cryptographic and message overheads. Third, Q/U and HQ do not take advantage of the Ethernet broadcast channel to speed up the one-to-all communication steps. Overall, the peak throughput achieved by Zyzzyva is within 35% of that of an unreplicated server that simply replies to client request over an authenticated channel. Note that as application-level request processing increases, the protocol overhead will fall.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Latency</head><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the latencies of Zyzzyva, Zyzzyva5, Q/U, and PBFT for the 0/0, 0/4, and 4/0 microbenchmarks. For Q/U, which can complete in fewer message delays than Zyzzyva during contention-free periods, we use a simple bestcase implementation of Q/U with preferred quorums in which a client simply generates and sends 4f + 1 MACs with a request, each replica verifies 4f + 1 MACs (1 to authenticate the client and 4f +1 to validate the OHS state), each replica generates and sends 4f + 1 MACs (1 to authenticate the reply to the client and 4f to authenticate OHS state) with a reply to the client, and the client verifies 4f + 1 MACs. We examine both the default read/write requests that use the full protocol and read-only requests that exploit the readonly optimization.</p><p>Zyzzyva uses fast agreement to drive its latency near the optimal for an agreement protocol-3 one-way message delays <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b25">25]</ref>. The experimental results in Figure <ref type="figure" target="#fig_3">4</ref> show that Zyzzyva and Zyzzyva5 achieve significantly lower latency than the other agreement-based protocols, PBFT and HQ. As expected, Q/U's avoidance of serialization gives it even better latency in low-contention workloads such as the one examined here, though Zyzzyva and PBFT can match Figure <ref type="figure">5</ref> shows latency and throughput as we vary offered load. As the figure illustrates, batching in Zyzzyva, Zyz-zyva5, and PBFT increases latency but also increases peak throughput. Adaptively setting the batch size in response to workload characteristics is an avenue for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Fault Scalability</head><p>In this section we examine performance of these protocols as f , the number of tolerated faults, increases.</p><p>Figure <ref type="figure">6</ref> shows the peak throughputs of Zyzzyva, PBFT, HQ, and Q/U (reported throughput) with increasing number of tolerated faults for batch sizes of 1 and 10. Zyzzyva is robust to increasing f and continues to provide significantly higher throughput than other systems for the same reasons as explained in the throughput section. Additionally, as expected for the case with no batching, the overhead of Zyzzyva increases more slowly than PBFT with increasing f because Zyzzyva requires 2 + (3f + 1) cryptographic operations compared to 2 + (10f + 1) cryptographic operations for PBFT.</p><p>Figures <ref type="figure" target="#fig_8">7</ref> shows the number of cryptographic operations per request and the number of messages sent and received per request at the bottleneck server (the primary in Zyzzyva, Zyzzyva5, PBFT, and any server in Q/U and HQ). We believe that for these metrics, the most interesting regions are when f is small and when batching is enabled. Not coincidentally, Zyzzyva performs well in these situations, dominating all of the approaches with respect to load at the bottleneck server. Also, when f is small, Zyzzyva and Zyzzyva5 also have low message counts at the primary. As f increases, when batching is used, Zyzzyva and Zyz-zyva5 are likely to remain attractive. One point worth noting is that message counts at the primary for Zyzzyva, Zyz-zyva5, and PBFT increase as f increases, while server message counts are constant with f for Q/U and HQ. In this figure, message counts do not include the multicast optimization we exploited in our experiments. Multicast reduces the number of client messages for all protocols by allowing clients to transmit their requests to all servers in one send. Multicast also reduces the number of server messages for Zyzzyva, Zyzzyva5, PBFT, and HQ (but not Q/U) when the primary or other servers communicate with their peers. In particular, with multicast the primary sends or receives one message per batch of operations plus an additional two messages per request regardless of f . The extended technical report <ref type="bibr" target="#b17">[17]</ref> examines other metrics such as client load and finds, for example, that Zyzzyva improves upon all of the protocols except PBFT by this metric. These graphs are omitted due to space constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Performance During Failures</head><p>Zyzzyva guarantees correct execution with any number of faulty clients and up to f faulty replicas. However, its performance is optimized for the expected case of failurefree operation. In particular a single faulty replica can force Zyzzyva to execute the slower 2 phase protocol. Zyzzyva's protocol, however, remains relatively efficient in such scenarios. In particular, Zyzzyva's cryptographic overhead increases from 2+   Zyzzyva5 provide 1.8 and 2.6 times higher throughput than PBFT, respectively, because of additional cryptographic and message overheads as described above. However, with the batch size of 10, PBFT performs 15% better than Zyzzyva as the cryptographic overhead of Zyzzyva is 16% higher than PBFT. As expected, Zyzzyva5 achieves the peak throughput that is same as the peak throughput for the fault-free case and continues to outperform PBFT by 43% with batching. For the same reasons as described in the throughput section, Zyzzyva, Zyzzyva5, and PBFT outperform HQ. We do not include a discussion of Q/U in this section the numbers of Q/U with failures are not reported <ref type="bibr" target="#b3">[3]</ref>.</p><p>A limitation Zyzzyva and Zyzzyva5 share with PBFT (and HQ during periods of contention) is that a faulty primary can significantly prevent progress. These protocols replace the primary to ensure progress. Although Q/U avoids having a primary, it shares a corresponding vulnerability: a faulty client that fails to adhere to the back-off protocol can impede progress indefinitely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Starting with PBFT <ref type="bibr">[9,</ref><ref type="bibr" target="#b33">33]</ref> several systems <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b41">41]</ref> have explored how to make Byzantine services practical.</p><p>We have discussed throughout the paper how Zyzzyva builds upon these systems and how it departs from them. As its predecessors, Zyzzyva leverages ideas inspired by Paxos <ref type="bibr" target="#b20">[20]</ref> and by work on Byzantine quorum systems <ref type="bibr" target="#b24">[24]</ref>. In particular, Zyzzyva fast agreement protocol is based on recent work on fast Paxos <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b25">25]</ref>.</p><p>Numerous BFT agreement protocols <ref type="bibr">[9,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b41">41]</ref> have used tentative execution to reduce the latency experienced by clients. This optimization allows replicas to execute a request tentatively as soon as they have collected the Zyzzyva equivalent of a commit certificate for that request. This optimization may superficially appear similar to Zyzzyva's support for speculative executions-but there are two fundamental differences. First, Zyzzyva's speculative execution allows requests to complete at a client after a single phase, without the need to compute a commit certificate: this reduction in latency is not possible with traditional tentative executions. Second, and more importantly, in traditional BFT systems a replica can execute a request tentatively only after the replica's "state reflects the execution of all requests with lower sequence number, and these requests are all known to be committed" <ref type="bibr" target="#b8">[8]</ref>. In Zyzzyva, replicas continue to execute request speculatively, without waiting to know that requests with lower sequence numbers have completed; this difference is what lets Zyzzyva leverage speculation to achieve not just lower latency but also higher throughput.</p><p>Q/U <ref type="bibr" target="#b3">[3]</ref> provides high throughput assuming low concurrency in the system but requires higher number of replicas than Zyzzyva. HQ <ref type="bibr" target="#b10">[10]</ref> uses fewer replicas than Q/U but uses multiple rounds to complete an operation. Both HQ and Q/U fail to batch concurrent requests and incur higher overhead in the presence of request contention; Singh et al. <ref type="bibr" target="#b37">[37]</ref> add a preserializer to HQ and Q/U to address these issues.</p><p>BFT2F <ref type="bibr" target="#b22">[22]</ref> explores how to gracefully weaken the consistency guarantees provided by BFT state machine replication when the number of faulty replicas exceeds one third (but is no more than two thirds) of the total replicas.</p><p>Speculator <ref type="bibr" target="#b29">[29]</ref> allows clients to speculatively complete operations at the application level and perform client level rollback. A similar approach could be used in conjunction with Zyzzyva to support clients that want to act on a reply optimistically, rather than waiting on the specified set of responses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>By systematically exploiting speculation, Zyzzyva exhibits significant performance improvements over existing BFT services. The throughput and latency of Zyzzyva approach the theoretical lower bounds for any BFT protocol.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Protocol communication pattern within a view for (a) gracious execution and (b) faulty replica cases. The numbers refer to the main steps of the protocol numbered in the text.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: State maintained at each replica.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Realized throughput for the 0/0 benchmark as the number of client varies for systems configured to tolerate f = 1 faults.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Latency for 0/0, 0/4, and 4/0 benchmarks for systems configured to tolerate f = 1 faults.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Latency vs. throughput for systems configured to tolerate f = 1 faults.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure8: Realized throughput for the 0/0 benchmark as the number of client varies when f nonprimary replicas fail to respond to requests.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>batch. Zyz-zyva5's increased fault tolerance ensures that its overheads do not increase in such scenarios, remaining at 2 + 5f +1 b per batch. For comparison, PBFT uses 2 + 10f +1 b operations in both this scenario and fault-free.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8</head><label>8</label><figDesc>compares throughput with increasing numbers of clients for Zyzzyva, Zyzzyva5, PBFT, and HQ in the presence of f backup server failures. For the case when f = 1, with one failure and no batching (b = 1), Zyzzyva and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Fault scalability using analytical model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Figure1illustrates the basic flow of the agreement subprotocol during a view. Because replicas execute requests Labels given to fields in messages.</figDesc><table><row><cell cols="2">Label Meaning</cell></row><row><cell>c</cell><cell>Client ID</cell></row><row><cell>CC</cell><cell>Commit certificate</cell></row><row><cell>d</cell><cell>Digest of client request message</cell></row><row><cell></cell><cell>d = H(m)</cell></row><row><cell>i, j</cell><cell>Server IDs</cell></row><row><cell>hn</cell><cell>History through sequence number n</cell></row><row><cell></cell><cell>hn = H(hn-1, d)</cell></row><row><cell>m</cell><cell>Message containing client request</cell></row><row><cell cols="2">maxn Max sequence number accepted by replica</cell></row><row><cell>n</cell><cell>Sequence number</cell></row><row><cell>o</cell><cell>Operation requested by client</cell></row><row><cell>OR</cell><cell>Order Request message</cell></row><row><cell cols="2">P OM Proof Of Misbehavior</cell></row><row><cell>r</cell><cell>Application reply to a client operation</cell></row><row><cell>t</cell><cell>Timestamp assigned to an operation by a client</cell></row><row><cell>v</cell><cell>View number</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Zyzzyva (ZIZ-uh-vuh) is the last word in the dictionary. According to dictionary.com, a zyzzyva is "any of various tropical American weevils of the genus Zyzzyva, often destructive to plants."</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In practice eventual synchrony can be achieved by using exponentially increasing timeouts[9].</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGEMENTS</head><p>This work was supported in part by NSF grants CNS-0720649, CNS-0509338, and CNS-0411026. Ramakrishna Kotla was awarded SOSP student travel scholarship, supported by Hewlett-Packard, to present the paper at the conference. We thank Rodrigo Rodrigues, James Cowling, and Michael Abd-El-Malek for sharing source code for PBFT, HQ, and QU respectively.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>The Zyzzyva view change sub-protocol is similar to traditional view change sub-protocols with two key exceptions. First, while replicas in traditional view change protocols commit to the view change as soon as they suspect the primary to be faulty, replicas in Zyzzyva only commit to a view change when they know that all other correct replicas will join them in electing a new primary. Second, Zyzzyva weakens the condition under which a request appears in the new view's history. The protocol proceeds as follows.</p><p>VC1. Replica initiates the view change by sending an accusation against the primary to all replicas.</p><p>Replica i initiates a view change by sending i-hate-theprimary, v σ i to all replicas, indicating that the replica is dissatisfied with the behavior of the current primary. In previous protocols, this message would indicate that replica i is no longer participating in the current view. In Zyzzyva, this message is only a hint that i would like to change views. Even after issuing the message, i continues to faithfully participate in the current view.</p><p>VC2. Replica receives f + 1 accusations that the primary is faulty and commits to the view change.</p><p>Replica i commits to a view change into view v+1 by sending an indictment of the current primary, consisting of ihate-the-primary, v σ j from f + 1 distinct replicas j, and the message view-change, v + 1, CC, O, i σ i to all replicas. CC is either the most recent commit certificate for a request since the last view change, f + 1 view-confirm messages if no commit certificate is available, or a new-view message if neither of the previous options are available. O is i's ordered request history since the commit certificate indicated by CC. At this point, a replica stops accepting messages relevant to the current view and does not respond to the client until a new view has started.</p><p>VC3. Replica receives 2f + 1 view change messages.</p><p>Primary. Upon receipt of 2f + 1 view-change messages, the new primary p constructs the message new-view, v + 1, P σp where P is a collection of 2f + 1 view-change messages defining the initial state for view v + 1.</p><p>Replica. The replica starts a timer. If the replica does not receive a valid new-view message from the new primary before the timer expires, then the replica initiates a view change into view v + 2.</p><p>Additional Pedantic Details: If a replica commits to change to view v + 2 before receiving a new view message for view v + 1, then the replica uses the set of ordered requests from view v to form its view change message. The length of the timer in the new view grows exponentially with the number view changes that fail in succession.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VC4. Replica receives a valid new view message and sends a view confirmation message to all other replicas.</head><p>Replicas determine the state of the new view based on the collection of 2f + 1 view-change messages included in the new-view message. The most recent request with a corresponding commit certificate (or old new view message) is accepted as the last request in the base history. The most recent request that is ordered subsequent to the commit certificate by at least f + 1 view-change messages is accepted. Replica i forms the message view-confirm, v + 1, n, h, i σ i based on the new-view message and sends the view-confirm message to all other replicas.</p><p>Additional Pedantic Details: When evaluating the newview message, a commit certificate from the most recent view takes priority over anything else, followed by f + 1 view-confirm messages, and finally a new-view message with the highest view number.</p><p>VC5. Replica receives 2f + 1 matching viewconfirm messages and begins accepting requests in the new view.</p><p>Upon receipt of 2f +1 matching view-confirm messages, replica i begins the new view v.</p><p>Additional Pedantic Details: The exchange of view confirm messages is not strictly necessary for safety and can be optimized out of the protocol, but including them simplifies our safety proof by ensuring that if a correct replica begins accepting messages in new view v, then no other correct replica will accept messages in view v with a different base history. This step allows replicas to consider a confirmed view change to be functionally equivalent to a commit certificate for all requests in the base history of the new view.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.openssl.org/" />
		<title level="m">OpenSSL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://www.sei.cmu.edu/about/press/insider-2005.html" />
		<title level="m">US secret service report on insider attacks</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fault-scalable byzantine fault-tolerant services</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abd-El-Malek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wylie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2005-10">Oct. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the implementation of n-version programming for software fault tolerance during execution</title>
		<author>
			<persName><forename type="first">A</forename><surname>Avizienis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE COMPSAC</title>
		<meeting>IEEE COMPSAC</meeting>
		<imprint>
			<date type="published" when="1977-11">Nov. 1977</date>
			<biblScope unit="page" from="149" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Commercial fault tolerance: A tale of two systems</title>
		<author>
			<persName><forename type="first">W</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Spainhower</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TODSC</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="87" to="96" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Threat assessment of malicious code and human threats</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bassham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Polk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>NIST, Computer Security Division</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A new paradigm for collision-free hashing: Incrementally at reduced cost</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Micciancio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT97</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Practical byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="1999-02">February 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Practical Byzantine fault tolerance and proactive recovery</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
			<publisher>ACM TOCS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">HQ replication: A hybrid quorum protocol for Byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shrira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Best-case complexity of asynchronous Byzantine consensus</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dutta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vukolić</surname></persName>
		</author>
		<idno>EPFL/IC/200499</idno>
	</analytic>
	<monogr>
		<title level="j">EPFL</title>
		<imprint>
			<date type="published" when="2005-02">Feb. 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Consensus in the presence of partial synchrony</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Linearizability: A correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. Sys</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Backtracking intrusions</title>
		<author>
			<persName><forename type="first">S</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An experimental evaluation of the assumption of independence in multi-version programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Leveson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Engineering</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="96" to="109" />
			<date type="published" when="1986-01">Jan. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">SafeStore: A Durable and Practical Storage System</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kotla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<meeting><address><addrLine>Monterey, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Kotla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<idno>: UTCS-TR-07-40</idno>
		<title level="m">Zyzzyva: Speculative byzantine fault tolerance. University of Texas at Austin</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">High-throughput byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kotla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DSN</title>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The part-time parliament</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOCS</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Lower bounds for asynchronous consensus</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FUDICO</title>
		<meeting>FUDICO</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="22" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Beyond one-third faulty replicas in Byzantine fault tolerant services</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Replication in the harp file system</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gruber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shrira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Byzantine quorum systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fast Byzantine consensus</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TODSC</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="202" to="215" />
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">NFS: Network file system protocol specification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Microsystems</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">InternetRFC</title>
		<imprint>
			<biblScope unit="volume">1094</biblScope>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The soft error problem: An architectural perspective</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Emer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Reinhardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Rethink the sync</title>
		<author>
			<persName><forename type="first">E</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Veeraraghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Speculative execution in a distributed file system</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2005-10">Oct. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Why do internet systems fail, and what can be done about it</title>
		<author>
			<persName><forename type="first">D</forename><surname>Openheimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ganapathi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USITS</title>
		<meeting>USITS<address><addrLine>Seattle,WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03">March 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Reaching agreement in the presence of faults</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1980-04">April 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">IRON file systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bairavasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">G A</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">BASE : Using abstraction to improve fault tolerance</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2001-10">October 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Deciding when to forget in the Elephant file system</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Santry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Feeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C</forename><surname>Hutchinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Veitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Carton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ofir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="1999-12">December 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: a tutorial</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Modeling the effect of technology trends on the soft error rate of combinational logic</title>
		<author>
			<persName><forename type="first">P</forename><surname>Shivakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kistler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DSN</title>
		<meeting>DSN</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Conflict-free quorum-based bft protocols</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
		<idno>2007-1</idno>
		<imprint>
			<date type="published" when="2007-08">August 2007</date>
		</imprint>
		<respStmt>
			<orgName>Max Planck Institute for Software Systems</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Understanding replication in databases and distributed systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wiesmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kemme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDCS</title>
		<meeting>ICDCS</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Explode: A lightweight, general system for finding serious storage system errors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Using Model Checking to Find Serious File System Errors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Twohey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Separating agreement from execution for byzantine fault tolerant services</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
