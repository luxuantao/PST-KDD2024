<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Research on Trustiness of Software Behavior Based on Cross-References</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Linlin</forename><surname>Ci</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Research on High Technology Information Institute of Beijing</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Liping</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Department</orgName>
								<orgName type="institution">Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Research on Trustiness of Software Behavior Based on Cross-References</title>
					</analytic>
					<monogr>
						<idno type="ISSN">1738-9984 IJSIA</idno>
					</monogr>
					<idno type="DOI">10.14257/ijsia.2015.9.5.10</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Software behavior</term>
					<term>trusted computing</term>
					<term>cross-reference</term>
					<term>reverse analysis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Trustiness of software dynamic behavior is always the research hotpot and difficult point in the field of trusted computing. Dynamic trustiness model of software behavior relies on three basic aspects including the extraction and description of intended software behavior, real-time monitoring of software behavior and a contrastive analysis of intended software behavior and running-time behavior. It is a hard nut to extract and describe intended software behavior. In our paper, we present a method of extracting and describing of software trajectory based on cross-references of binary file. Our method is thinking from the perspective of the attacker, and constructing suitable size function chain starting at input variables. Then we optimize and simplify of the chain in order to make it practical. Our specific experiment indicates the effectiveness of our way.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Trusted computing is becoming a new trend of computer security fields. Trustiness of software is a focus of trusted computing research. Current static trusted authentication of software is via checking hash value of binary codes or critical files before software running. However, it just guarantees data integrity of program before running.</p><p>The aim of dynamic trusted authentication of software is to make sure the real time behavior of software according to expecting behavior. Dynamic trusted authentication is an unavoidable obstacle in the trusted computing field. Dynamic trustiness model of software behavior depends on three key aspects, including the extraction and description of intended software behavior, real-time monitoring of software behavior and a contrastive analysis of intended software behavior and running-time behavior. How to abstract and describe the behavior of software is the paramount task of dynamic authentication. The accuracy and simplicity of the software behavior affect validity and practicability of the model. There is no generally acceptable theoretical method and the theoretical research lags behind the technical practice.</p><p>In our article, we present a means of extracting and describing of software trajectory based on cross-references of binary file. Our method is thinking from the perspective of the attacker, and constructing suitable size function chain starting at input variables. Then we optimize and simplify of the chain in order to make it practical and valid. Our specific experiment indicates the effectiveness of our way.</p><p>In recent years, many artful methods based on dynamic software behavior have been proposed for defending against these software abnormal behaviors; these include subverting the intended data flow in the program, subverting machine-code execution. For example, <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12]</ref>. In general, the methods of software behavior were two patterns. Both of them are supported by reverse technology.</p><p>One of the patterns is that based on vitual technology, namely, in the vitual environment, researchers observe and study the behavior of the software, or, researchers</p><p>Copyright â“’ 2015 SERSC implant codes to source codes and set checking points. And researchers will propose various intelligent learning algorithms to the modeling of software motion. But this pattern is not having completeness of the behavior. It depends on specific input. Dynamic analysis involves allowing the malware to execute in a carefully controlled environment (sandbox) while recording every observable aspect of its behavior using any number of system instrumentation utilities <ref type="bibr" target="#b21">[22]</ref>.</p><p>The other one is that based on these analytic techniques, these techniques include analysis of control flow, analysis data flow, codes dependence. Researchers divide the whole disassembly code into basic blocks and analyze control flow between basic blocks. Data flow analysis is different from control flow. Data flow is following with interest of data changes and relationships of data objects. Data flow analysis is complex than analysis of control flow. The most complex one is analysis of code dependence. It shows both information about control flow and data flow. This pattern is having completeness of the software behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Works</head><p>Study of software behavior involves four aspects works. The theoretic research is lag behind the actual technology. These theoretic models are based on statistics model <ref type="bibr" target="#b13">[14]</ref>, fuzzy mathematics model <ref type="bibr" target="#b14">[15]</ref>, subjective logic model <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>, software behavior model <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">18]</ref>, and finite state automaton model <ref type="bibr" target="#b18">[19]</ref>.</p><p>The research area of subverting control flow and data flow gives us an angle of attacker' view <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>. M. Abadi, et al., has present two important papers. The one illustrates the theory of secure control flow <ref type="bibr" target="#b19">[20]</ref>. In this article, they gives us the basic theory with precise and rigorious formulations of hypotheses and guarantees. And another shows us the principles, implementations and applications of control -flow. In companion paper, they regard that the enforcement of control-flow integrity (CFI) is simple and practical for existing software to avert shadow calling stack and accessing control for memory regions. They explore the benefits for CFI and present an implementation <ref type="bibr" target="#b20">[21]</ref>.</p><p>Reverse technology is often to facilitate understanding of programs when source code is unavailable. Common situations in which disassembly is used include these: analysis of malware, closed-source software for vulnerabilities, closed-source software for interoperability. That is a very important supporting technology <ref type="bibr" target="#b21">[22]</ref>. Static analysis attempts to understand the behavior of a program simply by reading through the program code, which, in the case of malware, generally consists of a disassembly listing. Disassembly listings also provide the only means to determine exactly how a compiler has chosen to order all of the variables declared globally or within functions. Understanding the spatial relationships among variables is often essential when attempting to develop exploits. Ultimately, by using a disassembler and a debugger together, an exploit may be developed <ref type="bibr" target="#b21">[22]</ref>.</p><p>The system call sequence is used to depict software behavior. It is also for this reason; the extracting and describing of software trajectory must match needs of practicability. The research on system call is indispensable. Remarkable works include Forrest, et al., <ref type="bibr" target="#b0">[1]</ref>, Giffin, et al., <ref type="bibr" target="#b22">[23]</ref>, Spivey <ref type="bibr" target="#b23">[24]</ref>, Bond and McKinley <ref type="bibr" target="#b24">[25]</ref>. Forrest firstly proposed distinguishing program self using system call. <ref type="bibr">Giffin</ref> Of course, other skill is indispensable, such as software testing technology and hardware technology <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b12">13]</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Analysis of Software Defects</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">The View of Program Generation</head><p>In a traditional software development model, compilers, assemblers, and linkers are used by themselves or in combination to create executable programs. The third-generation languages are generally platform independent, though programs written using them may be platform dependent as a result of using features unique to a specific operating system <ref type="bibr" target="#b21">[22]</ref>. So the software defects are associate with these factors, these include, operation system, compilers, assemblers, linkers, CPU and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The View of Attacker</head><p>How did the attacker make it after they have gotten the fundamental principles? We have made synthesis of responsible disclosure. Briefly, there are 4 common steps. The first step in the process is to discover a potentially exploitable condition in a program. This is often accomplished using dynamic techniques such as fuzzing <ref type="bibr" target="#b21">[22]</ref>. Secondly, attackers analyze the control flow of software and master the control flow in order to discover vulnerabilities. In addition, recognizing input data of application program. Thirdly, tracing the input data until discovering the hole of the software. Finally, attackers inject illegal code and hijack the legal control flow. So, we assert that attackers can not directly modify the PC and reserved registers without key variable data. And now, let me review previous meaningful work. The enforcement of control flow integrity is an effective method adopted for software behavior. A control flow graph is considered as the normal behavior of software after statically specified. We suppose that the software is trusted when the program run dynamically follows the former path. Step 2. Preliminary analysis of Binary File by IDA pro IDA is a comprehensive and recursive disassembler. It makes every effort to present code as close to source code as possible. It also goes to great lengths to annotate generated disassemblies with not only datatype information but also derived variable and function names. We mainly use the information of data cross-reference and code cross-reference in our analysis of intended software behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The Models of Extracting the Software Intended Behavior</head><p>Step 3. Analysis of Cross-references Some of the more common questions asked while reverse engineering a binary are along the lines of "Where is this function called from?" and "What functions access this data?" These and other similar questions seek to catalog the references to and from various resources in a program. Two examples serve to show the usefulness of such</p><p>Copyright â“’ 2015 SERSC questions <ref type="bibr" target="#b21">[22]</ref>.</p><p>Program changed the status one after another along with the control-flow. Traditionaly, analyzer lists all the possible path including conditional branches, jumps, procedure calls and procedure returns. All the instructions likely composite infinite combination paths. Our strategy is used to optimize the set of combination paths, concentrating on the most possible path which contains data closely related to input. We must analyze all cross-references of code and data firstly, and then monitor all paths containing variables related to the input, including direct and indirect. The overhead of prior approach is huge and waste more expansive time .We only tried to record paths that are closely related to the input data without all variables in all paths. We focused on optimization program to eliminate the overhead and tracing time.</p><p>Step 4.Construct function chain Our object of study in our work is function chain. The function is a suitable size object in software behavior research. The cross-references of data, codes and functions are made from one address to another address in IDA. We exploit cross-references information that IDA makes available and the tools for accessing cross-references data. We choose to think of the addresses of functions as nodes in a directed graph and cross-references as the edges in that graph. In Figure <ref type="figure">2</ref>, it shows a simple graph that was consisted of three node and two directed edges. Firstly, we create a graph node for each function. Secondly, on the basis of the call cross-reference between two functions, we generated function call graph by connecting function nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Basic Directed Graph</head><p>Step 5. Optimization and simplification the function chain. In general, we will get a nasty mess graph. Because the compiler has inserted wrapper code for initialization, termination and configuration. We will optimize and simplify the whole function calling graph in virtue of graph theory and restrictive condition of input parameters. Finally, the whole calling graph will transformed into function chain with 6 functions at most.</p><p>Step 6. Abstraction and Description of the function chain.</p><p>We must abstract and description the function chain in order to contrast with the real-time behavior. We choose a linear structure to save the function nodes information. It shows in Figure <ref type="figure" target="#fig_2">3</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiment and Evaluation</head><p>In the previous section we provide 6 steps for abstracting intended behavior, based on short sequences of system calls. These sections propose the details and related experiment.</p><p>We ran the experiment on a laptop with i3-370M 2.4G processor and 4G memory. The operating system is windows 7 Ultimate. We selected the trivial example program from website in order to illustrate the problem. Figure <ref type="figure" target="#fig_4">4</ref> shows the source code of the program.  There are 4 function chains from function main (In Figure <ref type="figure">6</ref>). These four chains are the optimal chains. Then we save all the function nodes as shown in the Figure <ref type="figure" target="#fig_2">3</ref>. We give the node of layer2_2 as shown in the Figure <ref type="figure">7</ref>. In Figure <ref type="figure">8</ref>, our strategy shows higher radio of successful execution than nonoptimized program and program based on system calling, and our strategy shows lower radio of false execution as show in Figure <ref type="figure">9</ref>. In Figure <ref type="figure">10</ref>, our strategy shows lower number in 1-3T than non-optimized program and program based on system calling, and our strategy shows lower mean time execution as show in Figure <ref type="figure" target="#fig_0">11</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We present an effective strategy to abstract and describe the intended behavior of software. We are following 6 steps to build the trace model of software based on function chains. The evaluation of the example shows that our model is an effective model. However the experiment of our model was applied in trivial program. Our next target is complex program.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .Figure 1 .</head><label>11</label><figDesc>Figure 1. The Flow Chart of Abstracting Intended Behavior Figure 1. Shows 6 Steps of our Abstracting Model Step 1. Load the new file of binary file. The authors of application software seldom to provide the source code of their productions. It is virtually important to know the file type before loading the binary file.Step 2. Preliminary analysis of Binary File by IDA pro IDA is a comprehensive and recursive disassembler. It makes every effort to present code as close to source code as possible. It also goes to great lengths to annotate generated disassemblies with not only datatype information but also derived variable and function names. We mainly use the information of data cross-reference and code cross-reference in our analysis of intended software behavior.Step 3. Analysis of Cross-references Some of the more common questions asked while reverse engineering a binary are along the lines of "Where is this function called from?" and "What functions access this data?" These and other similar questions seek to catalog the references to and from various resources in a program. Two examples serve to show the usefulness of such</figDesc><graphic url="image-1.png" coords="3,121.90,390.60,341.40,136.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>. The precursor domain represents the function node before current function node. The subsequent domain represents the function node after current function node. The order domain represents the location order of current function in the function chain. And the name domain indicates the name of current function node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. The Storage Structure</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5</head><label>5</label><figDesc>shows the function calls of disassembling binary file of the source code after compiling by gcc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4</head><label>4</label><figDesc>Figure 4. Source Code</figDesc><graphic url="image-4.png" coords="5,199.45,189.70,186.35,213.85" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 Figure 7 .Figure 8 .Figure 9 .Figure 10</head><label>678910</label><figDesc>Figure 6. Function Chains</figDesc><graphic url="image-6.png" coords="6,149.40,77.50,286.45,73.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, et al., proposed considering system context. Spivey, et al., presented calling context tree (CCT). Bond and McKinley presented probabilistic calling context (PCC).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0">Copyright â“’ 2015 SERSC</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We wish to thank the colleagues in our research group for their help and encouragement.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Authors</head><p>Wei LIU, PhD. Candidate, Beijing Institute of technology. His researches include computer security and trusted computing.</p><p>Liping LIU, PhD. Candidate, Beijing Institute of technology. His researches include computer security and trusted computing.</p><p>Linlin CI is a professor and doctoral supervisor of Beijing Institute of technology. His research interests include computer security, sensor networks, and distributed system.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Sense of Self for Unix Processes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Hofmey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Somayaji</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the IEEE Symposium on Security and privacy</title>
				<meeting>eeding of the IEEE Symposium on Security and privacy<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996">1996. 2015</date>
			<biblScope unit="page" from="120" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hierarchiealand Dynamic Trusted Evaluation Model Based on Agent</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiaohui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xuehai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jjunfeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2009 Conference on Communication Faculty</title>
				<meeting>2009 Conference on Communication Faculty<address><addrLine>Irvine, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Scientific Research Publishing</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="312" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A direct path to dependable soft</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="78" to="88" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">An Approach to Measuring A System&apos;s Attack Surface</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Manadhata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Maxion</surname></persName>
		</author>
		<idno>CMU-CS07-146</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Handbook of Software Reliable Engineering</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Lyu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>McGraw-Hill Book Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Auto Whitebox Fuzz Testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16 th Annual Network &amp; Distributed System Security Symposium</title>
				<meeting>16 th Annual Network &amp; Distributed System Security Symposium<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Internet Society</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Time-Related Trust Model Based on Subjective Logic Theory</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 9 th International Conference for Yong Computer Scientists (ICYCS 2008)</title>
				<meeting>The 9 th International Conference for Yong Computer Scientists (ICYCS 2008)<address><addrLine>Hunan China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1902" to="1907" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Securing software by enforcing data-low integrity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Harris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Control-flow integrity: Principles, implementations and applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM computer and Communication Security conf</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Proof-carrying code</title>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 24thACM Symposium on Principles of Programming Languages</title>
				<meeting>eeding of the 24thACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1997-01">1997. January</date>
			<biblScope unit="page" from="106" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Efficient, verifiable binary sandboxing for a CISC architecture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
		<idno>MIT-LCS-TR-988</idno>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>MIT Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Native client: A sandbox for portable, untrusted x86 native code</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 30th IEEE Symposium on Security and Privacy</title>
				<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Adapting software fault isolation to contemporary cpu architectures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Biffle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Khimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pasko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schimpf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 19th conference on USENIX Security Symposium</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Probabilistic Trust Model for Handling Inaccurate Reputation Sources</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T L</forename><surname>Teacy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Trust Management, 3 rd International conference on iTrust Heidelberg Springer</title>
				<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="193" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A Complete fuzzy logical system to deal with trust management System. Fuzzy Sets and Systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Flaminioa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Pinnab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B P</forename><surname>Tiezzia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="page" from="1191" to="1207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Trust network analysis with subjective logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Josang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hayward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pope</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference Proceeding series, Proceedings of the 29th Australia Computer Science Conference (VOI.48)</title>
				<meeting><address><addrLine>Hobart, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="page" from="85" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Conditional Reasoning with Subjective Logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Josang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Multiple-Valued Logic and Soft Computing</title>
				<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="5" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Profiling Program Behavior for Anomaly Intrusion Detection Based on The Transition and Frequency Property of Computer Audit Data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">H</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Security</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="539" to="550" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Intrusion Detection via Static Analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wagller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Drew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
				<meeting>the IEEE Symposium on Security and Privacy<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="156" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A theory of secure control flow</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conf. on Formal Engineering Methods</title>
				<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Control-flow integrity: Principles, implementations and applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM computer and Communication Security conf</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The IDA Pro Book</title>
		<author>
			<persName><forename type="first">C</forename><surname>Eagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Pollock</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Environment-Sensitive Intrusion Detection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8 th International symposium on Recent Advances in Intrusion Detection</title>
				<meeting>the 8 th International symposium on Recent Advances in Intrusion Detection<address><addrLine>Heidelberg Springer Berlin</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="185" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Fast, Accurate Call Graph Profiling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Spivey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="249" to="264" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Probabilistic Call Context</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22 nd Annual ACM SIGPLAN Conference on Object-oriented Programming systems and applications</title>
				<meeting>the 22 nd Annual ACM SIGPLAN Conference on Object-oriented Programming systems and applications<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="97" to="112" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
