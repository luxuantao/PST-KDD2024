<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Frequency and Risks of Changes to Clones</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nils</forename><surname>GÃ¶de</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Bremen</orgName>
								<address>
									<settlement>Bremen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rainer</forename><surname>Koschke</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Bremen</orgName>
								<address>
									<settlement>Bremen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Frequency and Risks of Changes to Clones</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">379753CC2E77F16CDF8597D14C2A394C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.7 [Software Engineering]: Distribution</term>
					<term>Maintenance</term>
					<term>and Enhancement-restructuring</term>
					<term>reverse engineering</term>
					<term>and reengineering Experimentation</term>
					<term>Measurement Software maintenance</term>
					<term>clone detection</term>
					<term>clone evolution</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Code Clones-duplicated source fragments-are said to increase maintenance effort and to facilitate problems caused by inconsistent changes to identical parts. While this is certainly true for some clones and certainly not true for others, it is unclear how many clones are real threats to the system's quality and need to be taken care of. Our analysis of clone evolution in mature software projects shows that most clones are rarely changed and the number of unintentional inconsistent changes to clones is small. We thus have to carefully select the clones to be managed to avoid unnecessary effort managing clones with no risk potential.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Code clones are similar fragments of source code. There are many problems caused by the presences of clones. Among others, the source code becomes larger, change effort increases, and change propagation bears the risk of unwanted inconsistencies-for example, incomplete removal of defects. Consequently, a variety of clone detection techniques and tools has evolved to identify duplicated source code within a system. In addition, various tools have been created that support developers in managing clones. These include refactoring support <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b12">12]</ref>, automated change propagation <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b33">33]</ref>, and change monitoring to prevent unintentional inconsistencies <ref type="bibr" target="#b30">[30]</ref>.</p><p>There certainly exist clones that are true threats to software maintenance. Nevertheless, recent research <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref> doubts the harmfulness of clones in general and lists numerous situations in which clones are a reasonable design decision. From the clone management perspective, it is desirable to detect and manage only the harmful clones, because managing clones that have no negative effects creates only additional effort.</p><p>Unfortunately, state-of-the-art clone tools detect and classify clones based only on similar structures in the source code or one of its various representations. When it comes to clone-related problems, however, the most important characteristic of a clone is its change behavior and not its structure. Only if a clone changes, it causes additional change effort. Only if a clone changes, unintentional inconsistencies can arise. If, on the other hand, a clone never changes, there are no additional costs induced by propagating changes and there is no risk of unwanted inconsistencies.</p><p>Our hypothesis is that many clones detected by state-ofthe-art tools are "structurally interesting" but irrelevant to software maintenance because they never change during their lifetime.</p><p>Up-to-date clone detectors can efficiently process and detect clones within huge amounts of source code, consequently delivering huge numbers of clones. In contrast, clone assessment and deciding how to proceed can be very costly even for individual clones as we have experienced with clones in our own code <ref type="bibr" target="#b11">[11]</ref>. Hence, having many unproblematic clones in the detection results creates enormous overhead for assessing and managing clones that do not threaten maintenance because they never change.</p><p>To gain a better understanding of clones' threat potential, we conducted an extensive study on clone evolution in different systems and performed a detailed tracking to detect when and how clones had been changed. For this study, we concentrated on two prominent clone-related problems-the additional change effort caused by clones and the risk of unintentional inconsistent changes. Our research questions are the following: Question 1 -How often are clones changed throughout their lifetime? Question 2 -How many changes to clones are unintentionally inconsistent?</p><p>Contribution. The contribution of our work is a detailed analysis of how individual clones were changed throughout their lifetime. This includes the frequency of changes and the risk of unintentional inconsistencies. We provide an evaluation of the threat potential of clones detected by a stateof-the-art tool.</p><p>Outline. The structure of this papers is as follows. Section 2 introduces important terminology and concepts. Related work is given in Section 3. Section 4 describes our technique to extract the necessary clone evolution data. The setup of our study is outlined in Section 5. The data we collected and our results are presented in Section 6. We discuss our results in Section 7. Our conclusions are provided in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">TERMINOLOGY</head><p>In this section, we introduce relevant terminology. Clone detection, representation, and analysis can be done on different abstractions of a system, each of which has advantages and disadvantages. Approaches may be based on text <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b15">15]</ref>, tokens <ref type="bibr">[9,</ref><ref type="bibr" target="#b18">18]</ref>, abstract syntax trees <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b13">13]</ref>, graphs <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b23">23]</ref>, or metrics <ref type="bibr" target="#b28">[28]</ref>. We use a token-based approach that treats the system's files as sequences of tokens. Tokenbased approaches are language independent-except for the lexer that translates source text into a sequence of tokensand scalable while maintaining a basic understanding of the program's structure.</p><p>A fragment is a contiguous section of source code. As such, a fragment has a well-defined start and end and is contained in exactly one file in exactly one version of the system. A fragment has an arbitrary number of ancestors which are its occurrences in the previous version of the system. Each fragment has zero or one descendant which is its occurrence in the next version of the system.</p><p>A clone pair relates two fragments that are similar to each other and are contained in the same version of the system. The degree of similarity is expressed by different types:</p><p>Type 1. The token sequences of both fragments are identical disregarding whitespace and comments.</p><p>Type 2. A type-1 clone pair, but values of identifiers and literals may differ.</p><p>Type 3. A type-2 clone pair with gaps, that is, some tokens exist in only one of the fragments.</p><p>In contrast to a clone pair, a clone class groups two or more similar fragments. Like a clone pair, we assign one of the three types to a clone class to describe the similarity between its fragments. Regarding type-3 clone classes, it is important that the clone-class relation is not transitivefragment a being similar to b and b being similar to c does not imply that a is similar to b. Details on how we construct type-3 clone classes are given in Section 4.2.</p><p>Cloned fragments and the relations between them can be represented as a hypergraph, where fragments are vertices, the clone-class relation are hyperedges connecting two or more fragments of the same version, and the ancestor relation are normal edges connecting two fragments from subsequent versions. Let this be the clone evolution graph.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows our visualization of a sample graph. Each horizontal layer represents a version of the system. Cloned fragments-the vertices-are represented as circles. Rectangles are clone classes (hyperedges) containing the respective fragments. A shaded rectangle indicates that the fragments of the clone class have been changed between this version (where the clone class is shaded) to the next. A light shade indicates a consistent change, that is, exactly the same modifications have been applied to each fragment of the clone A clone genealogy is a connected component in the clone evolution graph. As such, it is a set of classes all of which are connected by the ancestry of their fragments. For example, the graph in Figure <ref type="figure" target="#fig_0">1</ref> shows four clone genealogies.</p><formula xml:id="formula_0">v 4 v 3 v 1 v 2 cf = 2 cf = 0 cf = 3 cf = 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RELATED WORK</head><p>This section presents previous research related to ours regarding the impact of clones on maintainability. For a general overview of research on software clones please refer to <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b31">31]</ref>. Previous work can be roughly classified into two categories. First, studies targeted at clone evolution and the ways in which clones change. Second, studies analyzing the harmfulness of clones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Clone Evolution</head><p>One of the first studies on clone evolution has been conducted by Kim and her colleagues <ref type="bibr" target="#b20">[20]</ref>. They analyzed the lifetime, occurrence of consistent changes, and suitability for refactoring of clone genealogies in two small Java systems. Although their study has been a major inspiration, our work differs in the way that we use a more detailed clone tracking (based on individual fragments) and we analyze changes for individual genealogies in more detail.</p><p>Aversano and her colleagues <ref type="bibr" target="#b1">[1]</ref> extended Kim's study with focus on the consistency of changes. They inspected individual changes and classified them according to whether clones evolved independently or were unknowingly changed inconsistently. In contrast to our study, they inspected individual changes not considering repeated changes to the same clones. Furthermore, clones that never changed were not considered.</p><p>Bakota and colleagues <ref type="bibr" target="#b3">[3]</ref> analyzed change anomalies in the evolution of clones. They map individual fragments instead of clones classes between versions. In their case study, they found 60 anomalies in the evolution of Mozilla Firefox of which six have been classified as true defects. The change frequency of clones has not been investigated.</p><p>The consistency of changes to clones has been quantitatively investigated by Krinke <ref type="bibr" target="#b24">[24]</ref>. Analyzing changes to clones in five different systems, he found that the number of consistent changes and inconsistent changes are roughly the same. Clones that never change, repeated changes to the same clones, and harmfulness of changes have not been analyzed.</p><p>In one of our previous studies <ref type="bibr" target="#b8">[8]</ref> we analyzed clone evolution in nine different systems. Although we performed a quantitative comparison of change consistency, we did neither analyze the frequency of changes for individual clones nor evaluate the harmfulness of changes.</p><p>Thummalapenta and colleagues <ref type="bibr" target="#b32">[32]</ref> analyzed change patterns in the evolution of code clones. They found that most clones were consistently changed or deliberately evolved independently. Hence, most inconsistent changes were intentional. The change frequency of clones has not been considered.</p><p>While changes to clones have been analyzed in various studies, the clones that never change have been neglected. Furthermore, repeated changes of the same clone have not been analyzed so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Harmfulness of Clones</head><p>While it is frequently stated that clones negatively affect software maintenance, there is not much proof that they really do. Regarding the problem of clones increasing the effort to change the code, there is hardly any work to quantify the additional effort. While it is not known how much additional change effort is caused by clones and how many clones are responsible for this, previous studies <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b32">32]</ref> have shown that some additional effort must exists, since numerous consistent changes to clones have been detected.</p><p>Lozano and her colleagues <ref type="bibr" target="#b27">[27]</ref> analyzed whether functions change more often when having clones. Their initial results suggest that functions change more often when they have clones compared to when they do not have clones. Nevertheless, the following study by Lozano and Wermelinger <ref type="bibr" target="#b26">[26]</ref> showed that change effort did not increase for more than half of the methods despite having clones. Only recently, Juergens and Deissenboeck <ref type="bibr" target="#b16">[16]</ref> presented an analytical model to quantify the additional maintenance costs caused by clones. The model has not been evaluated yet.</p><p>Regarding the risk of unintentional inconsistent changes to clones, different studies have shown that this problem exists. Li and colleagues <ref type="bibr" target="#b25">[25]</ref> identified defects based on similar clones that have similar but not identical sets of identifiers. They found 87 defects when analyzing 955 suspicious clones. Bakota and colleagues <ref type="bibr" target="#b3">[3]</ref> detected six defects based on their analysis of 60 change anomalies in the evolution of clones. Clones in Linux and Eclipse have been analyzed by Jiang and colleagues <ref type="bibr" target="#b14">[14]</ref>. In addition to the clone itself, they analyzed each clone's context to find defects. Out of 1342 spurious clones and their context, they detected 62 defects. Juergens and his colleagues <ref type="bibr" target="#b17">[17]</ref> (with the help of system experts) checked clones that are similar but not identical for defects. Out of 1427 candidates, 107 were found to contain defects of different severity.</p><p>The studies show that at least some clones facilitate defects. Nevertheless, all studies except for the one by Bakota and his colleagues analyzed clones in a single version. It is thus possible that the defects were caused by something else than an inconsistent change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXTRACTING GENEALOGIES</head><p>This section explains how we extract the clone evolution graph from the history of a system. The process is based on our incremental clone detection algorithm for efficiently detecting clones in multiple versions of a system <ref type="bibr">[9,</ref><ref type="bibr" target="#b10">10]</ref>. The algorithm processes versions of the system one after another. For each version, the following steps are performed:</p><p>(1) Process changed files and update data structures.</p><p>(2) Detect clones for the current version.</p><p>(3) Map clones between previous and current version. These steps are repeated for every version until no more versions are available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Processing Changed Files</head><p>Processing changed files is done as in the algorithm's original version. We distinguish three primary ways in which a file can be changed: addition, deletion, and modification. Apart from that, the algorithm also supports renaming of files. Which files have been changed or renamed is given as input to our algorithm. The algorithm internally uses a suffix tree to detect duplication. For details on how changed files are processed and the suffix tree is updated, please refer to <ref type="bibr">[9,</ref><ref type="bibr" target="#b10">10]</ref>.</p><p>When a modified file is processed, we calculate the difference between the file's old and new version. This information is needed later when fragments are mapped. We use our implementation of Myers' algorithm <ref type="bibr" target="#b29">[29]</ref> which we adopted to work for token sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Detecting Clones</head><p>In this phase, the clones that exist in the current version of the system are detected using a two-step process. First, type-1 clones are extracted from the suffix tree. We deliberately do not extract type-2 clones at this point, because this yields repetitive structures with a high ratio of identifiers which are primarily irrelevant clones. By first extracting only type-1 clones, we ensure that there are identical parts of sufficient length, before allowing any differences. In the second step, neighboring type-1 clones are merged to larger clones of types 2 and 3.</p><p>We use a simple algorithm inspired by Baker's approach <ref type="bibr" target="#b2">[2]</ref> to extract type-1 clone classes (identical fragments) from the suffix tree. To exclude irrelevant clone classes (for example, where each fragment is a single token), we apply a minimum length that fragments are required to have. Note that this is not the minimum length for the final clones as specified by the user.</p><p>Detection of type-2 and type-3 clones is done by merging neighboring type-1 clones and inspired by previous work by Ueda and colleagues <ref type="bibr" target="#b34">[34]</ref>. The type-1 clone classes that have been extracted from the updated GST are first expanded to type-1 clone pairs. These pairs are sorted into buckets according to the two files that contain the fragments. Each bucket is sorted based on the location of the pairs' fragments.</p><p>Each bucket is processed separately. The pairs are processed in sequence. For each pair, the algorithm checks whether it can extend one of the previous pairs. Two fragments are close enough, if the distance d between the fragments equals or is less than the shorter of the two fragments. This is driven by the assumption that the differences may not be larger than the similarities. In practice, we have observed that the differences are always much less than the similarities if pairs are merged using this rule. If the corresponding fragments of both pairs are close enough, the clone pairs can be merged.</p><p>We provide an example in Figure <ref type="figure" target="#fig_1">2</ref> with two files A and B and three clone pairs a, b, c each of which has one fragment Using the described procedure, our algorithm establishes chains of clone pairs that can be merged into a single but larger clone pair. That is, the algorithm merges an arbitrary number of clone pairs into a single pair obeying a user-specified minimum length. The algorithm has worst case quadratic complexity with respect to the number of identical pairs. Nevertheless, the number of identical pairs is usually small and we exploit the sorting to eliminate unnecessary calculations where possible.</p><p>After the gapped clone pairs have been created, they are grouped again into clone classes according to their similarities. This is done based on the common subsequence of the pair's fragments. For a gapped clone pair that has been merged from smaller type-1 clone pairs, the common subsequence is the concatenated token seqeunce of the type-1 pairs. We combine the fragments of two pairs into a single clone class when the common subsequences of both pairs are identical. Finally, we check the type of each merged clone class. If the gaps-the non-identical parts-between the fragments consist of only identifiers and literals, the clone class is of type 2, otherwise of type 3.</p><p>The final set of clones contains type-1 clone classes (the ones initially extracted), as well as type-2 and type-3 clone classes that have been merged. We then discard all type-1 clone classes whose fragments are shorter than a userspecified minimum clone length. This cannot be done earlier because we required the shorter type-1 classes for merging. Furthermore, we exclude all type-1 clone classes whose fragments are completely contained in the fragments of another clone class of type 2 or 3 (this can happen when the fragments of the type-1 clone class have been merged).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Mapping Clones</head><p>The goal of mapping fragments is to find for each fragment in the current version its ancestors in the previous version. Mapping fragments is relatively simple for files that are added or remain unchanged. All fragments in an added file have no ancestors. Note that duplicated files are also treated as added. For unchanged files, each fragment has exactly one ancestor which is found at exactly the same location.</p><p>For modified files, we exploit the difference information which has been calculated when changed files have been processed. For each fragment of the system's previous version that is contained in a modified file, we calculate its occurrence in the current version using the difference information being a list containing information about added or deleted token chunks. The occurrence is calculated by processing all modifications that affect the fragment. If tokens are added or deleted before the fragment, its location is adjusted accordingly. If tokens are removed or added within the fragments bounds, the fragment becomes shorter or longer, respectively. After the relevant modifications have been processed, the calculated occurrence of the fragment describes how the fragment "would look like" in the current version if it still existed.</p><p>After calculating a fragment's hypothetical occurrence, the algorithm checks whether there exists a cloned fragment in the system's current version that equals the calculated occurrence. The check can be done in constant time using a hash value computed from the fragments' locations. If such a fragment is found, the fragment from the previous version is added to the set of ancestors of the fragment in the current version.</p><p>Note that our mapping technique is independent from the source of the difference information. We currently use a standard differencing algorithm, but the information might also come from other sources, for example an IDE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">STUDY SETUP</head><p>This section describes the setup that we used to collect the data we need to answer the research questions. The setup includes our choice of subject systems, parameters for our clone detection tool, and an overview of our procedure to collect relevant data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Subject Systems</head><p>We used the following three subject systems for our study.</p><p>â¢ Our first subject system is our token-based clone detection tool, clones, itself. clones is written in Ada and part of the Bauhaus project<ref type="foot" target="#foot_0">1</ref> . We included this system, because our knowledge of the code allows us to much better assess clones and changes to clones in the code.</p><p>â¢ The second system is the web server httpd. <ref type="foot" target="#foot_1">2</ref> httpd is part of the Apache project and written in C.</p><p>â¢ Our third subject system is JabRef. <ref type="foot" target="#foot_2">3</ref> JabRef is a bibliography manager written in Java.</p><p>We chose these systems, because they have been used in some previous studies including ours <ref type="bibr" target="#b8">[8]</ref>. All systems are mature and have a reasonably long history. Each system has had a multitude of developers contributing and is of reasonable size. This mitigates the threat that a system is more or less maintained by a single developer who is an expert regarding every part of the system. For clones and JabRef, 15 distinct developers contributed changes relevant to our study. For httpd, 45 developers were involved in maintenance.</p><p>When analyzing clone evolution based on multiple versions of a system's source code, the interval between each pair of consecutive versions is of great importance. Increasing the interval between versions leads to multiple changes being merged into a single change and consequently results in loss of detail. To capture data with the highest degree of detail that is available, we consider each individual commit to the system's repository as a version. We excluded commits that did not change source files relevant to our analysis.</p><p>In addition to the interval between consecutive versions, we require a first and a last version that frame the period of the system's lifetime that we analyze. The number of versions that we can analyze is limited by our hardware. We chose to analyze all projects over the period of five years, starting from the very first version in 2005 to the very last version in 2009. Although more versions could have been analyzed for smaller projects, we chose the same scope for all subject systems to make the results comparable. Table <ref type="table" target="#tab_0">1</ref> summarizes our subject systems and details about the versions we have analyzed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Clone Detection Parameters</head><p>This section describes the parameters that we used to extract the relevant clone evolution data.</p><p>Exclusion of header files. For this study, we were interested in clones and changes that affect the systems' logic. We excluded all header files (*.h) from httpd and all Ada specification files (*.ads) from clones.</p><p>Exclusion of generated code. Generated code is not maintained by hand and thus, most problems caused by clones do not apply to generated code. Especially consistent and inconsistent changes to automatically generated files are not relevant to our study. We therefore exclude all generated files from our analysis. For clones all generated files are a kept in a single directory which we excluded. Regarding the other systems, we identified generated files by searching directory and file names as well as comments inside a file for indications.</p><p>Method Separation. Due to a token-based clone detector's missing knowledge about syntactic structures, clones may embrace more than a single method or function in the source code, that is, clones may start in one method and continue into the next method. To eliminate these artifacts, we preprocess the token sequence of each file before clone detection. We use regular expressions to identify the boundaries of methods and functions and insert unique sentinel tokens that can never be part of a clone. This procedure ensures that clones do not cross method boundaries. For httpd, we used a heuristic to identify the boundaries in the presence of preprocessor directives.</p><p>Token Exclusion. Another source of less relevant clones are reoccurring patterns imposed by the programming language. Like method separation, this step preprocesses each file's token sequence before clones are detected. This step excludes all include-directives in the C code, with-statements in the Ada code, and import-statements in the Java code. Clone types. This parameter determines which types of clones are detected and included in the clone evolution model. In this study, we consider two possible settings for this parameter. The first setting detects only type-1 clones. The second setting detects clones of type 1, 2, and 3. We deliberately analyzed the systems using both settings to evaluate their impact on the results.</p><p>Minimum clone length. This value determines how many tokens a clone needs to have to be considered as relevant. This value is of major importance since it influences the results significantly. Choosing a smaller value increases the recall because more clones are found that would not be found otherwise. Choosing a larger value increases the precision because fewer shorter clones are detected that just happen to be similar due to common programming patterns. We decided to use three distinct values. This allows us to compare the impact of the minimum length on the results. The values we chose are 30, 50, and 100 tokens.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Procedure</head><p>This section describes the overall procedure we used during our analysis. The process is illustrated in Figure <ref type="figure">3</ref>.</p><p>(1) We extracted the relevant versions of each subject system from its subversion repository and stored them locally. This step is necessary since fast access to the source codefor detection and analysis-is of great advantage. It allows to repeatedly access the source code without the overhead of accessing a distant repository. Note that we store only changed source code for each version, keeping the space requirement low. This step had to be done only once for each system, whereas every following step had to be done for each combination of parameters.</p><p>(2) We used our incremental detection algorithm ida to extract the clone evolution data as described in Section 4.</p><p>(3) We used our tool cyclone to analyze and visualize the evolution data. This includes creation of genealogies, calculating change frequencies, and support for manual inspection of clones and changes to clones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RESULTS</head><p>This section presents the results of our case study and describes the measurements we used to answer our research questions. We first quantified the relevant data to provide an overall impression of the cloning situation in our subject systems. For each subject system and each possible combination of clone type and minimum length, we calculated the total number of clone classes aggregated over all versions, the number of genealogies that were obtained from linking the clone classes, and the number of situations in which a clone class was changed. Consider our example of an evolution graph in Figure <ref type="figure" target="#fig_0">1</ref>. That graph contains 18 clone classes which are grouped into four distinct genealogies based on the ancestry of their fragments. There are six situations in which clone classes have been changed, indicated by the shaded clone classes.</p><p>The corresponding quantities for our subject systems are given in Table <ref type="table" target="#tab_1">2</ref>. Not surprisingly, increasing the minimum clone length reduces the number of detected clones for each system. When searching for all types of clones, more clones are detected compared to only looking for type-1 clones. For every system, the number of genealogies is proportional to the number of detected clones. Nevertheless, the number of clone classes for each genealogy differs between the systems. In clones, each genealogy embraces roughly 100 clone classes, in httpd 1000 clone classes, and in JabRef 200 clone classes. Although we have analyzed only twice as many versions of httpd than of the other systems, the number of clone classes per genealogy is ten (five) times higher in httpd. This may be due to clones in httpd changing less frequently compared to the other two systems. If clones change less, genealogies are more stable, that is, new genealogies appear only rarely and existing genealogies disappear only rarely. Consequently, genealogies contain more clone classes due to their longer life expectancy. This is supported by the number of changes displayed in the last column of Table <ref type="table" target="#tab_1">2</ref>. The number of situations in which clones were changed is not significantly higher for httpd compared to the other systems-although we have analyzed more than twice as many versions for httpd and the number of detected clone classes is significantly higher.</p><p>In summary, the cloning situation is quite different for our subject systems. clones contains comparatively few clones which are, however, changed more frequent. httpd has the highest clone density but clones are changed less frequently. JabRef falls in-between those two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Change Propagation</head><p>We now use the information about clone genealogies and changes to clones to answer Question 1 and estimate the additional costs of change propagation caused by clones. We assume that clones may cause additional change effort<ref type="foot" target="#foot_3">4</ref> only when they are modified. Hence, clones that are never changed can never induce costs for change propagation.</p><p>To analyze how often clones are changed during their lifetime, we counted the number of changes for each genealogy. Let the change frequency (cf ) of a genealogy be the number of the genealogy's clone classes marked as changed. Change frequencies are also given for the genealogies in our example shown in Figure <ref type="figure" target="#fig_0">1</ref>. The number of genealogies and its percentage compared to all genealogies are shown in Table <ref type="table" target="#tab_2">3</ref> for each change frequency. We chose to include these detailed results because the choice of clone detection parameters influences the results and different use cases may require different parameter settings. If furthermore allows to estimate the impact of changing a given parameter. The number of genealogies with a change frequency higher than 5 have been combined due to space limitation. We provide averages at the bottom of the table. The * represents the combination of all values.</p><p>Never changed. We first look at the clones that never changed. The column labeled "0" shows how many genealogies were never affected by change during their lifetime. The next column to the right gives the percentage when compared to the number of all genealogies. The values indicate that for httpd and JabRef, more than half of the clone genealogies were never changed during their lifetime. These numbers tell us that roughly half of the clones have-under no circumstances-induced costs for change propagation. For clones, 35.1% of the genealogies were never changed. This may be due to the high number of changes-considering clones' size and the number of versions analyzed-compared to the other systems. Taking the average of all measurements, 47.5% of all genealogies were never changed.</p><p>The numbers are almost the same, independent of whether we consider only type-1 clones or clones of all types. Increasing the minimum length of clones reduces the percentage of genealogies that are never changed. We think this is due to longer clones being more susceptible to change. When the smaller clones are not considered, the remaining longer ones are more likely to be affected by changes.</p><p>Changed once. Apart from the genealogies that never changed, the genealogies that changed only once are of interest to us. During the lifetime of these genealogies, there has been a single change applied to one clone class of the genealogy. Assuming that removing a clone requires changing it at least once, genealogies that were changed only once did not cause additional costs compared to when the clone would have been removed. It is, however, debatable, whether removing a clone or performing an arbitrary change to it requires more effort.</p><p>In clones 46.6%, in httpd 38.7%, and in JabRef 35.6% of the genealogies were changed exactly once. For clones the number of genealogies changed once is higher than the number of genealogies that never changed. For the other two systems, more genealogies were never changed than changed </p><p>once. The overall average of genealogies that changed exactly once is 40.3%, being almost as high as the percentage of clones that never changed. The type of clones has only a minor impact on the results. When considering only type-1 clones, 41.2% of the genealogies were changed exactly once. Considering all types of clones, 39.3% of genealogies were changed once. Increasing the minimum length of clones also increases the percentage of genealogies changed once. Interestingly, this is the inverse compared to the genealogies that never change, where the percentage of genealogies decreased as the minimum length is increased.</p><p>Changed more than once. The remaining category are clone genealogies that were changed more than once. Table <ref type="table" target="#tab_2">3</ref> lists the number of genealogies for change frequencies from 2 to 5 and the aggregated number of genealogies that changed more than five times. In general, the number of genealogies decreases as the change frequency increases. While there are still some genealogies that changed twice (7.5%) or thrice (2.7%), higher change frequencies are only scattered. Clone genealogies that change multiple times are likely to increase the change effort and should thus be regarded as harmful clones. These clones should be inspected and removed where possible.</p><p>When considering all types of clones, the percentage of genealogies that are changed more than once increases compared to considering only clones of type 1. Increasing the minimum length of clones also increases the number of genealogies that are changed more than once.</p><p>In general, switching from type-1 clones to clones of all types decreases the percentage of genealogies that were never changed or changed only once and increases the percentage of genealogies that were changed more than once. Increasing the minimum length of clones decreases the percentage of genealogies that are never changed while increasing the percentage of all genealogies that changed at least once. We believe that this is caused by the increased likelihood of larger clones being affected by change. Excluding clones of shorter length-most of which are not changed-leaves only the longer clones that are more susceptible to change due to their increased length.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Unintentional Inconsistencies</head><p>Apart from increasing the change effort, clones are also said to facilitate problems caused by unintentional inconsistent changes. To explore this assumption and to answer Question 2, we analyzed the changes to clones in detail. Unfortunately, manual assessment requires significant effort and is always threatened to be biased. From our experience we know, that assessing the impact of changes to code we are not familiar with is hardly possible for the majority of changes. To ensure familiarity with the code and its history, we restricted this part of our study to the system clones. Consequently, we are in a much better position to judge the changes and to explain our findings than if we were analyzing an unfamiliar system. The disadvantage of studying clones is, that some of its developers were aware of clonerelated problems (see our threats to validity in Section 6.3).</p><p>For assessment, we used only a single parameter setting to keep the assessment effort manageable. We chose to look at changes to type-1 clones only, because having identical fragments before the change makes the evaluation of the change itself much easier. For the minimum clone length, we chose 50 tokens. This setting provided us with a total number of High: The change must have been consistent. The inconsistency may cause the program to crash or produce wrong results.</p><p>The following paragraphs summarize the results of our analysis of changes to clones.</p><p>Consistent changes. Our objective is to identify unintentional inconsistent changes within the set of all changes. Consequently, we first removed all consistent changes-that is, changes where exactly the same modifications have been done to each fragment of the clone class. In total, 173 (56.9%) of the changes were consistent. The remaining 131 inconsistent changes were inspected manually.</p><p>Semantic-preserving. Inconsistent changes are detected based on the changes to the token sequences of the respective fragments. However, not every change to the token sequence changes the semantic of the program. For example, the rewriting of the parameter list as shown in Figure <ref type="figure">4</ref> does not change the semantic (in is the default mode for parameters in Ada), but may still be responsible for an inconsistent change. If semantic-preserving changes are unwanted inconsistencies, their severity can be only low.</p><p>We manually checked each inconsistent change whether it altered the semantic of the program or not. We found that almost half (51 out of 131) of the inconsistent changes did not change the semantic of the program. Many of the inconsistencies resulted from unused variable declarations or unnecessary uses of fully qualified names being removed.</p><p>Unwanted Inconsistencies. The final and most important assessment for each change is whether it features a missing change propagation and if it does, whether the severity is low or high. An example for an inconsistency with high severity is shown in Figure <ref type="figure">5</ref>. The missing check to prevent Ceiling_Prime being called with 0 (the type Positive Analyzing the 131 inconsistent changes, we found that 45 of them were unintentionally inconsistent. This amounts to 14.8% of the total number of changes to clones. Regarding severity, four out of five unwanted inconsistencies had low severity-for example changes to debugging code. Of all 36 changes classified as low, 20 are also semantic-preserving. In total, only 9 inconsistencies with high severity were found. This amounts to 3% of all changes. Table <ref type="table" target="#tab_3">4</ref> summarizes our results regarding the classification of changes. Note that changes may belong to multiple categories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Threats to Validity</head><p>There are certain threats to the validity of our results. Clone detection parameters. As with most studies on clones, the parameters used for detecting clones have a major impact on the results. We deliberately used different combinations of parameters to analyze their impact. This included the type of clones that were detected and the minimum length that clones were required to have. We presented detailed results in Table <ref type="table" target="#tab_2">3</ref> and described the impact of the parameters.</p><p>Precision. The precision of a clone detection tool influences the validity of the results. Although token-based clone detection has-in general-lower precision than approaches using abstract syntax trees or graphs, we carefully selected our parameters to exclude irrelevant clones from the results. Furthermore, we used a novel approach that requires clones to have identical parts of sufficient length to detect type-2 and type-3 clones-a frequent source of irrelevant clones using traditional approaches. One of the authors manually inspected a sample of clones to ensure that detected clones are relevant. The only clones we found to be less relevant are those in handling of command line parameters.</p><p>Study period. The part of a system's history that we used for our study also has an impact on the result. For every subject system, we have analyzed five years of its history to reduce the impact of special phases (e.g., major refactorings). Using only a part of a system's history also crops genealogies, that is, genealogies might have existed before the beginning of the study period and might exist beyond the end of the study period. When considering only genealogies that appear after the first version and disappear before the last version of the study period, the majority of genealogies has a change frequency of 1 (instead of 0). Nevertheless, the percentage of genealogies changed more than once remains   almost the same. Consequently, the ratio between genealogies changed never or once and genealogies changed more than once remains also roughly the same.</p><p>Mapping. The mapping between fragments of consecutive versions is another potential threat to the validity. As genealogies are created based on the mapping of fragments, a missing connection will break genealogies apart, leaving two genealogies each of which has a change frequency equal or less to the combined genealogy. The reason for an incomplete mapping can be the algorithm to calculate differences between token sequences-which has to deal with ambiguous situations-and clone classes becoming left-extensible or right-extensible due to changes or removal of fragments. However, according to our experience from previous studies and careful analysis of the clone evolution data, we have found that these situations are very rare.</p><p>Analyzing clones. Another threat may arise from the analysis of our own program clones. Although 15 different developers have contributed to clones, most of them knew about clone-related problems-not saying they were aware of them during development. This might have an impact on the number of unintentional inconsistencies. Thus, the percentage of unwanted inconsistencies might be higher for projects where developers are completely unaware of clones.</p><p>Manual assessment. Manual assessment of changes to clones depends on the judges and their expertise. We have deliberately chosen a system we are familiar with to reliably judge the impact of changes. Furthermore, we applied clear assessment criteria that reduced ambivalent decisions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION</head><p>Clones are said to increase the change effort when software is maintained, because changes have to be propagated to all clones. However, looking at our results we have presented in Section 6.1, we found that almost half of the clones have never been changed during their lifetime. These clones have never caused additional costs for change propagation. Apart from the clones that never changed, another 40.3% changed only once during their lifetime.</p><p>We assume that removal is the only option to prevent additional change effort since semi-automated change propagation (e.g., <ref type="bibr" target="#b33">[33]</ref>) still requires effort for manual verification of the suggested propagation. We also assume that the additional effort caused by a single change to a clone class is less than the effort to remove the respective clones by refactoring. That means, for 87.8% of the clones (the ones that never changed or changed once), removal would not have been beneficial because the effort to remove the clones would have been larger than the additional change effort that would have been prevented. Only for the remaining 12.2% of clones that changed more than once, removal might have been beneficial. Furthermore, we counted all changes including those that are meant to be independent-that is, they do not need to be propagated to the other clones of the class. Hence, the 87.8% is an under-estimation of the true percentage.</p><p>Our results show that the major percentage of clones does not cause additional effort, independent of whether the clone is "structurally interesting" or not. Based on our findings, we suggest to consult change information when deciding which clones are relevant and which clones are not relevant. Although the data describe only the past evolution of clones, we believe it provides important information to predict their future evolution.</p><p>When a cloned fragment is changed, the change might need to be propagated to the other copies. If this is not done-or not done correctly-new problems may arise or existing problems might not be completely mitigated. We analyzed changes to clones in our own code and found that 14.8% of all changes were unintentionally inconsistent. Regarding severity, 11.8% of the unwanted inconsistencies had only low severity whereas only 9 (3.0%) of all changes were found to have high severity.</p><p>On the one hand, we can confirm the results of previous studies <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b25">25]</ref> that identified faults based on inconsistencies between clones or their contexts. There are clones that facilitate problems when being changed. On the other hand, our results show that 85.2% of the changes are consistent or intentionally inconsistent confirming findings of previous studies <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b32">32]</ref>. This is important for developing clone-management tools, because too many false alarms regarding potential problems caused by inconsistent changes may be counterproductive for the adoption of clone management in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>Code clones are said to cause a variety of problems among which are additional costs for change propagation and the risk of unintentional inconsistencies. We have analyzed clone evolution using the history of three subject systems to estimate the threat potential of clones. Regarding the additional change effort, the answer to Question 1 is that 87.8% of clones were never changed or changed only once during their lifetime. Thus, we cannot say that these clones caused additional change effort (assuming the effort to remove them equals the effort to change them once).</p><p>Regarding Question 2, the answer is that only 14.8% of all changes to clones are unintentionally inconsistent. Furthermore, only few of these changes have high severity, while the others are more or less cosmetic.</p><p>Please note that our study focused on two prominent clonerelated threats. Apart from these, there are other problems caused by the presences of code clones. These include, for example, increased system size and additional effort to read and understand the code. Hence, our results are not to be regarded as a general acquittal for clones.</p><p>The implication of our results is, that the history of clones provides important information to determine their relevance and threat potential. This is important regarding the increasing number of clone management tools. To successfully establish these tools in the daily maintenance practice, it is important to reliably identify the clones with high threat potential and not besiege maintainers with false alarms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of an evolution graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Merging clones</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>3 Figure 3 :</head><label>33</label><figDesc>Figure 3: Our analysis process</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 function 2 (i 1 function 3 Bi + 1 Figure 4 :</head><label>121314</label><figDesc>Figure 4: Semantic-preserving change</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 function C e i l i n g P r i m e 2 (</head><label>12</label><figDesc>Number : in P o s i t i v e )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>10 T 11 ( 2 (</head><label>10112</label><figDesc>a b l e S i z e : N a t u r a l := N a t u r a l F l o a t ( Number Of Tokens ) * 2 . 4 ) ; 12 begin 13 14 T a b l e S i z e := 15 C e i l i n g P r i m e ( T a b l e S i z e ) ; 16 . . . 17 end I n i t i a l i z e ; (a) Version i 1 function C e i l i n g P r i m e Number : in P o s i t i v e )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>10 T 11 ( 1 Figure 5 :</head><label>101115</label><figDesc>Figure 5: Unintentional inconsistency with high severity</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Subject systems used in our study</figDesc><table><row><cell>System</cell><cell cols="2">Lang. #Vers.</cell><cell cols="4">Revision First Last First Last â¼KLOC</cell></row><row><cell>clones</cell><cell>Ada</cell><cell>820</cell><cell>15271</cell><cell>28900</cell><cell>5</cell><cell>35</cell></row><row><cell>httpd</cell><cell>C</cell><cell cols="3">2186 208366 894526</cell><cell>187</cell><cell>218</cell></row><row><cell cols="2">JabRef Java</cell><cell>906</cell><cell>664</cell><cell>3150</cell><cell>52</cell><cell>127</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Detected clones and changes</figDesc><table><row><cell>System</cell><cell cols="5">Type Min. #Cl. Classes #Geneal. Changes</cell></row><row><cell>clones</cell><cell>1</cell><cell>30</cell><cell>101,807</cell><cell>876</cell><cell>736</cell></row><row><cell></cell><cell>1</cell><cell>50</cell><cell>32,131</cell><cell>317</cell><cell>304</cell></row><row><cell></cell><cell>1</cell><cell>100</cell><cell>9,315</cell><cell>86</cell><cell>90</cell></row><row><cell></cell><cell>1-3</cell><cell>30</cell><cell>109,714</cell><cell>1,027</cell><cell>923</cell></row><row><cell></cell><cell>1-3</cell><cell>50</cell><cell>49,888</cell><cell>523</cell><cell>544</cell></row><row><cell></cell><cell>1-3</cell><cell>100</cell><cell>19,708</cell><cell>189</cell><cell>238</cell></row><row><cell>httpd</cell><cell>1</cell><cell>30</cell><cell>1,723,091</cell><cell>1,532</cell><cell>678</cell></row><row><cell></cell><cell>1</cell><cell>50</cell><cell>743,762</cell><cell>742</cell><cell>388</cell></row><row><cell></cell><cell>1</cell><cell>100</cell><cell>198,295</cell><cell>245</cell><cell>168</cell></row><row><cell></cell><cell>1-3</cell><cell>30</cell><cell>2,163,465</cell><cell>1,902</cell><cell>990</cell></row><row><cell></cell><cell>1-3</cell><cell>50</cell><cell>1,211,477</cell><cell>1,145</cell><cell>717</cell></row><row><cell></cell><cell>1-3</cell><cell>100</cell><cell>433,733</cell><cell>461</cell><cell>369</cell></row><row><cell>JabRef</cell><cell>1</cell><cell>30</cell><cell>281,957</cell><cell>927</cell><cell>548</cell></row><row><cell></cell><cell>1</cell><cell>50</cell><cell>98,493</cell><cell>416</cell><cell>244</cell></row><row><cell></cell><cell>1</cell><cell>100</cell><cell>26,299</cell><cell>132</cell><cell>72</cell></row><row><cell></cell><cell>1-3</cell><cell>30</cell><cell>376,383</cell><cell>1,220</cell><cell>754</cell></row><row><cell></cell><cell>1-3</cell><cell>50</cell><cell>196,489</cell><cell>731</cell><cell>466</cell></row><row><cell></cell><cell>1-3</cell><cell>100</cell><cell>60,692</cell><cell>269</cell><cell>177</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Change frequency of clone genealogies</figDesc><table><row><cell>Change frequency</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Classification of changes in clones</figDesc><table><row><cell>Total</cell><cell cols="2">304 100.0%</cell></row><row><cell>Consistent</cell><cell>173</cell><cell>56.9%</cell></row><row><cell>Inconsistent</cell><cell>131</cell><cell>43.1%</cell></row><row><cell>Semantic-preserving</cell><cell>51</cell><cell>16.8%</cell></row><row><cell>Unintentional</cell><cell>45</cell><cell>14.8%</cell></row><row><cell>Low severity</cell><cell>36</cell><cell>11.8%</cell></row><row><cell>High severity</cell><cell>9</cell><cell>3.0%</cell></row><row><cell cols="3">expects numbers greater than 0) is inserted in only one of</cell></row><row><cell cols="3">the fragments making this an incomplete bug removal. The</cell></row><row><cell cols="3">change has high severity, because the change must be prop-</cell></row><row><cell cols="3">agated to all fragments. Unless the missing check is inserted</cell></row><row><cell cols="3">in all fragments, the program may crash when encountering</cell></row><row><cell>empty token sequences.</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.bauhaus-stuttgart.de</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://httpd.apache.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://jabref.sourceforge.net</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We refer to the act of changing the source code and exclude the effort to understand or test the code.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How clones are maintained: An empirical study</title>
		<author>
			<persName><forename type="first">L</forename><surname>Aversano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cerulo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parameterized duplication in strings: Algorithms and an application to software maintenance</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Clone smells in software evolution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bakota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ferenc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>GyimÃ³thy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Advanced clone-analysis to support object-oriented system refactoring</title>
		<author>
			<persName><forename type="first">M</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dagenais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>LagÃ¼e</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kontogiannis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WCRE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Clone detection using abstract syntax trees</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yahin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sant'anna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Managing code clones using dynamic change tracking and resolution</title>
		<author>
			<persName><forename type="first">M</forename><surname>De Wit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zaidman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Van Deursen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A language independent approach for detecting duplicated code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rieger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Demeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Evolution of type-1 clones</title>
		<author>
			<persName><forename type="first">N</forename><surname>GÃ¶de</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCAM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Incremental clone detection</title>
		<author>
			<persName><forename type="first">N</forename><surname>GÃ¶de</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Studying clone evolution using incremental clone detection</title>
		<author>
			<persName><forename type="first">N</forename><surname>GÃ¶de</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JSME</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Quo vadis, clone management?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Harder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>GÃ¶de</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IWSC</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Refactoring support based on code clone analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Higo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">3009</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">DECKARD: Scalable and accurate tree-based detection of code clones</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Misherghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Glondu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Context-based detection of clone-related bugs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Identifying redundancy in source code using fingerprints</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>CASCON. IBM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How much is a clone?</title>
		<author>
			<persName><forename type="first">E</forename><surname>Juergens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Deissenboeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SQM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Do code clones matter?</title>
		<author>
			<persName><forename type="first">E</forename><surname>Juergens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Deissenboeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hummel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">CCFinder: A multilinguistic token-based code clone detection system for large scale source code</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TSE</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cloning considered harmful&quot; considered harmful: patterns of cloning in software</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Kapser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Godfrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ESE</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An empirical study of code clone genealogies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sazawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Using slicing to identify duplication in source code</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Komondoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Survey of research on software clones</title>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Duplication, Redundancy, and Similarity in Software</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Merlo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Walenstein</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>number 06301 in Dagstuhl Seminar Proceedings</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Identifying similar code with program dependence graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WCRE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A study of consistent and inconsistent changes to code clones</title>
		<author>
			<persName><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
		<editor>WCRE. IEEE</editor>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">CP-Miner: Finding copy-paste and related bugs in large-scale software code</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Myagmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TSE</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Assessing the effect of clones on changeability</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lozano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wermelinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Evaluating the harmfulness of cloning: A change based experiment</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lozano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wermelinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nuseibeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MSR</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Experiment on the automatic detection of function clones in a software system using metrics</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mayrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An O(ND) difference algorithm and its variations</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Clone-aware configuration management</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Al-Kofahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Nguyen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">A survey on software clone detection research</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Cordy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Kingston, Ontario, Canada</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Queens University at</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">An empirical study on the maintenance of source code clones</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thummalapenta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cerulo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Aversano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ESE</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Managing duplicated code with linked editing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Toomim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Begel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Visual Languages and Human Centric Computing</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">On detection of gapped code clones using gap locations</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ueda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
		<editor>APSEC. IEEEy</editor>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
