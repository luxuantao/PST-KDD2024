<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Discrete logarithms in finite fields and their cryptographic significance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Odlyzko</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">AT&amp;T Bell Laboratories</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">AT&amp;T Bell Laboratories</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Discrete logarithms in finite fields and their cryptographic significance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D6448CA6DB8E835285FDD2BB3AB66D4A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Given a primitive element g of a finite field GF(q), the discrete logarithm of a nonzero element u ∈ GF(q) is that integer k, 1 ≤ k ≤ q -1, for which u = g k . The well-known problem of computing discrete logarithms in finite fields has acquired additional importance in recent years due to its applicability in cryptography. Several cryptographic systems would become insecure if an efficient discrete logarithm algorithm were discovered. This paper surveys and analyzes known algorithms in this area, with special attention devoted to algorithms for the fields GF( 2 n ). It appears that in order to be safe from attacks using these algorithms, the value of n for which GF( 2 n ) is used in a cryptosystem has to be very large and carefully chosen. Due in large part to recent discoveries, discrete logarithms in fields GF( 2 n ) are much easier to compute than in fields GF(p) with p prime. Hence the fields GF( 2 n ) ought to be avoided in all cryptographic applications. On the other hand, the fields GF(p) with p prime appear to offer relatively high levels of security.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The multiplicative subgroup of any finite field GF(q), q a prime power, is cyclic, and the elements g ∈ GF(q) that generate this subgroup are referred to as primitive elements. Given a primitive element g ∈ GF(q) and any u ∈ GF(q) * = GF(q) -{0}, the discrete logarithm of u with respect to g is that integer k, 0 ≤ k ≤ q -1, for which u = g k .</p><p>We will write k = log g u. The discrete logarithm of u is sometimes referred to as the index of u.</p><p>Aside from the intrinsic interest that the problem of computing discrete logarithms has, it is of considerable importance in cryptography. An efficient algorithm for discrete logarithms would make several authentication and key-exchange systems insecure. This paper briefly surveys (in Section 2) these cryptosystems, and then analyzes the known algorithms for computing discrete logarithms. As it turns out, some of them, including the most powerful general purpose algorithm in this area, have not been analyzed in complete detail before. Moreover, some of the analyses in the literature deal only with fields GF(p), where p is a prime. In cryptographic applications, on the other hand, attention has been focused on the fields GF( 2 n ), since arithmetic in them is much easier to implement, with respect to both software and hardware. Therefore we concentrate on the fields GF( 2 n ).</p><p>Several proposed algorithms for computing discrete logarithms are known. We briefly discuss most of them (including some unsuccessful ones) in Section 3. In Section 4 we present the most powerful general purpose algorithm that is known today, called the index-calculus algorithm, and analyze its asymptotic performance. Recently a dramatic improvement in its performance in fields GF ( 2 n ) was made by</p><p>Coppersmith <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>, and we discuss it in detail. In Section 5 we discuss several technical issues that are important to the performance of the index-calculus algorithm, such as rapid methods to solve the systems of linear equations that arise in it. In that section we also present several suggested modifications to the Coppersmith algorithm which appear to be unimportant asymptotically, but are of substantial importance in practice. We discuss them in order to obtain a reasonable estimate of how fast this algorithm could be made to run in practice. In Section 6 we estimate the running time of that algorithm for fields GF ( 2 n ) that might actually be used in cryptography. In Section 7 we briefly discuss the performance of the indexcalculus algorithms in fields GF(p) for p a prime. Finally, we discuss the implications of these algorithms for cryptography in Section 8. It turns out, for example, that the MITRE scheme <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b58">59]</ref> and the Hewlett-Packard chip <ref type="bibr" target="#b68">[69]</ref>, both of which use the field GF ( 2 127 ), are very insecure. Depending on the level of security that is desired, it seems that fields GF ( 2 n ) to be used ought to have n large, no smaller than 800 and preferably at least 1500. Furthermore, these values of n have to be very carefully chosen. On the other hand, it appears at this moment that the fields GF(p), where p is a prime, offer a much higher level of security, with p &gt; ∼ 2 500 adequate for many applications and p &gt; ∼ 2 1000 being sufficient even for extreme situations. The fields GF(p) appear at this moment to offer security comparable to that of the RSA scheme with modulus of size p.</p><p>It has to be stressed that this survey presents the current state of the art of computing discrete logarithms. Since the state of the art has been advancing very rapidly recently, this paper has already gone through several revisions. The most important of the new developments has certainly been the</p><p>Coppersmith breakthrough in fields GF ( 2 n ). Even more recently, there has been much less spectacular but still important progress in fields GF(p), which is briefly described in Section 7, and in methods for dealing with sparse systems of equations, which are discussed in Section 5, and which are crucial for the indexcalculus algorithms. It is quite likely that further progress will take place in discrete logarithm algorithms and so the cryptographic schemes described below will require the use of even larger fields than are being recommended right now.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Cryptographic systems related to discrete logarithms</head><p>One of the first published cryptosystems whose security depends on discrete logarithms being difficult to compute appears to be an authentication scheme. In many computer systems, users' passwords are stored in a special file, which has the disadvantage that anyone who gets access to that file is able to freely impersonate any legitimate user. Therefore that file has to be specially protected by the operating system.</p><p>It has been known for a long time (cf. <ref type="bibr" target="#b53">[54]</ref>) that one can eliminate the need for any secrecy by eliminating the storage of passwords themselves. Instead, one utilizes a function f that is hard to invert (i.e., such that given a y in the range of f, it is hard to find an x in the domain of f such that f (x) = y) and creates a file containing pairs (i, f (p i ) ), where i denotes a user's login name and p i the password of that user. This file can then be made public. The security of this scheme clearly depends on the function f being hard to invert.</p><p>One early candidate for such a function was discrete exponentiation; a field GF(q) and a primitive element g ∈ GF(q) are chosen (and made public), and for x an integer, one defines</p><formula xml:id="formula_0">f (x) = g x .</formula><p>Anyone trying to get access to a computer while pretending to be user i would have to find p i knowing only the value of g p i ; i.e., he would have to solve the discrete logarithm problem in the field GF(q).</p><p>Public key cryptography suffers from the defect that the systems that seem safe are rather slow. This disadvantage can be overcome to a large extent by using a public key cryptosystem only to distribute keys for a classical cryptosystem, which can then be used to transmit data at high speeds. Diffie and Hellman <ref type="bibr" target="#b22">[23]</ref> have invented a key-exchange system based on exponentiation in finite fields. (This apparently was the very first public key cryptosystem that was proposed.) In it, a finite field GF(q) and a primitive element g ∈ GF(q) are chosen and made public. Users A and B, who wish to communicate using some standard encryption method, such as DES, but who do not have a common key for that system, choose random integers a and b, respectively, with 2 ≤ a, b ≤ q -2. Then user A transmits g a to B over a public channel, while user B transmits g b to A. The common key is then taken to be g ab , which A can compute by raising the received g b to the a power (which only he knows), and which B forms by raising g a to the b power. It is clear that an efficient discrete logarithm algorithm would make this scheme insecure, since the publicly transmitted g a would enable the cryptanalyst to determine a, and he could then determine the key used by A and B. Diffie and Hellman <ref type="bibr" target="#b22">[23]</ref> have even conjectured that breaking their scheme is equivalent in difficulty to computing discrete logarithms. This conjecture remains unproved, and so we cannot exclude the possibility that there might be some way to generate g ab from knowledge of g a and g b only, without computing either a or b, although it seems unlikely that such a method exists.</p><p>The Diffie-Hellman key-exchange scheme seems very attractive, and it has actually been implemented in several systems, such as a MITRE Corp. system <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b58">59]</ref>. Moreover, Hewlett-Packard has built a special purpose VLSI chip which implements this scheme <ref type="bibr" target="#b68">[69]</ref>. However, these implementations have turned out to be easily breakable. It appears possible, though, to build a Diffie -Hellman scheme that is about as secure as an RSA scheme of comparable key size. This will be discussed at some length in Section 8.</p><p>Systems that use exponentiation in finite fields to transmit information have also been proposed. One is based on an idea due to Shamir <ref type="bibr">[37; pp. 345-346]</ref> and has been advocated in the context of discrete exponentiation by Massey and Omura <ref type="bibr" target="#b62">[63]</ref>. For example, suppose user A wishes to send a message m (which we may regard as a nonzero element of the publicly known field GF(q)) to user B. Then A chooses a random integer c, 1 ≤ c ≤ q -1, (c,q -1 ) = 1, and transmits x = m c to B. User B then chooses a random integer d, 1 ≤ d ≤ q -1, (d,q -1 ) = 1, and transmits y = x d = m cd to A. User A now forms z = y c ′ where cc ′ ≡ 1 ( mod q -1 ), and transmits z to B. Since</p><formula xml:id="formula_1">z = y c ′ = m cdc ′ = m d ,</formula><p>B only has to compute z d ′ to recover m, where dd ′ ≡ 1 ( mod q -1 ), since</p><formula xml:id="formula_2">z d ′ = m dd ′ = m .</formula><p>In this scheme it is again clear that an efficient method for computing discrete logarithms over GF <ref type="bibr">(q)</ref> would enable a cryptanalyst to recover the plaintext message m from the transmitted ciphertext messages m c , m cd , and m d .</p><p>Another scheme for transmission of information has been proposed by T. ElGamal <ref type="bibr" target="#b25">[26]</ref> and is in essence a variant of the Diffie-Hellman key distribution scheme. User A publishes a public key g a ∈ GF(q), where the field GF(q) and a primitive root g are known (either they are also published by A or else they are used by everyone in a given system), but keeps a secret. User B, who wishes to send m ∈ GF(q) to A, selects k at random, 1 ≤ k ≤ q -2 (a different k has to be chosen for each m) and transmits the pair (g k , mg ak ) to A. User A knows a and therefore can compute g ak = (g k ) a and recover</p><p>m. An efficient discrete logarithm algorithm would enable a cryptanalyst to compute either a or k, and would therefore make this scheme insecure also.</p><p>T. ElGamal <ref type="bibr" target="#b25">[26]</ref> has also proposed a novel signature scheme that uses exponentiation in fields GF(p), p a prime. User A, who wishes to sign messages electronically, publishes a prime p, a primitive root g modulo p, and an integer y, 1≤y≤p -1, which is generated by choosing a random integer a, which is kept secret, and setting y = g a . (The prime p and the primitive root g can be the same for all the users of the system, in which case only y is special to user A.) To sign a message m, 1 ≤ m ≤ p -1, user A provides a pair of integers (r,s), 1 ≤ r,s ≤ p -1, such that g m ≡ y r r s ( mod p) .</p><p>(2.1)</p><p>To generate r and s, user A chooses a random integer k with (k,p -1 ) = 1 and computes r = g k .</p><p>Since y = g a , this means that s has to satisfy</p><formula xml:id="formula_3">g m ≡ g ar + ks ( mod p) ,<label>(2.2)</label></formula><p>which is equivalent to m ≡ ar + ks ( mod p -1 ) .</p><p>(2.3)</p><p>Since (k, p -1 ) = 1, there is a unique solution to (2.3) modulo p -1, and this solution is easy to find for user A, who knows a, r, and k. An efficient discrete logarithm algorithm would make this scheme insecure, since it would enable the cryptanalyst to compute a from y. No way has been found for breaking this scheme without the ability to compute discrete logarithms, and so the scheme appears quite attractive. It is not as fast as the Ong-Schnorr-Shamir signature scheme <ref type="bibr" target="#b49">[50]</ref>, but since several versions of that scheme were recently broken by Pollard, it should not be considered for use at the present time. The ElGamal scheme appears to be about as secure as the RSA scheme for moduli of the same length, as we will see later, although it does expand bandwidth, with the signature being twice as long as the message.</p><p>The presumed intractability of the discrete logarithm problem is crucial also for the Blum-Micali construction <ref type="bibr" target="#b8">[9]</ref> of a cryptographically strong random number generator. What they show is that it is possible to compute a long sequence that is obtained deterministically from a short random sequence, and in which successive bits cannot be predicted efficiently from the preceding ones without the ability to compute discrete logarithms efficiently.</p><p>A scheme whose security is essentially equivalent to that of the Diffie -Hellman scheme was recently published by Odoni, Varadharajan, and Sanders <ref type="bibr" target="#b48">[49]</ref>. These authors proposed taking a matrix B over GF(p) which is the companion matrix of an irreducible polynomial f (x) of degree m over GF(p). The Diffie -Hellman scheme would then be implemented by replacing the primitive element g by the matrix B, so that pairs of users would transmit matrices B a and B b to each other, where a and b are the two random integers chosen by the two users. However, the matrix ring generated by B is isomorphic to the field GF(p m ), so this scheme does not provide any additional security. The more sophisticated scheme proposed in <ref type="bibr" target="#b48">[49]</ref>, with the matrix B being obtained from several companion matrices of irreducible polynomials of degrees m 1 , . . . , m s can also be shown to be reducible to the problem of computing discrete logarithms in the fields GF(p m i ) separately.</p><p>Finally, we mention that the ability to compute quantities generalizing discrete logarithms in rings of integers modulo composite integers would lead to efficient integer factorization algorithms <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b51">52]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Some special algorithms</head><p>In this section we discuss briefly some algorithms that apparently don't work very well and then we discuss a very useful algorithm that works well only when all the prime divisors of q -1 are of moderate size.</p><p>The first method we discuss was not designed as an algorithm at all. In a field GF(p), p a prime, any function from the field to itself can be represented as a polynomial. Wells <ref type="bibr" target="#b63">[64]</ref> has shown that for any u,</p><formula xml:id="formula_4">1 ≤ u ≤ p -1, if g is a primitive root modulo p, then one can write log g u ≡ j = 1 Σ p -2 ( 1 -g j ) -1 u j ( mod p) . (3.1)</formula><p>This formula is clearly useless computationally, but it is interesting that such an explicit form for the discrete logarithm function exists.</p><p>The Herlestam-Johannesson method <ref type="bibr" target="#b31">[32]</ref> was designed to work over the fields GF( 2 n ), and was reported by those authors to work efficiently for fields as large as GF ( 2 31 ). However, the heuristics used by those authors in arguing that the method ought to work efficiently in larger fields as well seem to be very questionable. As usual, GF( 2 n ) is represented as polynomials over GF( 2 ) modulo some fixed irreducible polynomial f (x) of degree n over GF <ref type="bibr" target="#b1">( 2 )</ref>. In order to compute the logarithm of h(x) to base x, Herlestam and Johannesson proposed to apply a combination of the transformations</p><formula xml:id="formula_5">h(x) → h(x) 2 r , h(x) → x -2 s h(x)</formula><p>so as to minimize the Hamming weight of the resulting polynomial, and apply this procedure iteratively until an element of low weight, for which the logarithm was known, was reached. There is no reason to expect such a strategy to work, and considerable numerical evidence has been collected which shows that this method is not efficient <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b66">67]</ref>, and is not much better than a random walk through the field. However, some unusual phenomena related to the algorithm have been found whose significance is not yet understood <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b56">57]</ref>. In particular, the algorithm does not always behave like a random walk, and its performance appears to depend on the choice of the polynomial defining the field. These observations may be due to the small size of the fields that were investigated, in which case their significance would be slight.</p><p>Another approach to computing discrete logarithms in fields GF( 2 n ) was taken by Arazi <ref type="bibr" target="#b2">[3]</ref>. He noted that if one can determine the parity of the discrete logarithm of u, then one can quickly determine the discrete logarithm itself. Arazi showed that one can determine the parity of discrete logarithms to base g fast if g satisfies some rather complicated conditions. Since being able to compute discrete logarithms to one base enables one to compute them to any other base about equally fast (as will be discussed in Section 5), it would suffice to find any g that satisfies Arazi's condition. However, so far no algorithm has been found for finding such primitive elements g in large fields GF( 2 n ), nor even a proof that any such elements exist. It was shown by this author that primitive elements g satisfying another set of conditions originally proposed by Arazi, which were more stringent than those of <ref type="bibr" target="#b2">[3]</ref>, do exist in fields GF( 2 n ) for 2 ≤ n ≤ 5, but not for 6 ≤ n ≤ 9. Thus while the ideas of <ref type="bibr" target="#b2">[3]</ref> are interesting and may be useful in future work, they appear to be of little practical utility at this moment.</p><p>We next discuss a very important algorithm that was published by Pohlig and Hellman <ref type="bibr" target="#b50">[51]</ref>, and whose earlier independent discovery they credit to Roland Silver. This algorithm computes discrete logarithms over GF(q) using on the order of √  p operations and a comparable amount of storage, where p is the largest prime factor of q -1. In fact, there is a time-memory tradeoff that can be exploited, and Pohlig and Hellman <ref type="bibr" target="#b50">[51]</ref> showed that if</p><formula xml:id="formula_6">q -1 = i = 1 Π k p i n i ,<label>(3.2)</label></formula><p>where the p i are distinct primes, and if r 1 ,...,r k are any real numbers with 0 ≤ r i ≤ 1, then logarithms over GF(q) can be computed in</p><formula xml:id="formula_7">O( i = 1 Σ k n i ( log q + p i 1 -r i ( 1 + log p i r i ) ) )</formula><p>field operations, using</p><formula xml:id="formula_8">O( log q i = 1 Σ k ( 1 + p i r i ) )</formula><p>bits of memory, provided that a precomputation requiring</p><formula xml:id="formula_9">O( i = 1 Σ k (p i r i log p i r i + log q) )</formula><p>field operations is carried out first.</p><p>We now present a sketch of the above algorithm. Suppose that g is some primitive element of GF(q), x ∈ GF(q) -{0}, and we wish to find an integer a, 1 ≤ a ≤ q -1, such that</p><formula xml:id="formula_10">x = g a . (3.3)</formula><p>Because of the Chinese Remainder Theorem, we only need to determine a modulo each of the p i n i . Suppose that p = p i and n = n i for some i. Let</p><formula xml:id="formula_11">a ≡ j = 0 Σ n -1 b j p j ( mod p n ) .</formula><p>To determine b 0 , we raise x to the (q -1 )/ p power:</p><formula xml:id="formula_12">y = x p q -1 _ ____ = g a p q -1 _ ____ = (q p q -1 _ ____ ) b 0 ,</formula><p>and note that y is one of only p elements, namely</p><formula xml:id="formula_13">h 0 = 1 , h 1 , h 2 ,...,h p -1 ,</formula><p>where</p><formula xml:id="formula_14">h = g (q -1 )/ p .</formula><p>How one determines b 0 we will describe below. Once we have determined b 0 , we can go on to determine b 1 by forming</p><formula xml:id="formula_15">(xg -b 0 ) (q -1 )/ p 2 = h b 1 ,</formula><p>and so one.</p><p>The value of b 0 is determined using Shanks' "baby steps-giant steps" technique. We are given y, and we need to find m such that</p><formula xml:id="formula_16">y = h m , 0 ≤ m ≤ p -1. If r ∈ R is given, 0 ≤ r ≤ 1, we form u =  p r  .</formula><p>Then there exist integers c and d such that</p><formula xml:id="formula_17">m = cu + d, 0 ≤ d ≤ u -1 , 0 ≤ c &lt; p / u .</formula><p>Hence finding m is equivalent to finding integers c and d in the above ranges which satisfy</p><formula xml:id="formula_18">h d ≡ yh -cu .</formula><p>To find such c and d, we can precompute h d for 0 ≤ d ≤ n -1 and then sort the resulting values. We then compute yh -cu for c = 0 , 1 ,..., and check each value for a match with the sorted table of values of y d . The precomputation and sorting take O(p 2 log p) operations (note that these steps have to be done only once for any given field), and there are O(p 1 -r ) values of yh -cu to be computed.</p><p>The Silver-Pohlig-Hellman algorithm is efficient whenever all the prime factors of q -1 are reasonably small. (It is most efficient in fields in which q is a Fermat prime, q = 2 m + 1, for which there is another polynomial-time discrete logarithm method <ref type="bibr" target="#b40">[41]</ref>.) Therefore great care has to be taken in selecting the fields GF(q) for use in cryptography. This question will be discussed further in Section 8.</p><p>We conclude this section by mentioning two interesting randomized algorithms due to Pollard <ref type="bibr" target="#b51">[52]</ref>.</p><p>One of them computes discrete logarithms in fields GF(q) in time roughly q 1/2 . The other algorithm finds the discrete logarithm of an element in time roughly w 1/2 , if that logarithm is known to lie in an interval of size w.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A subexponential discrete logarithm method</head><p>This section presents the fastest known general purpose discrete logarithm method. The basic ideas are due to Western and Miller <ref type="bibr" target="#b64">[65]</ref> (see also <ref type="bibr" target="#b46">[47]</ref>). The algorithm was invented independently by Adleman <ref type="bibr" target="#b0">[1]</ref>,</p><p>Merkle <ref type="bibr" target="#b45">[46]</ref>, and Pollard <ref type="bibr" target="#b51">[52]</ref>, and its computational complexity was partially analyzed by Adleman <ref type="bibr" target="#b0">[1]</ref>.</p><p>We will refer to it as the index-calculus algorithm. Previous authors were concerned largely with the fields GF(p), where p is a prime. Here the method will be presented as it applies to the fields GF( 2 n ), since they are of greatest cryptographic interest. An extensive asymptotic analysis of the running time of the algorithm in this and the related cases GF(p n ) with p fixed and n → ∞ was given recently by Hellman and Reyneri <ref type="bibr" target="#b29">[30]</ref>. As will be shown below, their estimates substantially overestimate the running time of this algorithm.</p><p>Recently some improvements on the index-calculus method as it applies to the fields GF( 2 n ) were made by I. Blake, R. Fuji-Hara, R. Mullin, and S. Vanstone <ref type="bibr" target="#b7">[8]</ref> which make it much more efficient, although these improvements do not affect the asymptotics of the running time. Even more recently, D.</p><p>Coppersmith <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> has come up with a dramatic improvement on the GF( 2 n ) version of the algorithm (and more generally on the GF(p n ) version with p fixed and n → ∞) which is much faster and even has different asymptotic behavior. More recently, a whole series of improvements on the basic algorithm have been discovered <ref type="bibr" target="#b19">[20]</ref>. They do not approach the Coppersmith algorithm in asymptotic performance, but they do apply to fields GF(p) as well as GF( 2 n ) and they can be used to motivate Coppersmith's algorithm (although they did not perform this function, having come afterwards), so we briefly sketch them as well.</p><p>The model of computation we will assume in this section is that of the Random Access Machine (RAM), with no parallel computation. In Section 6 we will discuss what effect lifting this restriction might have. The index-calculus algorithm, at least in the form presented here is a probabilistic method in that the analysis of its running time relies on assumptions about randomness and independence of various polynomials which seem reasonable but at present cannot be proved.</p><p>Before presenting the algorithm, it is necessary to specify the notation that will be used. As usual, we regard the field GF( 2 n ) as the ring of polynomials over GF( 2 ) modulo some irreducible polynomial f (x) of degree n. Hence all elements g ∈ GF( 2 n ) can be regarded as polynomials g(x) over GF( 2 ) of degree</p><formula xml:id="formula_19">&lt; n.</formula><p>One very important factor in analyzing the performance of the index-calculus algorithm over GF ( 2 n ) is that polynomials over GF <ref type="bibr" target="#b1">( 2 )</ref> are very easy to factor. Algorithms are known <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b54">55]</ref> that can factor g(x) in time polynomial in the degree of g(x). Since the running time of the index-calculus algorithm in GF( 2 n ) is much higher (of the form exp (c(n log n) 1/2 ) for the basic version and of the form exp (c ′ n 1/3 ( log n) 2/3 ) for the Coppersmith version), we will neglect the time needed to factor polynomials in this section, since we will be concerned here with asymptotic estimates. In Section 6 we will perform a more careful analysis for some specific values of n.</p><p>Suppose that g(x), a polynomial of degree &lt; n over GF <ref type="bibr" target="#b1">( 2 )</ref>, is a primitive element of GF( 2 n ). The index-calculus method for computing discrete logarithms in GF( 2 n ) with respect to the base g(x) consists of two stages. The first stage, which is by far the more time and space consuming, consists of the construction of a large data base. This stage only has to be carried out once for any given field. The second stage consists of the computation of the desired discrete logarithms.</p><p>We now present the basic version of the index-calculus algorithm. The initial preprocessing stage, which will be described later, consists of the computation of the discrete logarithms (with respect to g(x))</p><p>of a set S of chosen elements of GF( 2 n ). The set S usually consists of all or almost all the irreducible polynomials over GF( 2 ) of degrees ≤ m, where m is appropriately chosen. Once the preprocessing stage is completed, logarithms can be computed relatively rapidly. The basic idea is that given h = h(x), to find</p><formula xml:id="formula_20">a ∈ Z + such that h ≡ g a ( mod f ) ,</formula><p>one chooses a random integer s, 1 ≤ s ≤ 2 n -1, and computes</p><formula xml:id="formula_21">h * ≡ h g s ( mod f ) , deg h * &lt; n . (4.1)</formula><p>The reduced polynomial h * is then factored into irreducible polynomials and if all its factors are elements of S, so that</p><formula xml:id="formula_22">h * ≡ h g s ≡ v∈S Π v b v (h *) ( mod f ) , (4.2) then log g h ≡ v∈S Σ b v (h *) log g v -s ( mod 2 n -1 ) . (4.3)</formula><p>In the form in which we have presented it so far, it is possible to obtain a fully rigorous bound for the running time of the second stage.  </p><formula xml:id="formula_23">w(x) = i Π u i (x) c i , deg u i (x) ≤ m , then p(k,m) = N(k,k) N(k,m) _ ______ = 2 k N(k,m) _ ______ . (<label>4</label></formula><formula xml:id="formula_24">k = 1 Σ n 2 -k p(n -k, m) , which is approximately p(n, m) 2 -(ne / m) 1/ m (ne / m) 1/ m _ ___________ ,</formula><p>as follows from the results of Appendix A. The last quantity above is ∼ p(n, m) as n → ∞, n 1/100 ≤ m ≤ n 99/100 . Hence asymptotically this effect is unimportant, although for small values of n and m it can make a difference; for example, for n = 127 and m = 17 we obtain <ref type="bibr">1. 51p( 127 , 17 )</ref> as the correct estimate of the probability that h * will factor in the form (4.2).</p><p>The relation <ref type="bibr">(4.5)</ref> shows that the expected running time of the second stage of the algorithm, as it has been presented so far, is approximately </p><formula xml:id="formula_25">p(n,m) -1 = ( m n _ __ ) ( 1 + o( 1 ) ) n / m . (<label>4</label></formula><formula xml:id="formula_26">w i = v∈S Π v c v (i) ,<label>(4.8)</label></formula><p>then</p><formula xml:id="formula_27">log g h ≡ v∈S Σ (c v ( 1 ) -c v ( 2 ) ) log g v -s ( mod 2 n -1 ) .</formula><p>(4.9)</p><p>The advantage of this approach is that if the w i behave like independently chosen random polynomials of degree ∼ n /2, as seems reasonable, then the probability that both will factor into irreducibles of degrees 2 , and therefore the expected number of polynomials h * that have to be tested is on the order of</p><formula xml:id="formula_28">≤ m is approximately p( [n /2 ] ,m)</formula><formula xml:id="formula_29">p( [n /2 ] ,m) -2 = ( 2m n _ ___ ) ( 1 + o( 1 ) ) n / m . (4.10)</formula><p>This is smaller than the quality in (4.8) by a factor of approximately 2 n / m , and so is very important, provided the w i can be generated fast.</p><p>The polynomials w i can be generated very rapidly (in time polynomial in n) by applying the extended Euclidean algorithm <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b41">42]</ref> to h * and f. This algorithm produces polynomials α and β over GF <ref type="bibr" target="#b1">( 2 )</ref> such that αh * + β f = 1, the greatest common divisor of h * and f, and such that deg</p><formula xml:id="formula_30">α &lt; deg f = n, deg β &lt; deg h * &lt; n.</formula><p>To do this, the algorithm actually computes a sequence of triples of polynomials (α j ,β j ,γ j ) such that</p><formula xml:id="formula_31">α j h * + β j f = γ j ,<label>(4.11)</label></formula><p>where the final (α j ,β j ,γ j ) = (α,β, 1 ), deg γ 1 &gt; deg γ 2 &gt; ..., and where deg</p><formula xml:id="formula_32">α j ≤ n -1 -deg γ j . If</formula><p>we choose that j for which deg γ j is closest to n /2, then w 1 = γ j and w 2 = α j will satisfy the congruence (4.7), and their degrees will be relatively close to n /2 most of the time. These w 1 and w 2 are not completely independent (for example, they have to be relatively prime), but on the other hand their degrees will often be less than n /2, so on balance it is not unreasonable to expect that the probability of both having a factorization of the form (4.8) should be close to p( [n /2 ] , m) 2 .</p><p>The above observations justify the claim that the second stage of the index-calculus algorithm, as modified by Blake et al., ought to take on the order of p( [n /2 ] ,m) -2 operations on polynomials of degree ≤ n over GF <ref type="bibr" target="#b1">( 2 )</ref>, where each such polynomial operation might involve on the order of n 3 bit operations.</p><p>For small values of n, p( [n /2 ] ,m) can be found in Appendix B, while for very large n, the quantity on the right side of (4.10) ought to be a reasonable approximation to the running time of the second stage.</p><p>It is clear that the running time of the second stage can be decreased by increasing m. Doing that, however, increases both storage requirements and the running time of the first (preprocessing) stage of the algorithm. It is well known (see Appendix A) that the number of irreducible polynomials of degree ≤ m is very close to m -1 2 m + 1 , and for each one it is necessary to store roughly n bits, namely its logarithm (which is in the range [ 1 , 2 n -1 ]). This already puts a limit on how large m can be, but this limit is not very stringent, since these discrete logarithms can be stored on slow storage devices, such as tape. This is due to the fact that they are needed only once in the computation of each discrete logarithm by stage two, when both of the polynomials w i are discovered to have factorizations of the form (4.8). Thus this argument does not exclude the use of values of m on the order of 40.</p><p>A much more severe limitation on the size of m and n is placed by the preprocessing first stage, which we now discuss. The basic idea there is to choose a random integer s, 1 ≤ s ≤ 2 n -1, form the polynomial</p><formula xml:id="formula_33">h * ≡ g s ( mod f ) , deg h * &lt; n ,</formula><p>and check whether h * factors into irreducible factors from S. If it does, say</p><formula xml:id="formula_34">h * = v∈S Π v b v (h *) ,<label>(4.12)</label></formula><p>then we obtain the congruence</p><formula xml:id="formula_35">s ≡ v∈S Σ b v (h *) log g v ( mod 2 n -1 ) . (4.13)</formula><p>Once we obtain slightly more than Ssuch congruences, we expect that they will determine the log g v, v∈S, uniquely modulo 2 n -1, and the first stage will be completed. There is a complication here in that 2 n -1 is not in general a prime, so that solving the system (4.13) might require working separately modulo the different prime power divisors of 2 n -1 and using the Chinese Remainder Theorem to reconstruct the values of log g v. This complication is not very serious, and if it does occur, it should lead to a speedup in the performance of the algorithm, since arithmetic would have to be done on smaller numbers. In any case this complication does not arise when 2 n -1 is a prime. A general linear system of the form (4.13) for the log g v takes on the order of S </p><formula xml:id="formula_36">n _ ___ ) n / m</formula><p>is minimized approximately for m ∼ c 1 (n log e n) 1/2 , where</p><formula xml:id="formula_37">c 1 = ( 2 log e 2 ) -1/2 = 0. 8493... , in which case 2 m ( 2m n _ ___ ) n / m = exp ( (c 2 + o( 1 ) ) √  n log e n ) as n → ∞ ,<label>(4.17)</label></formula><p>where 2 2m is also of the form (4.17), so the time to solve the system of linear equations is of the same asymptotic form as the time needed to generate them.</p><formula xml:id="formula_38">c 2 = c 1 log 2 2 + ( 2c 1 ) -1 = ( 2 log e 2 ) 1/2 = 1. 1774... . For m ∼ c 1 (n log e n) 1/2 ,</formula><p>If we modify the notation used by Pomerance <ref type="bibr" target="#b52">[53]</ref> in his survey of integer factorization and let</p><formula xml:id="formula_39">M = M(n) represent any quantity satisfying M = exp ( ( 1 + o( 1 ) ) (n log e n) 1/2 ) as n → ∞ ,</formula><p>then our analysis shows that the first stage of the basic index-calculus algorithm can be carried out in time M 1. 178 .</p><p>The time required by the second stage of the index-calculus algorithm to compute a single discrete logarithm is We next describe several algorithms that improve on the asymptotic performance of the basic indexcalculus algorithm to an extent greater than the Blake et al. <ref type="bibr" target="#b7">[8]</ref> modification. They are nowhere near as fast as the Coppersmith version, since they still run in time M c for some constant c &gt; 0, but they have the property that c &lt; c 2 . They are presented here very briefly in order to show the variety of methods that are available, and also to motivate the Coppersmith algorithm. Like the Coppersmith method, these variants depend on the polynomial f (x) that defines the field being of a somewhat special form, namely</p><formula xml:id="formula_40">M ( 2c 1 ) -1 = M 0.</formula><formula xml:id="formula_41">f (x) = x n + f 1 (x) ,<label>(4.18)</label></formula><p>where the degree of f 1 (x) is small. Since approximately one polynomial of degree n out of n is irreducible (cf. Appendix A), we can expect to find f (x) of the form (4.18) with deg</p><formula xml:id="formula_42">f 1 (x) &lt; ∼ log 2 n. (The f 1 (x) of smallest degrees for which x n + f 1 (x) is irreducible for some interesting values of n are f 1 (x) = x + 1 for n = 127, f 1 (x) = x 9 + x 6 + x 5 + x 3 + x + 1 for n = 521, f 1 (x) = x 9 + x 7 + x 6 + x 3 + x + 1 for n = 607,<label>and</label></formula><formula xml:id="formula_43">f 1 (x) = x 11 + x 9 + x 8 + x 5 + x 3 + x 2 + x + 1 for n = 1279.</formula><p>) As is explained in Section 5.2, this is not a severe restriction, since being able to compute logarithms rapidly in one representation of a field enables one to compute logarithms in any other representation just about as fast.</p><p>The first algorithm we discuss is one of several that have the same asymptotic performance. (The other algorithms in this group are described in <ref type="bibr" target="#b19">[20]</ref>, at least in the form applicable to fields GF(p).) It is basically an adaptation of the Schroeppel factorization algorithm <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b52">53]</ref>. We assume that f (x) is of the form (4.18) with deg f (x) ≤ n /2, say. This time we let S = S 1 ∪ S 2 , where S 1 consists of the irreducible polynomials of degrees ≤m, and S 2 of polynomials of the form</p><formula xml:id="formula_44">x k + g(x) , deg g(x) ≤ m ,<label>(4.19)</label></formula><p>where</p><formula xml:id="formula_45">k =  n /2 is the least integer ≥ n /2. Consider any h 1 (x) , h 2 (x) ε S 2 . If h i (x) = x k + h ˜i (x) , i = 1 , 2 ,</formula><p>then, if we write 2k = n + a, a = 0 or 1, we have</p><formula xml:id="formula_46">h 1 (x) h 2 (x) = x 2k + x k (h ˜1 (x) + h ˜2 (x) ) + h ˜1 (x) h ˜2 (x) = x a ( f (x) + f 1 (x) ) + x k (h ˜1 (x) + h ˜2 (x) ) + h ˜1 (x) h ˜2 (x) (4.20) ≡ x k (h ˜1 (x) + h ˜2 (x) ) + h ˜1 (x) h ˜2 (x) + x a f 1 (x) ( mod f (x) ) ,</formula><p>and so the polynomial on the right side of (4.20) is of degree roughly n /2 (for m = o(n), as will be the case). If that polynomial, call it h * (x), factors into irreducible polynomials of degrees ≤m, say</p><formula xml:id="formula_47">h * (x) = vεS 1 Π v(x) b v (h * ) ,</formula><p>then (4.20) yields a linear equation for the logarithms of the elements of S:</p><formula xml:id="formula_48">log g h 1 + log g h 2 ≡ vεS 1 Σ b v (h * ) log g v ( mod 2 n -1 ) . (4.21)</formula><p>Since each of S 1 and S 2 has on the order of 2 m elements, once we obtain about 2 m equation of the form (4.21), we ought to be able to solve them and obtain the discrete logarithms of the elements of S </p><formula xml:id="formula_49">2 2m p( [n /2 ] , m) &gt; ∼ 2 m ,<label>(4.22)</label></formula><p>and the work we do is on the order of 2 2m , since the linear equations can also be solved in this much time.</p><p>To minimize the running time, we choose the smallest m for which (4.22) is satisfied, and a brief computation shows that the right choice is m ∼ c 3 (n log e n) 1/2 as n → ∞, with c 3 = ( 4 log e 2 ) -1/2 , so that the running time of the first stage of this algorithm is</p><formula xml:id="formula_50">M c 4 = M 0. 8325... , c 4 = ( log e 2 ) 1/2 . (4.23)</formula><p>The improvement in the exponent of M is the running time estimate of the first stage from 1.177... in the basic algorithm to 0.832... in the version above was due to the fact that this time, in order to obtain a linear equation we only had to wait for a single polynomial of degree about n /2 to split into low degree irreducibles, instead of a single polynomial of degree n or two polynomials of degree n /2. In the next algorithm, we obtain a further improvement by reducing to the problem of a single polynomial of degree about n /3 splitting into low degree irreducibles. The method is an adaptation of the so-called ''cubic sieve'' for factoring integers, which was invented by J. Reyneri some years ago and rediscovered independently several times since then (see <ref type="bibr" target="#b19">[20]</ref> for further details). This time we assume that f (x) has the form (4.18) with deg f 1 (x) ≤ n /3. We set k =  n /3 and let S = S 1 ∪ S 2 with S 1 consisting of the irreducible polynomials of degrees ≤m and S 2 of polynomials of the form x k + h(x) , deg h(x) ≤ m. We consider pairs h 1 (x) and h 2 (x) with each h i (x) of degree ≤m, and let</p><formula xml:id="formula_51">h * (x) ≡ (x k + h 1 (x) ) (x k + h 2 (x) ) (x k + h 1 (x) + h 2 (x) ) ( mod f (x) ) , (4.24) 0 ≤ deg h * (x) &lt; n. We then have h * (x) ≡ x 3k + x k (h 1 2 + h 1 h 2 + h 2 2 ) + h 1 h 2 (h 1 + h 2 ) ( mod f ) ,<label>(4.25)</label></formula><p>and since</p><formula xml:id="formula_52">x 3k ≡ x a f 1 (x) ( mod f (x) ) for some a, 0 ≤ a ≤ 2, we find that h * (x) is of degree about k ∼ n /3 if m = o(n). If h * (x) is divisible</formula><p>only by irreducibles in S 1 , we obtain a linear equation relating logarithms of three elements of S 2 to those of elements of S 1 . There are about 2 2m pairs h 1 (x) ,h 2 (x) to test, and so if the h * (x) behave like random polynomials of degrees ∼ n /3, we expect to obtain about 2 2m p( [n /3 ] , m) equations. Since there are about 2 m elements of S, we therefore need to choose m so that</p><formula xml:id="formula_53">2 2m p( [n /3 ] , m) &gt; ∼ 2 m . (4.26)</formula><p>The time to run the algorithm is (within polynomial factors of n) 2 2m , both to form and factor the polynomials h * (x), and to solve the system of linear equations. A simple computation shows that the smallest m that satisfies (4.26) has m ∼ c 5 (n log e n) 1/2 , where c 5 = ( 6 log e 2 ) -1/2 , and the running time of the first phase of this algorithm is</p><formula xml:id="formula_54">M c 6 = M 0. 6797... , where c 6 = ( 2 ( log e 2 )/3 ) 1/2 . (4.27)</formula><p>The running times of the second phases of the two algorithms presented above can be improved beyond what is obtained by using the strategy of the basic variant, but we will not discuss that subject. Details can be found in <ref type="bibr" target="#b19">[20]</ref>, in the case of fields GF(p), p a prime, and it is easy to adapt those methods to the fields</p><formula xml:id="formula_55">GF( 2 n ).</formula><p>The variants of the index-calculus algorithm presented above raise the question of whether they can be generalized so as to give even faster algorithms. The obvious idea is to use more than three factors and choose those factors in such a way that the product will reduce modulo f (x) to a polynomial of low degree.</p><p>A very clever way to do this was found by Coppersmith <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. However, his work was motivated by different considerations.</p><p>We next present the Coppersmith variation <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> on the index-calculus algorithm. Unlike the basic algorithm, which runs in time roughly of the form exp (n 1/2 ) in fields GF( 2 n ), this new variation runs in time which is roughly of the form exp (n 1/3 ). Unlike the basic version, though, the Coppersmith variant does not apply to the fields GF(p) with p prime. Just like the algorithms presented above, the Coppersmith algorithm relies on several unproved assumptions. Since these assumptions are supported by both heuristic reasoning and empirical evidence, though, there seems to be no reason to doubt the validity of the algorithm.</p><p>The Coppersmith algorithm was inspired to a large extent by the Blake et al. <ref type="bibr" target="#b7">[8]</ref> method of systematic equations, which is explained in Section 5.1, and which yields many linear equations involving logarithms at very low cost. Like the systematic equations method, it depends on the polynomial f (x) being of a the special form (4.18) with f 1 (x) of very low degree.</p><p>We now discuss the first stage of the Coppersmith variant of the index-calculus algorithm. We assume that the field GF( 2 n ) is defined by a polynomial f (x) that is of the form (4.18) with deg</p><formula xml:id="formula_56">f 1 (x) &lt; ∼ log 2 n.</formula><p>The first stage consists again of the computation of logarithms of v ∈ S, where S consists of irreducible polynomials of degrees ≤ m, but now m will be much smaller, on the order of n 1/3 ( log e n) 2/3 . We will also assume that g(x) ∈ S, since it follows from Section 5.2 that this restriction does not affect the running time of the algorithm.</p><p>The essence of the Blake et al. <ref type="bibr" target="#b7">[8]</ref> improvement of the basic index-calculus algorithm is that it replaced the factorization of a single polynomial of degree about n by the factorization of two polynomials of degrees about n /2 each. The essence of the two improvements discussed above was that they rely on the factorization of polynomials of degrees about n /2 and n /3, respectively, into low degree irreducibles. The essence of the Coppersmith <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> improvement is that it instead relies on factorization of two polynomials of degrees on the order of n 2/3 each. The lower the degree of the polynomials being factored, the greater the probability that they will consist only of small degree irreducible factors. To accomplish this lowering of the degree, take k ∈ Z + (k will be chosen later so that 2 k is on the order of n 1/3 ( log e n) -1/3 ) and define</p><formula xml:id="formula_57">h =  n 2 -k  + 1 . (4.28)</formula><p>Pick u 1 (x) and u 2 (x) of degrees ≤ B (B will be chosen later to be on the order of n 1/3 ( log e n) 2/3 ) with (u 1 (x) , u 2 (x) ) = 1, and set</p><formula xml:id="formula_58">w 1 (x) = u 1 (x) x h + u 2 (x) . (4.29)</formula><p>Next let</p><formula xml:id="formula_59">w 2 (x) ≡ w 1 (x) 2 k ( mod f (x) ) , deg w 2 (x) &lt; n . (4.30)</formula><p>We then have</p><formula xml:id="formula_60">w 2 (x) ≡ u 1 (x 2 k ) x h2 k + u 2 (x 2 k ) ( mod f (x) ) , = u 1 (x 2 k ) x h2 k -n f 1 (x) + u 2 (x 2 k ) . (4.31)</formula><p>If B and 2 k are on the order of n 1/3 , then h is on the order of n 2/3 , h 2 kn is on the order of n 1/3 , and so both w 1 (x) and w 2 (x) have degrees on the order of n 2/3 . Since log g w 2 (x) ≡ 2 k log g w 1 (x) ( mod 2 n -1 ) , if both w 1 (x) and w 2 (x) have all their irreducible factors in S we obtain a linear equation for the log g v, v ∈ S. (The restriction (u 1 (x) , u 2 (x) ) = 1 serves to eliminate duplicate equations, since the pairs u 1 (x) , u 2 (x) and u 1 (x) t(x) , u 2 (x) t(x) produce the same equations.)</p><p>We next consider the Coppersmith algorithm in greater detail. We need to obtain about S linear equations for the log g v, v ∈ S. Now</p><formula xml:id="formula_61">deg w 1 (x) ≤ B + h , deg w 2 (x) ≤ B . 2 k + 2 k + deg f 1 (x) ,</formula><p>so if w 1 (x) and w 2 (x) behave like independent random polynomials of those degrees, then the probability that both w 1 (x) and w 2 (x) have all their irreducible factors in S is approximately</p><formula xml:id="formula_62">p(B + h, m) p(B2 k + 2 k , m) . (<label>4.32)</label></formula><p>Of course w 1 (x) and w 2 (x) are neither independent nor random. However, as far as their factorizations are concerned, it does not appear unreasonable to expect that they will behave like independent random polynomials, and this does turn out to hold in the case n = 127 studied by Coppersmith <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. Therefore to obtain S ∼ m -1 2 m + 1 equations we need to satisfy</p><formula xml:id="formula_63">2 2B p(B + h, m) p(B2 k + 2 k , m) &gt; ∼ 2 m . (4.33)</formula><p>The work involved consists of generating approximately 2 2B polynomials w 1 (x) and testing whether both w 1 (x) and w 2 (x) have all their irreducible factors in S. Once these roughly 2 m equations are generated, it becomes necessary to solve them, which takes about 2 2m operations. The estimate (4.5) shows that to minimize the running time, which is approximately</p><formula xml:id="formula_64">2 2B + 2 2m ,</formula><p>subject to (4.33), it is necessary to take</p><formula xml:id="formula_65">2 k ∼ α n 1/3 ( log e n) -1/3 , (4.34a) m ∼ β n 1/3 ( log e n) 2/3 , (4.34b) B ∼ γ n 1/3 ( log e n) 2/3 ,<label>(4.34c)</label></formula><p>as n → ∞, where α, β, and γ are bounded away from both zero and infinity. Under these conditions we find that the running time of the first stage of the algorithm is</p><formula xml:id="formula_66">K 2γ log e 2 + K 2β log e 2 ,<label>(4.35)</label></formula><p>where K = K(n) denotes any quantity that satisfies</p><formula xml:id="formula_67">K = exp ( ( 1 + o( 1 ) ) n 1/3 ( log e n) 2/3 ) ,<label>(4.36)</label></formula><p>and this is subject to the condition</p><formula xml:id="formula_68">2 γ log e 2 - 3α β 1 _ ____ - 3β α γ _ __ ≥ ( 1 + o( 1 ) ) ) β log e 2 . (<label>4.37)</label></formula><p>Let us now regard α, β, and γ as continuous variables. Since the estimate (4.35) does not depend on α, we can choose α freely. The quantity on the left side of (4.37) is maximized for</p><formula xml:id="formula_69">α = γ -1/2 , (<label>4.38)</label></formula><p>and for this choice of α, (4.37) reduces to (after neglecting the 1</p><formula xml:id="formula_70">+ o( 1 ) factor) 2γ log e 2 ≥ β log e 2 + 3 2 _ _ β -1 γ 1/2 . (4.39)</formula><p>To minimize the asymptotic running time of the algorithm, we have to choose β and γ so that (4.39) is satisfied and max ( 2γ, 2β) is minimized. A short calculation shows that the optimal choice is obtained when γ = β and equality holds in (4.37), which yields</p><formula xml:id="formula_71">β = 2 2/3 3 -2/3 ( log e 2 ) -2/3 = 0. 9743... . (4.40)</formula><p>The running time for this choice is</p><formula xml:id="formula_72">K 2β log e 2 = K 1. 3507... ,</formula><p>and the space required is K β log e 2 = K 0. 6753... . The analysis above assumed that α, β, and γ could all be treated as continuous variables. This is essentially true in the case of β and γ, but not in the case of α, since (4.34a) has to hold with k a positive integer. Since the analysis is straightforward but tedious, we do not discuss the general situation in detail but only mention that the running time of the Coppersmith algorithm and the space required are of the form K u , where u is a function of log 2 (n 1/3 ( log e n) </p><formula xml:id="formula_73">p(n, n 2/3 ( log e n) 1/3 ) -1 = K log e 3 = K 1. 098... (4.41)</formula><p>trials. When we do succeed with some value of s, we obtain</p><formula xml:id="formula_74">h ≡ g -s i Π u i ( mod f (x) ) ,</formula><p>where the u i are of degrees ≤ n 2/3 ( log n) 1/3 , and there are &lt; n of them (since their product is a polynomial of degree &lt; n). This then yields</p><formula xml:id="formula_75">log g h ≡ -s + i Σ log g u i ( mod 2 n -1 ) ,<label>(4.42)</label></formula><p>and so if we find the log g u i , we obtain log g h.</p><p>Suppose next that u is a polynomial of degree ≤ B ≤ n 2/3 ( log n) 1/3 (say one of the u i above, in which case B = n 2/3 ( log n) 1/3 ). We again reduce the problem of computing log g u to that of computing logarithms of several polynomials of lower degrees. We select 2 k to be a power of 2 close to (n / B) 1/2   (precise choice to be specified later), and let</p><formula xml:id="formula_76">d =  n2 -k  + 1 . (4.43)</formula><p>Consider polynomials</p><formula xml:id="formula_77">w 1 (x) = v 1 (x) x d + v 2 (x) ,<label>(4.44)</label></formula><p>where deg</p><formula xml:id="formula_78">v 1 (x), deg v 2 (x) ≤ b (b to be specified later), (v 1 (x) , v 2 (x) ) = 1, and u(x)w 1 (x). If w 2 (x) ≡ w 1 (x) 2 k ( mod f (x) ) , deg w 2 (x) &lt; n ,<label>(4.45)</label></formula><p>then (for b small)</p><formula xml:id="formula_79">w 2 (x) = v 1 (x 2 k ) x d2 k -n f 1 (x) + v 2 (x 2 k ) ,</formula><p>and thus w 1 (x) and w 2 (x) both have low degrees. If w 1 (x)/ u(x) and w 2 (x) both factor into irreducible polynomials of low degree, say</p><formula xml:id="formula_80">w 1 (x) = u(x) i Π s i (x) , w 2 (x) = j Π t j (x) ,</formula><p>then we obtain</p><formula xml:id="formula_81">j Σ log g t j (x) ≡ log g w 2 (x) ≡ 2 k log g w 1 (k) ≡ 2 k ( log g u(x) + i Σ log g s i (x) ) ( mod 2 n -1 ) .</formula><p>This reduces the computation of log g u to the computation of the log g t j and the log g u i . We next analyze how much of a reduction this is. The probability that w 1 (x)/ u(x) and w 2 (x) both factor into irreducible polynomials of degrees ≤ M is approximately</p><formula xml:id="formula_82">p(d + b -deg u(x) , M) p(b2 k + 2 k + deg f 1 (x) , M) ,</formula><p>and the number of pairs of polynomials</p><formula xml:id="formula_83">v 1 (x) , v 2 (x) of degrees ≤ b with (v 1 (x) , v 2 (x) ) = 1 and u(x)  w 1 (x) is approximately 2 2b -deg u(x) .</formula><p>(Divisibility by u(x) is determined by a set of deg u(x) linear equations for the coefficients of v 1 (x) and v 2 (x).) Hence to find v 1 (x) and v 2 (x) such that w 1 (x) and w 2 (x) factor in the desired fashion we select b to be approximately</p><formula xml:id="formula_84">(n 1/3 ( log e n) 2/3 ( log e 2 ) -1 + deg u(x) )/2 , (<label>4.46)</label></formula><p>and select 2 k to be the power of 2 nearest to (n / b) 1/2 . We then expect to obtain the desired factorization in time</p><formula xml:id="formula_85">K = exp ( ( 1 + o( 1 ) ) n 1/3 ( log e n) 2/3 ) ,</formula><p>with M being the largest integer for which</p><formula xml:id="formula_86">Kp(d + b -deg u(x) , M) p(b2 k + 2 k + deg f 1 (x) , M) ≥ 1 . (4.47)</formula><p>If B ∼ n 2/3 ( log e n) 1/3 (as occurs in the first step of the second stage of the Coppersmith algorithm), we find that we can take M ∼ cn 1/2 ( log e n) 3/2 , and if B ∼ cn 1/2 ( log e n) 3/2 , then we can take M ∼ c ′ n 5/12 ( log e n) 25/12 . More generally, it is also easy to show that if B ≥ n 1/3 ( log e n) 2/3 , say, then we can take M ≤ B /1. 1, so that each iteration decreases the degrees of the polynomials whose logarithms we need to compute by a factor ≥ 1. 1, while raising the number of these polynomials by a factor ≤ n.</p><p>When B ≤ ( 1. 1 ) -1 n 1/3 ( log e n) 2/3 , the polynomial u(x) is already in our data base, and we only need to read off its logarithm. Thus we expect to perform</p><formula xml:id="formula_87">≤ exp (c ′ ′ ( log n) 2 ) = K o( 1 )</formula><p>iterations of this process, each iteration taking K steps.</p><p>We have shown that the second stage of the Coppersmith algorithm can compute individual logarithms in time K 1. 098... . In fact, with slightly more care the exponent of K can be lowered substantially. We do not do it here, since the main point we wish to make is that as in the basic algorithm, the second stage of the Coppersmith variant requires very little time and negligible space, compared to the first stage.</p><p>This section was devoted almost exclusively to the asymptotic analysis of the index-calculus algorithms on a random access machine. In Section 6 we will consider the question of estimating the running time of this algorithm for some concrete values of n, including the possible effects of the use of parallel processors.</p><p>In the next section we will discuss several variations on the algorithm as it has been presented so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Further modifications of the index-calculus algorithm</head><p>Section 4 was concerned largely with the asymptotic behavior of the index-calculus algorithm in fields GF ( 2 n ). This section will discuss several technical issues related to both the basic algorithm and the</p><p>Coppersmith version. The most important of them is that of efficient solutions to systems of linear equations, discussed in Section 5.7. The fact that the equations that occur in index-calculus algorithms can be solved fast is a recent discovery which affects the estimates of the running time both asymptotically and in practice.</p><p>This section also presents a variety of modifications of both the basic algorithm and of the Coppersmith version, which do not affect the asymptotics of the running times very much, but which are very important in practice. The most significant of these variations is that of Section 5.6. That variation speeds up the first phase of the Coppersmith algorithm by two or three orders of magnitude in fields that might be of practical interest. The variations presented here are not analyzed in exhaustive detail because their exact contributions depend on the hardware and software in which the algorithm is implemented. The purpose here is to obtain rough estimates of the performance of the algorithm with the best currently conceivable techniques. These estimates will be used in the next section to evaluate how large n ought to be to offer a given level of security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Systematic equations</head><p>The first stage of the index-calculus algorithm involves the collection of slightly over S linear equations for the logarithms of the polynomials v ∈ S and then the solution of these equations. The reason the Coppersmith version is so much faster than the Blake et al. version is that by dealing with pairs of polynomials of degree around n 2/3 as opposed of degree about n /2, it increases the probability of finding an additional equation for the log g v, v ∈ S. In fact, for the fields GF( 2 n ), Blake et al. had some methods for obtaining large numbers of equations at very low cost per equation. They called the equations obtained this way ''systematic.'' They were able to obtain upwards of one half of the required number of equations that way, but never all. Their methods in fact inspired Coppersmith to invent his version of the algorithm. We will now explain the Blake et al. methods and explore their significance. These methods work best when the polynomial f (x) which defines the field has the special property that it divides some polynomial of the form</p><formula xml:id="formula_88">x 2 k + f 1 (x) ,<label>(5.1)</label></formula><p>where the degree of f 1 (x) is very small, and where the primitive element g = g(x) = x. In general, it appears likely that the degree of f 1 (x) will be relatively high, which will make these new approaches of Blake et al. of little significance. In some cases, however, these methods produce startling improvements. This happens, for example, in the case of n = 127, when we take the defining polynomial to be</p><formula xml:id="formula_89">f (x) = x 127 + x + 1, since here x f (x) = x 2 7 + x 2 + x ,</formula><p>and f 1 (x) has degree 2.</p><p>The first of the observations made by Blake and his collaborators is that if f 1 (x) is of low degree, the polynomials x 2 r , 1 ≤ r ≤ n -1, will often have low degree when reduced modulo f (x). When this degree is low enough to make that polynomial a product of polynomials from S, we obtain a linear equation of the desired kind, since log x x 2 r = 2 r . As an example, for n = 127 and f (x) = x 127 + x + 1, we find that for 7 ≤ i ≤ 126,</p><formula xml:id="formula_90">x 2 i = (x 2 7 ) 2 i -7 = (x 2 + x) 2 i -7 = x 2 i -6 + x 2 i -7 ,</formula><p>and repeated application of this result shows that each x 2 r , 0 ≤ r ≤ 126, can be expressed in the form</p><formula xml:id="formula_91">i = 0 Σ 6 ε i x 2 i , ε i = 0 , 1 ,</formula><p>and so the logarithms of all such elements can be quickly computed, and are of the form 2 r for some r.</p><p>Furthermore, since</p><formula xml:id="formula_92">1 + x 2 r = ( 1 + x) 2 r = x 127. 2 r ,</formula><p>one can also obtain the logarithms of all elements of the form</p><formula xml:id="formula_93">ε -1 + i = 0 Σ 6 ε i x 2 i , ε i = 0 , 1 .</formula><p>In particular, these will include the logarithms of 31 nonzero polynomials of degrees ≤ 16. In general, for other values of n, f 1 (x) will not have such a favorable form, and we can expect fewer usable equations.</p><p>Another observation of Blake et al., which is even more fruitful, is based on the fact that if u(x) is any irreducible polynomial over GF( 2 ) of degree d, and v(x) is any polynomial over GF <ref type="bibr" target="#b1">( 2 )</ref>, then the degrees of all irreducible factors of u(v(x) ) are divisible by d. To prove this, note that if w(x) is an irreducible factor of u(v(x) ), and α is a root of w(x) = 0, then v(α) is a zero of u(x), and thus is of degree d over GF <ref type="bibr" target="#b1">( 2 )</ref>. Since v(x) has its coefficients in GF <ref type="bibr" target="#b1">( 2 )</ref>, this means that α must generate an extension field of GF( 2 d ), which means that its degree must be divisible by d, as we wished to show.</p><p>To apply the above fact, Blake et al. take an irreducible u(x) of low degree, u(x) ∈ S, and note that by (5.1),</p><formula xml:id="formula_94">u(x) 2 k = u(x 2 k ) = u( f 1 (x) ) .</formula><p>If u( f 1 (x) ) factors into polynomials from S, one obtains another equation for the logarithms of the v ∈ S.</p><p>The result proved in the preceding paragraph shows that all the factors of u( f 1 (x) ) will have degrees divisible by deg u(x), and not exceeding ( deg u(x) ) ( deg f 1 (x) ). Blake and his collaborators noted that in many cases all the irreducible factors have degrees actually equal to deg u(x). We will now discuss the likelihood of this happening.</p><p>Suppose that</p><formula xml:id="formula_95">f (x)  x 2 k + f 1 (x) . (5.2)</formula><p>We can assume without loss of generality that not all powers of x appearing in f 1 (x) are even, since if they were, say 2 , we would have</p><formula xml:id="formula_96">f 1 (x) = f 2 (x 2 ) = f 2 (x)</formula><formula xml:id="formula_97">f (x)  x 2 k + f 2 (x) 2 = (x 2 k -1 + f 2 (x) ) 2 ,</formula><p>and since f (x) is irreducible, we would obtain</p><formula xml:id="formula_98">f (x)  x 2 k -1 + f 2 (x) ,</formula><p>and we could replace f 1 (x) by f 2 (x) in (5.2). Therefore we will assume f 1 (x) does have terms of odd degree, and so f 1 ′ (x) ≠ 0.</p><p>The polynomial</p><formula xml:id="formula_99">F d (x) = x 2 d + x (5.3)</formula><p>is the product of all the irreducible polynomials of all degrees dividing d. When we substitute f 1 (x) for x in</p><formula xml:id="formula_100">F d (x)</formula><p>, we obtain</p><formula xml:id="formula_101">F d ( f 1 (x) ) = f 1 (x) 2 d + f 1 (x) = f 1 (x 2 d ) + f 1 (x) . (5.4) But f 1 (x 2 d ) + f 1 (x) ≡ f 1 (x) + f 1 (x) = 0 ( mod F d (x) ) ,</formula><p>and so each irreducible polynomial whose degree divides d has to divide some u( f 1 (x) ) for another irreducible u(x) of degree dividing d. Since One factor which is hard to predict is how small can one take the degree of f 1 (x) so that (5.2) holds for some k and some primitive polynomial f (x) of degree n. The situation for n = 127, where we can take</p><formula xml:id="formula_102">dx d _ __ F d ( f 1 (x) ) = f 1 ′ (x)</formula><formula xml:id="formula_103">f 1 (x) = x 2 +</formula><p>x, is extremely favorable. For some n, it is possible to take deg</p><formula xml:id="formula_104">f 1 (x) = 1. Condition (5.2)</formula><p>with f 1 (x) = x is not useful, since it holds precisely for the irreducible polynomials of degrees dividing k, and the resulting discrete logarithm equations simply say that</p><formula xml:id="formula_105">2 k log x v ≡ log x v ( mod 2 d -1 )</formula><p>for dk, d = deg v(x), which is trivial. Condition (5.2) with f 1 (x) = x + 1 is somewhat more interesting.</p><p>If it holds, then</p><formula xml:id="formula_106">f (x)  x 2 2k + x ,</formula><p>and thus deg f (x)  2k. On the other hand, because of (5.2), deg f (x)  / k. Thus this condition can hold only for even n, which, as we will argue later, ought to be avoided in cryptographic applications. For these even n, however, it gives relations of the form</p><formula xml:id="formula_107">2 n /2 log x v ≡ log x v * ( mod 2 n -1 ) ,</formula><p>for all irreducible v(x), where v * (x) = v(x + 1 ), and then gives about S/2 useful equations.</p><p>In many cases it is impossible to find f (x) of a given degree such that (5.2) holds for some f 1 (x) of low degree. When such f (x) can be found, it sometimes happens that (5.2) holds for several pairs (k, f 1 (x) ).</p><p>For example, when n = 127, f (x) = x 127 + x + 1, condition (5.2) holds for k = 7, f 1 (x) = x 2 + x and also</p><formula xml:id="formula_108">for k = 14, f 1 (x) = x 4 + x.</formula><p>The significance of these systematic equations is not completely clear. Our arguments indicate that unless (5.2) is satisfied with f 1 (x) of low degree, few systematic equations will be obtained. No method is currently known for finding primitive f (x) of a given degree n for which (5.2) is satisfied with some f 1 (x) of low degree. It is not even known whether there exist such f (x) for a given n. Even in the very favorable situation that arises for n = 127, f (x) = x 127 + x + 1, Blake et al. <ref type="bibr" target="#b7">[8]</ref> found only 142 linearly independent systematic equations involving the 226 logarithms of the irreducible polynomials of degrees ≤ 10. (They reported a very large number of linear dependencies among the systematic equations they obtained.) Thus it seems that while systematic equations are a very important idea that has already led to the Coppersmith breakthrough and might lead to further developments, at this time they cannot be relied upon to produce much more than S/2 equations, and in practice probably many fewer can be expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Change of primitive element and field representation</head><p>The Coppersmith algorithm requires that the polynomial f (x) that generates the field GF( 2 n ) be of the form (4.18) with f 1 (x) of low degree. Section 4.1 showed that if the f (x) satisfies (5.2) with f 1 (x) if low degree, and x is a primitive element of the field, one can obtain many systematic equations. On the other hand, it is often desirable that f (x) satisfy other conditions. For example, if f (x) is an irreducible trinomial,</p><formula xml:id="formula_109">f (x) = x n + x k + 1 ,<label>(5.5)</label></formula><p>where we may take k ≤ n /2, since</p><formula xml:id="formula_110">x n + x n -k + 1 is irreducible if and only if f (x) is, then reduction of polynomials modulo f (x) is very easy to implement; if h(x) = i = 0 Σ 2n -2 a i x i</formula><p>(as might occur if h(x) is the product of two polynomials reduced modulo f (x)), then</p><formula xml:id="formula_111">h(x) ≡ i = 0 Σ n -1 a i x i + i = 0 Σ n -2 a i + n x i + i = k Σ k + n -2 a i + n -k x i ( mod f (x) ) ,<label>(5.6)</label></formula><p>a reduction that can be accomplished using two shifts and two exclusive or's of the coefficient strings, and another iteration of this procedure applied to the polynomial on the right side of (4.6) yields the fully reduced form of h(x). It is often also desirable that f (x) be primitive, since then x can be used as a primitive element of the field. (Extensive tables of primitive trinomials are available, see <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b70">71,</ref><ref type="bibr" target="#b71">72]</ref>.) In some cases, of which n = 127 and f (x) = x 127 + x + 1 is the example par excellence, it is possible to satisfy all these desirable conditions. In general, though, some kind of compromise might be necessary, and the choice to be made might depend both on n (and thus on what kinds of polynomials exist) and on the hardware and software that are being used. Our purpose here is to show that the security of a cryptosystem is essentially independent of the choices that are made; the cryptosystem designer and the cryptanalyst can choose whichever f (x) and g(x) suit them best.</p><p>To show that changing only the primitive element g(x) does not affect the security of a system, suppose that we have a way to compute discrete logarithms to base g(x) efficiently. If another primitive element g 1 (x) and a nonzero polynomial h(x) are given, and it is desired to compute the logarithm of h(x) to base g 1 (x), we compute the logarithms of g 1 (x) and h(x) to base g(x), say</p><formula xml:id="formula_112">g 1 (x) ≡ g(x) a ( mod f (x) ) , h(x) ≡ g(x) b ( mod f (x) ) ,</formula><p>and obtain immediately</p><formula xml:id="formula_113">h(x) ≡ g 1 (x) a * b ( mod f (x) ) ,</formula><p>where a * is the integer with 1 ≤ a * ≤ 2 n -1 for which aa * ≡ 1 ( mod 2 n -1 ) .</p><p>(Since g(x) and g 1 (x) are primitive, (a 1 2 n -1 ) = 1, and so a * exists.)</p><p>Changing the representation of the field, so that it is given as polynomials modulo f 1 (x), as opposed to modulo f (x), also does not affect the difficulty of computing discrete logarithms, as was first observed by</p><p>Zierler <ref type="bibr" target="#b69">[70]</ref>. The two fields are isomorphic, with the isomorphism being given by</p><formula xml:id="formula_114">x ( mod f 1 (x) ) → h(x) ( mod f (x) ) ,</formula><p>where</p><formula xml:id="formula_115">f 1 (h(x) ) ≡ 0 ( mod f (x) ) .</formula><p>Thus to construct the isomorphism we have to find a root h(x) of f 1 (x) in the field of polynomials modulo f (x). Such a root can be found in time polynomial in n <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b69">70]</ref>, which establishes the isomorphism and enables one to transfer logarithm computations from one representation to another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Faster generation and processing of test polynomials</head><p>As we described the basic index-calculus algorithm, the polynomials h * are generated (in the first stage of the algorithm, say) by selecting a random integer s and reducing g s modulo f (x). Typically this involves on the order of 3n /2 polynomial multiplications and reductions modulo f (x). This work can be substantially reduced by choosing the h * in succession, say h 1 * = 1 , h 2 * , h 3 * ,..., with</p><formula xml:id="formula_116">h k + 1 * ≡ h k * v s ( mod f (x) ) ,</formula><p>where v s is chosen at random from S. This requires only one polynomial multiplication (in which one factor, namely v s , is of low degree) and one reduction. Since each h k * is of the form</p><formula xml:id="formula_117">h k * ≡ v∈S Π v a v ( mod f (x) ) ,</formula><p>any time we find that both w 1 and w 2 have all their irreducible factors in S, we obtain another equation for the log g v, v ∈ S. Heuristic arguments and some empirical evidence <ref type="bibr" target="#b57">[58]</ref> indicate that the sequence h k * ought to behave like a random walk in GF( 2 n ) \ {0}, which means that the modified algorithm ought to produce linear equations about as efficiently as the old one.</p><p>Once h * is computed, the (w 1 , w 2 ) pair that satisfies (4.7) is produced by the extended Euclidean algorithm applied to the polynomials h * and f, which are each of degree about n. It might be advantageous to decrease the cost of this relatively slow operation by generating several pairs (w 1 , w 2 ) that satisfy (4.7).</p><p>This can be done by choosing w 1 = γ j and w 2 = α j for several values of j such that (4.11) holds and the degrees of the w i are not too far from n /2. As is shown in Appendix A,</p><formula xml:id="formula_118">p(r + s, m) p(r -s, m) ∼ ∼ p(r, m) 2</formula><p>for s small compared to r (for example, p( 105 , 18 ) p( 95 , 18 ) = 1. 07×10 -8 , while p( 100 , 18 ) 2 = 1. 09×10 -8 ) so that if the neighboring pairs (γ j , α j ) that satisfy (4.11) are independent with regard to factorization into small degree irreducible polynomials, as seems reasonable, we can cheaply obtain additional pairs (w 1 , w 2 ) satisfying (4.7) which will be just as good in producing additional equations.</p><p>The two modifications suggested above can also be applied to the second stage of the basic indexcalculus algorithm, where they will lead to a similar improvements in running time. They can also be used in the first step of the second stage of the Coppersmith algorithm.</p><p>Blake et al. <ref type="bibr" target="#b7">[8]</ref> used the Berlekamp algorithm <ref type="bibr" target="#b6">[7]</ref> to factor the polynomials w i . However, what is really needed initially is only to check whether all the irreducible factors of the w i are of degrees ≤ m. The complete factorization of the w i is needed only when the w i are both composed of low degree factors, and this happens so infrequently that the time that is needed in those cases to factor the w i is an insignificant fraction of the total running time. Now to rapidly check whether a polynomial w(x) has all its irreducible factors of degrees ≤ m, we can proceed as follows. Since the greatest common divisor, (w ′ (x) , w(x) ), of w(x) and its derivative equals</p><formula xml:id="formula_119">(w ′ (x) , w(x) ) = i Π y i (x) 2 [a i /2 ] ,<label>(5.7)</label></formula><p>where</p><formula xml:id="formula_120">w(x) = i Π y i (x) a i ,</formula><p>and the y i (x) are distinct irreducible polynomials, we can compute</p><formula xml:id="formula_121">w ( 0 ) (x) = i Π y i (x)</formula><p>in a few greatest common divisor and square root operations. Then, for i = 1 , 2 ,..., m we compute</p><formula xml:id="formula_122">w (i) (x) = (w (i -1 ) (x) , x 2 i + x)</formula><p>w (i -1 ) (x) _ ________________ .</p><p>(5.8)</p><p>Since x 2 k + x is the product of all the irreducible polynomials of degrees dividing k, w (m) (x) = 1 if and only if all the irreducible factors of w(x) are of degrees ≤ m.</p><p>The above procedure ought to be quite fast, since the greatest common divisor of two polynomials of degrees ≤ n can be computed using at most n shifts and exclusive or's of their coefficient sequences and since the degrees of the w (i) are likely to decrease rapidly. The above procedure can be simplified some more by noting that it suffices to define w (i 0 ) (x) = w ( 0 ) (x) for i 0 = [ (m -1 )/2 ] and apply (5.8) for i = i 0 + 1 ,..., m, since any irreducible polynomial of degree d, d ≤ m, divides at least one of the x 2 i + x, i 0 + 1 ≤ i ≤ m. Furthermore, the x 2 i + x do not have to be computed at each stage separately, but instead, if we save</p><formula xml:id="formula_123">u i (x) ≡ x 2 i + x ( mod w (i -1 ) (x) ) ,</formula><p>with u i (x) reduced modulo w (i -1 ) (x), then</p><formula xml:id="formula_124">u i (x) ≡ x 2 i + x ( mod w (i) (x) ) ,</formula><p>and so</p><formula xml:id="formula_125">u i + 1 (x) ≡ u i (x 2 ) + x 2 + x ( mod w i (x) ) ,</formula><p>which is a much simpler operation.</p><p>Another fast way to test whether a polynomial w(x) has all its irreducible factors of degrees ≤ m was suggested by Coppersmith <ref type="bibr" target="#b18">[19]</ref>. It consists of computing</p><formula xml:id="formula_126">w ′ (x) i =  m /2 Π m (x 2 i + x) ( mod w(x) ) ,</formula><p>and checking whether the resulting polynomial is zero or not. This method avoids the need for many greatest common division computations, and so may be preferable in some implementations. It is not completely foolproof, since polynomials in which all irreducible factors of degrees &gt; m appear to even powers will pass the test. However, such false signals will occur very infrequently, and will not cause any confusion, since polynomials w(x) that pass the Coppersmith test have to be factored in any case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Large irreducible factors</head><p>This section discusses a variation on both the basic index-calculus algorithm and the Coppersmith variation that was inspired by the "large prime" variation on the continued fraction integer factoring method (cf. <ref type="bibr" target="#b52">[53]</ref>). In practice, as will be discussed in greater length later, the w i would probably be factored by removing from them all irreducible factors of degree ≤ m, and discarding that pair (w 1 , w 2 ) if either one of the quotients is not 1. If one of the quotients, call it u(x), is not 1, but has degree ≤ 2m, then it has to be irreducible. The new variation would use such pairs, provided the degree of u(x) is not too high (≤ m + 6, say). The pair (w 1 , w 2 ) that produced u(x) would be stored, indexed by u(x). Then, prior to the linear equation solving phase, a preprocessing phase would take place, in which for each irreducible u(x), deg u(x) &gt; m, the pairs (w 1 , w 2 ) that are associated to it would be used to obtain additional linear equations involving logarithms of the v ∈ S. For example, in the basic algorithm, if there are k pairs associated to u(x), say</p><formula xml:id="formula_127">h i * ≡ u a i v∈S Π v b v (i) ( mod f ) , 1 ≤ i ≤ k ,</formula><p>where each a i = ±1, then we can obtain k -1 equations for the logarithms of the v ∈ S by considering the polynomials</p><formula xml:id="formula_128">h i * (h 1 * ) -a i / a 1 ≡ v∈S Π v b v (i) -b v ( 1 ) a i / a 1 ( mod f ) , 2 ≤ i ≤ k .</formula><p>A similar method works with the Coppersmith variation.</p><p>We now consider the question of how many equations we are likely to obtain by this method. Suppose that we generate N different pairs (w 1 , w 2 ), where each of the w i is of degree approximately M (which would be ∼ n /2 for the basic algorithm and on the order of n 2/3 in the Coppersmith variation). We then (The probability that both w 1 and w 2 have one irreducible factor of degree k and all others of degree ≤ m is negligible.) Hence among our N pairs (w 1 , w 2 ) we expect about</p><formula xml:id="formula_129">N k ∼ 2N p(M, m) p( [n /2 ] -k, m) I(k) 2 -k (5.9)</formula><p>pairs that would be preserved. The number of equations that we expect to obtain from these N k pairs is</p><formula xml:id="formula_130">N k -M k</formula><p>, where M k is the number of irreducible polynomials of degree k that appear in the stored list.</p><p>To estimate M k , we make the assumption that the irreducible polynomials u(x) of degree k that appear in the factorization of the w i behave as if they were drawn at random from the I(k) such polynomials.</p><p>When N k balls are thrown at random into I(k) buckets, the expected number of buckets that end up empty is I(k) times the probability that any single bucket ends up empty. Since the probability that a particular bucket ends up with no balls is</p><formula xml:id="formula_131">I(k) N k (I(k) -1 ) N k _ __________ ,</formula><p>the expected number of buckets that we expect to be occupied is</p><formula xml:id="formula_132">I(k) -I(k) (I(k) -1 ) N k I(k) -N k .</formula><p>Therefore we expect to obtain approximately</p><formula xml:id="formula_133">N k + I(k) ( ( 1 -I(k) -1 ) N k -1 )<label>(5.10)</label></formula><p>additional equations from polynomials of degree k. Since N k will be comparable to I(k) in magnitude in applications to the index-calculus algorithm, we can approximate (5.10) by</p><formula xml:id="formula_134">N k + I(k) ( exp ( -N k / I(k) ) -1 ) . (5.11) Since (see Appendix A) I k ∼ 2 k k -1 and p(M -k, m) ∼ p(M, m) (Mm -1 log e M / m) k / m ,</formula><p>(5.9) gives us</p><formula xml:id="formula_135">N k ∼ 2 Nk -1 p(M, m) 2 (Mm -1 log e M / m) k / m .</formula><p>(5.12)</p><p>Since S ∼ 2 m + 1 m -1 , we are interested in N for which Np(M, m) 2 is on the order of 2 m m -1 . For such N, though, (5.11) and (5.12) show that the number of additional equations is negligible for km → ∞. For k ∼ m, on the other hand, (5.12) shows that</p><formula xml:id="formula_136">N k ∼ 2 M m -2 N p(M, m) 2 ( log e M / m) , which is ∼ c ′ Np(M, m) 2</formula><p>for m ∼ c(M log e M) 1/2 , which is the case for both the basic algorithm and the Coppersmith variant.</p><p>Hence we also have</p><formula xml:id="formula_137">N k ∼ c ′ ′ I(m) ,</formula><p>and (5.11) then shows that we can expect</p><formula xml:id="formula_138">[c ′ ′ -2 k -m ( 1 -exp ( -c ′ ′ 2 m -k ) ) ] I(m)</formula><p>additional equations, where the implied constants are absolute. Hence when we sum over k, we find that the total number of additional equations we can expect the large irreducible factor variation to generate is proportional to the number that have to be obtained.</p><p>The large irreducible factor variation can be quite important for moderate values of n, especially when m is relatively low, as it might have to be to make the solution of the system of linear equations feasible.</p><p>For example, for M ∼ 65, m = 18, without the large irreducible factor variation we might expect to test about N ∼ ∼ 1. 04 ×10 8 pairs (w 1 , w 2 ), whereas with this variation we expect to need only about 6. 7 × 10 7 .</p><p>For M ∼ 65 and m = 12, the difference is even more dramatic, since without the variation we expect to need N ∼ ∼ 1. 3 ×10 10 , while with it we need only N ∼ ∼ 3. 5 × 10 9 . For M ∼ 100 and m = 20 the figures are N ∼ ∼ 4. 9 × 10 11 and N ∼ ∼ 2. 3 × 10 11 , respectively, while for M ∼ 100 and m = 18 they are N ∼ ∼ 2. 7 × 10 12 and N ∼ ∼ 1. 1 × 10 12 . Thus for values that are of cryptographic significance, the large irreducible variation can shorten the running time of the equation generating phase by a factor of between 2 and 3. Furthermore, it can speed up the second stage of the index-calculus algorithm by an even greater factor, since in addition to the logarithms of the v ∈ S, the cryptanalyst will possess the logarithms of many polynomials of degrees m + 1 , m + 2 ,... .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Early abort strategy</head><p>Like the large irreducible factor variation discussed in the preceding section, the early abort strategy is also inspired by a similar technique used in factoring integers. Most of the pairs (w 1 , w 2 ) that are generated turn out to be ultimately useless, whether the large irreducible factor variation is used or not. It would obviously be of great advantage to be able to select those pairs (w 1 , w 2 ) in which both of the w i are likely to factor into irreducible polynomials from S. The idea behind the early abort strategy is that a polynomial is unlikely to have all its factors in S unless it has many factors of small degree.</p><p>Asymptotically this variation is unimportant, since factorization of binary polynomials can be accomplished in time polynomial in their degree. For small values of n, though, this variation can be important, as will be shown below.</p><p>Let p k (r, m) denote the probability that a polynomial of degree r has all its irreducible factors of degrees strictly larger than k but at most m. It is easy to obtain recurrences for p k (r, m) similar to those for p(r, m) derived in Appendix A, which enables one to compute the p k (r, m) numerically. (It is also possible to obtain asymptotic expansions for the p k (r, m), but since we know a priori that the early abort strategy is unimportant asymptotically, we will not do it here.) For a polynomial w(x), let w * (x) denote the product of all the irreducible factors of w(x) of degrees ≤ k (with their full multiplicity). Let Q(r, R, m, k) denote the probability that a polynomial w(x) of degree r has all its irreducible factors of degrees ≤ m, that deg w * (x) ≥ R. Then we easily obtain</p><formula xml:id="formula_139">Q(r, R, m, k) = j≥R Σ p( j, k) p k (r -j, m) .</formula><p>Let Q * (r, R, k) denote the probability that a random polynomial w(x) of degree r has the property that deg w * (x) ≥ R. Then we similarly obtain</p><formula xml:id="formula_140">Q * (r, R, k) = j≥R Σ p( j, k) p k (r -j, r -j) .</formula><p>The early abort strategy with parameters (k, R) is to discard the pair (w </p><formula xml:id="formula_141">{ B + A Q * ( [n /2 ] , R, k) 2 } Q( [n /2 ] , R, m, k) -2 .</formula><p>(5.14)</p><p>In Table <ref type="table" target="#tab_8">1</ref> we present some values of the ratio of the quantity in <ref type="bibr">(5.14)</ref> to that in (5.13): </p><formula xml:id="formula_142">                           </formula><p>We see from this that if B / A &lt; ∼ 1/10, then one can reduce the work required to obtain an additional equation by 30-40%, which might speed up the algorithm by a factor of approximately 1.5.</p><p>The success of the early abort strategy is crucially dependent on the ability to quickly find the divisors w i * of the w i that are composed only of irreducible factors of degrees ≤ k. If we use the procedure suggested in Section 5.3, this can be accomplished quite easily. Given a polynomial w(x) to be tested, we compute its square-free part w ( 0 ) (x) and go through the first k steps of the procedure described by <ref type="bibr">(5.8)</ref>. If k = 4, this can be simplified further. Here we only need to know (w 0 (x) , x 8 + x) and (w 0 (x) , x 16 + x) , and these can be computed by reducing w ( 0 ) (x) modulo x 8 + x and modulo x 16 + x, respectively, and looking up the greatest common divisors in precomputed tables. We could then decide not to reject w(x) if the difference of the degree of w ( 0 ) (x) and the sum of the degrees of the two divisors is small enough. It might also be advantageous to avoid computing w ( 0 ) (x) on the first pass, compute (w(x) , x 8 + x) , (w(x) , x 16 + x) , and accept or reject w(x) depending on how small the difference between the degree of w(x) and the sum of the degrees of those factors is.</p><p>One can obtain some further slight gains by using additional conditions further along in the computation of the w (i) (x) defined by (5.8). It seems safe to say, though, that the early abort strategy is unlikely to speed up the linear equation collection phase of the index-calculus algorithm by more than a factor of 2 or so.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Faster generation of equations in Coppersmith's method</head><p>It is possible to significantly speed up the first stage of Coppersmith's variant of the index-calculus algorithm by applying some of the ideas that occur in the second stage of that version. Asymptotically, the improvements are not important, but in practice they are likely to be much more important than all the other variations we have discussed so far, and could speed up the equation-collecting phase of the algorithm by factors of 10 to 20 for n = 127, by up to 300 for n = 521, and by over 1000 for n = 1279.</p><p>The idea behind the new variation is that instead of selecting u 1 (x) and u 2 (x) to be any pair of relatively prime polynomials of degrees ≤ B each, we select them to increase the chances of w 1 (x) and w 2 (x) splitting into low degree irreducible factors. To do this, we select a pair v 1 (x) and v 2 (x) of polynomials of degrees ≤ B -1 (but close to B) such that each is composed of irreducible factors of degrees ≤ m. We then select u 1 (x) and u 2 (x) of degrees ≤ B so that v 1 (x)  w 1 (x) and v 2 (x)  w 2 (x). The divisibility condition gives us deg v 1 (x) + deg v 2 (x) ≤ 2B -2 homogeneous linear equations for the 2B coefficients of u 1 (x) and u 2 (x), and so we obtain at least 3 nonzero solutions. Moreover, these solutions can be found very fast, by using gaussian elimination on the GF( 2 ) matrix of size ≤ 2B -2 by 2B.</p><p>When u 1 (x) and u 2 (x) are selected by the above procedure, the probability of w 1 (x) splitting into irreducible factors of degrees ≤ m ought to be close to p(h, m), and the probability of w 2 (x) splitting in this way ought to be close to</p><formula xml:id="formula_143">p(h2 k -n + B( 2 k -1 ) + deg f 1 (x) , m) .</formula><p>Since B = O (n 1/3 ( log e n) 2/3 ), the form of the asymptotic estimate for the probability of both w 1 (x) and w 2 (x) splitting is not affected by this improvement. In practice, however, the improvements can be vital.</p><p>Some care has to be used in the application of the idea proposed above. The first stage of the indexcalculus algorithm requires the generation of S ∼ m -1 2 m + 1 linearly independent equations. The equations generated by the basic version of the algorithm and by the Coppersmith variation are expected to be largely independent of the preceding ones (as long as there are &lt; Sof them) on heuristic grounds, and this is confirmed by computational experience. That is not the case, however, with the variation proposed above, because in general many pairs (v 1 (x) , v 2 (x) ) will give rise to the same pair (w 1 (x) , w 2 (x) ). To circumvent this difficulty, we select B so that the standard Coppersmith algorithm without the variation proposed here would generate about 1. 6 Sequations. (This involves increasing B by at most 1.) We then implement the present variation, with the new value of B. Essentially all of the 1. 6 Sequations that would be generated by the standard Coppersmith algorithm can be generated by the new variation with appropriate choices of v 1 (x) and v 2 (x), and most can be generated in roughly the same number of ways. Hence we can again model this situation in terms of the ''balls into buckets'' problem described in Section 5.4; we have about 1. 6 Sbuckets corresponding to the equations we can possibly obtain, and we are throwing balls into them corresponding to the equations our variation actually produces. If we obtain about 1. 6 Sequations all told, approximately 1. 6 ( 1e -1 ) S &gt; 1. 01 S of them will be distinct, and so it will be overwhelmingly likely that Sof them will be independent.</p><p>In our new variation we do not need to check whether (u 1 (x) , u 2 (x) ) = 1, and thus whether (v 1 (x) , v 2 (x) ) = 1. Therefore we can prepare beforehand a list of all polynomials of degrees ≤ B -1 that are composed of irreducible factors of degrees ≤ m, and this will generate a slight additional saving over the standard Coppersmith algorithm. (In order to take full advantage of the sparse matrix techniques of Section 5.7, it might be best to use only irreducible factors of degrees ≤ m -5, say.) The effort needed to compute u 1 (x) and u 2 (x) (i.e., to solve a small linear system of equations), which is comparable to the work needed to test whether a polynomial has all its irreducible factors of degrees ≤ m, can be amortized over more test polynomials by requiring that degrees of v 1 (x) and v 2 (x) be ≤ B -2, since that will produce at least 15 nonzero solutions each time.</p><p>There are other ways to speed up the Coppersmith algorithm. One way would be to fix 2B + 2b of the coefficients of u 1 (x) and u 2 (x), where b is maximal subject to being able to store about 2 b small integers.</p><p>Then, for all irreducible polynomials u(x) of degrees ≤ m, one could quickly compute those choices of the remaining b coefficients for which w 1 (x) or w 2 (x) is divisible by u(x). All that would need to be stored for each of the 2 b combinations would be the sum of the degrees of the divisors that were found. This variation, however, does not appear as promising as the one discussed above, and it would require some very novel architectures to implement it on a parallel processing machine of the type we will discuss later.</p><p>Hence we do not explore this variation further.</p><p>A slight improvement on the basic idea of this section is to allow v 1 (x) and v 2 (x) to have different degrees, subject to the requirement that their sum be ≤ 2B -2, so as to make the degrees of w 1 (x)/ v 1 (x) and w 2 (x)/ v 2 (x) more nearly equal.</p><p>Another modification to the Coppersmith algorithm was suggested by Mullin and Vanstone <ref type="bibr" target="#b47">[48]</ref>. It consists of choosing w 1 (x) to be of the form</p><formula xml:id="formula_144">w 1 (x) = u 1 (x) x h -a + u 2 (x)</formula><p>for a = 1 or 2, say, and selecting</p><formula xml:id="formula_145">w 2 (x) ≡ w 1 (x) 2 k x b ( mod f (x) ) ,</formula><p>where b is chosen so as to give small degree for w 2 (x) after reduction modulo f (x). This might allow the use of slightly lower degree polynomials for u 1 (x) and u 2 (x) than would otherwise be required, since if u 1 ( 0 ) = 1, the equations this method yields ought to be idependent of those the basic method produces.</p><p>This modification can be combined with the others suggested here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Sparse matrix techniques</head><p>So far we have concentrated on variations on the linear equation collection phase of the index-calculus algorithm. However, as we noted in Section 4, the difficulty of solving systems of linear equations seemed for a long time to be an important limiting factor on the algorithm and affected the asymptotic estimate of its running time. For example, in the basic algorithm, if the term 2 2m in (4.16) were replaced by 2 rm for any r &gt; 2 (r = 3 corresponding to the use of gaussian elimination, for example), then the minimum of (4.16) would occur not at m ∼ c 1 (n log e n) 1/2 , but at a smaller value, m ∼ c 1 (r) (n log e n) 1/2 , and would be larger, with c 2 replaced by</p><formula xml:id="formula_146">c 2 (r) = r( 2 (r -1 ) ) -1/2 ( log e 2 ) 1/2 .</formula><p>In this section, though, we will show that the linear equations produced by the index-calculus algorithm can be solved in time essentially S 2 , where Sis roughly the number of equations.</p><p>The matrices of coefficients of the linear equations generated by the first stage of the index-calculus algorithm are special in that they are very sparse. The reason is that the coefficient vector of each equation is obtained by adding several vectors (b v (h) ), indexed by v ε S, coming from factorizations of polynomials</p><formula xml:id="formula_147">h = v ε S Π v b v (h) .</formula><p>Since the polynomials h are always of degrees &lt; n, there can be at most n nonzero b v (h), and so each equation has at most n nonzero entries. This is a very small number compared to the total number of equations, which is around exp (n 1/3 ) or exp (n 1/2 ). The literature on sparse matrix techniques is immense, as can be seen by looking at <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b60">61]</ref> and the references cited there. Many of the techniques discussed there turn out to be very useful for the index-calculus problem, even though we face a somewhat different problem from the standard one in that we have to do exact computations modulo 2 n -1 as opposed to floating point ones. In the worst case, the problem of solving sparse linear systems efficiently is probably very hard. For example, it is known that given a set of 0 -1 vectors v 1 ,..., v r , each of which contains exactly three 1's, to determine whether there is a subset of them of a given size that is dependent modulo 2 is NP-complete <ref type="bibr" target="#b34">[35]</ref>. Thus we cannot hope to find the most efficient worst case algorithm.</p><p>However, very efficient algorithms can be found.</p><p>There are several methods for solving the systems of linear equations that arise in the index-calculus algorithms that run in tone O(N 2 + ε ) for every ε &gt; 0, where N is the number of equations. The first ones were developed by D. Coppersmith and the author from an idea of N. K. Karmarkar. This idea was to adapt some of the iterative algorithms that have been developed for solving real, symmetric, positive definite systems of equations <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b38">39]</ref>. For example, in the original version of the conjugate gradient method <ref type="bibr" target="#b32">[33]</ref>, in order to solve the system Ax = y, where A is a symmetric positive definite real matrix of size N by N, and y is a given real column vector of length N, one can proceed as follows. Let x 0 be an arbitrary vector of length N, and let P 0 = r 0 = y -Ax 0 . The algorithm then involves ≤ N -1 iterations of the following procedure: given x i ,r i , and p i , let</p><formula xml:id="formula_148">a i = (p i ,Ap i ) (r i ,r i ) _ _______ ,</formula><p>(5.15a)</p><formula xml:id="formula_149">x i + 1 = x i + a i p i ,<label>(5.15b</label></formula><p>)</p><formula xml:id="formula_150">r i + 1 = r i -a i Ap i , (5.15c) b i = (r i ,r i ) (r i + 1 ,r i + 1 )</formula><p>_ __________ , (5.15d)</p><formula xml:id="formula_151">p i + 1 = r i + 1 + b i p i .</formula><p>(5.15e)</p><p>It can be shown <ref type="bibr" target="#b32">[33]</ref> that if the computations are done to infinite precision, the algorithm will find r i = 0 for some i ≤ N -1, and x = y i will then solve the original system Ax = y.</p><p>There are several problems with trying to use the conjugate gradient method to solve the systems of linear equations that arise in the index-calculus algorithms. One is that the system is not symmetric, and one has to solve Bx = y where B is not even a square matrix. This problem can be bypassed (as is well known, cf. <ref type="bibr" target="#b32">[33]</ref>) by solving the system Ax = z, where A = B T B and z = B T y. Since B will in general be of almost full rank, solutions to Ax = z will usually give us solutions to Bx = y. The matrix A will not in general be sparse, but its entries do not have to be computed explicitly, since it is only necessary to compute the vectors Ap i , and that can be done by multiplying p i first by B and then B T . The matrix B can be stored in the sparse form, with rows and columns being given by lists of positions and values of nonzero coefficients.</p><p>The main difficulty with the use of the conjugate gradient method is that the basic theory was based on minimizing a quadratic functional, and this does not apply in finite fields. However, as was suggested by Karmarkar, the most important property of the algorithm is that the direction vectors p i are mutually conjugate (i.e., (p i , Ap j ) = 0 for i ≠ j), and this is a purely algebraic property. Therefore the algorithm will terminate after at most n -1 iterations and will find a solution unless at some stage a vector p i is encountered such that (p i , Ap i ) = 0. This cannot happen if A is a real positive-definite matrix and p i ≠ 0, but can occur over finite fields. If the computations are being done over a large finite field, the probability of this occurring if x 0 is choosen at random is quite low. If the field is small, say GF(q) with j = 0 Σ N c j z j .</p><p>(5.18)</p><p>Given any sequence of length on the order of N, the Berlekamp-Massey algorithm <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b55">56]</ref> finds its minimal characteristic polynomial in O(N 2 ) operations in the field GF(q). Hence if we apply the Berlekamp-Massey algorithm to each of the K coordinates of the vectors v 0 , . . . , v 2N , we will in O(KN 2 ) steps obtain K polynomials whose least common multiple is likely to be the minimal polynomial of A.</p><p>When we do find that minimal polynomial, and it is of the form (5.18) with c 0 ≠ 0, then we can easily obtain the desired solution to Ax = y from</p><formula xml:id="formula_152">y = A 0 y = -c 0 -1 j = 1 Σ N c j A j y (5.19) = A   -c 0 -1 j = 1 Σ N c j A j -1 y    .</formula><p>If A is nonsingular, then c 0 ≠ 0, as is easy to see. Conversely, if c 0 ≠ 0, then A is nonsingular, since we can then write</p><formula xml:id="formula_153">A j = 1 Σ N c j A j -1 = -c 0 I .</formula><p>In general in index-calculus algorithms, we have to solve a system of the form Ax = y, where A is of size M by N, with M &gt; N (but M -N small). One way to reduce to the earlier case of a nonsingular square matrix is to take a submatrix A ′ of A of size N by N, and apply the algorithm presented above to (A ′ ) T x = z for some random vector z. If A ′ turns out to be nonsingular, we can then go back and search for solutions to A ′ x = y, which is what we are interested in. If A ′ is singular, though, we will obtain a linear dependency among the rows of A ′ . This means we can discard one of the rows of A ′ that was involved in that dependency and replace it with another row of that part of A that has not been used yet.</p><p>After a few steps, we ought to obtain a nonsingular A ′ , and this will enable us to solve for x in Ax = y.</p><p>Wiedemann <ref type="bibr" target="#b65">[66]</ref> also has a deterministic algorithm, which may not be as practical, however.</p><p>We conclude this section by discussing some very simple methods for solving sparse systems of equations. Some of these methods can be used as a preliminary step before the application of Wiedemann's algorithm, say, since they serve to reduce the effective size of the matrix that has to be dealt with. In some cases these methods by themselves could be just about as efficient as the techniques described above.</p><p>These methods are based on a simple observation that has often been made in the work on sparse matrices (cf. <ref type="bibr" target="#b5">[6]</ref>), namely that if a matrix is noticeably sparser on one end than on the other, then it is better to start gaussian elimination from the sparse end. In our case, if we arrange the matrix of coefficients so that the columns correspond to polynomials v ∈ S sorted by increasing degree, then the right side of the matrix will </p><formula xml:id="formula_154">p(B2 k ,m) 2 -m p(B2 k -m,m) _ _________________ , which, by Lemma A.3 of Appendix A, is ∼ 2 -m m -1 B2 k log (B2 k / m) .</formula><p>Therefore the probability that any particular entry in the last M columns of the matrix is nonzero is about</p><formula xml:id="formula_155">2 -(m -1 ) m -1 B2 k log (B2 k / m) . (<label>5.20)</label></formula><p>(The factor 2 comes from the fact that we are adding two vectors.) For the choices of B, 2 k , and m that were specified, this becomes δM -1 , where</p><formula xml:id="formula_156">δ = 2α γ β -2 /3 = 2β -3/2 /3 = log 2 = 0. 6931....</formula><p>(Exactly the same asymptotic result also applies to the basic index-calculus algorithm.) Therefore, by the ''balls into buckets'' model, we expect that with probability about</p><formula xml:id="formula_157">( 1 -δM -1 ) 2M ∼ ∼ exp ( -2δ) = 1/4 ,</formula><p>any column among the last M will contain only zeros. This means that about M /4 of the M irreducible polynomials of degree m will not appear in any of the factorizations and so the data base obtained from the first phase will be missing those values. More importantly, it means that it was not necessary to obtain all of the 2M equations, as 7M /4 would have sufficed. (In fact fewer than 7M /4, since with that few equations, the chances of obtaining a zero column would be even larger, and in addition we would also have some irreducible polynomials of degrees m -1 , m -2, etc., which would not appear in the equations.)</p><p>In addition, the probability of a particular column among the last M having just a single nonzero coefficient is about</p><formula xml:id="formula_158">2M . δM -1 ( 1 -δM -1 ) 2M -1 ∼ ∼ 2δ exp ( -2δ) = ( log 2 )/2 = 0. 346...</formula><p>Thus an additional 0.346M of the last M columns would have a single nonzero coefficient, so that we could remove those columns together with the rows in which those columns have nonzero coefficients, solve the remaining system, and then obtain the values of logarithms corresponding to the deleted columns by back substitution. (Occasionally a row might contain two nonzero coefficients which are the only such in their columns, which would prevent recovery of the values of the corresponding logarithms, but that is not a significant problem.) Furthermore, removal of those rows and columns would create more columns with only a single nonzero coefficient, so that the size of the matrix could be cut down by more than 0.35M.</p><p>However, both simulations and heuristic arguments show that if we proceed to carry out standard gaussian elimination, proceeding from the sparse end, then very rapid fill-in occurs. Therefore one does have to be careful about algorithms that are used.</p><p>The above discussion of just how sparse the index-calculus algorithms matrices are was meant to motivate the following method. It will be helpful to explain it in terms of operating on the full matrix, although in practice the matrix would be stored in the sparse encoding, using lists of nonzero coefficients and their positions for rows and columns, just as in the case of the algorithms discussed above. The algorithm is as follows:</p><p>Step 1: Delete all columns which have a single nonzero coefficient and the rows in which those columns have nonzero coefficients.</p><p>Step 1 is repeated until there are no more columns with a single nonzero entry.</p><p>Step 2: Select those αM columns which have the largest number of nonzero elements for some α &gt; 0.</p><p>Call these columns "heavy," the others "light."</p><p>A typical value of α might be 1/32. The entries in the "heavy" columns for every given row might be stored on a disk, with a pointer attached to the row list indicating the storage location. These pointers would have coefficients attached to them, which are set to 1 initially. The weight of a row is then defined as the number of nonzero coefficients in its "light" columns.</p><p>Step 3: Eliminate variables corresponding to rows of weight 1 by subtracting appropriate multiples of those rows from other rows that have nonzero coefficients corresponding to those variables.</p><p>During execution of Step 3, if u times row i is to be subtracted from row j, the pointers attached to row j are to have added to them the pointers of row i, with their coefficients multiplied by u.</p><p>Step 3 is to be repeated until there are no more rows of weight 1. At the end of this process there are likely to be many more equations than unknowns. We can then perform the following operation.</p><p>Step 4: If r rows are excess, drop the r rows with highest weight.</p><p>We now iterate Step 1, and then Step 3. We then go on to the next procedure. Note that if a variable indexed by j, say, appears in rows of weights 2≤w 1 ≤ w 2 ≤ . . . ≤ w k , then eliminating that variable using a row of weight w i will increase the number of nonzero entries in the matrix (after deletion of the row of weight w i and the column corresponding to our variable) by</p><formula xml:id="formula_159">(w i -1 ) (k -1 ) -w i -(k -1 ) = (w i -2 ) (k -1 ) -w i .</formula><p>(5.21)</p><p>Hence to minimize the amount of fill-in, we need to choose that variable and that w i (which clearly equals w 1 ) for which (5.21) is minimized. Keeping track of this quantity is fairly easy if we use a priority queue data structure.</p><p>equations. (Their systematic equations method produced a substantial fraction of all the required equations.) Once the first stage is completed, the second stage is expected to take around 1 CPU hour per logarithm even on the VAX 11/780. On the IBM 3081K, Coppersmith estimated that the equation collecting phase for GF ( 2 127 ) would take around 9 hours with the basic algorithm. Using his own variation, Coppersmith was able to find all the necessary polynomials (for m = 12) in 11 minutes <ref type="bibr" target="#b18">[19]</ref>.</p><p>(The factorization of the polynomials to obtain the actual equations took 8 minutes, and solution of the equations took 20 minutes, but these tasks were performed with a general purpose symbolic manipulation program, and so could undoubtedly be speeded up very substantially.) Further speedups, perhaps by a factor of 30 to 50, could be obtained by combining the variation proposed in Section 5.6, which might gain a factor of 10 to 20, with those of sections 5.4 and 5.5, which together might gain a factor of 2 or 3. Using the Cray-1 might gain an additional factor of 10 or so, because it is perhaps 5 times faster than the IBM 3081K and because it could store and manipulate the test polynomials (of degrees &lt; ∼ 42) in single words.</p><p>Thus we can expect that with current supercomputers the equation collecting part of the first phase of the algorithm can be completed in around one second. Since the database produced by the algorithm is not very large (16,510 127-bit numbers for m = 17 in the basic algorithm and 747 numbers for m = 12 in the Coppersmith variation), this means that individual logarithms in GF ( 2 127 ) can now be computed even on personal computers. Therefore GF( 2 127 ) ought to be regarded as completely unsuitable for cryptographic applications. Our intention here is to explore what other fields might be appropriate.</p><p>We first consider the basic algorithm. Although it has been made obsolete by the Coppersmith variation in applications to the fields GF( 2 n ), it is worth analyzing in detail, since by comparing our estimates to actual running times we will obtain a better idea of how accurate the estimates are.</p><p>In Section 5 we presented briefly a number of variations on the basic index-calculus algorithm. These variations were not analyzed very carefully, since we were interested only in the order of magnitude of the improvements that can be obtained from such techniques. The general conclusion to be drawn from that section is that the time to generate the pairs (w 1 , w 2 ), can probably be neglected. The work needed to obtain Sequations is probably no more than and at least 1/5 of the work needed to test</p><formula xml:id="formula_160">S p( [n /2 ] , m) -2</formula><p>pairs (w 1 , w 2 ) by the procedure outlined in Section 4.3 to see whether all the irreducible factors of each of the w i are in S. To test each w i takes about m /2 operations of the form (4.8), each of which involves a squaring modulo a polynomial of degree perhaps n /3 on average (since the degrees of the w (i) (x) will be decreasing, especially if we use the early abort strategy with additional test along the way to discard pairs (w 1 , w 2 ) that are not factoring satisfactorily), a greatest common divisor operation or two polynomials of degrees around n /3, and a division, which will usually be trivial.</p><p>To evaluate the significance of the index-calculus algorithm for cryptographic schemes, we have to look at the effect of parallel processing and at speeds of modern circuits. We will assume that no exotic algorithms, such as fast integer multiplication using the Fast Fourier Transform <ref type="bibr" target="#b9">[10]</ref> are to be used, since they are probably not practical for n on the order of several hundred. Since a cryptographic scheme ought to be several orders of magnitude too hard to break, we will only try to be accurate within a factor of 10 or so.</p><p>It appears that at present, custom VLSI chips could be built that would perform about 10 8 operations per second, where each operation would consist of a shift of a register of length 200 to 300 or else an exclusive or of two such registers. Semi-custom chips, which would be much easier to design and cheaper to produce, could operate at about 10 7 operations per second. Within the next decade or so, these speeds might increase by a factor of 10, so custom chips might do 10 9 operations per second, while semi-custom ones do 10 8 . General purpose supercomputers like the Cray-1 can do about 10 8 operations per second when running in vector mode to take advantage of parallel processing, where each operation consists of a shift or exclusive or of 64-bit words. The structure of the index-calculus algorithm lends itself to parallel processing, but the fact that coefficients of polynomials would often take more than a single machine word to store would cause a substantial slowdown in operations, perhaps to a level of 10 7 operations per second.</p><p>The next generation of supercomputers, such as the Cray-2, will be about 10 times faster, and might run at the equivalent of 10 8 operations per second.</p><p>The number of shifts and exclusive or's that are involved in squaring a polynomial of degree ∼ n /3 modulo another polynomial of roughly that same degree and then in taking the greatest common divisor of two polynomials of degrees ∼ n /3 can be roughly estimated by 3n. Therefore each of the roughly S p( [n /2 ] , m) -2 pairs (w 1 , w 2 ) that are generated can be expected to require about 3mn operations.</p><p>(Various branchings and the like would make the actual algorithm slower, but this would be compensated somewhat by the factor of 3 or more that we might gain from using the large irreducible factor and the early abort variations, and the method of systematic equations. Note also that almost always it is only necessary to test w 1 , since when it turns out not to factor in the desired way, there is no need to test w 2 .) We therefore expect that about </p><formula xml:id="formula_161">n 2 m + 3 p( [n /2 ] ,</formula><formula xml:id="formula_162">                </formula><p>We will now temporarily neglect the effort needed to solve the linear equations that are generated, and discuss for which n and m one could hope to generate the required linear equations with various hardware configurations. We will assume that the equations are to be generated within one year, roughly 3 × 10 7</p><p>seconds. If we use a single supercomputer, we can hope to carry out between 3 × 10 14 and 3 × 10 15 operations in that year. If we use a massively parallel machine with M special chips, we can expect to carry out between 3 × 10 14 M and 3 × 10 16 M operations in a year, depending on the technology that is used.</p><p>Comparing these figures with those in the table in the preceding paragraph we see that even under our very optimistic assumptions, a general supercomputer could not assemble the required set of linear equations in under a year if n &gt; ∼ 240, say, whereas it probably could for n &lt; ∼ 180. On the other hand, even a relatively modest special purpose processor using 10 4 semi-custom chips based on current technology could perform about 3 × 10 18 operations per year, and so could probably cope with n &gt; ∼ 260, and perhaps with n &gt; ∼ 280, but probably not much beyond it. A very ambitious processor, using 10 6 custom designed chips operating at speeds that might become attainable in the next decade could do about 3 × 10 22 operations per year, and could probably generate the needed equations for n &lt; ∼ 380, but probably not for n &gt; ∼ 420.</p><p>The estimates made above are probably quite accurate, as is confirmed by comparing the numbers in Table <ref type="table" target="#tab_9">2</ref> with the results of the GF( 2 127 ) computations of <ref type="bibr" target="#b7">[8]</ref>. Interpolating between the values in Table <ref type="table" target="#tab_9">2</ref>, we might expect that GF ( 2 127 ) might require about 10 12 operations on a modern supercomputer, which is roughly what can be done in a day to a week. On the HEP, which is one of the modern multiprocessor supercomputers, the actual running time was about 7 hours, even though the method of systematic equations yielded about half of the equations practically for free.</p><p>The discussion in the preceding paragraph dealt only with the equation collection phase of the algorithm. The main reason for this is that the methods discussed in Section 5.7 make solving those equations rather negligible. However, in some cases this part of the algorithm might be nontrivial, since it would require doing arithmetic modulo 2 n -1. It is possible to envisage VLSI chips that multiply n-bit integers very fast, but such chips have impractically large areas. At the present time the best practical designs appear to be able to multiply two n-bit integers modulo another n-bit integer in about n clock periods (cf. <ref type="bibr" target="#b11">[12]</ref>). Therefore we can expect that special purpose chips could perform between n -1 10 7 and n -1 10 9 multiplications modulo 2 n -1 per second, depending on the technology. In the case of a modern supercomputer, which could possibly perform about 10 8 multiplications on 32-bit words per second, we could expect about 10 8 /( 10 (n /32 ) 2 ) ∼ ∼ 10 10 n -2 modular multiplications per second, and this will probably go up to 10 11 n -2 in the next generation of supercomputers. (The factor 10 is there largely to compensate for the difficulty of working with multi-word numbers. We ignore the fact that many modern computers, such as the Cray-1, only allow 24-bit integer multiplication.)</p><p>In many situations, solving linear equations should be regarded as a limiting factor not so much due to its high operation count, but rather due to its requirements for a large memory and operation synchronization. A special purpose multiprocessor for the collection of equations is relatively simple to build. Each of the processors in it is quite simple, with essentially no storage, and these processors can operate independently of each other. Every once in a while one of these processors will find a factorization of the desired kind, which will then be sent to a central processor for storage. This also means that a multiprocessor of this kind would be fault-tolerant, since any factorization obtained by a small processor could be easily checked either by the central processor or by other processors without affecting the running time significantly. Therefore it would be very easy to build a multiprocessor to collect equations. On the other hand, a multiprocessor built for solving linear equations would require a very large memory, all the processors in it would have to operate synchronomsly under the control of the central unit, and it would have to operate essentially without errors. Such a multiprocessor would be much harder to build, and so we will often consider the use of a supercomputer for the equation solving phase together with a modest special purpose multiprocessor for the equation collecting phase.</p><p>In the case of the basic algorithm, the estimates derived from Table <ref type="table" target="#tab_9">2</ref> for the running time of the algorithm do change somewhat if we consider using a modern supercomputer to solve the equations. For example, for n = 400, the value 2. 1×10 22 for the number of operations to find the needed equations requires the use of m = 40, which means that the number of unknowns (and equation) is around 5×10 10 .</p><p>Moreover, each equation might involve around 20 nonzero coefficients (which are usually equal to 1, though). Thus even with the use of the method described at the end of Section 5.7 to reduce the number of equations, of sorting on a disk, and sophisticated data structures, it seems that m = 40 would not be practical. However, use of m = 35 would reduce the size of the storage required by a factor of about 30, while increasing the number of operations to obtain the linear equations to only 3. 5×10 22 . Further reduction of m, to ≤30, would bring solution of the linear equations within practical reach without drastically increasing the effort needed for the equation collection phase.</p><p>The basic conclusion to be drawn from the preceding discussion is that using the basic algorithm, a supercomputer could probably be used to complete the first phase for n &lt; ∼ 200, but almost certainly not for n &gt; ∼ 300. Using a relatively simple special purpose multiprocessor to assemble the equation and a supercomputer to solve them might be feasible for n &lt; ∼ 300. Finally, even a very ambitious special purpose machine with 10 6 chips operating at 1 nanosecond per operation would not suffice for n &gt; ∼ 500.</p><p>The above discussion applied to the basic index-calculus algorithm. We next analyze the Coppersmith variation. In this case the performance of the algorithm can again be improved through use of the large irreducible factor variation and the early abort strategy, but again probably only by a factor of 3 to 5.</p><p>Hence we will neglect these techniques. On the other hand, the method described in Section 5.6 leads to a speedup by two or three orders of magnitude, and so we will take it into account. As before, we first neglect the effort needed to solve the linear equations, and estimate only the work involved in finding those equations.</p><p>In the first stage of the Coppersmith algorithm, the time to generate the polynomials w 1 (x) and w 2 (x) can probably be neglected, especially since for each choice of v 1 (x) and v 2 (x) in the variation of Section 5.6 we will typically obtain several (w 1 (x) , w 2 (x) ) pairs. The main work consists of testing the pairs (w 1 , w 2 ) to see whether all the irreducible factors of the w i are in S. By a reasoning almost identical to that used in analyzing the basic algorithm (but with n replaced by 2h), we see that this ought to take about 6mh exclusive or's and shifts. Hence the total number of such operations might be around</p><formula xml:id="formula_163">h2 m + 4 p(h, m) -1 p(M, m) -1 ,<label>(6.2)</label></formula><p>with</p><formula xml:id="formula_164">M = max (h2 k -n + 2 k d 1 -d 2 + deg f 1 (x) , ( 2 k -1 ) d 2 ) ,</formula><p>where we select deg</p><formula xml:id="formula_165">u i (x) ∼ ∼ deg v i (x) ∼ ∼ d i , i = 1 , 2.</formula><p>(There is occasionally some slight advantage in allowing different degree bounds for u 1 and u 2 .) We also have to satisfy</p><formula xml:id="formula_166">p(h + d 1 , m) p(M + d 2 , m) 2 d 1 + d 2 + 1 &gt; ∼ m -1 2 m + 2</formula><p>in order to have enough possible equations.</p><p>In the table below we present approximate values for the minimal number of operations that these estimates suggest. In the preparation of this the basic algorithm, the equation solution phase would be limited more by the large memory size needed then by the number of operations. If we consider somewhat smaller values of m, we obtain Table <ref type="table" target="#tab_11">4</ref>.</p><p>There are two entries in the table for each n. It is possible to obtain finer estimates than in Table <ref type="table" target="#tab_11">4</ref> by using what are in effect fractional values of m. What that would mean, in practice, is that S might consist of all the irreducible polynomials of degrees ≤ m ′ and one third of those of degree m ′ + 1, say. However, since Table <ref type="table" target="#tab_11">4</ref> is meant to be used only as a rough guide, accurate only to within an order of magnitude, there is no point in doing this. A special purpose processor using 10 4 chips running at 100 nanoseconds per cycle might be able to assemble the equations for n &lt; ∼ 700 in about a year, and these equations could probably be solved in about that much time on a supercomputer. For n ∼ ∼ 520, though, a processor consisting of only about 100 chips of this kind might be able to find the equations in about a year (with m = 22), and they could then be solved in about a month on a supercomputer like the Cray-2. (Alternatively, with 10 3 chips in the equation collecting phase, a supercomputer might be needed for only a couple of days.) A very fanciful multiprocessor with 10 6 chips running at 1 nanosecond per cycle might be able to assemble the required equations for n &lt; ∼ 1280 and solve them in between 1 and 10 years. Since even relatively small improvements to presently known algorithms could lower the operation count by a factor of 10 or 100, this means that even n = 1279 should not be considered safe, since it could then be broken using a less ambitious machine. (Note that a machine using 10 6 chips running at around 10 nanoseconds per cycle was proposed by Diffie and Hellman <ref type="bibr" target="#b23">[24]</ref> for finding a DES key in about a day through exhaustive search. Such a machine was generally thought to be too ambitious for the then current technology, but it seems to be generally accepted that it could be built for some tens of millions of dollars by 1990.) On the other hand, n &gt; ∼ 2200 is about 10 6 times harder than n ∼ 1280, and so can be considered safe, barring any new major breakthroughs in discrete logarithm algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Algorithms in GF(p), p prime</head><p>The Silver-Pohlig-Hellman algorithm presented in Section 2 obviously applies directly to prime fields.</p><p>The basic version of the index-calculus algorithm that has been presented so far can also be applied mutatis mutandis to the computation of discrete logarithms in fields GF(p), p aprime. However, its simplest adaptation, even with the use of the early abort strategy <ref type="bibr" target="#b52">[53]</ref>, results in a running time for the first phase of about</p><formula xml:id="formula_167">L ( 5/2 ) 1/2 = L 1. 581... ,<label>(7.1)</label></formula><p>where L stands for any quantity that is <ref type="formula">1</ref>) ) ( log e p log e log e p) be computed rapidly even on today's personal computers. For that reason the field GF ( 2 127 ) should be regarded as very unsafe for cryptographic applications.</p><formula xml:id="formula_168">L = exp ( ( 1 + o(</formula><p>Once n moves up to 400 or so, the first stage of the index-calculus algorithm becomes infeasible to carry out in the fields GF( 2 n ) by anyone not having access to computing resources comparable to those of a modern supercomputer. However, if somebody does use a supercomputer or a large number of smaller machines to carry out the first stage, and makes the database widely available, anyone with access to even a medium speed computer can rapidly compute individual logarithms.</p><p>When n reaches 700 or so, the first stage becomes infeasible even with a supercomputer. However, a relatively modest special purpose device consisting of about 10 4 semi-custom chips would enable a 881 every year, the cryptanalyst will have only that long on average to assemble his database. (This may not be a serious strengthening of security in the case of information that has to be kept secret for extended periods of time.) Therefore having only a few fields to choose from makes a cryptosystem less secure.</p><p>The algorithms presented here show that great care has to be exercised in the choice of the fields GF( 2 n ) for cryptographic applications. First of all, n should be chosen so that 2 n -1 has a large prime factor, preferably larger than 10 40 . Secondly, n should be quite large. Even to protect against attackers possessing small but fast computers of the kind that might be widely available within the next ten years, it seems best to choose n ≥ 800. To protect against sophisticated attacks by opponents capable of building large special purpose machines, n should probably be at least 1500. In fact, to guard against improvements in known algorithms or new methods, it might be safest to use n ≥ 2000 or even larger.</p><p>Given a bound on the size of the key, one can obtain much greater security by using the fields GF(p)</p><p>with p prime then the fields GF( 2 n ). In this case p also has to be chosen so that p -1 contains a large prime factor. If this precaution is observed, fields with p &gt; ∼ 2 750 provide a level of security that can only be matched by the fields GF( 2 n ) with n &gt; ∼ 2000.</p><p>The requirement that p be changed frequently is not an onerous one. It is easy to construct large primes p for which p -1 have a large prime factor (cf. <ref type="bibr" target="#b67">[68]</ref>). Moreover, it is easy to construct them in such a way that the complete factorization of p -1 is known, which makes it easy to find primitive roots g modulo p and prove that they are primitive.</p><p>The discrete logarithm problem in fields GF(p) for which p -1 does have a large prime factor appears to be about as hard as the problem of factoring integers of size about p. The comparison of the asymptotic complexity of the two problems was presented in Section 7. As far as values of practical use are concerned, the best current factorization programs appear to be capable of factoring integers around 2 250 in about 1 day on a supercomputer like the Cray-XMP <ref type="bibr" target="#b21">[22]</ref>. In applications where one is only interested in exchanging keys for use with ordinary cryptographic equipment, the Diffie-Hellman scheme presented in the Section 2 seems comparable to the Rivest-Shamir-Adleman (RSA) scheme, provided one uses fields GF(p).</p><p>However, the best choice is not totally obvious. The Diffie-Hellman scheme has the advantage that the parties exchanging keys do not have to keep their private keys secret (since there are no private keys). It has the disadvantage that there is no authentication. Furthermore, if the Diffie-Hellman scheme is to be used with the same field shared by many people for a prolonged time, the discrete logarithm problem being as hard as factorization loses some of its significance because the cryptanalyst can afford to spend much more time compiling the database. If the field to be used does change from one session to another, though, the Diffie-Hellman scheme appears as a good choice among key distribution systems. </p><formula xml:id="formula_169">                         N(n,m</formula><p>) asymptotically, we use different techniques. The method we use differs from those used to study the analogous problem for ordinary integers (see <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b45">46]</ref>), and relies on the saddle point method <ref type="bibr" target="#b14">[15]</ref>.</p><p>With extra effort, it is capable of producing much more refined estimates than we obtain over much greater ranges of n and m. However, in order to keep the presentation simple, we consider only the ranges most important for cryptographic applications.</p><formula xml:id="formula_170">Theorem A1. Let f m (z) = k = 1 Π m ( 1 -z k ) -I(k) (A.4) and b(z) =   f m f ′ m _ ___ (z)    ′ = k = 1 Σ m I(k)   1 -z k k(k -1 ) z k -2 _ ___________ + ( 1 -z k ) 2 k 2 z 2k -2 _ _______    . (A.5)</formula><p>Then, for n 1/100 ≤ m ≤ n 99/100 , we have</p><formula xml:id="formula_171">k = 1 Σ m 1 -r k I(k) kr k _ ______ = k = 1 Σ m 1 -r k 2 k r k _ _____ + O( 1 )</formula><p>as n → ∞ (uniformly in m satisfying n 1/100 ≤ m ≤ n 99/100 , as will be the case throughout the rest of the exposition), and so</p><formula xml:id="formula_172">k = 1 Σ m 1 -r k I(k) kr k _ ______ = k = 1 Σ m 2 k r k + O( 1 ) = 2r 2r -1 2 m r m -1 _ _______ + O( 1 ) (A.14) = α log n m( 1 + O(n -α + m -1 log n) ) _ _______________________ n α .</formula><p>We conclude that r = r 0 is given by (A.13) with α = α 0 satisfying</p><formula xml:id="formula_173">α 0 = ( log n / m + log log n / m + o( 1 ) ) ( log n) -1 , (A.15) so that α 0 ∼ log n log n / m _ _______ as n → ∞ , (A.16)</formula><p>and that 2 m r 0 m ∼ α 0 nm -1 log n . (A.17)</p><p>From (A.17) and (A.2) we easily conclude that</p><formula xml:id="formula_174">k = 1 Σ m -I(k) log ( 1 -r 0 k ) = k = 1 Σ m k -1 2 k r 0 k + O( 1 ) , (A.18) b(r 0 ) = ( f m f m ′ _ __ (r) ) ′  r = r 0 = k = 1 Σ m   1 -r 0 k I(k) k(k -1 ) r 0 k -2 _ ______________ + ( 1 -r 0 k ) 2 I(k) k 2 r 0 2k -2 _ __________    ∼ 4 mn , (A.19) ( f m f m ′ _ __ (r) ) ′ ′ r = r 0 = O(m 2 n) . (A.20)</formula><p>We now use the above estimates to carry out the saddle point approximation, which proceeds along very standard lines (cf. <ref type="bibr" target="#b14">[15]</ref>). We choose</p><formula xml:id="formula_175">θ 0 = m -1/2 n -599/1200 .</formula><p>If we let a(r 0 ) = log f m (r 0 )n log r 0 , then by (A.12), (A. <ref type="bibr" target="#b18">19)</ref>, and (A.20) we obtain, for θ ≤ θ 0 ,</p><formula xml:id="formula_176">log f m (re iθ ) -n log r -inθ = a(r 0 ) - 2 1 _ _ b(r 0 ) θ 2 + O(m 2 nθ 3 ) = a(r 0 ) - 2 1 _ _ b(r 0 ) θ 2 + O(m 1/2 n -199/400 ) . Therefore 2π 1 _ __ ∫ -θ 0 θ 0 f m (r 0 e iθ ) r 0 -n e -inθ dθ = ( 2πb(r 0 ) ) -1/2 f m (r 0 ) r 0 -n ( 1 + O(m 1/2 n -199/400 ) ) .</formula><p>It remains only to show that the integral over θ 0 &lt; θ ≤ π is negligible. Now for z = re iθ , r = r 0 , and</p><formula xml:id="formula_177">m * = [ 999m /1000 ], we have log f m (r) -log f m (z) = k = 1 Σ m I(k) log  1 -r k 1 -z k _ _____  = k = 1 Σ m k -1 2 k {log 1 -z k  -log ( 1 -r k ) } + O( 1 ) = k = 1 Σ m k -1 2 k r k ( 1 -cos kθ) + O( 1 ) ≥ m -1 2 m * r m * k = m * Σ m ( 1 -cos kθ) + O( 1 ) . (A.21)</formula><p>If θ ≥ 10 4 m -1 , say, the right side above is for some ε, δ &gt; 0, and so the integral over that range is indeed negligible compared to the integral over θ ≤ θ 0 .</p><formula xml:id="formula_178">= m -1 2 m * r m *    m -m * + 2 sin θ/2 sin (m + 2 1 _ _ ) θ -sin (m * + 2 1 _ _ ) θ _ ____________________________     + O( 1 )</formula><p>When we combine all the results obtained above, we obtain the estimate (A.6) of the theorem. Proof of Corollary A2. By (A.19), we know that b(r 0 ) ∼4mn. Now</p><formula xml:id="formula_179">-n log r 0 = n log 2 - m n _ __ α 0 log n (A.24) = n log 2 -( 1 + o( 1 ) ) m n _ __ log m n _ __ .</formula><p>Furthermore, by (A.17),</p><formula xml:id="formula_180">2 k r 0 k = O(n 1/2 m -1/2 log n) , k ≤ m /2 , so k = 1 Σ m k -1 2 k r 0 k = O(n 1/2 m -1/2 ( log n) 2 ) + O(nm -1 ) ,</formula><p>and so by (A.18),</p><formula xml:id="formula_181">log f m (r) = o( m n _ __ log m n _ __ ) .</formula><p>This proves the estimate (A.8) of the corollary.</p><p>Proof of Corollary A3. We first study how r 0 = r 0 (n, m) varies with n. Letting n be a continuous variable defined by (A.12) (with m fixed and r varying), we find that (as in (A. <ref type="bibr" target="#b18">19</ref>) and (A.20))</p><formula xml:id="formula_182">∂r ∂n _ __    r = r 0 ∼ 2mn , (A.25)</formula><p>and for rr 0  = O(n -1 ), 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 16</p><formula xml:id="formula_183">∂r 2 ∂ 2 n _ ___ = O(m 2 n) . Hence for 0 ≤ k ≤ 2m, δ = r 0 (n + k, m) -r 0 (n, m) ∼ k( 2mn) -1 . (A<label>.</label></formula><p>1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 21 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 26 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 31 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 36 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 26 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 31 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 1.00000E+00 36 1.00000E+00 1.00000E+00 1.00000E+00 </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>by ( 5 . 4 )</head><label>54</label><figDesc>, only a small number of irreducibles can divide F d ( f 1 (x) ) to second or higher powers. Hence we conclude that at most only about one in deg f 1 (x) of the irreducible polynomials u(x) of degree d can have the property that u( f 1 (x) ) factors into irreducible polynomials of degree d. Thus if we have only one pair (k, f 1 (x) ) for which (5.2) holds, then we can expect at most about S/( deg f 1 (x) ) systematic equations from this method. We also obtain useful equations from all u(x) for which deg u( f 1 (x) ) ≤ m, but there are relatively few such polynomials u(x). If deg f 1 (x) = 2 (as it is for n = 127, f (x) = x 127 + x + 1), it is easy to see that almost exactly one half of the irreducible polynomials u(x) of a given degree d will have the property that u( f 1 (x) ) factors into irreducible polynomials of degree d. If deg f 1 (x) &gt; 2, the situation is more complicated, in that the u( f 1 (x) ) can factor into products of irreducible polynomials of several degrees, and so the number of useful equations obtained this way is typically considerably smaller than S/( deg f 1 (x) ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>expect to obtain about Np(M, m) 2 pairs (w 1 ,</head><label>21</label><figDesc>w 2 ), where each of the w i factors into irreducibles from S. Consider now some k &gt; m. The probability that a random polynomial of degree ∼ M has exactly one irreducible factor of degree k and all others of degrees ≤ m is about p(Mk, m) I(k) 2 -k , where I(k) is the number of irreducible polynomials of degree k. Therefore we expect that the probability that exactly one of w 1 and w 2 has one irreducible factor of degree k and all other factors of both w 1 and w 2 are of degrees ≤ m is about 2p(Mk, m) p(M, m) I(k) 2 -k .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>be very sparse. (If we use the fast version for generating the h * that is presented in Section 5.3, it is necessary to choose the random v r ∈ S to have only low degrees for this to remain true.) To see just how sparse that matrix is, consider the Coppersmith algorithm in GF( 2 n ), with k, m, and B chosen to satisfy (4.34a-c) with α satisfying (4.38), and β and γ satisfying β = γ and (4.40). If we take M ∼ m -1 2 m , then the matrix of coefficients will have about 2M rows and 2M columns, with columns M + 1 , . . . , 2M (approximately) corresponding to the irreducible polynomials of degree m. We now consider those columns. Any row in the matrix comes from adding two vectors of discrete logarithm coefficients from factorization of two polynomials of degrees about B . 2 k , both of which are divisible only by irreducible factors of degrees ≤m. The probability that a polynomial of degree B . 2 k , which factors into irreducibles of degrees ≤m, also is divisible by a particular chosen irreducible polynomial of degree exactly m is approximately</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>≥ 10 -</head><label>10</label><figDesc>4 2 m * r m * + O( 1 ) ≥ 10 -5 (n / m) 999/1000 + O( 1 ) . (A.22) If θ 0 ≤ θ ≤ 10 4 m -1 , on the other hand, 1cos kθ ≥ 1cos kθ 0 ≥ 10 -3 mn -599/600 , m * ≤ k ≤ m , and the last quantity in (A.21) is ≥ 10 -6 m 1/1000 n 1/1500 + O( 1 ) . (A.23) Combining the estimates (A.22) and (A.23), we conclude that for θ 0 &lt; θ ≤ π, log f m (r)log f m (z) ≥ ε n δ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>26)Therefore log f m (r 0 (n + k, m) )log f m (r 0 (n, m) )= δ f m f m ′ _ __ (r 0 (r, k) ) + O(δ 2 M) ,whereM = r 0 (n, k) ≤ r ≤ r 0 (n, k) + δ max ( f m f m ′ _ __ ) ′ (r) = O(mn) ,and solog f m (r 0 (n + k, m) )log f m (r 0 (n, m) ) ∼ k / m . Since by (A.19), b(r 0 (n + k, m) ) ∼ b(r 0 (n, m) ) ∼ 4mn ,we finally obtain, for r = r 0 (n, m),N(n, m) N(n + k, m) _ __________ ∼ exp (k / m) r -k ( 1 + δr -1 ) -n ∼ r -k ∼ 2 k ( m n _ __ log m n _ __ ) -k / m , (A.27)which yields the desired result. Appendix B. Values of p(n,k), the probability that a random polynomial over GF( 2 ) of degree n will have all its irreducible factors of degrees ≤ k, for various values of n and for 1 ≤ k ≤ 40.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>588... .</figDesc><table><row><cell>exp ( (c 1 log e 2 + o( 1 ) ) (n log e n) 1/2 )</cell></row><row><cell>bits of storage, but these logarithms are needed only once, and so they can be stored on a cheap slow-access</cell></row><row><cell>device, such as tape.</cell></row><row><cell>Our estimates for the running time of the basic index-calculus algorithm for the fields GF( 2 n ) are</cell></row><row><cell>substantially smaller than those of Hellman and Reyneri [30]. This is due primarily to our use of a more</cell></row><row><cell>accurate estimate for p(n, m). The Blake et al. innovation which replaces the polynomial h * by the</cell></row><row><cell>quotient of two polynomials, each of roughly half the degree of h * turns out not to affect the asymptotic</cell></row><row><cell>estimate, since it improves the running time only by the factor 2 n / m , which is M o( 1 ) for</cell></row><row><cell>m ∼ c(n log e n) 1/2 . However, for values of n that might be of practical interest, say 200 ≤ n ≤ 1000, and</cell></row><row><cell>best possible choices of m, this factor 2 n / m is very important, speeding up the algorithm by between two</cell></row><row><cell>and ten orders of magnitude.</cell></row><row><cell>This running time estimate is much lower than for the first stage. The space requirements of the second</cell></row><row><cell>stage are essentially negligible. It is necessary to have access to the logarithms of the elements of S, which</cell></row><row><cell>requires</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>2/3 ) which is periodic with period 1. The minimal value of u is 2β log e 2, with β given by (4.40), while the maximal value of u is 3 2/3 β log e 2 = ( 2. 08008... ) β log e 2. Thus we are faced with the not uncommon situation in which the running time of the algorithm does not satisfy a simple asymptotic relation but exhibits periodic oscillations.</figDesc><table /><note><p>We next discuss the second stage of the Coppersmith algorithm, which computes logarithms of arbitrary elements. It is somewhat more involved than the second stage of the basic version of the algorithm. If h is a polynomial whose logarithm is to be determined, then Coppersmith's second stage consists of a sequence of steps which replace h by a sequence of polynomials of decreasing degrees. The first step is similar to the second stage of the basic algorithm and consists of selecting a random integer s, forming h * as in (4.1), and checking whether h * has all its irreducible factors of degrees ≤ n 2/3 ( log e n) 1/3 , say. (In practice, one would again replace h * by w 1 / w 2 , where the degrees of the w i are &lt; ∼ h /2, and the bound on the degrees of the irreducible factors might be somewhat different, but that is not very important.) The probability of success is approximately p(n, n 2/3 ( log e n) 1/3 ), so we expect to succeed after</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 1 .</head><label>1</label><figDesc>Evaluation of the early abort strategy.</figDesc><table><row><cell cols="3">n _ _____________________________________ m k R ratio of (5.14) to (5.13) 128 16 4 5 2. 47 B / A + 0. 412</cell></row><row><cell>128 16 5</cell><cell>5</cell><cell>1. 73 B / A + 0. 452</cell></row><row><cell>200 20 4</cell><cell>5</cell><cell>2. 67 B / A + 0. 445</cell></row><row><cell>200 20 5</cell><cell>6</cell><cell>2. 32 B / A + 0. 396</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 2 .</head><label>2</label><figDesc>m) -2 (6.<ref type="bibr" target="#b0">1)</ref> operations might be needed to generate the linear equations for the log g v, v ∈ S. Below we give approximations to the minimal values of (6.1) for various values of n as m varies (only values of m ≤ 40 were considered): Operation count for the basic algorithm.</figDesc><table><row><cell cols="3">n _ _______________________________________ minimum of (6.1) m 120 3. 3 × 10 11 19</cell></row><row><cell>160</cell><cell>2. 9 × 10 13</cell><cell>23</cell></row><row><cell>200</cell><cell>1. 6 × 10 15</cell><cell>26</cell></row><row><cell>240</cell><cell>6. 5 × 10 16</cell><cell>29</cell></row><row><cell>280</cell><cell>2. 0 × 10 18</cell><cell>32</cell></row><row><cell>320</cell><cell>5. 2 × 10 19</cell><cell>35</cell></row><row><cell>360</cell><cell>1. 1 × 10 21</cell><cell>37</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 3 .</head><label>3</label><figDesc>table, deg f 1 (x) was taken to be 10, since that is approximately what it is for such cryptographically important values of n as 521, 607, 881, and 1279. Also, only values of m ≤ 40 were considered. Operation count for Coppersmith's algorithm (equation collecting phase only).</figDesc><table><row><cell></cell><cell>approximate</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">n _ ______________________________________________________________________ minimum of (6.2) 2 k h m d 1 d 2</cell></row><row><cell>280</cell><cell>4. 5×10 11</cell><cell>4</cell><cell>70</cell><cell>20</cell><cell>14</cell><cell>16</cell></row><row><cell>400</cell><cell>4. 8×10 13</cell><cell>4</cell><cell>100</cell><cell>23</cell><cell>17</cell><cell>20</cell></row><row><cell>520</cell><cell>3. 0×10 15</cell><cell>4</cell><cell>130</cell><cell>27</cell><cell>20</cell><cell>22</cell></row><row><cell>700</cell><cell>7. 3×10 17</cell><cell>4</cell><cell>175</cell><cell>31</cell><cell>24</cell><cell>26</cell></row><row><cell>880</cell><cell>3. 8×10 18</cell><cell>8</cell><cell>110</cell><cell>36</cell><cell>27</cell><cell>29</cell></row><row><cell>1060</cell><cell>6. 0×10 20</cell><cell>8</cell><cell>133</cell><cell>38</cell><cell>29</cell><cell>31</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 4 .</head><label>4</label><figDesc>Operation count for Coppersmith's algorithm (taking into account limitations of equation solving phase).</figDesc><table><row><cell cols="7">n _ ___________________________________________________________________________________________ value of (6.2) 2 k h m d 1 d 2</cell></row><row><cell>280</cell><cell>2. 7×10 12</cell><cell>4</cell><cell>70</cell><cell>16</cell><cell>17</cell><cell>20</cell></row><row><cell>280</cell><cell>4. 7×10 11</cell><cell>4</cell><cell>70</cell><cell>19</cell><cell>14</cell><cell>17</cell></row><row><cell>400</cell><cell>1. 3×10 14</cell><cell>4</cell><cell>100</cell><cell>20</cell><cell>19</cell><cell>22</cell></row><row><cell>400</cell><cell>7. 3×10 13</cell><cell>4</cell><cell>100</cell><cell>21</cell><cell>18</cell><cell>21</cell></row><row><cell>520</cell><cell>1. 3×10 16</cell><cell>4</cell><cell>130</cell><cell>22</cell><cell>23</cell><cell>25</cell></row><row><cell>520</cell><cell>7. 0×10 15</cell><cell>4</cell><cell>130</cell><cell>23</cell><cell>22</cell><cell>24</cell></row><row><cell>700</cell><cell>1. 2×10 19</cell><cell>4</cell><cell>175</cell><cell>24</cell><cell>28</cell><cell>31</cell></row><row><cell>700</cell><cell>2. 6×10 18</cell><cell>4</cell><cell>175</cell><cell>26</cell><cell>26</cell><cell>29</cell></row><row><cell>880</cell><cell>2. 0×10 21</cell><cell>4</cell><cell>220</cell><cell>27</cell><cell>32</cell><cell>34</cell></row><row><cell>880</cell><cell>4. 3×10 20</cell><cell>4</cell><cell>220</cell><cell>29</cell><cell>30</cell><cell>32</cell></row><row><cell>1060</cell><cell>2. 4×10 24</cell><cell>8</cell><cell>133</cell><cell>30</cell><cell>38</cell><cell>40</cell></row><row><cell>1060</cell><cell>1. 2×10 23</cell><cell>8</cell><cell>133</cell><cell>31</cell><cell>35</cell><cell>37</cell></row><row><cell>1280</cell><cell>4. 3×10 26</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 5 .</head><label>5</label><figDesc>Known Mersenne primes 2 p -1.</figDesc><table><row><cell>VALUES OF p FOR WHICH 2 p -1 IS PRIME _ ________________________</cell></row><row><cell>2</cell></row><row><cell>3</cell></row><row><cell>5</cell></row><row><cell>7</cell></row><row><cell>13</cell></row><row><cell>17</cell></row><row><cell>19</cell></row><row><cell>31</cell></row><row><cell>61</cell></row><row><cell>89</cell></row><row><cell>107</cell></row><row><cell>127</cell></row><row><cell>521</cell></row><row><cell>607</cell></row><row><cell>1,279</cell></row><row><cell>2,203</cell></row><row><cell>2,281</cell></row><row><cell>3,217</cell></row><row><cell>4,253</cell></row><row><cell>4,423</cell></row><row><cell>9,689</cell></row><row><cell>9,941</cell></row><row><cell>11,213</cell></row><row><cell>19,937</cell></row><row><cell>21,701</cell></row><row><cell>23,209</cell></row><row><cell>44,497</cell></row><row><cell>86,243</cell></row><row><cell>132,049</cell></row></table><note><p><p><p><p>1/2 </p>) as n → ∞ . (7.2) It was recently found, however, that there are several algorithms which run in time L</p><ref type="bibr" target="#b19">[20]</ref></p>. The second</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 6 .</head><label>6</label><figDesc>Factorization of Mersenne numbers 2 p -1 (p prime) which contain a very large prime factor. Pn denotes a prime of n decimal digits, PRPn a probable prime of n digits.</figDesc><table><row><cell cols="2">p _ _____________________________________________ Factorization of 2 p -1</cell></row><row><cell>167</cell><cell>2349023 . P44</cell></row><row><cell>197</cell><cell>7487 . P56</cell></row><row><cell>227</cell><cell>269863334377777017 . P52</cell></row><row><cell>241</cell><cell>220000409 . P66</cell></row><row><cell>269</cell><cell>13822297 . P74</cell></row><row><cell>281</cell><cell>80929 . P80</cell></row><row><cell>307</cell><cell>14608903 . 85798519 . 23487583308 . . 78952752017 . P57</cell></row><row><cell>331</cell><cell>16937389168607 . 865118802936559 . P72</cell></row><row><cell>373</cell><cell>25569151 . P105</cell></row><row><cell>409</cell><cell>4480666067023 . 76025626689833 . P97</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 7 .</head><label>7</label><figDesc>Values of I(n), the number of irreducible binary polynomials of degree n.</figDesc><table><row><cell cols="2">n __________ I(n)</cell></row><row><cell>1</cell><cell>2</cell></row><row><cell>2</cell><cell>1</cell></row><row><cell>3</cell><cell>2</cell></row><row><cell>4</cell><cell>3</cell></row><row><cell>5</cell><cell>6</cell></row><row><cell>6</cell><cell>9</cell></row><row><cell>7</cell><cell>18</cell></row><row><cell>8</cell><cell>30</cell></row><row><cell>9</cell><cell>56</cell></row><row><cell>10</cell><cell>99</cell></row><row><cell>11</cell><cell>186</cell></row><row><cell>12</cell><cell>335</cell></row><row><cell>13</cell><cell>630</cell></row><row><cell>14</cell><cell>1161</cell></row><row><cell>15</cell><cell>2182</cell></row><row><cell>16</cell><cell>4080</cell></row><row><cell>17</cell><cell>7710</cell></row><row><cell cols="2">18 14532</cell></row><row><cell cols="2">19 27594 20 52377 </cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>supercomputer could probably compute the database for n &lt; ∼ 460 in about a year, and the next generation might be able to do it for n &lt; ∼ 520. On the other hand, n &gt; ∼ 800 would be safe from such attacks. If we assume that methods such as those of Section 5.7 are to be used to solve the linear equations, then Table4suggests that n &gt; ∼ 700 is safe even from the next generation of supercomputers, while n &lt; ∼ 500 probably isn't.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>The author thanks D. Coppersmith, J. Davenport, J. Davis, D. Ditzel, G. Gonnet, D. Holdridge, J. Jordan, N. K. Karmarkar, L. Kaufman, H. W. Lenstra, Jr., R. Mullin, C. Pomerance, J. Reyneri, B. Richmond, N. Sollenberger, J. Todd, S. Vanstone, and D. Wiedemann for helpful conversations.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>small q, this probability is much more significant, and the way to avoid the problem is to choose x 0 to have entries in a larger field, say GF(q t ) for some small tεZ + .</p><p>The adaptation of the conjugate gradient algorithm outlined above has been tested successfully by the author on some small systems. The advantages of the method include not only speed, since only about NQ operations in the field GF(q t ) are required, where Q is the number of nonzero entries in B, and thus O( log N) or O( ( log N) 2 ) in our problems, but also very modest storage requirements, since aside from the matrix B it is necessary to store the vectors x i , p i , r i for only two consecutive values of i at a time.</p><p>An algorithm due to Lanczos <ref type="bibr" target="#b38">[39]</ref>, somewhat different from the conjugate gradient algorithm, was similarly adapted by Coppersmith to solve the linear systems arising in the index-calculus algorithm.</p><p>Coppersmith used that method to obtain another solution to the linear system that arose in the implementation of his attack on discrete logarithms in GF ( 2 127 ).</p><p>A more elegant method for dealing with the index-calculus linear systems was invented recently by Wiedemann <ref type="bibr" target="#b65">[66]</ref>. Suppose first that we wish to solve for x in Ax = y, where A is a matrix of size N by N (not necessarily symmetric) over a field GF(q). Let v 0 ,v 1 , . . . , v 2N be vectors of length K, which might be 10 or 20, with v j consisting of the first K coefficients of the vector A j y. Since to compute the v j we need only start with y and keep multiplying it by A, without storing all the vectors A j y, we need only O(KN) storage locations, each one capable of storing an element of GF(q), and the number of GF(q) operations to carry out this computation is O(NQ). Now the matrix A satisfies a polynomial equation of degree ≤ N:</p><p>and therefore also for any k ≥ 0,</p><p>(5.17)</p><p>Eq. (5.17) implies that any single component of the v 0 , . . . , v 2N satisfies the linear recurrence with characteristic polynomial</p><p>Step 5: Eliminate that variable which causes the least amount of fill-in.</p><p>The algorithm outlined above can be implemented to run very fast, and it reduces the problem of solving a roughly 2M by 2M system to that of solving an αM by αM system. What is perhaps most remarkable, if the original system is sufficiently sparse, only the first few steps of the algorithm are needed.</p><p>For example, if the elements of the matrix are chosen independently at random, so that the probability of an entry in the last M columns being nonzero is δM -1 , in the next M /2 column is 2δM -1 , etc., where δ ≤ 0. 85 (compared to δ = 0. 693... for the optimal case of Coppersmith's algorithm), and α = 1/32, than</p><p>Steps 1-4 of the algorithm are all that is needed, since by the time they are completed, there is nothing left of the "light" portion of the matrix. This result is confirmed by simulations (with systems of sizes up to 96,000) and by heuristic arguments.</p><p>The method presented above draws on ideas that are well known in the literature on sparse matrices (cf. <ref type="bibr" target="#b10">[11]</ref>). Moreover, some of these ideas have already been used in the factoring integers and computing discrete logarithms. For example, J. Davenport in his computations related to Coppersmith's algorithm <ref type="bibr" target="#b18">[19]</ref> used some heuristic methods to minimize fill-in. Such methods were also used during the execution of the Blake et al. <ref type="bibr" target="#b7">[8]</ref> version of the basic index-calculus algorithm in GF ( 2 127 ). According to R. Mullin (private communication), the system of about 16,500 equations in about that many variables (m = 17 was used) was reduced by methods similar to those presented above to a system of size under 1000, which was then solved by ordinary gaussian elimination. Moreover, their procedure did not involve such tricks as always choosing the equation with fewest nonzero entries during elimination, which appear to result in dramatic improvements in performance. Therefore we expect these methods to be quite useful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Practical and impractical implementations</head><p>Blake, Fuji-Hara, Mullin, and Vanstone <ref type="bibr" target="#b7">[8]</ref> have successfully tested the basic index-calculus algorithm on fields up to GF ( 2 127 ). They estimated that with their VAX 11/780, a relatively slow minicomputer, it would have taken them many CPU months to carry out the first stage of the algorithm for GF ( 2 127 ) with m = 17. On the HEP, a powerful multiprocessor to which they obtained access, their implementation of the algorithm took about 8 hours for the first stage, of which about one hour was devoted to solving linear phases of those algorithms can be used to find individual logarithms in time L 1/2 <ref type="bibr" target="#b19">[20]</ref>.</p><p>The discovery of the new algorithms for computing discrete logarithms in fields GF(p) means that discrete logarithms in these fields are just about as hard to compute as it is to factor integers of size about p, provided that the field GF(p) is changing. If the field were to stay fixed, then there would be an initial phase that would be about as hard to do as factoring a general integer around p, but then each individual logarithm would be relatively easy to compute.</p><p>Until recently, it was thought that the Schnorr-Lenstra algorithm <ref type="bibr" target="#b59">[60]</ref> was the only factorization algorithm that ran in time L, with various other methods, such as the Pomerance quadratic sieve <ref type="bibr" target="#b52">[53]</ref> requiring time L 1 + δ for various δ &gt; 0. Those conclusions were based on the assumption that one had to use general matrix inversion algorithms to solve systems of linear equations. Now, with the methods described in Section 5.7 that take advantage of the sparseness of those systems, there are several algorithms, including the quadratic sieve and the Schroeppel linear sieve, and the new ones proposed in <ref type="bibr" target="#b19">[20]</ref>, which factor integers of size around p in time L.</p><p>It is quite possible that further progress in both discrete logarithm and factorization algorithms could be made in the near future. For example, if one can find, for a given p, integers a,b, and c such that they are all O(p 1/3 + ε ) and such that</p><p>then one obtains a discrete logarithm algorithm and a factorization algorithm with running time</p><p>for the first phase <ref type="bibr" target="#b19">[20]</ref>. Such a,b, and c are expected to exist for all p, and the problem is to construct an algorithm that finds them. In some cases they can be found. For example, if p = a 3c for c = O(p 1/3 ), then (7.3) is satisfied with b = 1. (This version is the "cubic sieve" of Reyneri.) Any algorithm for constructing a,b, and c satisfying (7.3) would help about equally in factoring integers and computing discrete logarithms. In general, while there are algorithms for factorization that do not generalize to give discrete logarithm algorithms (the Schnorr-Lenstra algorithm <ref type="bibr" target="#b59">[60]</ref>, for example), the converse is not the case. Therefore it seems fairly safe to say that discrete logarithms are at least as hard as factoring and likely to remain so.</p><p>The idea behind the Coppersmith variant cannot be extended to the fields GF(p) with p prime. That idea is based on the fact that squaring is a linear operation in GF( 2 ), so that if the difference of two polynomials over GF( 2 ) is of low degree, so is the difference of the squares of those polynomials. Nothing like this phenomenon seems to hold in the fields GF(p), p prime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Cryptographic implications</head><p>The preceding sections presented descriptions of the most important known algorithms for computing discrete logarithms in finite fields. The conclusions to be drawn from the discussion of these algorithms is that great care should be exercised in the choice of the fields GF(q) to be used in any of the cryptosystems described in the Introduction. The Silver-Pohlig-Hellman algorithm presented in Section 2 has running time on the order of √  p , where p is the largest prime factor of q -1. It is possible to decrease the √  p running time in cases where many discrete logarithms in the same field are to be computed, but only at the cost of a substantially longer preprocessing stage. Of the cryptosystems based on discrete logarithms, probably the most likely ones to be implemented are the authentication and key exchange ones (cf. <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b58">59,</ref><ref type="bibr" target="#b68">69]</ref>). To crack one of these systems, it is only necessary to compute one discrete logarithm, since that gives the codebreaker a valid key or password, with which he can then either impersonate a valid user or forge enciphered messages. Thus it can be expected that any discrete logarithm method would be used relatively infrequently in cryptanalysis, so that optimizing the form of the Silver-Pohlig-Hellman algorithm would yield both the preprocessing stage and the average running time on the order of √  p , or at least within a factor of 100 or so of √  p . The Silver-Pohlig-Hellman algorithm can be parallelized to a very large extent, the main limitation arising from the need to have a very large memory, on the order of √  p bits, which would be accessible from all the independent elements. This means that values of p &lt; ∼ 10 25 , say, ought to be avoided in cryptographic applications. On the other hand, for p &gt; ∼ 10 40 , the Silver-Pohlig-Hellman algorithm appears impractical for the foreseeable future.</p><p>The limitation that q -1 have at least one large prime factor, which is imposed by the Silver-Pohlig-</p><p>Hellman algorithm, has led to suggestions that fields GF( 2 n ) be used for which 2 n -1 is a prime. Primes of the form 2 n -1 are known as Mersenne primes, and the known ones are listed in Table <ref type="table">5</ref>. One disadvantage of Mersenne primes is that there are relatively few of them. In particular, there are wide gaps between the consecutive Mersenne primes 2 607 -1, 2 1279 -1, and 2 2203 -1. The index-calculus algorithm is not very sensitive to the factorization of 2 n -1, and so it seems safe to use values of n for which 2 n -1 is not prime, provided it has a large prime factor (&gt; ∼ 10 40 , preferably, for reasons discussed above). Table <ref type="table">6</ref> presents a selection of values of n between 127 and 521 for which the complete factorization of 2 n -1 is known and includes a very large prime factor. (This table is drawn from <ref type="bibr" target="#b13">[14]</ref>,</p><p>except that the primality of the 105-digit factor of 2 373 -1 was proved by the author using the Cohen-Lenstra <ref type="bibr" target="#b16">[17]</ref> version of the Adleman-Pomerance-Rumely primality test <ref type="bibr" target="#b1">[2]</ref>.) Also included are the two values n = 881 and n = 1063, for which the cofactors have not been shown to be prime, although they almost definitely are, since they pass pseudoprime tests. Any one of these values of n will give a cryptosystem that is resistant to attacks by the Silver-Pohlig-Hellman algorithm.</p><p>It would be very desirable to have some additional entries in Table <ref type="table">6</ref> to fill in the gap in Table <ref type="table">5</ref> between n = 1279 and n = 2203. Unfortunately no prime values of n in that range are known for which 2 n -1 has been shown to contain a very large prime factor. It is possible to obtain composite values of n with this property (any multiple of 127 or 241 will do), but these are probably best avoided, since logarithms in these fields GF( 2 n ) might be easy to compute. More generally, it might be advisable to avoid fields GF(q) which have large subfields. Hellman and Reyneri <ref type="bibr" target="#b29">[30]</ref> raised the possibility that the fields GF(p 2 ) with p prime might be more secure than the fields GF(p), since the index-calculus algorithm did not seem to extend to them. However, ElGamal <ref type="bibr" target="#b24">[25]</ref> has shown how to modify the index-calculus algorithm to apply to most of the fields GF(p 2 ). Furthermore, ElGamal's approach can be extended to all the fields GF(p 2 ), and in fact to fields GF(p n ) with n bounded. Thus fields of this kind appear not to offer increased security. In fact, these fields may be very weak because of the possibility of moving between the field and its subfields. As an example of the danger that exists, it can be shown that if p + 1 is divisible only by small primes, computing logarithms in GF(p 2 ) is only about as hard as in GF(p).</p><p>In the case of GF ( 2 127 ), the first stage of the index-calculus algorithm can now be carried out in a matter of hours on a minicomputer. Furthermore, once the database is generated, individual logarithms can     cryptanalyst to assemble the desired database even in these ranges. Such a special purpose computer might be assembled as part of a university project (cf. <ref type="bibr" target="#b61">[62]</ref>). Furthermore, computations of individual logarithms could still be performed on any relatively fast computer. Special purpose machines of this kind, but either with more special chips or with faster chips could probably be used to assemble the databases for n up to perhaps 1200, but might have difficulty solving the system of linear equations.</p><p>The fields GF( 2 n ) have been preferred for cryptographic applications because of ease of implementation. There are penalties for this gain, though. One is that the codebreaker's implementation is correspondingly easy to carry out. Another is that logarithms in the fields GF( 2 n ) are much easier to compute than in the fields GF(p) for p a prime, p ∼ 2 n , especially now that the Coppersmith algorithm is available <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. Still another disadvantage of the fields GF( 2 n ) as compared with the prime fields of the same order is that there are very few of them. All of the fields GF( 2 n ) with a fixed value of n are isomorphic, and so can be regarded as essentially the same field. On the other hand, there are many primes p with 2 n -1 &lt; p &lt; 2 n . This is important, since in the index-calculus algorithm (and to some extent also in the Silver-Pohlig-Hellman algorithm) the initial preprocessing stage has to be done only once, and once it's done, individual logarithms are computable relatively fast. If the field can be changed, say every month or Let I(k) denote the number of irreducible polynomials over GF( 2 ) that are of degree k. Then it is well-known <ref type="bibr" target="#b37">[38]</ref> that</p><p>where µ(d) is the Mo . . bius µ-function. The formula (A.1) provides an efficient method for computing I(k), the first few values of which are shown in Table <ref type="table">7</ref>. In addition, (A.1) shows immediately that</p><p>We define N(k, 0 ) = 1 if k = 0 and N(k, 0 ) = 0 if k ≠ 0. Also, we adopt the convention that N(k,m) = 0 if k &lt; 0 and m ≥ 0. With these conventions, we obtain the following recurrence, valid for n, m &gt; 0:</p><p>To prove the validity of (A.3), note that any polynomial f (x) of degree n, all of whose irreducible factors are of degrees ≤ m, can be written uniquely as</p><p>where the u(x) are all of degree k for some k, (A.12)</p><p>Since I(k) &gt; 0, it is clear that (A.12) has a unique solution r = r 0 with 0 &lt; r 0 &lt; 1. We next estimate r 0 and f m (r 0 ). We consider n 1/100 ≤ m ≤ n 99/100 , n → ∞, and take r = exp ( m α log n _ _______log 2 ) , 10 -3 ≤ α ≤ 10 3 , (A. <ref type="bibr" target="#b12">13)</ref> say. (All logrithms are to base e in this appendix.) Then, by (A.2),</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A subexponential algorithm for the discrete logarithm problem with applications to cryptography</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th IEEE Found. Comp. Sci. Symp</title>
		<meeting>20th IEEE Found. Comp. Sci. Symp</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="55" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On distinguishing prime numbers from composite numbers</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Adleman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pomerance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Rumely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals Math</title>
		<imprint>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="173" to="206" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Sequences constructed by operations modulo 2 n -1 or modulo 2 n and their application in evaluating the complexity of a log operation over GF</title>
		<author>
			<persName><forename type="first">B</forename><surname>Arazi</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An efficient parallel algorithm for the solution of large sparse linear matrix equations</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Parr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dewe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Discrete logarithms and factoring</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bach</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Barker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sparse Matrix Techniques</title>
		<title level="s">Lecture Notes in Mathematics #</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="volume">572</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Factoring polynomials over large finite fields</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Berlekamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="713" to="735" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Computing logarithms in finite fields of characteristic two</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Blake</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fuji-Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Mullin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Alg. Disc. Methods</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="276" to="285" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">How to generate cryptographically strong sequences of pseudo random bits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comp</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Computational Complexity of Algebraic and Numeric Problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Munro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>American Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Brameller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Allan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Hamam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<pubPlace>Sparsity, Pitman</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A fast modular multiplication algorithm with applications to two key crytography</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Brickell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: Proceedings of CRYPTO &apos;82</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sherman</surname></persName>
		</editor>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="51" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Some remarks on the Herlestam-Johannesson algorithm for computing logarithms over GF</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: Proceedings of CRYPTO &apos;82</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sherman</surname></persName>
		</editor>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">11 , 12 up to High Powers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Brillhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lehmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Selfridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Tuckerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Wagstaff</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. Math. Society</title>
		<imprint>
			<date type="published" when="1983">b = 2 , 3 , 5 , 6 , 7 , 10 ,. 1983</date>
		</imprint>
	</monogr>
	<note>Factorizations of b n ±1</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>De Bruijn</surname></persName>
		</author>
		<title level="m">Asymptotic Methods in Analysis</title>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1958">1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A new algorithm for factoring polynomials over finite fields</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Cantor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zassenhaus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="587" to="592" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Primality testing and Jacobi sums</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="297" to="330" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
		<title level="m">Proc. 16th ACM Symp. Theory of Computing</title>
		<meeting>16th ACM Symp. Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="201" to="207" />
		</imprint>
	</monogr>
	<note>Evaluating logarithms in GF</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast evaluation of logarithms in fields of characteristic two</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory IT</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="587" to="594" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Odlyzko</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>manuscript in preparation</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the asymptotic complexity of matrix multiplication</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Winograd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comp</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="472" to="492" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Holdridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Simmons</surname></persName>
		</author>
		<title level="m">Status report on factoring</title>
		<imprint/>
		<respStmt>
			<orgName>Sandia National Laboratories</orgName>
		</respStmt>
	</monogr>
	<note>to appear in Proc. EUROCRYPT 84</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">New directions in cryptography</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory, IT</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="644" to="654" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Exhaustive cryptanalysis of the NBS Data Encryption Standard</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="74" to="84" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A subexponential-time algorithm for computing discrete logarithms over GF(p 2 )</title>
		<author>
			<persName><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A public key cryptosystem and a signature scheme based on discrete logarithms</title>
		<author>
			<persName><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Computer Solution of Large Sparse Positive Definite Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-H</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Shift-register Sequences</title>
		<author>
			<persName><forename type="first">S</forename><surname>Golomb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967</date>
			<publisher>Holden-Day</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Analysis of the Berlekamp-Massey feedback shift-register synthesis algorithm</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">G</forename><surname>Gustavson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Dev</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="204" to="212" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast computation of discrete logarithms in GF</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Hellman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Reyneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptography: Proceedings of CRYPTO &apos;82</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sherman</surname></persName>
		</editor>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="3" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">The number of positive integers ≤ x and free of prime factors &gt;</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hensley</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note type="report_type">preprint</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<author>
			<persName><forename type="first">T</forename><surname>Herlestam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johannesson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">On computing logarithms over GF( 2 p )</title>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="326" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Methods of conjugate gradients for solving linear systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Hestenes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stiefel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Res. Nat. Bureau of Standards</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="409" to="436" />
			<date type="published" when="1952">1952</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">On the number of positive integers ≤ x and free of prime factors &gt;</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hildebrand</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to be published</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On the complexity of a parity problem related to coding theory</title>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ja</forename><forename type="middle">'</forename><surname>Ja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">'</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatesan</surname></persName>
		</author>
		<idno>81-5</idno>
	</analytic>
	<monogr>
		<title level="j">Pennsylvania State Univ. Computer Sci. Report CS</title>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seminumerical Algorithms</title>
		<title level="s">The Art of Computer Programming</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Cryptography: A Primer</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Konheim</surname></persName>
		</author>
		<imprint>
			<date>19981</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Communication privacy: Integration of public and secret key cryptography</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kowalchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Schanning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Powers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NTC Conference Record</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="49" to="50" />
			<date type="published" when="1980-12-05">1.5, Dec. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Solution of systems of linear equations by minimized iterations</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lanczos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Res. Nat. Bureau of Standards</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="33" to="53" />
			<date type="published" when="1952">1952</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Random equivalence of factorization and computation of orders</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Comp. Sci</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">How discreet is the discrete log?</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15-th ACM Symp. Theory of Computing</title>
		<meeting>15-th ACM Symp. Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="413" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The Theory of Error-Correcting Codes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">On integers free of large prime divisors</title>
		<author>
			<persName><forename type="first">H</forename><surname>Maier</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to be published</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Shift-register synthesis and BCH decoding</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory IT</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="122" to="127" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Logarithms in finite cyclic groups -cryptographic issues</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Benelux Symp. on Inform. Theory</title>
		<meeting>4th Benelux Symp. on Inform. Theory<address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983-05">May 1983</date>
			<biblScope unit="page" from="17" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Merkle</surname></persName>
		</author>
		<title level="m">Secrecy, authentication, and public key systems</title>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Electrical Engineering, Stanford Univ.</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">On factorization, with a suggested new approach</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="155" to="172" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Mullin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>manuscript in preparation</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Public key distribution in matrix rings</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W K</forename><surname>Odoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Varadharajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronics Letters</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="386" to="387" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">An efficient signature scheme based on quadratic forms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th ACM Symp. Theory of Comp</title>
		<meeting>16th ACM Symp. Theory of Comp</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="208" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">An improved algorithm for computing logarithms over GF(p) and its cryptographic significance</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Pohlig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory IT</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="106" to="110" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Monte Carlo methods for index computations ( mod p)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pollard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="918" to="924" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Analysis and comparison of some integer factoring algorithms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pomerance</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Methods in Number Theory: Part 1</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jr</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Tijdeman</surname></persName>
		</editor>
		<meeting><address><addrLine>Math. Centre Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page" from="89" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A high security log-in procedure</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">B</forename><surname>Purdy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="442" to="445" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Probabilistic algorithms in finite fields</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comp</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="273" to="280" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Shift-register synthesis (modulo m)</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Reeds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comp</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Probabilistic analysis and performance modelling of the &quot;Swedish&quot; algorithm and modifications</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Sachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Berkovits</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to be published</note>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
		<title level="m">Generating random walks in groups</title>
		<imprint/>
	</monogr>
	<note type="report_type">preprint</note>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Schanning</surname></persName>
		</author>
		<title level="m">Data encryption with public key distribution, EASCON Conf. Rec</title>
		<meeting><address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1979-10">Oct. 1979</date>
			<biblScope unit="page" from="653" to="660" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A Monte Carlo factoring algorithm with linear storage</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="289" to="311" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A new implementation of sparse gaussian elimination</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schreiber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Math. Software</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="256" to="276" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">An extended precision operand computer</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Wagstaff</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st Southeast Region. ACM Conference</title>
		<meeting>21st Southeast Region. ACM Conference</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Realization and application of the Massey-Omura lock</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K S</forename><surname>Wah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Intern. Zurich Seminar</title>
		<meeting>Intern. Zurich Seminar</meeting>
		<imprint>
			<date type="published" when="1984">March 6-8, 1984</date>
			<biblScope unit="page" from="175" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A polynomial form for logarithms modulo a prime</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wells</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Tables of Indices and Primitive Roots</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Western</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Royal Society Mathematical Tables</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="1968">1968</date>
			<publisher>Cambridge Univ. Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Solving sparse linear equations over finite fields</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wiedemann</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>manuscript in preparation</note>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">Finding logarithms over large finite fields</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Willett</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>in prepration</note>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Some remarks concerning the M.I.T. public-key system</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BIT</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="525" to="538" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">A single-chip VLSI implementation of the discrete exponential public key distribution system</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. GLOBCOM-82</title>
		<meeting>GLOBCOM-82</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="173" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">A conversion algorithm for logarithms on GF( 2 n )</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zierler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="353" to="356" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Zierler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Brillhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">On primitive trinomials (mod 2)</title>
		<imprint>
			<date type="published" when="1968">1968</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="541" to="554" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">On primitive trinomials (mod 2), II</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zierler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Brillhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Control</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="566" to="569" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
