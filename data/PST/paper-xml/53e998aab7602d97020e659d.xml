<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">HAIL: A High-Availability and Integrity Layer for Cloud Storage</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kevin</forename><forename type="middle">D</forename><surname>Bowers</surname></persName>
							<email>kbowers@rsa.com</email>
							<affiliation key="aff0">
								<orgName type="institution">RSA Laboratories Cambridge</orgName>
								<address>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ari</forename><surname>Juels</surname></persName>
							<email>ajuels@rsa.com</email>
							<affiliation key="aff1">
								<orgName type="institution">RSA Laboratories Cambridge</orgName>
								<address>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alina</forename><surname>Oprea</surname></persName>
							<email>aoprea@rsa.com</email>
							<affiliation key="aff2">
								<orgName type="institution">RSA Laboratories Cambridge</orgName>
								<address>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">HAIL: A High-Availability and Integrity Layer for Cloud Storage</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">60ACE3CD39ED5E78205442F21A0779D3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>E.3 [Data]: [Data Encryption] Distributed storage systems</term>
					<term>cloud storage</term>
					<term>data availability</term>
					<term>erasure codes</term>
					<term>proofs of retrievability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce HAIL (High-Availability and Integrity Layer), a distributed cryptographic system that allows a set of servers to prove to a client that a stored file is intact and retrievable. HAIL strengthens, formally unifies, and streamlines distinct approaches from the cryptographic and distributed-systems communities. Proofs in HAIL are efficiently computable by servers and highly compact-typically tens or hundreds of bytes, irrespective of file size. HAIL cryptographically verifies and reactively reallocates file shares. It is robust against an active, mobile adversary, i.e., one that may progressively corrupt the full set of servers. We propose a strong, formal adversarial model for HAIL, and rigorous analysis and parameter choices. We show how HAIL improves on the security and efficiency of existing tools, like Proofs of Retrievability (PORs) deployed on individual servers. We also report on a prototype implementation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Cloud storage denotes a family of increasingly popular on-line services for archiving, backup, and even primary storage of files. Amazon S3 [1] is a well known example. Cloud-storage providers offer users clean and simple file-system interfaces, abstracting away the complexities of direct hardware management. At the same time, though, such services eliminate the direct oversight of component reliability and security that enterprises and other users with high service-level requirements have traditionally expected.</p><p>To restore security assurances eroded by cloud environments, researchers have proposed two basic approaches to client verification of file availability and integrity. The cryptographic community has proposed tools called proofs of retrievability (PORs) <ref type="bibr" target="#b22">[23]</ref> and proofs of data possession (PDPs) <ref type="bibr" target="#b1">[2]</ref>. A POR is a challengeresponse protocol that enables a prover (cloud-storage provider) to demonstrate to a verifier (client) that a file F is retrievable, i.e., recoverable without any loss or corruption. The benefit of a POR over simple transmission of F is efficiency. The response can be highly compact (tens of bytes), and the verifier can complete the proof using a small fraction of F .</p><p>As a standalone tool for testing file retrievability against a single server, though, a POR is of limited value. Detecting that a file is corrupted is not helpful if the file is irretrievable and the client has no recourse. Thus PORs are mainly useful in environments where F is distributed across multiple systems, such as independent storage services. In such environments, F is stored in redundant form across multiple servers. A verifier (user) can test the availability of F on individual servers via a POR. If it detects corruption within a given server, it can appeal to the other servers for file recovery. To the best of our knowledge, the application of PORs to distributed systems has remained unexplored in the literature.</p><p>A POR uses file redundancy within a server for verification. In a second, complementary approach, researchers have proposed distributed protocols that rely on queries across servers to check file availability <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b30">31]</ref>. In a distributed file system, a file F is typically spread across servers with redundancy-often via an erasure code. Such redundancy supports file recovery in the face of server errors or failures. It can also enable a verifier (e.g., a client) to check the integrity of F by retrieving fragments of F from individual servers and cross-checking their consistency.</p><p>In this paper, we explore a unification of the two approaches to remote file-integrity assurance in a system that we call HAIL (High-Availability and Integrity Layer).</p><p>HAIL manages file integrity and availability across a collection of servers or independent storage services. It makes use of PORs as building blocks by which storage resources can be tested and reallocated when failures are detected. HAIL does so in a way that transcends the basic single-server design of PORs and instead exploits both within-server redundancy and cross-server redundancy.</p><p>HAIL relies on a single trusted verifier-e.g., a client or a service acting on behalf of a client-that interacts with servers to verify the integrity of stored files. (We do not consider a clientless model in which servers perform mutual verification, as in distributed information dispersal algorithms such as <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">20]</ref>.) HAIL offers the following benefits: Strong file-intactness assurance: HAIL enables a set of servers to prove to a client via a challenge-response protocol that a stored file F is fully intact-more precisely, that the client can recover F with overwhelming probability. HAIL protects against even small, e.g., single-bit, changes to F .</p><p>Low overhead: The per-server computation and bandwidth required for HAIL is comparable to that of previously proposed PORs. Apart from its use of a natural file sharing across servers, HAIL improves on PORs by eliminating check values and reducing withinserver file expansion.</p><p>Strong adversarial model: HAIL protects against an adversary that is active, i.e., can corrupt servers and alter file blocks and mobile, i.e., can corrupt every server over time.</p><p>Direct client-server communication: HAIL involves one-to-one communication between a client and servers. Servers need not intercommunicate-or even be aware of other servers' existence. (In comparison, some information dispersal algorithms involve serverto-server protocols, e.g., <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">20]</ref>.) The client stores just a secret key.</p><p>Static file protection: HAIL protects static stored objects, such as backup files and archives. Constructing protocols to accommodate file updates, i.e., to provide integrity assurance for dynamically changing objects, is left to future work. Our two broad conceptual contributions in HAIL are:</p><p>Security modeling. We propose a strong, formal model that involves a mobile adversary, much like the model that motivates proactive cryptographic systems <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b20">21]</ref>. A mobile adversary is one capable of progressively attacking storage providers-and in principle, ultimately corrupting all providers at different times.</p><p>None of the existing approaches to client-based file-integrity verification treats the case of a mobile adversary. We argue that the omission of mobile adversaries in previous work is a serious oversight. In fact, we claim that a mobile adversarial model is the only one in which dynamic, client-based verification of file integrity makes sense. The most common alternative model is one in which an adversary (static or adaptive) corrupts a bounded number of servers. As real-world security model for long-term file storage, this approach is unduly optimistic: It assumes that some servers are never corrupted. More importantly, though, an adversarial model that assumes a fixed set of honest servers for all time does not require dynamic integrity checking at all: A robust file encoding can guarantee file recovery irrespective of whether or not file corruptions are detected beforehand.</p><p>HAIL design strategy: Test-and-Redistribute (TAR). HAIL is designed like a proactive cryptographic system to withstand a mobile adversary. But HAIL aims to protect integrity, rather than secrecy. It can therefore be reactive, rather than proactive. We base HAIL on a new protocol-design strategy that we call TAR (Test-And-Redistribute). With TAR, the client uses PORs to detect file corruption and trigger reallocation of resources when neededand only when needed. On detecting a fault in a given server via challenge-response, the client communicates with the other servers, recovers the corrupted shares from cross-server redundancy built in the encoded file, and resets the faulty server with a correct share.</p><p>Our TAR strategy reveals that for many practical applications, PORs and PDPs are overengineered. PORs and PDPs assume a need to store explicit check values with the prover. In a distributed setting like that for HAIL, it is possible to obtain such check values from the collection of service providers itself. On the other hand, distributed protocols for checking file availability are largely underengineered: Lacking robust testing and reallocation, they provide inadequate protection against mobile adversaries.</p><p>Three main coding constructions lie at the heart of HAIL:</p><p>Dispersal code: In HAIL, we use what we call a dispersal code for robustly spreading file blocks across servers. For the dispersal code in HAIL, we propose a new cryptographic primitive that we call an integrity-protected error-correcting code (IP-ECC). Our IP-ECC construction draws together PRFs, ECCs, and universal hash functions (UHFs) into a single primitive. This primitive is an error-correcting code that is, at the same time, a corruption-resilient MAC on the underlying message. The additional storage overhead is minimal-basically just one extra codeword symbol.</p><p>In a nutshell, our IP-ECC is based on three properties of (certain) universal hash function families h: (1) h is linear, i.e., h κ(m) + hκ(m ) = hκ(m + m ) for messages m and m and key κ; (2) For a pseudorandom function family (PRF) g, the function hκ(m) + g κ (m) is a cryptographic message-authentication code (MAC) on m; and (3) hκ(m) may be treated as a parity block in an errorcorrecting code applied to m.</p><p>Server code: File blocks within each server are additionally encoded with an error-correcting code that we call a server code. This code protects against the low-level corruption of file blocks that may occur when integrity checks fail. (For efficiency, our server code is a computational or "adversarial" error-correcting code as defined in Bowers et al. <ref type="bibr" target="#b5">[6]</ref>.)</p><p>Aggregation code: HAIL uses what we call an aggregation code to compress responses from servers when challenged by the client. It acts across multiple codewords of the dispersal code. One feature of the aggregation code is that it combines / aggregates multiple MACs in our IP-ECC into a single composite MAC. This composite MAC verifies correctly only if it represents a combination of valid MACs on each of the aggregated codewords.</p><p>Note that while the aggregation code is built on an error-correcting code, it is computed as needed, and thus imposes no storage or fileencoding overhead. Organization. We review related work in Section 2. We give an overview of the HAIL construction and its main technical ingredients in Section 3. We introduce our adversarial model in Section 4 and describe technical building blocks for HAIL in Section 5. The details of the HAIL protocol are described in Section 6, and its security properties in Section 7. We give implementation results in Section 8 and conclude in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>HAIL may be viewed loosely as a new, service-oriented version of RAID (Redundant Arrays of Inexpensive Disks). While RAID manages sector redundancy dynamically across hard-drives, HAIL manages file redundancy across cloud storage providers. Recent multi-hour failures in S3 illustrate the need to protect against basic service failures in cloud environments. In view of the rich targets for attack that cloud storage providers will present, HAIL is designed to withstand Byzantine adversaries. (RAID is mainly designed for crash-recovery.)</p><p>Information dispersal. Distributed information dispersal algorithms (IDA) that tolerate Byzantine servers have been proposed <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">20]</ref>. In these algorithms, file integrity is enforced within the pool of servers itself. Some protocols protect against faulty clients that send inconsistent shares to different servers <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">20]</ref>. In contrast, HAIL places the task of file-integrity checking in the hands of the client or some other trusted, external service. Unlike previous work, which verifies integrity at the level of individual file blocks, HAIL provides assurance at the granularity of a full file. This difference motivates the use of PORs in HAIL, rather than block-level integrity checks.</p><p>Universal Hash Functions. Our IP-ECC primitive fuses several threads of research that have emerged independently. At the heart of this research are Universal Hash-Functions (UHFs). (In the distributed systems literature, common terms for variants of UHFs are algebraic signatures <ref type="bibr" target="#b30">[31]</ref> or homomorphic fingerprinting <ref type="bibr" target="#b19">[20]</ref>.) UHFs can be used to construct message-authentication codes (MAC) <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b13">14]</ref> (see <ref type="bibr" target="#b27">[28]</ref> for a performance evaluation of various schemes). In particular, a natural combination of UHFs with pseudorandom functions (PRFs) yields MACs.</p><p>PORs and PDPs. Juels and Kaliski (JK) <ref type="bibr" target="#b22">[23]</ref> formally define PORs and propose a POR protocol that only supports a limited number of challenges. Shacham and Waters (SW) <ref type="bibr" target="#b31">[32]</ref> offer alternative constructions based on the idea of storing block integrity values that can be aggregated to reduce the communication complexity of a proof. They construct symmetric-key POR protocols based on the UHF + PRF paradigm and publicly verifiable PORs based on publicly verifiable homomorphic authenticators.</p><p>In concurrent and independent work, Bowers et al. <ref type="bibr" target="#b5">[6]</ref> and Dodis et al. <ref type="bibr" target="#b11">[12]</ref> give frameworks for POR protocols that generalize the JK and SW protocols. Both papers propose the use of an errorcorrecting code in computing server responses to challenges with the goal of ensuring file extraction through the challenge-response interface. The focus of <ref type="bibr" target="#b11">[12]</ref> is mostly theoretical in providing extraction guarantees for adversaries replying correctly to an arbitrary small fraction of challenges. In contrast, Bowers et al. consider POR protocols of practical interest (in which adversaries with high corruption rates are detected quickly) and show different parameter tradeoffs when designing POR protocols.</p><p>Ateniese et al. <ref type="bibr" target="#b1">[2]</ref> propose a closely related construction called a proof of data possession (PDP). A PDP detects a large fraction of file corruption, but does not guarantee file retrievability. Subsequent work gives file update protocols in the PDP model <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">13]</ref>. Curtmola et al. <ref type="bibr" target="#b10">[11]</ref> proposed an extension of PDPs to multiple servers. Their proposal essentially involves computational cost reduction through PDP invocations across multiple replicas of a single file, rather than a share-based approach. Earlier closely related constructions to PORs and PDPs include <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>Distributed protocols for dynamic file-integrity checking. Lillibridge et al. <ref type="bibr" target="#b24">[25]</ref> propose a distributed scheme in which blocks of a file F are dispersed across n servers using an (n, m)-erasure code. Servers spot-check the integrity of one another's fragments using message authentication codes (MACs).</p><p>Schwartz and Miller (SM) <ref type="bibr" target="#b30">[31]</ref> propose a scheme that ensures file integrity through distribution across multiple servers, using errorcorrecting codes. They employ keyed algebraic encoding and streamcipher encryption to detect file corruptions. Their keyed encoding function is equivalent to a Reed-Solomon code in which codewords are generated through keyed selection of symbol positions. We adopt some ideas of simultaneous MACing and error-correcting in our HAIL constructions, but we define the construction rigorously and prove its security properties.</p><p>Proactive cryptography. Our adversarial model is inspired by the literature on proactive cryptography initiated by <ref type="bibr" target="#b21">[22]</ref>, which has yielded protocols resilent to mobile adversaries for secret sharing (e.g., <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b6">7]</ref>) as well as signature schemes (e.g., <ref type="bibr" target="#b20">[21]</ref>). In previous proactive systems, key compromise is a silent event; consequently, these systems must redistribute shares automatically and provide protections that are proactive. Corruption of a stored file, however, is not a silent event. It results in a change in server state that a verifier can detect. For this reason, HAIL can rely on remediation that is reactive. It need not automatically refresh file shares at each interval, but only on detecting a fault.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">HAIL OVERVIEW</head><p>In this section, we present the key pieces of intuition behind HAIL. We start with simple constructions and build up to more complex ones.</p><p>In HAIL, a client distributes a file F with redundancy across n servers and keeps some small (constant) state locally. The goal of HAIL is to ensure resilience against a mobile adversary. This kind of powerful adversary can potentially corrupt all servers across the full system lifetime. There is one important restriction on a mobile adversary, though: It can control only b out of the n servers within any given time step. We refer to a time step in this context as an epoch.</p><p>In each epoch, the client that owns F (or potentially some other entity on the client's behalf) performs a number of checks to assess the integrity of F in the system. If corruptions are detected on some servers, then F can be reconstituted from redundancy in intact servers and known faulty servers replaced. Such periodic integrity checks and remediation are an essential part of guaranteeing data availability against a mobile adversary: Without integrity checks, the adversary can corrupt all servers in turn across n/b epochs and modify or purge F at will.</p><p>Let us consider a series of constructions, explaining the shortcomings of each and showing how to improve it. In this way, we introduce the full conceptual complexity of HAIL incrementally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Replication system.</head><p>A first idea for HAIL is to replicate F on each of the n servers. Cross-server redundancy can be used to check integrity. To perform an integrity check, the client simply chooses a random file-block position j and retrieves the corresponding block Fj of F from each server. Provided that all returned blocks are identical, the client concludes that F is intact in that position. If it detects any inconsistencies, then it reconstructs F (using majority decoding across servers) and removes / replaces faulty servers. By sampling multiple file-block positions, the client can boost its probability of detecting corruptions.</p><p>A limitation of this approach is that the client can only feasibly inspect a small portion of F . Another is that while the client checks consistency across servers, it does not directly check integrity, i.e., that the retrieved block for position j is the one originally stored with F . Consequently, this simple approach is vulnerable to a creeping-corruption attack. The adversary picks a random position i and changes the original block value Fi to a corrupted value Fi in all b servers corrupted during a given epoch. After T = n/(2b) epochs, the adversary will have changed Fi to Fi on a majority of servers. At that point, majority decoding will fail to reconstruct block Fi.</p><p>Because the client can feasibly check only a small fraction of the file, the probability that it will detect temporary inconsistencies introduced by the adversary's corruptions is low. Thus, the adversary can escape detection and render F unretrievable with high probability in T epochs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Replication system with POR.</head><p>To achieve better resilence against a creeping-corruption attack, we might employ a POR system (e.g., <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b5">6]</ref>) on each of the n servers. In a single-server POR system, F is encoded under an error-correcting code (or erasure code) that we refer to in HAIL as the server code. The server code renders each copy of F robust against a fraction c of corrupted file blocks, protecting against the single-block corruptions of our previous approach. (Here c is the error rate of the server code.) There are then two options to check the integrity of F . One is to use the single-server POR approach of embedding integrity checks within each server's copy of F . This approach, however, imposes high storage overhead: It does not take advantage of cross-server redundancy.</p><p>An alternative approach is to perform integrity checks by comparing block values in a given position j using cross-server redundancy as in our previous construction. With this approach, the system is still vulnerable to a creeping-corruption attack, but much less than in the previous construction. Suppose that the POR can detect inconsistencies within a server if the adversary modifies at least d -fraction of blocks. Assuming that the client performs majority decoding to replace faulty servers whenever it detects corruption, this approach will ensure the integrity of F with high probability for T = n/(2b) × ( c / d ) epochs-improving over the previous approach by a factor of c/ d .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dispersal code with POR.</head><p>We can improve the storage overhead of the previous approach with a more intelligent approach to creating file redundancy across servers. Rather than replicating F across servers, we can instead distribute it using an error-correcting (or erasure) code. We refer to this code in HAIL as the dispersal code. In HAIL, each file block is individually distributed across the n servers under the dispersal code.</p><p>Let (n, ) be the parameters of the dispersal code. We assume for convenience that this code is systematic, i.e., that it preserves message blocks in their original form. Then is the number of primary servers, those servers that store fragments of the original file F . The remaining nare secondary servers, or redundant servers, i.e., servers that maintain additional redundancy/parity blocks and help recover from failure.</p><p>A graphical representation of dispersal encoding is given in Figure <ref type="figure" target="#fig_0">1</ref>. Before transforming the file F into a distributed, encoded representation, we partition it into distinct segments F (1) , . . . , F ( ) and distribute these segments across the primary servers S1, . . . , S . This distributed cleartext representation of the file remains untouched by our subsequent encoding steps. We then encode each segment F (j) under the server code with error rate c. The effect of the server code is to extend the "columns" of the encoded matrix by adding parity blocks. Next, we apply the dispersal code to create the parity blocks that reside on the secondary servers. It extends the "rows" of the encoded matrix across the full set of n servers S1, . . . , Sn.</p><p>With this scheme, it is possible to use cross-server redundancy to check the integrity of F . The client / verifier simply checks that the blocks in a given position, i.e., "row," constitute a valid codeword in the dispersal code. By means of the dispersal code, we reduce the overall storage cost of our previous construction from n|F | to</p><formula xml:id="formula_0">(n/ )|F |.</formula><p>Use of a dispersal code does reduce the number of epochs T over which it is possible to ensure the integrity of F with high probability. This is because the adversary can now corrupt a given "row" / codeword merely by corrupting at least (d -1)/2 blocks, where d is the minimum distance of the dispersal code. (For an (n, )-Reed-Solomon dispersal code, for instance, d = n -+ 1.) In our next construction, however, we show how to reduce vulnerability to creeping-corruption attacks considerably using cryptographic integrity checks. This improvement greatly extends the integrity lifetime T of the file F .</p><p>Remark. The three simple constructions we have shown thus far have the attractive property of being publicly verifiable. It may be that F is encrypted and that the server code is cryptographically keyed (for reasons we explain below). Thus only the client that stored F can retrieve it. But it is still possible for any entity to perform an integrity check on F . Integrity checks only involve verification of block consistency across servers, and therefore don't require any secret keys. In our next construction, we sacrifice public verifiability in favor of a much longer lifetime T of integrity assurance for F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Embedding MACs into dispersal code.</head><p>We now show how to address the problem of creeping-corruption attacks. Our solution is to authenticate matrix rows with a messageauthentication code (MAC), computed with a secret key known by the client. A simple approach is to attach a MAC to each file block on each server. We achieve a solution with lower storage overhead than this simple approach.</p><p>Our key insight (inspired by ideas of Schwartz and Miller <ref type="bibr" target="#b30">[31]</ref>) is to embed MACs in the parity blocks of the dispersal code. As we show, both MACs and parity blocks can be based on a universal hash function. Consequently, it is possible to create a block that is simultaneously both a MAC and a parity block. One of our main contributions is a construction based on this idea that we call an integrity-protected error-correcting code (IP-ECC) and whose details are given in Section 5.4. By inserting MACs into each row of the encoded matrix, we are able to effectively verify the responses received from servers. This mechanism protects against creepingcorruption attacks because it does not just check that rows are selfconsistent as in the simpler approaches described above. Instead, with MACs, it is possible to ensure that rows do not differ from their original values in F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Aggregating responses.</head><p>While the client could check individual blocks in the encoded file, a more efficient approach is to check multiple blocks of the file simultaneously. Another contribution of our paper is to provide a mechanism to aggregate MACs across multiple blocks. The client can specify multiple positions in the file, and verify their correctness via a single, composite response from each server.</p><p>We propose to use a linear code in HAIL called the aggregation code for combining servers' responses in a challenge-response protocol. The aggregate response is a linear combination of rows of the encoded file matrix, and is a codeword (or sufficiently close to a codeword) in the dispersal code. However, we need to ensure that by aggregating MAC values on individual blocks, we obtain a valid MAC. We define the notion of composite MAC in Section 5.3 that, intuitively, guarantees that a MAC on a vector of messages can not be obtained unless all the MACs of individual vector components are known. Note that the aggregation code in HAIL carries zero storage overhead: It is computed on the fly.</p><p>We describe the full HAIL system in detail in Section 6, after defining the adversarial model in Section 4. The necessary cryptographic building blocks can be found in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ADVERSARIAL MODEL</head><p>We model HAIL as a set of n servers, S1, S2, . . . , Sn, and a trusted, external entity T . We assume authenticated, private channels between T and each server. In practice T may be a client or an external auditor.</p><p>We consider an adversary A that is mobile, i.e., can corrupt a different set of servers in each epoch, and is Byzantine, i.e., can behave arbitrarily. Obviously, meaningful file availability is not possible against a fully Byzantine adversary that controls all servers. Consequently, we assume that our adversary controls at most b servers in any given epoch.</p><p>We regard each server Si as containing a distinct code base and storage system. The code base determines how the server replies to challenges; the storage system contains a (potentially corrupted) file segment.</p><p>At the beginning of each epoch, A may choose a fresh set of b servers and arbitrarily corrupt both their code bases and storage systems. At the end of an epoch, however, we assume that the code base of every server is restored to a correct state. From a theoretical perspective, this restoration models the limitation of the adversary to b servers. From a practical perspective, code-base restoration might reflect a malware-detection pass, software re-installation, invocation of a fresh virtual machine image, etc. Even when the code base of a server is restored, however, the adversary's corruptions to the server's storage system remain.</p><p>Repair of servers' storage systems only happens when a client reactively invokes the redistribute function-an expensive and generally rare event. Thus, while the adversary controls only b servers, it is possible for more than b servers to contain corrupted data in a given epoch. The aim of the client in HAIL is to detect and repair corruptions before they render a file F unavailable.</p><p>A time step or epoch in HAIL thus consists of three phases: 1. A corruption phase: The adversary A chooses a set of up to b servers to corrupt (where b is a security parameter).</p><p>2. A challenge phase: The trusted entity T challenges some or all of the servers.</p><p>3. A remediation phase: If T detects any corruptions in the challenge phase, it may modify / restore servers' file shares.</p><p>Let F denote the file distributed by T . We let</p><formula xml:id="formula_1">F (i) t</formula><p>denote the file share held by server Si at the beginning of epoch t, i.e., prior to the corruption phase, and let</p><formula xml:id="formula_2">F (i) t</formula><p>denote the file share held by Si after the corruption phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">HAIL: Formal preliminaries</head><p>In our formal adversarial model, we let a system HAIL consist of the following functions:</p><p>• keygen(1 λ ) → κ: Generates a key κ = (sk, pk) of size security parameter λ. (For symmetric-key systems, pk may be null.)</p><formula xml:id="formula_3">• encode(κ, F, , n, b) → {F (i) 0 } n i=1 :</formula><p>Encodes F as a set of file segments, where</p><formula xml:id="formula_4">F (i) 0</formula><p>is the segment designated for server i. The encoding is designed to provide -out-of-n redundancy across servers and to provide resilience against an adversary that can corrupt at most b servers in any time step.</p><formula xml:id="formula_5">• decode(κ, t, { F (i) t } n i=1</formula><p>) → F : Recovers the original file F at time t from a set of file segments stored at different servers.</p><p>• challenge(κ) → {Ci} n i=1 : Generates a challenge value Ci for each server i.</p><formula xml:id="formula_6">• respond(i, Ci, F (i) t ) → Ri: Generates server's Si response at time t to challenge Ci. • verify(κ, j, {Ci, Ri} n i=1 ) → {0, 1}.</formula><p>Checks the response of server j, using the responses of all servers R1, . . . , Rn to challenge set C1, . . . , Cn. It outputs a '1' bit if verification succeeds, and '0' otherwise. We assume for simplicity that verify is sound, i.e., returns 1 for any correct response.</p><formula xml:id="formula_7">• redistribute(κ, t, { F (i) t } n i=1 ) → {F (i)</formula><p>t+1 } n i=1 ∪ ⊥: Is an interactive protocol that replaces the fragment F (i) t stored at server i with F (i) t+1 . It implements a recreation and distribution of corrupted file segments, and outputs ⊥ if the file can not be reconstructed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Security model: Formalization</head><p>The adversary A is assumed to be stateful and have access to oracles encode and verify; we assume that A respects the bound b on the number of permitted corruptions in a given epoch. Denote by π the system parameters ( , n, b, T, q , nq).</p><p>A participates in the two-phase experiment in Figure <ref type="figure" target="#fig_1">2</ref>. In the test phase, A outputs a file F , which is encoded and distributed to servers. The second phase is a challenge phase that runs for T epochs. In each epoch, A is allowed to corrupt the code base and storage system of at most b out of n servers. Each server is challenged nq times in each epoch, and A responds to the challenges sent to the corrupted servers. If more than a fraction q of a server's responses are incorrect, the redistribute algorithm is invoked.</p><p>After the experiment runs for T time intervals, a decoding of the file is attempted and the experiment outputs 1 if the file can not be correctly recovered. We define the HAIL-advantage of A as:</p><formula xml:id="formula_8">Adv HAIL A (π) = Pr[Exp HAIL A (π) = 1]. Remark.</formula><p>In the POR security definition, by analogy with zeroknowledge proofs, the same interface used for challenge-response interactions between the client and server is also available for file extraction. In the POR model, the (single) server is permanently controlled by the adversary. In contrast, in HAIL only at most b out of the n servers can be corrupted in one time epoch. We could  construct a stronger security model for HAIL in which the file could be extracted through the challenge-response protocol if decoding fails. However, the stronger model would only benefit in extracting of file fragments for those b servers corrupted by an adversary in an epoch (the other nb servers have a correct code base). We do not investigate this model further in the paper.</p><formula xml:id="formula_9">(i) t+1 } n i=1 ← { F (i) t } n i=1 /* shares remain the same */ else {F (i) t+1 } n i=1 ← redistribute(κ, t, { F (i) t } n i=1 ) if decode(κ, T, { F (i) T } n i=1 ) = F output 0 /* F can be recovered */ else output 1 /* F is corrupted */</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">BUILDING BLOCKS</head><p>We introduce the main building blocks of HAIL. Proofs for all claims can be found in the full version of the paper <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">UHFs and Reed-Solomon codes</head><p>Let I denote a field with operations (+, ×). For example, in our prototype implementation, we work with GF [2 128 ].</p><p>A UHF <ref type="bibr" target="#b8">[9]</ref> is an algebraic function h : K × I → I that compresses a message m ∈ I into a compact digest based on a key κ ∈ K such that the hash of two different messages is different with overwhelming probability over keys. A related notion is that of almost exclusive-or universal (AXU) hash functions. Formally: DEFINITION 1. h is an -universal hash function family if for any x = y ∈ I :</p><formula xml:id="formula_10">P rκ←K[hκ(x) = hκ(y)] ≤ .</formula><p>h is an -AXU family if for any x = y ∈ I , and for any z ∈ I:</p><formula xml:id="formula_11">P rκ←K[hκ(x) ⊕ hκ(y) = z] ≤ .</formula><p>Many common UHFs are also linear, meaning that for any message pair (m1, m2), it is the case that hκ(m1)+hκ(m2) = hκ(m1+ m2). In fact, it is possible to construct a UHF based on a linear error-correcting code (ECC). An (n, , d) ECC encodes messages of length into codewords of size n such that the minimum distance between any two codewords is d. An (n, , d) code can correct up to d -1 errors and d-1 2 erasures. For example, a UHF may be based on a (n, , n -+ 1)-Reed-Solomon code over I. Let m = (m1, m2, . . . , m ), where mi ∈ I. m may be viewed in terms of a polynomial representation of the form p m (x) = m x -1 +m -1 x -2 +. . .+m1. A Reed-Solomon code, then, may be defined in terms of a vector a = (a1, . . . , an). The codeword of a message m is the evaluation of polynomial p m at points (a1, . . . , an): (p m (a1), p m (a2), . . . , p m (an)).</p><p>A UHF of interest, then, is simply hκ(m) = p m (κ) with key space K = I. It is well known that this construction, denoted RS-UHF (and typically referred as the polynomial evaluation UHF), is indeed a good UHF <ref type="bibr" target="#b33">[34]</ref>: FACT 1. RS-UHF is a -1 2 α -universal hash family (and, as such, a -1 2 α -AXU family).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">MACs obtained from UHFs</head><p>A UHF, however, is not a cryptographically secure primitive. That is, it is not generally collision-resistant against an adversary that can choose messages after selection of κ. Thus a UHF is not in general a message-authentication code (MAC). A MAC is formally defined as: DEFINITION 2. A Message Authentication Code MA = (MGen, MTag, MVer) is given by algorithms: κ ← MGen(1 λ ) generates a secret key given a security parameter; τ ← MTag κ (m) computes a tag on message m with key κ; MVerκ(m, τ ) outputs 1 if τ is a valid tag on m, and 0 otherwise. For adversary A, we define:</p><formula xml:id="formula_12">Adv uf-mac MA (A) = Pr[κ ← MGen(1 λ ); (m, τ ) ← A MTag κ (•),MVerκ(•,•) : MVerκ(m, τ ) = 1 ∧ m not tagged before].</formula><p>We denote by Adv uf-mac MA (q1, q2, t) the maximum advantage of all adversaries making q1 queries to MTag, q2 queries to MVer and running in time at most t.</p><p>It is well known that a MAC may be constructed as the straightforward composition of a UHF with a pseudorandom function (PRF) <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b33">34]</ref>. A PRF is a keyed family of functions g : K PRF × D → R that is, intuitively, indistinguishable from a random family of functions from D to R.</p><p>We define the prf-advantage of an adversary A for family g as</p><formula xml:id="formula_13">Adv prf g (A) = | Pr[κ ← K PRF : A gκ(•) = 1] -Pr[f ← F D→R : A f (•) = 1]|,</formula><p>where F D→R is the set of all functions from D to R. We denote by Adv prf g (q, t) the maximum prf-advantage of an adversary making q queries to its oracle and running in time t.</p><p>Given a UHF family h : K UHF × I → I and a PRF family g : K PRF × L → I, we construct the MAC UMAC = (UGen, UTag, UVer) such as: UGen(1 λ ) generates key (κ, κ ) uniformly at random from K UHF × K PRF ; UTag :</p><formula xml:id="formula_14">K UHF × K PRF × I → L × I is defined as UTag κ,κ (m) = (r, hκ(m) + g κ (r)); UVer : K UHF × K PRF × I × L × I is defined as UVer κ,κ (m, (c1, c2)) = 1 if and only if hκ(m) + g κ (c1) = c2.</formula><p>The tagging algorithm of UMAC outputs, in addition to the composition of UHF and PRF, a unique counter r ∈ L incremented at each invocation. Thus, the UMAC is stateful and its properties are as follows <ref type="bibr" target="#b33">[34]</ref>.</p><p>FACT 2. Assume that h is an UHF -AXU family of hash functions and g is a PRF family. Then UMAC is a stateful MAC with advantage: Adv uf-mac UMAC (q1, q2, t) ≤ Adv prf g (q1 + q2, t) + UHF q2.</p><p>Remark. For the composition of a UHF and PRF to be a MAC, it is important that the nonces used as input into the PRF be unique. In our HAIL implementation, when computing the MAC for a file block, we use as input to the PRF a hash of the file name and the block offset in the file instead of a counter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Aggregating MACs</head><p>In our HAIL protocol, we aggregate MACs on a set of file blocks for bandwidth efficiency. We define here generic composite MAC algorithms that apply to any MAC outputing tags in a field.</p><p>Let MTag : K × J → N be the tagging algorithm of a MAC MA = (MGen, MTag, MVer) defined on messages from field J that outputs tags in a field N . Let M = (m1, . . . , mv) ∈ J v be a vector of messages and let A = (α1, . . . , αv) ∈ J v be a vector of scalar values with αi = 0. We define τ = v i=1 αiMTag κ (mi) as the composite MAC of M for coefficients α1, . . . , αv. If τ is as above, we define the composite MAC verification algorithm CMVerκ({mi, αi} v i=1 , τ ) to output 1. Consider an adversary that has access to MTag and CMVer oracles. Intuitively, a composite MAC has the property that the adversary can generate a vector of messages and a composite MAC with small probability if it does not query the MTag oracle for all component messages of the vector.</p><p>We give a formal definition of composite MACs below, the first in the literature to the best of our knowledge. DEFINITION 3. Let MA = (MGen, MTag, MVer) be a MAC algorithm and CMVer the composite MAC verification algorithm defined above. For adversary A, we define:</p><formula xml:id="formula_15">Adv c-mac MA (A) = Pr[κ ← MGen(1 λ ); ({mi, αi} v i=1 , τ ) ← A MTag κ (•),CMVerκ(•,•) : CMVerκ({mi, αi} v i=1 , τ ) = 1 ∧ ∃i ∈ [1, v] for which mi was not queried to MTag κ (•)].</formula><p>We denote by Adv c-mac MA (q1, q2, t) the maximum success probability of all adversaries making q1 queries to MTag, q2 queries to CMVer and running in time t.</p><p>LEMMA 1. Given a MAC MA on field J, MA extended to J v as above is a composite MAC with advantage:</p><formula xml:id="formula_16">Adv c-mac MA (q1, q2, t) ≤ vAdv uf-mac MA (q1 + vq2 + v -1, 0, (v + 1)t).</formula><p>We define a linear composite MAC to be such that a composite MAC can be verified from a linear combination of messages: m = v i=1 αimi (without access to individual messages {mi} v i=1 ). DEFINITION 4. A composite MAC algorithm is linear if there exists an algorithm CMVer-Lin such that CMVerκ({mi, αi} v i=1 , τ ) = 1 if and only if CMVer-Linκ( v i=1 αimi, τ ) = 1.</p><p>LEMMA 2. If the nonces input to the PRF in the UMAC construction are known, the composite MAC defined from UMAC is linear.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">An integrity-protected error-correcting code (IP-ECC)</head><p>Typically, a MAC is appended to a message. Our goal in this section is to define a cryptographic primitive that acts both as a MAC and an error-correcting (or erasure) code. Moreover, we leverage the redundancy added by the error-correcting code for constructing the MAC. Such a primitive allows efficient checking of server response in our HAIL protocol. DEFINITION 5. For n ≥ , we define an (n, , d)-integrityprotected error-correcting code (denoted IP-ECC) as a tuple of algorithms IC = (KGenECC, MTagECC, MVerECC) such that:</p><p>-KGenECC(1 λ ) selects a random key κ from key space K; -MTagECC : K×I → I n on input key κ and message m ∈ I outputs an integrity-protected codeword c ∈ I n that acts as an encoding of m, and contains an integrity tag for m. The minimum (Hamming) distance between two codewords is d.</p><p>-MVerECC : K × I n → ({I ∪ ⊥}, {0, 1}) on input a key κ and an integrity-protected codeword c ∈ I n outputs a message m ∈ I (or ⊥ upon decoding failure), as well as a one-bit with value 1 if c contains a valid integrity tag on m, and 0 otherwise.</p><p>For an adversary A, we define:</p><formula xml:id="formula_17">Adv uf-ecc IC (A) = Pr[κ ← KGenECC(1 λ ); c ← A MTagECC κ (•),MVerECCκ(•) : MVerECCκ(c) = (m, 1) ∧ m not queried to MTagECC κ (•)].</formula><p>We denote by Adv uf-ecc IC (q1, q2, t) the maximum advantage of all adversaries making q1 queries to MTagECC, q2 queries to MVerECC and running in time at most t.</p><p>Similarly, integrity-protected erasure codes can be defined. We give now a construction of an IP-ECC code ECC d based on a (n, , n -+ 1) Reed-Solomon (R-S) code. Intuitively, to tag a message, we encode it under the R-S code, and then apply a PRF to the last s code symbols (for 1 ≤ s ≤ n a parameter in the system), effectively obtaining a MAC on each of those s code symbols using the UMAC construction. A codeword is considered valid if at least one of its last s symbols are valid MACs under UMAC on its decoding m. More specifically, the IP-ECC (n, , d = n -+ 1) code construction ECC d is defined as:</p><p>-</p><formula xml:id="formula_18">KGenECC(1 λ ) selects keys κ = {{κi} n i=1 , {κ i } n i=n-s+1 } at random from space K = I n × (K PRF ) s .</formula><p>The security parameter λ specifies the size of I, as well as the length of the keys in K PRF . The keys {κi} n i=1 define a Reed-Solomon code as described in Section 5.1 (they define the points at which polynomials are evaluated when constructing a codeword). The keys {κ i } n i=n-s+1 are used as PRF keys in the UMAC construction.</p><p>-MTagECC κ (m1, . . . , m ) outputs (c1, . . . , cn),</p><formula xml:id="formula_19">where ci = RS-UHFκ i ( m), i = [1, n-s] and ci = UTag κ i ,κ i (m1, . . . , m ) = (ri, RS-UHFκ i ( m) + g κ i (ri)), i = [n -s + 1, n].</formula><p>-MVerECCκ(c1, . . . , cn) first strips off the PRF from cn-s+1, . . . , cn as:</p><formula xml:id="formula_20">c i = ci -g κ i (ri), i = [n -s + 1, n],</formula><p>and then decodes (c1, . . . , cn-s, c n-s+1 , . . . , c n ) using the decoding algorithm of Reed-Solomon codes to obtain message m = (m1, . . . , m ). If the decoding algorithm of the R-S code defined by points {κi} n i=1 fails (when the number of corruptions in a codeword is beyond d-1 <ref type="formula">2</ref>), then MVerECC outputs (⊥, 0). If one of the last s symbols of (c1, . . . , cn) is a valid MAC on m under UMAC, MVerECC outputs ( m, 1); otherwise it outputs ( m, 0).</p><p>Error resilience of ECC d . The MVerECC algorithm in ECC d needs at least one correct MAC block in order to verify the integrity of the decoded message. This implies that, even if the minimum distance of the underlying code is d = n -+ 1, the construction is resilient to at most E -1 erasures, and E-1 2 errors, for E = min(d, s). LEMMA 3. If RS-UHF is constructed from a (n, , n -+ 1)-Reed-Solomon code and g is a PRF family, then the IP-ECC code ECC d defined above has the following advantage:</p><formula xml:id="formula_21">Adv uf-ecc ECC d (q1, q2, t) ≤ 2 Adv uf-mac UMAC (q1, q2, t) .</formula><p>Aggregating MACs for IP-ECC codes. The techniques we developed in Section 5.3 for aggregating MACs, i.e., for composite MAC verification, apply in a natural way to IP-ECC codes. Consider the linear combination of IP-ECC codewords c1, . . . , cv as a composite codeword c = v i=1 αi ci. Implicit in c are composite MACs, i.e., linear combinations of MACs from the individual, contributing codewords. So we can apply MVerECC directly to c, thereby verifying the correctness of c1, . . . , cv.</p><p>Systematic IP-ECC codes. In a systematic code, codewords are formed by appending parity blocks to messages. The Reed-Solomon codes obtained through polynomial evaluation are, in general, not systematic. However, it is possible to offer a different view of R-S encoding that is, in fact, systematic. The codebook for an R-S code specified by a = (a1, . . . , an) consists of all polynomials of degree -1 evaluated on {ai} n i=1 : CRS = {(f (a1), . . . , f(an))| deg(f ) ≤ -1}. A systematic code is one in which a message is mapped to a codeword whose first symbols match the message (given a message m = (m1, . . . , m ), a unique polynomial f of degree -1 for which f (ai) = mi, i = [1, ] can be determined).</p><p>The IP-ECC construction can be adapted for systematic Reed-Solomon codes as follows: we encode a message under a systematic code, and then apply the PRF only to the parity blocks. Our results in Lemma 3 still hold for this systematic encoding for s = n -. We employ this systematic code that can recover from n --1 erasures and n--1 2 errors in our HAIL protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Adversarial codes</head><p>Adversarial codes <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23]</ref> are keyed codes resistant to a large fraction of adversarial corruptions (within classical error-correcting bounds) against a computationally bounded adversary. BJO <ref type="bibr" target="#b5">[6]</ref> define adversarial codes formally and give the first practical systematic construction based on cryptographically protected, striped Reed-Solomon codes. We omit the formal definition of adversarial codes, but intuitively, an adversary has advantage γ for a secret-key adversarial code if she is able to output a pair of codewords at small Hamming distance that decode to different messages. We refer the reader to <ref type="bibr" target="#b5">[6]</ref> for full details of definition. A related notion is that of computational codes, codes that achieve higher error resilience than classical error-correcting codes by exploiting computationally bounded channels <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>In the BJO construction, the file is permuted first with a secret key and then divided into stripes. Parity blocks are computed for each stripe and appended to the unmodified file. To hide stripe boundaries, parity blocks are encrypted and permuted with another secret key. The encoding of the file consists of the original file followed by the permuted and encrypted parity blocks, and is systematic. The same construction (without rigorous formalization, though) has been proposed independently by Curtmola et al. <ref type="bibr" target="#b9">[10]</ref>. We employ this construction for the server code in HAIL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">HAIL: PROTOCOL SPECIFICATION</head><p>Using the technical building blocks defined in Section 5, in this section we give full details on the HAIL protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Key Generation</head><p>Let be the number of primary servers, and n the total number of servers. The client generates the following sets of keys:</p><p>-Dispersal-code keys: These are npairs of keys {κj , κ j } n j= +1 , for the UHF and PRF in the UMAC construction given in Section 5.2, respectively; -Server-code keys: These are n keys (one per server) for the server code described in Section 5.5; and -Challenge keys: These are keys used to generate challenges and to seed inputs to the aggregation code for responses. They can be generated from a master key that the client stores locally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Encoding Files</head><p>The encoding of files in HAIL has been depicted in Figure <ref type="figure" target="#fig_0">1</ref>. We aim at obtaining a distributed, systematic encoding F d of a file F . First, we partition F into distinct segments F (1) , . . . , F ( ) and distribute these segments across the primary servers S1, . . . , S respectively. Each segment can be viewed as a set of blocks (or symbols) with values in a field I (in our implementation we use I = GF [2 128 ]). This distributed cleartext representation of the file remains untouched by our subsequent encoding steps.</p><p>We then encode each segment F (j) under the server code (implemented with the adversarial erasure code construction of BJO <ref type="bibr" target="#b5">[6]</ref> described in Section 5.5) to protect against small corruption at each server. The effect of the server code is to extend the "columns" of F d by adding parity blocks. Next, we apply the dispersal code ECC d (as defined in Section 5.4) to create the parity blocks that reside on the secondary servers S +1 , . . . , Sn. It extends the "rows" of F d across the full set of n servers. To embed the dispersal code in a full-blown IP-ECC, we also add PRF values on the parity blocks for each row. Viewed another way, we "encrypt" columns + 1 through n, thereby turning them into cryptographic MAC values.</p><p>Finally, to allow the client to confirm when it has successfully downloaded F , we compute and store on the server a MAC over F .</p><p>The steps of encode are detailed below:</p><p>1. [File partitioning] Partition the file into segments and store segment F (j) on Sj, for j = [1, ]. Denote by mF = |F |/ the number of blocks in each segment. We have obtained a (mF , ) <ref type="bibr">[1, ]</ref> containing the original file blocks.</p><formula xml:id="formula_22">matrix {Fij } i=[1,m F ],j=</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">[Server code application]</head><p>Encode each file segment F (j) under the systematic server code with symbols in I (viewed as an erasure code), and obtain a segment of m blocks at each server (where blocks mF + 1, . . . , m are parity blocks for the server code).</p><p>3. [Dispersal code application] Apply the systematic dispersal code ECC d as defined in Section 5.4 to the rows of the encoded matrix from step 2. We determine thus segments F ( +1) , . . . , F (n) .</p><p>If we denote by <ref type="bibr">[1,n]</ref> the encoded representation of F at the end of this step, then</p><formula xml:id="formula_23">F d = {F d ij } i=[1,m],j=</formula><formula xml:id="formula_24">F d ij = Fij ∈ I (i.e., block i in F (j) ), for i = [1, mF ], j = [1, ]. F d ij for i = [mF + 1, m], j = [1,</formula><p>] are the parity blocks under the server code. The columns + 1, . . . , n are obtained through the application of the ECC d construction to columns 1, . . . , as follows:</p><formula xml:id="formula_25">F d ij = RS-UHFκ j (Fi1 . . . F i ) + g κ j (τij ), for i = [1, m], j = [ + 1, n]</formula><p>. τij is a position index that depends on the file handle, block index i and server index j, e.g., hash of the file name, i and j. RS-UHF is the universal hash function construction based on Reed-Solomon codes given in Section 5.1.</p><p>4. [Whole-file MAC computation] Lastly, a cryptographic MAC of the file (and its handle) is computed and stored with the file.</p><p>The initial share at time 0 for each server Sj is F</p><formula xml:id="formula_26">(j) 0 = {F d ij } m i=1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Decoding Files</head><p>For decoding the encoded matrix, there are two cases to consider:</p><p>-If the dispersal code is an error-correcting code, then up to n--1 2</p><p>errors can be corrected in each row. This choice imposes the requirement that b ≤ n--1 2 . (Otherwise, the adversary could corrupt all rows in an epoch, obliterating F ).</p><p>In this case, decoding of the matrix proceeds first on rows, and then on columns. In the first step, each row of the matrix is decoded and the corresponding message is checked for integrity using the MACs embedded in the parity blocks. If a row can not be correctly decoded (i.e., the number of corruptions exceeds the error correction capability of the dispersal code) or if none of the MACs in the parity blocks of a row verifies, then we mark all blocks in that row as erasures. In the second step, the server code implemented with an erasure code is used to recover the row erasures from the first step.</p><p>-If the dispersal code is an erasure code, the protocol tolerates up to b ≤ n --1 failures per epoch. In this case, we could employ an error-correcting server code. Decoding proceeds first on columns, to recover from small corruptions within each server. Then, the rows of the matrix are corrected with the dispersal erasure code.</p><p>A mechanism for determining the positions of errors in a row is needed. We can find erroneous blocks using the embedded MACs on the parity blocks, as long as at least one of the MACs in the parity blocks is valid. This approach requires brute force: We consider in turn each MAC block to be valid, try all sets of blocks in the codeword (among the n -1 remaining blocks), until we find a decoding for which the MAC block is valid. The brute force approach can recover from n --1 erasures.</p><p>Using an erasure code instead of an error-correcting code for ECC d requires fewer secondary servers. The required brute-force decoding, though, is asymptotically inefficient, since (n -) n-1 combinations of blocks have to be examined. In the rest of the paper, we assume that the dispersal code is an error-correcting code. Nonetheless, we can construct protocols for erasure dispersal codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">The Challenge-Response Protocol</head><p>In the HAIL challenge-response protocol, the client verifies the correctness of a random subset of rows D = i1, . . . , iv in the encoded matrix. The client's challenge consists of a seed κc from which each server derives set D, as well as a value u ∈ I.</p><p>Each server Sj returns a linear combination of the blocks in the row positions of D, denoted by Rj . To aggregate server responses, we use an aggregation code ECCa with message size v, implemented also with a Reed-Solomon code. Rj is computed as the u th symbol in ECCa across the selected rows. The responses of all servers (R1, . . . , Rn) then represent a linear combination of rows i1, . . . , iv with coefficients αi = u i-1 , i = <ref type="bibr">[1, v]</ref>.</p><p>Intuitively here, because all servers operate over the same subset of rows D, the sequence R = (R1, . . . , Rn) is itself a codeword in the dispersal code-with aggregate PRF pads "layered" onto the responses R +1 , . . . , Rn of the parity servers. Thanks to our IP-ECC dispersal code and our techniques of aggregating several MACs into a composite MAC (described in Section 5.3), the client can check the validity of the combined response R, by decoding to a message m and checking that at least one of the (composite) responses Rj of the secondary servers is a valid (composite) MAC on m. Having done so, the client can then check the validity of each individual response Rj : Rj is a valid response for a primary server if it matches the j-th symbol in m; for a secondary server, Rj is a valid response if it is a valid MAC on m.</p><p>The challenge-response protocol is described below:</p><p>1. The client sends a challenge κc to all servers. 2. Upon receiving challenge κc, server Sj derives set D = {i1, . . . , iv}, as well as a value u ∈ I. The response of server Sj is Rj = RS-UHFu(F d i 1 j , . . . , F d iv j ). 3. The client calls the linear composite MVerECC algorithm of the dispersal code (as described in Section 5.4) on (R1, . . . , Rn). If the algorithm outputs ( m, 0) or (⊥, 0), then verification of the response fails and verify(κ, j, {κc, Ri} n i=1 ) returns 0 for all j. 4. Otherwise, let ( m, 1) be the output of the composite MVerECC algorithm. Algorithm verify(κ, j, {κc, Ri} n i=1 ) returns 1 if: -mj = Rj , for j ∈ [1, ]; or -Rj is a valid composite MAC on m under UMAC with keys (κj , κ j ) and coefficients {αi} v i=1 , for j ∈ [ + 1, n]. As an optimization, the client can first check that the responses (R1, . . . , Rn) are valid without involving the algorithm MVerECC of the dispersal code. To do so, the client computes the valid codeword of the first positions (R1, . . . , R ) from the vector of responses. If at least one parity block in this codeword matches the received response, the client has found the correct message without involving the expensive decoding algorithm of Reed-Solomon codes used in MVerECC. In this case, the client could skip step 3, and proceed directly to step 4 in the above algorithm.</p><p>As in Section 6.3, a brute force approach to the decoding step in MVerECC could be applied if the dispersal code is an erasure code, instead of an error-correcting code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Redistribution of Shares</head><p>HAIL runs for a number of epochs T . In each epoch the client issues nq challenges to all servers and verifies their responses. The client monitors all servers in each epoch, and if the fraction of corrupted challenges in at least one server exceeds a threshold q , the redistribute algorithm is called.</p><p>In the redistribute algorithm, the client downloads the file shares of all servers, and applies the decoding algorithm described above. Once the client decodes the original file, she can reconstruct the shares of the corrupted servers as in the original encoding algorithm. The new shares are redistributed to the corrupted servers at the beginning of the next time interval t+1 (after the corruption has been removed through a reboot or alternative mechanism). Shares for the servers that have correct shares remain unchanged for time t +1. We leave the design of more efficient redistribute algorithms for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">SECURITY ANALYSIS</head><p>We define the HAIL system to be available if the experiment from Figure <ref type="figure" target="#fig_1">2</ref> outputs 0; otherwise we say that the HAIL system is unavailable. HAIL becomes unavailable if the file can not be recovered either when a redistribute is called or at the end of the experiment. In this section, we give bounds for HAIL availability and show how to choose parameters in HAIL for given availability targets. Full proofs are deferred to the full version of the paper <ref type="bibr" target="#b4">[5]</ref>.</p><p>There are several factors that contribute to HAIL availability. First is the redundancy embedded in each server through the server code; it enables recovery from a c fraction of corruption at each server. Second is the frequency with which the client challenges each server in an epoch; this determines the probability of detecting a corruption level greater than c at each server. Third, the redundancy embedded in the dispersal code enables file recovery even if a certain threshold of servers are corrupted.</p><p>Challenge frequency. In HAIL, nq challenges are issued by the client in an epoch. A redistribute operation is triggered if at least one of the servers replies incorrectly to more than a q -fraction of challenges. Recall that at least nb servers have a correct code base in a time interval, but might have corruptions in their storage system. We refer to these corruptions as residual-they were "left behind" by A. We are interested in detecting servers whose residual corruptions exceed the correction level c tolerated by the server code.</p><p>Given a c fraction of residual corrupted blocks from a server's fragment, we can compute a lower bound on the fraction of challenges that contain at least one incorrect block q,c = 1-</p><formula xml:id="formula_27">( (1-c )m v ) ( m v )<label>(</label></formula><p>for m the size of file segments and v the number of blocks aggregated in a challenge). Based on q,c, we can determine a threshold q (chosen at q,c 2 ) at which the client considers the server fragment corrupted and calls the redistribute algorithm. We estimate the probability pn that we fail to detect corruption of at least a c- fraction of blocks. PROPOSITION 1. Let μ be the uf-ecc advantage of an adversary for the (composite) dispersal code ECC d (as given by Lemmas 1 and 3 in Section 5. <ref type="bibr">3 and 5.4, respectively)</ref>. For q = q,c 2 , the probability with which the client does not detect a corruption of c fraction of blocks at a server with a correct code base is</p><formula xml:id="formula_28">pn ≤ e - nq ( q,c -2μ) 2 8( q,c -μ)</formula><p>. Based on the above proposition, we can choose the frequency of challenge-response interactions in an epoch based on the desired probability of detection (1pn), the redundancy embedded in the server code and the number of aggregated blocks in a challenge. The left graph in Figure <ref type="figure" target="#fig_2">3</ref> shows that the number of challenges nq increases when the server code shrinks, and also when the detection probability increases (this graph assumes that 20 blocks are aggregated in a challenge). The right graph in Figure <ref type="figure" target="#fig_2">3</ref> shows that the client needs to issue less challenges in an epoch if more blocks are aggregated in a challenge (this graph is done for a server code with redundancy 5%).</p><p>Role of dispersal code.</p><p>The adversary controls up to b ≤ n--1 2</p><p>out of the n servers in epoch t and corrupted up to b servers in epoch t -1. Therefore, we can only guarantee that at least n -2b servers successfully completed at least one challengeresponse round with the client in epoch t -1 with a correct code base, and still have a correct code base.</p><p>For those n -2b servers, there are still two cases in which a server's fragment is too heavily corrupted to be recovered with the server code: (1) The corruption level is below c, but the server code can not correct c-a low probability side-effect of using an "adversarial code" or (2) The corruption level is ≥ c, but the HAIL challenge-response protocol didn't successfully detect the corruption. We can bound the probability of Case (1) by the adversarial code advantage γ. The probability of Case (2) is bounded above by pn, as computed in Proposition 1.</p><p>These two bounds apply to a single server. In order to compute the availabilty of the whole HAIL system, we must treat the system as a stochastic process. Our goal, then, is to obtain an upper bound on the probability that enough fragments become unrecoverable that F is unavailable. We do so in the following theorem. THEOREM 1. Let U be the probability that HAIL becomes unavailable in a time epoch. Then U is upper bounded by: -</p><formula xml:id="formula_29">e β (1+β) 1+β (n-2b)(γ+pn ) , for β = n-2b--1 (n-2b)(γ+pn ) -1, if b &lt; n--1 2 and γ + pn &lt; n-2b--1 n-2b . -1 -[1 -(γ + pn)] +1 , if b = n--1 2 .</formula><p>The probability that HAIL becomes unavailable over an interval of t epochs is upper bounded by tU .  <ref type="figure" target="#fig_3">4</ref>, the number of primary servers is fixed to 8 and the number of total servers varies from 15 to 24. In the right graph of Figure <ref type="figure" target="#fig_3">4</ref>, the total number of servers is constant at 20 and the number of primary servers is between 6 and 13.</p><p>Consider epochs of length one week for a 2-year time interval (about 100 epochs). A 10 -6 unavailability target for 2 years translates to 10 -8 unavailability per epoch. This availability level can be obtained, for instance, from a <ref type="bibr" target="#b16">(17,</ref><ref type="bibr" target="#b7">8)</ref> dispersal code at detection level 0.99999 or <ref type="bibr" target="#b19">(20,</ref><ref type="bibr" target="#b8">9)</ref> code at detection level 0.999. Once the detection level is determined, parameters such as server code redundancy and frequency of challenge-response protocol in an epoch can be determined from Proposition 1.</p><p>Weaker adversarial model. Our experiment in Figure <ref type="figure" target="#fig_1">2</ref> defines a very strong adversarial model: As A is fully Byzantine, it can corrupt both the code base and the storage systems of servers. As servers and storage can be separate systems, it is interesting to consider a model in which the adversary only corrupts storage systems. Such a "storage-limited" adversarial model yields better security bounds: n-b servers are needed to decode the file instead of n-2b (under the technical condition that nb ≥ + 1). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">IMPLEMENTATION</head><p>We have implemented HAIL file-encoding functionality in order to test the effect of dispersal code choice on encoding time. The code was written in C++ and experiments were run on an Intel Core 2 processor running at 2.16 GHz. All cryptographic operations utilize the RSA BSAFE C library.</p><p>The dispersal code was implemented using the Jerasure <ref type="bibr" target="#b28">[29]</ref> optimized library written in C. In order to implement the integrityprotected ECC algorithm, PRF values are added to the fragments stored on secondary servers. One subtle issue when implementing the IP-ECC construction is that the symbol size of Reed-Solomon encoding should be equal to the security parameter (e.g., 128 bits). However, Jerasure implements codes with symbol sizes up to 32  bits. In order to obtain a UHF on 128 bits, we combine four blocks of size 32 bits, construct a polynomial of degree 4 , and evaluate that polynomial four times at different random points to obtain four UHF outputs of size 32 bits.</p><p>To maximize the size of files that can be encoded efficiently using our algorithm, the file is first dispersed across the primary and secondary servers before application of the server code. Applying the server code involves a logical permutation of the file fragment using a PRP and can be done much more efficiently if each server's fragment fits into main memory. For the server code, we use a <ref type="bibr" target="#b34">(35,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b2">3)</ref> Cauchy Reed-Solomon code over GF [2 32 ] that adds 9% redundancy to data stored on each server.</p><p>Disk access is expensive and comprises 50% -60% of our encoding time, depending on the parameters. In the graphs we present, I/O time has been removed to make the other encoding functions more visible. Figure <ref type="figure">5</ref> shows the encoding cost of HAIL for a 1GB file divided into several components: Jerasure dispersal code application, Jerasure server code application, the application of a PRF to the parity blocks both in the dispersal and server encoding, the time to logically rearrange the fragment on a server before application of the server code using a PRP, the computation of a MAC over the entire file, and additional data manipulations necessary to support the encoding functions. Reflecting parameter choices from Figure <ref type="figure" target="#fig_3">4</ref>, on the left graph in Figure <ref type="figure">5</ref>, we present the encoding cost as the number of primary servers remains constant at 8 and the total number of servers varies from 15 to 21. On the right graph in Figure <ref type="figure">5</ref> we keep the total number of servers constant at 20 and vary the number of primary servers between 6 and 12.</p><p>We get an encoding throughput between 2MB and 4MB per second, not including the disk I/O time. As noticed from Figure <ref type="figure">5</ref>, time spent performing dispersal code application using Jerasure is the dominant factor in file encoding speed (at least 50% of the total encoding cost, excluding I/O). For instance, for the <ref type="bibr" target="#b19">(20,</ref><ref type="bibr" target="#b11">12)</ref> dispersal code, HAIL encoding throughput is 4MB per second, compared to 7MB per second given by the dispersal code encoding. For the <ref type="bibr" target="#b20">(21,</ref><ref type="bibr" target="#b7">8)</ref> dispersal code, Jerasure encoding is 5MB per second, while HAIL achieves an encoding throughput of 2.5MB per second.</p><p>As the number of secondary servers increases, the dispersal cost increases linearly, both in terms of time spent in Jerasure, as well as the time necessary to compute the required PRF values. The time spent to perform server encoding, including Jerasure application and PRP and PRF computation, increases linearly with the total amount of data to be encoded (the size of the dispersed file), which depends on both the number of primary and secondary servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>We have proposed HAIL, a high-availability and integrity layer that extends the basic principles of RAID into the adversarial setting of the Cloud. HAIL is a remote-file integrity checking protocol that offers efficiency, security, and modeling improvements over straightforward multi-server application of POR protocols and over previously proposed, distributed file-availability proposals. Through a careful interleaving of different types of error-correcting layers, and inspired by proactive cryptographic models, HAIL ensures file availability against a strong, mobile adversary.</p><p>There are a number of interesting HAIL variants to explore in follow-up work. The protocols we have described above for HAIL only provide assurance for static files. We are investigating in current work design of similar protocols that accommodate file updates. We believe that the HAIL techniques we have introduced in this paper help pave the way for valuable approaches to distributed file system availability.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Encoding of file F : on the left, original file represented as a matrix; on the right, encoded file with parity blocks added for both the server and dispersal codes.</figDesc><graphic coords="4,325.25,54.16,216.10,170.49" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: HAIL security experiment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Number of challenges for different server codes (left) and different number of blocks aggregated in a challenge (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4</head><label>4</label><figDesc>Figure 4 shows HAIL's availability (per epoch) for b = 3 faults tolerated in an epoch, different configurations for the dispersal code and different detection probabilities. In the left graph from Figure4, the number of primary servers is fixed to 8 and the number of total servers varies from 15 to 24. In the right graph of Figure4,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Probability that HAIL is unavailable for 8 primary servers (left) and 20 total servers (right) for b = 3 faults per epoch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Sj 's incorrect replies below q */ if Scorr = {1, 2, . . . , n} then {F</figDesc><table><row><cell cols="3">Experiment Exp HAIL A (π): κ = (sk, pk) ← keygen(1 λ )</cell></row><row><cell cols="3">F ← A("test", pk, π)</cell><cell>/* output file F */</cell></row><row><cell cols="3">{F 0 } n (i) i=1 ← encode(κ, F, , n, b) for t = 0 to T do</cell><cell>/* compute file shares */</cell></row><row><cell cols="3">At ← A("corrupt servers")</cell><cell>/* set of corrupted servers */</cell></row><row><cell cols="2">for i = 1 to n do</cell></row><row><cell cols="2">Vi ← 0</cell><cell>/* number of correct replies for Si */</cell></row><row><cell cols="2">for a = 1 to nq do</cell><cell>/* generate nq challenges */</cell></row><row><cell cols="3">C = (C1, . . . , Cn) ← challenge(κ)</cell></row><row><cell cols="3">for j = 1 to n do</cell><cell>/* challenge all servers */</cell></row><row><cell></cell><cell cols="2">if j ∈ At then</cell><cell>/* A responds for</cell></row><row><cell cols="3">Rj ← A("respond", Cj , else Rj ← respond(j, Cj, F (j) F (j) t ) t ) for j = 1 to n do if verify(κ, j, {Ci, Ri} n i=1 ) = 1 then Vj ← Vj + 1 /* Sj replied correctly */ corrupted servers */ /* verify all responses */</cell></row><row><cell cols="2">Scorr ← Φ</cell><cell>/* servers with small fraction of incorrect replies */</cell></row><row><cell cols="2">for j = 1 to n do</cell><cell>/* compute fraction of correct replies */</cell></row><row><cell>if</cell><cell cols="2">V j nq ≥ 1 -q then</cell></row><row><cell></cell><cell cols="2">Scorr ← Scorr ∪ {j}</cell><cell>/*</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 : Several code parameters and their availability per epoch for a weaker model.</head><label>1</label><figDesc>Table1illustrates several code parameters and the availability they offer for the weaker, "storage-limited" adversarial model.</figDesc><table><row><cell>b</cell><cell>n</cell><cell></cell><cell>Unavailability</cell><cell>b</cell><cell>n</cell><cell></cell><cell>Unavailability</cell></row><row><cell>1</cell><cell>3</cell><cell>1</cell><cell>2 • 10 -6</cell><cell>2</cell><cell>7</cell><cell>4</cell><cell>5 • 10 -6</cell></row><row><cell>1</cell><cell>4</cell><cell>2</cell><cell>3 • 10 -6</cell><cell>2</cell><cell>8</cell><cell>3</cell><cell>6 • 10 -9</cell></row><row><cell>1</cell><cell>5</cell><cell>3</cell><cell>4 • 10 -6</cell><cell>3</cell><cell>6</cell><cell>2</cell><cell>3 • 10 -6</cell></row><row><cell>1</cell><cell>6</cell><cell>2</cell><cell>4 • 10 -9</cell><cell>3</cell><cell>7</cell><cell>3</cell><cell>3 • 10 -6</cell></row><row><cell>2</cell><cell>5</cell><cell>2</cell><cell>3 • 10 -6</cell><cell>3</cell><cell>8</cell><cell>4</cell><cell>5 • 10 -6</cell></row><row><cell>2</cell><cell>6</cell><cell>3</cell><cell>4 • 10 -6</cell><cell>3</cell><cell>9</cell><cell>3</cell><cell>6 • 10 -9</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank James Hendricks, Burt Kaliski and Ron Rivest for carefully reading the paper and providing detailed comments and suggestions. We also thank Yevgeniy Dodis and Daniel Wichs for many insights on protocol design.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Amazon simple storage service</title>
		<author>
			<persName><surname>Amazon</surname></persName>
		</author>
		<author>
			<persName><surname>Com</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>Referenced 2009 at aws.amazon.com/s3</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Provable data possession at untrusted stores</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kissner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th ACM CCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="598" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalable and efficient provable data possession</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Di Pietro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Mancini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IACR ePrint manuscript</title>
		<imprint>
			<date type="published" when="2008">2008. 2008/114</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">UMAC: Fast and secure message authentication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krovetz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1666</biblScope>
			<biblScope unit="page" from="216" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">HAIL: A high-availability and integrity layer for cloud storage</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Bowers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><surname>Oprea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IACR ePrint manuscript</title>
		<imprint>
			<date type="published" when="2008">2008. 2008/489</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Proofs of retrievability: Theory and implementation</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Bowers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><surname>Oprea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IACR ePrint manuscript</title>
		<imprint>
			<date type="published" when="2008">2008. 2008/175</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Asynchronous verifiable secret sharing and proactive cryptosystems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Strobl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th ACM CCS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="88" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Asynchronous verifiable information dispersal</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th IEEE SRDS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Universal hash functions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Robust remote data checking</title>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th ACM StorageSS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="63" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">MR-PDP: Multiple-replica provable data possession</title>
		<author>
			<persName><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th IEEE ICDCS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Proofs of retrievability via hardness amplification</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th IACR TCC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="109" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic provable data possession</title>
		<author>
			<persName><forename type="first">C</forename><surname>Erway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kupcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th ACM CCS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SQUARE HASH: Fast message authentication via optimized universal hash functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Etzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ramzan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1666</biblScope>
			<biblScope unit="page" from="234" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Demonstrating data possession and uncheatable data transfer</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L G</forename><surname>Filho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S L M</forename><surname>Barreto</surname></persName>
		</author>
		<idno>IACR eArchive 2006/150</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Secure distributed storage and retrieval</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">243</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="363" to="389" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient byzantine-tolerant erasure-coded storage</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Wylie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">34th IEEE DSN</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="135" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Error correction against computationally bounded adversaries</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Z</forename><surname>Ding</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">MMH: Software message authentication in the Gbit/second rates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption, volume 1267 of LNCS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="172" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Verifying distributed erasure-coded data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hendricks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th ACM PODC</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="139" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Proactive public key and signature systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Herzberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jakobsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th ACM CCS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="100" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Proactive secret sharing, or: How to cope with perpetual leakage</title>
		<author>
			<persName><forename type="first">A</forename><surname>Herzberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1963</biblScope>
			<biblScope unit="page" from="339" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">PORs: Proofs of retrievability for large files</title>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kaliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th ACM CCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="584" to="597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">LFSR-based hashing and authentication</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">839</biblScope>
			<biblScope unit="page" from="129" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A cooperative Internet backup scheme</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="29" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Optimal error correction against computationally bounded noise</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The complexity of online memory checking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">46th IEEE FOCS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="573" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Software performance of universal hash functions</title>
		<author>
			<persName><forename type="first">W</forename><surname>Nevelsteen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT, volume 1233 of LNCS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="24" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A performance evaluation and examination of open-source erasure coding libraries for storage</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Plank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Schuman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">W</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th USENIX FAST</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="253" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Bucket hashing and its application to fast message authentication</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">963</biblScope>
			<biblScope unit="page" from="29" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Store, forget, and check: Using algebraic signatures to check remotely administered storage</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J E</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th IEEE ICDCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Compact proofs of retrievability</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="90" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Auditing to keep online storage services honest</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Swaminathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th USENIX HotOS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">On fast and provably secure message authentication based on universal hashing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="313" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">New hash functions and their use in authentication and set equality</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Carter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciencies</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="265" to="279" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
