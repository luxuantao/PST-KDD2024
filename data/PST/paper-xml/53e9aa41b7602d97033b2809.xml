<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Counterexample-guided predicate abstraction of hybrid systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
								<address>
									<addrLine>3330 Walnut Street</addrLine>
									<postCode>19104</postCode>
									<settlement>Philadelphia</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thao</forename><surname>Dang</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Centre Équation</orgName>
								<orgName type="institution">VERIMAG</orgName>
								<address>
									<addrLine>2, avenue de Vignate</addrLine>
									<postCode>38610</postCode>
									<settlement>Gières</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Franjo</forename><surname>Ivančić</surname></persName>
							<email>ivancic@nec-labs.com</email>
							<affiliation key="aff2">
								<orgName type="institution">NEC Laboratories America</orgName>
								<address>
									<addrLine>4 Independence Way, Suite 200</addrLine>
									<postCode>08540</postCode>
									<settlement>Princeton</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Counterexample-guided predicate abstraction of hybrid systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8A755057256EF1E89E8D962B880A2CAF</idno>
					<idno type="DOI">10.1016/j.tcs.2005.11.026</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Hybrid systems</term>
					<term>Predicate abstraction</term>
					<term>Model checking</term>
					<term>Verification</term>
					<term>Counterexample analysis</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Predicate abstraction has emerged to be a powerful technique for extracting finite-state models from infinite-state systems, and has been recently shown to enhance the effectiveness of the reachability computation techniques for hybrid systems. Given a hybrid system with linear dynamics and a set of linear predicates, the verifier performs an on-the-fly search of the finite discrete quotient whose states correspond to the truth assignments to the input predicates. The success of this approach depends on the choice of the predicates used for abstraction. In this paper, we focus on identifying these predicates automatically by analyzing spurious counterexamples generated by the search in the abstract state-space. We present the basic techniques for discovering new predicates that will rule out closely related spurious counterexamples, optimizations of these techniques, implementation of these in the verification tool, and case studies demonstrating the promise of the approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Inspired by the success of model checking in hardware verification and protocol analysis <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b25">27]</ref>, there has been increasing research on developing tools for automated verification of hybrid (mixed discrete-continuous) models of embedded controllers <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">6,</ref><ref type="bibr" target="#b6">8,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b30">32]</ref>. Model checking requires the computation of the set of reachable states of a model, and in presence of continuous dynamics, this is typically undecidable. Consequently, contemporary tools for model checking of hybrid systems, such as CHECKMATE <ref type="bibr" target="#b10">[12]</ref> and d/dt <ref type="bibr" target="#b6">[8]</ref>, approximate the set of reachable states by polyhedra. We have recently shown that effectiveness of the reachability computation for hybrid systems can be enhanced using predicate abstraction <ref type="bibr" target="#b2">[3]</ref>. Predicate abstraction is a powerful technique for extracting finite-state models from complex, potentially infinite-state, discrete systems (see, for instance, <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b31">33]</ref>), and tools such as Bandera <ref type="bibr" target="#b15">[17]</ref>, SLAM <ref type="bibr" target="#b7">[9]</ref>, and Feaver <ref type="bibr" target="#b26">[28]</ref> have used it for analysis of C or Java programs. The input to our verification tool consists of the concrete system modeled by a hybrid automaton, the safety property to be verified, and a finite set of predicates over system variables to be used for abstraction. For the sake of efficiency, we require that all invariants, guards, and discrete updates of the hybrid automaton are specified by linear expressions, the continuous dynamics is linear, possibly with bounded input, and the property as well as the abstraction predicates are linear. Non-linear systems can often be modeled in this framework by increasing the number of discrete states and hiding the non-linearity in the bounded uncertain input. An abstract state is a valid combination of truth values to the predicates, and thus, corresponds to a polyhedral set of the concrete state-space. The verifier performs an on-the-fly search of the abstract system by symbolic manipulation of polyhedra.</p><p>The core of the verifier is the computation of the transitions between abstract states that capture both discrete and continuous dynamics of the original system. Computing discrete successors is relatively straightforward, and involves computing weakest preconditions, and checking non-emptiness of intersection of polyhedral sets. For computing continuous successors of an abstract state A, we use a strategy inspired by the techniques used in CHECKMATE and d/dt. However, while tools such as d/dt are designed to compute a "good" approximation of the continuous successors of A, we are interested in checking if this set intersects with a new abstract state permitting many optimizations. Postulating the verification problem for hybrid systems as a search problem in the abstract system has many benefits compared to the traditional approach of computing approximations of reachable sets, and our experiments indicate significant improvements in time and space requirements compared to a tool such as d/dt.</p><p>The success of our scheme crucially depends on the choice of the predicates used for abstraction. In this paper, we focus on identifying such predicates automatically by analyzing spurious counterexamples generated by the search in the abstract state-space. Counterexample-guided refinement of abstractions has been used in multiple contexts before, for instance, to identify the relevant timing constraints in verification of timed automata <ref type="bibr" target="#b5">[7]</ref>, to identify the relevant Boolean predicates in verification of C programs <ref type="bibr" target="#b7">[9]</ref>, and to identify the relevant variables in symbolic model checking <ref type="bibr" target="#b12">[14]</ref>. We present the basic techniques for analyzing counterexamples, techniques for discovering new predicates that will rule out spurious counterexamples, optimizations of these techniques, implementation of these in our verifier, and case studies demonstrating the promise of the approach. Counterexample guided abstraction refinement (CEGAR) for hybrid systems is being independently explored by the hybrid systems group at CMU <ref type="bibr" target="#b11">[13]</ref>.</p><p>The abstract counterexample consists of a sequence of abstract states leading from an initial state to a state violating the property. The analysis problem is to check if the corresponding sequence can be traversed in the concrete system. We perform a forward search from the initial abstract state following the given counterexample. The analysis relies on techniques for polyhedral approximations of the reachable sets under continuous dynamics. We also implemented a local test that checks for feasibility of pairwise transitions, and this proves to be effective in many cases. If the counterexample is found to be infeasible, then we wish to identify new predicates that would rule out this sequence in the refined abstract space. This reduces to the problem of finding predicates that separate two sets of polyhedra. We present a greedy strategy for identifying such predicates. After discovering new predicates, we include these to the set of predicates used before, and rerun the search in the refined abstract state-space. We demonstrate the feasibility using three case studies. The first one involves the analysis of a thermostat model, which we also use as running example throughout this paper. The second one involves verification of a parametric version of Fischer's protocol for timing-based mutual exclusion, and the third analyzes a model of an adaptive cruise controller. In each of these cases, we show how counterexample analysis can be effective in discovering the predicates that are needed for establishing safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Predicate abstraction for linear hybrid systems</head><p>In this section, we briefly recap the definitions of predicate abstraction for linear hybrid systems and the search strategy in the abstract space as outlined in <ref type="bibr" target="#b2">[3]</ref>. The class of linear hybrid systems is formally introduced, which are hybrid systems, where the continuous dynamics are linear with uncertain, bounded input and all guards, invariants and reset actions are linear. Note that this class of hybrid systems is more general than the so-called linear hybrid automata <ref type="bibr" target="#b23">[25]</ref>. It should also be noted that the theory of abstraction and counterexample analysis developed in this paper can be applied to more general classes. The focus on linear hybrid systems here is purely due to implementation considerations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Mathematical model</head><p>We denote the set of all n-dimensional linear expressions l : R n → R with E n and the set of all n-dimensional linear predicates : R n → B, where B := {0, 1}, with L n . A linear expression is of the form l(x) := n i=1 a i x i + a n+1 , and a linear predicate is of the form (x) := n i=1 a i x i + a n+1 ∼ 0, where ∼∈ { , &gt;} and ∀i ∈ {1, . . . , n + 1} : a i ∈ R.</p><formula xml:id="formula_0">T= -T t = 1 T ≥ 5 Cool T = 2 t = 1 T ≤ 10 ∧ t ≤ 3 Heat T = -T/ 2 t = 1 t ≤ 1 Check t ≥ 0.5 → t ≥ 2 → T ≥ 9 t := 0 t := 0 t := 0 T ≤ 6 → ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ Fig. 1. A simple hybrid system model of a thermostat.</formula><p>Additionally, the set of finite sets of n-dimensional linear predicates is denoted by C n , where an element of C n represents the conjunction of its elements. We use the symbol T to denote the time domain.</p><p>Definition 1 (Linear hybrid systems). An n-dimensional linear hybrid system (LHS) is a tuple H = (X , L, X 0 , I, f, T ) with the following components:</p><p>• X ⊂ R n is a convex polyhedron representing the continuous state-space.</p><p>• L is a finite set of locations. The state-space of H is X = L × X . Each state has the form (l, x), where l ∈ L is the discrete part of the state, and x ∈ X is the continuous part.</p><formula xml:id="formula_1">• X 0 ⊆ X is the set of initial states. It is assumed that for all locations l ∈ L, the set {x ∈ X | (l, x) ∈ X 0 } is a convex polyhedron. • I : L → C n</formula><p>assigns to each location l ∈ L a finite set of linear predicates I (l) defining the invariant conditions that constrain the value of the continuous part of the state while the discrete location is l.</p><formula xml:id="formula_2">• f : L → (X × R m → R n )</formula><p>assigns to each location l ∈ L a linear continuous vector field f (l) on the continuous state x ∈ X given an input u ∈ R m . While at location l the evolution of the continuous variable is governed by the differential equation ẋ = f (l)(x, u).</p><formula xml:id="formula_3">• T ⊆ L × L × C n × (E n ) n</formula><p>is a relation capturing discrete transition jumps between two discrete locations. A transition (l, l , g, r) ∈ T consists of an initial location l, a destination location l , a set of guard constraints g and a linear reset mapping r. From a state (l, x) where all predicates in g are satisfied the linear hybrid system can jump to location l at which the continuous state x is reset to a new value r(x).</p><p>The linear hybrid system can only stay in location l as long as the continuous part of the state x satisfies the invariant I (l), i.e. ∀ ∈ I (l) : (x) = 1. The notation I l is used for the invariant set of location l, that is the set of all points x satisfying all predicates in I (l). In other words,</p><formula xml:id="formula_4">I l := {x ∈ X | ∀ ∈ I (l) : (x) = 1}.</formula><p>The continuous dynamics is restricted to hybrid systems with linear continuous dynamics and uncertain, bounded input, that is, for every location l ∈ L, the vector field f (l) is linear, i.e. f (l)(x, u) = A l x + B l u where A l is an n × n matrix, B l is an n × m matrix, and the input u is provided by an input function ∈ U where U consists of piecewise continuous functions of the form</p><formula xml:id="formula_5">: T → U such that U ⊂ R m is a bounded convex set.</formula><p>It is assumed that the function f (l) is globally Lipschitz in x and continuous in u. This assumption guarantees existence and uniqueness of the solution of the differential equation. Additionally, we use the notation G t ⊆ I l to represent the guard set of a transition t = (l, l , g, r) ∈ T which is the set of points satisfying all linear predicates of g and the invariant of the location l, that is,</p><formula xml:id="formula_6">G t := {x ∈ I l | ∀ ∈ g : (x) = 1}.</formula><p>The simple thermostat model of Fig. <ref type="figure">1</ref> is a linear hybrid system according to this definition. All the guards and invariants of the system are linear predicates, the resets are linear, and the continuous dynamics also follow the aforementioned constraints of linearity. The thermostat model consists of three locations, that is L = {Heat, Cool, Check}. It contains two continuous variables, namely a clock t ∈ R 0 and a temperature T ∈ R 0 . In this particular example the continuous state-space can be limited such that both the clock t and the temperature T are within the interval [0, 100] without loss of accuracy of the analysis. The continuous state thus is</p><formula xml:id="formula_7">(t, T ) ∈ X = [0, 100] 2 .</formula><p>A state is denoted with (Heat, <ref type="bibr" target="#b1">(2,</ref><ref type="bibr" target="#b6">8)</ref>) representing t = 2 ∧ T = 8 while in location Heat. The continuous dynamics of the clock t is ṫ = 1 in all locations. The thermostat is switched on in the Heat location, so that the temperature increases by Ṫ = 2. The invariant in the Heat location is T 10 ∧ t 3, that is, I Heat = {(t, T ) ∈ [0, 100] 2 | T 10 ∧ t 3}. The thermostat system, therefore, cannot remain in the Heat location when the temperature exceeds ten or the clock exceeds three time-units. The control can switch to the Cool location, which models that the thermostat is switched off, when the guard T 9 is enabled. The guard set G of this transition therefore is G = {(t, T ) ∈ [0, 100] 2 | t 3 ∧ 9 T 10}. This means, the switch from the Heat location to the Cool location can happen non-deterministically at any time when the temperature T is in the interval <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b8">10]</ref>. The control remains in the Cool location, until the temperature is in the interval <ref type="bibr">[5,</ref><ref type="bibr" target="#b4">6]</ref>, when it switches back to the Heat location. This transition has a reset, which resets the clock t := 0. The third location, Check, models a self-checking mode of the thermostat controller. The invariant in the Check location guarantees that the control will return to the Heat location after at most one time-unit. During this time, the temperature drops, but this happens slower than in the Cool location. It is assumed that initially the thermostat is in its Heat location with t = 0 and 5 T 10. This example is used throughout this paper for illustrative purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Transition system semantics and verification problem</head><p>The semantics of a linear hybrid system can be formalized by describing its underlying transition system. We first define the notion of transition systems and traces used throughout this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Transition systems).</head><p>A transition system is a quadruple TS = (Q, Q 0 , , ) with the following components:</p><formula xml:id="formula_8">• Q is a (possibly infinite) set of states; • Q 0 ⊆ Q is a (possibly infinite) set of initial states;</formula><p>• is a (possibly infinite) set of labels; and</p><formula xml:id="formula_9">• ⊆ Q × × Q is a (possible infinite) relation capturing transitions.</formula><p>A trace of a transition system TS = (Q, Q 0 , , ) is a sequence : N → Q, such that (0) ∈ Q 0 , and ∀k 0 ∃t ∈ : ( (k), t, (k + 1)) ∈ . The notations q t → q and q → t q are often used instead of (q, t, q ) ∈ .</p><p>The semantics of a linear hybrid system can now be formalized assuming an admissible set U of input functions : T → U . The flow of the system ẋ(t) = A l x(t) + B l (t) in location l ∈ L can then be denoted by l (x, t, ) for an input function ∈ U with initial condition l (x, 0, ) = x. The underlying transition system of a hybrid system H is T H = (X, X 0 , T ∪T , ) with X 0 := {(l, x) ∈ X 0 | x ∈ I l }. For notational convenience, a transition relation →⊆ X × X between states of the transition system is defined as the union of two relations → C , → D ⊆ X × X. The relation → C describes transitions due to continuous flows, whereas → D describes the transitions due to discrete jumps.</p><formula xml:id="formula_10">(l, x) → C (l, y) :⇔ ∃ t ∈ T , ∈ U : l (x, t, ) = y ∧ ∀t ∈ [0, t] : l (x, t , ) ∈ I l , (l, x) → D (l , y) :⇔ ∃ (l, l , g, r) ∈ T : x ∈ G t ∧ y = r(x) ∧ y ∈ I l .</formula><p>Some basic reachability notation is introduced next. The set of continuous successors of a set of states (l, P ) where l ∈ L and P ⊆ X , denoted by Post C (l, P ), and the continuous successors of a set of states S ⊆ X denoted by Post C (S) can be defined as: Post C (l, P ) := {(l, y) ∈ X | ∃x ∈ P : (l, x) → C (l, y)}; and Post C (S) := {(l, y) ∈ X | ∃(l, x) ∈ S : (l, x) → C (l, y)}. Similarly, the set of discrete successors of (l, P ) and S, denoted by Post D (l, P ) and Post D (S) respectively, can be defined as: Post D (l, P ) := {(l , y) ∈ X | ∃x ∈ P : (l, x) → D (l , y)}; and Post D (S) := {(l , y) ∈ X | ∃(l, x) ∈ S : (l, x) → D (l , y)}. For the thermostat example (see Fig. <ref type="figure">1</ref>), and a set S with S = {(Heat, (t, T )) ∈ X | 1.5 t 2.5 ∧ 8.5 T 9.5}, it can thus be computed that</p><formula xml:id="formula_11">Post D (S) = {(Cool, (t, T )) ∈ X | 1.5 t 2.5 ∧ 9 T 9.5} ∪ {(Check, (t, T )) ∈ X | t = 0 ∧ 8.5 T 9.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5} and</head><p>Post C (S) = (Heat, (t, T )) ∈ X 1.5 t 3 ∧ 8.5 T 10∧ 2(t -2.5) + 8.5 T 2(t -1.5) + 9.5 .</p><p>Safety properties of systems are usually specified by partitioning the set of all states into safe and unsafe states. A system satisfies the safety properties if an unsafe state cannot be reached. We proceed to formalize this notion for linear hybrid systems. A property can be specified by a set of unsafe locations L u ⊆ L and a convex set B ⊆ X of unsafe continuous states. The property is said to hold for the hybrid system H iff there is no valid trace from an initial state to some state in B while in an unsafe location. For the thermostat example, the set of unsafe continuous states B is defined as the set of states when the temperature drops below 4.5, that is: B = {(t, T ) ∈ [0, 100] 2 | T 4.5}. The set of unsafe locations L u is defined as L u = {Check}, as the invariant in location Cool provides that the system cannot reach B in the Cool location. The Heat location is also not included in L u , as the dynamics provide that B will not be reached while in the Heat location unless the system starts initially in B.</p><p>Definition 3 (Verification problem). Given a hybrid system H = (X , L, X 0 , I, f, T ), the set of reachable states Reach ⊆ X is defined as</p><formula xml:id="formula_12">• Reach (0) := {(l, x) ∈ X 0 | x ∈ I l }; • Reach (i+1) := Post C (Reach (i) ) ∪ Post D (Reach (i) ) ∀i 0; and • Reach := i 0 Reach (i) .</formula><p>Given a set of unsafe locations L u ⊆ L and a convex set B ⊆ X , the set of unsafe states B X can be defined as</p><formula xml:id="formula_13">B X := {(l, x) ∈ X | l ∈ L u ∧ x ∈ B}. The verification problem then is: Reach ∩ B X ? = ∅.</formula><p>In <ref type="bibr" target="#b0">[1]</ref>, it was shown that the verification problem for general hybrid systems is undecidable. In many practical situations though, model checking of hybrid systems can be used to verify certain properties of systems or to discover bugs in implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Discrete abstraction</head><p>A discrete abstraction of a linear hybrid system H = (X , L, X 0 , I, f, T ) is defined with respect to a given kdimensional vector of n-dimensional linear predicates = ( 1 , 2 , . . . , k ) ∈ (L n ) k . The continuous state-space X ⊆ R n can be partitioned into at most 2 k states, corresponding to the 2 k possible Boolean truth evaluations of predicates in ; hence, the infinite state-space X of H is reduced to |L|2 k states in the abstract system. From now on, the hybrid system H is also referred to as the concrete system and its state-space X as the concrete state-space. Definition 4 (Abstract state-space). Given an n-dimensional linear hybrid system H = (X , L, X 0 , f, I, T ) and a k-dimensional vector ∈ (L n ) k of n-dimensional linear predicates an abstract state is defined as a tuple (l, b), where l ∈ L and b ∈ B k . The abstract state-space for a k-dimensional vector of linear predicates therefore is</p><formula xml:id="formula_14">Q := L × B k .</formula><p>Fig. <ref type="figure" target="#fig_0">2</ref> illustrates the abstraction of the continuous state-space for the thermostat example of Fig. <ref type="figure">1</ref>. Ten predicates are used for the abstraction, namely: = (t 0, t 0.5, t 1, t 2, t 3, T 4.5, T 5, T 6, T 9, T 10).</p><p>(</p><formula xml:id="formula_15">)<label>1</label></formula><p>For the sake of simplicity these predicates all involve only one continuous variable, that is they correspond to hyperplanes parallel to some axis, though this is not necessary. Each box or line on the right-hand side of Fig. <ref type="figure">1</ref> corresponds to a vector b ∈ B 10 for the predicates as specified in Eq. <ref type="bibr" target="#b0">(1)</ref>. The abstract continuous state-space consists of 36 non-empty states, which means that the size of the relevant abstract state-space Q is 3 • 36 = 108.</p><p>For each vector b ∈ B k for a vector of linear predicates the set of states of the continuous state-space that it represents can be computed given the following definition. For example, the vector (0, 1, 0, 1, 1, 0, 1, 0, 0, 1) represents the set of predicates t &gt; 0, t 0.5, t &gt; 1, t 2, t 3, T &gt; 4.5, T 5, T &gt; 6, T &lt; 9, and T 10 given the vector of predicates as specified in Eq. ( <ref type="formula" target="#formula_15">1</ref>), which represents the continuous state-space </p><formula xml:id="formula_16">{(t, T ) ∈ R 2 | 2 t 3 ∧ 6 &lt; T &lt; 9}.</formula><formula xml:id="formula_17">= ( 1 , . . . , k ) ∈ (L n ) k with C : B k → 2 R n is defined as follows: C ( b) := {x ∈ R n | ∀i ∈ {1, . . . , k} : i (x) = b i }. A vector b ∈ B k is said to be consistent with respect to a vector of linear predicates ∈ (L n ) k , iff C ( b) = ∅. An abstract state (l, b) ∈ Q is said</formula><p>to be consistent with respect to a vector of linear predicates , iff b is consistent with respect to .</p><p>As mentioned before, the set of abstract states has at most size |L|2 k for k linear predicates. However, the set of consistent abstract states is actually much smaller due to the fact that many predicates are redundant, that is they may be parallel, or do not cross inside the relevant continuous state-space X . Fig. <ref type="figure" target="#fig_0">2</ref> provides such an example. The abstract state-space consists only of 108 consistent abstract states, although there are 3 • 2 10 = 3072 possible abstract states. The implementation of the verification tool is based on the fact that abstract states in the continuous state-space form a convex partition of the continuous state-space, which is formulated in the following lemma, and can be proven easily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1. Given a set of linear predicates ∈ (L n ) k and a convex polyhedron X , then for any</head><formula xml:id="formula_18">b ∈ B k C ( b) and C ( b) ∩ X represent convex polyhedra.</formula><p>The following definition formalizes the discrete transition system of a hybrid system using predicate abstraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (Discrete abstraction</head><p>). An abstract system given a linear hybrid system H = (X , L, X 0 , f, I, T ) with respect to a vector of linear predicates is defined as the transition system H = (Q, Q 0 , T , ) where</p><formula xml:id="formula_19">• the state-space of H is Q = Q ;</formula><p>• the set of initial states are those abstract states that overlap with concrete initial abstract states and the relevant invariant:</p><formula xml:id="formula_20">Q 0 = {(l, b) ∈ Q |∃x ∈ C ( b) ∩ I l : (l, x) ∈ X 0 };</formula><p>• the set of labels of the transition system T is the union of the transition function T denoting transitions due to discrete switches and the symbol C denoting transitions due to continuous flow, i.e. T = T ∪{C}; and • the transition relation ⊆ Q × T × Q between states of the transition system includes both transitions due to discrete switches and due to continuous flow. It thus can be defined using the following two cases:</p><formula xml:id="formula_21">(l, b) → C (l, b ) :⇔ ∃ t ∈ T , ∈ U, x ∈ C ( b) : l (x, t, ) ∈ C ( b ) ∧ ∀t ∈ [0, t] : l (x, t , ) ∈ I (l), (l, b) → t (l , b ) :⇔ t = (l, l , g, r) ∈ T ∧ ∃x ∈ C ( b) : x ∈ g ∧ r(x) ∈ C ( b ) ∧ r(x) ∈ I (l ).</formula><p>For notational convenience, the abstract transition relation →⊆ Q × Q is defined as the union of the follow-</p><formula xml:id="formula_22">ing two relations → D , → C ⊆ Q × Q . The relation → D represents transitions in the abstract state-space due to discrete jumps (l, b) → D (l , b ) ⇔ ∃t = (l, l , g, r) ∈ T , x ∈ C ( b) ∩ G t : r(x) ∈ C ( b ) ∩ I l .</formula><p>The successors of an abstract state (l, b) ∈ Q and a set of abstract states S ⊆ Q by discrete jumps and by continuous flows, denoted, respectively, by Post D (l, b), Post D (S), Post C (l, b), and Post C (S) can be defined as</p><formula xml:id="formula_23">Post D (l, b) := {(l , b ) ∈ Q | (l, b) → D (l , b )}, Post D (S) := {(l , b ) ∈ Q | ∃(l, b) ∈ S : (l, b) → D (l , b )}, Post C (l, b) := {(l, b ) ∈ Q | (l, b) → C (l, b )}, and Post C (S) := {(l, b ) ∈ Q | ∃(l, b) ∈ S : (l, b) → C (l, b )}.</formula><p>Consider the abstract state 1 &lt; t &lt; 2 ∧ 9 T 10 in location Heat for the thermostat model of Fig. <ref type="figure">1</ref>, which is represented by the abstract state (l, b) = (Heat, (0, 1, 0, 0, 1, 0, 1, 0, 1, 1)) given as specified in Eq. ( <ref type="formula" target="#formula_15">1</ref>). In this case, the following holds:</p><formula xml:id="formula_24">Post D (l, b) = {(Cool, b)}, and Post C (l, b) = {(l, b), (l, (0, 1, 0, 1, 1, 0, 1, 0, 1, 1))},</formula><p>where (0, 1, 0, 1, 1, 0, 1, 0, 1, 1) represents 2 t 3 ∧ 9 T 10. The verification problem in the abstract state-space can then be stated as described in the following definition: Definition 7 (Abstract verification problem). Given a linear hybrid system H = (X , L, X 0 , I, f, T ) and a vector of linear predicates , the set of reachable abstract states Reach is defined as</p><formula xml:id="formula_25">• Reach (0) := Q 0 ; • Reach (i+1) := Post D (Reach (i) ) ∪ Post C (Reach (i) )</formula><p>∀i 0; and</p><formula xml:id="formula_26">• Reach := i 0 Reach (i) .</formula><p>Given a set of unsafe locations L u ⊆ L and a convex set B ⊆ X , the set B is defined as</p><formula xml:id="formula_27">B := {(l, b) ∈ Q | l ∈ L u ∧ C ( b) ∩ B = ∅}. The verification problem is: Reach ∩ B ? = ∅.</formula><p>It can be proven that predicate abstraction of linear hybrid systems computes an over-approximation of the set of reachable states of the concrete system. This is formalized in the following lemma, which can easily be proven (see <ref type="bibr" target="#b28">[30]</ref>): Lemma 2. Given a linear hybrid system H = (X , L, X 0 , I, f, T ) and a vector of linear predicates , the following holds:</p><formula xml:id="formula_28">Reach ⊆ {(l, x) ∈ X | ∃(l, b) ∈ Reach : x ∈ C ( b) ∩ I l }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Searching the abstract state-space</head><p>We implemented an on-the-fly search of the abstract state-space. The search in the abstract state-space can be performed in a variety of ways. Our goal is to make the discovery of counterexamples in the abstract state-space given a reachability property as fast as possible. In the case that the property is true we need to search the entire reachable abstract sub-space. We perform a DFS, which usually does not find a shortest counterexample. On the other hand, it only stores the current trace of abstract states from an initial abstract state on a stack. In case we find an abstract state that violates the property, the stack content represents the counterexample. This is generally much more memory-efficient than BFS.</p><p>We give a priority to computing discrete successors rather than continuous successors, as this is generally much faster. Computing discrete successors is relatively straightforward, and involves computing weakest preconditions, and checking non-emptiness of intersection of polyhedral sets. For computing continuous successors of an abstract state A, we compute the polyhedral slices of states reachable at fixed times r, 2r, 3r, . . . for a suitably chosen r, and then, compute the convex-hull of all these polyhedra to over-approximate the set of all states reachable from A. We are only interested in checking if this set intersects with a new abstract state.</p><p>This approach has many benefits compared to the traditional approach of computing approximations of reachable sets, one of them being the fact that the expensive operation of computing continuous successors is applied only to abstract states, and not to intermediate polyhedra of unpredictable shapes and complexities. In <ref type="bibr" target="#b3">[4]</ref> we proved soundness of our search algorithm: Theorem 1. If the search algorithm terminates and reports that the abstract system is safe, then the corresponding concrete system is also safe.</p><p>We include various optimization techniques in the search strategy. In the following, we describe one optimization that is being exploited during the counterexample analysis. For each concrete counterexample in the concrete hybrid system, there exists an equivalent counterexample that has the additional constraint that there are no two consecutive transitions due to continuous flow. This is due to the additivity of flows of hybrid systems, namely</p><formula xml:id="formula_29">(l, x) → C (l, x ) ∧ (l, x ) → C (l, x ) ⇒ (l, x) → C (l, x ).</formula><p>We are hence searching only for counterexamples in the abstract system that do not have two consecutive transitions due to continuous flow. By enforcing this additional constraint we eliminate some spurious counterexamples that could have been found otherwise in the abstract transition system. The spurious counterexamples that are eliminated are due to the fact that <ref type="figure">l,</ref><ref type="figure">b</ref> ). Hence, we are in fact not computing the whole relation → C as it was defined above, but only a part of it without compromising the conservativeness of our approach. This optimization allows us to remove many spurious counterexamples from the set of reachable traces through a simple check during the reachability computation. The following theorem formalizes this optimization and proves that this approach still computes a conservative abstraction.</p><formula xml:id="formula_30">(l, b) → C (l, b ) and (l, b ) → C (l, b ) does not imply that (l, b) → C (</formula><p>Theorem 2. Given a linear hybrid system H = (X , L, X 0 , I, f, T ) and a vector of linear predicates , the set of reachable abstract states R ⊆ Q is defined as</p><formula xml:id="formula_31">• D (0) = {(l, b) ∈ Q | ∃x ∈ C ( b)∩I l : (l, x) ∈ X 0 }; • C (0) = ∅; • R (i) = D (i) ∪C (i) ∀i 0; • D (i+1) = Post D (R (i) )∪D (i) ∀i 0; • C (i+1) = (Post C (D (i) )∪C (i) ) \ D (i+1) ∀i 0; • R = i 0 R (i) .</formula><p>Then the following holds:</p><formula xml:id="formula_32">Reach ⊆ {(l, x) ∈ X | ∃(l, b) ∈ R : x ∈ C ( b)∩I l }.</formula><p>Proof. It will be shown that ∀i ∈ N</p><formula xml:id="formula_33">Reach (i) ⊆ {(l, x) ∈ X | ∃(l, b) ∈ R (i) : x ∈ C ( b)∩I l }.</formula><p>• The definition of Reach (0) and D (0) guarantee the statement for i = 0.</p><p>• Assume that the statement holds for i. Using the fact that ∀i 0 : Reach (i) ⊆ Reach (i+1) and that ∀(l, x) ∈ Reach : x ∈ I l , it only needs to be shown that</p><formula xml:id="formula_34">∀(l, x) ∈ Reach (i+1) \ Reach (i) ∃(l, b) ∈ R (i+1) : x ∈ C ( b).</formula><p>Consider two cases independently: The first case covers the scenario that the state (l, x) was produced by a state (l i , x i ) ∈ Reach (i) through a transition due to a discrete switch. The induction hypothesis guarantees that there exists a state</p><formula xml:id="formula_35">(l i , b i ) ∈ R (i) such that x i ∈ C ( b i ).</formula><p>It is clear then that there also exists a transition i+1) proving this case. On the other hand, consider the case that the state (l, x) was produced by a state (l i , x i ) ∈ Reach (i) through a transition due to continuous flow. The induction hypothesis guarantees that there exists a state</p><formula xml:id="formula_36">(l i , b i ) → D (l, b) such that x ∈ C ( b). Furthermore, this implies that (l, b) ∈ D (</formula><formula xml:id="formula_37">(l i , b i ) ∈ R (i) such that x i ∈ C ( b i ).</formula><p>It is clear then that there also exists a transition</p><formula xml:id="formula_38">(l i , b i ) → C (l, b) such that x ∈ C ( b).</formula><p>There are two cases to consider:</p><p>• The first case covers that i = 0. In this case R (0) = D (0) and thus (l i , b i ) ∈ D (i) . Then, it is clear that (l, b) ∈ Post C (D (0) ), and thus will be in R (1) .</p><p>• In case i &gt; 0, it must then be true that the state (l i , x i ) was produced by a state (l i-1 , x i-1 ) ∈ Reach (i-1) thro ugh a transition due to a discrete switch, because otherwise it would also be true that (l, x) ∈ Reach (i) . This implies that (l i , b i ) ∈ D (i) , and analogously to the previous case, we can guarantee that (l, b) ∈ R (i+1) .</p><p>As shown in <ref type="bibr" target="#b3">[4]</ref>, the ten predicates specified in Eq. ( <ref type="formula" target="#formula_15">1</ref>) can be used to prove safety of the thermostat controller. The search discovers 35 reachable abstract states. For the sake of brevity we omit the details of the reachability analysis and various other optimization techniques in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Counterexample analysis</head><p>The success of the predicate abstraction scheme as outlined in the previous section crucially depends on the choice of the predicates used for abstraction. This and the following section describe methods to identify such predicates automatically by analyzing spurious counterexamples generated by the search in the abstract state-space. Counterexampleguided refinement of abstractions has been used in multiple contexts before, for instance, to identify the relevant timing constraints in verification of timed automata <ref type="bibr" target="#b5">[7]</ref>, to identify the relevant Boolean predicates in verification of C programs <ref type="bibr" target="#b7">[9]</ref>, and to identify the relevant variables in symbolic model checking <ref type="bibr" target="#b12">[14]</ref>. In the following, the basic techniques for analyzing counterexamples and techniques for discovering new predicates that will rule out spurious counterexamples are presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Forward analysis</head><p>An abstract counterexample consists of a sequence of abstract states and transitions leading from an initial state to a state violating the property. The analysis problem, then, is to check if the corresponding sequence of locations and continuous states can be traversed in the concrete system. This analysis problem is solved by a forward search from the initial abstract state following the given counterexample in the abstract state-space. The analysis relies on techniques for polyhedral approximations of the reachable sets under continuous dynamics. We first define the notion of abstract paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (Abstract path</head><p>). An abstract path p of length n 0 in the abstract state-space given by the vector of predicates is a pair ( a, t) ∈ (Q ) n+1 × ( T ) n , such that: a = (a 0 , . . . , a n ) and t = (t 0 , . . . , t n-1 ) with t i ∈ T , a 0 = (l 0 , b 0 ) ∈ Q 0 , and ∀0 i n -1 : a i → t i a i+1 . The set of abstract paths of length n given by the vector of predicates is denoted by P n . Consider Fig. <ref type="figure" target="#fig_1">3</ref> which illustrates an abstract path of length 3 for the thermostat example of Fig. <ref type="figure">1</ref> in the abstract state-space defined by the predicates mentioned in the model. That is, the abstract state-space is partitioned according to all predicates mentioned in Eq. ( <ref type="formula" target="#formula_15">1</ref>) except t 0. The abstract path in Fig. <ref type="figure" target="#fig_1">3</ref> contains three transitions, two of which are due to continuous flow and graphically represented by a dashed edge, and one transition due to a discrete switch drawn by a solid edge.</p><p>Given a linear hybrid system H , a set of unsafe locations L u and a set of unsafe continuous states B ⊆ X , it can now be formally defined what a counterexample in the abstract state-space is. Definition 9 (Counterexample). A counterexample of length n is an abstract path p = ( a, t) = ((a 0 , . . . , a n ), (t 0 , . . . , t n-1 )) of length n, such that a n = (l n , b n ) is a violation of the property to be proven; that is,</p><formula xml:id="formula_39">l n ∈ L u ∧ C ( b n ) ∩ B = ∅.</formula><p>The sequence of abstract states a = (a 0 , . . . , a n ) of a counterexample p = ( a, t) is called an unlabeled counterexample.</p><p>Consider again the abstract path in Fig. <ref type="figure" target="#fig_1">3</ref>. As the path ends in an abstract state with a continuous state-space T 4.5, which is unsafe, while in the unsafe location Check ∈ L u , this path is therefore a counterexample in the abstract state-space defined by the predicates mentioned in the model. However, as mentioned earlier, the thermostat model Check, 0 ≤ t &lt; 0.5, 6 &lt; T &lt; 9 Check, 0.5 ≤ t ≤ 1, T ≤ 4.5 Heat, 0 ≤ t &lt; 0.5, 5 ≤ T ≤ 6 Heat, 2 ≤ t ≤ 3, 6 &lt; T &lt; 9 is safe. The compressed set of predicates considered here is not enough to prove the thermostat model safe. As the thermostat system is safe, it is clear that this counterexample has to be spurious, which will be shown subsequently.</p><p>The counterexample analysis problem is twofold. The first objective is to check whether a counterexample in the abstract state-space corresponds to a counterexample in the concrete state-space. In case that this analysis finds that this particular counterexample cannot be traversed in the concrete system, the analysis procedure should identify one or more new predicates that would rule out closely related counterexamples in the refined abstract state-space. The refined abstract state-space is defined by adding these predicates to the previous set of predicates used in the abstract state-space search. We would like some guarantee of convergence that the same counterexample is not discovered repeatedly. The notion of refinement between abstract paths is defined to formalize the concept of closely related abstract paths. First, the notion of refinement is defined for vectors of predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10 (Refinement of a vector of predicates). A vector of predicates</head><formula xml:id="formula_40">= ( 1 , . . . , k ) ∈ (L n ) k refines an- other vector of predicates = ( 1 , . . . , k ) ∈ (L n ) k , iff ∀1 i k ∃j ∈ {1, . . . , k } : i = j .</formula><p>From now on, when the thermostat model is used for illustrative purposes in this paper two vectors of predicates will be considered. The vector of predicates as defined in Eq. ( <ref type="formula" target="#formula_15">1</ref>) is denoted by , whereas ˆ denotes only those predicates that are mentioned in the model of the thermostat example in Fig. <ref type="figure">1</ref> itself. Therefore, ˆ contains all predicates in except for t 0. Thus, is a refinement of ˆ according to the above definition. Next, the notion of refinement is defined for abstract states. An abstract state is considered a refinement of another abstract state, if the two have the same locations, and the concretization of the former is covered by the latter. The abstract state t = 0 ∧ 5 T 6 in the Heat location for the vector of predicates is a refinement of 0 t &lt; 0.5 ∧ 5 T 6 in the same location for the vector of predicates ˆ . The previous two definitions of refinement are now combined to define refinements of abstract paths. It is required that each abstract state on the path is refined while following the same transitions. Formally, it is defined as follows:</p><p>Definition 12 (Refinement of abstract paths). An abstract path p = ( a , t ) = ((a 0 , . . . , a n ), (t 0 , . . . , t n-1 )) ∈ P n for a vector of predicates refines another abstract path p = ( a, t) = ((a 0 , . . . , a n ), (t 0 , . . . , t n-1 )) ∈ P n for a vector of predicates , with a i = (l i , b i ) and a i = (l i , b i ), iff refines , ∀0 i n : a i refines a i , and ∀0 i n-1 : During the counterexample analysis specialized Pre :</p><formula xml:id="formula_41">t i = t i . a 0 = (l 0 , b 0 ) a 1 = (l 1 , b 1 ) a 2 = (l 2 , b 2 ) a 3 = (l 3 , b 3 ) C D C → → → → → Π → Π → Π</formula><formula xml:id="formula_42">Q × T × Q → 2 X and Post : 2 X × T × Q → 2 X</formula><p>functions are defined that will either only consider a particular abstract state or the concretely reachable state-space rather than the whole continuous state-space X . The computation of these takes into consideration the concretization of the abstract state, as well as the invariants and guards of the system. The functions Pre :</p><formula xml:id="formula_43">Q × T × Q → 2 X and Post : 2 X × T × Q → 2 X with a = (l, b) and a = (l , b ) are defined as Pre(a, t, a ) = ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ x ∈ C ( b) ∩ G t | r(x) ∈ C ( b ) ∩ I l : t = (l, l , g, r); ⎧ ⎨ ⎩ x ∈ C ( b) ∩ I l | ∃ ∈ T , ∈ U : l (x, , ) ∈ C ( b ) ∩ I l ∧ ∀ ∈ [0, ] : l (x, , ) ∈ I l ⎫ ⎬ ⎭ : t = C. Post(X, t, a ) = ⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ Post x ∈ C ( b ) ∩ I l | ∃ y ∈ G t ∩ X : x = r(y) , C, a : t = (l, l , g, r); ⎧ ⎨ ⎩ x ∈ C ( b ) ∩ I l | ∃ ∈ T , ∃y ∈ X, ∈ U : l (y, , ) = x∧ ∀ ∈ [0, ] : l (y, , ) ∈ I l ⎫ ⎬ ⎭ : t = C.</formula><p>The counterexample analysis algorithm is presented in Algorithm 1. The set R 0 is the part of the initial state-space X 0 that is covered by the abstract state (l, b 0 ). Then, the concretely reachable state-space of each abstract state of the counterexample of length n in the abstract state-space is computed. It should be noted that this computation can often only be approximated, as will be discussed in detail in Section 5. This process is illustrated in Fig. <ref type="figure" target="#fig_3">4</ref>. For each 1 i n the analysis computes R i as the reachable region after i transitions according to the counterexample. It is hence clear that if R i = ∅ for some i then the counterexample is spurious. The shaded sub-spaces in Fig. <ref type="figure" target="#fig_3">4</ref> represent the concretely reachable regions R i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1. ANALYZING</head><formula xml:id="formula_44">A COUNTEREXAMPLE p ∈ P n R 0 = C ( b 0 ) ∩ {x ∈ I l 0 |(l 0 , x) ∈ X 0 } for 1 i n do R i = Post(R i-1 , t i-1 , a i ) if R i = ∅ then return "Counterexample is spurious!" end if end for return "Counterexample is concrete!"</formula><p>Following Algorithm 1 for the counterexample in Fig. <ref type="figure" target="#fig_1">3</ref> for the thermostat model of Fig. <ref type="figure">1</ref>, the concretely reachable sub-spaces of the abstract states following this particular counterexample are computed. The first abstract state a 0 = (l 0 , b 0 ) in the counterexample represents the continuous state-space 0 t &lt; 0.5 ∧ 5 T 6 while in location Heat. Given the constraints on the initial sets, however, only t = 0 ∧ 5 T 6 are concretely possible in a 0 . Thus, the following holds: R 0 = {(Heat, (0, T )) ∈ X | 5 T 6}. Consider now the continuous transition that leads from a 0 to a 1 , which is 2 t 3 ∧ 6 &lt; T &lt; 9 in the continuous state-space while in location Heat. It is thus evident that a 1 cannot be reached from R 0 , that is R 1 = ∅. This proves that the counterexample of Fig. <ref type="figure" target="#fig_1">3</ref> is indeed spurious.</p><p>In case that the analysis finds that the counterexample is spurious, the counterexample is then used to find new predicates. These new predicates should be added to the current set of predicates used in the predicate abstraction model checker, in order to disallow closely related counterexamples to reappear. Consider a counterexample p ∈ P n , such that R k+1 = ∅ and R k = ∅ for 0 k &lt; n. The transition t k of the counterexample p is called the failing transition. Then the following lemma can be proven: Lemma 3. Given a counterexample p = ( a, t) = ((a 0 , . . . , a n ), (t 0 , . . . , t n-1 )) ∈ P n where t k is the failing transition, the following holds: R k ∩ Pre(a k , t k , a k+1 ) = ∅.</p><p>Proof. Assume the contrary. Then it is true that: ∃x ∈ R k ∩ Pre(a k , t k , a k+1 ). Consider the two cases independently.</p><formula xml:id="formula_45">• Assume t k = (l k , l k+1 , g k , r k ), then it is true that ∃x ∈ R k ∩ C ( b k ) ∩ G t k : r k (x) ∈ C ( b k+1 ) ∩ I l k+1 ∃y ∈ C ( b k+1 ) ∩ I l k+1 ∃x ∈ R k ∩ C ( b k ) ∩ G t k : y = r k (x) As R k ⊆ C ( b k ) ∩ I l k , it holds that ∃y ∈ C ( b k+1 ) ∩ I l k+1 ∃x ∈ R k ∩ G t k : y = r k (x) ∃y ∈ Post(R k , t k , a k+1 ),</formula><p>which is a contradiction to the assumption that t k is a failing transition.</p><formula xml:id="formula_46">• Assume t k = C, then the following holds: ∃x ∈ R k ∩ C ( b k ) ∩ I l k , t ∈ R 0 , ∈ U : l k (x, t, ) ∈ C ( b k+1 ) ∩ I l k ∧ ∀t ∈ [0, t] : l k (x, t , ) ∈ I l k ; ∃y ∈ C ( b k+1 ) ∩ I l k , x ∈ R k ∩ C ( b k ) ∩ I l k , t ∈ R 0 , ∈ U : y = l k (x, t, ) ∧ ∀t ∈ [0, t] : l k (x, t , ) ∈ I l k . As R k ⊆ C ( b k ) ∩ I l k , it is true that ∃ y ∈ C ( b k+1 ) ∩ I l k , x ∈ R k , t ∈ R 0 , ∈ U : y = l k (x, t, ) ∧ ∀t ∈ [0, t] : l k (x, t , ) ∈ I l k .</formula><p>As l k = l k+1 , it follows that ∃y ∈ Post(R k , t k , a k+1 ), which is a contradiction to the assumption that t k is a failing transition.</p><p>New predicates are supposed to be added to the vector , so that the refined vector does not allow a refined (unlabeled) counterexample of p to reappear. Consider a strategy that adds predicates to the set that correspond to a separation of R k from Pre(a k , t k , a k+1 ) for the failing transition t k . This means that the analysis is looking for a refined set of predicates of , such that every refined abstract state intersects at most with one of the two sets R k and Pre(a k , t k , a k+1 ). A notion of separation is defined in terms of polyhedral sets, since the set of reachable states is approximated by polyhedral slices in the implementation of the tool. It should be noted here that under-approximations of the reachable sets of states are used during the analysis of counterexamples while over-approximations of the reachable sets of states are used during the search in the abstract state-space.</p><p>Definition 13 (Separating predicates). Assume that P = {P 1 , . . . , P n } and Q = {Q 1 , . . . , Q m } denote two disjoint sets of convex polyhedra. The union of all polyhedra in P and Q are, respectively, denoted by P and Q. A finite vector of linear predicates = ( 1 , 2 , . . . , k ) separates P and Q iff for all b ∈ B k , at least one of the two sets</p><formula xml:id="formula_47">(C ( b) ∩ X ∩ P) and (C ( b) ∩ X ∩ Q) is empty.</formula><p>The predicates in are called separating predicates. Note that such a vector always exists, 1 but it is not unique. Theorem 3. Assume a counterexample p ∈ P n for a vector of predicates such that t k is the failing transition. If refines and additionally contains predicates corresponding to a separation of R k from Pre(a k , t k , a k+1 ), and a refined counterexample p ∈ P n of p is found, then there exists a failing transition t j in p , such that j &lt; k.</p><p>Proof. Assume a refined counterexample p = ( a , t) given the vector of predicates of the counterexample p = ( a, t) is found. Additionally, assume t k was the failing transition in the counterexample p. The notation A = C ( b k )\(R k ∪ Pre(a k , t k , a k+1 )) is used during this proof. Consider then the two possibilities for the abstract state a k = (l k , b k ):</p><formula xml:id="formula_48">• C ( b k ) ⊆ R k ∪ A: As Pre(a k , t k , a k+1 ) ⊆ Pre(a k , t k , a k+1 ), it is evident that Pre(a k , t k , a k+1 ) ∩ C ( b k ) = ∅.</formula><p>This means, that the transition t k was not available in a k , which contradicts the statement that p is a path.</p><formula xml:id="formula_49">• C ( b k ) ⊆ Pre(a k , t k , a k+1 ) ∪ A: It is clear, that R k ⊆ R k . Since R k ⊆ C ( b k ) and C ( b k ) ∩ R k = ∅, then it follows that R k = ∅.</formula><p>Hence, there is a failing transition t j in p with j &lt; k.</p><p>As a single counterexample p is of finite length, the above theorem guarantees that after a finite number of iterations, a refinement of p will not be possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Locally infeasible abstract states</head><p>This section presents a second counterexample analysis algorithm. The purpose of this algorithm is to check a counterexample quickly for a common cause of spurious counterexamples. It is also shown that this analysis produces new predicates with stronger implications for subsequent searches in the refined abstract state-space. Definition 14. For a path p = ( a, t) ∈ P n+1 given the vector of predicates , with a = (a 0 , . . . , a n+1 ) = ((l 0 , b 0 ), . . . , (l n+1 , b n+1 )) and t = (t 0 , . . . , t n ), an abstract state</p><formula xml:id="formula_50">a i for 1 i n is called locally infeasible, iff Post(C ( b i-1 ) ∩ X , t i-1 , a i ) ∩ Pre(a i , t i , a i+1 ) = ∅.</formula><p>The detection of locally infeasible abstract states can be implemented in a straight-forward fashion. In addition, new predicates can easily be computed that will disallow refined counterexamples. If a state a i is locally infeasible, then the analysis can use the fact that the implemented optimization technique guarantees that either t i-1 or t i is a discrete transition. If t i-1 is discrete, one reasonable choice is to use the predicates corresponding to the constraints of the polyhedral sets representing Post(C ( b i-1 ) ∩ X , t i-1 , a i ) in the refined search. Otherwise, a possible approach is to use the predicates corresponding to Pre(a i , t i , a i+1 ) in the refined search. This strategy of picking new predicates is denoted with LocalStrategy<ref type="foot" target="#foot_1">2</ref> from now on.</p><p>Consider the thermostat example of Fig. <ref type="figure">1</ref> for a vector of predicates = (t 1, t 3, T 5, T 6). A possible path in this abstract state-space is to start in the abstract state a 0 with continuous state-space 0 t 1 ∧ 5 T 6 while in location Heat, then enter the abstract state a 1 with 1 &lt; t 3 ∧ 5 T 6 in location Heat following a transition t c due to continuous flow, and end up in the abstract state a 2 with 0 t 1 ∧ 5 T 6 in location Check following a transition t d due to a discrete switch. The following shows that the abstract state a 1 is locally infeasible:</p><formula xml:id="formula_51">Post(a 0 , t c , a 1 ) = {(Heat, (t, T )) ∈ X | 1 &lt; t 1.5, 6 T 2(t -1) + 5}; Pre(a 1 , t d , a 2 ) = {(Heat, (t, T )) ∈ X | 2 t 3, 5 T 6};</formula><p>thus, Post(a 0 , t c , a 1 )∩Pre(a 1 , t d , a 2 ) = ∅ which implies that a 1 is indeed locally infeasible. Using LocalStrategy as described above, we add the predicate t 2 to the vector of predicates, as this is the only new predicate in Pre(a 1 , t d , a 2 ). This implies that the guard condition of this transition is important for the verification of this particular safety property.</p><p>The following theorem can be proven about using the strategy LocalStrategy in case a locally infeasible abstract state is found. The theorem formalizes that this strategy guarantees that a refinement of the (unlabeled) counterexample will not be found in subsequent searches. Theorem 4. Assume a counterexample p ∈ P n for a vector of predicates , such that there is a locally infeasible abstract state a i in p. A search in the refined abstract state-space given by the strategy LocalStrategy to find new predicates will not find a counterexample that is a refinement of p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Consider two possible cases:</head><p>• The state a i for i 1 is locally infeasible and t i-1 is discrete. In this case a refined counterexample is not possible, as the following transition t i will not be available for the single possible refined abstract state a i = (l i , b i ) of the locally infeasible state a i = (l i , b i ). In other words, a refined counterexample would end up in the continuous statespace</p><formula xml:id="formula_52">C ( b i ) = C ( b i ) ∩ Post(C ( b i-1 ) ∩ X , t i-1 , a i ).</formula><p>The assumption that a i is locally infeasible provides that</p><formula xml:id="formula_53">Post(C ( b i-1 ) ∩ X , t i-1 , a i ) ∩ Pre(a i , t i , a i+1 ) = ∅, which means that Post(C ( b i ) ∩ X , t i , a i+1 ) ⊆ Post(Post(C ( b i-1 ) ∩ X , t i-1 , a i ), t i , a i+1 ) = ∅.</formula><p>Hence, Post(C ( b i ) ∩ X , t i , a i+1 ) = ∅ for the refined abstract state a i+1 of the abstract state a i+1 . Therefore, the transition t i is not available in the refined abstract state a i , and a refined counterexample is not possible. • The state a i for i 1 is locally infeasible and t i is discrete. Any possible refined abstract state a i of the locally infeasible abstract state a i that is reachable using the same sequence of transitions will not be able to reach any refined version of the abstract state a i+1 using t i . In other words, any refined counterexample would end up in the continuous state-space</p><formula xml:id="formula_54">C ( b i ) ⊆ C ( b i )\Pre(a i , t i , a i+1 ). As a i is locally infeasible, Post(C ( b i ) ∩ X , t i , a i+1 ) = ∅.</formula><p>Following the same reasoning as above, it can be seen that a refined counterexample is not possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Computing separating predicates</head><p>The previous sections describe two counterexample analysis algorithms. If the counterexample is found to be infeasible, then the analysis should identify one or more new predicates that would rule out this sequence in the refined abstract space. This reduces to the problem of finding one or more predicates that separate two sets of polyhedra. This section presents a greedy strategy for identifying the separating predicates. After discovering new predicates, these predicates can then be added to the set of predicates used before, and the search can then be rerun in the refined abstract state-space defined by the enriched predicate set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Separating two disjoint convex polyhedra</head><p>Let P and Q be two disjoint convex polyhedra. To separate them, the distance between P and Q is defined as <ref type="figure">where d(•,</ref><ref type="figure">•</ref>) denotes the Euclidean distance. Since P and Q are disjoint, <ref type="figure">d(P ,</ref><ref type="figure">Q</ref>) is positive. Let p * ∈ P and q * ∈ Q be points that realize the distance d(P , Q), in other words, they form a pair of closest points. Denote by s(p * , q * ) the line segment with extreme points p * and q * . The half-space H which is normal to s(p * , q * ) and has q * as a supporting point can be written as: H = {x| p *q * , x p *q * , q * }. The complement of H is denoted by H.</p><formula xml:id="formula_55">d(P , Q) = inf{d(p, q)|p ∈ P ∧ q ∈ Q},</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4. The polyhedron Q is contained in H and the polyhedron P it is contained in H.</head><p>As a remark, Lemma 4 also holds for any half-space which is normal to s(p * , q * ) and passes through an arbitrary point in s(p * , q * ). Hence, any such half-space can be used to define a separating predicate. To compute d(P , Q) as well as p * and q * , there exist efficient algorithms <ref type="bibr" target="#b9">[11]</ref> which take time O(K P + K Q ) where K P and K Q are the number of vertices of P and Q.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Separating two disjoint sets of convex polyhedra</head><p>This section proceeds with the problem of finding a set of separating predicates for two sets of convex polyhedra P 1 and P 2 . In order to keep the size of the abstract state space small, the analysis tries to find with the smallest number of predicates. Many related polyhedral separation problems have been considered in the literature (see <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b32">34]</ref> and references therein). However, the solutions proposed in these works are only for two and three dimensional polyhedra. On the other hand, even in low dimensions most separation problems were shown to be intractably hard. In three dimensions the problem of finding a minimum facet-separator for two polyhedral solids is NP-complete <ref type="bibr" target="#b17">[19]</ref>. Therefore, in this work the objective is not to find an optimal solution but to develop some heuristics which are effective on the problem of separating reachable sets of hybrid systems for abstraction refinement purposes.</p><p>The solution is based on the following observation. Given two sets of polyhedra P 1 and P 2 , if the convex hulls of P 1 and P 2 are disjoint, then one can apply the method presented in the previous section to find a separating predicate. If the convex hulls intersect, it is clear that P 1 and P 2 cannot be separated by a single hyperplane. The main idea is to divide P 1 and P 2 into subsets of polyhedra such that their convex hulls do not intersect allowing to find a separating predicate. The procedure of subdivision can be performed in a hierarchical way. Initially, all polyhedra in P 1 and P 2 are recursively subdivided until the convex hulls are pairwise disjoint. Moreover, for efficiency purposes, instead of convex hulls, approximations by non-axis-aligned bounding boxes are used which are easier to compute and to test for overlaps (see Fig. <ref type="figure" target="#fig_5">5</ref>). The figure shows a case where subdividing based on non-axis-aligned bounding boxes the sets P = {P 1 , P 2 , P 3 } and Q = {Q 1 , Q 2 , Q 3 }, respectively, into {P 1 , P 2 }, {P 3 } and {Q 1 , Q 2 }, {Q 3 } allows to find two separating predicates 1 and 2 . One way of computing tight fitting bounding boxes is to align the axes of the box in the directions along which the vertices of the polyhedra tend to lie. From the vertices of the polyhedra the matrix of covariance can be determined and its largest eigenvectors can be taken to define the orientation of the box.</p><p>The method for computing separating predicates is summarized in Algorithm 2. H( ) denotes the half-space defined by predicate . Given a set P of polyhedra, chull(P) and bbox(P) are respectively the convex hull and a non-axisaligned bounding box of P. The set S(P, ) = {s ∈ P | s ⊆ H( )} is the largest subset of P lying entirely inside H( ), and Int(P, ) = {s ∩ H( ) | s ∈ P ∧ s ∩ H( ) = ∅} is the intersection of P with H( ). The core of the algorithm is a procedure sep, which computes a separating predicate for two disjoint polyhedra using the method presented in Section 4.1. Two sets of polyhedra P 1 and P 2 are said to be separable if conv{P 1 } ∩ conv{P 2 } = ∅ where conv is a convex-approximation operation which, as stated above, can be chull or bbox. In the algorithm the notation separable(P 1 , P 2 ) indicates that P 1 and P 2 are separable.</p><p>As one can see from line 4, a greedy strategy is used to choose separating predicates, that is the predicate that can separate the largest number of polyhedra is selected. An alternative selection criterion is to maximize the volume of separable polyhedra. The goal of line 5 is to exclude the subsets of P 1 and P 2 that the selected predicate m can separate. Indeed, if one of the sets Int(P 1 , m ) and Int(P 2 , m ) is empty, then either P 1 or P 2 lies entirely outside the half-space H( m ). This means that the predicate m can separate a part of one set from the other, and the algorithm only needs to continue with the remaining part.</p><p>One factor that determines the number of separating predicates is the subdivision in line 2. The way the algorithm subdivides the sets P 1 with view of avoiding interference of the resulting subsets with P 2 is as follows. First, it tries Algorithm 2. SEPARATING(P 1 , P 2 )</p><p>1: If separable(P 1 , P 2 ), compute = sep(chull{P 1 }, chull{P 2 }) and return . 2: Divide P 1 and P 2 into subsets P 11 , P 12 and P 21 , P 22 , respectively.</p><p>3: Compute separating predicates for pairs of one set and a subset of the other:</p><formula xml:id="formula_56">t = { = sep(chull{P i }, chull{P jk })|separable(P i , P jk ), 1 i = j, k 2}.</formula><p>If t = ∅, go to line 4; otherwise, continue with pairs of subsets:</p><formula xml:id="formula_57">t = { = sep(chull{P 1i }, chull{P 2j })|separable(P 1i , P 2k ), 1 i, j 2}.</formula><p>If t = ∅, repeat the algorithm for all pairs (P 1i , P 2j ), 1 i, j 2. 4: Pick m ∈ t that maximizes |S(P 1 , )| + |S(P 2 , ¬ )|. 5: Compute the two pairs (Int(P 1 , m ), Int(P 2 , m )), (Int(P 1 , ¬ m ), Int(P 2 , ¬ m )). For each pair, if both sets are non-empty, repeat the algorithm for the pair.</p><p>to split P 1 into two subsets such that one contains all the polyhedra entirely outside conv(P 2 ). If this subset is empty, then P 1 is split with respect to a hyperplane which is perpendicular to the longest side of bbox(P 1 ) and passes through its centroid. Another option for the normal of the splitting hyperplane is the line passing through the two most distant points. <ref type="foot" target="#foot_3">4</ref> It is not easy to know which option is better (in terms of number of resulting predicates); often the first one is preferred since the splitting hyperplane is easier to compute. Finally, the following lemma can be used to achieve better efficiency.</p><p>Lemma 5. If a set of predicates separates the boundaries of P 1 and P 2 then it separates P 1 and P 2 .</p><p>To prove the lemma, it is remarked that separates P 1 and P 2 iff any line segment between a point in P 1 and another point in P 2 intersects with the hyperplane of at least one predicate in . Hence, if separates the boundaries of P 1 and P 2 , then it separates P 1 and P 2 since any line segment connecting points in the interior of two disjoint sets must cross the boundaries of both sets. Using Lemma 5, only some boundary layers of P 1 and P 2 can be considered, which allows to obtain tighter convex approximations and thus requires less splitting. To extract a boundary layer for P 1 and P 2 , begin by triangulating the two sets. Let B be the bounding box of P 1 ∪ P 2 . The subset G of B \ ( P 1 ∪ P 2 ) that has a common boundary with both P 1 and P 2 is called the separation space. The boundary layers P 1 and P 2 are chosen as the sets of simplices in the triangulations of P 1 and P 2 which are adjacent to the separation space G. Intuitively, the hyperplanes of form a separating surface inside G; therefore, it suffices to use Algorithm 2 to separate P 1 and P 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">The thermostat example</head><p>This section demonstrates the global counterexample analysis algorithm as well as the procedure to separate two disjoint sets of polyhedra using the thermostat example as described in Fig. <ref type="figure">1</ref>. For purposes of illustration, the verification is started with the predicates mentioned in the model ˆ ; that means, we are considering all predicates mentioned in Eq. (1) except t 0, which is not sufficient to prove safety.</p><p>The first iteration of the algorithm produces a spurious counterexample of length 7 after 11 abstract states have been discovered by the search of the abstract state-space. The separation routine suggests the following four linear predicate to refine the abstract state-space: 0.979265*T + 0.202584*t &lt;= 9.34423 0.872555*T + 0.488515*t &lt;= 8.16961 0.428587*T + 0.9035 *t &lt;= 4.11184 -0.0680518*T + 0.997682*t &lt;= -0.439659 Please note the last suggested predicate and its similarity to the predicate t 0 considering the normal range 5 T 10. The model designer may have been able to use this suggested set of predicates to refine the abstract state space by adding the predicate t 0. However, in the following we use the four suggested predicates as such, and continue the analysis of this example. After refining the predicates with the help of these four predicates, the system still finds a spurious counterexample, and suggests four more predicates. In a third round, the system generates eleven more predicates after discovering another spurious counterexample, one of which is 0.0139043 * T + 0.999903 * t &lt;= 0.152558. The total set of 28 predicates is then in the following iteration enough to prove the thermostat example safe. The search in the abstract state-space finds 358 reachable abstract states. This compares to the ten predicates of Eq. ( <ref type="formula" target="#formula_15">1</ref>) that are sufficient to prove safety while discovering 35 reachable abstract states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implementation issues</head><p>This section presents algorithms for the validation analysis of counterexamples encountered during the search of the abstract state-space as presented in the preceding sections and a greedy polyhedral separation routine to discover new predicates. The algorithms as presented earlier in this paper are inspired by similar techniques used for the analysis of counterexamples encountered during program abstraction of discrete computer models.</p><p>However, computationally, it is often not possible to compute the Post-sets corresponding to the statement R i = Post(R i-1 , t i-1 , a i ) in Algorithm 1 exactly, and approximations are needed. Similarly, the Pre-and Post-sets used in the definition of locally infeasible abstract states cannot be computed precisely, but rather need to be approximated. This section explores the implementation issues that arise due to this constraint which is a significant additional constraint on the computation method.</p><p>Since the discrete program abstraction methods can compute sets of reachable states exactly, they have a significant advantage in picking new predicates based on such a counterexample analysis. This is one reason why the idea of a second analysis algorithm (the local feasibility checker) has not surfaced in previous program abstraction methodologies. It is worth mentioning here that the previously mentioned CEGAR algorithm implementation for hybrid systems also provides a similar local feasibility check <ref type="bibr" target="#b13">[15]</ref>. The authors describe certain advantages of considering fragments of a counterexample compared to the whole counterexample. Fragments are sub-paths of unspecified length of the original counterexample. Thus, the here presented local feasibility check can be seen as a particular fragment. However, the authors only provide an experimental description why fragments can be interesting to consider in this approximationbased counterexample analysis methodology without providing a formal comparison of the expected relative strength of predicates as described earlier in this paper.</p><p>An additional difference to our work presented here is the fact that the approach described in <ref type="bibr" target="#b11">[13]</ref> performs lazy abstraction <ref type="bibr" target="#b24">[26]</ref>. We believe that this choice may not be appropriate for hybrid systems verification given the nature of extensive over-and under-approximations needed during the various analysis steps and the numerical computations performed. The thermostat example shows that a user may be able to find more appropriate predicates based on suggestions provided by the tool. In the small, two-dimensional thermostat example 10 predicates would be enough to prove safety, while the fully automated approach needs to discover 28 predicates thus complicating the analysis substantially. In bigger examples, such lazy abstraction can easily result in impractically large abstractions.</p><p>Considering the order of the analysis algorithms, it is clear that since the local feasibility checker provides a fast and reliable way to eliminate a common spurious counterexample pattern, it is advantageous to perform this algorithm first. The algorithm should only raise a flag, if the counterexample to be analyzed is clearly spurious. Therefore, the implementation actually computes over-approximations of the reachable Pre-and Post-sets that are due to continuous flow. <ref type="foot" target="#foot_4">5</ref> Using an over-approximated polyhedral set computation, one can guarantee that a problem will only be detected if the counterexample is indeed spurious.</p><p>In order to keep the approximation tight in this analysis check, the implementation actually uses by default a 5-times smaller time-step than was used during the search of the abstract state-space. However, this finer precision factor can be changed by the user as a parameter to the verification tool. Again, a tradeoff between precision on the one hand and space and time considerations on the other has to be made. Now, consider the forward analysis algorithm as presented in Section 3.1. In contrast to the local feasibility checking algorithm, this analysis algorithm actually has two main contributions: Firstly, it should flag a problem if a spurious trace can then be used as a simulation guide in the original system to verify the existence of a counterexample. The methodology presented here uses a slightly modified version of Algorithm 3. Instead of simply saving the set of polyhedral slices at each step of the algorithm, the algorithm actually saves full traces up to that point. Each trace consists of a sequence of polyhedral slices and an appropriate transition information between successive polyhedra. This information is either the appropriate discrete switch or the exact time that the next slice has been computed.</p><p>Assuming that Algorithm 3 finds that the counterexample actually does correspond to a concrete trace, it is then clear that the algorithm has found a sequence of locations and polyhedra and corresponding transition information of the form (l 0 , p 0 ) → t 0 (l 1 , p 1 ) → t 1 • • • → t n-1 (l n , p n ) with l i ∈ L and p i ⊆ C ( b i ) ∩ X for all 0 i n. It is thus clear that there is a state in p 0 while in location l 0 that can end up in the set of unsafe states by taking the transitions → t 0 , → t 1 , . . . , → t n-1 . However, not all states in p 0 will end in an unsafe state following these transitions. To compute a witness trace, the algorithm takes a complete trace, and starting from the last polyhedron p n computes successively the Pre-sets given the applicable transition that leads to the previous polyhedron. It thus computes subsets r i of the polyhedra p i , and it is guaranteed that all states in r 0 following the transitions will end up in an unsafe state inside r n = p n . This procedure is illustrated in Fig. <ref type="figure" target="#fig_6">6</ref>.</p><p>The figure shows an abstract counter-example with four abstract states (l 0 , b 0 ), (l 1 , b 1 ), (l 2 , b 2 ) and (l 3 , b 3 ) with (l i , b i ) → t i (l i+1 , b i+1 ) for i ∈ {0, 1, 2}. Only the continuous state-space is shown in Fig. <ref type="figure" target="#fig_6">6</ref>, and a particular trace as computed by Algorithm 3 is given as p i ⊆ C ( b i ) for i ∈ {0, 1, 2, 3}. The computation of a witness trace first sets r 3 = p 3 , and then computes r 2 ⊆ p 2 as the Pre-set of r 3 given the transition t 2 . It is guaranteed that r 2 is not empty. Analogously, the algorithm then computes r 1 ⊆ p 1 and r 0 ⊆ p 0 . Any state in r 0 can then be used to prove the validity of the discovered abstract counterexample in the concrete system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Separating sets of polyhedra</head><p>The previous section described how to compute a witness trace if Algorithm 3 determines that the abstract counterexample corresponds to a concrete trace. This section elaborates on the case that the algorithm determines that the abstract counterexample is spurious. As discussed earlier, the algorithm actually computes an under-approximation of the reachable sets of states following the counterexample. As discussed in Section 4, the separation of polyhedra uses the last set of reachable polyhedra R k that is not empty, and separates this set from the set of states that correspond to the Pre of the following abstract state s k+1 .</p><p>The implementation uses various heuristics to generate good separation predicates. Initially, the algorithm computes an over-approximation of the Pre-set with an user-specified finer precision than used in the abstract search. It should be noted that since an over-approximation of the Pre-set is computed, it is not guaranteed that it will be disjoint from the set of reachable states R k . If R k , however, does intersect with this over-approximation, the separation routine will not be able to compute any separation predicates. In this case, the algorithm re-computes the Pre-set; however, this time it computes an under-approximation. This guarantees that the two sets will be disjoint and can thus be separated using the greedy algorithm as presented in Section 4. However, it should be understood that the predicates are based on under-approximated reachable sets of states that will be used in an abstract state-space search based on over-approximations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Case studies</head><p>We presented foundations for automated verification of safety properties of hybrid systems by combining the ideas of counterexample guided predicate abstraction and polyhedral approximation of reachable sets of linear continuous dynamics. The presented counterexample analysis tool extends previous work on predicate abstraction of hybrid systems <ref type="bibr" target="#b2">[3]</ref>. Our current prototype implementation of the predicate abstraction model checking and the counterexample analysis tool are both implemented in C++ using library functions of the hybrid systems reachability tool d/dt <ref type="bibr" target="#b6">[8]</ref>. We implemented a translation procedure from CHARON <ref type="bibr" target="#b1">[2]</ref> source code to the predicate abstraction input language which is based on the d/dt input language. Our tool uses the polyhedral libraries CDD <ref type="bibr" target="#b21">[23]</ref> and QHull <ref type="bibr" target="#b8">[10]</ref>. We have implemented the global analysis algorithm, the local feasibility check, as well as the computation of separating predicates as part of the counterexample analysis tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Fischer's mutual exclusion</head><p>We first look at an example of mutual exclusion which uses time-based synchronization in a multi-process system. We want to implement a protocol that allows a shared resource to be used exclusively by at most one of two processes at any given time. The state machines for the two processes are shown in Fig. <ref type="figure" target="#fig_7">7</ref>. The example is small enough to be used effectively for an illustration of our approach.</p><p>The variable turn is used to establish right of access in the model. The system starts with turn = 0 and both agents are in their respective Idle locations. Once process i ∈ {1, 2} moves to its respective Request location, it takes at most time-units to assign i to turn, establishing its wish to access the shared resource, and switch to its Check location. The process is required to stay in its Check location for at least time-units before it can test the value of turn. If turn still holds the value i it will access the shared resource; otherwise, it does not access the resource this time and moves back to its Idle location. The constraints ẋ = 0 and ẏ = 0 are omitted in the respective Idle and Check locations in the figure in order not to clutter the presentation. Similar case studies have been studied in various contexts and with slightly different models, as, for example, in <ref type="bibr" target="#b29">[31]</ref>.</p><p>The possible execution traces depend on the two positive parameters and . If the parameters are such that is true, we can find a counterexample that proves the two processes may access the shared resource at the same time. On the other hand, if &gt; , then the system preserves mutual exclusive use of the shared resource.</p><p>We use this example to illustrate the use of the local feasibility check of counterexamples for the case that &gt; . Consider the abstract system defined by the predicates used in the description of the 2-process Fischer's mutual exclusion protocol. These are: x , y , x , y , &gt; , &gt; 0, &gt; 0, x 0 and y 0. The search in the abstract statespace finds a counterexample of length nine. The third abstract state a 3 in the counterexample has both processes in their respective Request locations, turn = 0, and 0 x , 0 y . The following state a 4 can be reached by a discrete transition t d , and the first process is now in its Check location, while turn = 1 and 0 x , 0 y . The fifth abstract state a 5 can then be reached by a continuous transition t c , so that the locations and the turn variable are unchanged, but now we have x &gt; ∧ 0 y . It can be shown that a 4 is locally infeasible:</p><p>Pre(a 4 , t c , a 5 ) = ((Check, Request), (turn, x, y, , )) ∈ X | turn = 1 ∧ 0 y &lt; x &lt; and Post(a 3 , t d , a 4 ) = ((Check,Request), (turn, x, y, , )) ∈ X | turn = 1 ∧ 0 x y &lt; ∧ 0 &lt; ; hence, it follows that Post(a 3 , t d , a 4 ) ∩ Pre(a 4 , t c , a 5 ) = ∅. Using LocalStrategy we include the only one new predicate x y to the set of predicates. In the next iteration with this refinement of the abstract state-space, we obtain a symmetrical locally infeasible counterexample. The strategy LocalStrategy then suggests the symmetric predicate y x. The subsequent reachability analysis finds 54 reachable abstract states in the refined abstract state-space, which all maintain the mutual exclusion property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Coordinated adaptive cruise control</head><p>We have also successfully applied our predicate abstraction technique to verify a model of the coordinated adaptive cruise control mode of a vehicle-to-vehicle coordination system. This case study is provided by the PATH project (see http://www-path.eecs.berkeley.edu). We first briefly describe the model omitting a more detailed discussion for the sake of brevity. The goal of this mode is to maintain the car at some desired speed v d while avoiding collision with a car in front. Let x and v denote the position and velocity of the car. Let x l , v l and a l denote respectively the position, velocity and acceleration of the car in front. Since we want to prove that no collision happens regardless of the behavior of the car in front, this car is treated as disturbance, more precisely, the derivative of its acceleration is modeled as uncertain input ranging in [da l min , da l max ].</p><p>The closed-loop system can be modeled as a hybrid automaton with 5 continuous variables and 8 locations. The invariants of the locations and the transition guards are specified by the operation regions and switching conditions of the controller together with the bounds on the speed and acceleration. In order to prove that the controller can guarantee that no collision between the cars can happen, we specify an unsafe set as x lx 0 in all locations. To define initial predicates, in addition to the constraints of the invariants and guards, we use the predicate of the bad set allowing to distinguish safe and unsafe states and predicates representing the initial set. Assuming that the follower car is faster than the preceding car, and a too small initial separation of the two cars, the tool finds a counterexample that corresponds to a real trace in the concrete system. On the other hand, if the two cars start with a large enough initial separation, the combined verification approach enabled us to prove safety of the abstract system which implies safety of the concrete system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>This paper described algorithms for the validation analysis of abstract counterexamples in the concrete hybrid system. If this validation analysis finds that the abstract counterexample does in fact represent a valid counterexample in the concrete system, a concrete witness trace is computed that can be used by the user as an input to a simulation engine. If the validation analysis determines that the abstract counterexample is spurious, this paper also describes methods to identify appropriate new predicates to be used in subsequent abstract state-space explorations. The success of the abstract search crucially depends on the choice of the predicates and the methods described in this paper produce such predicates. We also defined a notion of refinement of abstract states and abstract paths that provides valuable insight into the quality of such computed predicates.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Discrete abstraction of the continuous state-space for the thermostat model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. An abstract path for the thermostat model of Fig. 1 using predicates mentioned in the model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 11 (</head><label>11</label><figDesc>Refinement of abstract states). An abstract state a = (l , b ) ∈ Q for the vector of predicates refines another abstract state a = (l, b) ∈ Q for the vector of predicates , iff l = l and C ( b ) ⊆ C ( b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A counterexample of length 3. For each abstract state a i = (l i , b i ) the concrete continuous state-space C ( b i ) that it represents is illustrated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>3</head><label>3</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Illustrating the greedy algorithm that separates sets of polyhedra.</figDesc><graphic coords="15,132.84,67.60,281.52,125.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Computing a concrete witness trace for a non-spurious abstract counterexample.</figDesc><graphic coords="19,130.84,67.45,285.84,72.29" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The two processes for the mutual exclusion example.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The analysis could use the constraints of all polyhedra from P or Q to determine . However, as the size of the refined abstract state-space is exponential in the number of predicates, it is advantageous to include as few predicates as possible.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>It is preferred to use predicates computed on the basis of discrete transitions, as these can be computed more easily and more exactly.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The problem of finding a separating predicate for two disjoint polyhedra can also be formulated as a linear programming problem and thus solved in polynomial time.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>These ideas are inspired by collision detection techniques in robotics and computer graphics<ref type="bibr" target="#b27">[29]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>It should be noted, that it is possible to compute exact polyhedral sets for transitions due to discrete jumps. As mentioned earlier, it is guaranteed that at least one of the two considered transitions for the local feasibility check is due to a discrete jump.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>counterexample is found. In this case, it should also provide the greedy separation routine of Section 4 with sets of polyhedra to be separated. Secondly, however, if the abstract counterexample corresponds to a concrete counterexample, it should be able to provide a witness trace in the concrete hybrid system model proving the validity of the counterexample and a witness trace of the violation of the property at hand. Since the polyhedral sets need to be approximated, it cannot be guaranteed that an abstract counterexample is identified as spurious if and only if it really is spurious. Given these requirements, it is thus clear that the forward search analysis algorithm needs to compute under-approximations of the reachable sets of states (for transitions due to continuous flow). One way of implementing such an under-approximated analysis algorithm is to keep track only of particular slices of the reachable sets of states. The Algorithm 3 presents such an approach and should be understood as one possible implementation of Algorithm 1. An alternative would be to implement a procedure that computes under-approximated flow-pipes between the slices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3. UNDER-APPROXIMATION ANALYSIS OF</head><p>return"Counterexample is probably spurious!" end if end for return"Counterexample corresponds to a concrete trace!"</p><p>The algorithm computes for each abstract state a set of polyhedral slices R i representing an under-approximation of the forward analysis as described in Algorithm 1. The initial set R 0 of polyhedra is initialized by exactly one polyhedron representing the initial states of the initial abstract state mentioned in the counterexample. For the following abstract states on the counterexample, the set of under-approximated polyhedra is computed as follows. If the transition is discrete, the algorithm computes the image of the enabled states for each polyhedron in the set R i-1 . However, if the transition is continuous, the algorithm computes for each polyhedron in the set R i-1 the slices at time r, 2r, 3r, . . . . These slices can be computed exactly. Therefore, the set of these polyhedra constitutes an under-approximation of the reachable set of states. This analysis algorithm then checks whether any R i is empty, which signals that the performed under-approximation could not produce a witness trace. This means that the counterexample may be spurious without guaranteeing this result. However, if the analysis algorithm finds that all sets including R n are non-empty, it has thus found proof that this counterexample corresponds to a counterexample in the concrete hybrid system.</p><p>There are certain optimizations that can be helpful in this analysis algorithm. First of all, the search in the abstract state-space finds the first possible time instance that an abstract state can be reached by continuous flow from another one. This information can now be used to reduce the amount of computations necessary in the analysis algorithm. The algorithm needs to only compute the slices at time k • r for k ( /r) since it is known that previous slices will definitely not intersect the next abstract state. Secondly, for the computation to be feasible, one can prescribe a limit on the number of slices that one wants to consider for continuous time flow at each instance of continuous flow. This parameter is also under user control in the implementation of the tool.</p><p>The following two sections discuss the implemented procedures that govern the two possible outcomes of Algorithm 3. First, the outcome is considered that the counterexample is found to correspond to a concrete one. Following that the computation of sets of polyhedra to be separated is discussed in case the counterexample is found to probably be spurious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Computing witness traces</head><p>If Algorithm 3 finds that the abstract counterexample corresponds to a concrete trace, a follow-up algorithm should be able to find a set of initial states and a sequence of concrete transitions that constitute a witness trace. This witness</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The algorithmic analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="3" to="34" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hierarchical modeling and analysis of embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivančić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="11" to="28" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reachability analysis of hybrid systems via predicate abstraction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivančić</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, Fifth Internat. Workshop</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2289</biblScope>
			<biblScope unit="page" from="35" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Reachability analysis of hybrid systems using counter-example guided predicate abstraction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ivančić</surname></persName>
		</author>
		<idno>MS-CIS-02-34</idno>
		<imprint>
			<date type="published" when="2002-11">November 2002</date>
			<pubPlace>Philadelphia, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A theory of timed automata</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="235" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Timing verification by successive approximation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Itai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">118</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="142" to="157" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Approximate reachability analysis of piecewise linear dynamical systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Asarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Bournez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1790</biblScope>
			<biblScope unit="page" from="21" to="31" />
		</imprint>
	</monogr>
	<note type="report_type">Third Internat. Workshop</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bebop: a symbolic model checker for boolean programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN 2000 Workshop on Model Checking of Software</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="113" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Quickhull algorithm for convex hulls</title>
		<author>
			<persName><forename type="first">C</forename><surname>Barber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huhdanpaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Math. Software</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="469" to="483" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A comparison of two fast algorithms for computing the distance between convex polyhedra</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cameron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robotics Automation</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="915" to="920" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Verification of polyhedral-invariant hybrid automata using polygonal flow pipe approximations, Hybrid Systems: Computation and Control</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chutinan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Krogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1569</biblScope>
			<biblScope unit="page" from="76" to="90" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Verification of hybrid systems based on counterexample-guided abstraction refinement, Tools and Algorithms for the Construction and Analysis of Systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Stursberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2619</biblScope>
			<biblScope unit="page" from="192" to="207" />
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
		<title level="m">Counterexample-guided abstraction refinement</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="154" to="169" />
		</imprint>
	</monogr>
	<note>Computer Aided Verification</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Abstraction and counterexample-guided refinement of hybrid systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Stursberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-aided verification</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="61" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">extracting finite-state models from Java source code</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Robby</surname></persName>
		</author>
		<author>
			<persName><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd Internat. Conf. on Software Engineering</title>
		<meeting><address><addrLine>Bandera</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="439" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th ACM Symp. on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The complexity of minimum convex nested polyhedra</title>
		<author>
			<persName><forename type="first">G</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Joseph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Canadian Conf. on Computational Geometry</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The tool KRONOS</title>
		<author>
			<persName><forename type="first">C</forename><surname>Daws</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems III: Verification and Control</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1066</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Determining the separation of preprocessed polyhedra-a unified approach</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kirkpatrick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP&apos;90</title>
		<meeting>ICALP&apos;90</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="400" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Minimum polygon separation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="218" to="232" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">cddlib reference manual, cddlib version 092a</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fukuda</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>McGill University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">HYTECH: the next generation</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th IEEE Real-Time Systems Symposium</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">HYTECH: a model checker for hybrid systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong-Toi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Tools Technol. Transfer</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Lazy abstraction</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="58" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The model checker SPIN</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="295" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automating software feature verification</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Labs Technical J</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="72" to="87" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">V-collide: accelerate collision detection for vrml</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gottschalk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VRML&apos;97</title>
		<meeting>VRML&apos;97</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Modeling and analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ivančić</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<pubPlace>Philadelphia, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A compositional proof of a real-time mutual exclusion protocol</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Kristoffersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Laroussinie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Internat. Joint Conf. Theory and Practice of Software Development (TAPSOFT&apos;97)</title>
		<meeting>7th Internat. Joint Conf. Theory and Practice of Software Development (TAPSOFT&apos;97)<address><addrLine>Lille, France; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-04">April 1997. 1997</date>
			<biblScope unit="volume">1214</biblScope>
			<biblScope unit="page" from="565" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">UPPAAL in a nutshell</title>
		<author>
			<persName><forename type="first">K</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Springer Internat. J. Software Tools Technol. Transfer</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Property preserving abstractions for the verification of concurrent systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Loiseaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bouajjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bensalem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Meth. System Des</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On the complexity of polyhedral separability</title>
		<author>
			<persName><forename type="first">N</forename><surname>Megiddo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Comput. Geometry</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="325" to="327" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
