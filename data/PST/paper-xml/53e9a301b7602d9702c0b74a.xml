<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An overview of the MOP runtime verification framework</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-04-23">23 April 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Patrick</forename><surname>O'</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Neil</forename><surname>Meredith</surname></persName>
							<email>pmeredit@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dongyun</forename><surname>Jin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dennis</forename><surname>Griffith</surname></persName>
							<email>dgriffi3@cs.uiuc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Feng</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Grigore</forename><surname>Ro≈üu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">P</forename><forename type="middle">O</forename><surname>Meredith</surname></persName>
							<email>pmeredit@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
								<address>
									<addrLine>201 N Goodwin Ave</addrLine>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An overview of the MOP runtime verification framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-04-23">23 April 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">2B16DD7F27D89DB01FCB69FA5874D9D7</idno>
					<idno type="DOI">10.1007/s10009-011-0198-6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Runtime verification</term>
					<term>Monitoring</term>
					<term>Testing</term>
					<term>Real time systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This article gives an overview of the, monitoring oriented programming framework (MOP). In MOP, runtime monitoring is supported and encouraged as a fundamental principle for building reliable systems. Monitors are automatically synthesized from specified properties and are used in conjunction with the original system to check its dynamic behaviors. When a specification is violated or validated at runtime, user-defined actions will be triggered, which can be any code, such as information logging or runtime recovery. Two instances of MOP are presented: JavaMOP (for Java programs) and BusMOP (for monitoring PCI bus traffic). The architecture of MOP is discussed, and an explanation of parametric trace monitoring and its implementation is given. A comprehensive evaluation of JavaMOP attests to its efficiency, especially in comparison with similar systems. The implementation of BusMOP is discussed in detail. In general, BusMOP imposes no runtime overhead on the system it is monitoring.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Runtime monitoring of requirements can increase the reliability of the resulting hardware or software systems. There is an increasingly broad interest in uses of monitoring in software development and analysis, as reflected, e.g., by abundant approaches proposed recently ( <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b46">46]</ref> among others), and also by the runtime verification (RV) and the formal aspects of testing (FATES) initiatives <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b58">58]</ref> among many others. Hardware approaches to monitoring have seen less active research. Most attempts in hardware to perform monitor tasks have been for the purposes of performance measures or temperature control. Lu and Forin <ref type="bibr" target="#b45">[45]</ref> is an approach that generates monitors from formal properties that are implemented in hardware, but these hardware monitors are actually used to monitor software programs.</p><p>Monitoring oriented programming (MOP) <ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref><ref type="bibr" target="#b21">[21]</ref><ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b47">47</ref>] is a generic monitoring framework that integrates specification and implementation by checking the former against the latter at runtime. In MOP, one specifies desired properties using logical formalisms with actions to handle violations or validations of the specified property. MOP tools will then automatically synthesize monitors from property specifications and integrate them within the application together with user-provided handling code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related work</head><p>We next discuss the relationships between the MOP framework and other related paradigms, including AOP, design by contract, runtime verification, and other trace monitoring approaches. Broadly speaking, all the approaches discussed below are instances of runtime monitoring. Interestingly, even though most of the systems mentioned below target the same programming languages, no two of them share the exact same logical formalism for expressing properties. This observation strengthens our belief that probably there is no silver bullet logic (or super logic) for all purposes. A major objective in the design of the MOP framework was to avoid hardwiring particular logical formalisms into the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.1">Aspect oriented programming languages</head><p>Since its proposal in <ref type="bibr" target="#b42">[42]</ref>, Aspect oriented programming (AOP) has been increasingly adopted and many tools have been developed to support AOP in different programming languages, e.g., AspectJ and JBoss <ref type="bibr" target="#b40">[40]</ref> for Java, and AspectC++ <ref type="bibr" target="#b5">[5]</ref> for C++. Built on these general AOP languages, numerous extensions have been proposed to provide domain-specific features for AOP. Among these extensions, Tracematches <ref type="bibr" target="#b2">[3]</ref> and J-LO <ref type="bibr" target="#b15">[15]</ref> support history(trace)-based aspects for Java.</p><p>Tracematches enable the programmer to trigger the execution of certain code by specifying a parametric regular pattern of events in a computation trace, where the events are defined over entry/exit of AspectJ pointcuts. When the pattern is matched during the execution, the associated code will be executed. In this sense, Tracematches support tracebased pointcuts for AspectJ. J-LO is a tool for runtimechecking temporal assertions. These temporal assertions are specified using parametric linear temporal logic (LTL) and the syntax adopted in J-LO is similar to Tracematches' except that the properties are specified in a different formalism. J-LO also uses the same parametricity semantics as Tracematches. J-LO mainly focuses on checking at runtime properties rather than providing programming support. In J-LO, the temporal assertions are inserted into Java files as annotations that are then compiled into runtime checks. Both Tracematches and J-LO support parametric events, i.e., free variables can be used in the specified properties and will be bound to specific values at runtime for matching events.</p><p>The MOP framework has logic plugins, which encapsulate different logical formalisms and allow it to capture the capabilities of Tracematches and J-LO. JavaMOP is the instantiation of the MOP framework for Java programs (see Sect. <ref type="bibr">3.2)</ref>.</p><p>JavaMOP allows for two different modes of matching traces, referred to as total trace matching and suffix trace matching. Total is the default mode of JavaMOP, while suffix mode is used by prefixing a JavaMOP property with the suffix modifier (see Fig. <ref type="figure" target="#fig_4">7</ref> and the accompanying text).</p><p>With total matching, e.g., with the pattern a * b, a sequence of events abb will trigger the validation handler of the generated MOP monitor only at the first b event and then the violation handler (if any) at the second b.</p><p>With suffix matching, however, the pattern will be matched twice, once for each b event: the first matches either the whole trace a b or the partial trace consisting of just the first b with zero occurrences of a, while the second matches the subsequent partial trace b (the second b in the trace) with zero occurrences of a; thus, the related advice will be executed twice.</p><p>With suffix matching, one can count matches of a pattern open close without a need to reset the monitor after each match, as would be required with total match monitoring. On the other hand, total trace matching is more suitable for runtime verification of formal properties, because it is the only semantics that makes sense for some logical formalisms, such as LTL, and thus many users expect this behavior for pattern languages like regular expressions and contextfree grammars (CFGs), as well.</p><p>J-LO can be captured by the JavaMOP with total matching because LTL (see Sect. <ref type="bibr" target="#b6">6</ref>.3) is supported by the MOP framework. MOP supports regular expressions as part of its extended regular expression (ERE) logic plugin (see Sect. 6.2), and Tracematches may be captured by JavaMOP using these ERE patterns with suffix matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.2">Runtime verification</head><p>In runtime verification, monitors are automatically synthesized from formal specifications, and can be deployed offline for debugging, or online for dynamically checking properties during execution. MaC <ref type="bibr" target="#b43">[43]</ref>, PathExplorer (PaX) <ref type="bibr" target="#b31">[31]</ref>, Eagle <ref type="bibr" target="#b10">[10]</ref>, and RuleR <ref type="bibr" target="#b11">[11]</ref> are runtime verification frameworks for logic based monitoring, within which specific tools for Java-Java-MaC, Java PathExplorer, and Hawk <ref type="bibr" target="#b24">[24]</ref>, respectively-are implemented. All these runtime verification systems work in outline monitoring mode and have hardwired specification languages: MaC uses a specialized language based on interval temporal logic, JPaX supports just LTL, and Eagle adopts a fixed-point logic. Java-MaC and Java Pat-hExplorer integrate monitors via Java bytecode instrumentation, making them difficult to port to other languages. Our MOP approach supports inline, outline, and offline monitoring; allows one to define new formalisms to extend the MOP framework; and is adaptable to new languages (we discuss two such instances in this paper).</p><p>Temporal Rover <ref type="bibr" target="#b25">[25]</ref> is a commercial runtime verification tool based on the future time metric temporal logic. It allows programmers to insert formal specifications in programs via annotations, from which monitors are generated. An automatic test generation (ATG) component is also provided to generate test sequences from logic specifications. Temporal Rover and its successor, DB Rover, support both inline and offline monitoring. However, they also have their specification formalisms hardwired and are tightly bound to Java. MOP currently has no metric temporal logic plugin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.3">Design by contract</head><p>Design by Contract (DBC) <ref type="bibr" target="#b49">[49]</ref> is a technique allowing one to add semantic specifications to a program in the form of assertions and invariants, which are then compiled into runtime checks. It was first introduced as a built-in feature of the Eiffel language <ref type="bibr" target="#b27">[27]</ref>. Some DBC extensions have also been proposed for a number of other languages. Jass <ref type="bibr" target="#b12">[12]</ref> and jContractor <ref type="bibr" target="#b0">[1]</ref> are two Java-based approaches.</p><p>Jass is a precompiler which turns the assertion comments into Java code. Besides the standard DBC features such as pre-/post-conditions and class invariants, it also provides refinement checks. The design of trace assertions in Jass is mainly influenced by CSP <ref type="bibr" target="#b37">[37]</ref>, and the syntax is more like a programming language. jContractor is implemented as a Java library which allows programmers to associate contracts with any Java class or interface. Contract methods can be included directly within the Java class or written as a separate contract class. Before loading each class, jContractor detects the presence of contract code patterns in the Java class bytecode and performs on-the-fly bytecode instrumentation to enable checking of contracts during the program's execution. jContractor also provides a support library for writing expressions using predicate logic quantifiers and operators such as Forall, Exists, suchThat, and implies. Using jContractor, the contracts can be directly inserted into the Java bytecode even without the source code.</p><p>Java modeling language (JML) <ref type="bibr" target="#b44">[44]</ref> is a behavioral interface specification language for Java. It provides a more comprehensive modeling language than DBC extensions. Not all features of JML can be checked at runtime; its runtime checker supports a DBC-like subset of JML. Spec# <ref type="bibr" target="#b8">[8]</ref> is a DBC-like extension of the object-oriented language C#. It extends the type system to include non-null types and checked exceptions and also provides method contracts in the form of pre-and post-conditions as well as object invariants. Using the Spec# compiler, one can statically enforce non-null types, emit run-time checks for method contracts and invariants, and record the contracts as metadata for consumption by downstream tools.</p><p>We believe that the logics of assertions/invariants used in DBC approaches fall under the uniform format of our logic engines, so that an MOP environment following our principles would naturally support monitoring DBC specifications as a special methodological case. In addition, the MOP framework also supports outline monitoring, which we find important in assuring software reliability (e.g., monitoring for and detecting and fixing deadlocks) but which is not provided by any of the current DBC approaches that we are aware of.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.4">Other related approaches</head><p>Program query language (PQL) allows programmers to express design rules that deal with sequences of events associated with a set of related objects <ref type="bibr" target="#b46">[46]</ref>. Both static and dynamic tools have been implemented to find solutions to PQL queries. The static analysis conservatively looks for potential matches for queries and is useful to reduce the number of dynamic checks. The dynamic analyzer checks the runtime behavior and can perform user-defined actions when matches are found. PQL has a "hardwired" specification language based on CFGs and supports only inline monitoring. CFGs can potentially express more complex languages than regular expressions, so in principle PQL can express more complex safety policies than Tracematches. The MOP CFG plugin described in Sect. 6.5 allows the MOP framework to specify most of the properties that may be specified in PQL.</p><p>Program trace query language (PTQL) <ref type="bibr" target="#b28">[28]</ref> is a language based on SQL-like relational queries over program traces. The current PTQL compiler, Partiqle, instruments Java programs to execute the relational queries on the fly. PTQL events are timestamped and the timestamps can be explicitly used in queries. PTQL queries can be arbitrarily complex and, as shown in <ref type="bibr" target="#b28">[28]</ref>, PTQL's runtime overhead seems acceptable in many cases but we were unable to obtain a working package of PTQL and compare it in our experiments with JavaMOP because of license issues. PTQL properties are globally scoped and their running mode is inline. PTQL provides no support for recovery, its main use being to detect errors.</p><p>The PSL to Verilog compiler, P2V <ref type="bibr" target="#b45">[45]</ref>, is the sole attempt to perform runtime monitoring of formal properties in hardware, other than our BusMOP instance (see Sects. <ref type="bibr">3.3 and 5)</ref>, of which we are aware. P2V is similar to BusMOP in that monitors are implemented in hardware rather than software, and that both approaches thus have no runtime overhead on the CPU. P2V, however, is more like the above approaches in that it is designed for monitoring actual programs rather than peripheral devices. Also it requires a dynamically extensible soft-core processor implemented on an FPGA, while our approach can potentially be applied to any COTS communication architecture. Further, P2V uses hardwired logic (PSL) while BusMOP allows different formalisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.5">Discussion</head><p>All this research and associated tools show that runtime monitoring is an increasingly accepted, powerful, and beneficial approach for developing reliable software and hardware.</p><p>Here we summarize the systems discussed above, and show how they may be classified in terms of the five orthogonal attributes of the MOP framework: programming language, logic, scope, running mode, and handlers. The programming language determines what language the programs to be monitored must be written in. The logic specifies which formalism is used to specify the property. The scope determines where to check the property; it can be class invariant, global, interface, etc. The running mode denotes where the monitoring code runs; it can be inline (weaved into the code), online (operating at the same time as the program), outline (receiving events from the program remotely, e.g., over a socket), or offline (checking logged event traces). 1 The handlers specify what actions to perform under exceptional conditions; there can be violation and validation handlers. It is worth noting that for many logics, violation and validation are not complementary to each other, i.e., the violation of a formula does not always imply the validation of the negation of the formula.</p><p>Most runtime monitoring approaches can be framed in terms of these attributes, while in the MOP framework they may be configured. Figure <ref type="figure" target="#fig_0">1</ref> lists the attributes for most of the software monitoring systems discussed above. For example, JPaX can be regarded as an approach that uses LTL to specify class-scoped properties, whose monitors work in offline mode and only detect violation.</p><p>This observation essentially motivates the design discipline of the MOP framework and specification language, namely that one should be allowed to choose the most appropriate logic and the most efficient monitoring algorithm for her/his own applications: while programming languages are designed and intended to be universal, logics and specifications tend to work best when they are domainspecific. 1 Offline implies outline, and inline implies online. Fig. <ref type="figure">2</ref> A JavaMOP Specification (SafeEnum)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Examples</head><p>Figure <ref type="figure">2</ref> shows an example specification using JavaMOP; recall that this is the MOP instance for Java programs (see Sects. 3.2 and 4). Detailed explanation of the specification syntax can be found in Sects. 3.1 and 3.2.1. This specification, called SafeEnum, describes the correct behavior of using Enumerations in Java. Essentially, this specification requires that an Enumeration created from a Vector not be used if the Vector has been updated since the Enumeration was created. This is important in legacy code that still uses Vectors and Enumerations because Java does not warn of this practice, it simply allows for non-deterministic results.</p><p>The specification is composed of five parts. The first line is the header of the specification, starting with three modifiers, full-binding, connected, and decentralized; the first states that monitor instances for this property should only raise failures when every parameter for the monitor instance has been bound (Sect. 4.4), the second states that the objects bound to the parameters must be connected by an event that actually occurs (Sect. 4.4), and the last chooses the way to index monitors for different parameter bindings (Sect. 4.3). An ID for the specification is given after modifiers and followed by parameters of the property; in this example, two parameters are used, namely a Vector object v and an Enumeration object e.</p><p>The second part contains the declaration of two monitor variables: instanceV and instanceE. Each monitor instance for each instantiation of the specification parameters has distinct monitor instance variables. Thus, they can be used for many purposes: logging, extra states for monitoring, statistics, and so on. Here, they are used for bug reporting, to keep track of which Vector and Enumeration cause the failure.</p><p>The third part of the specification contains event declarations. Three events are defined: createE for the creation of an Enumeration, updateV for updates to a Vector, and useE for uses of an Enumeration. JavaMOP borrows (and extends; see Sect. 3.2) the syntax of AspectJ <ref type="bibr" target="#b41">[41]</ref> for event declarations. For example, the createE event is declared to occur "after" a function call to the elements() method of class Vector. Note that the target clause is used to bind parameters in the event. Each event also sets one or both of the monitor variables, which will, again, be distinct for each binding of the parameters, using an event action (the Java code within the curly braces).</p><p>The fourth part of the specification is a formal description of the desired property. As discussed in Sect. 2, MOP is specification formalism independent, and one may choose different logics to specify properties. In this example, the property description begins with fsm, meaning that a finite state machine (FSM) is used, and continues with a finite state description of the monitor. Monitors for FSM properties are initially in the first state listed in the specification, in this case start. The monitor stays in the start state until an Enumeration is created from a given Vector. Once the Enumeration has been created, it is safe to use the Enumeration until such time as the underlying Vector is modified, at which point the invalidEnum state is entered. Using an Enumeration in the invalidEnum state will result in a failure of the property.</p><p>The last part of the specification consists of handlers to execute in different states of the corresponding monitor, such as pattern match or failure. In Fig. <ref type="figure">2</ref>, the handler starts with @fail, defining the action, a simple warning in this case, to execute when the trace fails to match the pattern. The handler reports which Vector and Enumeration are used incorrectly, and the line number where the failure occurs (given by the MOP-reserved variable __LOC). The __MONITOR keyword is resolved to the monitor object by JavaMOP. This is needed because there is no way from the context to tell if a given variable reference refers to a variable declared locally or a monitor instance variable.</p><p>JavaMOP specifications are compiled into AspectJ <ref type="bibr" target="#b41">[41]</ref> aspects. Specifications as short as the one in Fig. <ref type="figure">2</ref> compile into several hundred lines of AspectJ code. The generated aspect can then be weaved into a program one wishes to monitor, using any AspectJ compiler. Once weaved, simply running the program as normal results in a monitored run of the program. Figure <ref type="figure" target="#fig_1">3</ref> shows an example specification using BusMOP, the MOP instance for peripheral component interconnect (PCI) Bus monitoring (see Sects. 3 and 5). The main use for this instance is ensuring the proper use of peripherals connected to the PCI Bus. Improper use of peripherals may result from bugs in drivers or from misuse of the drivers by application programs. This specification, SafeCounterModify, states a desired property of the PCI703A digital-to-analog and analog-to-digital converter PCI board (ADC) <ref type="bibr" target="#b26">[26]</ref>. The ADC has counters that are used to determine when input data are fully converted and ready to be placed on the PCI bus. The specification in Fig. <ref type="figure" target="#fig_1">3</ref> is concerned with the ADC's Counter 2. It requires that any modification to cntr_cntrl2, the control register on the ADC for Counter 2, happens only while the Counter 2 is not enabled (running). Counter 2 is enabled when the 0th bit of cntr_cntrl2 is set to '1'.</p><p>As in Fig. <ref type="figure">2</ref>, the first line is the header of the specification. The keyword pci specifies that this property should generate bus listening code for the PCI bus. Again an ID naming the specification is provided. This time, because BusMOP does not have parameters, there is no parameter list.</p><p>The second part of the specification declares two signals, cntrlCurrent and cntrlOld, much like the monitor variables of Fig. <ref type="figure">2</ref>, but BusMOP has no monitor instances, so there is only one copy of the variables. These variables are used to store the previous value of cntr_cntrl2, which is the control register for Counter 2 on the ADC board. This is necessary because PCI bus properties cannot prevent incorrect behavior, but only detect and correct it. The stored value is used to restore the value of the register when the pattern fails to match (see below).</p><p>The third part of the specification contains event declarations, much like those in Fig. <ref type="figure">2</ref>, but using an instrumentation language specific to PCI Bus traffic, rather than AspectJ. Three events are defined. The keyword dbyte used in each event tells BusMOP that the quantity will be 16 bits wide (i.e., double byte). Event countDisable occurs when cntr_cntrl2, which is address X"220" in the address space of the ADC (base1 contains the address of the beginning of the ADC's address space), has its 0th bit (value(0)) set to '0', which disables Counter 2. The third event, countEnable, is analogous, but, as mentioned earlier, the bit is set to '1'. The event cntrl-Mod occurs when cntr_cntrl2 is modified. The keyword in is used rather than = to define the address for cntrlMod. This is because when no value for the read or write is specified, it is possible to check a whole range of addresses. Note that this event overlaps with countDisable and countEnable. The order of the events in Fig. <ref type="figure" target="#fig_1">3</ref> is significant because simultaneous events are handled by reporting them in the declared order (see Sect. 5). Each cntrlEnable saves the previous value of the register, so that it may be restored if the property is violated. The special variable value refers to the value of the data on the bus. A pipeline is kept where the previous value is stored to cntrlOld before cntrlCurrent receives the new bus value, so that the previous value may be recovered if the pattern fails (the event action occurs before the pattern is checked).</p><p>As in Fig. <ref type="figure">2</ref>, the fourth part is a formal description of the desired property, this time using an ERE. This pattern specifies the desired behavior where all modifications must happen after disabling the counter (note again the order of event declarations, which ensures that the cntrlMod encountered from a countDisable is reported after the cntrlMod). The pair (countEnable countDisable) enforces that no changes can be made to cntrl_cntrl2 while Counter 2 is enabled, other than disabling it.</p><p>The last part of the specification is the handler for a pattern failure, similar to SafeEnum. An assignment of '1' to the special variable mem_reg alerts the system that a memory write is eminent. The address of the write is placed in address_reg (note that it is the control register for Counter 2). The special variable value_reg is the value to be written out by the monitor, and it is given the value of cntrlOld, which stores the previous value of cntr_cntrl2. Lastly, the enable_reg is specific to the PCI Bus interface (see Sect. 5).</p><p>BusMOP specifications are compiled into hardware description language (HDL). As in JavaMOP, the size of the generated code is far greater than that of the original specification. The HDL code is compiled into an FPGA bitstream and programmed onto an FPGA that is inserted into an empty slot on the PCI bus of the system one wishes to monitor.</p><p>The examples given in Figs. 2 and 3 may monitor completely different properties in completely different problem domains, but they follow the same pattern and philosophy. By a clear separation of monitor generation and monitor integration, MOP provides fundamental and generic support for effective and efficient application of runtime monitoring in different problem domains, and can be understood from at least three perspectives:</p><p>1. As a discipline allowing one to improve safety, reliability and dependability of a system by monitoring its requirements against its implementation at runtime; 2. As an extension of programming languages with logics. One can add logical statements anywhere in the program, referring to past or future states of the program. These statements are like any other programming language boolean expressions, so they give the user a maximum of flexibility on how to use them: to terminate the program, guide its execution, recover from a bad state, add new functionality, etc.; 3. As a lightweight formal method. While firmly based on the logical formalisms and mathematical techniques, MOP's purpose is not program verification. Instead, the idea is to avoid verifying an implementation against its specification before operation, by not letting it go wrong at runtime.</p><p>Section 2 introduces the generic MOP framework. Section 3 discusses the two current language instances of MOP, giving a brief overview and describing their syntax. Section 4 presents topics specific to the efficient implementation of JavaMOP, as well as a thorough evaluation of JavaMOP, while Sect. 5 focuses on BusMOP. A performance evaluation of BusMOP (the MOP instance for monitoring PCI bus traffic) is unnecessary, as it has zero runtime overhead. <ref type="foot" target="#foot_0">2</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MOP framework</head><p>All monitoring systems share some features, such as program instrumentation and monitor integration, even when they aim at different domains or goals. MOP separates monitor generation and integration and provides a generic, extensible framework for runtime monitoring, allowing one to instantiate MOP with specific programming languages and specification formalisms to support different domains. In this section, we focus on the overall architecture of MOP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Architecture</head><p>Figure <ref type="figure" target="#fig_2">4</ref> shows the architecture of MOP. There are two kinds of high level components in MOP, namely the logic repository and language clients. The logic repository, shown in the bottom of Fig. <ref type="figure" target="#fig_2">4</ref>, contains various logic plugins and a logic plugin manager component. The logic plugin is the core component to generate monitoring code from formulae written in a specific logic; for example, the LTL plugin synthesizes state machines from LTL formulae. The output of logic plugins is usually pseudocode and not bound to any specific programming language. This way, the essential monitoring generation can be shared by different instances of MOP using different programming languages. The logic plugin manager bridges the communication between the language clients and the logic plugin. More specifically, it receives the monitor generation request from the language client and distributes the request to an appropriate plugin. After the plugin synthesizes the monitor for the request, the logic plugin manager collects the result and sends it back to the language client. This way, one can easily add new logic plugins into the repository to support new specification formalisms in MOP without changing the language client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Language client</head><p>The language client hides the programming languageindependent logic repository and provides language specific support for the different MOP instances. Because the language client is the language-specific portion of an MOP instance, we occasionally refer to the language client by the name of the MOP instance to which it belongs. Language clients are responsible for all language-specific aspects of monitoring, such as instrumentation, parametricity, online/inline/ outline, modifiers, etc. They are usually composed of three layers: the bottom layer contains language translators that translate the abstract output of logic plugins into concrete code in a specific programming language; the middle layer is the specification processor, which extracts formulae from the given property specification and then instruments the generated monitoring code into the target program; finally, the top layer provides usage interfaces to the user.</p><p>We next explain in some detail the Java language client for the JavaMOP instance (which by abuse of terminology we will simply call JavaMOP). JavaMOP generates AspectJ <ref type="bibr" target="#b41">[41]</ref> aspects from a specification. At the bottom layer, it has language translators for CFGs, the pseudocode output generated by the past time linear temporal logic with calls and returns plugin, and FSM descriptions. All plugins not mentioned use FSM descriptions as an output language. At the mid level, as mentioned, the Java client instruments the program with the generated monitor code by creating a stand-alone aspect that can be weaved into the program using any AspectJ compiler, such as ajc <ref type="bibr" target="#b6">[6]</ref>. At the top level, there is a command line interface and a web-based interface. The two current MOP instances are discussed in Sect. 3, and, respectively, Sect. 4 (JavaMOP) and Sect. 5 (BusMOP), and the discussions essentially apply to the language clients associated with each instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Logic plugins</head><p>Every logic plugin implements and encapsulates a monitor synthesis algorithm for a particular specification formalism, such as the past-time linear temporal logic (PTLTL) and the CFG plugins supported in the current MOP framework (see Sect. 6 for a complete list of available plugins). The logic plugin accepts, as input, a set of events and a formula or pattern written in the underlying formalism and outputs an abstract monitor. This abstract monitor is usually a piece of pseudocode, which checks a trace of events against the given formula.</p><p>We next explain in some detail one particular plugin, the plugin for FSM specifications. Figure <ref type="figure">5</ref> shows the monitoring code generated by the MOP FSM plugin from the FSM specification in Fig. <ref type="figure">2</ref>.</p><p>FSM monitors are simple, as one might expect. Static arrays keep the next state. There is one array for each event Fig. <ref type="figure">5</ref> Java code for the FSM in Fig. <ref type="figure">2</ref> in the specification, as can be seen in Fig. <ref type="figure">5</ref>. When an event arrives, the proper array is queried with the current state, and the next state is returned. After the state is updated, the category checks are preformed to see which handlers must run. Because the specification only checked @fail, we only have one check, which is for fail. As can be seen, fail is reached if the machine is in state 3. This code must be combined with generic code to handle the other properties of the specification, such as connectedness or full-binding, as well as the indexing system used for parametric trace slicing. The FSM plugin, as well as the others, is described in Sect. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MOP instances</head><p>As one may expect, when putting together various languages and specification formalisms, each with its own syntax and semantics, consistency and syntactic separation may become a non-trivial problem. In this section, we discuss the four dimensions that need to be instantiated in order to develop a new MOP instance (like JavaMOP or BusMOP), how they are instantiated, and where the boundary between the various components of an instance is. Since the semantics of the various pieces is typically implicit and not formally defined, in what follows we place emphasis on syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">MOP syntax</head><p>Every MOP instance needs to instantiate the MOP framework in four dimensions: (1) a specification language based on the problem domain, which is mainly related to how one defines events in the domain; (2) a target language for generated monitors; (3) supported logic plugin specification formalisms; and (4) the handlers allowed in the specification. Two MOP instances have been implemented and experimented with at this point: JavaMOP and BusMOP. We expect to see more MOP instances in the future because many problem domains can benefit from monitoring.</p><p>Each instance of MOP uses an instance of the generic MOP syntax. The syntax of any instance of MOP can be generated by defining certain syntactic categories (nonterminals) of the MOP grammar, which can be seen in Fig. <ref type="figure" target="#fig_3">6</ref>. All of the grammars used to define MOP syntax in this article use Extended Backus-Naur Form (EBNF) <ref type="bibr" target="#b39">[39]</ref>. Non-terminals in the grammars are surrounded by " " and " ". Braces ("{" and "}") enclose portions of the grammar that may appear zero or more times. Brackets ("[" and "]") enclose portions of the grammar that are optional (i.e., it may or may not appear). Concrete examples of the syntax defined below can be seen in Figs. <ref type="figure">2</ref> and<ref type="figure" target="#fig_1">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Shared syntax</head><p>The following syntax constructs are shared by different MOP instances:</p><p>-Specification : Specification describes the generic MOP specification syntax which can be instantiated for MOP language instances and MOP logic plugins. -Event : The Event declaration code allows for the definition of events, which may then be referred to in the property (see Property below). Event declarations can also have arbitrary code associated with them ( Instance Action ), which is run when the event is observed ( Instance Event Definition ), e.g. code to modify the program or the monitor state. For manual indication of events that can start a trace, the keyword creation is used at the beginning of each declaration.<ref type="foot" target="#foot_1">3</ref> -Property : Every MOP specification may contain zero or more properties. A Property consists of a named formalism ( Logic Name ), followed by a colon, followed by a property specification using the named formalism (see Logic Syntax below) and usually referring to the declared events. If the property is missing, then the MOP specification is called raw. Raw specifications are useful when no existing logic plugin is powerful or efficient enough to specify the desired property; in that case, one embeds the custom monitoring code manually within the Instance Action code. -Property Handler : Handlers contain arbitrary code from the instance source language, and are invoked when a certain logic state (see Logic State below) or category is reached, e.g., match, fail, or a particular state in a FSM description.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Instance-specific syntax</head><p>The following constructs are based on the particular instance of MOP used for a particular specification. More information on the instances of MOP can be found in the remainder of this section, and Sect. 4 (JavaMOP) and 5 (BusMOP).</p><p>-Instance Modifier : Instance Modifier s are specific to each language instance of MOP. Syntactically, they can be any valid identifier restricted by the given language. They change the behavior of the monitoring code. -Instance Parameters : Allow one to define the parameters of a parametric specification using the language corresponding to the MOP instance. Not all MOP instances are parametric (e.g., BusMOP), however, so this nonterminal may be empty. -Instance Declaration : Instance Declaration s are specific to each language instance of MOP. They allow for the declaration of monitor local variables. -Instance Event Definition : Instance Event Definition s are specific to each language instance of MOP. They define the conditions under which an event is triggered. -Instance Action : An event can have arbitrary code associated with it, called an action. The action is run when the event is observed. An action can modify the program or the monitor state, and the syntax of the allowed statements are dependent upon the MOP instance in question.</p><p>Typically, the statements used in actions have different variables and functions that may be referred to than handlers. This is why different non-terminals are used for actions and handlers. -Instance Handler : Instance Handler s are arbitrary code that is executed when a property handler is triggered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Logic-plugin-specific syntax</head><p>The following constructs are based on the logic plugin(s) used in a particular specification. More information on logic plugins can be found in Sect. 6.</p><p>-Logic Name : An identifier to indicate in which logic a property is defined. -Logic Syntax : This refers to the syntax of the actual property definition, and is defined in the syntax section for each plugin. -Logic State : Logic State s are constants defined for each plugin, stating for which monitor states or categories (match, fail, etc.) a handler may be written.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The JavaMOP instance</head><p>JavaMOP is an MOP development tool for Java, supporting several logical formalisms and a general specification language using them to describe Java program behaviors <ref type="bibr" target="#b21">[21]</ref>.</p><p>It compiles property specifications into optimized monitoring code. The generated code uses AspectJ <ref type="bibr" target="#b41">[41]</ref>, and is currently<ref type="foot" target="#foot_2">4</ref> program-independent. For example, a user can write a JavaMOP specification for a library. Then, JavaMOP generates monitoring code for this specification. This code can be applied to any program that uses the library. In JavaMOP, an event corresponds to a pointcut, which an AspectJ compiler (such as ajc <ref type="bibr" target="#b6">[6]</ref>) can use to weave monitoring code into the original program. Pointcuts include function call, function return, function begin, function end, field assignment, object creation, and more complex ones with pointcut operators, which combine multiple simpler pointcuts. JavaMOP generates monitoring code for each pointcut-corresponding to an event in a JavaMOP specification-to maintain monitoring state, to check if the program conforms to the specification, and to trigger a handler if appropriate.</p><p>A system behavior can be described using one of several logical formalisms supported by JavaMOP, including all those described in Sect. 6. A specification will be interpreted by the logic repository, a generic server used by all instances of MOP, and transformed into generic monitor code as mentioned in Sect. 2. JavaMOP translates the monitor pseudocode to AspectJ code. Any logic which can be translated to FSM (ERE, LTL, PTLTL) are reported to JavaMOP using the MOP FSM plugin syntax to reduce the number of translation algorithms necessary in JavaMOP (see Sect. 6.1).</p><p>A user can write a handler in Java for each monitoring state. There can be more monitoring states than simple match and fail, depending on logical formalism. A handler can be used for logging, recovering, blocking, or any other purpose. Since handlers are specified as arbitrary Java code, a user has quite a bit of latitude to achieve his or her purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">JavaMOP syntax</head><p>The syntax of JavaMOP is discussed below, as an instance of the generic MOP syntax defining the relevant modifiers and language-specific syntax (Java for declarations and event/hand-ler actions, enriched with AspectJ for event definitions). The formal syntax can be seen in Fig. <ref type="figure" target="#fig_4">7</ref>. Anything not explicitly described below can be considered to be identical to the generic MOP syntax. Note that some non-terminals such as Event refer to language instance specific non-terminals, which are defined below for JavaMOP.</p><p>-JavaMOP Modifier : The three binding modifiers refer to the different binding modes described in Sect. 4.4, the default is any-binding. The modifier "unsynchronized" tells JavaMOP that the monitor state needs not be protected against concurrent accesses; the default is synchronized. The unsynchronized monitor is faster, but may suffer from races on its state updates if the monitored program has multiple threads. The "decentralized" modifier refers to decentralized monitor indexing. The default indexing is centralized, meaning that the indexing trees needed to quickly access and garbage-collect monitor instances are stored in a common place; decentralized indexing means that the indexing trees are scattered all over the code as additional fields of objects of interest. Decentralized indexing typically yields lower runtime overhead, though it may not always work for all settings. More information on indexing can be found in Sect. 4.3.</p><p>The "perthread" modifier causes JavaMOP to consider events from each thread as though from separate runs of the program, (i.e., one parametric monitor for each thread monitors only events from its own thread). The "suffix" modifier causes JavaMOP to consider a trace as matching if any suffix of that trace would match. -JavaMOP Parameters and JavaMOP Declaration -These are ordinary Java parameters (as used in methods) and Java declarations. The former are the parameters of the JavaMOP specification and the latter are additional local monitor variables that one can access and modify in both event actions and property handlers. Each parameter from JavaMOP Parameters should be used in at least one event of the specification. -JavaMOP Action , JavaMOP Handler , and Java-MOP Event Definition : JavaMOP Action are normal Java statements that may also refer to monitor local variables. JavaMOP Handler , however, slightly extends Java with three special variables:</p><p>-__RESET: a special expression (evaluates to void) that resets the monitor to its initial state, but does not affect any user defined variables of the monitor; -__LOC: a string variable that evaluates to the line number generating the current event; -__MONITOR: a special variable that evaluates to the current monitor object, so that one can read/write monitor variables.</p><p>Similarly, the advice used to define JavaMOP events slightly extends the AspectJ advice syntax. The Java-MOP Event Definition follows the AspectJ syntax except for its extension with JavaMOP Pointcut , which can only be added in a top-level conjunct context. AspectJ Pointcut and AspectJ AdviceSpec are both standard AspectJ syntax <ref type="bibr" target="#b6">[6]</ref>. The additional pointcuts have the following meaning:</p><p>-"thread": The thread pointcut captures the current thread and takes an identifier as a parameter. The identifier can be a class name or a variable name. For the former, the type of the captured thread should be a sub-class of the given class to trigger the event. For the latter, the captured thread is bound to the variable. The thread pointcut allows for the easy specification of properties which are parameterized by the current thread of execution. -"condition": The condition pointcut takes a boolean expression as a parameter. An event containing a con- dition pointcut is not triggered if the boolean expression evaluates to false. This differs only from the if pointcut in standard AspectJ in that monitor instance variables may be used in the conditional expression. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The BusMOP instance</head><p>BusMOP <ref type="bibr" target="#b52">[52]</ref> was designed to address the safety problem of third party consumer off-the-shelf (COTS) components. The complexity of safety critical systems has grown to the point where the ability to use COTS in a safe manner is almost mandatory. In addition, the vast majority of OS crashes in PCs are caused by faulty peripherals or their drivers. BusMOP answers both of these problems by allowing the specification and monitoring of properties with respect to PCI Bus traffic (soon to be expanded to other bus architectures).</p><p>In BusMOP, the events correspond to reads and writes of specified values to specified memory locations on the bus. PCI Bus interrupts are also allowed as events. The monitors, and the logic to extract events from bus traffic, are synthesized from hardware design language (HDL) code and programmed onto a field programmable gate array (FPGA), which is plugged into the PCI Bus.</p><p>BusMOP supports the FSM, ERE, LTL, and PTLTL plugins of MOP (see Sect. 6). PTCaRet and CFG have the problem of unbounded logic response time, which would cause the monitor to not meet timing constraints in some cases, and are thus not suitable for inclusion in BusMOP. It is also not clear exactly where the structured capabilities of these logics are useful when considering flat bus traffic traces.</p><p>Handlers in BusMOP can be specified using arbitrary VHDL code. Several resources are provided for the user for use in handler code, such as serial output for logging, and the actual ability to write to the PCI Bus to perform recovery. Recovery actions in BusMOP require bus arbitration to undo deleterious actions of faulty peripherals or their drivers. This bus arbitration is the only possible overhead incurred by BusMOP, in cases of heavy Bus traffic. In the majority of systems, BusMOP can be used with no runtime overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">BusMOP syntax</head><p>Below we discuss the BusMOP syntax. Anything not explicitly described below can be considered to be identical to the generic MOP syntax. Note that some non-terminals such as Event refer to language instance specific non-terminals, which are defined below for BusMOP. The grammar for the syntax can be seen in Fig. <ref type="figure" target="#fig_5">8</ref>.</p><p>-BusMOP Modifier : Modifiers in BusMOP are used to distinguish the bus architecture to be monitored. Currently, only standard parallel PCI is supported. PCI-E will be supported using a bridge adapter that will sit between the PCI Express bus slot and the peripheral to monitor. -BusMOP Parameters and BusMOP Declaration :</p><p>BusMOP is not parametric because there is no clear unit of parametrization. BusMOP Declaration 's are standard VHDL signal declarations. These are used to define additional local monitor variables that one can access and modify in both event actions and property handlers. -BusMOP Event Definition : BusMOP event definitions use an original syntax to define interesting potential bus traffic. At the basic level there are three types of events: memory, IO, and interrupt. The last event is triggered when there is an interrupt on the bus. The first two are further subdivided into reads and writes. The difference between memory and IO is the address space of the read 123 Fig. <ref type="figure" target="#fig_5">8</ref> BusMOP syntax or write in question. This is important for correctly specifying the necessary bus enable signals in the generated code. Reads and writes can be concerned with the read or write of a specific location with a select range of values, or a read or write to a range of locations where the value is of no concern. Specifying a range of read or write addresses is valuable for enforcing memory safety policies (such as, if the value 0xdeadbeef is written to address 0xffff0000 then allow no writes to some buffer until 0x000000 is written to 0xffff0000). Arithmetic Op allows for arithmetic operations combining variables and literal numbers. This is useful both for specifying monitor local variables and monitor input variables. Placing a numerical index on the keyword "value" indicates that one bit, specified by the index, should be checked rather than the whole value read or written. The monitor input variables hold the values of inputs to the monitor, and are as follows:</p><p>-The value register holds the value of the read or write in question. -The address register holds the address of the read or write in question. -The baseN registers allow a user to specify a memory value relative to a given peripheral. Without this support monitoring would be very difficult due to the plug-and-play PCI bus interface that assigns memory spaces to peripherals at boot time.</p><p>-BusMOP Action : Actions are arbitrary VHDL statements that may refer to monitor local variables as well as the input variables described above in BusMOP Event Definition . As mentioned in Instance Action , these statements are executed when the event for which they are defined is observed.</p><p>-BusMOP Handler : Handlers are arbitrary VHDL statements that may refer to monitor local variables as well as the input variables described above in BusMOP Event Definition . In addition, there are variables the may be set in order to perform recovery actions. They are as follows:</p><p>-The io_reg is used to specify a read or write to I/O space. It is asserted as '1' to select the I/O space. -The mem_reg is used to specify a read or write to memory space by asserting it as '1'. -The address_reg is used to specify the 32 bit address of a read or write. -The value_reg is used to specify the value of a 32 bit read or write. -The enable_reg is used to specify the byte enables for a read or write (specific to PCI, see Sect. 5). -The serial_reg allows output of an ASCII value to a serial port for debugging. -Thestop_reg register that stops the peripheral in question from reading from or writing to the PCI bus when it is asserted as '1'.</p><p>As mentioned in Instance Handler these statements are executed when a property handler is triggered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">JavaMOP</head><p>Each instance of MOP has issues specific to its domain. Java-MOP must deal with the complexities of parametric monitoring, in order to make itself useful in highly object-oriented systems. We first provide an introduction to parametric trace slicing (Sect. 4.1). We next cover improving the efficiency of parametric monitoring (4.2). Lastly, we discuss different modes of parameter binding, which define which parameter instance monitors trigger handlers (Sect. 4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Parametric trace slicing and naive monitoring</head><p>Parametric specifications are widely used in practice, particularly in object oriented languages, like Java, where we need to describe properties over a group of objects. For example, consider again the property in Fig. <ref type="figure">2</ref> from Sect. 1. Here the events are parametrized by the Vector v and the Enumeration e. This is because we do not want uses of an Enumeration e 1 to be flagged as an error because of an intervening modification to Vector v 2 , when it has Vector v 1 as its underlying Vector.</p><p>When monitoring a parametric specification, the observed execution trace is parametric, i.e., the events in the trace come with parameter information. For example, a possible parametric trace for the specification in Fig. <ref type="figure">2</ref> </p><formula xml:id="formula_0">is: updateV v ‚Üí v 1 createE v ‚Üí v 1 , e ‚Üí e 1 createE v ‚Üí v 1 , e ‚Üí e 2 createE v ‚Üí v 2 , e ‚Üí e 3 useE e ‚Üí e 3 useE e ‚Üí e 1 updateV v ‚Üí v 1 useE e ‚Üí e 1 useE e ‚Üí e 2 .</formula><p>Every event in this trace is associated with a concrete parameter binding, such as v ‚Üí v 1 , e ‚Üí e 2 that indicates that the parameters v and e in Fig. <ref type="figure">2</ref> are bound to concrete objects v 1 and e 2 , respectively. Such a parametric trace represents a set of non-parametric traces each of which corresponds to a particular parameter binding. For example, the above trace contains 11 non-parametric traces for 11 parameter bindings (one for each of five singleton objects, and one for each element in the cross product of the singleton objects). The non-parametric traces for four of these bindings are summarized in the table below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parameter binding Non-parametric trace slice</head><formula xml:id="formula_1">v ‚Üí v 1 updateV updateV v ‚Üí v 1 , e ‚Üí e 1 updateV createE useE updateV useE v ‚Üí v 1 , e ‚Üí e 2 updateV createE updateV useE v ‚Üí v 2 , e ‚Üí e 3 createE useE</formula><p>The second and third of these fail to match the pattern in Fig. <ref type="figure">2</ref>, thus two failures are produced. It is highly non-trivial to monitor parametric specifications efficiently since there can be a tremendous number of parameter bindings during a single execution. For example, in a few experiments that we carried out, millions of parameter bindings were created <ref type="bibr" target="#b22">[22]</ref>. Most other approaches for monitoring parametric specifications handle parameters in a logic-specific way <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b46">46]</ref>, i.e., they extended the underlying specification formalisms with parameters and devised algorithms for the extended formalism. Such a solution results in very complicated monitor synthesis algorithms and makes it difficult to support new problem domains. In MOP, parameters are handled in a completely logical formalism independent manner and separated from the monitor synthesis process, vastly simplifying the implementation of new logic plugins. Surprisingly, this logic independent consideration of parameters turns out to be more efficient than those closely coupled systems (see Sect. 4.5) thanks to the clean separation of concerns. In the following sections, we will explain parametric monitoring in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Events, traces, properties, and parameters</head><p>First, we introduce the notions of event, trace and property, first non-parametric and then parametric. Trace slicing is then defined as a reduct operation that forgets the events that are unrelated to the given parameter instance. Most of this discussion is derived from <ref type="bibr" target="#b23">[23]</ref>.</p><p>Definition 1 Let E be a set of (non-parametric) events, called base events or simply events. An E-trace, or simply a (nonparametric) trace when E is understood or not important, is any finite sequence of events in E, that is, an element in E * . If event e ‚àà E appears in trace w ‚àà E * then we write e ‚àà w.</p><p>Example Consider again the SafeEnum policy from Fig. <ref type="figure">2</ref>. E = {createE, updateV, useE} and execution traces corresponding to this are sequences of the form createE useE up- dateV createE useE, etc. For now we ignore the distinction between "good" and "bad" execution traces.</p><p>Definition 2 An E-property P, or simply a (base or nonparametric) property, is a function P : E * ‚Üí C partitioning the set of traces into categories C. It is common, but not enforced, that C includes "match", "fail", and "don't know" (or "?") categories. In general, C, may be any set and is referred to as the set of verdict categories when it eases readability.</p><p>Example Consider again Fig. <ref type="figure">2</ref>. The FSM has no match category as we did not define it. The fail category is reached by "falling off the machine", i.e., receiving an event in a state for which there is no transition. For example, the trace createE updateV useE would result in the fail category.</p><p>We next extend the above definitions to the parametric case, i.e., traces containing events that carry concrete data instantiating abstract parameters.</p><p>Example Event useE is parametric in the Enumeration; if e is the name of the generic Enumeration parameter and e 1 and e 2 are concrete Enumerations, then parametric useE events have the form useE e ‚Üí e 1 , useE e ‚Üí e 2 , etc.</p><p>In what follows, let [A ‚Üí B] be the set of total functions and [A B] be the set of partial functions, both from A to B. Definition 3 (Parametric events and traces) Let X be a set of parameters and let V be a set of corresponding parameter values. If E is a set of base events like in Definition 1, then 123 let E X be the set of corresponding parametric events e Œ∏ , where e is a base event in E and Œ∏ is a partial function in [X V ]. A parametric trace is a trace with events in E X , that is, a word in E X * .</p><p>To simplify writing, we occasionally assume the parameter values set V implicit.</p><p>Example A parametric trace for our property in Fig. <ref type="figure">2</ref> can be:</p><formula xml:id="formula_2">updateV v ‚Üí v 1 createE v ‚Üí v 1 , e ‚Üí e 1 createE v ‚Üí v 1 , e ‚Üí e 2 createE v ‚Üí v 2 , e ‚Üí e 3 useE e ‚Üí e 3 useE e ‚Üí e 1 updateV v ‚Üí v 1 useE e ‚Üí e 1 useE e ‚Üí e 2 .</formula><p>We take the freedom to only list the parameter values when writing parameter instances, that is,</p><formula xml:id="formula_3">v 1 instead of v ‚Üí v 1 .</formula><p>With this notation, the above trace is:</p><formula xml:id="formula_4">updateV v 1 createE v 1 , e 1 createE v 1 , e 2 createE v 2 , e 3 useE e 3 useE e 1 updateV v 1 useE e 1 useE e 2 .</formula><p>As mentioned earlier, this trace induces eleven trace slices. The slice corresponding to v 1 , e 1 is updateV createE useE updateV useE.</p><formula xml:id="formula_5">Definition 4 Partial functions Œ∏ in [X V ] are called param- eter instances. Œ∏, Œ∏ ‚àà [A B] are compatible if for any x ‚àà Dom(Œ∏ ) ‚à© Dom(Œ∏ ), Œ∏ (x) = Œ∏ (x).</formula><p>We can combine compatible instances Œ∏ and Œ∏ , written Œ∏ Œ∏ , as follows:</p><formula xml:id="formula_6">(Œ∏ Œ∏ )(x) = ‚éß ‚é® ‚é© Œ∏(x) when Œ∏(x) is defined Œ∏ (x)</formula><p>when Œ∏ (x) is defined undefined otherwise Œ∏ Œ∏ is also called the least upper bound (lub) of Œ∏ and Œ∏ . Œ∏ is less informative than Œ∏ , or Œ∏ is more informative than Œ∏ , written Œ∏ Œ∏ , if for any x ‚àà X , if Œ∏(x) is defined then Œ∏ (x) is also defined and Œ∏(x) = Œ∏ (x).</p><p>Definition 5 (Trace slicing) Given parametric trace œÑ ‚àà E X * and Œ∏ in [X V ], let the Œ∏ -trace slice œÑ Œ∏ ‚àà E * be the non-parametric trace defined as:</p><p>Œ∏ = , where is the empty trace/word, and -(œÑ e Œ∏ ) Œ∏ = (œÑ Œ∏ ) e when Œ∏ Œ∏ œÑ Œ∏ when Œ∏ Œ∏</p><p>The trace slice œÑ Œ∏ first filters out all the parametric events that are not relevant for the instance Œ∏ , i.e., which contain instances of parameters that Œ∏ does not care about, and then, for the remaining events relevant to Œ∏ , it forgets the parameters so that the trace can be checked against base, non-parametric properties. It is crucial to discard events for parameter instances that are not relevant to Œ∏ during the slicing, including those more informative than Œ∏ , in order to achieve a "proper" slice for Œ∏ : in our running example, the trace slice for v 1 should contain only updateV events and no createE or useE events. Definition 6 Let X be a set of parameters together with their corresponding parameter values V , like in Definition 3, and let P : E * ‚Üí C be a non-parametric property like in Definition 2. Then, we define the parametric property X.P as the property (over traces E X * and categories</p><formula xml:id="formula_7">[[X V ] ‚Üí C]) X.P : E X * ‚Üí [[X V ] ‚Üí C] defined as ( X.P)(œÑ )(Œ∏ ) = P(œÑ Œ∏ ) for any œÑ ‚àà E X * and any Œ∏ ‚àà [X V ]. If X = {x 1 , . . . ,</formula><p>x n } we may write x 1 , . . . , x n .P instead of ( {x 1 , . . . , x n }.)P. Also, if P œï is defined using a pattern or formula œï in some particular trace specification formalism, we take the liberty to write X.œï instead of X.P œï .</p><p>A parametric property is, therefore, similar to a normal property, except that the domain is parametric traces, and the output, rather than being one category, is a mapping of parameter instances to categories. This allows the parametric property to associate an output category for each parameter instance from [X V ].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Monitors and parametric monitors</head><p>Here we define monitors M and parametric monitors X.M. Like for parametric properties, which are just properties over parametric traces, parametric monitors are also just monitors, but for parametric events and with instance-indexed states and output categories: a parametric monitor X.M is a monitor for the parametric property X.P, with P the property monitored by M <ref type="bibr" target="#b23">[23]</ref>.</p><p>Monitors are defined as a variant of Moore machines:</p><formula xml:id="formula_8">Definition 7 A monitor M is a tuple (S, E, C, ƒ±, œÉ : S √óE ‚Üí S, Œ≥ : S ‚Üí C),</formula><p>where S is the set of states, E is the set of input events, C is the set of output categories, ƒ± ‚àà S is the initial state, œÉ is the transition function, and Œ≥ is the output function. The transition function is extended to handle traces of events (i.e., œÉ : S √ó E * ‚Üí S) the standard way.</p><p>The notion of a monitor above is often impractical. Actual implementations of monitors need not generate all the state space a priori, but rather on an "as needed" basis. Allowing monitors with infinitely many states is a necessity in our context. Even though only a finite number of states is reached during any given (finite) execution trace, there is, in general, no bound on how many may be reached. For example, monitors for CFGs have potentially unbounded stacks as part of their state. Also, as shown shortly, parametric monitors have domains of functions as state spaces, which are infinite as well. We next define parametric monitors in the same style as the other parametric entities defined in this paper: starting with a base monitor and a set of parameters, the corresponding parametric monitor can be thought of as a set of base monitors running in parallel, one for each parameter instance. Definition 9 Given parameters X with corresponding values V and monitor M = (S, E, C, ƒ±, œÉ : S√óE ‚Üí S, Œ≥ : S ‚Üí C), the parametric monitor X.M is the monitor</p><formula xml:id="formula_9">([[X V ] ‚Üí S], E X , [[X V ]‚Üí C], ŒªŒ∏.ƒ±, X.œÉ, X.Œ≥ ), with X.œÉ : [[X V ] ‚Üí S] √ó E X ‚Üí [[X V ] ‚Üí S] and X.Œ≥ : [[X V ] ‚Üí S] ‚Üí [[X V ] ‚ÜíC] defined as ( X.œÉ )(Œ¥, e Œ∏ )(Œ∏ ) = œÉ (Œ¥(Œ∏), e) if Œ∏ Œ∏ Œ¥(Œ∏) if Œ∏ Œ∏ ( X.Œ≥ )(Œ¥)(Œ∏ ) = Œ≥ (Œ¥(Œ∏)) for any Œ¥ ‚àà [[X V ]‚Üí S] and any Œ∏, Œ∏ ‚àà [X V ].</formula><p>Therefore, a state Œ¥ of parametric monitor X.M maintains a state Œ¥(Œ∏) of M for each parameter instance Œ∏ , takes parametric events as input, and outputs categories indexed by parameter instances (one category of M per instance). Intuitively, one can think of a parametric monitor as a collection of "monitor instances". Each monitor instance, which is indexed by a parameter instance, keeps track of the state of one trace slice. The rule for X.œÉ can be read as stating that when an event with parameter instance Œ∏ is evaluated, it updates the state for all monitor instances more informative than the instance for Œ∏ , and the instance for Œ∏ itself, leaving all other monitor instances untouched. The rule for X.Œ≥ simply states that Œ≥ is applied to a state, as normal, but the state is found by looking up the state of the monitor instance for Œ∏ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Naive parametric monitoring</head><p>Intuitively, the necessary steps for online monitoring of parametric properties are as follows:</p><p>1. Begin with a monitor instance for the empty parameter instance ‚ä• initialized to the start state of the monitor, ƒ±. 2. As each event, e Œ∏ , arrives there are two possibilities:</p><p>-There is already a monitor instance for Œ∏ , in this case the instance is simply updated with e. -There is not already a monitor instance for Œ∏ , in this case an instance is created for Œ∏ . It is initialized to the state of the most informative Œ∏ less informative than Œ∏ . Such a Œ∏ ' is guaranteed to exist because we begin with a monitor instance for ‚ä•, which is less informative than all other possible Œ∏ 's. We also create monitor instances for every parameter instance that may be created by combining Œ∏ with previously seen parameter instances. Each of these created instances is initialized similarly to the instance for Œ∏ , using the most informative instance less than itself. All created monitor instances are updated with e after initialization.</p><p>3. e is then used to update the monitor instances for all Œ∏ that are strictly more informative than Œ∏ .</p><p>We next present a more concrete monitoring algorithm for parametric properties first introduced in <ref type="bibr" target="#b23">[23]</ref>. It is derived from the algorithm A X , which is omitted here, that was also first presented in <ref type="bibr" target="#b23">[23]</ref>. A first challenge here is how to represent the states of the parametric monitor. We encode the functions [[X V ] S] as tables with entries indexed by parameter instances in [X V ] and with contents states in S. Such tables will have finite entries since each event binds only a finite number of parameters. Figure <ref type="figure" target="#fig_6">9</ref> shows our monitoring algorithm for parametric properties. Given parametric property X.P and M a monitor for P, B X (M) yields a monitor that is equivalent to X.M, i.e., a monitor for X.P.</p><p>B X first assigns ƒ±, the initial state, to (‚ä•) ( is a mapping from parameter instance to monitor state). , which contains all known parameter instances is initialized to contain {‚ä•}, as ‚ä• is always known. For each event e Œ∏ that arrives during program execution (line 2), B X generates every compatible parameter instance by combining {Œ∏ } with all the previously known parameter instances. It then updates the state of every one of these compatible parameter instances (Œ∏ ) on line 4 with the state, transitioned by event e, of the "monitor instance" corresponding to the "largest" parameter instance less than or equal to Œ∏ . At the same time we also calculate the output corresponding to that monitor instance and store it in table . Rather than storing a whole slice as in Definition 5, the knowledge of the slice is encoded in the state of the monitor instance for Œ∏ . After the algorithm completes contains the category for each possible trace slice. An actual implementation is free to report a category (e.g., match) as soon as it is discovered. In fact, in JavaMOP, it is necessary to report a category as soon as it occurs so that recovery actions can be performed, and also because the category of a trace may change several times throughout its lifetime, while B X only gives the final result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Efficient parametric monitoring</head><p>Algorithm B X is correct, and easy to understand, but it is not very efficient. It creates many more monitor instances than are actually required to correctly monitor a given property. An algorithm designed for runtime monitoring should receive a trace one event at a time, rather than all at once as B X . Next we show an algorithm that receives a trace one event as a time. We also discuss optimizations to the algorithm that vastly improve efficiency <ref type="bibr" target="#b20">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Algorithm C X</head><p>Figure <ref type="figure" target="#fig_0">10</ref> shows the algorithm C X<ref type="foot" target="#foot_3">5</ref> for online monitoring of parametric property X.P, given that M is a monitor for P. The algorithm shows which actions to perform, e.g., creating a new monitor state and/or updating the state of related monitors, when an event is received. Algorithm C X refines Algorithm B X in Fig. <ref type="figure" target="#fig_6">9</ref> for efficient online monitoring. C X essentially expands the body of the outer loop in B X (lines 3 to 7 in Fig. <ref type="figure" target="#fig_6">9</ref>). The direct use of B X would yield prohibitive runtime overhead when monitoring large traces, because its inner loop requires searching for all parameter instances in that are compatible with Œ∏ ; this search can be very expensive. C X introduces an auxiliary data structure and illustrates a mechanical way to accomplish the search, which also facilitates further optimizations.</p><p>Algorithm C X also extends algorithm B X to support creation events. Recall from Sect. 3.1 that users may specifically choose creation events using the keyword creation. Supporting creation events in algorithm C X is justified and motivated by experience with implementing and evaluating B X in <ref type="bibr" target="#b23">[23]</ref>, mainly by the following observation: one often chooses to start monitoring at the witness of a specific set of events (versus the beginning of the program).</p><p>Two mappings are used in C X : and U. stores the monitor states for parameter instances, and U maps a parameter instance Œ∏ to all the parameter instances that have been defined and are properly more informative than Œ∏ . In what follows, "to create a parameter instance Œ∏ " and "to create a Fig. <ref type="figure" target="#fig_0">10</ref> Monitoring algorithm C X monitor state for parameter instance Œ∏ " have the same meaning: to define (Œ∏ ). We next use an example about the interaction between the classes Map, Collection and Iterator in Java (Fig. <ref type="figure" target="#fig_7">11</ref>), as this provides a better demonstration of the power of C X than does the pattern in Fig. <ref type="figure">2</ref>. This also provides us an opportunity to show how parametric trace slicing is truly generic with respect to the logical formalism by using ERE in place of FSM. Map and Collection implement data structures for mappings and collections, respectively. Iterator is an interface used to enumerate elements in a collection-typed object. One can also enumerate elements in a Map object using Iterator. But, since a Map object contains key-value pairs, one needs to first obtain a collection object that represents the contents of the map, e.g., the set of keys or the set of values stored in the map, and then create an iterator from the obtained collection. An intricate safety property in this usage, according to the Java API specification, is that when the iterator is used to enumerate elements in the map, the contents of the map should not be changed, or unexpected behaviors may occur. The parametric LTL formula in Fig. <ref type="figure" target="#fig_7">11</ref> specifies the incorrect behavior of the system. In Fig. <ref type="figure" target="#fig_7">11</ref>, createC is an event corresponding to creating a collection from a map, createI corresponds to creating an iterator from a collection, updateM corresponds to updating the map, and useI corresponds to using the iterator. The pattern says that a Collection is created from a Map, an Iterator is created from the Collection, the Map is updated at least once ( + means one or more times), and then the Iterator is used after the update. The extra updateM m * and useI c, i * define places where these events are still valid. When an observed execution matches this pattern, the UnsafeMapIterator property is broken.</p><p>In Fig. <ref type="figure" target="#fig_0">12</ref>, we show the contents of and U after every event (given in the first row of the table) is processed. The observed trace is updateM</p><formula xml:id="formula_10">m 1 createC m 1 , c 1 createC m 2 , c 2 createI c 1 , i 1 .</formula><p>We assume that createC is the only creation event. The first event, updateM m 1 , is not a creation event and nothing is added to and U. The second event, createC m 1 , c 1 , is a creation event. So a new monitor state is defined in for m 1 , c 1 , which is also added to the lists in U for ‚ä•, m 1 and c 1 . Note that ‚ä• is less informative than any other parameter instances. The third event createC m 2 , c 2 is another creation event, incompatible with the second event. Hence, only one new monitor state is added to . U is updated similarly. The last event createI c 1 , i 1 is not a creation event. So no monitor instance is created for c 1 , i 1 . It is compatible with the existing parameter instance m 1 , c 1 (found from the list for c 1 in U) introduced by the second event but not compatible with m 2 , c 2 due to the conflict binding on c. Therefore, a new monitor instance is created for the combined parameter instance m 1 , c 1 , i 1 using the state for m 1 , c 1 in . U is also updated to add the new instance into lists of parameter instances that are less informative.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Enable set optimization</head><p>While C X is an improvement over B X , it is possible to improve C X by making assumptions on the given monitor M. In other words, one may monitor properties written in any specification formalism, e.g., ERE, CFG, PTLTL etc., as long as one also provides a monitor generation algorithm for said formalism. However, this generality leads to extra monitoring overhead in some cases. It is possible to optimize monitor creation using the concept of enable sets <ref type="bibr" target="#b20">[20]</ref>. Algorithms for computing enable sets can be found in Sects. 6.1 and 6.5.</p><p>To motivate the optimization, let us continue the run in Fig. <ref type="figure" target="#fig_0">12</ref> to process one more event, useI i 1 . The result is shown in Fig. <ref type="figure" target="#fig_8">13</ref>. useI i 1 is not a creation event and no monitor instance is created for i</p><formula xml:id="formula_11">1 . Since i 1 is compatible with m 2 , c 2 , a new monitor instance is defined for m 2 , c 2 , i 1 . The monitor instance for m 1 , c 1 , i 1 is then updated accord- ing to useI because i 1 is less informative than m 1 , c 1 , i 1 .</formula><p>U is also updated to add m 2 , c 2 , i 1 to the lists for all the parameter instances less informative than m 2 , c 2 , i 1 . New entries are added into U during the update since some of the less informative parameter instances, e.g., m 2 , i 1 , have not been used before this event.</p><p>Creating the monitor instance for m 2 , c 2 , i 1 is needed for the correctness of C X , but it can be avoided when more information about the program or the specification is available. For example, according to the semantics of Iterator, no event createI c 2 , i 1 will occur in the subsequent execution since an iterator can be associated to only one collection. Hence, the monitor for m 2 , c 2 , i 1 will never reach the validation state and we do not need to create it from Fig. <ref type="bibr" target="#b12">12</ref> Sample run of C X . The first row gives the received events; the second and the third rows give the content of and U, respectively, after every event is processed. Monitor states are represented symbolically in the table, e.g., œÉ (ƒ±, createC) represents the state after the event createC the beginning. However, such semantic information about the program is very difficult to infer automatically. Below, we show a simpler yet effective solution to avoid unnecessary monitor creations by analyzing the specification to monitor.</p><p>When monitoring a program against a specific property, usually only a certain subset of property categories, (C in Definition 2), is checked. For example, in the UnsafeMapI- terator property in Fig. <ref type="figure" target="#fig_7">11</ref>, the regular expression specifies a defective interaction among related Map, Collection and Iterator objects. To find an error in the program using monitoring is thus to detect matches of the specified pattern during the execution. In other words, we are only interested in the validation category of the specified pattern. Obviously, to match the pattern, for a parameter instance of parameter set {m, c, i}, createC and createI should be observed before useI is encountered for the first time in monitoring. Otherwise, the trace slice for {m, c, i} will never match the pattern. Based on this information, we next show that creating the monitor state for m 2 , c 2 , i 1 in Fig. <ref type="figure" target="#fig_8">13</ref> is not needed. When event useI i 1 is encountered, if the monitor state for a parameter instance m 2 , c 2 exists without the monitor state for m 2 , c 2 , i 1 , like in Fig. <ref type="figure" target="#fig_8">13</ref>, it can be inferred that in the trace slice for m 2 , c 2 , i 1 , only events createC and/or updateM occur before useI because, otherwise, if createI also occurred before useI, the monitor state for m 2 , c 2 , i 1 should have been created. Therefore, we can infer, when event useI i 1 is observed and before the execution continues, that no match of the specified pattern can be reached by the trace slice for m 2 , c 2 , i 1 , that is to say, the monitor for m 2 , c 2 , i 1 will never reach the validation state.</p><p>This observation shows that the knowledge about the specified property can be applied to avoid unnecessary creation of monitor instances. In this way, the sizes of and U can be reduced, reducing the monitoring overhead. We next formalize the information needed for the optimization and argue that it is not specific to the underlying specification formalism. How this information is used is discussed in Sect. 4.2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10</head><p>Given w ‚àà E * and e, e ‚àà w, we denote that e occurs before an occurrence of e in w as e w e. Let the trace enable set of e ‚àà E be the function enable w : E ‚Üí P f (E), defined as: enable w (e) = {e | e w e}.</p><p>Note that if e ‚àà w then enable w (e) = ‚àÖ. The trace enable set can be used to examine whether the execution under observation may generate a particular trace of interest, or not: if event e is encountered during monitoring but some event e ‚àà enable w (e) has not been observed, then the (incomplete) execution being monitored will not produce the trace w when it finishes. This observation can be extended to check, before an execution finishes, whether the execution can generate a trace belonging to some designated property  Intuitively, if event e is encountered during monitoring but none of event sets enable E G (e) has been completely observed, the (incomplete) execution being monitoring will not produce a trace w s.t. P(w) ‚àà G. For example, given the regular expression specifying the UnsafeMapIterator property in Fig. <ref type="figure" target="#fig_7">11</ref>, where G contains only the match, fail, and ? categories, the second column in Fig. <ref type="figure" target="#fig_9">14</ref> shows the property enable sets of events in UnsafeMapIterator.</p><p>The property enable set provides a sound and fast way to decide whether an incomplete trace slice has the possibility of reaching the desired categories by looking at the events that have already occurred. In the above example, if a trace slice starts with createC useI, it will never reach the match category, because {createC} ‚àà enable E G (useI). In such case, no monitor state need be created even when the newly observed event may lead to new parameter instances. For example, suppose that the observed (incomplete) trace is createC useI from before. At the second event, useI, a new parameter instance can be constructed, namely, m 1 , c 1 , i 1 , and a monitor state s will be created for m 1 , c 1 , i 1 if algorithm C X is applied. However, since the trace slice for s is createC useI, we immediately know that s cannot reach state match. So there is no need to create and maintain s during monitoring if match is the goal. A direct application of the above idea to optimize C X requires maintaining observed events for every created monitor and comparing event sets when a new parameter instance is found, reducing the performance. Therefore, we adapt the notion of the enable set to be based on the parameter sets instead of event sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 12</head><p>Given a property P : E * ‚Üí C, a set of categories G ‚äÜ C as the goal, a set of parameters X and a function D E : E ‚Üí P f (X ) mapping an event to its parameters, the property parameter enable set of event e ‚àà E is defined as a function enable X G :</p><formula xml:id="formula_12">E ‚Üí P f (P f (X )) as follows: enable X G (e) = {‚à™{D E (e ) | e ‚àà enable w (e)} | P(w) ‚àà G}.</formula><p>From now on, we use "enable set" to refer to "property parameter enable set" for simplicity. For example, given the regular pattern for the UnsafeMapIterator property in Fig. <ref type="figure" target="#fig_7">11</ref> and G = {match}; the third column in Fig. <ref type="figure" target="#fig_9">14</ref> shows the parameter enable sets of events in UnsafeMapIterator. Then, given again the trace createC m 1 , c 1 useI i 1 , no monitor state need be created at the second event for m 1 , c 1 , i 1 since the parameter instance used to initialize the new monitor state, namely, m 1 , c 1 , is not in enable X G (useI). In other words, one may simply compare the parameter instance used to initialize the new parameter instance with the enable set of the observed event to decide whether a new monitor state is needed or not. Note that in JavaMOP, the property parameter enable sets are generated from the property enable sets provided by the formalism plugin. This allows the plugins to remain totally parameter agnostic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Algorithm D X</head><p>We next integrate the concept of enable sets with algorithm C X , to improve performance and memory usage <ref type="bibr" target="#b20">[20]</ref>.</p><p>Given a set of desired verdict categories G, we are guaranteed that we can optimize the monitoring process by omitting creating monitor states for certain parameter instances when an event is received using the enable set without missing any trace belonging to G. However, skipping the creation of monitor states may result in false alarms, i.e., a trace that is not in G can be reported to belong to G. Let us consider the following example. We monitor to find matching of a regular pattern e 1 e 3 . Relevant events and their parameters are e 1 ( p), e 2 (q), e 3 ( p, q). The observed trace is e 1 p 1 e 2 q e 3 p 1 , q 1 . Also, suppose e 1 is the only creation event. Obviously, the trace does not match the pattern. Figure <ref type="figure" target="#fig_0">15</ref> shows the run using the enable set optimization (i.e., not creating monitor states for parameter instances disallowed by the enable sets). Only the content of is given for simplicity. At e 1 , a monitor state is created for p 1 since it is the creation event. At e 2 , no action is taken since enable X G (e 2 ) = ‚àÖ. At e 3 , a monitor state will be created for p 1 , q 1 using the monitor state for p ‚Üí p 1 since enable X G e 3 = {p}. This way, e 2 is forgotten and a match of the pattern is reported incorrectly.</p><p>To avoid unsoundness, we introduce the notion of disable stamps of events. disable : [[X V ] integer] maps a parameter instance to an integer timestamp. disable(Œ∏ ) gives the time when the last event with Œ∏ was received. We maintain timestamps for monitors using a mapping T : [[X V ] integer]. T maps a parameter instance for which a monitor state is defined to the time when the original monitor state is created from a creation event. Specifically, if a monitor state for Œ∏ is created using the initial state when a creation event is received (i.e., using the defineNew function in algorithm C X ), T (Œ∏ ) is set to the time of creation; if a monitor state for Œ∏ is created from the monitor state for Œ∏ , T (Œ∏ ) is passed to T (Œ∏ ). Figure <ref type="figure" target="#fig_3">16</ref> shows the evolution of disable and T while processing the trace in Fig. <ref type="figure" target="#fig_0">15</ref>.</p><p>disable and T can be used together to track "skipped events": when a monitor state for Œ∏ is created using the monitor state for Œ∏ , if there exists some Œ∏ Œ∏ s.t. Œ∏ Œ∏ and disable(Œ∏ ) &gt; T (Œ∏ ) then the trace slice for Œ∏ does not belong to the desired verdict categories G. Intuitively, disable(Œ∏ ) &gt; T (Œ∏ ) implies that an event e Œ∏ has been encountered after the monitor state for Œ∏ was created. But Œ∏ was not taken into account (Œ∏ Œ∏ ). The only possibility is that e is omitted due to the enable set and thus the trace slice for Œ∏ does not belong to G according to the definition of the enable set. Therefore, in Fig. <ref type="figure" target="#fig_3">16</ref>, no monitor instance is created for p 1 , q 1 at e 3 because disable( q 1 ) &gt; T ( p 1 ).</p><p>The above discussion applies when the skipped event occurs after the initial creation of the monitor state. The other case, i.e., an event is omitted before the initial monitor state is created, can also be handled using timestamps. If the skipped event is not a creation event, it does not affect the soundness of the algorithm because of the definition of creation events. In the above example, if the observed trace is e 2 q 1 e 1 p 1 e 3 p 1 , q 1 , we will ignore e 2 and report the matching at e 3 since e 1 is the only creation event. It is more sophisticated (but not much different) when the skipped event is a creation event.</p><p>Based on the above discussion, we develop a new parametric monitoring algorithm that optimizes algorithm C X using the enable set and timestamps, as shown in Fig. <ref type="figure" target="#fig_11">17</ref>. This algorithm makes use of the mappings discussed above, namely, enable X G , , U, disable, and T , and maintains an integer variable to track the timestamp. Similar to algorithm C X , when event e Œ∏ is received, D X first checks whether (Œ∏ ) is defined or not (line 1 in main). If not, monitor states may be generated for new encountered parameter instances, which is achieved by function createNewMonitorStates in algorithm D X . Unlike in algorithm C X , where all the parameter instances less informative than Œ∏ are searched to find all the compatible parameter instances using U, createNewMon-itorStates enumerates parameter sets in enable X G (e) and looks for parameter instances whose domains are in enable X G (e) and which are compatible with Œ∏ , also using U. The inclusion check at line 2 in createNewMonitorStates is to omit unnecessary search since if Dom(Œ∏ ) ‚äÜ X e then no new parameter instance will be created from Œ∏ . This way, createNewMonitorStat-es creates all the parameter instances from Œ∏ whenever the enable set of e is satisfied using fewer lists in U.</p><p>If e is a creation event then a monitor state for Œ∏ is initialized (lines 3-5 in main). Note that (Œ∏ ) can be defined in function createNewMonitorStates if (Œ∏ ) has been defined for some Œ∏ Œ∏ . disable(Œ∏ ) is set to the current timestamp after all the creations and the timestamp is increased (line 6 in main). The rest of function main in D X is the same as in C X : all the relevant monitor states are updated according to e. Function defineNew in D X first searches for a defined sub-instance of Œ∏ . If such instance exists, Œ∏ should be defined using it; otherwise, (Œ∏ ) is set to the initial state. Then, T (Œ∏ ) is set to the current timestamp, and the timestamp is incremented. Function defineTo in D X checks disable and T as discussed above to decide whether (Œ∏ ) can be defined using (Œ∏ ). If (Œ∏ ) is defined using (Œ∏ ), T (Œ∏ ) is set to T (Œ∏ ). Both functions then add Œ∏ to the sets in table U for the bindings less informative than Œ∏ , as in C X .</p><p>In all of our tested cases D X performs better than C X ; in most cases that C X or D X caused notable monitoring overhead, the efficiency of D X is significantly better (see Sect. 4.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Indexing</head><p>Algorithm D X gives an efficient algorithm for monitoring parametric specifications, but it tells us nothing about the data structures used to map parameter instances to their given monitor states. The following techniques have been adapted from <ref type="bibr" target="#b22">[22]</ref> to algorithm D X . D X is more powerful than the monitoring algorithm used in <ref type="bibr" target="#b22">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Centralized indexing</head><p>Efficient monitor lookup is crucial to reduce the runtime overhead. The major requirement here is to quickly locate all related monitor instances given a parameter instance. Recall that different events can have different sets of parameters: e.g., in Fig. <ref type="figure" target="#fig_7">11</ref>, all four events declare different parameter subsets. Our centralized indexing algorithm constructs multiple indexing trees according to the event definitions to avoid inefficient traversal of the indexes; more specifically, for every distinct set of event parameters found in the specification, an indexing tree is created to map the set of parameters directly into the list of corresponding monitors.</p><p>The number and structure of indexing trees needed for a specification can be determined by a simple static analysis of event parameter declarations. For example, from our original parametric specification in Fig. <ref type="figure">2</ref>, since there are three different sets of event parameters, namely v, e , v , and e , three indexing trees will be created to index monitors, as illustrated in Fig. <ref type="figure" target="#fig_5">18</ref>: the first tree uses a pair of v and e to find the corresponding monitor, while the other two map v and, respectively, e to the list of related monitors. Fig. <ref type="bibr" target="#b18">18</ref> Centralized indexing for the JavaMOP spec in Fig. <ref type="figure">2</ref> Fig. <ref type="bibr" target="#b19">19</ref> Centralized indexing monitoring code generated by JavaMOP for updateV (from the JavaMOP spec in Fig. <ref type="figure">2</ref>)</p><p>We use hash maps in JavaMOP to construct the indexing tree. Figure <ref type="figure" target="#fig_6">19</ref> shows the generated monitor lookup code for the updateV event in Fig. <ref type="figure">2</ref>. This code is inserted at the end of every call to a Vector.add method<ref type="foot" target="#foot_4">6</ref> or to Vector.remove, according to the event definition. One parameter is associated to this event, namely, the vector v on which we invoke the method. A map, SafeEnum_v_map, is created to store the indexing information for v, i.e., the {v}Map in Fig. <ref type="figure" target="#fig_5">18</ref>. When such a method call is encountered during the execution, a concrete vector object will be bound to v and the monitoring code will be triggered to fetch the list of related monitors using SafeEnum_v_map. Then all the monitors in the list will be invoked to process the event.</p><p>A performance-related concern in our implementation of JavaMOP is to avoid memory leaks caused by hash maps. The values of parameters are stored in hash maps as key values. When these values are objects in the system, this might prevent the Java garbage collector from removing them even when the original program has released all references to them. We use weakly referenced hash maps in JavaMOP. The weakly referenced hash map only maintains weak references to key values; hence, when an object that is a key in the hash map dies in the original program, it can be garbage collected and the corresponding key-value pair will also be removed from the hash map. This way, once a monitor instance becomes unreachable, it can also be garbage collected and its allocated memory released. Note that a monitor instance will be destroyed only when it will never be triggered in the future because the monitor is not destroyed unless all parameters are garbage collected. If a future event can ever trigger monitor instance m, then m is not garbage collectible. This guarantees the soundness of our usage of weak references. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Optimization: decentralized indexing</head><p>The centralized-indexing approach above can be regarded as a centralized database of monitors. This solution proves to be acceptable with respect to runtime overhead in many of the experiments that we have carried out. However, reducing runtime overhead is and will always be a concern in runtime verification. We next propose a further optimization based on decentralizing the indexing. This optimization is also implemented in JavaMOP using the decentralized keyword. Theoretically, decentralized indexing will not always outperform centralized indexing, but in our experiments it has.</p><p>In decentralized indexing, the indexing trees are piggybacked into states of objects to reduce the lookup overhead. For every distinct subset of parameters that appear as a parameter of some event, JavaMOP automatically chooses one of the parameters as the master parameter and uses the other parameters, if any, to build the indexing tree using hash maps as before; the resulting map will then be declared as a new field of the master parameter. For example, for the updateV event in Fig. <ref type="figure">2</ref>, since it has only the v parameter, v is selected as master parameter and a new field will be added to its Vec- tor class to accommodate the list of related monitor instances at runtime. Figure <ref type="figure" target="#fig_12">20</ref> shows the decentralized version of the centralized indexing example in Fig. <ref type="figure" target="#fig_5">18</ref>.</p><p>Comparing Figs. <ref type="figure" target="#fig_13">21</ref> and<ref type="figure" target="#fig_6">19</ref>, one can see that the major difference between the centralized and the decentralized indexing approaches is that the list of monitors related to v can be directly retrieved from v when using decentralized indexing; in centralized indexing we need to look up the list from a hash map. Decentralized indexing thus scatters the indexing over objects in the system and avoids unnecessary lookup operations, reducing both runtime overhead and memory usage. It is worth noting that the decentralized indexing does not affect the behavior of disposing unnecessary monitor instances as discussed in the previous section: when an object is disposed, all the references to monitor instances based on this object will also be discarded, no matter whether they are stored in maps using weak references or whether they are embedded as fields of the object.</p><p>On the negative side, decentralized indexing involves more instrumentation than the centralized approach, sometimes beyond the boundaries of the monitored program, since it needs to modify the original signature of the master parameter: for the monitoring code in Fig. <ref type="figure" target="#fig_13">21</ref>, the Java library class Vector has to be instrumented (add a new field). This is usually acceptable for testing/debugging purposes, but may not be appropriate if we use MOP as a development paradigm and thus want to leave monitors as part of the released program. If that is the case, then one should use centralized indexing instead, by not using the modifier decentralized.</p><p>The choice of the master parameter may significantly affect the runtime overhead. In the specification in Fig. <ref type="figure">2</ref>, since there is a one-to-many relationship between Collections and Iterators, it would be more effective to choose the Iterator as the master parameter of the create event. Presently, Java-MOP picks the first parameter encountered in the analysis of the MOP specification as the master parameter for each set of event parameters. Hence, the user can control the choice of the master parameter by putting, for each set of parameters P, the desired master parameter first in the list of parameters of the first event parametric over P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Binding modes and connectedness</head><p>There are three parameter binding modes available in Java-MOP, as well as the concept of connectedness, which may be used in conjunction with any binding mode. These modes and connectedness determine which monitor instances are allowed to report verdict categories (e.g., match or fail). This allows a user to essentially apply a filter on the number of results they want from their monitors. For each binding mode The default binding mode is the any-binding mode. In this mode, any instance monitor is allowed to report categories. When the above trace is monitored using any-binding four matches are reported, one on each of the first two events as they arrive and two for the last event, e 3 . Two matches are reported when e 3 arrives because one is reported from the monitor instance for a 1 , b 1 and one is reported from the monitor instance for b 1 , and categories can be reported from any monitor instance. The trace slices for each monitor instance after all three events can be seen in Fig. <ref type="figure" target="#fig_14">22</ref>. Note that each one matches the pattern, and that the one for a 1 , b 1 has two prefixes that match the pattern (e 1 e 2 and e 1 e 2 e 3 ), resulting in four total matches, as expected.</p><p>The other extreme, full-binding is allowing only those instance monitors that correspond to fully instantiated parameter instances to report categories. This is similar to the semantics of Tracematches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b17">17]</ref>. Looking at our example trace, two matches will be reported because two prefixes of the trace e 1 e 2 e 3 , which comes from the only instance we consider ( a 1 , b 1 ), match (see Fig. <ref type="figure" target="#fig_14">22</ref>). To implement this mode, during monitor generation we count the number of parameters in the parameter list of the monitor. Whenever we check a monitor instance for a category (such as the check for the match category in Figs. <ref type="figure" target="#fig_6">19</ref> and<ref type="figure" target="#fig_13">21</ref>) we compare the number of bound parameters of the monitor instance to the number of parameters of the specification. If the numbers of parameters do not match, the monitor instance's output is ignored.</p><p>In between these two extremes are maximal-binding. The "less informative or as informative as" relation " " in Definition 4 induces a partial order over parameter instances. In this mode, we only report verdict categories from those instances that are currently maximal in that partial order. Considering again our example, this is a bit more complex. When event e 1 arrives, the instance is maximal, so a match is reported. When e 2 arrives the new maximal instance is a 1 , b 1 , and a match is reported. When e 3 arrives, a 1 , b 1 is still larger than b 1 so only the instance a 1 , b 1 is allowed to report a match, thus only three matches are reported, unlike the four from any-binding. To implement this binding mode, all monitor instances contain flags; when defineTo in Algorithm D X (Fig. <ref type="figure" target="#fig_11">17</ref>) defines a new monitor from a less informative monitor the flag in the less informative monitor is set to false. In addition, when a new instance is created we must check if there is a monitor instance for a more informative parameter instance already in existence, as happens in our example, and set the flag to false if there is. Results from the monitor instance are only reported when the flag is true.</p><p>Connectedness, which may be used to augment any binding mode, filters out all those monitor instances for which the parameters are not connected to each other by some event. For example, if events e 1 p 1 and e 2 q 1 are the only events that have been seen that are sent to the p 1 , q 1 instance, no categories will be reported from that instance until some event such as e 3 p 1 , q 1 occurs. For connectedness, we will consider again the SafeEnum property of Fig. <ref type="figure">2</ref>, and we will consider the trace:</p><formula xml:id="formula_13">updateV v 1 createE v 1 , e 1 updateV v 2 useE e 1</formula><p>Nothing violating the SafeEnum condition of not using an Enumeration created from a Vector that has been modified occurs in this pattern, however, because of the generic parametric trace slicing algorithm, some monitor instances will be generated that will flag failures, as can be seen in Fig. <ref type="figure" target="#fig_15">23</ref>. With connectedness the results of extraneous monitor instances such as v 2 , e 1 , which would signal an undesired fail verdict, can be filtered out. Note that the instance for v 2 , e 1 must be created by the generic parametric monitoring algorithm, because it has no way to know that v 2 , e 1 cannot be connected at some time in the future, as it has no semantic knowledge of the createE event. Connectedness can be added to a specification via the connected keyword shown in Fig. <ref type="figure" target="#fig_4">7</ref>, and is implemented using a union-find data structure in which each set represents parameter objects which have been connected by a given event. When an event arrives, all of its associated parameter objects are unioned in the union-find data structure. When a monitor instance attempts to report a verdict category, the union-find data structure is queried to ensure that all parameter objects of the instance are in the same set of the union-find.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">JavaMOP evaluation</head><p>The evaluation presented here is a summary of the evaluation of JavaMOP that we performed in the summer of 2009 and described in <ref type="bibr" target="#b20">[20]</ref>. Algorithms C X and D X described in Sect. 4.2 were both used to showcase the effectiveness of using enable sets to reduce extraneous monitor creations. Results from Tracematches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b17">17]</ref> are also presented because it is the most efficient Java monitoring system of which we are aware, other than JavaMOP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experimental Settings</head><p>Our experiments were performed on a machine with 2GB RAM and a Pentium 4 2.66 GHz processor using Ubuntu Linux 7.10. We used version 2006-2010 of the DaCapo benchmark suite <ref type="bibr" target="#b14">[14]</ref>. The default input for DaCapo was used, and we use the -converge option to ensure the validity of our test by running each test multiple times, until the execution time converges. After convergence, the runtime is stabilized within 3%, thus numbers in Fig. <ref type="figure" target="#fig_16">24</ref> should be interpreted as "¬±3%". Additional code introduced by the AspectJ weaving process changes the program structure in DaCapo, sometimes causing the benchmark to run slightly faster due to better instruction cache layout. Both of these facts account for the negative overheads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Properties</head><p>These properties, borrowed from <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b47">47]</ref> and specified using formalisms discussed in Sect. 6, were used in the evaluation of JavaMOP.</p><p>-UnsafeMapIterator: Do not update a Map when using the Iterator interface to iterate its values or its keys; -UnsafeSyncCollection: If a Collection is synchronized, then its iterator also should be accessed synchronously; -UnsafeSyncMap: If a Collection is synchronized, then its iterators on values and keys also should be accessed in a synchronized manner; -UnsafeIterator: Do not update a Collection when using the Iterator interface to iterate its elements; -UnsafeFileWriter: Do not write to a FileWriter after closing.</p><p>UnsafeMapIterator and UnsafeIterator specify properties that catch conditions in which the Java Virtual Machine will throw an exception. However, the exception will not always be properly thrown when the Map or Collection in question is modified in a separate thread from the thread iterating over the Map or Collection. Also, each of these properties is relevant to most of our benchmarks, and shows large overheads that are useful for comparisons between Tracematches and JavaMOP, which is the goal of this evaluation.</p><p>UnsafeFileWriter cannot be expressed in Tracematches because it is a context-free property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results and Discussion</head><p>Figures 24 and 25 summarize the results of the experiments from <ref type="bibr" target="#b20">[20]</ref>. Figure <ref type="figure" target="#fig_16">24</ref> shows the percent overheads of C X , D X , and Tracematches. All the properties were heavily monitored in the experiments. Millions of parameter instances were observed for some properties under monitoring, e.g., UnsafeIterator, putting a critical test on the generated monitoring code. Note that Soot <ref type="bibr" target="#b59">[59,</ref><ref type="bibr" target="#b61">61]</ref>, the underlying bytecode engine for Tracematches, cannot handle the DaCapo benchmark properly, resulting in fewer instrumentation points in the pmd program. Accordingly, our specifications are modified to have the same scope of instrumentation in pmd for a fair comparison. All three systems generated low runtime overhead in most experiments, showing their efficiency. For D X , only 7 out of 66 cases caused more than 10% runtime overhead. The numbers for C X and Tracematches are 9 out of 66 and 15 out of 44, respectively. Figure <ref type="figure">25</ref> shows the comparison among three systems using 7 cases where significant numbers of monitors were created in monitoring. Figure <ref type="figure">25a</ref> compares runtime overhead. In all cases, D X outperformed the other two and C X is better than Tracematches. This shows that JavaMOP provides an efficient solution to monitor parametric specifications despite its genericity in terms of specification formalisms. The results also illustrate the effectiveness of the enable set based optimization: on average, the overhead of D X is about 20% less than C X . Moreover, when the property to monitor becomes more complicated, the improvement achieved by the optimization is more significant. In the two extreme cases, namely, bloat-UnsafeMapIterator and pmd-UnsafeMapIterator, where both the non-optimized JavaMOP and Tracematches ran out of memory, the optimized JavaMOP managed to finish the executions with overheads that are reasonable for many applications, such as testing and debugging.</p><p>Figure <ref type="figure">25b</ref> shows the maximum memory usages of our experiments in log 10 scale, in Megabytes. It shows that the enable set optimization does not always reduce peak memory usage. In two out of five pictured cases, algorithm D X produces significantly lower peak memory usage than C X . In fact, in bloat-UnsafeMapIterator and pmd-UnsafeMapIterator, where C X ran out of memory, D X managed to complete. In general, peak memory usage with D X was never observed to be higher than C X by any significant amount. Wherever C X was observed to have lower peak memory usage, it was at the expense of more garbage collections than with D X . For example, in pmd-UnsafeIterator, the C X monitored program had 1361 young generation garbage collections while the D X monitored program had 1167 collections. Of course, fewer garbage collection cycles contributes Figure <ref type="figure">25c</ref> shows the number of monitor instances generated by C X and D X . Tracematches are absent from the graph because it does not produce monitor instances per se. In general, fewer monitor instances are generated by D X .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">BusMOP</head><p>Every MOP instance has issues specific to its domain. Bus-MOP must deal with interfacing with buses at a hardware level. There is also complexity in the mechanisms for recovery actions, which require specialized hardware modules. We first provide an introduction to the PCI bus, which is the currently supported bus architecture for BusMOP. While we intend to support more bus architectures in the future, the operation of the PCI bus was instrumental in guiding the design of BusMOP. We then discuss the design of the Bus-MOP monitoring device. Particular care must be taken to support certain features of the current MOP logical formalism semantics that expect serialized events. To use BusMOP, one writes a property for a specific peripheral, say p, that is plugged into the bus. The property is then synthesized onto an FPGA that is also plugged into the bus. A small program is used to write the proper value of the base access register (BAR) for p to the FPGA (see below for more explanation on the BARs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">PCI bus</head><p>While BusMOP <ref type="bibr" target="#b52">[52]</ref> is a generic approach to generating hardware based monitors that can be adapted to any bus structure. <ref type="foot" target="#foot_5">7</ref> the current implementation is specific to the PCI Bus architecture. The idiosyncrasies of the PCI bus architecture guided the design of BusMOP.</p><p>The PCI is the current standard family of communication architectures for motherboard/peripheral interconnection in the personal computer market; it is also widely popular in the embedded domain <ref type="bibr" target="#b50">[50]</ref>. The standard can be divided into two parts: a logical specification, which details how the CPU configures and accesses peripherals through the system controller, and a physical specification, which details how peripherals are connected to and communicate with the motherboard. While the logical specification has remained largely unaltered since the introduction of the original PCI 1.0 standard in 1992, several different physical specifications have emerged since then.</p><p>One of the main features of the logical layer is plug-andplay (automatic configuration) functionality. On start-up, the OS executes a PCI base driver which reads information from special configuration registers implemented by each PCI-compliant peripheral and uses them to configure the system. Of peculiar importance is a set of up to six base access registers (BARs) (recall the baseN registers from Sect. <ref type="bibr">3.3.1)</ref>. Each BAR represents a request by the peripheral for a block of addresses in either the I/O or memory space; the PCI base driver is responsible for accepting such requests, allocating address blocks and communicating back the chosen addresses to the peripheral, by writing in the BARs.</p><p>To communicate with the peripheral, the CPU can, then, issue write and read commands, called transactions, to either I/O or memory space; each peripheral is required to implement bus slave logic, which decodes and responds to transactions targeting all address spaces allocated to the peripheral. Typically, address spaces are used to implement either registers, which control and determine the logical status of the peripheral, or data buffers. Peripherals can also implement bus master logic: they can autonomously initiate read and write transactions to either main memory or the address space of another peripheral. Master mode is typically used by highperformance peripherals to perform a DMA transfer, i.e., transfer data from the peripheral to a buffer in main memory. The peripheral's driver can then read the data directly from memory, which is much faster than issuing a read transaction on the bus. Finally, each peripheral is provided with an interrupt line that can be used to send interrupts to the CPU.</p><p>There are two main flavors of physical architecture: both PCI and PCI-X are parallel, while PCI-E is serial but runs at much higher frequency (2.5 Ghz against up to 133Mhz for PCI-X). We have focused on PCI/PCI-X, <ref type="foot" target="#foot_6">8</ref> which implements a shared bus architecture. The logical PCI tree is physically divided into bus segments, and most bus wires are shared among all peripherals connected to a single segment. We refer to <ref type="bibr" target="#b50">[50]</ref> for detailed bus specifications. Each transaction seen on the bus consists of an address phase, which provides the initial address in either memory or I/O space, followed by one or more data phases, each of which carries up to 32 or 64 bits of data for PCI/PCI-X, respectively (individual bytes can be masked using byte enables). Since each bus segment is shared, arbitration is required to determine which master peripheral is allowed to transmit at any one time. Arbitration uses two active-low, point-to-point wires between the peripheral and the bus segment arbiter, REQ# and GNT#. A standard request-grant handshake is used, where the peripheral first lowers REQ# to request access to the bus, and the arbiter grants permission to start a new transaction by lowering GNT#.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Monitoring device</head><p>The current version of BusMOP is designed for the Xilinx ML455 board <ref type="bibr" target="#b62">[62]</ref>, but adapting the generated code to different FPGA boards takes minimal effort. The monitoring device uses a mixed VHDL/Verilog register transfer level (RTL) description. The board is outfitted with a Virtex-4 FPGA and it can be plugged into a standard 3.3V PCI/PCI-X socket. The FPGA implements both a slave and a master peripheral module, together with the monitoring modules. Events for the system are specified in terms of read/write data transfers on the bus and interrupt requests; the device continuously "sniffs" all ongoing activities on the bus, and is, therefore, able to monitor communication for all other peripherals located on the same bus segment. Whenever a failure to meet the specification is detected, the device can execute a recovery action using strategies based on the detected error.</p><p>For a vast category of errors that involve incorrect interaction between the peripheral and its software driver, it is often possible to recover from the failure by forcing the peripheral into a consistent state. The monitoring device implements a master module, and can, therefore, initiate transactions on the bus. For example, consider a common type of error, where the driver fails to validate some input from the user and as a result writes an invalid value to a register in the peripheral. We can recover by rewriting the register with a valid value. However, if the error is caused by a fault in the peripheral hardware, interacting with registers may not be enough to bring the peripheral to a consistent and safe state.</p><p>To handle peripherals that cannot be put into a consistent and safe state, a hardware device, the peripheral gate <ref type="bibr" target="#b51">[51]</ref>, is used that is able to force the REQ# signal from the peripheral to the bus arbiter to be high. Hence, the peripheral never receives the grant and it is prohibited from initiating any further transaction on the bus. <ref type="foot" target="#foot_7">9</ref> The peripheral gate is implemented based on a PCI extender card, i.e., a debug card that is interposed between the peripheral card and the bus and provides easy access to all signals. A clarifying picture for monitoring of a single peripheral is provided in Fig. <ref type="figure" target="#fig_17">26a</ref>. The monitoring device can output a stop signal, which closes the gate when active high; this can be achieved in a specification by setting the stop_reg described in Sect. 3.3.1 to '1'. Finally, sometimes the monitoring device cannot perform a suitable recovery action by itself, but there is a higher level actor, such as the OS or the system user, that can provide better recovery; examples include complex software operations such as restarting the driver or the whole PCI stack, and physically interacting with the peripheral. In this case, the best strategy is to communicate the failure to the chosen actor. In addition, we implemented an RS-232 controller that can be used to send information to the user over a serial connection.</p><p>The reader should notice that the nature of our implementation is such that if a trace is seen, which does not conform to a specification, as a consequence of a bus transaction, that specific bus transaction cannot be prevented from propagating to the rest of the system. For example, if a faulty peripheral performs a write transaction to an area in main memory which is not supposed to modify, we can detect the error, disconnect the peripheral, and report the failure to the OS/user. However, the information in the overwritten area will be lost. As part of our future work, we are working to implement an interposed monitoring device: by sitting between the bus and a peripheral, it will be able to buffer all transactions that target that specific peripheral or are initiated by it. If a property is validated/violated, it is then possible to take preventive measures (i.e., either discard or modify the transaction before propagating it). While this solution will provide a higher degree of reliability, there is a price to be paid in terms of increased communication delay due to buffering in the monitoring device. 10  A simplified block diagram for the monitoring device is shown in Fig. <ref type="figure" target="#fig_17">26b</ref>. We distinguish three types of blocks:</p><p>(1) blocks provided by Xilinx as proprietary intellectual properties (IPs); (2) manually coded RTL modules provided by BusMOP, which are independent of the peripheral specification; (3) automatically generated RTL modules, which are dependent on the specification (see Sect. 3.3.1 for specification syntax). PCI transaction signals are routed to two different modules: the PCI_core and the decode module.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">The PCI_core module</head><p>The PCI_core module is a hard IP 11 that implements all logic required to handle basic PCI functions such as plug-and-play. Bus slave and bus master logic is implemented by the slave and master modules, respectively. In particular, slave implements a set of 16 registers, base0 through base15. Since the OS configures the BAR registers at system boot, a peripheral cannot directly determine the location of address blocks used by another peripheral. Hence, the OS must also write the locations of the address blocks allocated to monitored 10 Note, however, that communication bandwidth will be unaffected. 11 A hard IP is a module that is provided already synthesized rather than as an HDL or net list description (which are soft IPs). This means that it cannot be readily modified by users of the IP. peripherals in the base registers. The decode module is used to simplify event generation. It translates all transactions on the bus (except for those initiated by the monitoring device itself) into a series of I/O or memory reads/writes, one for each data phase, as well as the occurrence of an interrupt, and forwards the translated information to the monitoring logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">The systemN modules</head><p>The system0, . . ., systemN blocks implement the monitoring logic for each of N user specified properties. Each systemI block consists of two automatically generated modules: bus_interfaceI contains all logic that depends on the specific choice of communication interface (PCI bus), while monitorI contains all logic that depends on the formal language used to specify the property. This separation provides good modularity and facilitates code reuse. bus_interfaceI first receives as input the decoded bus signals and generates events, which are sequentialized by the events_sequentializ- er submodule (see Sect. 5.2.3), and then passed to monitorI using the seq_events wires. monitorI checks whenever the formula for the Ith property is validated/violated and passes the information back to bus_interfaceI, which can then execute three types of recovery: (1) disconnect a monitored peripheral from the bus using the stop signal; (2) send information to the user using the serial_output module, which implements a RS-232 transmitter; (3) start a write transaction on the bus using the master module. Finally, since it is possible for multiple systemI modules to initiate recovery at the same time, we provide queuing functions for serial_output and master in modules master_queue and serial_queue, respectively.</p><p>Notice that in the current implementation the time elapsed from any event that requires a handler to executing that corresponding handler is at most four clock cycles. This time is short enough to execute a recovery action before a faulty peripheral is allowed to start a new transaction, as PCI arbitration overhead prevents a peripheral from transmitting immediately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">The bus_interface module</head><p>The code for the BusMOP Declarations (see Sect. 3.3.1), BusMOP Action , and BusMOP Handler is copied verbatim into the VHDL module defining the bus_interface. The events are expanded to combinatorial statements implementing the specified logic. The output of the combinatorial statements is assigned to an events wire vector (not pictured), which is connected to the monitor module through an event_sequentializer submodule. Each index in the bus corresponds to the truth value of a specific event, numbered with the 0th index as the first event, and the nth index as the nth event from top to bottom in the specification. This order- ing is important, because it directs the event linearization performed by the event_sequentializer submodule.</p><p>The event_sequentializer is necessary because the logical formalisms expect linear, disjoint events. The event_sequen- tial-izer takes coincident events and sends them to the monitor in subsequent clock cycles, in ascending index order, using the seq_events wire vector (Fig. <ref type="figure" target="#fig_17">26b</ref>). Therefore, if events(0) and events(3) occur in the same cycle, the monitor will see 0 followed by 3. To see why simultaneous events are possible, consider, again, Fig. <ref type="figure" target="#fig_1">3</ref> from Sect. 1. The cntrlMod event is asserted whenever the cntr_cntrl2 register (base1 + X"220") is written. Because both the countEnable and countDisable events require writes to the same address as the cntrlMod event, any time countEnable or countDisable are triggered, a cntrlMod is also triggered. As the property tries to enforce the policy that all modifications happen when the counter is not enabled, we must serialize events such that cntrlMod happens after a countDisable and before a countEnable. The ordering of events in Fig. <ref type="figure" target="#fig_1">3</ref>, is consistent with this, because countDisable is listed before cntrlMod, which is listed before countDisable.</p><p>The @fail handler is placed in the module such that it is only executed if the monitor module denotes that the property has failed to match. The situation is similar for an @match handler, save that it is executed only when the formula or pattern is matched. <ref type="foot" target="#foot_8">12</ref> As can be seen in the Fig. <ref type="figure" target="#fig_17">26b</ref>, the monitor module reports the validation, violation, or neutral state of the monitored property, via the properties wire vector, to the bus_interface module. Several actions are available in Property Handlers as described under BusMOP Handler in Sect. 3.3.1. Aside from manipulating any local state of the monitor (such as the write to cntrlCurrent in Fig. <ref type="figure" target="#fig_1">3</ref>), the bus_interface module makes available several registers which can be used used to execute the recovery actions detailed in Sect. 5.2. The registers are described under BusMOP Handler in Sect. 3.3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">The monitor module</head><p>The monitor module is responsible for monitoring the property given serialized events. It encompasses the logic of the formula, and it is the only portion of our system dependent on the logical formalism used. The module is generated from the pseudocode monitor descriptions returned by the logic repository from Fig. <ref type="figure" target="#fig_2">4</ref>. The parallel assignment algorithm for monitoring PTLTL described in Sect. 6.4 was originally designed for use in BusMOP monitors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">BusMOP evaluation</head><p>In general, BusMOP imposes 0% runtime overhead on the system it monitors, <ref type="foot" target="#foot_9">13</ref> therefore, our evaluation is a case study on the usefulness of BusMOP, first presented in <ref type="bibr" target="#b52">[52]</ref>. We show how our runtime monitoring technique can be applied to a concrete case by providing specification and runtime experiments for a specific COTS peripheral, the PCI703A board <ref type="bibr" target="#b26">[26]</ref>. PCI703A is a high performance analogto-digital/digital-to-analog conversion (ADC/DAC) peripheral for the PCI bus. In particular, it can perform high-speed, 14-bits precision ADC at a rate of up to 450,000 conversions/s, and transfer data to main memory in bus master mode. At the same time, the peripheral is simple enough that we were able to carefully check all provided hardware manuals and to manually inspect its Linux driver; specifying formal properties for a peripheral clearly requires a deep understanding of its inner working. In our proposed model, the peripheral's manufacturer is responsible for writing the runtime specification. In this sense, the formal specification can be thought of as a correctness certification provided by the manufacturer, as long as the user employs a monitoring device and recovery actions can be proved to restore the system to a safe state.</p><p>To better mimic what we think would be a typical process for a COTS manufacturer, we produced a requirement specification for the PCI703A in two steps. First, we prepared a detailed description of the communication behavior of the peripheral in plain English. Then, we converted this informal description into a formal set of events and formulae for Bus-MOP. Inspection of the driver revealed two software faults, both of which can cause errors that are detected and recovered by the monitoring device. While in this case we could have prevented errors by simply removing the faults, we argue that drivers for more complex peripherals can be thousands of lines long and neither code inspection nor testing is sufficient to remove all bugs. We further injected additional faults in the driver to test all written formal properties. It would have been nice to also show recovery for hardware faults, but we did not find any in the tested peripheral and injecting faults in the hardware is difficult. In what follows, we first provide an overview of PCI703A and then we detail properties for an example subsystem, a counter used in the ADC process. The example is particularly instructive as we show how a small but representative set of properties is able to catch one of the aforementioned driver bugs.</p><p>A block diagram for the PCI703A is shown in Fig. <ref type="figure" target="#fig_4">27</ref>. The bus slave logic implements two memory address blocks in BAR0 and BAR1, used for conversion data and control registers, respectively; the corresponding base addresses are written in base0 and base1 in the monitoring device. The ADC Control and DAC Control blocks control the ADC/DAC operations and write/read data into internal FIFOs. The DMA Control block can be programmed to move data between each FIFO and main memory using bus master functionality. Finally, the Counter Timers block implements four counters. Counter 0 and 1 are user programmable and can be used either for debugging purposes or to trigger a DA conversion. Counter 3 is also user programmable and produces an external output. Finally, Counter 2 is not meant to be user programmable; it is to be used exclusively to generate the clock for AD conversions. The C user library provided with the driver exports an ADConfig function used to configure ADC Control and the associated Counter 2. The library Fig. <ref type="figure" target="#fig_4">27</ref> PCI703A diagram also provides a CTConfig function to be used to configure the user counters; unfortunately, under Linux the function can also be used to change the configuration of Counter 2. This is a problem, as any user in the system could erroneously or maliciously change Counter 2 while an ADC is in progress.</p><p>Three 16-bit control registers are relevant to our discussion: cntr_cntrl2 (at hexadecimal location 220 relative to BAR1), cntr_divr2 (228), and adc_cntrl (300). Bit 0 of cntr_cntrl2 determines whether Counter 2 is enabled, and bits 2-1 determine its clock source (either 20 Mhz or 100 Khz); when the counter is enabled, it first loads the content of cntr_divr2 and then starts counting down at the selected frequency. When it reaches zero, the value of cntr_divr2 is reloaded, a clock signal is sent to ADC Control, and finally if bit 4 of cntr_cntrl2 is set, an interrupt is generated. Register adc_cntrl controls the behavior of ADC Control; in particular, bit 0 enables/disables the ADC process and bits 2-1 determine the clock source, with a value of "00" indicating that Counter 2 is used.</p><p>We express three requirements:  Requirements 1-3 are able to catch the driver bug in the sense that an invalid counter configuration cannot be set before starting the ADC, and furthermore while the ADC is active no counter modification is allowed. We wrote four (five including the example from Sect. 1) formal properties to capture the requirements: InterruptFix The InterruptFix specification is the formalization of Requirement 1, and can be seen in Fig. <ref type="figure" target="#fig_18">28</ref>. Because we do not want the 4th bit set, we simply monitor the pattern setBit4, an event which corresponds to setting the 4th bit. We perform recovery when the pattern is validated by overwriting cntr_cntrl2 with the last valid value, similarly to SafeCounterModify in Fig. <ref type="figure" target="#fig_1">3</ref>. SafeConversionSpeed The SafeConversionSpeed specification is the formalization of Requirement 2, and can be seen in Fig. <ref type="figure" target="#fig_19">29</ref>. For this property, we chose to show how event side effects can be used in handlers as part of checking that a property has been validated/violated. When the clkSrcSet or srcSet events are triggered, meaning that the cntr_cntrl2 or adc_cntrl registers have been modified, respectively, we store the value written to the register in monitor local registers (e.g., src &lt;= value(15 downto 0)). The pattern specifies that the cntr_divr2 be set to a bad value (less than 45), followed by any number of updates to cntr_cntrl2 or adc_cntrl, followed by the enabling of the counter. If cntr_divr2 is set to a value larger than 44, the pattern will be violated, and the monitor will be reset. This means that the validation handler will be executed only when the value of cntr_divr2 is too low for safe conversion, but regardless of whether or not the board is actually using Counter 2. The handler then checks that it is, in fact using Counter 2, and that Counter 2 is using the 20 Mhz source, before performing the recovery: setting cntr_divr2 to a valid value <ref type="bibr" target="#b45">(45)</ref>. NoDisableWhileConverting The NoDisableWhileConverting specification is the formalization of part of Requirement 3, and can be seen in Fig. <ref type="figure" target="#fig_1">30</ref>. This could have been written in a similar manner to SafeConversionSpeed, i.e., using event side effects to store current register values and checking them in the handler. We decided to use a fully formal specification, that defines events for setting the registers to good or bad values. The formula itself specifies that, if the ADC is enabled, and clkSrc2 is good, meaning that Counter 2 is being used to time the ADC, then Counter 2 must be enabled. The part of the formula before the implies keyword, states that the ADC is enabled and the ADC clock source is Counter 2, the second half of the formula is the requirement that Counter 2 not be disabled. The formula is true when correct behavior is exhibited, so we use a violation handler for the recovery action, which again is simply to set cntr_cntrl2 to the last valid value. SafeDivrModify The SafeDivrModify specification is the formalization of part of Requirement 3, and can be seen in Fig. <ref type="figure" target="#fig_1">31</ref>. In conjunction with NoDisableWhileConverting and SafeCounterModify (from Sect. 1), all of requirement 3 is covered. This specification ensures that cntr_divr2 is not modified while Counter 2 is enabled. This property is the same as SafeCounterModify from Fig. <ref type="figure" target="#fig_1">3</ref>, save that we are ensuring that cntr_divr2 is not modified, rather than cntr_cntrl2. We also used PTLTL rather than ERE, to show how two very similar properties look in both logics. These could be collapsed into one specification, but it would make recovery more complicated, because we only want to roll back the register that was actually modified (cntr_cntrl2 or cntr_divr2). The formula itself states that if cntr_divr2 has been modified and the counter has not been disabled since the last time it was enabled, than we must recover. Unlike SafeCounterModify we use a validation rather than a violation handler, because the formula was easier to express with recovery being on validation. As a final consideration, note that the handlers of Safe-CounterModify, InterruptFix and NoDisableWhileConverting can be invoked simultaneously if an incorrect value is written to cntr_cntrl2, which results in the execution of multiple bus writes. However, this causes no problem since all handlers overwrite cntr_cntrl2 with the same valid value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Logic plugins</head><p>Each logical formalism provided by the MOP framework is implemented as a program called a logic plugin, as mentioned in Sect. 2. The individual logic plugins are controlled by the logic repository as can be seen in Fig. <ref type="figure" target="#fig_2">4</ref>.</p><p>For each plugin, we first discuss the syntax of specifications using the formalism. Each plugin syntax instantiates the generic Logic Name , Logic Syntax , Logic State non-terminals described in Sect. 3.1 (see also Fig. <ref type="figure" target="#fig_3">6</ref>). Internally, aside from the specified syntax, each plugin is also given the set of events used in the property by the instance client (either JavaMOP or BusMOP). The instance client simply drops the instance-specific event definition and actions, which are irrelevant to the plugin, and sends only the event names. For simplicity, in what follows, the event declarations are dropped from the logic plugin's syntax. To clarify the syntax, we show an example property in each logic, which also does not include event descriptions. Because only the property is shown, without any event definitions, the parameters, which are part of event definitions in JavaMOP, are absent. One should be aware, if one wishes to use the logic repository described in Sect. 2 without using one of the two pre-defined instance clients, that one should also provide the event names with the property. <ref type="foot" target="#foot_10">14</ref>We then discuss some issues specific to the particular plugin as well as how monitor pseudocode suitable for conversion to Java and HDL is generated. The pseudocode generated from each example property is shown to make the explanation of monitor pseudocode generation more concrete.</p><p>For every plugin, we also describe how enable sets are generated. Recall that enable sets distill information about which prior events must be seen for a given event to create a new monitor instance (see <ref type="bibr">Definitions 10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b12">12</ref> and the surrounding text in Sect. 4.2 for a complete explanation of enable sets).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Finite state machines</head><p>The FSM plugin is one of the most important plugins for MOP. Not only is it a useful logical formalism in itself, but also it is used as a backend for all logics reducible to finite automata. Currently, all logic plugins except for the CFG (Sect. 6.5) and past time linear temporal logic with calls and returns (PTCaRet; Sect. 6.6) generate FSM output. This allows for a strong separation of concerns. For instance, minimization need occurs only once, and it allows us to use one enable set generation algorithm for all of these plugins. In addition, each instance of MOP needs only know how to translate the pseudocode for FSMs, CFGs, and PTCaRet. Some MOP instances, such as BusMOP, may even opt to support only finite state monitors, in which case they only need to provide support for translating FSM pseudocode. <ref type="foot" target="#foot_11">15</ref>Figure <ref type="figure" target="#fig_21">32</ref> shows the syntax for FSM properties. An FSM property is a series of Item s followed by Alias s. An Item is essentially a state in the FSM, and the different transitions to take on a given input ( Transition ). The Alias allows for giving a name to a set of states. This is invaluable, because the FSM State non-terminal, which defines what categories may trigger handlers, both Group Name s, which are the names associated to sets of states in Alias s, and State Name s may be associated with handlers. This allows one to write a property that triggers actions when any state in a given Alias is entered. Figure <ref type="figure" target="#fig_1">33</ref> shows an example FSM property. In this example, three events: next, hasnext and dummy, and three states: start, safe and unsafe are defined. Two state aliases are declared: all_states represents all the states in the state machine and safe_states includes the start state and the safe state. The fail category is reported whenever an event occurs that is not specified for the current state. For example, the state machine will go into fail when the dummy event is seen in the unsafe state. The default transition in the start state covers any event not specified in the transition. Because of this, any state with a default transition cannot lead to a fail category for any input. As mentioned in Fig. <ref type="figure" target="#fig_21">32</ref>, handlers may be associated with any state (e.g., start) or group name (e.g., all_states).</p><p>In the interest of keeping runtime monitoring as efficient as possible, we wish to use minimized FSM for monitors. Because of the ability to trigger handlers from State Name s and Group Name s, MOP FSM properties are .multicategory finite state machines (FSM that recognize more than one language; essentially equivalent to Moore machines). This requires a small change to the normal Hopcroft FSM minimization algorithm <ref type="bibr" target="#b38">[38]</ref>.</p><p>The Hopcroft algorithm works by assuming the largest possible equivalence class of states, and then partitioning the equivalence classes into smaller classes if necessary. The Fig. <ref type="bibr" target="#b33">33</ref>  The way our algorithm differs is in the initial partition. The normal algorithm partitions the states into two classes, those states that are final states and those which are not. We, however, have multiple categories. The particularly interesting feature is that categories may overlap on states. If two categories C 1 and C 2 overlap, they must have three equivalence classes: those states in C 1 -C 2 , those in C 2 -C 1 , and those in C 1 ‚à© C 2 . The naive algorithm would be to compute the intersections between all the categories, but that is quadratic in nature. A better algorithm, which we use, is to find the set of categories each state belongs to. This takes time linear in the number of states. Those states that have the same set of categories are placed in the same initial equivalence class.</p><p>The monitor pseudocode for an FSM property appears the same as the input code, except that it will be minimized, whereas the input code may not be minimal. Because of this, we omit the output of the example in Fig. <ref type="figure" target="#fig_1">33</ref>. Each MOP instance that wants to support the FSM-based logics must convert the FSM pseudocode into executable code.</p><p>The algorithm in Fig. <ref type="figure" target="#fig_2">34</ref> computes the property enable sets for a finite state machine <ref type="bibr" target="#b20">[20]</ref>. We use this algorithm to compute the enable sets for any logic that is reducible to a FSM, including ERE, LTL, and PTLTL. The algorithm assumes a FSM, defined as F SM = (E, S, s 0 ‚àà S, Œ¥ : S √ó E S). E is the alphabet, traditionally listed as but changed for consistency, because the alphabets of our FSMs are event sets. s 0 is the start state, corresponding to ƒ± in the definition of a monitor. Fig. <ref type="figure" target="#fig_2">34</ref> FSM enable E G computation algorithm <ref type="bibr" target="#b20">[20]</ref> Œ¥ is the transition partial function, taking a state and an event and potentially mapping to a next state for the machine. We assume that all states not reachable from the initial state and not coreachable from the states of interest (states of interest being those states s such that Œ≥ (s) ‚àà G, where G is the goal category; see Definition 11) are pruned from the FSM before running the algorithm, leaving the transitions that pointed to them undefined. V Œº is a mapping from states to sets of events; it is used to check for algorithm termination. enable E G is the output property enable set, which is converted into a parameter enable set by the language instance client, discussed in Sect. 2.</p><p>Function compute_enables is first called from main with Œº = ‚àÖ and the initial state s 0 . If we think of the FSM as a graph, Œº represents the set of edges we have seen at least once in a given traversal path. For each defined Œ¥(s, e) (line 1), we add the current Œº to the enable E G (e) (line 2) because this means we have seen a viable prefix set (as all non-viable paths in the machine have been pruned). This follows from the definition of enable E G . Line 3 begins the recursive step of the algorithm. We let Œº = Œº‚à™{e}, because we have traversed another edge, and that edge is labeled as e. The map V Œº tells us which Œº have been seen in previous recursive steps, in a given state. If a Œº has been seen before, in a state, taking a recursive step can add no new information. Because of this, line 4 ensures that we only call the recursive step on line 6, if new information can be added. Line 5 keeps V consistent. Thus, the algorithm terminates only when every viable Œº has been seen in every reachable state, effectively computing a fixed point. Thus, the algorithm is bounded by the number of one cycle paths through the graph (and is faster in practice, because most paths will have repeated events). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Extended regular expressions</head><p>Regular expressions can be easily understood by the average software engineer or programmer, as shown by the immense interest in and the success of scripting languages like Perl, based essentially on regular expression pattern matching. We believe that regular expressions provide an elegant and powerful specification language also for monitoring requirements, because an execution trace of a program is in fact a string of states. Extended regular expressions add complementation to regular expressions, which brings additional benefits by allowing one to specify patterns that must not occur during an execution. Complementation gives one the power to express patterns on strings non-elementarily more compactly. Also, one important observation about the use of ERE in the context of runtime verification is that ERE patterns are often used to describe buggy patterns instead of desired properties.</p><p>Figure <ref type="figure" target="#fig_22">35</ref> shows the syntax for ERE properties. The operators are standard for regular expressions, except that "Àú" is the language complement of an ERE, and "&amp;" is language intersection. While "epsilon" is the empty string, as is normal, "empty" refers to the empty language.</p><p>Here is an example ERE property for the UnsafeMapItera- tor property previously shown in Fig. <ref type="figure" target="#fig_7">11:</ref> create_coll update_map* create_iter use_iter* update_map+ use_iter Recall that in this property, the sequence of actions of importance is the creation of an Iterator from a Collection that was created from a Map, which is updated between the creation of the Iterator and its use.</p><p>FSMs are generated from EREs using coinductive techniques <ref type="bibr" target="#b57">[57]</ref>. Briefly, in our approach we use the concept of derivatives of a regular expression, which is based on the idea of event consumption, in the sense that an extended regular expression R and an event e produce another ERE, denoted R{e}, with the property that for any trace w, trace e w is in L(R) (i.e., the language denoted by R) iff w is in L(R{e}). Figure <ref type="figure" target="#fig_23">36</ref> defines this derivative semantics recursively on the structure of regular expressions; the operators without equations can be defined in terms of operators that do have equations specified. In the equations "|" refers to the ERE operator "|". The generated FSM is not minimal; the minimization algorithm of the FSM plugin (Sect. 6.1) is used to make it minimal. A deterministic automaton is produced, saving memory and time (in contrast to the more conventional Thompson approach <ref type="bibr" target="#b60">[60]</ref>, which by first producing a non-deterministic automaton, and then using a determinization algorithm to produce a deterministic automaton).</p><p>Figure <ref type="figure" target="#fig_4">37</ref> shows the output FSM for the UnsafeMapIterator example ERE above. Note that the alias match is assigned so that ERE properties properly allow match as a verdict category. This was the initial motivation for aliases in the FSM plugin. Also note that the states do not have fully specified input, so fail is a possible output category.</p><p>As mentioned in Sect. 6.1, the property enable sets for EREs are computed by using the algorithm in Fig. <ref type="figure" target="#fig_2">34</ref> after the ERE has been converted to an FSM. Linear temporal logic <ref type="bibr" target="#b54">[54]</ref> is often used to specify properties in model checking. LTL formulae allow one to express concepts such as the occurrence of an event requiring that another event happen in the future. Note that runtime monitoring cannot guarantee the correctness of a safety or liveness property. Even though the properties might hold for a given execution of the system, they can only be proved to hold, in general, by exploring every possible state of the program. LTL specifications must be used with this in mind.</p><p>Figure <ref type="figure" target="#fig_24">38</ref> shows the complete syntax for LTL supported by our plugin. The operators "not", "and", "or" , and "implies" are the standard boolean connectives. The operator "[]" stands for "always", meaning the formula following it must hold at all times, while "&lt;&gt;" stands for "eventually", meaning that the formula following it must eventually hold in the future. The operator "o" means "next": the formula following it, say F, must hold in the next time step; in terms of MOP, this means that F must hold when the next event occurs. The operators "U" and "R" are duals of each other. "U" is "until": "F 1 U F 2 " means "either F 2 must hold now, or F 1 must hold until F 2 eventually holds". "&lt;&gt; F" can be defined as "true U F". The operator "R" means "release". "F 1 R F 2 " means "once F 1 holds, F 2 can be released in the next time step;" F 2 must hold at all periods before F 1 holds, and it must hold during the first time step in which F 1 holds. "[] F" can be defined in terms of "R" as "false R F".</p><p>Below is an example LTL property, which states that all requests of a resource must be immediately fulfilled (grant) until the end of a program:</p><p>(request implies o grant) U end The property does not hold until end occurs, and it must be that any request is fulfilled until such a time as end occurs.</p><p>FSMs are generated from LTL formulae in much the same way as from EREs, following a technique described in [32, Figure <ref type="figure" target="#fig_25">39</ref> shows the equations used to derive FSMs. Monitors generated by our current LTL plugin report violation when a state is reached where there is no way to reach validation, and vice versa. To handle this, we use an LTL satisfiability checker on each derived formula. Not only does this allow us to collapse unsatisfiable and tautological states, but also it allows us to perform minimization on the fly (by comparing states to each other using "iff" in the SAT solver). This minimization could be handled by the FSM plugin, but since we must check for unsatisfiable and tautological states to correctly implement the LTL monitoring algorithm, we perform the minimization on the fly.</p><p>Figure <ref type="figure" target="#fig_2">40</ref> shows the output FSM for the example given above. Note that the states validation and violation are named so that LTL properties properly allow validation and violation as output categories. Note that the validation and violation states cannot be left on any input.</p><p>As mentioned in Sect. 6.1, the property enable sets for LTL formulae are computed using the algorithm in Fig. <ref type="figure" target="#fig_2">34</ref> after a formula has been converted to an FSM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Past time linear temporal logic</head><p>Past time linear temporal logic is similar to LTL, except that all operators refer to the past. Some safety properties are more Fig. <ref type="figure" target="#fig_2">41</ref> PTLTL syntax easily expressed in terms of the past than the future, e.g., the property that a user authentication be required before accessing some resource is most naturally expressed as "access implies &lt; * &gt; authenticate", e.g., that an access requires an authentication at some point in the past. Monitors generated from PTLTL formulae also have the quality of validating or violating on every event because the past is already known. This contrasts with LTL monitors, which can also be in an intermediate, ?, state. In addition, once an LTL monitor validates or violates, it is always violated or validated, whereas PTLTL is allowed to change on each event. The earlier caveat of LTL not guaranteeing that its formula holds for all program executions applies to PTLTL, as well.</p><p>Figure <ref type="figure" target="#fig_2">41</ref> shows the syntax for our PTLTL plugin. The operators "not", "and", "or" , and "implies" are the standard boolean connectives. The operator "[*]" stands for "always in the past", meaning the formula following it must hold at all times in the past, while "&lt; * &gt;" stands for "eventually in the past", meaning that the formula following it must either currently hold or it must have held somewhere previously in the trace. The operator "(*)" means "previously": the formula following it, say F, must hold in the previous time step; in terms of MOP, this means that F must have held when the previous event occurred. "S" means "since"; "F 1 S F 2 " means "either F 2 must hold now, or F 2 must have held in the past and F 1 must have held since then."; "&lt; * &gt; F" can be defined as "true S F."</p><p>Below is an example PTLTL property. In this property, the goal is to ensure that next is never called on an Iterator without first calling hasNext:</p><p>next implies (*)hasNext</p><p>The event definition should make sure that the call to the hasNext method actually returns true, as well. Recall that (*) means previously, so the property states that the event preceding next must be hasNext.</p><p>The original algorithm for PTLTL monitor generation, as outlined in <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b36">36]</ref>, works using a bitvector to keep the state of each temporal operator in the formula. A series of sequential assignments updates the bitvector as each event arrives. For example, "hold S acquire" would need one bitvector index to monitor. The assignment for this bitvector index would be "b[0] ‚Üê b[0] and hold or acquire". Figure <ref type="figure" target="#fig_26">42</ref> shows the assignments necessary for each PTLTL temporal operator. Note that if one of the operands to a temporal formula is itself a temporal formula, it will appear as a bitvector index in the assignment. is, then, essential to generate the assignments in the proper order (depth-first).</p><p>In <ref type="bibr" target="#b52">[52]</ref>, it was determined that a parallel series of assignments would be more efficient for monitoring PTLTL properties on an FPGA. Sequential assignments are parallelized by back substitution of terms for the bitvector index they computed. This back substitution in an assignment to b[n] is only performed, however, for bitvector indices b[m] that are computed before the assignment to b[n] in the original sequential assignments. For example, consider the following sequential bitvector assignments:</p><formula xml:id="formula_14">b[0] ‚Üê b[0] or e1 b[1] ‚Üê b[0] and b[2] or e2 b[2] ‚Üê e3</formula><p>When parallelized (we us to denote parallel assignments and ‚Üê for sequential), the code becomes:</p><formula xml:id="formula_15">b[0] b[0] or e1 b[1]</formula><p>(b[0] or e1) and b <ref type="bibr" target="#b1">[2]</ref> or e2 b <ref type="bibr" target="#b1">[2]</ref> e3</p><p>Note how "b[0] or e1" was substituted for "b[0]" in the assignment to b <ref type="bibr" target="#b0">[1]</ref> because the assignment to "b[0]" occurred before the assignment to b <ref type="bibr" target="#b0">[1]</ref> in the sequential code, while the assignment to b <ref type="bibr" target="#b1">[2]</ref> was not substituted, because b <ref type="bibr" target="#b1">[2]</ref> was computed after b <ref type="bibr" target="#b0">[1]</ref> in the sequential code.</p><p>Using the parallel assignments, it also becomes straightforward to generate an FSM by exhaustively computing and enumerating the reachable bitvectors. This allows us to easily compute the property enable sets of a PTLTL formula using the algorithm in Fig. <ref type="figure" target="#fig_2">34</ref> on the FSM generated from the formula. This is the strategy now used in JavaMOP, while BusMOP continues to use the parallel assignments.</p><p>Figure <ref type="figure" target="#fig_2">43a</ref>, b shows the monitor pseudocode for the example above. Figure <ref type="figure" target="#fig_2">43a</ref> shows the parallel assignment format (which, in this case, is equivalent to the sequential code), while Fig. <ref type="figure" target="#fig_2">43b</ref> shows the FSM output. Note that in the parallel assignments b[0] is initialized to false. In the parallel assignments, the output statement outputs the actual category. If it evaluates to false a violation is reported, if it evaluates to true a validation is reported. The FSM output uses aliases for validation and violation because, unlike in LTL, multiple states can be validation or violation states due to the manner in which the FSM is generated (e.g., n1 and n2 are both in the validation alias).</p><p>As mentioned in Sect. 6.1, the enable sets for PTLTL are computed by generating an FSM and using the FSM enable set computation algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Context-free grammars</head><p>Context-free grammars are nearly as widely adopted by the average programmer as are regular expressions. Numerous context-free parser generators such as Bison <ref type="bibr" target="#b13">[13]</ref> exist and are widely used. CFGs offer a level of expressibility greater than that of finite-monitor logics, and allow for the specification of properties that involve proper nesting and a notion of counting.</p><p>Figure <ref type="figure" target="#fig_27">44</ref> shows the syntax for our CFG plugin, where "," separates rules and "|" multiple alternatives within one rule. The "-&gt;" separates the non-terminal head of a production from its body. While a CFG can contain epsilon, the language it represents will have the empty string removed from it. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S -&gt; P endThread, P -&gt; P acquire P release | epsilon</head><p>In this example, there are three events: acquire, release, and endThread, and one non-terminal, S. The fail category is reported whenever the program cannot have followed the proper lock nesting property, e.g., releasing a lock more times than it was acquired or not releasing it enough times before the end of the Thread. In addition, we could handle match, which is reported whenever our locking discipline is faithfully completed.</p><p>The CFG plugin uses a generalized LR (GLR) parser. Specifically, when an ambiguity is encountered, instead of choosing one of the particular alternatives, all are tried in parallel. The parser accepts a string if any of its parallel parses does and rejects it if there is no possible parse in any of the alternate parses. Thus, unlike normal LR(1) parsers, the GLR algorithm is capable of recognizing all context-free languages. This parsing algorithm is both online and the overhead relative to a normal LR parser is proportional to the amount of ambiguity in the grammar. The LR parser tables are generated using Knuth's LR(1) parser table generation algorithm as presented in <ref type="bibr" target="#b1">[2]</ref>. The table, which constitutes the monitor pseudocode, used for monitoring our nested locking example can be seen in Fig. <ref type="figure" target="#fig_2">45</ref>. 16  As with the other logic plugins, we have the problem of not knowing when the last event of a trace slice will be 16 This is actually an LALR table, which is smaller than the full LR table, see <ref type="bibr" target="#b48">[48]</ref>.</p><p>Fig. <ref type="figure" target="#fig_3">46</ref> CFG enable E G defining equations seen. Thus, the plugin classifies traces into {match, fail, ?} (see Sect. 4.1.1). Originally, in <ref type="bibr" target="#b47">[47]</ref>, this was done by cloning the state of the monitor and seeing if the copy would accept on an end of trace event. After examining how the LR tables were constructed we noticed in <ref type="bibr" target="#b48">[48]</ref> that if our parser is able to reduce on seeing an end of trace at all, then it must accept after some number of reductions. Thus, we just need to check if we can reduce assuming we are at the end of the trace instead of actually preforming the reductions. We refer to this concept as guaranteed acceptance. As a result, we no longer need to copy our parser's state and can just check whether the current state is the member of the set of states that would reduce at the end of the trace. More information on how to monitor CFGs can be found in <ref type="bibr" target="#b48">[48]</ref>. <ref type="foot" target="#foot_12">17</ref>It should be noted that guaranteed acceptance is specific to monitoring and is not suitable for use in most parser generators since they do not need to only verify that a string is in the language but also to assemble an abstract syntax tree or produce some other side effects. Since these side effects are performed as part of the reductions omitting them is not, in general, possible. There are a number of open optimization opportunities, e.g., those suggested in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref>. In addition, there are GLR-specific opportunities to share common segments of the copied stacks. Therefore, there is still room for generating better CFG monitors, though the current ones were satisfactory in our practical experiments.</p><p>To find the enables sets of a CFG, we find the least fixed point of the equations in Fig. <ref type="figure" target="#fig_3">46</ref>. Here, informally, G(A) is the set of events generated by the CFG, if the symbol A were used as the start symbol of the CFG. The rule G(Œ≤ 1 Œ≤ 2 ) = {S ‚à™ T | S ‚àà G(Œ≤ 1 ), T ‚àà G(Œ≤ 2 )} generalizes this notion to entire strings of symbols. P is the enable sets function generalized to strings that include both non-terminals and terminals. For example, the prefixes of abT B for B would be {{a, b} ‚à™ S | S ‚àà G(T )}. For a rule, A ‚Üí Œ≤ 1 BŒ≤ 2 , P(B) needs to cope with the fact that A has its own enables set of possible prefixes. Thus, its definition unions possible prefixes of A with the sets of symbols that are generated by Œ≤ 1 . The rest of MOP only needs to know sets of prefixes for events so enable E G is just the restriction of P to events. Past time linear temporal logic with calls and returns (PTC-aRet) <ref type="bibr" target="#b56">[56]</ref> is a specialization of CaRet <ref type="bibr" target="#b3">[4]</ref> for safety properties and their monitoring. CaRet is an extension of LTL with calls and returns. Matching call/return events in traces allows one to express program trace properties not expressible using plain LTL. One can express properties related to the contents of the program execution stack, such as "function g is always called from within function f ", or one can express properties that are allowed to be temporarily validated/violated, such as "a user u may never directly access a password file (but may access it through system procedures)" <ref type="bibr" target="#b56">[56]</ref>. Motivated by practical reasons, PTCaRet distinguishes call and return points from begin and end points: the former take place in the method caller's context and the latter take place in the callee's context. This distinction allows more flexible and elegant expressions of properties.</p><p>PTCaRet is a past time variant of CaRet. Essentially, it is PTLTL extended by adding abstract variants of temporal operators. Figure <ref type="figure" target="#fig_28">47</ref> shows the syntax for our PTCa-Ret plugin. PTCaRet includes all operators from PTLTL: the standard boolean operators and the temporal operators. PTCaRet, as mentioned, also has abstract temporal operators. The semantics of abstract operators is defined exactly as the semantics of their concrete counterpart operators, but they operate on the abstract version of the trace from which all the intermediate events of terminated method or function executions deeper in the call stack are erased <ref type="bibr" target="#b56">[56]</ref>. In other words, abstract operators refer only to the trace of the current call stack level. In the syntax of the abstract temporal operators, " * " and "S" are followed by "a", meaning that the operator is an abstract variant of the concrete counterpart operator. The operators "[ * a]", "&lt; * a&gt;", "( * a)", and "Sa" stand for "abstract always in the past", "abstract eventually in the past", "abstract previously in the past", and "abstract since", respectively.</p><p>PTCaRet also includes several derived operators which are convenient in practice, both for temporal and for stack Fig. <ref type="bibr" target="#b48">48</ref> PTCaRet example operators. The operators "@b" and "@c", read "at begin" and "at call" respectively, are derived temporal operators meaning that the formula they take as an argument must hold "at the Beginning of the execution of the current function" and "at the context when the current function was Called", respectively. The semantics of the derived stack operators are defined exactly as the semantics of their abstract counterpart operators, but they operate only on the begin/call points on the abstract version of the trace. For example, derived stack operators defined on "begin" operate on a trace where we have filtered out all events except events in "begin" contexts from the abstract trace. Similar to the abstract temporal operators, in the syntax of the derived stack operators, "*" and "S" are followed by "s", meaning that the operator is a derived stack variant of the concrete counterpart operator. In addition to this keyword, either of "@b", "@c", or "@bc" follows right after "s", to indicate that the derived stack operator is defined on "begins", "calls", or "both begins and calls", respectively. In particular, the operators "[ * s@b]", "&lt; * s@b&gt;", and "Ss@b" are the derived stack operators on the beginnings of method calls, meaning "always on begin contexts on abstract traces", "eventually on begin contexts on abstract traces", and "since on begin contexts on abstract traces", respectively. The derived stack operators for "calls" and "begins" are defined similarly. Figure <ref type="figure" target="#fig_5">48</ref> shows an example PTCaRet property from <ref type="bibr" target="#b56">[56]</ref>, which states that a program carrying out a critical multi-phase task should satisfy the following safety properties when execution enters the second phase:</p><p>-Execution entered the first phase in the same procedure; -Resources acquired within the same procedure since the first phase must be released; -The caller of the current procedure must have had approval for the second phase; -Task is executed directly or indirectly by the procedure safe_exec.</p><p>Since the operators "Sa", "@c", and "&lt; * s@b&gt;" are abstract temporal operators, the example abstracts out events that happened in the procedure calls from within the current procedure.</p><p>Our technique for generating monitors from PTCaRet formulae is inspired from and generalizes the synthesis from plain PTLTL formulae (Sect. 6.4). The difference is that two The former plays the same role as the bitvector b from PTLTL (Sect. 6.4). The other bitvector, beta[], stores the validity status of the subformulae corresponding to abstract temporal operators. a new function or method is called, a copy of the abstract bitvector is pushed onto the top of a stack. When the function or method ends, the bitvector is popped from the stack, effectively erasing all updates that happened during the called function or method.</p><p>Figure <ref type="figure" target="#fig_29">49</ref> shows the output for Fig. <ref type="figure" target="#fig_5">48</ref>. PTCaRet uses the sequential assignments explained in Sect. 6.4. In this example, we use the bitvector names and roles from previously, alpha[] and beta[]. Note that all elements in alpha[] and beta[] are initialized to false. When a new function or method is called, a copy of beta[] is pushed onto the top of a stack and when the function or method returns, the bitvector is popped from the stack, replacing beta[], while alpha[] stays as it is. Updating bitvectors before output is related to "since" operators, processing inner "since" operators before the outer ones. Updating bitvectors after output is related to "previously" operators, processing outer "previously" operators before the inner ones. Thus, bitvector updates before output are in order and bitvector updates after output are in reverse order. We refer to <ref type="bibr" target="#b56">[56]</ref> for detailed monitor synthesis algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this article, we presented an overview of the MOP framework. We detailed the organization of the framework, and presented the formal syntax of specifications. We presented an in depth discussion of the two current instances of MOP: JavaMOP and BusMOP.</p><p>JavaMOP is an MOP instance for monitoring Java programs. JavaMOP specifications are compiled into AspectJ <ref type="bibr" target="#b41">[41]</ref> aspects, which can be weaved into a program a user wishes to monitor using any standard AspectJ compiler such as ajc <ref type="bibr" target="#b6">[6]</ref>. The theory of parametric monitoring was presented in the context of JavaMOP (currently, the only parametric instance of MOP). We discussed both naive and optimized monitoring algorithms for parametric properties. One important optimization, the enable set optimization, was explained in detail. We explained the two different modes of indexing from JavaMOP (centralized and decentralized), and we introduced three binding modes, which can be used as a filter on the number of handlers invoked by a given monitor. An evaluation of JavaMOP shows that, in general, parametric monitoring of Java programs is efficient.</p><p>BusMOP is an instance for monitoring PCI bus peripherals. BusMOP specifications are compiled into hardware design language code suitable for implementation on an FPGA <ref type="bibr" target="#b52">[52]</ref>. Using a monitor implemented on an FPGA, it is possible to ensure the proper interaction between a peripheral and the system to which it is attached. BusMOP, in general, adds no runtime overhead to the monitored system.</p><p>Each logic plugin currently implemented in the MOP framework was presented. For each logic plugin, we explained the syntax of the implemented logical formalism, how to generate a monitor, as well as how to generate enable sets.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 Runtime monitoring breakdown</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 A</head><label>3</label><figDesc>Fig. 3 A BusMOP specification (SafeCounterModify)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 Architecture of MOP</figDesc><graphic coords="7,117.13,56.96,360.52,258.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 MOP syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 JavaMOP syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 8 M</head><label>8</label><figDesc>= (S, E, C, ƒ±, œÉ, Œ≥ ) is a monitor for property P : E * ‚Üí C if Œ≥ (œÉ (ƒ±, w)) = P(w) for each w ‚àà E * . Every monitor M defines the property P M : E * ‚Üí C with P M (w) = Œ≥ (œÉ (ƒ±, w)); We write P M to denote the property defined by M. Monitors M and M are equivalent, written M ‚â° M if P M = P M .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Naive monitoring algorithm B X</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 11</head><label>11</label><figDesc>Fig. 11 Parametric property (UnsafeMapIterator)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13</head><label>13</label><figDesc>Fig.<ref type="bibr" target="#b13">13</ref> Following the run of Fig.12</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 14</head><label>14</label><figDesc>Fig. 14 Property and parameter enable sets for UnsafeMapIterator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 15 Fig. 16</head><label>1516</label><figDesc>Fig. 15 Unsound usage of the enable set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 17</head><label>17</label><figDesc>Fig. 17 Optimized monitoring algorithm D X</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 20</head><label>20</label><figDesc>Fig.<ref type="bibr" target="#b20">20</ref> Decentralized indexing for the JavaMOP spec in Fig.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 21</head><label>21</label><figDesc>Fig. 21 Decentralized indexing monitoring code automatically generated by JavaMOP for updateV</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 22</head><label>22</label><figDesc>Fig. 22 Trace slices for binding mode example trace</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 23</head><label>23</label><figDesc>Fig. 23 Trace slices for connectedness example trace</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 24</head><label>24</label><figDesc>Fig.<ref type="bibr" target="#b24">24</ref> Average Percent Runtime Overhead for Tracematches (TM), C X , and D X (convergence within 3%, OOM Out of Memory). D X , at its worst, has less than an order of magnitude of overhead</figDesc><graphic coords="25,130.36,247.58,131.56,98.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 26</head><label>26</label><figDesc>Fig. 26 Monitoring Device</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 28</head><label>28</label><figDesc>Fig. 28 InterruptFix specification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Fig. 29</head><label>29</label><figDesc>Fig. 29 SafeConversionSpeed specification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 30 Fig. 31</head><label>3031</label><figDesc>Fig. 30 NoDisableWhileConverting specification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Fig. 32</head><label>32</label><figDesc>Fig. 32 FSM syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Fig. 35</head><label>35</label><figDesc>Fig. 35 ERE syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 36</head><label>36</label><figDesc>Fig. 36 ERE Derivative Equations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 38</head><label>38</label><figDesc>Fig. 38 LTL syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 39</head><label>39</label><figDesc>Fig. 39 LTL Derivative Equations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Fig. 42</head><label>42</label><figDesc>Fig. 42 PTLTL assignment equations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Fig. 44</head><label>44</label><figDesc>Fig. 44 CFG syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Fig. 47</head><label>47</label><figDesc>Fig. 47 PTCaRet syntax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Fig. 49</head><label>49</label><figDesc>Fig. 49 PTCaRet example output</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>FSM example way the algorithm determines that it necessary to split is by considering two equivalence classes C 1 and C 2 and an input, e. For each state s in C 1 , if s goes to a state in C 2 on e then it goes into class C 11 , otherwise it goes to class C 12 . Classes are continuously split by other classes until a fixed point is reached. When a fixed point is reached, each equivalence class becomes a state in the final machine.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Overhead is exactly 0% if no recovery actions are performed. Recovery actions take up a tiny portion of the bus bandwidth, and could theoretically add non-zero runtime overhead. This was negligible in practice, even with continuously recovering properties.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The creation keyword has no effect in BusMOP specifications.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>We intend to incorporate program static analysis to further reduce runtime overhead soon<ref type="bibr" target="#b16">[16]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>This algorithm was referred to as C + X in<ref type="bibr" target="#b20">[20]</ref>. The distinctions between C X and C + X are small, and elided for conciseness.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>The '*' tells AspectJ to weave at any method that begins with add.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>As demonstrated in<ref type="bibr" target="#b53">[53]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>We also plan to extend our design to PCI-E, as mentioned in Sect.3.3.1.   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_7"><p>While technically it is always possible for a faulty peripheral to disrupt the bus by altering the state of the signals, in practice the described approach is effective since access to the bus is mediated by three-state buffers enabled by GNT#.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_8"><p>The same is true for @validation and @violation for PTLTL (Sect. 6.4).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_9"><p>Because the monitor is implemented on a peripheral card, overhead from the users perspective can only occur by increased bus traffic caused by specification handlers. Specification handlers typically run infrequently, and do not add much traffic to the PCI bus even when they do run.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_10"><p>In addition, one must use the logic repository XML syntax, which distinguishes the events from the property.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_11"><p>Though note that in the case of BusMOP, finite state machines are not used for PTLTL in favor of using parallel assignments (see 6.4).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_12"><p>Note that normal LR(1) and LALR(1) parsing are used in<ref type="bibr" target="#b48">[48]</ref>, while in the meanwhile, as presented here, we generalized the techniques in<ref type="bibr" target="#b48">[48]</ref> to work with arbitrary context-free languages.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments Special thanks to Rodolfo Pellizzoni and Marco Caccamo, co-authors on <ref type="bibr" target="#b52">[52]</ref>, without whom the work on BusMOP would never have been completed. Also thanks to Choonghwan Lee for creating the JavaMOP installer program, and Michael Pradel for discussions that lead to the inclusion of the full-binding and connectedness modifiers of JavaMOP. Thanks to Klaus Havelund for using JavaMOP in his class at Caltech and Matthew Dwyer for using it at the University of Nebraska, thus forcing us to iron out the numerous bugs in earlier implementations.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported in part by NSF grants CCF-0916893, CNS-0720512, and CCF-0448501, by NASA contract NNL08AA23C, and by a Samsung SAIT grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">jContractor: Bytecode instrumentation techniques for implementing DBC in Java</title>
		<author>
			<persName><forename type="first">P</forename><surname>Abercrombie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karaorman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;02)</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">70</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers, Principles, Techniques, and Tools</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="215" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Adding trace matching with free variables to AspectJ</title>
		<author>
			<persName><forename type="first">C</forename><surname>Allan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Avgustinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuzins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Lhot√°k</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>De Moor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sereni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sittampalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tibble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Systems, Languages and Applications (OOPSLA&apos;05)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="345" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A temporal logic of nested calls and returns</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Etessami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems (TACAS&apos;04)</title>
		<imprint>
			<biblScope unit="volume">2988</biblScope>
			<biblScope unit="page" from="467" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Berlin</forename><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><surname>Aspectc++</surname></persName>
		</author>
		<ptr target="http://www.aspectc.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<ptr target="http://eclipse.org/aspectj/" />
	</analytic>
	<monogr>
		<title level="j">AspectJ</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Making trace monitors feasible</title>
		<author>
			<persName><forename type="first">P</forename><surname>Avgustinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tibble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>De Moor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming, Systems, Languages and Applications (OOPSLA&apos;07)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="589" to="608" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Spec# programming system: An overview</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Construction and Analysis of Safe, Secure and Interoperable Smart devices (CASSIS&apos;04)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3362</biblScope>
			<biblScope unit="page" from="49" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;05)</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Sipma</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">144</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Rule-Based Runtime Verification</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Verification, Model Checking, and Abstract Interpretation (VMCAI&apos;04)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2937</biblScope>
			<biblScope unit="page" from="44" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Rule systems for run-time monitoring: from EAGLE to RULER</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rydeheard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Comput</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Jass-Java with Assertions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bartetzko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wehrheim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;01)</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="103" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<ptr target="http://www.gnu.org/software/bison/" />
		<title level="m">Bison</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Garner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bentzur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Frampton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Z</forename><surname>Guyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hosking</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Phansalkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stefanoviƒá</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Vandrunen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Von Dincklage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The DaCapo benchmarks: Java benchmarking development and analysis</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="169" to="190" />
		</imprint>
	</monogr>
	<note>Systems, Languages and Applications (OOPSLA&apos;06)</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">J-LO, a tool for runtime-checking temporal assertions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>Aachen</pubPlace>
		</imprint>
		<respStmt>
			<orgName>RWTH Aachen University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dependent advice: A general approach to optimizing history-based aspects</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Aspect-Oriented Software Development (AOSD&apos;09)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A staged static program analysis to improve the performance of runtime monitoring</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Lhot√°k</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP&apos;07)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4609</biblScope>
			<biblScope unit="page" from="525" to="549" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Instumenting C programs with nested word monitors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Checking Software (SPIN&apos;07)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4595</biblScope>
			<biblScope unit="page" from="279" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A formal monitoring-based framework for software development and analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>D'amorim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Formal Engineering Methods (ICFEM&apos;04)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3308</biblScope>
			<biblScope unit="page" from="357" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient formalism-independent monitoring of parametric properties</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Software Engineering (ASE&apos;09)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="383" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Towards monitoring-oriented programming: A paradigm combining specification and implementation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;03)</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="108" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">MOP: An efficient and generic runtime verification framework</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Systems, Languages and Applications (OOPSLA&apos;07)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="569" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Parametric trace slicing and monitoring</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems (TACAS&apos;09)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5505</biblScope>
			<biblScope unit="page" from="246" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Event-based runtime verification of Java programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Amorim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSOFT Softw. Eng. Notes</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The Temporal Rover and the ATG Rover</title>
		<author>
			<persName><forename type="first">D</forename><surname>Drusinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Checking and Software Verification (SPIN&apos;00)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">Eagle</forename><surname>Technology</surname></persName>
		</author>
		<ptr target="http://www.eagledaq.com/display_product_36.htm" />
		<title level="m">PCI 703 Series User&apos;s Manual</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Eiffel</forename><surname>Language</surname></persName>
		</author>
		<ptr target="http://www.eiffel.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Relational queries over program traces</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldsmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>O'callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Systems, Languages and Applications (OOPSLA&apos;05)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="385" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nunez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Approaches to Testing and Runtime Verification (FATES/RV&apos;06)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Wolff</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4264</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Monitoring Java programs with Java Pat-hExplorer</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;01)</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="97" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Monitoring Java programs with Java Pat-hExplorer</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;01)</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">55</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Monitoring programs using rewriting</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Software Engineering (ASE&apos;01)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="135" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m">Runtime Verification (RV&apos;02)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">70</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m">Runtime Verification (RV&apos;04)</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">113</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Synthesizing Monitors for Safety Properties</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems (TACAS&apos;02)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2280</biblScope>
			<biblScope unit="page" from="342" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Efficient monitoring of safety properties</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Softw. Tools Technol. Transf</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="173" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall Intl</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">An n log n algorithm for minimizing states in a finite automaton</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Information technology-syntactic metalanguage-Extended BNF</title>
		<author>
			<persName><surname>Iso/Iec</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">14977. 1996</date>
			<pubPlace>Geneva, Switzerland</pubPlace>
		</imprint>
		<respStmt>
			<orgName>ISO</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<ptr target="http://www.jboss.org" />
		<title level="m">JBoss</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">An overview of AspectJ</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hilsdale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hugunin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP&apos;01)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2072</biblScope>
			<biblScope unit="page" from="327" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menhdhekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Loingtier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP&apos;97)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1241</biblScope>
			<biblScope unit="page" from="220" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Formally specified monitoring of temporal properties</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ben-Abdallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Europoean Conference on Real-Time Systems (ECRTS&apos;99)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">JML: notations and tools supporting detailed design in Java</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ruby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming, Systems, Languages and Applications (OOPSLA&apos;00)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="105" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">The design and implementation of P2V, an architecture for zero-overhead online verification of software programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Forin</surname></persName>
		</author>
		<idno>MSR-TR-2007-99</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Finding application errors and security flaws using PQL: a program query language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">B</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming, Systems, Languages and Applications (OOPSLA&apos;07)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="365" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Efficient monitoring of parametric context-free patterns</title>
		<author>
			<persName><forename type="first">P</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Software Engineering (ASE &apos;08)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="148" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Efficient monitoring of parametric context-free patterns</title>
		<author>
			<persName><forename type="first">P</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="180" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Object-Oriented Software Construction, 2nd edn</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<author>
			<persName><surname>Sig</surname></persName>
		</author>
		<ptr target="http://www.pcisig.com" />
		<title level="m">Conventional PCI 3.0, PCI-X 2.0 and PCI-E 2.0 Specifications</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Coscheduling of real-time tasks and PCI bus transactions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pellizzoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Buy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caccamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sha</surname></persName>
		</author>
		<ptr target="http://netfiles.uiuc.edu/rpelliz2/www/techreps/" />
	</analytic>
	<monogr>
		<title level="m">University of Illinois at Urbana-Champaign</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Hardware runtime monitoring for dependable cots-based real-time embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pellizzoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caccamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Real-Time System Symposium (RTSS&apos;08)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="481" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Handling mixed-criticality in soc-based real-time embedded systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pellizzoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-Y</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caccamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Embedded Software (Emsoft&apos;09)</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">The temporal logic of programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Computer Science (FOCS&apos;77)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="46" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Rewriting-based techniques for runtime verification</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Softw Eng</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="197" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Synthesizing monitors for safety properties-this time with calls and returns</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;08)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5289</biblScope>
			<biblScope unit="page" from="51" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Generating optimal monitors for extended regular expressions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ro≈üu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;03)</title>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="162" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Runtime Verification (RV&apos;03)</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Sokolsky</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">89</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<ptr target="http://www.sable.mcgill.ca/soot/" />
		<title level="m">Soot website</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Regular expression search algorithm</title>
		<author>
			<persName><forename type="first">K</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="419" to="422" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Soot -a Java optimization framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vall√©e-Rai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Co</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IBM Centre for Advanced Studies Conference (CASCON&apos;99)</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="125" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<author>
			<persName><forename type="first">Inc</forename><surname>Xilinx</surname></persName>
		</author>
		<ptr target="http://www.xilinx.com/support/documentation/boards_and_kits/ug084.pdf" />
		<title level="m">Virtex-4 ML455 PCI/PCI-X Development Kit User Guide</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
