<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Supporting Concurrency, Communication, and Synchronization in Human-Computer Interaction-The Sassafras UIMS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ralph</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">ECRC</orgName>
								<address>
									<addrLine>Arabellastrasse 17</addrLine>
									<postCode>D-8000</postCode>
									<settlement>Munich 81</settlement>
									<region>West Germany</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Supporting Concurrency, Communication, and Synchronization in Human-Computer Interaction-The Sassafras UIMS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DF023238F3F4962A2B0C07B8E61B6673</idno>
					<note type="submission">Received June 1986; revised October 1986, accepted October 1986</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>1.3.6 [Computer Graphics]: Methodology and Techniqueslanguages, interaction techniques</term>
					<term>H.1.2 [Information Systems]: User/Machine Systems--human factors</term>
					<term>D.2.2 [Software Engineering]: Tools and Techniques-user interfaces Concurrency, message passing, user interface management systems, user interfaces</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Sassafras is a prototype User Interface Management System (UIMS) specifically designed to support a wide range of user interface styles. In particular, it supports the implementation of user interfaces where the user is free to manipulate multiple input devices and perform several (possibly related) tasks concurrently.</p><p>These interfaces can be compactly represented and efficiently implemented without violating any of the rules of well-structured programming. Sassafras also supports elaborate run-time communication and synchronization among the modules that make up the user interface. This is needed to implement user interfaces that have context-sensitive defaults, and it simplifies recovery from semantic errors.</p><p>Sassafras is based on a new language for specifying the syntax of human-computer dialogues known as Event-Response Language (ERL) and a new run-time structure and communication mechanism for UIMSs known as the Local Event Broadcast Method (LEBM). Both ERL and LEBM are described in detail, and implementation techniques are presented. The effectiveness of Sassafras is demonstrated by describing two interfaces that have been implemented with Sassafras.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION 1 .l Motivation and Interest</head><p>The goal of Sassafras is to provide tools that aid in the development of better user interfaces. Within the scope of Sassafras, a user interface is that part of the software of an interactive system that presents displays to the user and collects commands from the user to be passed on to application routines for processing. l Ralph D. Hill Although it is difficult to arrive at a quantitative measure of user interface quality, by iteratively implementing, testing, and redesigning it is possible to arrive at a good user interface (e.g., <ref type="bibr" target="#b3">[4]</ref>). Thus the real goal of Sassafras is to provide tools that allow rapid repetition of this iteration and that can be used to develop better user interfaces. This is a far-too-general goal, so Sassafras was targeted specifically at user interfaces running on high-performance workstations. Also, it is assumed that the users of the interfaces produced will be experts in the use of the interactive system. Thus, the target context is highly skilled users using high-performance tools.</p><p>1.1.1 User Interface Development Systems. The iterative design approach to user interface development is widely recommended <ref type="bibr">[9, 24, 301.</ref> In this approach, a user interface design would first be roughed out and a prototype developed. On the basis of performance of users using the prototype, the design would be modified and a new prototype built (or the old one modified). This (re)designprototype-evaluate cycle should be repeated until the user interface is better than some standard, as determined by some measure chosen by the user interface designer.</p><p>Despite the recommendations for the use of this approach, it is rarely used; the problem is the high cost of implementing user interfaces. Because of the lack of appropriate implementation tools, time and money are usually exhausted before one cycle can be completed.</p><p>To reduce the high cost of implementing user interfaces, much effort has been directed toward the development of improved tools for the construction of user interfaces. The more advanced of these tools have been referred to as User Interface Management Systems (UIMSs) <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b33">33]</ref>. We prefer to use the term User Interface Development System (UIDS), as it more accurately reflects the emphasis of current systems.</p><p>Currently, research in UIDSs has two main directions: making it easier to specify user interfaces, and increasing the range of user interfaces that can be specified. The former is attracting the most interest by far. In general, the approach is to provide better languages or specification techniques.</p><p>In choosing the targeting of Sassafras with respect to these two directions, it was decided that the ease of use of a UIDS is irrelevant if the UIDS cannot support the type of interfaces that are desired. Hence, Sassafras concentrates on making major extensions to the range of the user interfaces that can be supported (on the assumption that better interfaces will be different interfaces), but makes no effort to make the specification process easier than it is with existing UIDSs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.2">Concurrency in User</head><p>Interfaces. There are three basic types of concurrency at the user interface:</p><p>(1) Concurrent output is exemplified by the simultaneous updating of several windows on a single display, or the simultaneous presentation of both acoustic and visual feedback or warning information in video games and process control.</p><p>(2) Concurrent input is characterized by multiple input devices supplying input to a single system simultaneously. This is possible with many workstations that have both a mouse and a keyboard. The presence of two input devices and an operating system that is able to accept input from both simultaneously implies support for concurrent input. (3) Concurrent dialogues are a form of concurrency whereby the user may supply input to several (possibly related) user interfaces simultaneously.</p><p>Concurrent output is independent of the other two forms but, for practical purposes, is a prerequisite. Similarly, concurrent input is a practical prerequisite for Concurrent dialogues. Concurrent dialogues allow the user to perform multiple (possibly related) tasks simultaneously. This is done by allowing several dialogues to proceed in parallel, using the concurrent input and output features. The dialogues may be closely related, such as changing the color of paint while painting in a paint program, or they may be loosely related, such as scrolling a list of compiler-generated error messages in one window while editing the source text of a program in another.</p><p>The first two types of concurrency are becoming common on modern workstations with bit-mapped displays and mice. The third is still rare, and is not supported by existing UIDSs.</p><p>It is reasonable to believe that the typical user of a computer system is not only fully capable of dealing with several dialogues using several input devices at the same time, but wants to do so, if these dialogues are directed toward an immediate goal <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr">131</ref>.' Hence, the lack of support for concurrent dialogues in existing UIDSs may be a major shortcoming.</p><p>1.2 Novel Features of Sassafras 1.2.1 Some Problems with UIDSs. Tanner and Buxton <ref type="bibr" target="#b31">[31]</ref> provide an extensive discussion of problems and issues that they feel must be addressed in future UIDS work. Two of the main problems they discuss are the lack of concurrency in user interfaces, and the separation of the syntactic level of the user interface from the application routines. These represent two serious problems that affect the usefulness of the UIDS:</p><p>(1) As discussed in the previous section, Buxton and Myers <ref type="bibr" target="#b4">[5]</ref> have demonstrated the value of two-handed, or concurrent, input in real-world tasks. Unfortunately, existing tools and environments do not encourage the use of this capability.</p><p>(2) In the development of most UIDSs, it is assumed that the user interface and the semantics of interactive systems can be implemented separately, and that there will be little or no information flow from the implementation of the semantics (the application) to the user interface. This creates a communication problem. There are many cases in which two-way communication between the user interface and application is needed. A simple example is a login and password verification dialogue. The user interface must collect the userid and password and pass them to the application for verification.</p><p>The application must be able to tell the user interface the result of the verification process so the login sequence can be repeated, or the dialogue continued.</p><p>Given that this communication is necessary for the development of highquality interfaces, the problem is to develop a UIDS structure that will accommodate it.</p><p>A third problem, not discussed by Tanner and Buxton, is a consequence of the above two, and the desire to use UIDSs in a realistic environment.</p><p>(3) In an environment where multiple concurrent dialogues may be used to perform related tasks, there will be a need to synchronize the dialogues. There will also be a need to allocate resources, such as screen space and input devices, to the dialogues. These problems are related in that they both require synchronization of some sort. 1.2.2 Major Features of Sassafras. The primary goal of Sassafras is to address the three key problems with UIDSs identified in the previous sections: their inability to handle concurrent dialogues, the lack of facilities to support communication among the various components of an interactive system, and their inability to deal with resource allocation and synchronization problems. These problems reduce to the following three requirements of a UIDS:</p><p>-Support for multiple concurrent dialogues. -Provision of a mechanism for communicating information (user input, state information, requests for information or processing) among the modules that support these dialogues, and with the input devices, application routines and other modules that make up the interactive system. -Provision of a mechanism for synchronizing these communicating dialogues and modules to ensure consistency of interface behavior and that resources are allocated safely and consistently.</p><p>Two key elements of a UIDS that satisfies these requirements have been developed. They are -For specifying the syntax of concurrent dialogues a language that deals with localized concurrency, such as concurrency in a logically related set of subdialogues that should be specified as a single unit. This language is known as Event-Response Language (ERL), and is based on specifying system responses to user-generated events. (ERL is a practical variation on Event-Response Systems (ERS), a new type of language recognition automaton developed in [W)</p><p>-A method for communicating among and synchronizing the modules that make up an interactive system. This method is known as the Local Event Broadcast Method (LEBM), since it treats each user interface as a cluster of modules that use a broadcast scheme to transmit events. (Large and complex interfaces can be decomposed into several clusters.) Restrictions are placed on event passing within and among clusters of modules so that LEBM can be used as a synchronization mechanism. (Event passing in LEBM is similar to asynchronous message passing when used as a concurrency control construct.)</p><p>Both ERL and LEBM are novel contributions to the field of user interface specification and implementation.</p><p>When combined, they can form the basis of a powerful UIDS that can support concurrent dialogues of realistic complexity in an efficient and well-structured manner. Sassafras is a prototype UIDS that has been implemented to demonstrate these features of ERL and LEBM, and to gain experience with concurrent user interfaces. It has been implemented</p><p>in the Interlisp-D programming language <ref type="bibr" target="#b35">[35]</ref> on a Xerox 1109 (Dandetiger) workstation. As a prototype, Sassafras is complete: It has been used to implement the user interface to its own run-time environment.</p><p>Unfortunately, Sassafras still relies heavily on Interlisp-D for support tools (editors and run-time debuggers), so it is not usable by persons unfamiliar with the Interlisp-D environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">The Structure of This Paper</head><p>The next section briefly presents a general structure for UIDSs. This is used in the following sections to help explain the structure of Sassafras and the functions of ERL and LEBM. Section 3 begins with an informal presentation of ERL and LEBM, followed by several example dialogue fragments. The fourth section describes two sample interfaces that have been developed with Sassafras and discusses their major features. The final section discusses many important features of Sassafras (and ERL and LEBM) and some general discoveries about the design and use of UIDSs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">THE STRUCTURE OF UlDSs</head><p>There are three primary phases in the design, development, and testing of a user interface. These three phases provide an initial division of a UIDS. They are preparation, run-time, and follow-up (see Figure <ref type="figure">1</ref>).2 The preparation phase produces a user interface specification and, in current systems, is the most complex phase. The run-time phase supports the execution of this specification, and collects data during usage. These data can be analyzed during the follow-up phase in an effort to locate weaknesses in the user interface design. Each of these phases is discussed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preparation</head><p>The preparation phase involves the design and specification of the interface, and the associated documentation.</p><p>The primary objective is to produce an executable specification of the interface. The structure of this phase is illustrated in Figure <ref type="figure">2</ref>. Following is a discussion of the major components of the structure.</p><p>Icon builder and icon library: The icon library consists of diagrams and pictograms that are used as tracking symbols, icons, and elements of diagrams in user interfaces. The icons are constructed with an icon builder.</p><p>IM builder and IM library: An interaction module (IM) implements an interaction technique. An interaction technique is a "minidialogue" in which the user 0 Ralph D. Hill and the user interface interact; the objective is to allow the user to provide some specific unit of input. The simplest possible interaction technique provides no prompt or feedback to the user and simply reads a character of input from the keyboard. More elaborate interaction techniques might provide for rubber-band line drawing (the input being the series of points making up the final sequence of line segments). The interaction modules provide the components for lexical level of the user interface (as defined by Foley and van Dam <ref type="bibr">[14, p. 2201)</ref>.</p><p>Dialogue specification: The syntactic level of the user interface is encoded in a dialogue specification language (DSL), a language that allows the user interface designer to specify the syntax of the language that the user will use when interacting with the user interface. This specification can be used in two ways: It can be (automatically) evaluated in an effort to discover potential problems with the interface <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b28">28]</ref>,</p><p>and it can be used to generate an implementation of the interface.</p><p>Application interface specification: The specification of the user interface must include an interface to the semantics of the system. These semantics are usually implemented as a set of application routines coded in some traditional programming language. Interface assembler: The interface assembler is used to assemble the pieces of the user interface; that is, it is used to link the dialogue specification with appropriate interaction techniques and icons, and the application routines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Run-Time</head><p>The run-time support component of UIDSs is a relatively unexplored area, although efforts are being made in the area (e.g., [ll] and <ref type="bibr" target="#b15">[16]</ref>). Most existing UIDSs are built on top of graphics packages or window systems and rely on the input and output facilities of these systems to provide I/O support at run time. The user interface runs on top of this package, with the semantic routines as an additional, higher layer (see Figure <ref type="figure">3</ref>). The flow of control and information between the layers varies from system to system, suggesting that there is no consensus on the issues of control flow and information flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Follow-Up</head><p>The run-time system should record information such as user comments, user errors, and time between commands for later analysis. During follow-up, this information must be studied to attempt to discover weaknesses or errors in the interface. The UIDS should include tools for analyzing this information. A great deal of development work is currently being done on analysis tools in other environments (e.g., <ref type="bibr" target="#b22">[23]</ref> and <ref type="bibr" target="#b25">[25]</ref>). When these tools are refined to a useful level, they should be incorporated into UIDSs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE INTERNALS OF SASSAFRAS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Introduction</head><p>This section concentrates on the two key components that underlie Sassafras: Event-Response Language and the Local Event Broadcast Method. Both ERL and LEBM are novel contributions to the field of user interface specification and implementation.</p><p>First, both ERL and LEBM will be described informally (they are formally defined in [HI). A simple but realistic example is then used to illustrate their use. Finally, a small dialogue fragment is used to illustrate concurrency and synchronization.</p><p>3.1.1 Euent-Response Language. Event-Response Language (ERL) is a language for encoding the syntax of a human-computer dialogue that was originally inspired by <ref type="bibr" target="#b20">[21]</ref>. In the structure of Section 2, ERL is a dialogue specification language. Recursive transition networks currently, are the most popular basis for dialogue specification languages (e.g., <ref type="bibr" target="#b21">[22]</ref> and <ref type="bibr" target="#b34">[34]</ref>). Because of the structure of ERL, the specifications of concurrent dialogues encoded in ERL are more compact and maintainable than they would be if they were encoded in a recursive transition network (RTN)-based language. Also, the ERL encodings can be efficiently interpreted or compiled, making ERL a strong alternative to RTN-based dialogue specification languages.</p><p>The main elements of ERL are incoming events, outgoing events, and flags. All input to an ERL processor comes through a queue of incoming events. An event is a signal that something has occurred, and it may carry data relevant to that event (e.g., an event might signal that a new sample of tablet input is available and carry the sampled point as data). Incoming events are the only form of input to an ERL. Outgoing events can be sent to other modules in a user interface and are the only form of output in ERL. Flags are local variables used to encode the state of the system and control execution. They are primarily Boolean variables but can have other information associated with them. (Because of their optional value fields, events and flags are probably best thought of as special types of records.)</p><p>An ERL specification consists of a list of rules. Each rule specifies a response to some external event or an action to be taken when some state is entered. Rules are of the form condition --+ action where the condition is either the name of an event followed by a list of flags or simply a list of flags. If the condition consists only of a list of flags, the rule is known as an c-rule; otherwise, it is called a regular rule. The action is a list of flags to raise, events to send, and assignments.</p><p>The rule is fir&amp;de when all flags in the condition are on (raised), and the event (if any) is at the head of the input queue. When the rule fires, the flags in the condition are first turned off (lowered); then all flags in the action are raised, any events in the action are sent (what this means is determined by LEBM), and the assignments are processed. These things are done in the order in which they appear in the action.</p><p>Following is an example of a realistic rule:</p><p>TabletEvent waitTablet + haveTablet.currentPosition t TabletEvent.position haveTablet.currentButtons t TabletEvent.buttons haveTablet 7</p><p>In this case "TabletEvent" is an event with two value fields: position and buttons;3 "waitTablet" is a flag (with no value fields); "haveTablet" is a flag with two value fields: CurrentPosition and CurrentButtons. When waitTablet is on, and TabletEvent is at the head of the input queue, then this rule will fire. When this happens, waitTablet will be turned off (all flags in the condition are turned off before the action is processed). Then the current position and button settings of the tablet will be assigned to the appropriate fields of haveTablet. Finally, haveTablet will be turned on. This rule handles the TabletEvent event (presumably generated when the user presses a button on the tablet puck) and records the information in a local variable (the haveTablet flag).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Human-Computer</head><note type="other">Interaction-The Sassafras UIMS l 187</note><p>In principle, assignments have to be made separately from turning flags on or sending events (as has been done in this example), but a special syntax is available so that assignments can be combined with sends or flag raises. (This feature is used extensively in the following login dialogue example.)</p><p>Execution of an ERL specification proceeds by repeating the following two steps:</p><p>(1) Considering only e-rules, repeat until there are no firable rules: There are two important things to note about the firing process:</p><p>(1) More than one rule may be marked at one time; thus, a single event may cause more than one rule to fire. (2) c-rules are treated as high-priority rules, making them useful in some forms of synchronization.</p><p>The syntax of ERL in Sassafras (which is a slight extension of the above) is presented in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Local Event Broadcast Method. The Local Event Broadcast Method (LEBM) is a run-time structure that supports communication</head><p>and synchronization among the various modules that make up an interactive system, and that schedules their execution, In the terminology of Thomas and Hamlin <ref type="bibr" target="#b33">[33]</ref>, LEBM uses neither an internal nor an external control structure. It allows control to be shared between the user interface and the application, as needed. This greatly increases the flexibility of Sassafras compared with many existing UIDSs. In the structure of Section 2.1, LEBM provides the major structure of the run-time environment.</p><p>The primary elements of LEBM are modules and clusters. A module is a component of a user interface that represents a logical unit of code that exchanges information and synchronizes other modules only via the LEBM event-passing mechanism. Each module should deal with only one of the following: input/ output, dialogue control, or application routines. Most of the input/output modules will be interaction modules (as described in Section 1.2) and will come from the interaction module library. Application routines will usually be coded in some high-level language and grouped into modules on the basis of the function they perform (in Sassafras, most application routines are coded in Interlisp-D, but some are coded in ERL). Dialogue control modules will normally be coded in ERL. Each such module will contain a single ERL specification.</p><p>Clusters are groups of modules linked by a single instance of the LEBM runtime structure. Normally there would be one cluster for each user interface; however, for large and complex interfaces, it may be best to decompose the l Ralph D. Hill interface into several smaller components, each of which would be implemented as a cluster. The typical structure of a cluster is shown in Figure <ref type="figure" target="#fig_3">4</ref>.</p><p>LEBM allows modules within a cluster to communicate by sending events (as defined above in the section on ERL) to other modules in the cluster. These events are passed through the cluster controller, where they are queued and processed in first in, first out (FIFO) order.</p><p>Events are processed by first waiting until all modules are idle. The next event is then sent to all modules that will accept it. When these modules are again idle, the next event is processed. By distributing events in order, and only when all modules are idle, synchronization of modules is supported. To avoid some potential race conditions, two queues are used. One queue is used for events passed from module to module within the cluster. This is known as the internal queue. Another queue, the external queue, is used for events that originate outside the cluster. These events must be inserted into the queue by a module that is part of the cluster, but they are generated in response to outside actions, such as user input. No input is processed from the external queue until the internal queue is empty. This ensures that the cluster is stable before accepting input and eliminates some potential race conditions. In particular, the use of two queues guarantees that type-ahead (or the equivalent for other devices) is automatically supported for all devices and interfaces.</p><p>Event passing in LEBM is a form of asynchronous message passing. Note that most systems that use message passing as a concurrency control construct use synchronous message passing. Asynchronous message passing in LEBM requires a slightly different approach during programming, but it allows the implementation to be more efficient, since the overhead for sending a message is greatly reduced.</p><p>3.1.3 Completing the UIDS. Together, ERL and LEBM do not make a complete UIDS. The main things that must be added are the interaction module and icon libraries, and the interface assembler. Many other tools, such as editors and debuggers, are also needed to make a practical user interface prototyping system. In the case of Sassafras, the facilities of the Interlisp-D programming environment were used to mock-up the other pieces as needed. Thus, Sassafras is complete in terms of the structure of Section 2 (except for the lack of analysis tools) but is not a practical tool, since some of the components are quite crude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Simple Example</head><p>3.2.1 ERL Specification. Figure <ref type="figure" target="#fig_4">5</ref> shows a slightly simplified specification of a login dialogue, as printed by the ERL prettyprinter.</p><p>(The simplifications are primarily elimination of declarations and removal of some interaction with the window system.) This interface prompts the user for a userid and a password, and then sends them to an application routine to be checked. The dialogue repeats the userid and password prompts until the user succeeds, or until too many attempts have been made.</p><p>Figure <ref type="figure" target="#fig_4">5</ref> consists of a sequence of rules. Each rule consists of a condition (before the "+") and an action (on the following indented lines). All of the rules are regular rules, with the exception of the c-rule on line 8. (The prettyprinter prints "---" in place of the event in an c-rule.)</p><p>In this example, the actions consist of assignments, event sends, and flag raises. Assignments are usually combined with event sends or flag raises; for example, lines 5 and 6 set the value of the value field "printout" of the event "TtyOut," and then send the event (the ! indicates that it is a send). Line 7 is an example of a simple flag raise (indicated by the 7). Simple assignments have a t following the event or token name, as seen in line <ref type="bibr" target="#b14">15</ref>.</p><p>This example uses three interaction modules: one to display messages to the user, one to prompt for and collect user input, and one to interact with the Interlisp-D window system (the interaction with this module has been removed for simplicity). The first is accessed on lines 6 and 7 by sending the event "TtyOut." It is used to skip two lines, print the string "4.2 BSD UNIX (utcsri)," and skip two more lines. (Printout is the main Interlisp-D text output routine; this specification is in printout format for convenience.) Lines 9-11 send the event "PromptForWord," with the value field "prompt" set to "Login:" and the value field "echoForm" set to NIL (this causes the default value to be used). This will prompt the user with the string "Login:" and will send the event "GotPromptWord" when the user replies. When "GotPromptWord" is received, its value field "input" will hold the string typed by the user.</p><p>Considering the dialogue as a whole, it first prints the message "4.2 BSD UNIX (utcsri)" (the herald message on the CSRI VAX at the University of Toronto) and raises the flag "getuserid." At this point the input queue will be empty, so the only rule that can fire is the one beginning on line 8. Firing this rule takes the flag "getuserid" down (so this rule will not fire again, unless this flag is raised again). It sends the event "PromptForWord," with the value field "prompt" set to "login:". This will be displayed and any input the user types will be collected (up to a carriage return). The second value field of "PromptForWord," "echoForm," is set to NIL. This means that the default value (echo each character as it is typed) should be used. Finally, the flag "waituserid" is raised.</p><p>At this point, the input queue is empty, so no rules can fire. As soon as the user types some input, followed by a carriage return, the interaction module that handles typed input will send the event "GotPromptWord" (in response to the "PromptForWord" event). This makes the rule beginning on line 14 firable. It sets the value field "userid)) of the event "CheckLogin" to the string typed by the user (it is returned as the "input" field of the "GotPromptWord" event).</p><p>This rule also prompts the user for a password. In this case, echoForm is set to "*". This means that a "*" is to be printed each time the user types a character (instead of simply echoing the character). This is so that no other users can see the user's password, but the user can know that the characters being typed are being accepted. This rule also raised the flag "WaitPassword."</p><p>Again, the input queue is empty, so no rule can fire until the user types a carriage return and the "GotPromptWord" event is received. This will cause the rule beginning at line 24 to fire. This rule sends the event "CheckLogin" with the value fields "userid" (set on line 16) and "password" set to strings supplied by the user. This event is accepted by an application routine that replies with either "GoodLogin, " "BadLogin," or "TooManyAttempts."</p><p>The event "GoodLogin" is handled on line 28. This rule sends the event "LoginSuccessful."</p><p>Presumably, this event is handled by the dialogue that invoked this dialogue. The event "TooManyAttempts" is treated similarly at line 36, with the exception that a message is printed before sending the event "LoginUnSuccessful."</p><p>The event "BadLogin" causes the rule starting at line 31 to fire. This rule prints a message and then raises the flag "getuserid."</p><p>This causes the rule at line 8 to fire, and the dialogue (except for the herald message) is repeated.</p><p>Figure <ref type="figure" target="#fig_5">6</ref> shows the display the user would see after entering the userid "ralph," followed by an incorrect password and then trying again. The image shows the display just before the carriage return is typed following the second password.</p><p>For this user interface, a simple mock-up of the application routines was written to count the number of login attempts and to verify the userid/password combination. This was implemented with a slightly extended version of ERL. The behavior of this module is described by the following pseudo-ERL code: Modules marked with a * are library modules. The others were explicitly written for this interface.</p><p>In order to connect the pieces of this interface, a list of modules to be passed to the cluster controller had to be constructed. Using this list of modules and lists of all the events each module accepts and sends (derived from the module declarations), the run-time support routines generate tables used to improve the performance of the event-passing routines and to check for run-time errors.</p><p>The run-time structure of this interface is shown in Figure <ref type="figure">7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">An Example with Concurrency</head><p>This example represents a fragment of a realistic ERL specification with some synchronization.</p><p>Consider a user interface that repeatedly waits for the user to specify a command and an argument for the command. The command and the argument may be given in either order. As soon as they have both been specified, the command is executed. An ERL fragment to deal with this is: Assuming the user supplies a command and then an argument (say, from two separate menus), execution will proceed as follows: Initially "getcmd" and "getArg" are on. The system will wait until there is a token in the input queue. The first token is a command, so the first rule fires. Now the flags "cmd" and "getArg" are on. No rules can fire, so the system again waits for user input. The next token is an argument, so the second rule fires. Now the flags "cmd" and "arg" are on, and the E-rule and step (1) of the firing process come into play. In effect, this specification includes two concurrent subdialogues: one to collect the command and another to collect the argument. The c-rule provides a simple form of synchronization.</p><p>It allows the two concurrent subdialogues to rendezvous when they are both satisfied. When the flags "cmd" and "arg" are both on, the E-rule sends the event "Process" (presumably to a module of application routines) and turns on the flag "waitProcessing." This n Cluster Controller Fig. <ref type="figure">7</ref>. Run-time structure of login dialogue.</p><p>rendezvous is a simple form of synchronization that is often needed in concurrent dialogues.</p><p>When the processing is done, the event "DoneProcessing" is sent by the application routine, the last rule fires, and the system is back to the initial state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Summary</head><p>This section has presented informal descriptions of ERL and LEBM (they are formally defined in <ref type="bibr">[ 181)</ref>.</p><p>ERL is based on the principle of specifying responses to events (e.g., system responses to user actions). Unlike finite-state machines (as used in <ref type="bibr" target="#b21">[22]</ref> and <ref type="bibr" target="#b34">[34]</ref>), ERL allows concurrent dialogues to be compactly represented and easily edited. They also provide useful synchronization primitives and are designed to eliminate or simplify the detection of many common concurrent programming errors. Despite this power, ERL can be compactly and efficiently implemented.</p><p>To complement ERL, LEBM has been developed as a run-time structure to help support concurrent dialogues coded in ERL. LEBM is a communication mechanism that allows all the modules that make up a user interface to communicate and synchronize efficiently using an asynchronous message-passing mechanism. The power and flexibility of this communication mechanism encourage a modular approach to the construction of large interfaces, greatly simplifying maintenance.</p><p>Together, ERL and LEBM form the basis of Sassafras, a prototype for a flexible and powerful UIDS that supports concurrent dialogues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">USING SASSAFRAS-TWO EXAMPLES</head><p>This section first outlines the development and use of Sassafras. Two user interfaces that have been developed with Sassafras are then discussed. This is followed by a discussion of some discoveries about the use of Sassafras that were made during the development of these and several other user interfaces.4</p><p>'The reader can get a better idea of the behavior of the interfaces described in this section by watching the video tape <ref type="bibr" target="#b18">[19]</ref>. The 1109 is a personal workstation with 3.5 megabytes of memory, local disk, large bit-mapped display, mouse, and Ethernet interface. The processor is a bitslice processor that uses microcode that was developed for Interlisp-D.</p><p>The ERL interpreter and cluster controller were first implemented in roughdraft form. Once these basic components were completed, many interaction modules were developed. These typically provide a clean, event-driven interface to an existing set of Interlisp-D interaction routines. These interaction modules and several example user interfaces, including the user interface to the Sassafras development environment, were developed over a period of several months. During this time, the original ERL interpreter and cluster controller were improved and some features were added. In addition, tools to aid in debugging, an editor, and a prettyprinter were developed. Throughout the development of Sassafras, flexibility has been chosen over speed, and whenever there was a need to do something twice, it has always been done two different ways. The goal of this has been to discover the best ways to do things, and to ensure that Sassafras be as flexible as possible so that extensions could easily be added. As a consequence, much has been learned, and Sassafras is a flexible system. Unfortunately, the implementation of Sassafras is currently not so efficient or self-consistent as it should be. These problems can and should be corrected by reimplementing Sassafras, and making use of current knowledge. Sassafras has been developed as a test bed for the basic concepts of ERL and LEBM, and it relies heavily on the tools provided by the Interlisp-D environment. Hence, many of the supporting tools need further development and currently are only usable by experienced Interlisp-D users.</p><p>Although Sassafras is based on an interpreter model of execution, compilation techniques have been designed <ref type="bibr" target="#b17">[18]</ref> but have not yet been implemented. There has been no need to develop an ERL compiler, since the existing interpreter is more than fast enough for its current uses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Developing a User Interface with</head><p>Sassafras. There are currently, three major tasks in the construction of an interactive system with Sassafras:</p><p>(1) construction of the ERL specification, (2) coding of the application routines, (3) coding of special-purpose interaction routines (if any are needed).</p><p>ERL specifications are currently constructed by editing a copy of an existing specification or a null specification (the existing editor must be given a valid ERL specification when it is started). When the interface implementor attempts to exit from the ERL editor, the specification is checked. It is not possible to exit the editor if errors are found.</p><p>The application routines are implemented as traditional Interlisp-D functions. No special effort is required in the coding of application routines unless timeconsuming computations are involved, and all such computations should be done in a separate process. The interface between the user interface and the application routines is usually coded in ERL.</p><p>Some interfaces (including the two that are discussed below) require specialpurpose interaction modules. These interaction modules are often needed to improve the responsiveness of application-generated feedback, or for simple pragmatic reasons when a given fragment of an interface is easier to code in a traditional programming language than in ERL. These are best implemented and interfaced as if they were application routines-which they are, the only distinction being that they are allowed to access user input directly.</p><p>In practice, most of the refinement of interfaces developed with Sassafras is achieved with Sassafras's suspended-time editing feature. Suspended-time editing allows execution of a user interface to be suspended, the specification of the ERL modules to be edited, and the execution of the interface to be resumed from the point of suspension, but running the changed specification. This is perhaps the most useful feature of Sassafras from the user interface designer's point of view, and it was extensively used in the development of the interfaces discussed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A Simple Paint Program</head><p>This is a paint program that allows the user to control the brush position with one hand and the size of the brush and the shade of paint with the other. (The Xerox 1109 has a monochrome display; thus, instead of having several colors to choose from, the user has three shades of gray and the option of painting, inverting, or erasing.) The mouse is used to control the position of the brush. A trail of "paint" is left whenever the user holds the left mouse button down. The mouse can also be used to select brush sizes and paint attributes from a menu to the left of the painting area. The user's view of this program is shown in Figure <ref type="figure">8</ref>.</p><p>Normally, the user controls the brush size and the paint color with a touchsensitive tablet (see <ref type="bibr" target="#b6">[7]</ref> for a discussion of touch tablets and their use). The surface of the tablet is partitioned into six virtual buttons for controlling paint attributes and a virtual slide potentiometer used to control the brush size (see Figure <ref type="figure">9</ref>). The mouse and the tablet can be used simultaneously, allowing the user to paint with continuous strokes of varying thickness and color (as seen in Figure <ref type="figure">8</ref>)-something that cannot be done with existing paint programs. This interface provides an obvious example of a task that can be performed faster or better with a concurrent interface. Other important features of this interface include the following:</p><p>-This interface was originally constructed as a strictly two-handed interface. There was no on-screen menu to select sizes and colors. The on-screen menu was added after the interface was complete and required no changes to existing code. The ease with which the interface was transformed into an optionally one-handed interface demonstrates the flexibility of ERL. -Several programming language features of ERL were used in the implementation of this interface. These are used to manipulate brush size information. By using ERL to do the needed calculations, the implementation of the interactive system as a whole was simplified by eliminating many small application routines. This also makes the interface specification clearer, since the effects of the explicit calculations are easier to understand than the effects of an application routine coded in another language. This interface is an example of one for which the user interface designer should not be a nonprogrammer, since limited programming skills can be used to produce a simpler specification.</p><note type="other">l Ralph D. Hill</note><p>-This interface illustrates the use of an interaction module that was especially built for the interface. In this interface, the "painting" is done by an interaction module written in Interlisp-D, which directly accesses the mouse position and the display memory. The ERL code sends events to this interaction module to tell it to start and stop painting, and to control brush size and paint color. The use of this special interaction module results in good performance and aided in rapid program development.</p><p>-The development of this interface was greatly expedited by the interaction module that allows flexible access to the touch tablet. This interaction module accepts parameters that specify how it should behave. The specification is tabular in nature and allows the interface designer to allocate various proportions of the interface to different virtual devices. For this interface, it is used to divide the touch tablet into six buttons and a slider. Few existing UIDSs support parameterized interaction modules, since their communications facilities are not sufficiently flexible. This interface clearly demonstrates that parameterized interaction modules are needed and that they must be supported if powerful interfaces are to be developed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Furniture Positioning in a Room</head><p>This example is an enhanced version of the furniture-positioning-in-a-room application described by Foley and van Dam <ref type="bibr">[ 14, ch. 21</ref>. This program was chosen as an example because it clearly was not designed to be easily implemented with Sassafras and has a published implementation that can be used for comparison. This program allows the user to select pieces of office furniture (e.g., desks and chairs) from a menu, and rotate and position them within a room. As originally described, this program had a restrictive, moded interface. Several versions of this program, ranging from the one described by Foley and van Dam to a modeless, direct-manipulation style interface, were developed. All use the touch tablet to control the rotation of the pieces of furniture. For brevity, only the most advanced version is described. The user's view of this interface is shown in Figure <ref type="figure" target="#fig_9">10</ref>.</p><p>All commands are available from the menu at the right of the main window. Selecting an item of furniture allows the user to drag a copy of the selected piece into position and rotate it. The positioning and rotating tasks can be performed simultaneously, reducing the time to perform the combined task. Furniture that has already been placed can be selected and repositioned or rotated. Thus, this interface has a direct-manipulation style of interaction <ref type="bibr" target="#b29">[29]</ref> with real-time feedback.</p><p>An important feature of this version of the interface is the options that the user has when rotating the pieces of furniture. The same touch tablet that was used to control the brush and paint parameters in the paint program is used to control rotation in this program. It can be used to select rotations of multiples of 90 degrees quickly and easily or, with slightly more care to select any rotation. This is done by simultaneously implementing three different virtual devices on the touch tablet: a matrix of nine buttons, a rotary potentiometer, and a slide potentiometer. All three virtual devices use the entire surface of the tablet. These virtual devices are illustrated in Figure <ref type="figure" target="#fig_10">11</ref>. The input from the potentiometers is ignored until the user presses a virtual button that indicates that one of the potentiometers is to be used. The buttons are then ignored, and the potentiometer attended to until the user's finger is removed from the touch tablet. The rotary potentiometer is absolute: If the user presses in the upper left corner, the selected piece of furniture will be rotated to face the upper left. Thus the corner buttons can be used to do jump rotations to the diagonals, as well as to select any rotation by dragging. The slider potentiometer is relative, so it can be used to make small changes in rotation.</p><p>Fortunately, this scheme is simpler to use than to describe (see <ref type="bibr" target="#b18">[19]</ref>). In practice, it allows the user to select common rotations easily, yet allows arbitrary rotations to be precisely specified.</p><p>Major features of this interface include the following:</p><p>-It is a direct-manipulation-style interface with real-time feedback. This style of interaction is currently popular and is believed to be easy to learn and use. Unfortunately, interfaces of this type are often hard to implement. Sassafras makes it easier to implement interfaces of this style.</p><p>-The implementation of several variations on this interface, of increasing sophistication, demonstrates that it is possible to build several different interfaces to one set of application routines with Sassafras.</p><p>-All the interfaces to this application support the "picking" of pieces of furniture so that they may be repositioned or rotated. Tanner and Buxton <ref type="bibr" target="#b31">[31]</ref> suggest that pick processing is a feature that is potentially difficult to support in a UIDS. In these interfaces the user interface passes a coordinate pair to an application routine. The application routine replies with an event indicating the item that was selected. More advanced forms of picking (such as picking by drawing a closed curve around the desired objects, e.g., <ref type="bibr" target="#b5">[6]</ref>) could be supported in a similar manner. In general, the solution is found in the powerful communications support provided by LEBM.</p><p>-The advanced rotation scheme makes extensive use of the concurrency support of ERL and the communications support of LEBM. The rotation interface is implemented as several concurrent dialogues, only one of which is listened to at a time. This results in a compact and easily modified implementation.</p><p>It is important to note that one interaction module (the one that simulates virtual buttons and sliders on the touch tablet) is instantiated twice in this interface. One instance supports the nine-button view of the touch tablet, and the other supports the slider view.</p><p>Three key features of ERL and LEBM make this interface fragment easier to implement in Sassafras than it would be in any existing UIDS; these are concurrency, communication, and the ability to use several instances of a single interaction module in one interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Discussion</head><p>These interfaces (and several others) were developed quickly. For example, the original two-handed paint program took about three days to implement. The various forms of the layout program took less than a week and a half.5 All interfaces that have been developed with Sassafras were developed by first constructing a rough interface and then iteratively refining this interface. Because Sassafras allows suspended-time editing, the iterative approach is fast, resulting in short development times. The rapid implementation of changes also ensures that motivation is not lost because of delays in testing new ideas. Some specific things that were discovered about Sassafras (and ERL and LEBM) include the following.</p><p>-The primary speed gain in the development of interfaces with Sassafras (and likely with other UIDSs) is not in the initial development of the first version of an interactive system, but in the iterative refinement. The first version of a user interface takes time to implement, largely because of difficulties in developing a good implementation of the application routines and the interfaces to them. During the development of the interfaces described above, it was found that the best approach was to start with a simple user interface so that effort could be concentrated on the application routines and any specialpurpose interaction modules. Once these were stable, the user interface could be rapidly refined.</p><p>---In general, the implementation of the application routines is the slow part and the main limiting factor. For example, the user interface to the Sassafras runtime environment has many features for which the user interface is complete but the application routines are not. This is because the user interface can be rapidly refined with Sassafras, and new and useful commands are invented and implemented faster than the supporting application routines can be extended.</p><p>The application routines were implemented with the full facilities of the Interlisp-D environment, an environment that allows rapid program development. This implies that this "problem" would be more acute in other programming environments.</p><p>-Suspended-time editing is extremely useful. This feature is important to the rapid development of user interfaces with Sassafras and may be the single most important feature of Sassafras as a rapid prototyping system. The structure of ERL and the ease of building interpreters for ERL make this feature easy to implement. -It is important that the interaction modules accept parameters. Both the paint and room-layout interfaces make extensive use of this feature. In most existing UIDSs the communications facilities are not powerful enough to support parameterized interaction modules. -It is important that it be possible to add interaction modules that send new event types. In many existing UIDSs, there is a fixed set of interaction modules and a fixed set of tokens or events that they can send to the dialogue-control portion of the UIDS at run time. This is clearly inadequate. The ability to add special-purpose interaction modules and new event types was needed in both the paint program and the more elaborate forms of the room-layout program. -The development of the user interface and the application routines are not completely separate tasks. Often the development of one will influence the other. For example, it is common for improvements to the interactive system as a whole to be discovered while experimenting with the user interface. Implementing these improvements may require changes to both the user interface and the application routines. In a rapid prototyping environment one must expect many changes, including some that may affect pieces of a system other than the one of immediate concern. This appears to be a contradiction of some comments in the UIDS literature, which suggest that the user interface and the application can be developed separately.</p><p>-The interfaces that have been implemented with Sassafras use a range of interface styles. This demonstrates that interfaces implemented with Sassafras are not limited to a single interaction style. -ERL is an inherently concurrent language. Occasionally the user must be prevented from doing several things concurrently (which could lead to confusion in the prompts, result in ambiguity of input, or result in loss of internal state within the ERL specification). This means that the user interface designer must be aware of the concurrency and must control it when necessary. In practice this is not difficult, nor excessively error prone, but it is a novel problem to most programmers.</p><p>This point illustrates a key failing of ERL. ERL allows multiple simultaneous threads of execution, but it has only one set of variables. Thus, it is possible for two threads to use a single variable simultaneously for different purposes. This can be a major problem. In practice, however, wherever this problem occurs, the user would probably have to be prevented from performing two tasks simultaneously in order to ensure that the input is correctly interpreted and to avoid confusing the user.</p><p>-UIDSs based on ERS and LEBM would typically be intended for expert users of the UIDS and elaborate user interfaces. ERL specifications in Sassafras tend to have initialization code that requires a detailed knowledge of the environment. In more restrictive UIDSs, much of this code could be generated automatically, but because ERS and LEBM are designed for maximum flexibility, it is difficult to provide defaults without compromising the goals of ERS and LEBM.</p><p>-Because of the rule-based nature of ERL, it is difficult to extract from an ERL specification the sequence of commands a user must enter to invoke a specific command. Equivalently, it is difficult to map from an ERL specification to a simple representation of the grammar for the user's language. This means that ERL is not appropriate for interfaces with complex syntaxes, for example, systems allowing natural language input or complex nested expressions (e.g., an algebraic-style calculator).</p><p>-For interfaces with many modes, with a large number of simple commands in each mode and a major change in the commands associated with each change of mode, there may already exist better tools than ERL. In the original moded version of the room-layout program, it was found that a lot of ERL code was used to control mode changes. Systems such as Trillium <ref type="bibr" target="#b16">[17]</ref> and the one described in <ref type="bibr" target="#b7">[8]</ref> may be better at this style of interface since they have good support for major mode changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK ERL and LEBM have some similarities</head><p>with other UIDSs and concurrent programming systems. Some of these are discussed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Communicating Sequential Processes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Communicating</head><p>Sequential Processes (CSP) is a programming notation for concurrent programs developed by Hoare <ref type="bibr" target="#b19">[20]</ref>. CSP is a simple, but powerful, notation. It uses the same constructs for I/O, interprocess communication, and function invocation. It is based on synchronous message passing, where the sender must name the receiver, and vice versa. The synchronous message passing implies that a process can only send a message when the receiver is ready. This results in many context switches.</p><p>The design of ERL was influenced by CSP. Like CSP, ERL relies on a small number of basic operations, and uses the same constructs for I/O, communication, and invocation of other ERS modules. Thus, like CSP, ERL is both simple and powerful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Adagio</head><p>Adagio is a robot simulation workstation <ref type="bibr" target="#b32">[32]</ref>. Its user interface is based on Harmony, a multitasking, multiprocessor operating system based on synchronous message passing [El. This user interface uses concurrency in its implementation and uses a process known as the switchboard to perform a function similar to LEBM's device allocator. Adagio is one of the few examples of a serious attempt to develop a fully concurrent user interface. The tools to support this interface, however, are simply those provided by Harmony-there are no special-purpose tools like ERL and LEBM. In particular, there are no restrictions on message passing to help prevent and detect races and deadlocks. In addition, all dialogue specifications are coded directly in the Harmony language; there is no specialpurpose dialogue specification language. Thus the developers of Adagio have no tools to help them. They must rely on adherence to some standard programming practices in the development of user interfaces. Hence, they are merely developing a concurrent user interface using a traditional concurrent programming language. In terms of the user interfaces they can develop, Adagio is a step in the right direction but it only emphasizes the need for a concurrent UIDS and tools like ERL and LEBM.</p><p>Beach et al.</p><p>[l] describe the use of a similar message-passing system to implement a paint program and explain the programming methodology used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Squeak</head><p>Squeak is a programming language based on the CSP message-passing paradigm. It was developed by Cardelli and Pike [lo] as a language for writing event-driven interaction modules. It has a clever compiler that generates simple C code. Hence, the implementation is extremely efficient. Unfortunately, there is little evidence to show that it will be practical, and there is the possibility that some Squeak programs will result in huge C programs when compiled.</p><p>Squeak is similar to LEBM in that it uses message passing for synchronization and communication, and it supports an efficient sequential implementation. The main difference is that it has no special constructs (other than the concurrency support) that aid in the specification of interactive dialogues. Thus, Squeak is only a general-purpose programming language with efficient concurrency support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Augmented Petri Nets</head><p>Zisman <ref type="bibr" target="#b36">[36]</ref> proposes a technique for specifying asynchronous concurrent processes that is a cross between Petri nets and production system. This technique was developed to help model office procedures. Petri nets are used to control concurrency, and a production system approach is used to specify the behavior of individual sequential elements. This approach makes the flow of control and the interaction between the processes clear. Unfortunately, it may not be well suited to dialogue specification, since the granularity of control on the concurrency is quite coarse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SUMMARY AND CONCLUSIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Review of Contributions</head><p>As stated in the introduction, the specific goal of Sassafras is to demonstrate techniques for supporting concurrency, communication, and synchronization in user interface development systems. Concurrency is considered an important extension to the range of user interfaces that can be supported. Improved communication and synchronization among the modules that make up a user interface are prerequisites for supporting concurrency. Improved support for communication is also an independent goal, since existing UIDSs lack sufficiently flexible communication schemes to support many useful forms of interaction. The two major contributions of the work on Sassafras are the development of Event-Response Language (ERL) and the Local Event Broadcast Method (LEBM). ERL is a dialogue specification language that allows the syntax of concurrent dialogues to be more compactly represented than they are with state transition-based dialogue specification languages. LEBM provides a run-time structure and mechanism for communicating among and synchronizing the modules that make up a user interface at run-time.</p><p>When combined, ERL and LEBM can form the basis for a powerful UIDS. This was demonstrated through the development of the Sassafras prototype UIDS and the implementation of several user interfaces with Sassafras. These example user interfaces show that Sassafras (and hence ERL and LEBM) succeed in supporting concurrent user interfaces and in providing improved support for communication and synchronization when compared with existing UIDSs. Other features of Sassafras that have been demonstrated include the following:</p><p>-Rapid development of user interfaces, via the iterative design approach, is supported by suspended-time editing.</p><p>-Interfaces can be created by combining pieces, thus encouraging the use of large libraries of standard pieces and a modular approach to user interface construction.</p><p>-The user interface and the application routines can be physically separated without limiting their ability to exchange important information. -Special-purpose interaction modules can be quickly incorporated into user interfaces.</p><p>-Unlike most existing UIDSs, the interaction modules accept parameters, allowing greater flexibility in input handling. -In addition to supporting concurrency in human-computer dialogues, the concurrency support in Sassafras is also a useful tool for adding structure to the implementation of user interfaces.</p><p>Other important features of the design of LEBM and ERL that have not been discussed in detail in this paper include the following:</p><p>-The design of LEBM ensures that type-ahead (or the equivalent on other devices) is safely supported for all input devices and all interfaces.</p><p>-Even though ERL and LEBM support concurrency in the user interface, they can be efficiently implemented in sequential code. The elimination of the process-switching overhead results in better performance than would otherwise be expected. In addition, it is possible to build both interpreters (for rapid development) and compilers (for efficient execution) of ERL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">General Discoveries about UlDSs</head><p>During the use of Sassafras to implement several demonstration interfaces, several discoveries were made. Many of these appear to be contradictions of prevailing thoughts or wishful thinking about UIDSs and user interface design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>These contradictions</head><p>may not arise when most existing UIDSs are used, since they support only a limited range of user interfaces. Sassafras is intended to extend this range greatly; hence, it should not he surprising that some flaws in prevailing thought are found when Sassafras is used.</p><p>The discoveries are:</p><p>Purser versus programming language. Many UIDSs are built around some form of parser and are predicated on the assumption that a key function of the UIDSs is the parsing of user input. Thus, the language used to specify the user interface is a language for formally specifying languages, and it does not have most of the features of traditional programming languages. For many simple interfaces this is sufficient. For more complex interfaces the parser-based approach becomes clumsy and awkward. The problem is that simple computations must be frequently performed on user input or system state. If the user interface specification language does not support these computations, application routines must be used. This greatly increases the size and complexity of the specification and reduces its legibility.</p><p>A solution is to extend the user interface specification language so it becomes a simple programming language with special control constructs to assist in dialogue specification. The current implementation of ERL in Sassafras allows the user interface implementor to treat the specification language this way, and it has been found useful in the implementation of the paint and room-layout interfaces.</p><p>Separation. Much UIDS research, and many systems, assume that the user interface can be separated from the application and the two developed separately. There are two key forms of separation: logical and physical. The user interface is logically separated from the application routines if there is no sharing of data at run-time. The two are physically separated if they are specified separately, perhaps in different files. Although separation is often considered both good and possible, in practice, logical separation can seriously impede the development of some types of user interfaces (most notably, direct-manipulation interfaces). On the other hand, physical separation is possible, practical, and desirable. In order to support physical separation, without logical separation, a powerful and flexible communications mechanism is required. Unfortunately, most existing UIDSs do not have a suitable communication mechanism, and hence, they cannot support some interfaces.</p><p>Nonprogramming user interface implementor. It is commonly claimed that UIDSs should allow nonprogramming user interface experts to design and implement user interfaces. The above "discoveries" are obvious reasons for requiring the user of a UIDS to have some programming skills.</p><p>The goal should not be to eliminate programming, but to provide the user interface designer with an appropriate set of tools. These tools could require the use of some programming skills. In the development of the example interfaces, it was found that simple arithmetic operators, conditional branches, and procedure calls were the only constructs needed. It is likely that nonprogrammers could quickly learn to deal with these constructs (the more complex and errorprone concepts of iteration and recursion are not needed). Hence, it is reasonable to ask that the user interface expert have some basic knowledge of programming.</p><p>UIDSs as the solution. UIDSs are often seen as a solution to the problems of supporting rapid prototyping and the development of good user interfaces. This is unrealistic. UIDSs cannot guarantee the development of good user interfaces, nor do they necessarily make it easy to prototype interfaces. UIDSs can make it easier and faster to prototype and iteratively refine user interfaces, but they rely heavily on a robust and flexible set of application routines. Also, they are only tools-it is only when they are used by skilled artisans that high-quality interfaces are produced. Given a good set of application routines, these skilled individuals could probably develop a good user interface independent of their tools. UIDSs are not the solution; they are a tool. Skilled designers and implementors and lots of hard work are the solution.</p><p>Cheaper user interfaces. UIDSs may not make the time to produce the first version of an interface significantly shorter than it would be if a powerful programming environment were used. Hence, they are not necessarily a good way of producing quick and inexpensive interfaces. Most of the time needed to produce the first version of an interface is spent thinking about the interface and designing the interface to the application routines. Using a UIDS cannot expedite these activities (and may even delay the design of the application interface, because of the restrictions of the UIDS). The greatest saving in time and effort is usually realized when the interface is being modified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Future Work on Sassafras</head><p>Much work remains to be done with Sassafras. Some examples of further work that should be done are the following:</p><p>-Sassafras should be extended with improved tools so that it becomes a practical tool for experimentation. Some things that are needed immediately are improved editors for ERL and cluster specifications, improved debugging information, and a more consistent and complete library of interaction modules.</p><p>-The basic structure of UIDSs presented in Section 2 identifies three key phases: specification, run-time, and follow-up. So far, the follow-up phase, consisting of an analysis of user or system performance, has been largely ignored. Eventually, some form of data collection must be added to Sassafras to support the analysis. The problems are determining what information should be collected and finding a way to collect this information without impacting the performance of the system.</p><p>-Bleser <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, Payne and Green [ 261, and Reisner <ref type="bibr" target="#b28">[28]</ref> have proposed techniques for analyzing the specification of user interfaces, in an effort to predict their ease of use or task performance times. The proposed analysis techniques assume specific specification techniques. An attempt should be made to develop comparable techniques that can be applied to ERL specifications. -In general, Sassafras and its supporting tools should be reimplemented. The original components were designed to be as flexible as possible, and they have evolved over time. As a result, the code is inefficient and is not written with a consistent style. A careful reimplementation would substantially improve performance and make the code more maintainable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Summary</head><p>Given the current state of the art in interface design, it is not possible to build good user interfaces on the first attempt; hence, an iterative approach must be used. Because existing programming tools are not well suited to the implementation of user interfaces, this approach is very expensive. A new UIDS called Sassafras has been described; it supports the iterative design approach and greatly extends the range of user interfaces supported when compared to existing UIDSs. Sassafras is based on two new contributions to the field of user interface design and implementation: event-response systems, a technique that can be used to specify concurrent dialogues and the local event broadcast method, a run-time structure for user interfaces that allows the various components of the user interface to communicate and synchronize.</p><p>Sassafras has been used to develop several user interfaces; it clearly demonstrates that concurrency and communication are needed in the implementation of user interfaces, and that ERL and LEBM can efficiently support these features on existing workstations.</p><p>In addition, Sassafras demonstrates that suspendedtime editing is important in the use of the iterative design approach and that this feature can be efficiently supported. In the third rule (condition), the symbol "---" is used instead of the event name, when the rule is an e-rule.</p><p>The nonterminal indent indicates an increase in the level of indent. The following undent stands for a reduction in the level of indent. In the case of conditionals, the rules bracketed by indent and undent are executed only if lisp-expression returns a non-NIL value.</p><p>The following nonterminals are best described in words:</p><p>flag</p><p>The name of a flag. incoming-event</p><p>The name of an incoming event. outgoing-event</p><p>The name of an outgoing event.</p><p>event The name of any event (incoming or outgoing). value-field</p><p>The name of a value-field. literal A LISP constant expression. comment Any string of italic characters.</p><p>Identifiers (flag, event, and value-field names) may be any Interlisp-D litatom (any sequence of characters that cannot be interpreted as a number or a string and is less than 256 characters long).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX B. OUTLINE OF ERL SPECIFICATION FOR PAINT PROGRAM</head><p>This is a rough sketch of the ERL specification for the paint program. The complete specification is substantially larger, but is not much more complex. The extra size is primarily the result of handling details (e.g., what do you do when the user tries to paint outside of the paint window?) and error handling.</p><p>The core of the paint program specification (in ERL) is: The incoming events in this specification are: LefButtonDown LeftButtonUp Dark Generated by the mouse button interaction module. Indicates left button has been depressed while the tracking symbol is in the paint window. Generated by the mouse button interaction module. Indicates left button has been released. Generated by the touch tablet interface module or the interaction module supporting the on-screen menu. Both of these modules receive tabular specifications on startup. Indicates that the user has touched the touch Medium Light SliderChange PluslMenuItem MinuslMenuItem tablet in the area that indicates that black paint should be used, or has selected black from the on-screen menu with the mouse. Similar to Dark. Similar to Dark. Sent by the touch tablet module when the user adjusts the slide potentiometer. Has a single value-field "delta" that indicates the amount of change. Sent by the interaction module supporting the on-screen menu when the user selects the "+l" item. Sent by the interaction module supporting the on-screen menu when the user selects the "-1" item. This ERL module sends four events. These events are sent to the inking module to control the inking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>StartInking</head><p>Start inking at the current size, with the current color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>StopInking Stop inking. ChangeInkingOptions</head><p>This event has one value-field "color," and is used to change the current color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ChangeInkingSize</head><p>This event has one value-field "size," and is used to change the current brush size. (The size value could be an additional value field associated with the Change-InkingOptions event; the use of an extra event is a style decision-and may be wrong).</p><p>Two important things to note are the following.</p><p>-There is no explicit concurrency in this specification. Concurrency is a natural consequence of the independence of the rules and can (almost always) be ignored by the user interface implementor. -The on-screen menu and the menu on the touch tablet send the same events for color selection. This simplifies and shortens the specification.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. Overall UIDS structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Traditional structure of run-time environment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Identify and mark all rules that are firable given the current values of the flags. (b) Fire all the marked rules. (2) Considering only the regular rules, do once: (a) Identify and mark all rules that are firable given the current values of the flags and the token at the head of the input queue. (b) Fire all the marked rules. (c) Delete the token at the head of the input queue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Typical structure of a user interface implemented with Sassafras.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Login example coded in ERL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. User's view of login dialogue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>INITIALLY + attempt.count c 0 CheckLogin --, attempt.count c attempt.count + 1 if CheckLogin.password = "wizard" then GoodLogin ! elseif attempt.count &lt;= 3 then BadLogin ! else TooManyAttempts ! 3.2.2 Communication via LEBM. All the run-time activity of the modules that make up this interface (execution, communication, etc.) is controlled via a cluster controller, the implementation of LEBM. The modules in this interface are dialogue (Fig. 5) Mock-up of login semantics Keyboard input Simple character output Interaction with window system</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Sassafras Prototype UIDSSassafras is a prototype UIDS that has been built around an ERL interpreter and a simple implementation of LEBM. It has been developed in the Interlisp-D programming language<ref type="bibr" target="#b35">[35]</ref> on a Xerox 1109 (Dandetiger) workstation. Interlisp-D is a dialect of LISP that has been developed to run on Xerox D-machines (e.g., Dorado, Dandelion, and Dandetiger). The principle features of Interlisp-D are support for windows and the mouse, and a multiprocess operating system that supports efficient creation and destruction of processes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .Fig. 9 .</head><label>89</label><figDesc>Fig. 8. User's view of two-handed paint program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. User's view of advanced layout program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Use of touch tablet in advanced layout program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>APPENDIX A. THE SYNTAX OF ERL IN SASSAFRAS This is a formal description of the syntax of ERL as supported by Sassafras. The syntax for the declarations are omitted since they are simple lists with headers. The syntax of the rules is: rule list *rule* rule + (condition "+" action) ) comment condition + (incoming-event 1 "---") flag* action + assign 1 bulk assign 1 send I raise I conditional I comment assign ---, (flag ( outgoing-event) "t" value bulk assign + (flag I outgoing-event) "t" indent assignment + undent assignment * "." value-field "t" value value + ERL-value I literal ERL-value + (flag I euent) "." value-field send + outgoing-event 'I!" [indent assignment + undent] raise + flag t [indent assignment + undent] conditional + "I" lisp-expression "1" ident rule* undent</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Graphics, Vol. 5, No. 3, July 1986, Pages 179-210.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>ACM Transactions on Graphics, Vol. 5, No. 3, July 1986.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>' It seems that in interactive computing the notion of concurrent dialogues must be carefully justified.Buxton (private communication)   claims that he met resistance from many people involved in user interface design, who claimed that users could not use two hands at once without great difficulty or special training, and that this resistance motivated his experiments<ref type="bibr" target="#b4">[5]</ref>. One clear example showing that most people are capable of carrying on concurrent dialogues is the act of driving a car. To do this requires simultaneous use of the right foot to control the throttle and the hands to steer. Also, most people can turn the windshield wipers on or off, or sound the horn, while still controlling the car.ACM Transactions on Graphics, Vol. 5, No. 3, July 1986.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>Ralph D. Hill</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>' This decomposition is from<ref type="bibr" target="#b31">[31]</ref>. The following subsections are extensions of this work. ACM Transactions on Graphics, Vol. 5, No. 3, July 1986.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>ACM Transactions on Graphics, Vol. 5, No. 3, July 1966.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_6"><p>By convention, event names start with an uppercase letter, flag names start with a lowercase letter. ACM Transactions on Graphics, Vol. 5, No. 3, July 1986.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_7"><p>ACM Transactions on Graphics. Vol. 5, No. 3, July 1986.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_8"><p>l Ralph D. Hill</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_9"><p>ACM Transactions on Graphics, Vol. 5, No. 3, July 1996.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_10"><p>Most of this time was spent developing the original moded interface. This interface was difficult to implement since the interface is complex and the specification is a Pascal program. There are also, several subtleties in the user interface, and it takes a great deal of effort to check the Pascal code carefully and to determine the exact behavior of the interface. Additionally, a simple graphics package had to be written, since no suitable package was available. ACM Transactions on Graphics, Vol. 5, No. 3, July 1936.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_11"><p>ACM Transactionson Graphics, Vol. 5, No. 3, July 1986.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The design of ERL owes a great deal to many discussions with Bill Buxton and Peter Rowley. Bill Buxton, Ronald Baecker, and Alison Lee provided many useful comments that have improved this presentation, as did the anonymous referees. The use of concurrency and touch tablets in user interfaces has a long history at the University of Toronto, and the present work builds on this history. Bill Buxton has been the leader of work in this area at the University of Toronto for a long time, and this work owes a lot to his ideas.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was financially assisted by the Natural Sciences and Engineering Research Council of Canada and the University of Toronto. We also gratefully acknowledge a grant from Xerox Canada, Inc., that provided the equipment that made the implementation possible.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The message is the medium: Multiprocess structuring of an interactive paint program</title>
		<author>
			<persName><forename type="first">R</forename><surname>Beach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Beatty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Booth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fiume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plebon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH &apos;82 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1982-07">July 1982</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="271" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Towards specifying and evaluating the human factors of user-computer interfaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bleser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Human Factors in Computer Systems Conference</title>
		<meeting>Human Factors in Computer Systems Conference</meeting>
		<imprint>
			<date type="published" when="1982-03">Mar. 1982</date>
			<biblScope unit="page" from="309" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A formal specification and computer-assisted evaluation of person-computer interfaces</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Bleser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>George Washington Univ</publisher>
			<pubPlace>Washington, D.C.</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">GWU-IIST Rep. 83-18</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Olympic message system-A case study in system design</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Boies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Gould</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Schoonard</surname></persName>
		</author>
		<author>
			<persName><surname>The</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM</title>
		<imprint>
			<date type="published" when="1984">1984. 1985</date>
			<pubPlace>Yorktown Heights, N.Y.</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Res. Rep. RC-11138</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A study in two-handed input</title>
		<author>
			<persName><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI &apos;86 Human Factors in Computer Systems</title>
		<meeting>CHI &apos;86 Human Factors in Computer Systems<address><addrLine>Boston, Mass.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">Apr. 13-17. 1986</date>
			<biblScope unit="page" from="321" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Continuous hand-gesture driven input</title>
		<author>
			<persName><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fiume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Interface &apos;83</title>
		<meeting>Graphics Interface &apos;83<address><addrLine>Edmonton, Alta., Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">May 9-13. 1983</date>
			<biblScope unit="page" from="191" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Issues and techniques in touch-sensitive tablet input</title>
		<author>
			<persName><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rowley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH &apos;85 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1985-07">July 1985</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Towards a comprehensive user interface management system</title>
		<author>
			<persName><forename type="first">W</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sherman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH &apos;83 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1983-07">July 1983</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="35" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Iteration in the design of the human-computer interface</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A S</forename><surname>Buxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sniderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, 13th Annual Meeting</title>
		<meeting>13th Annual Meeting</meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="72" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Squeak: A language for communicating with mice</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pike</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGGRAPH &apos;85 Conference Proceedings</title>
		<imprint>
			<date type="published" when="1985-07">July 1985</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="199" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Report on the interface of the UIMS to the application</title>
		<author>
			<persName><forename type="first">G</forename><surname>Enderle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Report on the activity of the working group on the interface between the application and the UIMS from the IFIP/EG Workshop on User Interface Management Systems</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Pfaff</surname></persName>
		</editor>
		<meeting><address><addrLine>New York; Seeheim, Federal Republic of Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1983">1985. October 1983</date>
			<biblScope unit="page" from="21" to="29" />
		</imprint>
	</monogr>
	<note>User Interface Management Systems</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Design considerations for knowledge workshop terminals</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Engelbart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Computer Conference</title>
		<meeting>the National Computer Conference<address><addrLine>Reston, Va</addrLine></address></meeting>
		<imprint>
			<publisher>AFIPS Press</publisher>
			<date type="published" when="1973-08">June 4-8. 1973</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="221" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A research center for augmenting human intellect</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Engelbart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>English</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fall Joint Computer Conference</title>
		<meeting>the Fall Joint Computer Conference<address><addrLine>San Francisco, Calif; Reston, Va</addrLine></address></meeting>
		<imprint>
			<publisher>AFIPS Press</publisher>
			<date type="published" when="1968">1968</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="395" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Fundamentals of Interactive Computer Graphics</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Using the harmony operating system</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Gentleman</surname></persName>
		</author>
		<idno>ERB-966 NRC 23030</idno>
		<imprint>
			<date type="published" when="1983">1983</date>
			<pubPlace>Ottawa, Canada</pubPlace>
		</imprint>
		<respStmt>
			<orgName>National Research Council of Canada</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Report on dialogue specification tools</title>
		<author>
			<persName><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Report on the activity of the working group on dialogue specification from the IFIP/EG Workshop on User Interface Management Systems</title>
		<meeting><address><addrLine>New York; Seeheim, Federal Republic of Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1983">1985. October 1983</date>
		</imprint>
	</monogr>
	<note>User Interface Management Systems, G. Pfaff</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Trillium user interface design environment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Henderson</surname></persName>
		</author>
		<author>
			<persName><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHZ &apos;86 Human Factors in Computer Systems</title>
		<meeting>CHZ &apos;86 Human Factors in Computer Systems<address><addrLine>Boston, Mass.; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">Apr. 13-17. 1986</date>
			<biblScope unit="page" from="221" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Supporting concurrency, communication and synchronization in human-computer interaction</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Univ. of Toronto, Canada</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Sassafras demonstration video tape</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">R Communicating sequential processes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978-08">Aug. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A production system approach to interactive graphic program design</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R A</forename><surname>Hopgood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Duce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Methodology of Interaction</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Guedj</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="247" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Using formal specification in the design of a human-computer interface</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J K</forename><surname>Jacob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="259" to="264" />
			<date type="published" when="1983-04">Apr. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Command use and interface design</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Kraut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Farber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI &apos;83 Human Factors of Computer Systems</title>
		<meeting>CHI &apos;83 Human Factors of Computer Systems<address><addrLine>Boston, Mass; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983">Dec. 12-15. 1983</date>
			<biblScope unit="page" from="120" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Prototyping interactive information systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E A</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Carey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="347" to="354" />
			<date type="published" when="1983-05">May 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Ralph</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A method for evaluating the usability of software and its documentation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Neal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Simons</surname></persName>
		</author>
		<author>
			<persName><surname>Playback</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI &apos;83 Human Factors of Computer Systems</title>
		<meeting>CHI &apos;83 Human Factors of Computer Systems<address><addrLine>Boston, Mass; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983">Dec. 12-15. 1983</date>
			<biblScope unit="page" from="72" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The user&apos;s perception of the interaction language: A twolevel model</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Payne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R G</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHI &apos;83 Human Factors of Computer Systems</title>
		<meeting>CHI &apos;83 Human Factors of Computer Systems<address><addrLine>Boston, Mass; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983">Dec. 12-15. 1983</date>
			<biblScope unit="page" from="202" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">User Interface Management Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><surname>Ed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFIP/EG Workshop on User Interface Management Systems</title>
		<meeting>the IFIP/EG Workshop on User Interface Management Systems<address><addrLine>New York; Seeheim, Federal Republic of Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1983">1985. October 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Formal grammar and human factors design of an interactive graphics system</title>
		<author>
			<persName><forename type="first">P</forename><surname>Reisner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng. SE-T</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="229" to="240" />
			<date type="published" when="1981-03">Mar. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Direct manipulation: A step beyond programming languages</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="57" to="69" />
			<date type="published" when="1983-08">Aug. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The inevitable intertwining of specification and implementation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Swartout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Balzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="438" to="440" />
			<date type="published" when="1982-07">July 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Some issues in future user interface management system development</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Tanner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A S</forename><surname>Buxton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFIP WG 5.2 Workshop on User Interface Management</title>
		<editor>
			<persName><surname>User Interface Management</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Systems</surname></persName>
		</editor>
		<editor>
			<persName><surname>Pfaff</surname></persName>
		</editor>
		<meeting><address><addrLine>New York; Seeheim, Federal Republic of Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1983">1985. October 1983</date>
			<biblScope unit="page" from="67" to="79" />
		</imprint>
	</monogr>
	<note>Invited paper presented at</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The user interface of Adagio, a robotics multitasking multiprocessor workstation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Tanner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Gentleman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mackay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Stewart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Internotional Conference and Exhibition on Computer Workstations</title>
		<meeting>the 1st Internotional Conference and Exhibition on Computer Workstations<address><addrLine>San Jose, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="90" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Graphical input interaction technique workshop summary</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hamlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph. (ACM)</title>
		<imprint>
			<biblScope unit="page" from="5" to="30" />
			<date type="published" when="1983-01">Jan. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Rapid prototyping of interactive information systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Wasserman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">T</forename><surname>Shewmake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Eng. Not. (ACM)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="171" to="180" />
			<date type="published" when="1982-12">Dec. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Interlisp Reference Man&amp;</title>
		<author>
			<persName><surname>Xerox Corp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Xerox Corp</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<pubPlace>Pasadena, Calif</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Use of production systems to model asynchronous, concurrent processes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Zisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pattern Directed Inference Systems</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Waterman</surname></persName>
		</editor>
		<meeting><address><addrLine>Orlando, Fla</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="53" to="68" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
