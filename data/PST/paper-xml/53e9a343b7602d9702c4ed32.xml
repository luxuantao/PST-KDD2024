<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SKEME: A Versatile Secure Key Exchange Mechanism for Internet</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Research Center Yorktown Heights</orgName>
								<address>
									<postCode>10598</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ibm</forename><forename type="middle">T J</forename><surname>Watson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Research Center Yorktown Heights</orgName>
								<address>
									<postCode>10598</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SKEME: A Versatile Secure Key Exchange Mechanism for Internet</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9D0B6E64B03B1E202A3C0EE85DD4C622</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A secure a n d versatile k e y exchange protocol f o r k e y m a n a g e m e n t o v e r I n t e r n e t is presented. SKEME cons t i t u t e s a c o m p a c t protocol t h a t s u p p o r t s a v a r i e t y of realistic s c e n a r i o s a n d s e c u r i t y m o d e l s over I n t e r n e t . It p r o v i d e s clear tradeoffs between security a n d perform a n c e a s required by t h e different s c e n a r i o s w i t h o u t i n c u r r i n g in u n n e c e s s a r y s y s t e m complexity. T h e protocol s u p p o r t s k e y e z c h a n g e based o n public k e y , k e y d i s t r i b u t i o n centers, o r m a n u a l installation, a n d pro- v i d e s f o r f a s t a n d secure k e y r e f r e s h m e n t . In addition, SKEME selectively p r o v i d e s perfect f o r w a r d secrecy, all o w s f o r replaceability a n d n e g o t i a t i o n of t h e u n d e rlying cryptographic p r i m i t i v e s , a n d addresses p r i v a c y i s s u e s a s a n o n y m i t y a n d repudiatability.</head></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The need to secure the Internet is now clear to everyone. Consequently, more and more mechanisms to provide security at different layers and different applications are being developed. Common to most of these security mechanisms is the need for key management. One crucial component of key management is the exchange of secret keys between two parties. This is a basic enabler for the use of conventional cryptography (based on shared secret keys) on which most of the efficient security solutions rely. This paper presents the design of SKEME, a key exchange mechanism which provides the scalability and flexibility required by the growing Internet, and by the diversity of scenarios that are part of it. Accommodating this variety of scenarios and requirements, both in terms of performance and security, into a simple and compact protocol is the main challenge and accomplishment of SKEME.</p><p>The design of SKEME has been mainly motivated by the work carried through the IPSEC working group of the IETF (Internet Engineering Task Force) which is in charge of developing a standard and interoperable key management protocol for Internet. This protocol is intended to provide key management for the IPlayer security protocols developed by the same working group (see <ref type="bibr">[l]</ref>), but also to provide a key man-agement solution for other security applications over Internet. The currently proposed mechanism for key exchange in this working group is the Photuris protocol designed by Phil Karn <ref type="bibr" target="#b14">[16]</ref> which is similar to the STS key exchange protocol of Diffie, van Oorschot, and Wiener <ref type="bibr">[lo]</ref>. Photuris is designed to exchange a key between two parties using public key and the Diffie-Hellman key exchange [9]; it also addresses issues like anonymity and denial-of-service attacks.</p><p>SKEM E provides with the same basic functionality of Photuris, it accommodates other trust models (e.g., key distribution centers or manual installation), and provides for flexible tradeoffs between security and performance (e.g., it allows for selective execution of Diffie-Hellman, and for fast and frequent key refreshment). Mostly importantly, the added features do not require any significant increase in protocol complexity, or incur on any performance penalty. Because of the many aspects that are common to Photuris and SKEME, the later is not proposed to replace Photuris, but to be merged with it in order to broaden and strengthen the functionality of the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Protocol Overview and Design Rationale</head><p>The design of SKEME follows a set of requirements and goals that are presented in detail in Section 2.</p><p>Here we briefly overview these issues, and the basic features of SKEME.</p><p>The central approach of SKEME is to provide with a scalable and flexible protocol capable of accommodating many realistic scenarios in Internet, as well as to provide with clear tradeoffs between security and performance. The basic model that needs to be addressed is the public key model which is the most scalable and has minimal trust requirements. The basic mode of SKEM E provides, therefore, key exchange based on public keys of the parties and the strong security of the Diffie-Hellman mechanism. The latter has the great advantage of minimizing the negative effects of the eventual exposure of long-lived keying material (e.g., the exposure of the private keys of the parties or a long-lived master key). This property of the Diffie-Hellman protocol is referred to as perfect 0-8186-7222-6196 $5.00 0 1996 IEEE Proceedings of SNDSS <ref type="bibr">'96</ref> forward secrecy (PFS) [lo, 131.</p><p>However, SKEME does not limit itself to the combination of public key and Diffie-Hellman. It addresses additional needs like, e.g., key exchange based on a previously shared key between the parties. This supports many important and realistic scenarios which include manual key installation and other forms of shared master keys. Furthermore, it accommodates key exchange in the Key Distribution Center model (also known as the Kerberos model <ref type="bibr" target="#b17">[19]</ref>), where the parties share a key via a commonly-trusted center. By using this key to authenticate a Diffie-Hellman exchange, rather than using it directly as a session key, SKEM E achieves a significant security improvement by reducing the trust required in the KDC.</p><p>SKEME also provides for more efficient key exchange mechanisms for the cases in which the perfect forward secrecy property of the Diffie-Hellman exchange can be relaxed, thus saving the significant computational cost associated with that mechanism. Such cases include applications where authenticity of information, rather than confidentiality, is at stake, or where the level of secrecy required is relatively low (see Section 2.3.1). Finally, a very important goal of SKEME is to provide with a mode to perform very fast and frequent key refreshments. This has the effect of shortening the lives of cryptographic keys, thus limiting the damage and potential of key exposure.</p><p>All of the above results in four modes of SKEME:</p><p>1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>The basic mode which provides both public key based key exchange and PFS (Diffie-Hellman).</p><p>Fast re-key mechanism based on efficient symmetric key techniques only (e.g., MD5).</p><p>These four modes are folded into a single simple protocol, with a small set of messages, a well defined set of options, and a compact representation. All of which makes SKEME attractive from a system and implementation point of view.</p><p>A basic technical observation behind the design of SKEME is that in most common implementations (e.g., RSA), the performance cost of public key signatures is similar to khat of public key encryption. Therefore, SKEME deviates from the approach of performing a Diffie-Hellman exchange authenticated via digital signatures (e.g., [lo, 15, 161). Instead, the protocol first goes through a share p h a s e in which the parties share a key by mutually encrypting half-keys based on the public key of each other, and then uses this key to authenticate the Diffie-Hellman exchange.</p><p>The later authentication utilizes efficient operations only, e.g., MD5. In this way the same functionality of Diffie-Hellman-plus-signatures is obtained, but one gets "for free" (computationally speaking) the share phase where a key is already shared by the parties. This allows for the option of skipping the Diffie-Hellman phase (thus providing mode 2 above), or skipping the share phase (i.e., omitting the use of public keys) when the exchange is to be based in a previously shared key between the parties (mode 3). Finally by skipping both the share phase and the Diffie-Hellman phase, a fast re-key mechanism is obtained (mode 4).</p><p>For the details, see the protocol description in Section 3.</p><p>In addition, SKEME provides for anonymity in the sense that it prevents unnecessary disclosure of the communicating identities (beyond what is strictly necessary, e.g., IP addresses); it addresses further privacy issues by avoiding the use of digital signatures and then allowing for "repudiation of communication" (see Section 2.3.2); and it also provides certain defenses against denial of service attacks (by adopting the "cookies" technique of <ref type="bibr" target="#b14">[16]</ref>). Related work: Besides the works cited above, the literature contains many references to protocols and standards on key management in general and key exchange mechanisms in particular. We refer the reader to the survey by Rueppel and van Oorschot <ref type="bibr" target="#b18">[20]</ref> on key exchange mechanisms, as well as to the forthcoming book by Menezes, van Oorschot, and Vanstone (chapter 12) <ref type="bibr" target="#b15">[17]</ref>. Our work was mainly motivated by the activities carried through the IPSEC working group in the IETF, but we also note the suitability of our approach to the framework defined by IEEE 802.10 [14]. SKEME evolved as an extension of MKMP (modular key management protocol) <ref type="bibr">[8]</ref> where a modular approach to key management is suggested and a specific module for key refreshment based on a shared key between the parties is presented. In general, SKEME builds as much as possible, even for its public key based modes, on the existing solid design and analysis work developed for key exchange over the shared-key model (cf. <ref type="bibr" target="#b16">[18,</ref><ref type="bibr">7,</ref><ref type="bibr">41)</ref>. Security analysis: A detailed and formal security analysis of SKEME is beyond the scope of this paper which is intended to describe the protocol design and its rationale. However, for completeness, we include an informal outline of a proof of security for all four modes of the protocol. We base this outline on previous formal work developed for proving the security of key exchange mechanisms in the shared-key model <ref type="bibr" target="#b3">[4]</ref>. See Section 5. (We believe that the fact that the security of SKEME can be related to that of protocols in the shred-key model is another advantage of SKEME. The shared-key model has been extensively studied and we consider it simpler and better understood for analysis than the general public key case.) Organization of this paper: Section 2 describes the main goals and requirements standing behind the design of SKEME. Section 3 describes the protocol.</p><p>Section 4 highlights the main features of SKEME. Section 5 argues about the security of the protocol. Fi- nally, Section 6 provides some concluding remarks.</p><p>A note on implementation: This paper presents the basic design and rationale of the protocol. Implementation of the protocol is underway; when completed more details and implementation experience will be reported in a separate document.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Goals and Requirements</head><p>In this section we list some of the basic goals and requirements behind the design of SKEM E. It is not intended as an exhaustive enumeration of requirements for key management, but rather to emphasize the basic properties required from a key exchange mechanism for use in Internet, and t o highlight the main features of the protocol proposed here. Many of these requirements are the result of the numerous discussions carried in the IPSEC working group of the IETF.</p><p>The basic functionality of a key exchange mechanism is t o provide two communicating parties with a common shared secret key that is known to these parties only. One can think of this key as a master key or session key depending on the life span of the key or the semantics of the application. For the sake of concreteness, we will often refer to the exchanged key as a "session key".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Variety of Scenarios and Security</head><p>One of the most demanding aspects of a security protocol intended for use over the global Internet is the variety and heterogeneity of scenarios and security models existing in this medium. Any single model of trust will be insufficient to address the needs of key management for Internet. Our protocol is therefore designed to support a variety of these models while keeping the system aspects of the protocol as simple as possible.</p><p>PUBLIC KEY MODEL. In the case of two parties that possess the public keys of each other, the protocol is required t o establish a shared secret key between these parties even if no prior shared secret existed between them. The security of the protocol will then depend on the authenticity of these public keys. The trust on this authenticity will be based, in general, on the existence of some form of certification mechanism that can range from a global Certification Authority to local and distributed trust as in the PGP model <ref type="bibr" target="#b19">[21]</ref> (manual distribution of public-keys is also possible). The advantage of the public key model is that it has minimal third party trust requirements and, fundamentally, is the most scalable model for Internet. KEY DISTRIBUTION CENTERS. A well established and extensively used trust model is that of a key distribu-Models tion center (KDC) <ref type="bibr" target="#b16">[18]</ref>. This is the model popularized by the Kerberos protocol <ref type="bibr" target="#b17">[19]</ref>. Although it does not have the scalability capability of the public key model (because of the high level of trust required by the communicating parties on the on-line KDC), this model cannot be ignored in a key management protocol for Internet due to its usefulness in many scenarios (e.g, corporate world), the efficiency of symmetric cryptography techniques on which it is based, and its existing and extensive deployment. Actually, a well designed key exchange protocol can strongly improve the security provided by the KDC model by reducing the level of trust required from the KDC. This issue is further discussed in Section 2.3.1.</p><p>MANUAL KEY INSTALLATION. Although it is the most primitive way to install a shared key between two parties, manual installation is still a common way to install initial keys in many systems. (It will be also useful in the new scenarios created by Internet, e.g., a mobile user which shares a manually installed key with its own office's workstation, or with a firewall.) In this case, the use of a key exchange protocol that is able to do periodic refreshment of keys and minimize the security risk attached to long-lived master keys is essential.</p><p>We note that the basic difference between the public key case and the last two cases is the fact that in the latter the key exchange protocol starts once a shared secret key is already established between the parties. Periodic key exchange based on previously shared keys is useful also in the public key case, since it allows for more efficient, and then more frequent key refreshment. The latter minimizes compromise of keys via cryptanalysis (the more a key is used the more information the adversary has for breaking it) and limits the harm of an exposed key by shortening its useful life. In addition, key refreshment can minimize the dependency between past and future keys (i.e., how much can be learned from a compromised key about past and future keys).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Basic Requirements</head><p>In addition to support the above different models we briefly list here some of the properties SKEME is required to support. SECRECY AND AUTHENTICITY. The protocol needs to guarantee to the executing parties that only the intended party learns the key exchanged and that this key is fresh and unique. Secrecy and authenticity (of the exchanged key) need t o be protected against passive (eavesdroppers) and active (man-in-the-middle) attackers, and these properties be guaranteed for as long as the underlying cryptographic functions in use (encryption, authentication, etc) are secure against these adversaries. Not only the value of the exchanged key is to be protected, but partial information on the key should be hidden as well (except for known public information like key 1ength)l.</p><p>An additional security goal is to minimise the negative effects of a compromised key. Keys may be exposed regardless of the security of the key exchange protocol that generates them, e.g., by break-ins to a system, poor secure storage management, and so on. Mechanisms like independence between different keys in the system, frequent refreshment, and perfect forward secrecy, as discussed below, address this goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>KEY REFRESHMENT.</head><p>The key exchange protocol must provide automatic mechanisms to periodically refresh keys. This needs to include low cost mecha nisms for very frequent key updates (say, each 5 minutes) and more costly and secure ones for less frequent refreshments (say, each 3 hours). These different mechanisms will differ in their performance cost and degree of independence between the refreshed key and past/future keys. Periodic refreshment of keys is required to limit the damage caused by exposed session keys and to reduce the amount of information available for cryptanalysis (the latter is especially significant when weak algorithms are in use, e.g. due to performance or crypto regulations restrictions). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PERFECT FORWARD SECRECY. Perfect</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>KEY SEPARATION. Different cryptographic functions</head><p>should use different and cryptographically independent keys (namely, the exposure of one key should not compromise the other). This applies to the different functions used in the key exchange protocol itself as well as to the cryptographic functions applied to data during the subsequent session. In particular, one has to be careful not to "re-use" the session key produced by the protocol to key different functions. (For example, if the session key is used in the protocol to key a hash function, say MD5, it should not be used to key a data encryption algorithm later, say DES.) The recommended way to use the session key to derive keys for different cryptographic algorithms is to use this session key as a "seed" from which other keys are derived (e.g., through a pseudorandom or hash function IGiving away even limited information about the key may have severe security implications. As an example consider the case where the exchanged key Is later used as a one-time pad to hide one of two possible strings: the all zeros string or the all ones string (which may represent a confidential yes/no information); in this case, a single known bit in the key would reveal the encrypted message.</p><p>keyed with the session key and applied to a unique identifier of the algorithm).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PRIVACY AND ANONYMITY. Communication over a</head><p>public and open network as the Internet not only requires the hiding of information exchanged between communicating parties but, in some cases, also the hiding of the identity of the communicating parties. This is not always possible: e.g., if a message carries for its delivery the IP address of the intended Internet host, or its originator, then that host can be identified from that information. However, in some other cases the communicating parties (typically, the initiator of a key exchange) can be hidden behind a temporary IP address, e.g., a traveling individual which is pro- vided with a temporary address in a remote system. In such a case the sole information on the origin IP address is not sufficient to identify the communicating party. It is a goal of S K E M E to protect this identity from attackers on the net. Other forms of privacy concerns exist, e.g., the protocol should not provide "nonrepudiatable proofs'' that party A has been talking to party B. The later is a real concern if digital signatures are used for authentication in the protocol. See further discussion of this issue in Section 2.3.2. CLOGGING ATTACKS. The complete elimination of denial of service attacks via flooding or clogging against a host is virtually impossible. However, some preventive measures can alleviate the problem. In the case of protocols involving public key operations, the opportunity for such attacks is increased due to the high performance cost of these operations. In our protocol we adopt a simple "cookies" technique introduced by Phil Karn in his Photuris protocol [I61 in order to make it more difficult for an adversary to accomplish such an attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PERFORMANCE.</head><p>Key exchange operations may strongly vary on their computation requirements depending on the trust model and level of security required (compare an MD5 operation vs. an RSA signature). The protocol requires a careful design to provide flexible tradeoffs between security and performance. The different variants for key refreshment as mentioned above are an example of these tradeoffs. The amount of communication in the protocol is another performance parameter to consider.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MULTIPLE SECURITY MODELS.</head><p>The protocol should support a variety of existing and widely used security models, like manual key installation and key distribution centers. In addition it must support public key based key distribution which is the only model to scale to the dimensions of Internet. The latter must be supported all the way from manually installed certificates to web of trust a la PGP to global certification authorities. These issues are discussed in more detail in Section 2.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ALGORITHM INDEPENDENCE. The protocol needs to</head><p>define the underlying cryptographic primitives in a functional level (e.g., encryption, signature, etc.), but not to depend on particular implementations (e.g., DES, RSA). Specific realizations of cryptographic primitives should be replaceable. This would accommodate different choices by different parties to implement these primitives, and mostly importantly, would allow for replacement of the algorithms in case of cryptanalysis or the finding of new and more secure or efficient algorithms. This is not to preclude the definition of default algorithms that may be required for interoperability. Related to this issue is the need to include in a complete key management protocol a negotiation mechanism through which parties agree on particular security transforms and options of a protocol.</p><p>EXPORTABILITY. The reality of existence of regulations concerning import and export of cryptographic technology in different countries needs to be taken into consideration. The goal is not to weaken the protocol in order to make it exportable (as in the case of US regulations) but to design it such that it does not contain elements that will have to be unreasonably weakened because of these regulations. One such example is the avoidance, if possible, of mandatory symmetric encryption in the protocol. MINIMIZE PROTOCOL COMPLEXITY. The above set of requirements, especially the need to support different security models and different tradeoffs security/performance may easily lead to a too complex protocol with too many options, message formats, and so on. In order to be acceptable and widely deployed the protocol needs to keep a low system complexity. This is the main challenge a n d accomplishment of SKEME: It accommodates the stated requirements through a small set of well-defined options, a uniform message format for the different options, and a compact representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Discussion of Some Requirements</head><p>While many of the above requirements are clear and do not necessitate much of an explanation, others are less well-understood and sometimes controversial. We elaborate on some of them here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Perfect Forward Secrecy (PFS)</head><p>An important goal in a security design (especially key management) is to limit the harm caused by the exposure of keys. This is especially important for long-lived keys. If the compromise of a single key exposes to the attacker all the traffic exchanged by a party during, say, the last two years, such a key becomes an attractive target for an adversary, and a major bottleneck for the system security. A far better design is to limit the advantage for the attacker that breaks the key only to future active impersonation attacks, where the potential of being detected is high. A key exchange mechanism that protects short-lived keys from compromise even in case of the exposure of long-lived keys, is said to provide perfect forward secrecy (PFS) [lo, 131.</p><p>If, for example, all session keys exchanged by a party, A , are encrypted under A's public key, then an attacker that breaks the private key of A would also learn all past, and even future, session keys of A . In contrast, by using the Diffie-Hellman algorithm for key exchange and A's private key only to sign this exchange, a much better level of security is achieved. In that case, the attacker that compromises the private key will be able to actively impersonate A in future communications, but will learn nothing about past communications, or even future ones in which the attacker is not actively involved.</p><p>Therefore, PFS is, in general, a very desirable property of a key exchange protocol. However, there is a computational cost to achieve it. Practically speaking, there is currently no other solution to provide this property except for the Diffie-Hellman exchange (in its different realizations: finite fields, elliptic curves, etc.)2 which requires two long (modular) exponentiations for each party per exchange (one of which can be done off-line).</p><p>Due to this cost it is worthwhile asking if PFS is necessary in all cases and all scenarios. Our answer is no. PFS relates to secrecy of information. In some applications, however, authenticity rather than secrecy is the goal. As an example, the Authentication Header standard developed by the IETF <ref type="bibr" target="#b1">[2]</ref> is intended to provide for authentication of I P packets and headers but not for confidentiality. A server that provides with non-confidential but authenticated information can use this authentication mechanism, but can dispense of secrecy, let alone PFS. In such a case, it could be unjustified to overload this server with the unnecessary effort of performing Diffie-Hellman in each key exchange (which may be required for each information request). Services requiring authentication but not confidentiality will be very common, e.g., a file server that authenticates files (especially, executables) for integrity, a web server providing non-confidential information, and so on. Other scenarios where PFS may not be a requirement include cases where the exchanged information is encrypted but its confidentiality is limited to a very short period of time (e.g., timely financial information), cases where the encryption in use is weak (for exportability, performance, etc.), or where the level of secrecy required is low (e.g., a DNS server that encrypts its responses for the sake of anonymity only).</p><p>21n principle, any public key system can be used t o achieve such an exchange, including RSA. However, the latter would require the generation of one-time RSA keys which is an unacceptably expensive process.</p><p>SKEME is designed to selectively provide with PFS. It provides PFS as part of the basic SKEME protocol based on public key, and for cases where the parties perform key exchange based on long-term shared keys (like a manually installed master key, a SKIP key derived from long-lived public keys [3], and more). Furthermore, SKEME can provide PFS for the case of parties that share a common key via a key distribution center (KDC). In this case, SKEME would derive a session key for the parties via a Diffie-Hellman exchange, while the KDC-provided key would be used for authentication only. Thus, the compromise of the key provided by the KDC (e.g., by breaking into the KDC, or by malicious insiders) does not effect the security of information exchanged between the parties using the Diffie-Hellman key (it may only allow the attacker to mount limited active impersonation attacks). In contrast, if the KDC-provided key is used directly as a session key, its compromise would expose to the attacker all the traffic in that session. Therefore, providing PFS in this case strongly enhances security by reducing the trust required by the parties on the KDC.</p><p>On the other hand, for those cases, as discussed above, where the expense of a Diffie-Hellman exchange is not justified, SKEME provides with the option of omitting this mechanism and still providing the parties with a secret shared key. (To learn this key from the protocol the attacker will need to compromise the private keys of both parties). We consider the provision of selective PFS as one of the important differentiating properties of SKEME relative to other proposed key exchange mechanisms, e.g., [lo, 161.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Privacy and the use of signatures</head><p>A natural approach to the design of a key exchange protocol based on public keys is to use digital signatures for authentication of the key exchange. Many protocols do that, e.g., [lo, 15, 161. Here we point out to some conflict between use of signatures and privacy requirements. A basic property of digital signatures is that they provide "non-rep~diation"~, namely, if A has signed some information using her private key, then anyone in possession of A's public key can verify that A was the signer. This makes digital signatures very useful in many scenarios, but also raises the following privacy concern. If during a key exchange between parties A and B , A is required to sign B's identity, then this signature can be used later by B (or any other party having that signature) to convince a third party that A had been communicating with B.</p><p>The provision of such "proofs of communication" raise a privacy concern even more serious than disclosing</p><p>The term non-repudiation here does not necessarily imply "legal liability", but just the ability to give to a third party a strong evidence that the signed data originated with the signer.</p><p>identities over the network. Indeed, even if the identities are eavesdropped over the network, the eavesdropper cannot later provide convincing evidence to a third party that she saw these identities. She could provide that evidence, however, if these identities were signed by the communicating parties. (Even if the signatures are encrypted over the network, they can be used by the recipient B to show that A has been communicating with him).</p><p>Therefore, if digital signatures are used in a key exchange protocol (where privacy protection is a requirement), then these signatures should not be used to sign the identities. However, this will not prevent a malicious party from encoding her own name into a piece of information to be signed by the other party dur- ing the protocol. This encoding can be done through seemingly random nonces, or, in the case of a protocol signing Diffie-Hellman exponents, the encoding can be done via these exponents. In addition, the use of signatures imposes the need to encrypt these signatures before transmission to prevent an adversary from learning the identity of the sender just by checking that the signature is consistent with the public key of that party.</p><p>A better way to deal with these issues is to completely avoid the use of digital signatures in the protocol. The latter is the approach of SKEME. In our protocol, public key operations are limited to encryption/decryption, while all authentication of information by the parties is done through symmetric key techniques which provide complete repudiatability of the authenticated information, as well as avoids the need to encrypt the authentication. (For alternative public key-based exchange protocols that do not use signatures see <ref type="bibr" target="#b18">[20]</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The SKEME Protocol</head><p>In this section we present the SKEME protocol with its basic phases and messages. The description is at a high-level and omits some of the details in order to concentrate on the basic security structure of the protocol and the functionality it provides. We first (53.1) introduce some notation and the basic cryptographic functions underlying the protocol. Then (53.2) we present the basic protocol which represents its strongest mode and provides with full security strength. Next (53.3), the additional modes of SKEME are described in which the basic protocol is accommodated to provide flexible security/performance tradeoffs, and to support diverse security scenarios. Finally (53.4), the full protocol is presented where the above modes are all combined into a single and compact representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Cryptographic Primitives and Notation</head><p>Here we list the basic cryptographic functions used in SKEME. We assume familiarity of the read.er with these basic functions and concepts. Public key encryption is used, but no specific algorithm is specified or as- sumed. RSA or El Gama1 encryption are examples of suitable algorithms. RSA is the most economic in the sense that only the operation of decryption involves a long modular exponentiation; encryption can be done with a few modular multiplications. The assumption on the security of the encryption is that it hides all partial information on the encrypted data (formally, we will assume semantic security of the encryption function [12]). In particular, it is assumed that encryption is randomized in the sense that the same message encrypted twice would lead to different encryptions. When using RSA this may be achieved by padding information with random salt before encryption, or more securely, by using the encoding scheme proposed in [6]. We use P K E A ( i n f 0 ) to denote the (public key) encryption of info under the public key of party A .</p><p>SKEME uses the Diffie-Hellman key exchange algorithm4 [9]. For simplicity of notation, we will denote the Diffie-Hellman exponents by g" mod p and gY mod p which corresponds to the standard Diffie-Hellman modulo a prime number p and generator g. However, there is no assumption in the protocol related to this special form. In general, one can use different primes/generators for different users, or use Diffie-Hellman over other structures (e.g., elliptic curves). Also for simplicity, we sometimes omit the mod p notation. SKEME requires the use of pseudorandom functions, which are collections of keyed functions (like DES or keyed-MD5) with the property that their output (including individual bits of it) cannot be predicted by an adversary that does not possess the key to the function. These functions (formalized in [ll]) extend the notion of pseudorandom generators, and can be seen as providing "random access" to a long pseudorandom string. In practice, pseudorandom functions have realizations via DES and other block cipher cryptosystems (in particular, can be ap- plied to variable length input via CBC-MAC modes), or via keyed one-way hash functions like keyed-MD5.</p><p>Two important properties of pseudorandom functions is that revealing the result of such a function on a set of inputs does not reveal information about the value of the same function on a different point, and that they serve as secure MAC (message authentication codes). These functions are used in SKEME both to provide data authentication (integrity) and as generators of keys. We denote a pseudorandom function using key K by FK. In practical terms, one can think of FK as keyed-MD5, DES-CBC-MAC, etc, and then very efficient to compute.</p><p>Any other exchange algorithm that provides perfect forward secrecy can be used instead of Diffie-Hellman; however, no such practical algorithm seems to be knownsee 2.3.1.</p><p>Finally, we need some further notation: H stands for a strong one-way hash function, e.g., MD5, SHA. The parties to the protocol are referred to as A and B , where A acts as initiator, and their identities in the protocol are denoted by i d A , i d B , respectively. The output of the protocol, namely, the exchanged secret (session key) key, is denoted S K .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Basic Protocol and Its Phases</head><p>There are three basic phases in the protocol: SHARE, EXCH, and AUTH. We first present these basic phases in a way that provides the full security capability of the protocol. This includes the sharing of a secret key based only on public keys and the provision of perfect forward secrecy. We call this the basic protocol. Later we show how these same phases with different parameters provide for the additional functionality and tradeoffs of the protocol. In the actual protocol messages of different phases can be combined to provide a more compact and communication efficient scheme. Some details are omitted for the sake of clarity of presentation.</p><p>Phase SHARE is intended to establish a key KO between A and B based only on the parties having the public key of each other. This phase by itself does not authenticate the parties or the shared key KO. It provides a very basic security level: If A follows the protocol then she is assured that the shared key KO is not known to anybody except B (though A does not have the assurance that B knows the key). And analogously for B. To be really meaningful this phase needs to be combined with the other phases of the protocol.</p><p>In SHARE the parties exchange "half-keys" encrypted under each other's public key and then combine the half-keys via a hash function to produce KO.</p><p>(Exclusive-or of the two half-keys can be used instead of hashing, but the hashing provides less opportunity for B to arbitrarily influence the key). The basic message structure of SHARE is as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SHARE:</head><p>When anonymity of the initiator, A , is desired then the first flow will also encrypt A's identity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A t B: P K E B ( i d A , K A )</head><p>If i d A is too long, in particular if it includes A's public key certificate, then a second key can be included under the encryption, and i d A transmitted encrypted under this second key using a symmetric encryption algorithm. (Notice that this would require use of symmetric encryption in the protocol. However this is done only optionally and with no other security function than the hiding of identity/certificate of A ) . We stress that the values K A and KB need to be chosen as (pseudo-) random values, and fresh for each run of the protocol.</p><p>The next phase, EXCH, is used to exchange DiRe-Hellman exponents. Notice that this phase is independent of SHARE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EXCH:</head><p>A -+ B: g" mod p B + A: g y m o d p</p><p>The above exponents g", q y can be computed offline by each party prior to the execution of the protocol.</p><p>The authentication of this Diffie-Hellman exchange is accomplished in the following phase, AUTH, which uses the shared key KO from SHARE to authenticate the Diffie-Hellman exponents. The combination of the EXCH and AUTH phases provides the protocol with the strong perfect forward secrecy (PFS) requirement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AUTH:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A + B: ~K o ( ~Y ~g x l i d A l i d ~)</head><p>B --+A: FKo(g",gY,idg,idA) Remember (Section 3.1) that FK,, represents a pseudorandom function using key KO, and that such a function (e.g., keyed-MD5, CBC-MAC) provides the functionality of a MAC (Le., message authentication). The messages of this phase are intended to authenticate the origin, the freshness, and the values of the Diffie-Hellman exponents. Only after this phase is completed, the parties have assurance that these Val- ues were chosen by their partner in the communication. Notice that the key KO shared in the SHARE phase can be known only to A and B (assuming their private keys are not compromised) and then only these parties could have generated the above authenticated messages. The inclusion of g" in the first message serves to authenticate (to B) that g" came from A; the value g y in the same message is used to prove to B the freshness of this message (assuming g y was freshly chosen by B ) ; finally, the included identities serve to reassure the parties about the correct binding between the exchanged key and their identities. The second message has the same security functionality relative to A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computation of the session key:</head><p>The session key S K , which is the key shared between A and B as the result of this protocol, is computed by the parties as SK = H(g"y modp).5 Notice that this computation (which involves an expensive on-line Diffie-</p><p>We recommend hashing the value gxY mod p for the purpose of "extracting randomness" from all the bits of g o ' .</p><p>Other methods are possible, including using directly some of the bits Hellman computation) can be completed after the protocol (thus, avoiding the consequent delay during the protocol). The value itself of S K is not used in the key exchange protocol. This saves the delay in the protocol that could be caused by this computation. The authentication of the individual exponents g" and g y guarantees the authenticity and uniqueness of S K .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Combining the Phases</head><p>The messages in the above phases have some level of flexibility as for their ordering and combination. For example, the ordering of messages in phase EXCH can be inverted, as is the case for messages in AUTH. In phase SHARE, A is assumed to be the initiator and then her message comes before B's. In some cases (discussed later) the order of phases SHARE and EXCH can be reverted. For the sake of communication efficiency, the above phases can be combined into three message as described in Figure <ref type="figure">1</ref>.</p><p>Notice that, as presented, the above protocol represents an opportunity for an adversary to mount denialof-service attacks against B , since B needs to perform an expensive operation (public key decryption) even before he knows to whom he is speaking, and before A authenticates herself. Moreover, in order to force B to decrypt the adversary does not need to perform any expensive operation. This problem is addressed in the Photuris protocol [16] via a technique called cookies. The same technique can be used in our case, it requires the performance of a COOKIES phase before the SHARE phase. Its incorporation to our protocol is straightforward and the details are omitted here. (We refer to <ref type="bibr" target="#b14">[16]</ref> for further motivation and description of this technique).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Modes of the Protocol</head><p>As said earlier, the distinguishing feature of SKEME is its capability to provide the different tradeoffs between performance and security as required by the different security scenarios in Internet. The basic protocol as described in Section 3.2 provides the most general solution in the sense that it accommodates the public key model (which is the most general and seal- able model) and achieves perfect forward secrecy, thus providing the strongest level of secrecy even in case of key compromise.</p><p>In this section we show some natural variations, or modes, of the basic protocol that provide with the suitable Ievel of security for scenarios where a secret key is already shared between the communicating parties, and those scenarios where the requirement of perfect forward secrecy can be relaxed and, therefore, its high computational cost be saved. (See Figures <ref type="figure" target="#fig_2">2</ref> and<ref type="figure" target="#fig_3">3</ref> of g"Y. However, notice that some of these bits, e.g. least significant bit, are predictable given gx and gy. Another possible method to compute SK is as SK = FKo(gxY mod p ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A B S K := H ( g Z Y mod p )</head><p>Figure <ref type="figure">1</ref>: SKEME with public keys and PFS for a combined and pictorial representation of these modes.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">SKEME W i t h o u t PFS</head><p>In Section 2.3.1 different scenarios where perfect forward secrecy (PFS) may not be a requirement were discussed. The mode of SKEME presented in this section is intended to provide the key exchange functionality based on public keys of the parties, but without paying the high performance cost required to achieve PFS. This mode takes the advantage of the key KO shared during the SHARE phase to produce a shared session key.</p><p>This mode of SKEME is derived from the basic protocol of Section 3.2 by modifying the EXCH phase. In this mode, the EXCH phase will be simply used to exchange nonces between the parties. These are (unstructured) random numbers freshly generated by the parties and sent instead of the Diffie-Hellman exponents. These nonces are typically implemented as pseudorandom bit strings of length 64-128. The resultant phases EXCH and AUTH follow the known techniques from the shared-key model originated with <ref type="bibr" target="#b16">[18]</ref>, and further developed and analyzed in subsequent works (especially, [7, 41).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EXCH:</head><formula xml:id="formula_0">A 4 23: nonceA B + A : nonceg</formula><p>The AUTH phase is modified accordingly to replace g x and g y , with nonceA and nonceg, respectively, as the F K ~ arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AUTH:</head><p>A -+ B: FKo(nonceg, nonceA, idA, id^)</p><formula xml:id="formula_1">B + A: FK0 (nonce* , nonceg , ZdB , idA)</formula><p>In this way the combination of EXCH and AUTH provides the parties with the assurance that the key KO they shared through the SHARE phase is known to both of them, and that the party they talked to is the correct one (because only that party had the private key required to decrypt the corresponding halfkey K A or K B ) . The nonces nonceA and nonceg act as challenges to "prove" to each other the possession Computation of t h e session key: One could imagine that the output of the protocol, i.e., the session key S K to be shared between the parties would be KO. However, since KO is used in the protocol as the key to the function F , it should not be output as the session key, otherwise one would be giving away some information on S K before it is even used6. Therefore, instead of outputting SK = KO, we define SK to be F ~~( u r g ) ,</p><p>where urg is the value sent in the message from A to B in phase AUTH, namely, arg = FK, (nonceg , nonceA, zdA, i d B ) . By the properties of pseudorandom functions the value of FK, on arg is (computationally) independent of any other value output by FK,. Thus, the protocol provides no information to an adversary on the value of S K .</p><p>Notice that in order to find SK from this mode of SKEM E, an adversary needs to actively impersonate one of the parties (which may succeed only if the attacker possesses the private key of that party), or to of KO. ~~ 6As an example, assume that the key is used later, in a different protocol, where one of the parties proves to the other the possession of the key S K by just showing a pair ( I , F s K ( I ) ) for any value of I . Had the key S K never been used before then the above would constitute a (one-time) proof of possession of the key; however, doing that with SK = KO would be insecure since the key exchange protocol itself provides such a pair. be able to learn KO by watching the communication in the protocol. However, the latter requires knowing the private keys of both parties in order to decrypt K A and KB. Notice that for a passive attacker (eavesdropper only) knowing only one of the private keys is not sufficient. Therefore, although it does not provide PFS, this mode of the protocol provides a significant level of security without incurring the expense of a Diffie-Hellman exchange.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Pre-shared key and PFS</head><p>In this mode, the protocol assumes that the parties already share a secret key, and that they use this key in order to derive a new and fresh key (as discussed in Section 2, this previously shared key could come from a key distribution center, a manually installed key, a long-lived shared master key, etc.). This mode provides also with perfect forward secrecy (PFS), thus ensuring the parties that even a future compromise of their pre-shared key will not expose all the traffic encrypted with keys derived from the exchanged session keys.</p><p>In this mode of SKEME the SHARE phase can be skipped and the pre-shared key used as KO. No further modification to the basic protocol of Section 3.2 is required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computation of the session key:</head><p>The computation is identical to that of the basic protocol, namely, SK = H(g"Y mod p ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Fast Re-Key</head><p>This is the fastest mode of SKEME. It is intended to provide for very frequent key refreshment without going through expensive operations like public key or Diffie-Hellman computations. It involves only fast operations like MD5. It assumes the parties share a key KO from a previous round of the protocol and they use that key to exchange a new one. The newly exchanged session key SK will have the property that its exposure does not expose any prior keys (however, an eventual exposure of KO would compromise all session keys exchanged under this mode due to its lack of PFS).</p><p>In this mode the SHARE phase is omitted, and the EXCH and AUTH phases are run as in Sec- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The Combined Protocol</head><p>After having described the four modes of SKEME, we present here the complete protocol in which all these modes are combined into one uniform and compact format. This combined protocol is shown in Fig- <ref type="figure">ure</ref> 2 and the derivation of the different modes of SKEME is summarized in the table in Figure <ref type="figure" target="#fig_3">3</ref>. The inclusion in square brackets of the public key encryption pieces is done to stress that these elements are omitted in some of the modes of the protocol.</p><p>Figure <ref type="figure" target="#fig_3">3</ref> shows the following information: mode name, whether the public key encryption is performed or not (in particular, whether the mode assumes the existence of public keys of the parties or not), whether Diffie-Hellman is performed (thus providing or not PFS), and the mode-dependent values of valueA,valueg, KO, and SK. Notice how the four modes of the protocol depend on the selection to perform or not the expensive operations required by the use of public keys (encryption) or to provide PFS (Diffie-Hellman).</p><p>Figure <ref type="figure" target="#fig_2">2</ref> illustrates how the different modes can be implemented through a uniform set of messages. Notice that the same message field can carry either a nonce or a Diffie-Hellman exponent, depending on the mode in use. These fields need to be, in any case, length-variable since the Diffie-Hellman exponents may have different lengths according to the required cryptographic strength. Also the fields carrying the public key encryption can be included or omitted according to the mode (if omitted they can be considered a zero-length field). Finally, the agreement on which mode of the protocol is to be used is part of the negotiation between the parties which also includes negotiation of specific security transforms.</p><p>Many implementation details are omitted here, including system issues (e.g., exact formats, acks, retransmission, security association identifiers, etc.) and cryptographic issues (e.g., off-line/on-line Diffie-Hellman computation, pseudorandom generation, format of public key encryption, derivation of multiple keys, etc.). Also, details of negotiation of modes, options and specific cryptographic primitives are omitted. All of these are beyond the scope of this paper which focuses on the basic design issues and rationale. Many of the implementation details are common or similar to the Photuris protocol <ref type="bibr" target="#b14">[16]</ref> where some of them are already dealt with. We will further address these issues when reporting on our implementation work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Summary of Main Features</head><p>SKEM E is designed to achieve the requirements listed and discussed in Section 2. In particular, to provide support for the different security scenarios and to allow flexible tradeoffs between security and performance, while maintaining system complexity as  simple as possible. In this section we briefly summarize those features whose combination differentiates SKEME from other proposed protocols (most notably, the STS/Photuris protocols [lo, IS]). See Sections 2 and 3 for more details on these features. P u b l i c key-based k e y ecchange. Provides key exchange based on public keys, with and without PFS. In the first case, an eavesdropper does not learn the exchanged key even if it knows both private keys of the parties. In the latter, it requires the compromise of both private keys in order to learn the exchanged session key. Active impersonation of a party during the protocol is possible only by an adversary that possesses the private key of the party.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S u p p o r t m a n u a l i n s t a l l a t i o n a n d o t h e r long-lived mast e r keys.</head><p>Supports key exchange based on a previously shared key between the parties. It provides PFS to this exchange in order to protect against information disclosure in case of exposure of a long-lived key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>K e y e c c h a n g e based o n KDC m o d e l .</head><p>Keys can be exchanged based on a common key distributed to the parties by a KDC. The security of the KDC model is enhanced via the provision of PFS to the key exchange Selective PFS. Perfect forward secrecy via Diffie-Hellman exchange provided as part of the basic protocol. It can be optionally omitted for the scenarios where its cost or functionality is not justified (see Section 2.3.1).</p><p>F a s t re-key. A fast re-key mechanism based on symmetric cryptography only is provided and intended for very frequent refreshment of session keys in order to shorten key lives. P e r f o r m a n c e . The basic mode of SKEME provides the best security functionality and is also the most expensive mode in the protocol. Using RSA for public key encryption it involves, for each party, one long exponentiation for decryption, and 2 exponentiations (one off-line) for Diffie-Hellman. In the pre-shared key modes, the public key decryption operations are saved, while in the share-only mode (without PFS) the two exponentiations per party of Diffie-Hellman are saved. The fastest mode is 'fast re-key' which involves symmetric key operation only (MD5-like). We stress that the cost of a Diffie-Hellman exchange can be reduced by using short exponents. For mod p implementations we recommend a bare minimum of 160 bits for the exponents (the values a and y in our description), and preferably 256 bits7. Notice, also, that in SKEME the computation of g"Y can be performed (or completed) after the end of the protocol (since this value is not used by the protocol itself except for the computation of SK). This avoids the introduction of delays between protocol messages due to this long computation'. K e y separation. SKEME is carefully designed according to the key separation principle (see Section 2.2).</p><p>SK is never used in the protocol. KO is used in the protocol only as a key to the function F. In the cases where KO is produced by the SHARE phase then we know that KO was not used before (and won't be used beyond the protocol). However, in the modes where KO is input into the protocol (the pre-shared mode and fast re-key) the implementation has to be careful not to use this key outside the protocol for anything else except keying the function F . (This would be satisfied if, e.g., &amp; is freshly distributed by a KDC, or if KO is a key solely used in consecutive runs of the fast re-key protocol.) As for the key SK, we recommend not using it to directly key a cryptographic algorithm applied to data during the session, but instead to use SK to derive independent keys for the different algorithms used during the session. As an example if a key for DES-CBC is required, then the key to be used can be derived from FSK (des-cbc-id) where des-cbc-id stands for a unique identifier for this algorithm. We note that there are ways to derive a variable number of key bits using pseudorandom or keyed hash functions. (Details are beyond the scope of the paper.)</p><p>A n o n y m i t y . The initiator, A, of the protocol may hide her identity whenever the mandatory plain information (e.g., IP address) is insufficient to identify her. This feature is achieved in a 'natural' way by encrypting A's identity, in the first message, together with the half-key exchange. This property is not provided for key exchange based on previously shared keys; in these cases, sending the parties identities is unnecessary since the parties identify themselves via IP addresses and previously exchanged security association identifiers. Identification of the receiver is not disclosed by the protocol except for the necessarily transmitted plain information (IP address). Sagnature-less property. The protocol does not use digital signatures. This avoids privacy issues as the need to encrypt these signatures for anonymity, and </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A l g o r i t h m independence.</head><p>The protocol requires several cryptographic primitives, but does not depend on any specific implementation of these primitives (only on the basic requirements from these functions as specified in section 3.1. Protocol complexity. In spite of the broad functionality it provides, the protocol has a simple and compact form. Different modes are supported with a small and uniform set of messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Security</head><p>Although this paper concentrates on the clescription of the protocol and its requirements, and not on a detailed security analysis, we present here some brief arguments supporting the security of SKEME. (This line of analysis is based on the generic security requirements from the underlying cryptographic functions rather than on specific implementations of these functions. In this way we achieve true algorithm independence.)</p><p>We need to argue for the security of the four modes of SKEME. The fast re-key mode (section 3.3.3) follows the well-understood and analyzed protocols in [7, 41.</p><p>In particular, the paper by Bellare and Rogaway <ref type="bibr" target="#b3">[4]</ref> (see AKEPB protocol in that paper), contains a rigorous proof of security directly applicable to this mode of SKEME. It follows that this mode is secure (for secrecy and authenticity) as long as the underlying cryptographic primitivee are aecure in the sense defined in section 3.1.</p><p>We argue that the analysis in <ref type="bibr" target="#b3">[4]</ref> can be adapted to prove the mode of SKEME (section 3.3.2) in which the parties share a key KO prior to the protocol and use this key to authenticate the Diffie-Hellman exchange, This protocol can be "mapped" to the protocols analyzed in <ref type="bibr" target="#b3">[4]</ref> by considering the Diffie-Hellman exponents (9" and gy) as the nonces in the protocol. If instead of generating the session key SK by H(g"Y)</p><p>we would do it by applying the pseudorandom function F K ~ to gzY, then the extension of the analysis of <ref type="bibr" target="#b3">[4]</ref> is straightforward. (A suggestion along these lines was first made in <ref type="bibr" target="#b4">[5]</ref>.) There is no problem to modify our description of the protocol to use F K ~ as above. On the other hand, by using the Diffie-Hellman conjecture on the unpredictability of S K = B(g"3') given gx and g y (a conjecture required anyway for the perfect forward secrecy of the basic Diffie-Hellman exchange) the proof can be extended to this case too.</p><p>The other two modes of SKEME are related to the above. The difference is that instead of assuming a pre-shared secret key KO between the parties, it is SKEME itself that generates this key through the HARE phase. That phase, by itself, does not guarantee anything except that if there are any parties that know the key KO = H ( K A , K B ) after the execution of SHARE then those parties are A and/or B. (This is implied by the security of the encryption function PKE.) Therefore, the premise that KO is not known to anybody except for A and B , which is the basis for the proof in the case of a pre-shared key, holds here too. (We stress that the successful run of the AUTH phase serves by itself as a confirmation that A and B indeed learned the key KO through the HARE phase.) This is clearly an informal argument. Formalizing these ideas requires extending the definitions of security from the shared-key model to public key. Based on such definitions, a formal proof would show that any adversary that can break the security of the protocol (by impersonation, learning information on the key, etc.) can be transformed into an adversary that is able to break (one or more of) the underlying cryptographic functions (e.g., the public key encryption, the pseudorandom function, etc.). Then, the security of SKEME would follow from the security of these cryptographic primitives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Concluding Remarks</head><p>We have presented a versatile protocol for key exchange suitable to support a wide variety of scenarios, security models, and security-performance tradeoffs. The main motivation for the present work has been the ongoing effort in the Internet community to standarize key management mechanisms to support secure IP (Internet Protocol). However, this work has applicability to many other environments as well, e.g., the framework of IEEE security protocols <ref type="bibr">[14]</ref>.</p><p>The protocol has many similarities, and some im-portant differences, with Photuris <ref type="bibr" target="#b14">[16]</ref>, which is being developed through the IPSEC working group of the IETF for the above purpose. Both protocols provide as their basis an authenticated Diffie-Hellman exchange based on public key. Photuris does it by first performing a Diffie-Hellman exchange and then authenticating it through the use of digital signatures. SKEME uses public key encryption to exchange a onetime key and then uses shared-key techniques to authenticate the Diffie-Hellman exchange. The main advantage of the SKEM E approach is that it allows for selective performance of the (expensive) Diffie-Hellman operations. That is, in SKEME one can skip the Diffie-Hellman phase and still have a key exchanged between the parties; in Photuris that is not possible. Photuris was originally designed with less functionality in mind than SKEME. One of the main motivations in developing SKEME (whose basic ideas were first presented by this author through the IPSEC working group) was to promote the addition to the Photuris protocol of some of the elements presented here. These elements include the support of sharedkey models (mainly, manual installation and key distribution centers) and the performance of cheap and frequent re-key operations (based on fast symmetric key techniques only). Some support for these aspects has since then been added to Photuris. The latter would be further benefited by the adoption of the specific mechanisms provided in SKEME for the pre-shared key modes, including fast re-key (as said, these mechanisms follow well-known and analyzed techniques from previous works). Finally, the support in Photuris for selective Diffie-Hellman performance is also strongly recommended.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>forward secrecy (denoted PFS) is a central notion pertaining key exchange protocols. It refers to the property that "disclosure of long-term secret keying material does not compromise the secrecy of exchanged keys from earlier runs." [lo]. This property has a central role in our protocol and it is extensively discussed in Section 2.3.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>tion 3 . 3 . 1 ,</head><label>331</label><figDesc>namely, by exchanging nonces rather than Diffie-Hellman exponents. (The resultant fast re-key protocol follows the authentication and key exchange techniques of [7, 41 based on symmetric key cryptography only.) Computation of the session key: Computation of S K is identical to that of Section 3.3.1, namely, SK = FKo(arg), where arg = F ~~( n o n c e g , nonceA, id^, id^) is the value sent in the message from A to B in phase AUTH.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Combined SKEME Protocol</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: SKEME Modes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>preventive measure against partners to communica- tion that use too short exponents (a fact that is hard to detect) SKEME could use a key derived from the SHARE phase to en- crypt the Diffie-Hellman exchange. stress that in contrast to some other protocols (e.g., [lo, 161) there is no security or functional reason in SKEME to prove possession of the session key by the parties during the protocol. This possession is (implicitly) guaranteed by a successful (i.e., errorless) completion of the protocol.</head><label></label><figDesc></figDesc><table><row><cell>~~</cell><cell>~ 7As a most importantly, avoids providing (forced) "proof-s" of communication between the parties (see Sec-tion 2.3.2). Notice that authentication is carried in SKEME via MAC or pseudorandom functions, and then it provides no useful proof of communication to third parties. D e n i a l of service attacks. Potential clogging attacks are alleviated through the cookies technique of [16]. Use of s y m m e t r i c encryption. There is no requirement for use of symmetric encryption inside the protocol. It may be optionally used to provide anonymity in the case in which A transmits her own public key certifi-cate to B in the first message of the protocol, but has no other security implications. U s e of public Bey encryption. Our protocol uses public key encryption to allow for key exchange without re-curring to Diffie-Hellman (costly) algorithm. It is also used as a replacement for signatures when running Diffie-Hellman; in this case the key (KO) exchanged through the use of encryption is used only for the purpose of authentication. We note that public key encryption is regulated in some countries. However, it is generally allowed for use for the purpose of key distribution. If desired, in order to enhance security, one could periodically renew these keys; e.g., by self-certifying them using a long-term certified signature key.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>I thank Pau-Chen Cheng, Juan Garay, and Amir Herzberg, for many fruitful discussions on IP security and key management. The work presented in this paper is a follow-up to our joint work on the MKMP protocol [8]. I also thank Shai Halevi, Paul van Oorschot, and David Wagner, for their excellent comments on earlier versions of this paper (though, of course, I carry full responsibility for all the paper's faults). Finally, I thank the program committee for the thorough review of the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Security Architecture for the Internet Protocol</title>
		<author>
			<persName><forename type="first">R</forename><surname>Atkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">1825</biblScope>
			<date type="published" when="1995-08">August 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">IP Authentication Header</title>
		<author>
			<persName><forename type="first">R</forename><surname>Atkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">1826</biblScope>
			<date type="published" when="1995-08">August 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Simple Key-Management for Internet Protocols (SKIP)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-09">September 1995</date>
		</imprint>
	</monogr>
	<note>Internet Draft draft-ietfipsec-aziz-skip-02.txt. work in progress</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Entity Authentication and Key Distribution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<ptr target="//wan-cse.ucsd.eau/users/mihir" />
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Stinson Ed</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="232" to="249" />
			<date type="published" when="1994">1994</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Advances in Cryptology, -CRYPTO&apos;93</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Distributing keys with perfect forward secrecy</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994-01">Jan. 1994</date>
		</imprint>
	</monogr>
	<note>manuscript</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Optimal Asymmetric Encryption -How to encrypt with RSA</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT&apos;Pd Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">De</forename><surname>Santis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ed</forename></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">950</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Systematic design of a family of attack-resistant authentication protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Gopal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Herzberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Janson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kutten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Molva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications (special issue on Secure Communications)</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="679" to="693" />
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Design and implementation of modular key management protocol and IP Secure Tunnel on AIX</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hersberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<ptr target="y/mkmp-ipst-usenix.ps" />
	</analytic>
	<monogr>
		<title level="m">Proc. 5th USENIX UNIX Security Syposium, Salt Lake City, Also available from ftp site software.watson.ibm</title>
		<meeting>5th USENIX UNIX Security Syposium, Salt Lake City, Also available from ftp site software.watson.ibm</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">New Directions in Cryptography</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Info. Theory IT</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="644" to="654" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Authentication and Authenticated Key Exchanges</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorshot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Designs, Codes and Cryptography</title>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="107" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="210" to="217" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Probabilistic Encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An identity-based key-exchange protocol</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Gunther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EURO-CRYPT&apos;SS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Key Management Protocol</publisher>
			<date type="published" when="1990-03">1990. March 1995</date>
			<biblScope unit="volume">434</biblScope>
			<biblScope unit="page" from="29" to="37" />
		</imprint>
	</monogr>
	<note>IEEE. draft</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Entity authentication mechanisms -Part 3: Entity authentication using asymmetric techniques</title>
		<idno>ISO/IEC IS 9798-3</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The Photuris Session Key Management Protocol</title>
		<author>
			<persName><forename type="first">P</forename><surname>Karn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Simpson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-09">September 1995</date>
		</imprint>
	</monogr>
	<note>Internet Draft draft-ietf-ipsec-photuris-03.txt</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Meneses</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
		<title level="m">Handbook of Applied Cryptography</title>
		<meeting><address><addrLine>Boca Raton, Florida</addrLine></address></meeting>
		<imprint>
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
	<note>to appear 1996</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using encryption for authentication in large networks of computers</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="993" to="999" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Kerberos: An Authentication Service for Computer Networks</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Neuman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ts'o</surname></persName>
		</author>
		<ptr target="http://nii.isi.edu/publications/kerheros-neuman-tso.htm1" />
	</analytic>
	<monogr>
		<title level="j">IEEE Communications</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="33" to="38" />
			<date type="published" when="1994-09">Sept. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Rueppel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modern key agreement techniques</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="458" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Zimmermann</surname></persName>
		</author>
		<title level="m">PGP User&apos;s Guide</title>
		<meeting><address><addrLine>Boulder, Colo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
