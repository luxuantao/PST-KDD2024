<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Data Dependence Tracking and its Application to Branch Prediction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lei</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rochester</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Steve</forename><surname>Dropsho</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rochester</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">H</forename><surname>Albonesi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rochester</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Data Dependence Tracking and its Application to Branch Prediction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>To continue to improve processor performance, microarchitects seek to increase the effective instruction level parallelism (ILP) that can be exploited in applications. A fundamental limit to improving ILP is data dependences among instructions. If data dependence information is available at run-time, there are many uses to improve ILP. Prior published examples include decoupled branch execution architectures and critical instruction detection.</p><p>In this paper, we describe an efficient hardware mechanism to dynamically track the data dependence chains of the instructions in the pipeline. This information is available on a cycle-by-cycle basis to the microengine for optimizing its performance. We then use this design in a new value-based branch prediction design using Available Register Value Information (ARVI). From the use of data dependence information, the ARVI branch predictor has better prediction accuracy over a comparably sized hybrid branch predictor. With ARVI used as the second-level branch predictor, the improved prediction accuracy results in a 12.6% performance improvement on average across the SPEC95 integer benchmark suite.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Much of the effort expended by microprocessor architects in the last decade has been centered on exploiting the inherent instruction-level parallelism (ILP) of serial programs. Examples include dynamic branch prediction, speculation, out-of-order superscalar execution, and parallel memory access. However, ILP performance gains have slowed considerably as these techniques have become commonplace in 4-and 6-way issue processors. A number of program properties, including control dependences, memory requirements, and data dependences, threaten to limit further gains. The latter has long been cited in limit studies, such as the well-known study by Wall <ref type="bibr" target="#b33">[34]</ref>, as the inherent program characteristic that fundamentally limits ILP gains. Value prediction <ref type="bibr" target="#b21">[22]</ref>, though a promising approach for alleviating data dependence barriers, has yet to yield the cost-performance gains necessary for widespread commercial adoption. For these reasons, the alleviation of data dependences, and the exploitation of data dependence information, remain key microarchitectural challenges.</p><p>Compilers have long performed static data dependence analysis for code optimizations. Such information could be invaluable to microarchitects for many purposes. Yet, such static information is both unwieldly to pass via instruction fields and potentially less precise than the dynamic data dependence information that could be gleaned at runtime.</p><p>In this paper, we present accurate and efficient hardwarebased mechanisms for cycle-by-cycle tracking of data dependences among all in-flight instructions in a dynamic superscalar microprocessor. We propose schemes appropriate for centralized physical register files (as in the Mips R10000 <ref type="bibr" target="#b34">[35]</ref> and Alpha 21264 <ref type="bibr" target="#b18">[19]</ref> microprocessors). A four-way fetch/issue/commit processor with 80 in-flight instructions and 72 physical integer registers requires 730 bytes of RAM with eight read and four write ports and modest control logic for data dependence tracking. This complexity compares favorably with that of other on-chip RAM/CAM structures (e.g., branch predictors, out-of-order issue queues) that are purely used for performance purposes.</p><p>We enumerate some of the many applications for such on-line data dependence information. These include dynamic scheduling, selective value prediction <ref type="bibr" target="#b5">[6]</ref>, criticality measures and their application <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30]</ref>, and decoupled architectures <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b32">33]</ref> to name a few. We then investigate in depth how dynamic data dependence information can be exploited to provide another dimension for branch prediction. Our approach, called ARVI, bases its prediction on partial register values along the data dependence chain leading up to the branch. This is a subtle, but important difference from approaches that use the branch register values directly as they are rarely available (and thus, for instance, must be predicted). We discuss how the correlation between such register value information and the branch outcome can for some branches be stronger than either history or path information. A two-level predictor using ARVI at the second level achieves a 12.6% overall IPC improvement for the SPEC95 integer benchmarks as compared to the stateof-the-art two-level predictor <ref type="bibr" target="#b25">[26]</ref> proposed for the Alpha EV8.</p><p>The rest of this paper is organized as follows. The hardware mechanism for data dependence tracking is described in Section 2, and potential applications are reviewed in Section 3. A novel branch prediction scheme (ARVI) based on the data dependence information is presented in Section 4. Our methodology is detailed in Section 5, while results of using an ARVI predictor on a set of integer benchmarks is presented in Section 6. Other related work is discussed in Section 7, and we conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Dynamic data dependence tracking</head><p>Data dependence analysis is a fundamental technique employed in compilers to maintain the correctness of code when performing optimization transformations. A data dependence chain shows ordering relationships between a sequence of instructions that must be preserved. A data dependence chain is defined relative to a particular instruction. Each instruction has its own data dependence chain, though different chains may share common instructions. In the following sections we describe the Data Dependence Table (DDT), a hardware method for incrementally maintaining the data dependence chains for the set of instructions in the processor pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">DDT operation</head><p>The DDT is implemented as a RAM. The depth of the RAM is one row for each physical register. The width of a row is one bit per instruction that can be in flight in the pipeline, thus, each instruction occupies a column in the DDT RAM. For clarity, we will refer to data in the row of the DDT RAM as a DDT register entry or simply as a register entry. Also, we refer to the instruction information occupying a column in the RAM as a DDT instruction entry or as an instruction entry.</p><p>The operation of the DDT is best described with an example, shown in Figure <ref type="figure">1</ref>. In this figure, the DDT RAM is oriented at 90 degrees, i.e., rows of the RAM are shown as vertical and columns are shown as horizontal. Let us assume the current state as shown in the top table with the instructions entered into the DDT shown at the right. The physical register numbers are shown at the top. Entries with an 'x' indicate that the bit is set and the physical register depends on that instruction. For example, physical register p5 is data dependent on both instructions 1 and 2. Register p5 is also trivially data dependent on its own instruction (3), so that entry is marked as well.</p><p>The lower table details the actions when a new instruction is added. The instruction is an add of registers p4 and p7 with the result deposited into p8. Since p8 is the target register, we need to set the appropriate bits in register entry for p8. The instruction is allotted the next empty instruction entry in the table, instruction entry 6. The bit at instruction entry 6, register entry 8 is set because every register is data dependent upon the instruction that updates it. Then register entries associated with the source registers, p4 and p7, are OR'd and the result is AND'd with the valid bit vector to limit the result only to settings from active instructions currently in the pipeline. The result is then written to the register 8 entry:</p><formula xml:id="formula_0">DDT[Target] = (DDT[Src1] OR DDT[Src2]</formula><p>) AND Valid-Vector. The entry for physical register p8 now contains the data dependence chain consisting of instructions 1, 2, 5, and 6. Instruction entries are allocated in circular FIFO fashion using head and tail pointers. For each instruction, access to the DDT occurs after register rename has assigned physical registers. Once the physical registers are known, two simultaneous reads of the source register entries are performed in one cycle and the result is written to the destination register's entry in the second cycle.</p><p>When an instruction commits it must be eliminated from all dependence chains because its register value is now ready for immediate use. An instruction is removed from the DDT by clearing its associated bit in the valid vector. Since all reads from the DDT are conditioned by the valid vector, clearing a valid bit immediately removes the associated instruction from henceforth being included in any dependence chains. Additionally, the tail pointer to the DDT circular buffer is incremented to free the instruction entry for reuse. However, before a new instruction reuses an instruction entry, all bits in the instruction entry must be cleared.</p><p>A branch misprediction requires a rollback of the DDT information to its state prior to the mispredicted branch. Since the structure of the DDT is similar to the Reorder Buffer (ROB), this rollback is achieved in an identical fashion. Just as in the ROB a pointer is decremented to point to the instruction before the mis-speculated instruction so, too, is the pointer in the DDT.</p><p>In this paper we only consider data dependences involving integer registers. The number of bits in the DDT is the number of ROB entries times the number of physical registers. The Alpha 21264 has 80 ROB entries and 72 phys- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Applications of on-line data dependence tracking</head><p>There are many potential applications of online, cycleby-cycle, data dependence tracking. Some examples: £ Dynamic scheduling: Instruction issue priority can be partially based on data dependence properties. One possibility is to assign priority to loads partially based on the length of their dependence chains. It is an incremental addition to the basic DDT design to track the number of data dependent instructions trailing particular instructions. By adding a small counter to each row in the DDT, this information can be updated for each instruction simultaneously on a cycle-by-cycle basis. £ Instruction fetching in SMT processors: In an SMT processor, instructions are fetched from the high-est priority threads according to some criteria. In Tullsen's ICOUNT policy <ref type="bibr" target="#b31">[32]</ref>, for example, priority is given to those threads that have the fewest instructions in the front-end and issue queues. Part of the rationale is that such threads should be rewarded for making forward progress. Per-thread data dependence chain information, e.g., the average length of each chain, can potentially provide a more accurate measure of the likelihood of a particular thread making forward progress in the near future. The above counter mechanism can be used to calculate these values on a per-thread basis using per-thread DDTs.</p><p>£ Selected value prediction: In value prediction, the relatively high cost of a misprediction and the relatively low prediction accuracy (in general) makes it imperative that it be applied wisely. Calder et al. <ref type="bibr" target="#b5">[6]</ref> restrict value prediction to instructions whose early resolution can have significant impact on overall performance. Their heuristic selects as critical instructions those which have a long data dependence chain waiting on their outcome. However, no mechanism for determining this length is described. Using the mechanism described above, those instructions that exceed a threshold count may be selected for value prediction.</p><p>£ Dynamic branch decoupled architectures: In these designs, the string of instructions comprising the dependence chain to a branch in a loop are segregated and executed in a parallel branch execution unit (BEX). Since the set of instructions in the dependence chain is fewer than the full set of instructions in the loop, the BEX unit will run ahead of the main execution unit and precompute branch outcomes so that, ideally, the main loop will never mispredict the outcome of the branch. In the DDT table, the data dependence chain is immediately available.</p><p>£ Optimizations driven by parallelism metrics: Bahar and Manne <ref type="bibr" target="#b1">[2]</ref> propose gating off pipeline resources based on recent IPC performance in order to save power. Similarly, Folegnani <ref type="bibr" target="#b11">[12]</ref> dynamically adapts the size of the issue queue according to parallelism estimates derived from the Reorder Buffer. Dependence chain information can potentially provide a more accurate parallelism estimate to guide these and other parallelism-based optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>£ Improving the accuracy of criticality measures:</head><p>Load criticality was originally investigated by Srinivasan and Lebeck <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref> in order to improve load performance. Other researchers, including Bodik <ref type="bibr" target="#b10">[11]</ref>, have proposed techniques for identifying critical instructions. Cycle-by-cycle dependence chain information can potentially improve the accuracy of critical instruction detection. For instance, Bodik's random sampling approach may unintentionally miss critical sequences. Data dependence information can potentially provide more directed, rather than random, sampling to increase critical instruction detection.</p><p>£ Dynamic branch prediction: History and path-based branch prediction can be augmented with a predictor that correlates the register values of instructions along the data dependence chain leading up to the branch. This is a subtle, but important, difference from approaches that use the branch register values directly and thereby achieve limited improvements.</p><p>In the next section, we describe a branch prediction mechanism that uses an augmented DDT design to quickly select the minimum set of registers in the data dependence chain upon which the branch outcome depends, and uses partial register values to make the prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The ARVI branch predictor</head><p>A branch instruction makes a decision based on the relationship between two values. The two values may be values in registers or one may be in a register and the other a constant. For a given path to the branch, if all the register values involved in its resolution have identical values as in a prior occurrence then the outcome will be the same. If one can determine the essential values in the data dependence chain that determine the final values at the branch, and those values have occurred in the past, then the outcome of the branch will be known. This method is valuebased branch prediction and is the essential idea behind the ARVI predictor.</p><p>Upon fetching a branch instruction, a prediction must be made based on the available information at that time. Ideally, if the values of the branch registers are available (i.e., committed) then a table look up can provide the outcome of the branch the last time those same values were present. In practice, the branch register values are rarely available at the time of the prediction. However, if values are available for registers along the dependence chain that leads up to the branch, then the predictor can use these values to index into a table and recall how the branch behaved the last time under the same circumstances. If the register set and value information is precise, then the branch must behave identically and the prediction can be made with certainty.</p><p>Prior work has shown that the path leading to a branch provides important information with which to classify instances of a branch. Behavior of a branch within a particular class (path) generally exhibits consistent behavior that a two bit saturating counter quickly learns. Instead of relying solely on branch history or a hash of branch PC addresses to identify the particular path, ARVI includes the data dependent register set as part of the signature and uses a hash of the register identifiers and the PC as an index into a table. The values in each of the registers in the set are likewise hashed together and used as a tag to disambiguate between occurrences of the same path but having different values in the registers. A distinguishing feature of the ARVI design is that it uses both path-and value-based information to classify branch instances.</p><p>Loops present an additional challenge in creating a unique path signature. In a heavily pipelined superscalar processor (20+ stages and 200+ instructions in flight simultaneously), the data dependence chain can span many iterations of a loop. In such circumstances, the data dependent register set may be the same in each iteration and make the path information ambiguous. A simple technique to disambiguate between iterations -without actually identifying loop constructs -is to include distance information between the instance of the register set whose values are used and the branch instruction. The ARVI design records as part of a tag the maximum number of instructions spanned by the dependence chain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">ARVI implementation details</head><p>ARVI uses the DDT to extract the set of registers corresponding to instructions along the data dependence chain leading up to the branch. A table look up indexed by a combination of the branch PC and the values in the register set returns information describing past branch behavior. Tag checks ensure that the entry corresponds to a prior, similar occurrence of the branch. If the tags match, then the prior outcome is used as the prediction. Since ARVI requires the physical register mappings, register rename must occur early in the pipeline. RISC instruction set architectures with highly regular instruction encodings permit this early register rename at fetch time. However, early rename requires additional physical registers because more mapped instructions can be in flight in the pipeline.</p><p>The details to generate a prediction in the ARVI predictor are listed in Table <ref type="table">1</ref> and their staging is shown in Figure 2. To make a prediction, the data dependence chain for the branch register is read from the DDT. This vector is fed to a filter called the Register Set Extractor (RSE) which forms the set of active registers that generate the value(s) being compared in the branch. From the PC and values in the register set, the index into the Branch Value Information Table (BVIT) is generated. The BVIT holds tags and information regarding prior branch occurrences. The read of the BVIT returns one tag based on the sum of the register identifiers, a second tag based on the length of the data dependence chain, a performance counter to aid in set replacement, and the prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1. ARVI access details</head><p>Step Action 1. Read the data dependence chain from the DDT for the branch 2. Generate the register set from the dependence chain (RSE) 3. In parallel, generate the index and tag a. Form a BVIT index from the XOR hash of register values b. Form a sum of the register set identifiers 4. Index the BVIT, compare the ID and depth tags, return a prediction Four-way set associativity in the BVIT helps minimize the thrashing that often occurs in direct-mapped buffers. A 3-bit performance counter based on Heil's design <ref type="bibr" target="#b16">[17]</ref> tracks the effectiveness of each entry and is used to select which entry to replace when a new entry is added.</p><p>If all the values of the required registers in the dependence chain are available at the time of the prediction then the input state precisely defines the outcome and we call this instance of the branch a calculated branch. If a value is not available at the time of the prediction then by necessity the data dependence chain has values that depend on outstanding load instructions and the current machine state does not precisely define the branch outcome. We call this type of branch a load branch.</p><p>We estimate that the ARVI predictor requires six cycles to make a prediction. The breakdown of the latency for each action is shown in Figure <ref type="figure">2</ref>. The long latency for the ARVI predictor necessitates a fast one cycle first level predictor to make an initial prediction that the ARVI predictor may override when its prediction is available. In addition to providing a fast initial prediction, the small first level predictor acts to filter easily predicted branches which results in dedicating ARVI resources to difficult branches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Selecting the branch register set from the DDT</head><p>The set of registers that generate the value for the branch comparison are available in the data dependence chain for the branch instruction's operand registers. The DDT has this information, but a complementary circuit, the RSE, is needed to extract it efficiently.</p><p>The operation of the RSE is shown in Figure <ref type="figure" target="#fig_0">3</ref>. The left hand table is the DDT in the same state as in the prior DDT example of Figure <ref type="figure">1</ref>. The RSE table on the right has the same identical dimensions as the DDT but each location contains 2 bits instead of one. When an instruction is inserted into the DDT (in stage 2, after the dependence chain information is read in stage 1), the source and destination registers for the instruction are marked in the corresponding entry in the RSE. A source register is marked in the example as S but is encoded as 01. The target register T is encoded as 10. Because the ARVI predictor treats load instructions as termination points in the chain, we do not set the source and target registers for loads (marked with '*' in the figure for this discussion).</p><p>When a branch arrives (instruction 7), we read the appropriate register entries from the DDT for the branch's operand registers (only p8 in the example). The marks indicating the data dependence chain form a bit vector that is used as enables to activate instruction entries in the RSE. If the branch instruction has two source operands then the bit vector for the enables is the OR of the two DDT entries. Each register entry in the RSE (the vertical dimension of the RSE in the figure) is spanned by two bit-lines to support the three encodings ¤ Unused='11', Source='10', Tar-get='01'¥ . We create the register set by precharging these bit-lines and then enabling the RSE instruction entries with the DDT data dependence chain bit vector. Any element in the RSE that is set to 'S' in the selected rows will discharge the low order bit-line (bit[0]). Similarly, any element set to 'T' will discharge the high order bit-line (bit <ref type="bibr" target="#b0">[1]</ref>). The resulting 2-bit value is consolidated to a single bit via the function ¦ ¨ § © ! " $# &amp;% (' 0) ! " 1# 32 (' . The result is '1' if and only if one of the selected instructions uses the register as a source and none use it as a target. This function removes registers from the chain whose values are calculated by other instructions in the chain. Such registers are redundant. In our example, the final set of registers is ¤ p1,  The register p3 is in the set because its value is currently available (thus, the instruction that set p3 has been committed and removed from the ROB and DDT).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Forming the index into the BVIT</head><p>The index into the BVIT is the XOR of the low order 4 bits of the values in the registers specified by the RSE register set bit vector. For our study, we configure the BVIT table as 2K entries with 4-way set associativity, thus, 4 5 65 bits. To avoid additional register file ports, a shadow set of the registers is kept but only the low order 11 bits of the value, as is shown in Figure <ref type="figure" target="#fig_1">4</ref>(a). A shadow register file for an Alpha 21264 with 72 physical integer registers would require 792 bits. Updates to the register file also update our duplicate set one cycle later. As shown in Figure <ref type="figure" target="#fig_1">4a</ref>, the low order bits of the branch address and the 11-bit values of the shadow registers selected by the RSE register set bit vector are XOR'd to form the BVIT index. A microarchitecture with 7 physical registers requires 8 5 95 A@ 7 CB XOR gates in a tree (D &amp;E 6F HG I7 CB deep.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Forming the register set tag</head><p>Differentiating paths to a branch can improve prediction accuracy <ref type="bibr" target="#b23">[24]</ref>. ARVI uses the set of registers from the RSE as a path differentiator. Since a full concatenation of the register IDs is impractical, we have discovered that a simple 3-bit sum of the low order logical branch IDs is sufficient.</p><p>The tag formation is shown in Figure <ref type="figure" target="#fig_1">4</ref>(b). The logical branch IDs are used because the physical register assignments are likely to vary between occurrences. Thus, we keep a shadow table of the register map table and update it whenever a register is allocated. We need only store the low order 3 bits of the logical register ID in the shadow map table and structure it as a vector of 96 bits (assuming the ISA defines a set of 32 logical registers). The summation is limited to a width of 3 bits. Since the result is used as a tag to verify a hit in ARVI, this addition tree can have a multiple cycle latency and be pipelined. The tag calculation must complete within the time for the XOR tree hash plus the access time to the BVIT table. The pipeline timing is shown in Figure <ref type="figure">2</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Forming the DD chain depth key</head><p>Tight loops can experience identical paths to a branch on successive iterations. We find it is important to differentiate these occurrences; however, because the logical set of registers involved are identical in each iteration, we need an additional tag. In experimenting with various metrics, we found that a simple but useful choice is the maximum number of instructions spanned by the dependence chain. We maintain a 5-bit value for this distance. This distance is calculated by subtracting the indices for the head pointer and the furthest instruction back in the dependence chain. Detecting the furthest instruction requires detecting the leading '1' in the DDT bit vector for the particular DDT register entry, while considering that the DDT buffer may have wrapped around the end of the RAM. This problem is similar to that in <ref type="bibr" target="#b4">[5]</ref> and can be solved with two priority encoders: one for the a non-wrapping chain and another for the case where the chain does wrap around the end of the RAM. The timing to generate this information is not critical and can be pipelined (see Figure <ref type="figure">2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Methodology</head><p>Our evaluation methodology uses Simplescalar <ref type="bibr" target="#b3">[4]</ref> for the PISA instruction set. Table <ref type="table" target="#tab_3">2</ref> lists the microarchitectural parameters and Table <ref type="table" target="#tab_4">3</ref> lists the benchmark suite. We selected the SPEC95 integer benchmarks because their branch behavior has been extensively studied which permits comparisons to be made across studies.</p><p>The purpose of the branch predictor is to improve the IPC performance of the microprocessor. Since the branch penalty for a mispredicted branch is directly related to the length of the processor pipeline (fetch through execute), we compare results for three different pipeline depths: 20-, 40-, and 60-cycle pipelines. These depths were selected because 20-cycles matches Intel's Pentium 4 design <ref type="bibr" target="#b12">[13]</ref> and higher clock rates will likely continue to increase the number of stages in future designs <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b27">28]</ref>. We have extended the base simulator to support two levels of branch prediction. In all configurations, the first level of branch prediction is a hybrid predictor based on the Alpha EV8 branch predictor design called 2Bc-gskew <ref type="bibr" target="#b25">[26]</ref>. There are three predictor tables and one table that controls which table provides the prediction. Each table is 1 KB in size for a total of 4 KB for the level one predictor and modeled as having single cycle access. Future technology estimates from <ref type="bibr" target="#b17">[18]</ref> suggest that modest size predictor RAMs will be required for single cycle access times. The Level-2 predictor is modeled as having a multicycle access time and is either a larger version of the base hybrid predictor (8 KB for each of the four RAMs for a total of 32 KB) or a comparably sized ARVI predictor (32 KB including the dependence tracking hardware). Upon detecting a branch, the first-level predictor returns an immediate prediction to direct the fetch unit. A number of cycles later (the number depending on the Level-2 predictor in use) the result from the larger Level-2 predictor is ready. If the second prediction agrees with the first then instruction fetching continues uninterrupted. In the hybrid L2, if the two predictions differ then the level 2 prediction is used. For the ARVI predictor, since the L1 hybrid is used to filter easily predicted highly biased branches, a confidence estimator <ref type="bibr" target="#b13">[14]</ref> indicates whether the branch is more difficult to predict and that the ARVI predictor should be used. We explore the performance for pipeline latencies of 20, 40, and 60 cycles (stages). The access latencies for the caches and main memory shown in Table <ref type="table" target="#tab_3">2</ref> vary with pipeline length. The values chosen are motivated by the results on future technology trends in <ref type="bibr" target="#b0">[1]</ref>.</p><p>In the ARVI design, we assume the BVIT RAM (32 KB 4-way) access requires 2, 4, and 6 cycles for each of the pipeline lengths, respectively. We use the BVIT RAM latency as the access time for the larger base hybrid predictor since the structure is similar to a 4-way RAM. Thus, in our model, the baseline Level-2 hybrid predictor is significantly faster than ARVI. The access latencies are listed in Table <ref type="table" target="#tab_5">4</ref>. We simulate four configurations. The baseline configuration uses the hybrid predictor 2Bc-gskew both for the Level-1 and for the Level-2 predictors. The other three configurations use the same 2Bc-gskew predictor as the fast Level-1 predictor but use the ARVI predictor for the larger Level-2 predictor.</p><p>The base ARVI configuration is the current value configuration which makes predictions as described in Section 4. We also attempt to increase the distance between a branch and a dependent load. The purpose is to increase the percentage of calculate branches, which are easier to predict as we show in the next section. We simulate moving load instructions back as far as possible while respecting all data dependences. We aggressively compare addresses at runtime to disambiguate memory references, which is an optimization a compiler can often not perform. We call this version load back. As a bound on performance, we also simulate a perfect value configuration that uses the true reg- ister values even if they would not be available at the time of the prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>Figure <ref type="figure" target="#fig_2">5</ref>(a) shows the fraction of load branches in each application using current value. The remaining fraction are calculate branches. The large fraction of load branchesbranches whose dependence chain requires values not yet available due to pending loads -is due to the fact that a large number of SPEC95 integer program branches are of the type load-evaluate-branch. Increasing pipeline depth increases the number of instructions in flight, which increases the probability that the branch dependence chain terminates in a non-committed load. Thus, a small number of calculate branches become load branches with increasing Figure <ref type="figure" target="#fig_2">5</ref>(b) compares the prediction rates of the two classes. In general, load branches are more difficult to predict, particularly those loads whose values are not consistent when repeatedly encountered. Developing methods that move loads back in order to convert a load branch into a calculated branch, such as we model with load back, should help improve the overall prediction accuracy.</p><p>Figure <ref type="figure" target="#fig_3">6</ref> compares the prediction accuracy of the twolevel hybrid and the two-level ARVI predictors (using current value, load back, and perfect value information) for different pipeline depths. The figures at the right compare the IPC for the various two level predictor configurations.</p><p>The first observation is that ARVI achieves a considerable boost in prediction accuracy, even with the current value scheme. For the 20-stage pipeline, near-perfect accuracy is achieved with m88ksim compared to 95% for the conventional hybrid. The result is a 75% improvement in IPC. Non-trivial prediction accuracy improvements are also realized for compress (93% for ARVI versus 90.5% for the hybrid) and li (95.5% to 93%). Compress achieves roughly a 8% IPC gain with ARVI and li achieves 16% improvement. Overall, a 12.6% IPC improvement is achieved with current value for a 20-stage pipeline.</p><p>The result for m88ksim highlights the special capability of ARVI. The improvement is due to a single branch in the routine lookupdisasm. The code (shown in Figure <ref type="figure" target="#fig_4">7</ref>) takes a key and finds the corresponding opcode information. The opcode is found by hashing into an array and traversing the associated linked list. Manual inspection reveals that the contents of the hash table do not vary, so the number of iterations to traverse the linked list is fully defined by the value of the key. With the values of the register set that generate the value for key known when the branch is fetched, ARVI is able to make perfect predictions on when to exit the while loop. The while loop iteration count is embodied in the dependence chain depth tag. In contrast, the historybased hybrid predictor has difficulty in predicting the exit because the condition is not strongly correlated with history.</p><p>With the exception of ijpeg, the load back scheme only slightly increases predictor accuracy, as there are few opportunities for moving loads a sufficient distance to convert the branch to a calculate branch. The results for perfect value show the potential for ARVI when all load branches are essentially treated as calculate branches. Recall from Figure <ref type="figure" target="#fig_2">5</ref> that the prediction accuracy for ARVI is much higher for calculate branches than for load branches. The impact is most pronounced for go and ijpeg which have particularly poor load branch mispredict rates. The resulting 25.1% increase in IPC for the 20-stage pipeline shows the potential for ARVI if more aggressive on-line load back schemes can be implemented.</p><p>Increasing the pipeline depth increases the misspeculation penalty, which improves ARVI's relative performance. For a 60-stage pipeline, ARVI achieves a 7% IPC improvement for go, 16% for compress, 18% for li, and 80% for m88ksim. The overall IPC improvement of 15.6% demonstrates the potential for the use of data dependence information coupled with register values to reduce branch prediction penalties in future processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>In <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20]</ref>, limited data dependence information is used to reduce the wakeup time of the issue queue. In <ref type="bibr" target="#b14">[15]</ref>, for each instruction in the issue queue, a matrix tracks only the instructions immediately dependent upon it. In <ref type="bibr" target="#b19">[20]</ref>, a standard issue queue is backed by a large buffer where instructions waiting on a load miss are stored. In both designs, only dependence information to the next instruction in the chain is used. The design in <ref type="bibr" target="#b19">[20]</ref> does construct longer dependence chains, but it does so over multiple clock cycles by following one step in the chain each cycle.</p><p>In contrast, our design maintains the full data dependence chain cycle-by-cycle at register rename. This provides the dependence information earlier in the pipeline which is required for branch prediction. A subtle, but important difference is that our design constructs the data dependence chains for all instructions as they are renamed and does not require an associative search to detect dependences incrementally.</p><p>Predication to convert IF clauses into conditionally executed statements as supported by Intel's IA64 processor can result in false dependences between uses of a logical register along mutually exclusive paths. A hardware mechanism is proposed in <ref type="bibr" target="#b6">[7]</ref> to track data dependences between predicates and reveal predicates that are in fact disjoint and can be executed in parallel.</p><p>A predicated branch (a branch within a predicated clause) has an implied data dependency with the predicate register guarding the branch. If the value of the predicate register is resolved to false then all branches predicated upon that condition can be squashed (and trivially predicted as not taken). The Predicate Enhanced Prediction (PEP) architecture proposed in <ref type="bibr" target="#b26">[27]</ref> records the predicate register in order to perform a look up of its value as part of the branch prediction. For an instruction set that supports predication, the DDT would include the predicate register as an explicit data dependence.</p><p>Most current dynamic branch predictors use some combination of the branch address, path information <ref type="bibr" target="#b23">[24]</ref>, and the local/global history <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b35">36]</ref> of branch outcomes to make the prediction. Despite many attempts to improve predictor mechanisms and eliminate aliasing <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b30">31]</ref>, only small incremental improvements have been realized with these approaches. There is still a large number of dynamic branches that are mispredicted, e.g., for go. Current branch predictor designs appear to be reaching the limit relative to the type of input information provided <ref type="bibr" target="#b7">[8]</ref>.</p><p>Related approaches that include additional information into the branch prediction process involve correlating the actual branch register values with the branch outcome <ref type="bibr" target="#b13">[14]</ref> using a conventional value predictor. The authors of the study acknowledge that the accuracy of value prediction is low. ARVI attempts to predict values based on the current state along the data dependence chain. If the generating values are present then ARVI's predictions are near perfect. Heil <ref type="bibr" target="#b16">[17]</ref> proposed another approach that correlates on the differences between branch source operand values. We consider this approach an application using a limited amount of data dependence information. The DDT circuit provides ARVI with more complete data dependence information.</p><p>Branch decoupled architectures <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b32">33]</ref> execute branch-related instructions on a branch processor and feed the control flow result to the main processor. By executing the few instructions leading to branches on a seperate engine, outcomes can be computed before the main thread encounters the branch, thus, eliminating prediction of these branches all together. In <ref type="bibr" target="#b9">[10]</ref>, instruction tagging by the compiler was proposed to select the data dependence chains for branches. The dynamic design in <ref type="bibr" target="#b32">[33]</ref> separated the branch execution stream at run-time but a hardware design to discover the data dependence chain was not proposed. Our DDT design could be employed to select the set of instructions to run in the separate branch engine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>Much of the work in microarchitecture research has been to improve the effective ILP that the processor can exploit. Data dependence information infers the true ILP of a sequence of instructions. In this paper, we present a practical hardware design, the DDT, for maintaining precise data dependence information between the in-flight instructions. Practical access to accurate dependence data suggests many possible uses from instruction scheduling to instruction filtering.</p><p>We demonstrate one application of the DDT in the branch predictor ARVI. ARVI makes predictions based on values in registers in the dependence chain. This highly selective use of information leverages the key feature of data dependence information: only information directly related to the outcome of the branch is used in the prediction table.</p><p>The improved prediction accuracy results in IPC improvements of 12.6% in a 20-stage pipeline and 15.6% in a longer 60-stage pipeline. In future work, we plan to explore other uses of the data dependence tracking hardware and to refine its design.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. RSE operation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Generating values for ARVI</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Breakdown of calculate and load branches and prediction accuracy for each</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Prediction accuracy and IPC results</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. m88ksim value-based branch instance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 . Architectural parameters</head><label>2</label><figDesc></figDesc><table><row><cell>Fetch queue</cell><cell>4 entries</cell></row><row><cell>Fetch, decode width</cell><cell>4 instructions</cell></row><row><cell>ROB entries</cell><cell>256</cell></row><row><cell cols="2">Load/Store queue entries 32</cell></row><row><cell>Integer units</cell><cell>4 ALUs, 1 mult/div</cell></row><row><cell>Floating point units</cell><cell>4 ALUs, 1 mult/div</cell></row><row><cell>Instruction TLB</cell><cell>64 (16 P 4-way) 8K pages, 30 cycle miss</cell></row><row><cell>Data TLB</cell><cell>128 (32 P 4-way) 8K pages, 30 cycle miss</cell></row><row><cell>L1 I-cache</cell><cell>64 KB, 4-way, 32B line, Q SR UT WV XT WY 1`¢ cycles</cell></row><row><cell>L1 D-cache</cell><cell>64 KB, 4-way, 32B line, Q SR UT WV XT WY 1`¢ cycles</cell></row><row><cell>L2 unified</cell><cell>512 KB, 4-way, 64B line, Q 1a bR UT ¨a bc UT dR V $`¢ cycles</cell></row><row><cell cols="2">Memory latency ¢ latencies depend on pipeline length Q SY fe UT dc fe UT ¨a be fe 1`¢ cycles initial</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 . SPEC95 Integer Benchmarks</head><label>3</label><figDesc></figDesc><table><row><cell>Benchmark</cell><cell>Data set</cell><cell>Inst. Window</cell></row><row><cell>gcc</cell><cell>ref</cell><cell>200M-300M</cell></row><row><cell>compress</cell><cell>ref</cell><cell>3000M-3100M</cell></row><row><cell>go</cell><cell>ref</cell><cell>900M-1000M</cell></row><row><cell>ijpeg</cell><cell>ref</cell><cell>700M-800M</cell></row><row><cell>li</cell><cell>ref</cell><cell>400M-500M</cell></row><row><cell>m88ksim</cell><cell>ref</cell><cell>150M-250M</cell></row><row><cell>perl</cell><cell>ref</cell><cell>700M-800M</cell></row><row><cell>vortex</cell><cell>ref</cell><cell>2400M-2500M</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 . Predictor access latencies</head><label>4</label><figDesc></figDesc><table><row><cell>Predictor</cell><cell>Size</cell><cell cols="3">Access time (cycles)</cell></row><row><cell></cell><cell cols="2">(bytes) 20-cycle</cell><cell>40-cycle</cell><cell>60-cycle</cell></row><row><cell>Level-1 hybrid</cell><cell>4 KB</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell>Level-2 hybrid</cell><cell>32 KB</cell><cell>2</cell><cell>4</cell><cell>6</cell></row><row><cell>Level-2 ARVI</cell><cell>32 KB</cell><cell>6</cell><cell>12</cell><cell>18</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¢</head><p>This work was supported in part by NSF grants CCR-9701915 and CCR-9811929; by DARPA/IPTO under AFRL contract F29601-00-K-0182; by an IBM Faculty Partnership Award; and by an external research grant from Intel.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Clock Rate versus IPC: The End of the Road for Conventional Microarchitectures</title>
		<author>
			<persName><forename type="first">V</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hrishikesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2000-06">June 2000</date>
			<biblScope unit="page" from="248" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Power and Energy Reduction Via Pipeline Balancing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rawsthorne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Topham</surname></persName>
		</author>
		<title level="m">The Effectiveness of Decoupling. 7th International Conference of Supercomputing</title>
				<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="47" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The Simplescalar Toolset, Version 2.0</title>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<idno>TR-97-1342</idno>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Oldest-First Selection Logic Implementation for Non-Compacting Issue Queues</title>
		<author>
			<persName><forename type="first">A</forename><surname>Buyuktosunoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>El-Moursy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Albonesi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th International ASIC/SOC Conference</title>
				<imprint>
			<date type="published" when="2002-09">September 2002</date>
			<biblScope unit="page" from="31" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Selective Value Prediction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<biblScope unit="page" from="64" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Using Predicate Path Information in Hardware to Determine True Dependences</title>
		<author>
			<persName><forename type="first">L</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th Annual ACM International Conference on Supercomputing</title>
				<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="230" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Analysis of Branch Prediction via Data Compression</title>
		<author>
			<persName><forename type="first">I.-C</forename><forename type="middle">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Coffey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Mudge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<imprint>
			<date type="published" when="1996-10">October 1996</date>
			<biblScope unit="page" from="128" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The YAGS Branch Prediction Scheme</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Eden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mudge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1998-11">November 1998</date>
			<biblScope unit="page" from="69" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dataflow Analysis of Branch Mispredictions and Its Application to Early Resolution of Branch Outcomes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farcy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Temam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Espasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Juan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1998-11">November 1998</date>
			<biblScope unit="page" from="59" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Focusing Processor Policies via Critical-Path Prediction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Fields</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="74" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Energy-Efficient Issue Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Folegnani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="230" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Pentium 4 (partially) previewed</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Glaskowsky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-08">August 2000</date>
			<biblScope unit="page" from="10" to="13" />
		</imprint>
	</monogr>
	<note type="report_type">Microprocessor Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Potential of Data Value Speculation to Boost ILP</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Supercomputing</title>
				<imprint>
			<date type="published" when="1998-07">1998. July 1998</date>
			<biblScope unit="page" from="21" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A High-Speed Dynamic Instruction Scheduling Scheme for Superscalar Processors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Goshima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nishino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Nakashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kitamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tomita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IPSJ Transactions on High Performance Computing Systems</title>
		<imprint>
			<biblScope unit="page" from="225" to="236" />
			<date type="published" when="2001-12">December 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The Optimum Pipeline Depth for a Microprocessor</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hartstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Puzak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 29th Annual International Symposium on Computer Architecture</title>
				<meeting>29th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Improving Branch Predictors by Correlating on Data Values</title>
		<author>
			<persName><forename type="first">T</forename><surname>Heil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1999-11">November 1999</date>
			<biblScope unit="page" from="28" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jimenez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<title level="m">The Impact of Delay on the Design of Branch Predictors. 33rd Annual International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="67" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Alpha 21264 Microprocessor Architecture</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mclellan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Design</title>
				<imprint>
			<date type="published" when="1998-10">1998. October 1998</date>
			<biblScope unit="page" from="24" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast Instruction Window for Tolerating Cache Misses</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Koppanalil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Patwardhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rotenberg</surname></persName>
		</author>
		<author>
			<persName><surname>Large</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2002-05">May 2002</date>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-C</forename><forename type="middle">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Mudge</surname></persName>
		</author>
		<title level="m">The Bi-Mode Branch Predictor. 30th International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1995-12">December 1995</date>
			<biblScope unit="page" from="4" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Exceeding the Data-Flow Limit Via Value Prediction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1996-12">December 1996</date>
			<biblScope unit="page" from="226" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Trading Conflict and Capacity Aliasing in Conditional Branch Predictors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uhlig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1997-06">June 1997</date>
			<biblScope unit="page" from="292" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Dynamic Path-Based Branch Correlation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Nair</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1995-11">November 1995</date>
			<biblScope unit="page" from="15" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Sechrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mudge</surname></persName>
		</author>
		<title level="m">Correlation and Aliasing in Dynamic Branch Predictors. 23rd International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="1996-05">May 1996</date>
			<biblScope unit="page" from="22" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Design Tradeoffs for the Alpha EV8 Conditional Branch Predictor</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Felix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sazeides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2002-05">May 2002</date>
			<biblScope unit="page" from="295" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Incorporating Predicate Information into Branch Predictors. To appear in the 9th International Symposium on High Performance Computer Architecture</title>
		<author>
			<persName><forename type="first">B</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ferrante</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-02">February 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Increasing Processor Performance by Implementing Deeper Pipelines</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sprangle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carmean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 29th Annual International Symposium on Computer Architecture</title>
				<meeting>29th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Srinivasan</surname></persName>
		</author>
		<title level="m">Locality vs Criticality. 28th International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="132" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lebeck</surname></persName>
		</author>
		<title level="m">Load Latency Tolerance in Dynamically Scheduled Processors. 31st International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1998-11">November 1998</date>
			<biblScope unit="page" from="148" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Variable Length Path Branch Prediction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Stark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Evers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<imprint>
			<date type="published" when="1998-10">October 1998</date>
			<biblScope unit="page" from="170" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Eggers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Emer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Stamm</surname></persName>
		</author>
		<title level="m">Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading Processor. 23rd Annual International Symposium on Computer Architecure</title>
				<imprint>
			<date type="published" when="1996-05">May 1996</date>
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Dynamic Branch Decoupled Architecture</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tyagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-C</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mohapatra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Computer Design</title>
				<imprint>
			<date type="published" when="1999-10">1999. October 1999</date>
			<biblScope unit="page" from="442" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Limits of Instruction-Level Parallelism</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Wall</surname></persName>
		</author>
		<idno>93/6</idno>
		<imprint>
			<date type="published" when="1993-11">November 1993</date>
		</imprint>
		<respStmt>
			<orgName>Digital Western Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">The MIPS R10000 Superscalar Microprocessor</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Yeager</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-04">April 1996</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="28" to="40" />
			<pubPlace>Micro</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History. 20th International Symposium on Computer Architecture</title>
		<author>
			<persName><forename type="first">T.-Y</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Patt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
			<biblScope unit="page" from="257" to="266" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
