<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">VBI-Tree: A Peer-to-Peer Framework for Supporting Multi-Dimensional Indexing Schemes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country>USA *</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">NUS</orgName>
								<address>
									<country>Singapore †</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Beng</forename><forename type="middle">Chin</forename><surname>Ooi</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">NUS</orgName>
								<address>
									<country>Singapore †</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Quang</forename><forename type="middle">Hieu</forename><surname>Vu</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">NUS</orgName>
								<address>
									<country>Singapore †</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rong</forename><surname>Zhang</surname></persName>
							<email>rongzh@fudan.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="institution">Fudan University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Aoying</forename><surname>Zhou</surname></persName>
							<email>ayzhou@fudan.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="institution">Fudan University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">VBI-Tree: A Peer-to-Peer Framework for Supporting Multi-Dimensional Indexing Schemes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2A90CD42EA850F3C591444F6E9460A23</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Multi-dimensional data indexing has received much attention in a centralized database. However, not so much work has been done on this topic in the context of Peerto-Peer systems. In this paper, we propose a new Peer-to-Peer framework based on a balanced tree structure overlay, which can support extensible centralized mapping methods and query processing based on a variety of multidimensional tree structures, including R-Tree, X-Tree, SS-Tree, and M-Tree. Specifically, in a network with N nodes, our framework guarantees that point queries and range queries can be answered within O(logN ) hops. We also provide an effective load balancing strategy to allow nodes to balance their work load efficiently. An experimental assessment validates the practicality of our proposal.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Peer-to-Peer (P2P) systems have become popular for sharing resources, particularly files, across large numbers of users. Exact match queries based on identifiers are well supported in this context. However, shared data such as documents, music files, and images, are frequently specified as points in a multi-dimensional data space based on expressed features. As a result, it is important for P2P systems to provide efficient multi-dimensional query processing.</p><p>Index structures are central to efficient search in database systems. Multi-dimensional indexes such as the R-tree <ref type="bibr" target="#b7">[8]</ref> and R * -tree <ref type="bibr" target="#b1">[2]</ref>, and high-dimensional indexes such as the M-tree <ref type="bibr" target="#b6">[7]</ref> have been well tested and are widely accepted as robust indexes in centralized systems. Even for P2P systems, there have been a few proposals to support multidimensional indexing <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b18">19]</ref>. Most systems sup-porting multi-dimensional data indexing in centralized database are based on tree structures, which have many robust properties such as concurrency, scalability, and adaptivity. However, construction of such a structure is difficult in a P2P environment. As such all the P2P multi-dimensional indexing systems referenced above are based on space filling curve or space partitioning. They do not inherit the properties of well-tested multi-dimensional hierarchical indexing structures proposed in the literature.</p><p>In this paper, we propose a general framework, called the Virtual Binary Index (VBI) overlay network, based on a virtual binary balanced tree structure, which can be used to support any kind of hierarchical tree structures that has been designed based on a space containment relationship such as the R-tree and M-tree. There are two main components in the framework. The first component is the overlay network based on a balanced binary tree concept that is inspired by BATON <ref type="bibr" target="#b9">[10]</ref>. However, the binary tree is only virtual, in that peer nodes are not physically organized in a tree structure at all. The second component defines abstract methods for multi-dimensional indexing and is extensible to a variety of index structures.</p><p>Our paper makes the following contributions</p><p>• We present a framework that is capable of supporting a variety of well-tested multi-dimensional indexing methods such as the R-Tree <ref type="bibr" target="#b7">[8]</ref>, X-Tree <ref type="bibr" target="#b3">[4]</ref>, SS-Tree <ref type="bibr" target="#b19">[20]</ref>, and M-Tree <ref type="bibr" target="#b6">[7]</ref> in a P2P system.</p><p>• We present search algorithms for point queries and range queries, bounded in cost by O(logN ) hops, defined as the maximum path length of messages required to solve the problem.</p><p>• We present a comprehensive load balancing mechanism so that the framework is adaptive to data and load distributions.</p><p>The rest of the paper is organized as follows: In Section 2 we present related work. In Section 3 we provide background information about BATON. In Section 4, we introduce our framework and the overlay network. In Section 5, we explain our index construction and general algorithms for different indexing schemes. In Section 6 we discuss load balancing schemes used in our system. Finally, we show the performance study in Section 7 and conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Multi-dimensional indexing, including highdimensional indexing, has received extensive research attention in the context of centralized databases <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. In many of these methods, the data space is hierarchically divided into smaller subspaces (regions), such that the higher level data subspace contains the lower level subspaces and acts a guide in searching. Naturally, most such methods are tree-based. These methods can be data-partitioning based, where data subspaces are allowed to overlap (eg. Rtree) or space-partitioning based, where data subspaces are disjoint (eg. R + -tree <ref type="bibr" target="#b16">[17]</ref>). The specific partitioning technique (whether space-based or data-based) is not material to our algorithms in this paper, and hence we shall not distinguish between them.</p><p>Amongst P2P systems, CAN <ref type="bibr" target="#b13">[14]</ref> can be considered the first system supporting multi-dimensional data, although the original intention is to hash data uniformly into multidimensional space such that a certain degree of fault tolerance can be guaranteed. Being a structure that has some similarity with the kd-tree <ref type="bibr" target="#b2">[3]</ref> and grid-file <ref type="bibr" target="#b8">[9]</ref>, CAN can be used to directly index multi-dimensional data in its natural space. Most other systems such as <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b11">12]</ref> use space filling curves to map multi-dimensional data to one dimensional data. After that, an overlay network is used to index that one dimensional data. These works behave poorly when the data distribution is skewed. pSearch <ref type="bibr" target="#b18">[19]</ref>, a P2P system based on CAN, is proposed for document retrieval in P2P networks by rotating the dimensions in indexing. Its focus is on retrieving relevant documents rather than on range queries. Another system also based on CAN is proposed by Sahin et al <ref type="bibr" target="#b14">[15]</ref> in which the ranges are included into hash functions. As a result, the system can always return a superset of the range query. However, exact search is highly inefficient in this system. SkipIndex <ref type="bibr" target="#b20">[21]</ref> is based on skip graph <ref type="bibr" target="#b0">[1]</ref>, which aims to support high dimensional similarity query. It is based on k-d-tree <ref type="bibr" target="#b2">[3]</ref> to partition the data space, and then maps the data space into skip graph overlay network by encoding it into a unique key. However, it inherits the scaling problems of space filling curves with respect to dimensionality. Furthermore, it cannot guarantee that data is found within O(logN ) steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Background -BATON</head><p>In this section, we briefly describe the recently proposed overlay network based on the binary tree called BAlanced Tree Overlay Network (BATON) <ref type="bibr" target="#b9">[10]</ref>. An example BA-TON network is shown in Figure <ref type="figure" target="#fig_0">1</ref>, where each peer in the network maintains one node of the tree. Each node in the tree is associated with a level and a number. Nodes form the network by connecting with others via links. Each node in the tree maintains "links" to its parent, children, adjacent nodes, and selected neighbor nodes. Links to selected neighbors are maintained by two sideways routing tables: a left routing table and a right routing table. Each of these routing tables contains links to nodes at the same level with numbers that are less (respectively greater) than the number of the source node by a power of 2. The definition of a balanced tree in BATON is given below for clarity: Definition 1: A tree is balanced if and only if at any node in the tree, the height of its two subtrees differ by at most one.</p><p>2 Two important theorems are central to BATON. The first theorem is used to guarantee the balance of the tree while the second gives an efficient way to forward requests among nodes in the network.</p><p>Theorem 1: A tree is a balanced tree if every node in the tree that has a child also has both its left and right routing tables full. <ref type="foot" target="#foot_0">1</ref>2 Theorem 2: If a node x contains a link to another node y in its left or right routing tables, the parent node of x must also contain a link to the parent node of y unless the same node is parent of both x and y.</p><p>2 We note that the overlay network proposed in this paper is a balanced binary tree, but is not the same as BA-TON, in two crucial ways. Firstly, index nodes are mapped differently into peer nodes from BATON in which each index node corresponds to a peer. Secondly, the definition of sideways routing is new since linear ordering between value ranges at nodes can no longer be assumed as in BATON. As a result, algorithms for all operations described differ from those in BATON; and in particular the crucial search algorithm is completely different. Nonetheless, the two central theorems of BATON apply to the VBI-Tree we introduce below, since they share a similar binary tree structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">VBI-Tree Architecture</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">The Overall Framework</head><p>The Virtual Binary Index Tree (VBI-Tree) is an abstract tree structure on top of an overlay network as shown in Figure <ref type="figure" target="#fig_1">2</ref>. The abstract methods defined can support any kind of hierarchical tree indexing structures in which the region managed by a node covers all regions managed by its children. Popular multi-dimensional hierarchical indexing structures include the R-tree <ref type="bibr" target="#b7">[8]</ref>, the X-tree <ref type="bibr" target="#b3">[4]</ref>, the SStree <ref type="bibr" target="#b19">[20]</ref>, the M-tree <ref type="bibr" target="#b6">[7]</ref>, and their variants. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Overlay Network</head><p>As is the case for many centralized indexing methods, VBI-Tree nodes can be partitioned into two classes: data nodes (or leaf nodes) and routing nodes (or internal nodes). Data nodes actually store data while routing nodes only keep routing information. Like BATON, each routing node in the VBI-Tree maintains links to its parent, its children, its adjacent nodes and its sideways routing tables. However entries in the routing tables do not need to keep information about regions covered by neighbor nodes. Instead, each routing node maintains an "upside table", with information about regions covered by each of its ancestors. Additionally, each node needs to keep information about heights of sub-trees rooted at its children. (This is used for the network restructuring process (see 6.1)). VBI-Tree construction employs a parsimony principle which requires that every internal node have two children. The parsimony principle forces the total number of nodes in a VBI-tree to be an odd number, and exactly half of these rounded up, to be data nodes. In fact, we can establish the following theorem: 2 Theorem 3 follows from the definition of a balanced binary tree -since any node that has a child must have full sideways routing tables, at the very least it has a sibling.</p><p>Each peer in the network is assigned a pair of VBI-Tree nodes: a routing node and a data node, in which the data node is the left adjacent node of the routing node (in the inorder traversal of the tree). The sole exception is the peer keeping the right most data node, which does not have a routing node. Since each peer keeps a routing node and a data node, and query requests can be forwarded via links in the routing node, to save space, data nodes do not need to keep sideways routing tables as well as upside path. The special peer keeping the rightmost data node, which does not have a routing node, always forwards requests to the parent node of the data node for processing. The VBI-Tree structure is shown in Figure <ref type="figure" target="#fig_2">3</ref>. Note that in the figure, nodes with the same name are stored at the same peer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Node Join</head><p>A node<ref type="foot" target="#foot_1">2</ref> wanting to join the network must know at least one node inside the network and sends a JOIN request to that node. There are two phases in a new node joining the network. The first phase is to determine where the new node should join. This is done exactly as in BATON except that only routing nodes are used and considered during join process. The cost of this step is O(logN ), which is the height of the tree. Details are in Algorithm 1.</p><p>After determining a position for the new node, the second phase starts. At first, the data node at the position of the Forward the JOIN request to m Else Forward the JOIN request to one of its adjacent nodes new routing node splits its covered region into two sub regions using node splitting algorithm. After that, a new routing node is created to replace the data node; two new data nodes are created and linked as children of the new routing node; sub regions and data covered by these regions are assigned to two new data nodes. Finally, the new routing node and its left child are given to the new node. The other data node is given to the correspondence right adjacent routing node. In case the new node is the first child of its parent, the parent node increases its height by one and notifies its parent. That parent in turn checks to see if its own height is increased in consequence, and if yes, notifies its own parent, and so on recursively. For example, assume that node u wants to join the network and it sends a JOIN request to node b as in Figure <ref type="figure" target="#fig_4">4</ref>. b has its routing tables full and its child slots full, and all its peers in its routing tables (only c in this case) also have both child slots full. Therefore b forwards the request to an adjacent node p. (Note that routing and data nodes alternate, so the adjacent node is really the data node p , which is located at the same peer node as the adjacent routing node p). At p, because its routing tables aren't full, it forwards the request to its parent j, which then forwards the request to n. At n, its routing tables are full but its doesn't have any routing node children. (Data nodes are not considered in this algorithm). So it accepts the new node, as its left child. A new routing node u is created and the data currently covered by its corresponding data node n is split into two sub-regions, one is assigned to u while the other remains assigned to n .</p><p>The cost of updating routing tables to reflect the existence of the new node is 6logN of which 2logN is for updating routing tables of the parent node's neighbors, 2logN for updating routing tables of the new node's neighbors and 2logN for setting routing tables for the new node. For up- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Node Departure</head><p>Similar to node join, only routing nodes are used and considered for node departure. If a leaf routing node, which is a routing node without any routing child (or a peer containing a routing leaf node), wishes to leave the network, and there is no routing node in its routing tables having routing children, it can leave the network without affecting the tree balance. In this case, the data node stored at the departing peer will be merged with its data node sibling. The result data node will replace the position of the routing node. For example, assume that a peer containing routing node r wishes to leave the network as in Figure <ref type="figure">5</ref>. It's clear that node r can leave without affecting the tree balance (note that only routing nodes are considered here). Thus, the corresponding data node r is merged with its data node sibling f , which later is pulled to replace the position of r. The cost of this process is 4logN in which 2logN is for updating routing tables of departure routing node's neighbors and 2logN for updating routing tables of neighbors of the departure routing node's parent. In addition, as in the case of a node join, a maximum additional logN cost may be incurred for updating height of sub-trees if there are any changes due to the node departure.</p><p>If a routing node wishing to leave is an internal routing node or a leaf routing node whose neighbor nodes have routing node children, it needs to find a replacement that is a routing leaf node. Algorithm 2 shows how the process of finding replacement node incurs O(logN ) cost. The cost of updating routing tables to reflect changes is 8logN of which 4logN is for updating routing tables of neighbors of the replacement node and its parent, and 4logN for updating routing tables of neighbors of the departure node and its parent. Note that upside paths don't need to be updated in this case since upside paths only keep covered regions of ancestors, not physical references to them. Failure recovery in VBI-Tree is identical to that in BA-TON. When a node is found to be unreachable, a report is sent to its parent, which is in charge of the recovery process. The parent of the failed node finds a replacement node if necessary and can re-establish links through redundant information at the nodes in its routing tables, and their children. Operations executed during the recovery process may by-pass failed nodes via either the sideways axis by links in routing tables or the up-down axis by parent-child and adjacent links.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Index Construction</head><p>Given the overlay network described in the preceding section, we describe here how to use it to construct a generic (multi-dimensional) index. The basic idea is to assign a region of the attribute space to each data node. Each internal node has associated a region that covers all regions managed by its children. Many known index structures follow this sort of region assignment -the difference is in the specifics of how these regions are chosen and split -we allow the same set of choices with regard to the specifics. In this manner, we can create a VBI-R-Tree, a VBI-M-Tree, a VBI-SS-Tree, etc. Initially, the root is the only data node and it covers the entire domain. When new nodes join, the Addition (or deletion) of data items is performed as in the corresponding centralized indexing scheme. However, there is one issue: when a newly inserted data item at a node has a value that doesn't fall into any region covered by a node's children, one of the node's children should be selected to enlarge its covered region. In a distributed system, such an enlargement can be expensive, involving an update to all upside paths of that node's descendants. To avoid this problem, we propose the use of discrete data. Discrete data is defined as data that does not fall into any regions covered by the node's children and hence can be stored at a non-leaf node <ref type="foot" target="#foot_2">3</ref> . A routing node can keep discrete data, and only if the number of discrete data items kept at a routing node exceeds some threshold is a batch enlargement performed of the children's regions. Additionally, we also perform lazy updating. When the region covered by a node is enlarged, update messages aren't sent immediately if the network is busy: rather they are sent to descendant nodes later when the network is free. This laziness does not save in the total number of messages, but simply permits quicker response to a data insertion that causes discrete data to go beyond threshold, and avoids stressing the network at times of load.</p><p>The general index scheme is illustrated in Figure <ref type="figure" target="#fig_6">6</ref>. In this figure, we show the way to map an R-Tree and an M-Tree in two dimensional space into our framework. We have chosen the data such in the two cases that the resulting VBI-Tree is the same for both schemes. There are two discrete data objects in the figure: one is stored at the routing node a, the other is stored at routing node c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">General Point Query Process</head><p>For simplicity, we first consider the case where sibling nodes do not have overlapping regions, to develop Algorithm 3. For a point query issued or received at node n, if the region associated with n covers the point query, then the search point will be in the tree rooted at n, and hence the request is either processed at n itself or forwarded to one of its children. If the region associated with n does not cover the point query, then n needs to find the nearest ancestor x covering the point query first by consulting its upside table. After that, it forwards the request to a neighbor node y, found in n's sideways routing table, situated at the other side of the tree rooted at x. Now y uses exactly the same algorithm as n, and continues the search. In order to avoid receiving back the search message from y when searched data is discrete data stored at the common ancestor x of nodes n and y, we use the nearest-checked-ancestor parameter, which indicates the parent of the root of the tree to which the search is to be limited. Initially, this parameter is set to null. We illustrate the search process using Figure <ref type="figure" target="#fig_7">7</ref>. Suppose node h wants to search a point stored under region covered by node g in an R-Tree index scheme for two dimensional data. Since the search point isn't covered by h's region, h checks its upside path and discovers that the only region that covers the search point corresponds to node a. As a result, h forwards the point query to j, which is its neighbor node on the other side of the subtree rooted at a. Now j checks its upside path and realizes that the nearest ancestor node whose region covers the search point is c. However, it cannot find a neighbor routing node on the other side of the tree rooted at c. Thus, it forwards the query to its parent f . Finally, f forwards the query to g, which is the destination routing node, and g forwards the request to the data node l .</p><p>With the above algorithm, when a node n wants to search for a point, if the search point is covered by the region of n the cost of search process is h ≤ logN , where h is the height of the subtree rooted at n. If the search point is neither covered by the region of n nor by the region of the root, by checking the upside path and the routing tables, it takes only one step to forward the request sideways to a node under control of a subtree whose height is less than the height of the current search tree by at least one (limited by the nearest-checked-ancestor parameter). In the last case, if the search point is covered by the region of the root, it takes one step to forward the request to an n's neighbor node. After that, the request is forwarded upward to the root, which take logN steps. As a result, the total cost of search process is O(logN ). Note that the process of forwarding the search request from a node to its ancestor can be reduced by taking adjacent links among nodes instead of using only childparent links.</p><p>A worry with a tree-structured overlay network is that the small number of nodes near the root will have to do disproportionately more work. However, such a case doesn't happen in our algorithm since search requests are forwarded up only if the recipient node itself has discrete data relevant to the query, and so has to be consulted; or the current node has no correspondence neighbor node to forward the request so that what would have been a sideways forwarding has to be kicked up a level. In the latter case, the node has to be a leaf node, which far enough away from the root.</p><p>So far, we have discussed the point query search algorithm without overlapping regions. However, most multi-dimensional indexing schemes allow regions associated with index nodes to overlap. Due to this, queries may be forwarded to multiple nodes instead of only one node. We use the same mechanism in our framework. Because the point query search can be considered as a special case of range query search in which the range query radius is 0, we skip a walkthrough of this algorithm, and move on to range queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">General Range Query Process</head><p>This section gives a general algorithm for range query processing. The search range algorithm is described in Algorithm 4. Obviously, one now seeks nodes with regions that intersect the query region rather than contain the query point. Since many nodes may intersect with a given query region, the request may be forwarded to multiple nodes. For example, assume that in an R-Tree index scheme for two dimensional data, node h wants to search a region as in Figure <ref type="figure" target="#fig_9">8</ref>. At first, h executes the query locally as its covered region intersects with the searched region. After that, it tries to forward the query to other nodes. Since d is a child of h and its region intersects with the searched region, d is forwarded the query. Because all of h's ancestors intersect with the searched region, h forwards the query to i, j, which are neighbor nodes located on the other side of the subtree rooted at d and a. h also forwards the request to its parent d because it can not find a neighbor node located on the other side of the subtree rooted at b. Thereafter, the request is forwarded to e from d, to g from j through f . Finally, at destination nodes i, e, and j, the query is forwarded to both data nodes b , r and l , and routing nodes b, c for discrete data.</p><formula xml:id="formula_0">Algorithm 4 RangeQuery(node n, search-region r, nearest- checked-ancestor a) If (Region(n) ∩ r != ø) LocalSearch(n, r) If ((Region(LeftChild(n)) ∩ r != ø) and (The search request is not sent from LeftChild(n)) RangeQuery(LeftChild(n), r, LeftChild(n)) If ((Region(RightChild(n)) ∩ r != ø)</formula><p>and (The search request is not sent from RightChild(n)) RangeQuery(RightChild(n), r, RightChild(n)) Consider a node x that issues a range query r and for each node y whose region intersects with r. If y is a descendant of x, the search request is always forwarded downward to reach y. If y is an ancestor of x, at first the request is for- warded to a neighbor node z of x, which is on the other side of the tree rooted at y. After that, z checks and realizes that no children of y covers the whole r. Thus, z forwards the request to y via child-parent links. In the last case, if y is neither descendant nor ancestor of x, y must fall into a subtree rooted at z, which is an ancestor of x and z's region must intersect with r. As a result, the request is forwarded to a neighbor node t, which is on the other side of the tree rooted at z. This process continues until y is either ancestor or descendant of the node receiving the searched request. In consequence, the algorithm is guaranteed to forward the query request to all nodes intersecting with the searched region. Even though this algorithm is a little different from the point query search algorithm without overlapped regions because at each step a search request may be forwarded to multiple nodes, the cost of the search algorithm is still kept at O(logN ) hops since these requests are forwarded in parallel.</p><formula xml:id="formula_1">For i = 0 to Level(n) -Level(a) -1 x = UpsidePath(n).get(i) If (Region(x) ∩ r != ø) If (x ==</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Load Balancing</head><p>There are two load balancing schemes in VBI-Tree. The first scheme is simple, the overloaded node tries to do load balancing with its children if it is an internal routing node, or with its sibling if it is a data node. Since this scheme is not sufficient to deal with a very skewed data set, we propose the second scheme. In the second scheme, an internal routing node always does load balancing only with its children. However, if it is a leaf data node, it tries to do load balancing with its sibling first. If its sibling is also overloaded, then it finds a lightly loaded data node via neighbor links as in BATON. The lightly loaded node leaves its current position and rejoins as a child of the overloaded node to share the work load. This scheme can quickly redress global imbalances in load, but it can cause the binary tree to become unbalanced in depth: network restructuring is thereafter used to rebalance the tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Network Restructuring</head><p>When a node receives a message from its child to update its height, by comparison with the height of the other child, a node can know if its subtree is still balanced. If the system becomes unbalanced, network restructuring is started, by the node that detects this, using rotation operators as in the AVL tree <ref type="bibr" target="#b10">[11]</ref>. There are four ways to rebalance the tree as shown in Figure <ref type="figure">9</ref>.</p><p>In the LL Rotation and RR Rotation, two nodes are required to recalculate their covered regions. As in Figure <ref type="figure">9a</ref> and 9c, a needs to recalculate the minimum region covering </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Experimental Study</head><p>We built a peer-to-peer simulator to evaluate the performance of our proposed system over large-scale networks. For each experiment in a multi-dimensional space, 100000 data objects are inserted into a network of 10000 nodes. Against this system, 1000 point queries, 1000 range queries, and 1000 kNN queries are executed. Using the VBI framework, we implemented the M-tree <ref type="bibr" target="#b6">[7]</ref>. A well known P2P system supporting multi-dimensional data -CAN <ref type="bibr" target="#b13">[14]</ref> -is used for comparison. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Performance of Point Queries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Performance of Range Queries</head><p>Figure <ref type="figure" target="#fig_13">10(c)</ref> shows the average number of hops required to find the result for range queries in different dimensions with different radius sizes. As in the case of point query processing, the result in VBI-Tree is only affected by the size of the network. It is not affected by change of dimension or radius size. In contrast, CAN requires more hops for processing when the size of range queries is bigger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Performance of kNN Queries</head><p>In this experiment, we implemented a simple kNN query algorithm. In this algorithm all points that fall within a predefined radius are returned. If the total number of returned points is still less than the number specified, the search distance is increased incrementally until enough points are returned. We set the initial radius small enough so that too many points are never returned at first. The result are shown in Figure <ref type="figure" target="#fig_13">10(d)</ref> shows that both CAN and VBI-tree increase average number of hops slightly when the number of requested nearest neighbor nodes is increased from 10 to 20. Other characteristics are similar to previous experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.">Cost of updating upside path versus Cost of search</head><p>Discrete data are an innovation in VBI Tree, and were introduced to reduce the cost of updating upside path tables. However, discrete data increases the cost of search queries. In this experiment, we vary the limit on the size of discrete data allowed at each internal (routing) node. Figures <ref type="figure" target="#fig_13">10(e</ref>) and 10(f) show that when we increase this value, the average number of messages required for updating upside paths decreases but the number for search increases. Depending on the system, we should adjust the size of discrete data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5.">Effect of load balancing</head><p>Figure 10(g) shows the average additional number of messages required to do load balancing and network restructuring in case of skewed data distribution compared to uniform data distribution. The result shows that the additional cost required for doing load balancing and network restructuring is not much, around 1 message for every 1000 insertion/deletions. This cost is so low because most of the time, network restructuring only involves a small number of nodes as shown in Figure <ref type="figure" target="#fig_12">10</ref>(h).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.6.">Workload distribution</head><p>To evaluate the workload in case of skewed data distribution, we tested the network with two sets of data: one uni-form and the other skewed. The skewed data set is generated using a Zipfian distribution with parameter 1.0. Figure <ref type="figure" target="#fig_13">10(i)</ref> shows that the distribution of data stored at nodes is not very sensitive to data skew in the case of VBI-Tree whereas CAN is highly sensitive to such skew. With the Zipfian data set in CAN, approximately 80% of data is stored at only 10% of nodes. (Note that all preceding experiments were run with uniform data sets and so represent a best case for CAN. Our relative performance would be even better if we used real data with skew). This experiment explains why the original CAN uses DHTs for data distribution, which makes it only suitable for point queries .  bered levels are leaves. In case of insert operation, the result shows that higher level (closer to leaf) nodes always have higher work load. This is due to updates to the upside tables: nodes closer to the leaf have more entries in these tables and so are more likely to have to update these. In the case of search, the load is more evenly distributed, with slightly higher load at levels just above the leaves. In no case is there a bottleneck at nodes close to the root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.7.">Access load</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>We have described VBI-Tree, a framework based on a binary balanced tree structure, which can support both point queries and range queries over high dimensional space efficiently. This framework can be used to implement a variety of hierarchical region-based index structures, including M-tree, R-tree, R*-tree, X-tree, etc., in a peer-to-peer system. Experimental evidence supports the effectiveness of this framework. Our contributions include:</p><p>• A virtual binary overlay network that is a significant modification of BATON.</p><p>• Introduction of discrete data as a mean to minimize update costs and novel P2P search algorithms that account properly for such discrete data.</p><p>• An AVL-tree like rotation scheme for rebalancing the virtual binary tree when needed, leading to effective load balance even with highly skewed data.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. BATON structure</figDesc><graphic coords="2,349.03,79.56,167.70,141.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Overall framework</figDesc><graphic coords="3,108.41,301.94,131.40,92.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. VBI-Tree structure</figDesc><graphic coords="3,346.55,79.62,172.60,155.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 1</head><label>1</label><figDesc>Join(node n) If (Full(LeftRoutingTable(n)) and Full(RightRoutingTable(n)) and ((LeftChild(n)==null) or (RightChild(n)==null)) Accept new node as child of n Else If ((Not Full(LeftRoutingTable(n))) or (Not Full(RightRoutingTable(n)))) Forward the JOIN request to parent(n) Else m=SomeNodesNotHavingEnoughChildrenIn (LeftRoutingTable(n), RightRoutingTable(n)) If (there exists such an m)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. A new node joins the network</figDesc><graphic coords="4,348.29,79.55,169.20,84.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 2</head><label>2</label><figDesc>FindReplacementNode(node n) If (LeftChild(n)!=null) Forward the request to LeftChild(n) Else If (RightChild(n)!=null) Forward the request to RightChild(n) Else m=SomeNodesHavingChildrenIn (LeftRoutingTable(n), RightRoutingTable(n)) If (there exists such an m) Forward the request to a child of m Else Come to replace the leave node 4.5. Node Failure and Fault Tolerance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Two dimensional index structure</figDesc><graphic coords="5,343.29,79.56,179.20,86.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Point query search</figDesc><graphic coords="6,344.09,79.55,177.60,79.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>a) If (No Region(Children(x) covers the whole r) LocalSearch(x, r) Else y = get a neighbor node in other side of the tree rooted at x If (y!=null) RangeQuery(y, r, x) Else RangeQuery(Parent(n), r, x)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Range query search</figDesc><graphic coords="7,344.09,79.55,177.60,79.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 9. Network Restructuring</figDesc><graphic coords="8,177.58,154.89,108.70,55.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>T 2 and T 3 first. After that, b recalculates the minimum region covering T 1 and a. No data movement is required except for discrete data locally stored at a and b. Similarly, in the LR Rotation and RL Rotation, shown in figure 9b and 9d, first b and a recalculate the minimum region covering T 1 and T 2, T 3 and T 4. Then, c recalculates the minimum region covering b and a. Finally, discrete data stored at a, b, and c is appropriately reallocated. After getting new covered regions, these regions need to be updated in the upside tables at descendant nodes. As in the case of enlarging covered regions due to data insertion, lazy updating can be used. For a network restructuring involving n nodes, n messages are required to do updating. Additionally, each node also needs to notify their new neighbor nodes about changes which takes O(logN ) cost. As a result, a network restructuring involving n nodes requires O(n × logN + n) effort. The more the nodes participating in the restructuring process, the more the cost of restructuring. However, the probability of the rotation process involving n nodes exponentially decreases with n. The amortized cost of an update can be shown to be just O(logN ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 (</head><label>10</label><figDesc>Figure 10(a) shows the average and maximum number of hops required to find the result for point queries in different dimensions. The result shows that the VBI-Tree performs independent of dimensionality. CAN achieves good performance only for a large number of dimensions. This may appear counter-intuitive at first, but it is due to the number of neighbors for each node in CAN going up with the number of dimensions, along with an increase in the size of routing tables. Figure 10(b) shows the increase in average number of search hops with increasing network size. CAN is executed in 5, 10, and 20 dimensional space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Cost of point query search (a, b), range query search (c), kNN query search (d); The effect of varying the number of maximum discrete data (e, f); The effect of load balancing (g, h)</figDesc><graphic coords="9,73.28,306.80,148.80,89.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 11</head><label>11</label><figDesc>Figure 11  shows access load of nodes at different levels, measured in terms of the average number of messages received at a node in each level. Level 0 is the root, high num-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Access load for nodes at levels</figDesc><graphic coords="10,99.89,79.56,148.50,90.30" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A routing table is full if none of its valid links is NULL</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Due to the fact that each peer node is associated with only one routing node and vice versa, we shall simply refer to "routing node" and "peer node" as "node" when such reference does not cause any confusion. We stick to the term "data node" as is.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This is usually not a good idea in a centralized database since internal nodes are usually kept in the memory so that size is a constraint, and high fan-out a more important imperative. But these desiderata do not apply in P2P systems</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported in part by NSF grant EIA-0303587 † Supported in part by IDA CCC grant as part of BestPeer <ref type="bibr" target="#b12">[13]</ref> project</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Skip graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of The 14th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>eeding of The 14th Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="384" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The R*-tree: An efficient and robust access method for points and rectangles</title>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD</title>
		<meeting>the ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="509" to="517" />
			<date type="published" when="1975-09">Sep 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The X-tree: An index structure for high-dimensional data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Berchtold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd VLDB Conference</title>
		<meeting>the 22nd VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Indexing Techniques for Advanced Database Applications</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sacks-Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shidlovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cantania</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Kluwer Academics</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Searching in high-dimensional spaces: Index structures for improving the performance of multimedia databases</title>
		<author>
			<persName><forename type="first">C</forename><surname>Böhm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Berchtold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Keim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-09">Sep 2001</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="322" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">M-tree: An efficient access method for similarity search in metric spaces</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ciaccia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Patella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zezula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd VLDB Conference</title>
		<meeting>the 23rd VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="426" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">R-trees: A dynamic index structure for spatial searching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guttman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD</title>
		<meeting>the ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The grid file: A data structure designed to support proximity queries on spatial objects</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hinrichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nievergelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Graphtheoretic Concepts in Computer Science</title>
		<meeting>the International Workshop on Graphtheoretic Concepts in Computer Science</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">BATON: A balanced tree structure for peer-to-peer networks</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">H</forename><surname>Vu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st VLDB Conference</title>
		<meeting>the 31st VLDB Conference</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley Professional</publisher>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">CISS: An efficient object clustering framework for DHT-based peer-topeer applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Choe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DBISP2P</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="215" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Bestpeer: A selfconfigurable peer-to-peer system</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-L</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ICDE Conference</title>
		<meeting>the 18th ICDE Conference</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A scalable content-addressable network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 ACM Annual Conference of the Special Interest Group on Data Communication</title>
		<meeting>the 2001 ACM Annual Conference of the Special Interest Group on Data Communication</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="161" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A peer-to-peer framework for caching range queries</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">D</forename><surname>Sahin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ICDE Conference</title>
		<meeting>the 20th ICDE Conference</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Flexible information discovery in decentralized distributed systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parashar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HPDC-12</title>
		<meeting>HPDC-12</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The R+-tree: A dynamic index for multi-dimensional objects</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th VLDB Conference</title>
		<meeting>the 13th VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="507" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Adapting the content native space for load balanced</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DBISP2P</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="122" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Peer-to-peer information retrieval using self-organizing semantic overlay networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dwarkadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. of the ACM SIGCOMM</title>
		<meeting>of the ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Similarity indexing with the SStree</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ICDE Conference</title>
		<meeting>the 12th ICDE Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="516" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Skipindex: Towards a scalable peer-to-peer index service for high dimensional data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Y</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
