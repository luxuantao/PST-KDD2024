<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A unifying semantics for time and events</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Brandon</forename><surname>Bennett</surname></persName>
							<email>brandon@comp.leeds.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">University of Leeds</orgName>
								<address>
									<postCode>LS2 9JT</postCode>
									<settlement>Leeds</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Antony</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
							<email>a.p.galton@exeter.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Exeter</orgName>
								<address>
									<postCode>EX4 4QF</postCode>
									<settlement>Exeter</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A unifying semantics for time and events</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C88A803668D886370C2A5296412237E4</idno>
					<idno type="DOI">10.1016/j.artint.2003.02.001</idno>
					<note type="submission">Received 14 December 2001</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Temporal logic; Semantics</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We give a formal semantics for a highly expressive language for representing temporal relationships and events. This language, which we call Versatile Event Logic (VEL), provides a general temporal ontology and semantics encompassing many other representations. The system incorporates a number of features that have not been widely employed in AI formalisms. It has the ability to describe alternative histories using a modal operator. It provides a semantics for individuals that explicitly models their identity through time and across alternative possible histories; and enables one to distinguish between necessary and extensional identity of individuals. In virtue of its treatment of individuals and count nouns, the formalism offers a solution to certain puzzles of identity, which arise when individuals are described in different ways. We propose that VEL can be used as a foundational interlingua for comparing and interfacing different AI languages and illustrate this by considering how Situation Calculus and Event Calculus can be represented within VEL.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Many researchers in the field of AI have recognised the need for formal representation languages capable of expressing high-level information in a naturalistic form-e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b28">29]</ref>. Of central importance to such a representation is a precise analysis of the semantics of actions, events and temporal relations. Among the most influential of the large number of formalisms proposed to deal with these are: the Situation Calculus <ref type="bibr" target="#b34">[35]</ref>, Allen's theory of action and time <ref type="bibr" target="#b1">[2]</ref> and the Event Calculus <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b44">45]</ref>. Philosophers have also examined various logical aspects of events and we aim to take into account in particular the analyses given by Davidson <ref type="bibr" target="#b8">[9]</ref> and Galton <ref type="bibr" target="#b15">[16]</ref>. We present a unifying language that we call Versatile Event Logic (VEL), embodying a range of insights into the logic of time and events.</p><p>Representations of time within formal languages can be readily divided into three main approaches:</p><p>• Explicit reference to time points and a temporal ordering relation.</p><p>• Explicit reference to temporal intervals and the temporal relationships between them (which implicitly constrain the ordering of the end-points of the intervals). • Use of propositional tenses to convey temporal relationships among facts (without explicit reference to any temporal entities).</p><p>Whereas most temporal logics incorporate only one of these ways of referring to temporal structure, in our formalism all three of them happily coexist. A single VEL formula can contain time-point and interval variables as well as tenses (though it turns out, unsurprisingly, that all of these constructs are in fact reducible to logically equivalent expressions involving just time points and the temporal ordering relation).</p><p>Our formalism incorporates each of the following analyses:</p><p>Events as transitions. A view of events that can be found in some of the earliest AI systems is that an event is a transition between states. This idea is the basis of STRIPS <ref type="bibr" target="#b14">[15]</ref> and also the Situation Calculus <ref type="bibr" target="#b34">[35]</ref>. The transition account of events can be handled very nicely within the general framework of modal logics, where a class of state transitions can be regarded as an accessibility relation. This idea has been used to provide the semantics for dynamic logic <ref type="bibr" target="#b25">[26]</ref>.</p><p>Events as occurrences over intervals. An approach widely adopted in AI is to correlate events with the time intervals over which they occur <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20]</ref>. This is done by means of a quasi-logical predicate Occurs(e, δ), which says that an event of type e occurs during the interval δ. Temporal relationships between events can then be described in terms of relations between the intervals over which they occur; and in particular by the 13 interval relations of Allen <ref type="bibr" target="#b0">[1]</ref>.</p><p>Davidson's existential analysis. <ref type="bibr">Davidson [9]</ref> gave an analysis of events according to which every action verb is associated with an implicit existentially quantified event-token variable. For example the sentence 'John saw Mary in London on Tuesday' would have the logical form ∃ε[Saw(ε, j, m) ∧ In(ε, l) ∧ On(ε, t)].</p><p>This explains how a large number of modifying phrases may be attached to verbs and also accounts for a wide range of inferences concerning verbs and their modifiers. For instance, from the above example we can infer ∃ε[Saw(ε, j, m)] by straightforward firstorder reasoning.</p><p>Although Davidson's work is not very well known to AI researchers, the logical analysis it provides is very close to that employed by a wide variety of AI representations based on reified events. In particular, semantic networks <ref type="bibr" target="#b32">[33]</ref> typically treat an event as a special kind of entity. Other entities are linked to the event by arcs describing their relationship to the event. The main difference between this approach and Davidson's analysis is that the fundamental rôles of agent and patient (and perhaps also indirect object) are separated out from the verb rather than treated as integral. Thus, many AI representations would exhibit a logical form such as</p><formula xml:id="formula_0">∃ε[Saw(ε) ∧ Agent(ε, j) ∧ Patient(ε, m) ∧ In(ε, l) ∧ On(ε, t)].</formula><p>The difference between this and Davidson's formulation does not seem to have any concrete semantic significance and in developing our semantics we have found it more intuitive to treat verbs as relation-like with a small fixed arity, as does Davidson. However, as will be explained below, we do not treat the event variable as a hidden argument of the verb but as bound to the verb by means of a kind of quantifier.</p><p>The ability to refer directly to individual event instances is undoubtedly useful for representing certain kinds of knowledge. For instance, it enables one to represent adverbs as predicates of events and allows the possibility of describing causality in terms of a binary relation between events.</p><p>Event radicals. Galton <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref> analyses events in terms of event radicals, syntactic units which refer to event-types and combine with temporal aspect operators to form propositions. For example, if the event-type John-tie-his-shoelace were operated on by the progressive aspect, we would obtain the proposition Prog(John-tie-his-shoelace), meaning that an event of type 'John-tie-his-shoelace' is in progress. We would read this as 'John is tying his shoelace'.</p><p>We want to encompass the essential insights of all these different approaches within a single semantic framework. Our paper may be regarded as an attempt to produce a detailed ontology (as advocated by, e.g., Guarino <ref type="bibr" target="#b22">[23]</ref>) of time and events accounting for their various linguistic manifestations. Whereas much recent work on ontology for AI systems has been carried out at the level of axioms (e.g., <ref type="bibr" target="#b33">[34]</ref>), ours is founded at the semantic level. We give a rich intensional semantics, in terms of which all our temporal operators are interpreted. This analysis is in some respects similar to Montague Semantics <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref>, although we are concerned only with the various logical forms of temporal expression, not with their syntactic realisation in a natural language. We do give axioms governing the behaviour of our operators; but formulating a complete proof system is a subject for further research.</p><p>It must be emphasised that the VEL formalism is not intended to contribute directly to solving the problem of how to reason about actions and change. This problem involves many factors that are completely beyond the scope of this work. In particular we do not address the much studied frame problem or any of its sub-problems, which have been studied in considerable detail within the AI literature (see, e.g., <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b43">44]</ref>). VEL gives us a very general language for talking about time and events but is completely agnostic about the workings of phenomena such as causality and inertia that determine what sequences of events are possible or likely. <ref type="foot" target="#foot_0">2</ref> The question of whether practical reasoning about events requires non-monotonic inference (or some other non-classical form of entailment) is orthogonal to the issues addressed by VEL; indeed there is no reason why such inference mechanisms could not be built on top of VEL.</p><p>It must be further acknowledged that even in terms of expressive power there is little that can be said within VEL that could not be said by means of some other existing formalism. However, the contribution of VEL is to put together a variety of expressive devices within a single language, thus clarifying their logical interdependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Temporal ontology</head><p>The semantics of our event logic must include a structure that determines relationships between different times. The simplest model treats time as a set of linearly ordered points. This set may be further constrained to be either discrete, dense or continuous and either bounded or unbounded in each direction (or to satisfy more esoteric conditions). If we want to be able to employ modal operators to distinguish between analytic and contingent propositions, we shall need a richer structure in which there are possible states of the world which do not occur at any point in the actual history of the world. We can think of the set of all possible histories of the world as forming a branching tree structure. A number of possible semantics and axiom sets based on such structures are discussed in <ref type="bibr" target="#b46">[47]</ref>. Branching structures have also been proposed as a basis for AI reasoning systems <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b45">46]</ref> but this approach does not seem to have been widely adopted. However, in the theory of computation, branching time logics such as CTL * <ref type="bibr" target="#b12">[13]</ref> have been extensively studied <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">History structures</head><p>To model the temporal order of states of an evolving universe and the relationship between possible alternatives to the actual history of the world we employ a structure that we call a History Structure. This is a tuple H = S, T , ≺, H , where:</p><p>• S is a set {s i } of world states (called simply states for short), • T is a set {t i } of time points, • ≺ is an irreflexive linear order on T (which may be further constrained to be dense, continuous etc.), • H is a set {h i } of histories, each of which is a function from T to S.</p><p>A pair h i , t i (where h i ∈ H and t i ∈ T ) is the index of a possible world in the tree, and h i (t i ) denotes the world state that holds at that index. Each state is associated with a set of</p><formula xml:id="formula_1">entities N s . An interval [t 1 . . . t 2 ] is the set {t | t ∈ T ∧ t 1 t t 2 } of time points.</formula><p>Thus defined, history structures can take a wide variety of different forms but our commonsense view of time builds in an asymmetry between the past and the future: from the perspective of any point in time there is a single determinate past but many possible futures. To capture this intuition we specify a restricted class of history structures called History Trees, characterised by the following properties:</p><formula xml:id="formula_2">SconfP (∀h 1 , h 2 ∈ H )[(h 1 = h 2 ) ∨ (∃t ∈ T )(∀t ∈ T )[(h 1 (t ) = h 2 (t )) ↔ (t t)]]. Gclock (∀h 1 , h 2 ∈ H )(∀t 1 , t 2 ∈ T )[h 1 (t 1 ) = h 2 (t 2 ) → (t 1 = t 2 )].</formula><p>SconfP gives strict confluence in the past: every two distinct histories agree up to and including some time point and after that point they never agree. Gclock tells us that we cannot have the same state at two distinct time points (there is a 'global clock').</p><p>The confluence property induces an equivalence relation on histories with respect to any given time point:</p><formula xml:id="formula_3">h 1 t ≈ h 2 ≡ def (∀t ∈ T ) (t t) → h 1 (t ) = h 2 (t ) .</formula><p>This means that the two histories agree on the states holding at all times up to and including t (after which they may or may not diverge); it can be read as 'h 1 and h 2 coincide up to t'. The SconfP property implies that any two histories coincide up to some time point.</p><p>This model of branching time has the following useful properties: (a) on each history the time structure is linear and can be described by a relatively simple logic; (b) reasoning about alternative histories can be handled by an S5 modality.</p><p>One might for certain purposes want to drop or weaken either or both of the conditions SconfP and Gclock. SconfP means that all possible states are accessible by travelling back in time and then forward again along some alternative possible history. If we omit SconfP we would allow other states that are not accessible in this way; and this would enable us to introduce a language with a more general modalities of logical possibility and necessity. <ref type="foot" target="#foot_1">3</ref>By omitting Gclock we allow the possibility that the same state may occur at different times. This is useful if we want to think of states as configurations which are independent of their place in the history structure. For instance, in <ref type="bibr" target="#b4">[5]</ref> states are modelled in terms of distributions of physical matter in space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">States</head><p>A world state h(t) ∈ S determines all those properties of the world at time t in history h which are invariant across all the histories coincident with h up to t. We call these the properties which are settled at t in h. If h 1 (t 1 ) = h 2 (t 2 ), this does not necessarily mean that the same propositions are true at h 1 , t 1 and h 2 , t 2 . This is because the truth of certain propositions depends upon the future, which depends on the actual history.</p><p>In the present paper, the nature of states is left unanalysed. They are just elements in the semantics. However, one might well want to associate a state with some further structure.</p><p>For instance one could identify states with distributions of matter (as in <ref type="bibr" target="#b4">[5]</ref>) or with sets of certain fundamental propositions.</p><p>It is worth emphasising that our notion of state corresponds to a total specification of all properties, whereas there is another usage of 'state' which refers to some limited part or aspect of the world. Thus one might want to talk, for instance, of the 'state' of John's being asleep. In the semantics of VEL this circumstance would hold in a set of world states, i.e., a subset of S. We call such a set a partial state. Moreover, the proposition 'John is asleep' would hold at a set {. . . h i , t i . . .} of index points corresponding to the set {. . .h i (t i ) . . .} of states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Episodes</head><p>In specifying the semantics for events we shall need to refer to the interval in which an event occurs; however, an interval [t 1 . . . t 2 ] alone is not enough to locate the event within the branches of the structure: we must also take into account the history on which it occurs. This leads us to consider a pair h, [t 1 . . . t 2 ] . We now observe that for any history h coincident with h up to t 2 , the same sequence of states, and hence the same event, occurs. Therefore we define the episode [t 1 . . . t 2 ] ≈ h (where t 1 t 2 ) by:</p><formula xml:id="formula_4">[t 1 . . . t 2 ] ≈ h = h , [t 1 . . . t 2 ] | h ∈ H ∧ h t 2 ≈ h .</formula><p>Ep T denotes the set of all episodes on tree T . Episodes are not themselves sets of time points so we do not distinguish whether they are open or closed. However, the open/closed distinction becomes important when we consider the time points over which a proposition is true. A proposition might be true/false at all points within an episode, or at either of the end points of the episode, or any combination of these. 4   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Event-types</head><p>An event-type is a set of episodes. This may be specified in various ways; one important way of specifying event-types is in terms of partial states. For, example, given the partial state S ⊆ S, the event-type</p><formula xml:id="formula_5">[t . . .t] ≈ h | (∃t 1 , t 2 ) (t 1 ≺ t ≺ t 2 ) ∧ (∀t )[((t 1 ≺ t ≺ t) → h(t ) / ∈ S ) ∧ ((t ≺ t ≺ t 2 ) → h(t ) ∈ S )]</formula><p>picks out inceptions of partial state S , i.e., transitions between an interval over which S does not hold and an interval over which it does. 4 Questions of whether propositions are true over open or closed intervals (and the associated dividing instant problem) are beyond the scope of the present paper. We believe that this depends on the particular proposition in question and also (as in cases such as the light bulb switching from off to on) on the particular and somewhat arbitrary stipulations that one must make to give precise truth conditions to natural language statements that are normally used rather imprecisely. A discussion of these issues can be found in <ref type="bibr" target="#b19">[20]</ref>, especially pp. 343-345.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Event-tokens</head><p>Event-tokens are occurrences of event-types. This being so it is tempting to regard event-types as predicates over a domain of event tokens. Indeed this is the essence of Davidson's account. However, a naïve development of this idea can easily lead to contradictions. These are most apparent when we try to formulate the conditions under which an event-token can be an occurrence of more than one event-type.</p><p>Consider the event-types:</p><p>• l = John-stand-on-one-leg,</p><p>• a = John-eat-an-apple,</p><p>• la = John-stand-on-one-leg-while-eat-apple.</p><p>On the one hand it seems that l and a are disjoint kinds of event, since a token of l might cause John's leg to become stiff, whereas a token of a could not,<ref type="foot" target="#foot_2">5</ref> so there can be no token that is a token of both these types. If the two event-types apply to the same sequence of world states then this just means that two different tokens occur simultaneously. However, on the other hand, one might wish to say that a token of type la is also a token of both type l and type a, since these are just less specific descriptions of a particular occurrence described by la. We believe that these intuitions about the token/type relationship cannot be reconciled as long as we divorce event-tokens from their types. In our semantics an event-token is always associated with the event-type of which it is a token. To model this we identify an event token ε with a pair η, e , where e is an event-type and η a specific episode over which an event of that type occurs-i.e., we must have η ∈ e. Thus an event token can regarded an episode seen from a certain perspective determined by an event-type.</p><p>Identity criteria for event-tokens are a very thorny philosophical issue and we do not pretend that our semantics gives a fully adequate account. However, we do believe that our theory is a reasonable simplification, which also allows one to make some useful comparisons between event-tokens.</p><p>If two tokens occur over the same episode they are merely contemporaneous and not necessarily connected in any other way. However, if e 1 ⊂ e 2 , then this means that for every episode (in every possible history) over which an event of type e 1 occurs, an event of type e 2 also occurs. In other words, type e 2 is a generalisation of type e 1 . Correspondingly, if we have ε 1 = η, e 1 and ε 2 = η, e 2 , then, although these are distinct tokens, ε 2 can be seen as representing the same occurrence as ε 1 but from a more general perspective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.">Entities and individuals</head><p>In standard first-order logic, names are taken as basic expressions denoting individuals, which are taken as satisfying a fixed set of predicates. However, in a temporal language in which one can describe events and changes one must be able to refer to individuals which persist through time although their properties may change. In the context of our history tree model of time, we stipulate that an individual is realised in each world state (in which it exists) by an entity. These entities correspond to 'time slices' of individuals located within the branching history structure. Thus an individual is modelled by a function from states to entities. At those worlds where an individual does not exist it denotes the value ø. If at some state s two individuals correspond to the same entity we say they are co-realised at s.</p><p>Formally, the time structure together with the individuals which inhabit it is modelled by a VEL frame. This is a structure: F = T , N, I where</p><formula xml:id="formula_6">• T = S, T , ≺, H is a history tree. • N is a set of entities, • I is a set of individuals, each of which is a function from S to N ∪ {ø}.</formula><p>In this general semantics, no constraints are imposed on the set of entities or on the functions corresponding to individuals. However, one might well want to add further constraints which tie the theory to some particular model of reality. For instance, in <ref type="bibr" target="#b4">[5]</ref> the 'entities' are taken as regular open subsets of R 3 , which correspond to possible extensions of individuals.</p><p>Note that we have chosen to identify individuals as functions from states to entities rather than using a slightly more general model in which individuals are identified with functions from H × T to S. Thus, at any given time t, each individual function will have the same value in all histories that coincide up to t. This seems to be a natural condition which corresponds to the way that we normally use proper names: the attribution of a name does not depend on any assumptions or predictions about the future of the individual in question. <ref type="foot" target="#foot_3">6</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.">Verbs</head><p>In the current paper we take a rather coarse-grained view of the combination of verbs with their arguments. We shall model a verb as a function from tuples of individuals to event-types. To allow for possible indexicality within a verb expression we treat verbs as intensional, so that this function will also depend on the history and time at which the verb is evaluated. more than one point in a history structure, we might also want to modify the semantics of individuals to allow individual functions to have different values for different occurrences of the same state. Suppose, in some state s we have two rigid objects a and b that are physically identical (but in different locations and thus having different properties relative to other objects). Then after a sequence of movements of the objects we may reach a state that is physically identical to s except that the positions of a and b are interchanged. So if we take the final state as a recurrence of the initial state, we see that the properties of a and b (and hence the entities that their individual functions denote) are not determined only by the state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.8.">Propositions</head><p>The propositional expressions of the VEL language have a truth value (t or f) that will in general vary according to the history and time at which the proposition is evaluated (and also according to the interpretation of its non-logical symbols). We could allow truth values to vary arbitrarily over the indices h, t of a history tree; however, in so far as propositions are used to describe properties of the real world, we believe that it is desirable to constrain their temporal variability to rule out some pathological models. Specifically, we impose the condition that it is not possible for a proposition to change its truth value infinitely often during a finite period of time.</p><p>Infinitely frequent oscillation of a proposition's truth value is sometimes called intermingling <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b20">21]</ref>. Prohibiting intermingling is equivalent to requiring that for every proposition ϕ and any time point t, there are time points t 1 and t 2 , where t 1 &lt; t &lt; t 2 , such that the truth value of ϕ is constant for all time points in the open interval (t 1 , t) and is also constant (though not necessarily with the same truth value) over the open interval (t, t 2 ). This latter formulation of the condition corresponds directly to the VEL axioms that we shall employ in Section 7 to enforce non-intermingling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Informal overview of the VEL language</head><p>In Sections 4 and 5 we shall give a fully formal syntax and semantics for VEL but first we consider the language from an informal point of view.</p><p>It should be noted that in the formal semantics each expression will be given a denotation relative to an index point h, t within a history tree structure. At this point h is the actual history, t is the actual time and the value of h(t) is the actual state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Variables and nominal terms</head><p>In VEL there are six types of object that can be named and quantified over. These types and the variables that are used to denote them are as follows:</p><formula xml:id="formula_7">• individuals-a, b, c, . . . , • times-t i , • intervals-δ i , • event-tokens-ε i , • states-s i , • observable values-o i .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Logical functions and predicates</head><p>A small number of logical functions are used to transfer information between different semantic types:</p><p>• b(δ) and e(δ) return times which are respectively the beginning and end points of the interval δ. • state(τ ) gives the world state that obtains at the time denoted by τ in the actual history.</p><p>• dur(ε) gives the interval of occurrence of the event token ε.</p><p>The following logical predicates are also employed:</p><p>• α = β is true just in case the terms α and β have the same extension.</p><p>• τ 1 τ 2 is true just in case the time term τ 1 denotes a time equal to or earlier than τ 2 .</p><p>• AT(τ ) is true just in case τ denotes the actual time.</p><p>The proposition AT(τ ) is true only at index points h, t , where the index t is the time point denoted by the object language time term τ . The AT predicate can be used to construct propositions whose truth at a given time point depends on other time points. For example,</p><formula xml:id="formula_8">AT(t) ∧ (∃t )[(t t) ∧ ϕ(t )] is true iff ϕ(t )</formula><p>holds for some t that is before or equal to the actual time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Count nouns and quantifiers over individuals</head><p>A component of VEL that is probably unfamiliar to most AI researchers is the use of Gupta's <ref type="bibr" target="#b23">[24]</ref> theory of count nouns. At each index h, t , a count noun picks out a set of individuals. This means that the entities picked out by a count noun are doubly relative to the possible world (as identified by the index) at which a count noun expression is evaluated: the count noun is evaluated at some possible world to give a set of individuals which are instances of the count noun. Each individual must in turn be evaluated relative to a possible world to yield an entity existing at that world (see Section 2.6 above).</p><p>The reason for this double relativity is that we very often employ count nouns to pick out individuals at some particular world and then consider properties of these individuals at another world. For example, in the sentence "Some girl will become president of the USA", the phrase "some girl" quantifies over individuals who are girls at the present time. The individual concepts corresponding to these girls will denote different entities in different possible worlds but in many of these worlds those entities will not be girls. Thus the claim (at least in one reading) does not imply that the predicted female president will still be young when she takes office.</p><p>Quantification over individuals takes the form</p><formula xml:id="formula_9">(∀C, x)[ϕ(x)],</formula><p>where C is a count noun. The count noun operates like a sort but it also fixes the transworld identity conditions of quantified variables by determining the entities denoted by an individual variable at each index in the history tree. We also define:</p><formula xml:id="formula_10">(D1) (∃C, x)ϕ(x) ≡ def ¬(∀C, x)¬ϕ(x), (D2) C(α) ≡ def (∃C, x)[x = α], (D3) C[α] ≡ def (∃C, x)[ (x = α)].</formula><p>C [α] means that α denotes one of the individuals that is (at the actual index) a C; whereas, C(α) means that α denotes an individual that is merely co-realised by some individual that is a C. Thus we might write:</p><formula xml:id="formula_11">(∃PRESIDENT, a)[WOMAN[a]],</formula><p>since presidents and women are both individuals of the same kind and share the same trans-world identity criteria; but</p><formula xml:id="formula_12">(∃QUANTITY-OF-WOOD, a)[SHIP(a)],</formula><p>since, although ships and quantities of wood may be materially identical (co-realised) in some world state, they do not have the same trans-world identity criteria (e.g., consider the ship of Theseus).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Propositional operators</head><p>VEL includes a variety of well-known temporal operators and modalities. P and F are past and future tense operators defined in the normal way. is just an S5 modality operatorϕ is true if ϕ is true at every index point. The * operator is a bit more subtle:</p><p>* ϕ is true at h, t if ϕ is true at t in all histories which share the same initial segment as h up to time t. Thus, * Fϕ means that ϕ is 'inevitable'. Dual operators ♦ and ♦ * are defined in terms of and * in the usual way. (♦ * can be used to model the E operator of CTL * <ref type="bibr" target="#b12">[13]</ref>, which has a similar interpretation.)</p><p>We also have operators ϕ and ϕ, meaning respectively that ϕ 'has just been true' or 'is just about to become true'. ϕ is rather like the standard 'next time' operator, except that it makes sense within a dense of continuous time series. It means that ϕ is true over some open set of time points, whose greatest lower bound is the actual time. is defined analogously. Such operators were proposed by Barringer et al. <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Relations and verbs</head><p>Relations represent arbitrary intensional constraints over the universe of possible denotations of nominal terms. At each index point an n-ary relation is associated with the set of n-tuples drawn from this universe for which the relation holds. These tuples must respect the type of the relation (see Section 5.1 below). Verbs combine with one or more expressions denoting individuals to produce an expression that denotes an event-type. At each index a verb is associated with a mapping from n-tuples of individuals to event-types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Syntactic roles of event-types</head><p>Expressions of the category of event-type can combine with other expressions in various different ways.</p><p>Event modalities. In the style of dynamic logics we employ event-types within a propositional operation [e]ϕ, which says that ϕ holds in all states accessible from the current state via an occurrence of an event of type e. The dual operator e ϕ is defined in the usual way.</p><p>The Occurs relation. The Occurs relation provides a flexible way of talking about types of events in terms of conditions which hold before and after (and perhaps also during) the time period over which an event of that type takes place. For example, following Galton <ref type="bibr" target="#b19">[20]</ref>, we could define the event-type where a body moves between two positions by:</p><formula xml:id="formula_13">(∀BODY, b)(∀r 1 , r 2 )[Occurs(move(b, r 1 , r 2 ), δ) ↔ Holds-at((ext(b) = r 1 ), begin(δ)) ∧ Holds-at((ext(b) = r 2 ), end(δ)) ∧ ∀t[(b(δ) &lt; t &lt; e(δ)) → Holds-at((ext(b) = r 1 ∧ ext(b) = r 2 ), t)].</formula><p>Here r i are observable variables. ext is a function returning an observable value giving the region occupied by an individual. 7 The moving object b is constrained to be at r 1 at the beginning of the movement and r 2 at the end, and it cannot be at either of these locations at any other time within the movement. We do not suggest that this corresponds exactly to what we would in natural language call a 'movement', which is ambiguous in various ways.</p><p>Quantifying over singular events. A quantification over event-tokens is a formula of the form ∀e, ε [ϕ(ε)]. Allowing event-types to act as sortals in quantification over event tokens provides a mechanism for associating event-types with event token variables. Because the event-token variable carries with it an event-type as well as an episode the truth conditions of properties of event-tokens (and also the values of functions involving them) are not determined solely by the time period over which they occur. If we allowed unrestricted quantification over singular events, the language would become second-order. This is because we would be implicitly quantifying over the associated event-types, and event-types are interpreted as sets of episodes. 8   Aspect operators. The operators Perf , Pros and Prog operate on event-type expressions to produce propositions. Perf (e), Pros(e) and Prog(e) mean respectively that event e has happened, will happen, and is happening. 9 If we want to say that an event is in progress without asserting that it will definitely be completed we can use the form ♦ * Prog(e). We can say that an event is just about to happen using the form ¬Prog(e) ∧ Prog(e) (that an event has just been completed can be represented similarly but with ).</p><p>Subsumption and identity of event-types. We will sometimes want to relate one eventtype expression to another, either by saying that they are equivalent: e 1 ≡ e 2 ; or that one is a 'more specific' type of event than another: e 1 e 2 . In terms of occurrence, these mean 7 The semantics of spatial extensions and relationships between them will not be considered in this paper; however, Bennett <ref type="bibr" target="#b4">[5]</ref> presents a language called O, which is compatible with VEL and does have a semantics that explicitly models spatial extensions of moving material bodies. 8 By defining very general types of event we can often express properties that might appear to require quantification over all event-tokens. We do this in our formulation of Event Calculus in Section 9.2, where we quantify over the type any-event defined in (D41). 9 In the case of instantaneous event-types the construct Prog e doesn't really make sense (see <ref type="bibr" target="#b15">[16]</ref> for a discussion of this). But according to the formal semantics given later in this paper it will always be false.</p><p>that for every interval over which an event of type e 1 occurs, an event of type e 2 also occurs, and in the case of ≡ the converse also holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.">Event-type abstraction</head><p>The construct δ : ϕ serves as a powerful means of defining event-types in terms of conditions on the time intervals over which they occur. Typically δ will occur as a free variable in ϕ, in which case we may write δ : ϕ(δ) . When evaluated at an index h, t , the expression δ : ϕ(δ) refers to the event-type corresponding to the set of all episodes</p><formula xml:id="formula_14">[t 1 . . . t 2 ] ≈ h such that ϕ([t 1 . . . t 2 ]</formula><p>) is true at index h , t . 10 To illustrate the use of event abstraction, let us define 11 a verb collide(a, b) describing (punctual) collision events between two individuals:</p><formula xml:id="formula_15">(∀ BODY, a, b)[collide(a, b) ≡ δ : ((b(δ) = e(δ) = t) ∧ Holds-at(C(a, b) ∧ ¬C(a, b), t)) ]</formula><p>Here C is the connection relation of the RCC spatial theory <ref type="bibr" target="#b40">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8.">Holds-at and Holds-in</head><p>VEL includes the construct Holds-at(ϕ, τ ), which has been employed in many AI representations. It is true just in case ϕ is true (in the actual history) at the time point denoted by τ .</p><p>Holds-in(ϕ, ς ) asserts that ϕ is 'settled' as true at the state s denoted by ς . This means that ϕ is true at every index h, t such that h(t) = s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Syntax</head><p>We now formally specify the syntax of VEL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Variables and non-logical constants</head><p>The language has variables of six nominal types, σ i , σ t , σ δ , σ ε , σ s , σ o , which can be quantified over. Any variable that is not bound by a quantifier behaves as a constant. The vocabulary sets of these types of variables are respectively:</p><formula xml:id="formula_16">• Individuals, V i = {a, b, c, . . .}. • Times, V t = {t i }. • Intervals, V δ = {δ i }.</formula><p>10 Thus, in general, the abstracted event-type depends on the time t of the point of evaluation; but in most useful cases ϕ(δ) will actually be invariant over time, unless ϕ contains some embedded indexical. 11 In fact we give a universal identity axiom; but, if we take C as being primitive, we can regard the r.h.s. of the identity as a definition of collide(a, b).</p><p>• Event-Tokens,</p><formula xml:id="formula_17">V ε = {ε i }. • States, V s = {s i }. • Observable Values, V o = {o i }.</formula><p>In many cases quantification over times, intervals, events and world states can be avoided by the use of tense and aspect operators, modal operators and various other constructs. For practical applications one might employ sublanguages of VEL that allow little or no quantification.</p><p>Four other types of non-logical constant are not quantified over: 12</p><formula xml:id="formula_18">• Count nouns, V c = {C i }. • Relations, V R = {A, B, C, . . .}. • Functions, V f = {f i }. • Verbs, V v = {v i }.</formula><p>A VEL vocabulary is thus a 10-tuple</p><formula xml:id="formula_19">V = V i , V t , V δ , V ε , V s , V o , V c , V R , V f , V v .</formula><p>The sets V R , V f and V v are partitioned into sub-classes according to the numbers and types of arguments that these expressions can combine with. It may seem that the diversity of syntactic types in VEL is excessive; but the idea of VEL is to be inclusive and to incorporate as many as possible of the kinds of expression that have been employed in temporal representations. VEL is not intended to provide a practical logic but rather a comprehensive umbrella language into which many other formalisms can be translated. 13   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Terms and functions</head><p>There are three types of term:</p><p>• variables (of the six nominal types),</p><p>• the symbol null (of type σ i ),</p><p>• functional terms of the form f (β 1 , . . . , β n ), where β 1 , . . . , β n are terms and f ∈ V f . Functions come in a variety of different types according to the nominal types they accept as arguments and the nominal type of the resulting functional term. A function type is described by a pair σ 0 , σ 1 , . . . , σ n specifying the result and argument types respectively. 12 In principle we could also allow quantification over these; but we would then immediately get a second order language which would be highly intractable and most probably unaxiomatisable. 13 It might be argued that to obtain a still more comprehensive logic we should also have variables referring to histories. We have chosen not to do so here. While this does to some extent limit the expressive power of the language relative to its semantics, we do not believe that this is a serious shortcoming. Unrestricted history quantification does not seem to correspond to any structure found in normal temporal discourse. Moreover, a restricted (and arguably more natural) version of quantification over histories can be expressed in VEL by the * operator, which will be introduced below.</p><p>The unary logical functions b and e are both of type σ t , σ δ , state is of type σ s , σ t and dur of type σ δ , σ ε ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Event-type expressions</head><p>An event-type, or σ e , expression is either:</p><formula xml:id="formula_20">• a 0-ary verb ∈ V v ,</formula><p>• an expression v(α 1 , . . . , α n ), where v is an n-ary verb ∈ V v and the αs are of type σ i ,</p><p>• an event abstraction δ : ϕ , where δ is any variable of type σ δ and ϕ is a proposition (as defined below).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Propositions</head><p>An atomic proposition has one of the following forms:</p><p>• α 1 = α 2 , where the α's are terms of the same type,</p><p>• τ 1 τ 2 , where the τ 's are terms of type σ t ,</p><p>• AT(τ ), where τ is a term of type σ t ,</p><p>• R(β 1 , . . . , β n ), where R ∈ V R and β 1 , . . . , β n are terms.</p><p>Each argument of a given relation R must be of a specific nominal type. The type of an n-ary relation can be described by a tuple σ 1 , . . . , σ n , where the σ s are the types of its arguments (the result type always being a proposition). More generally, a proposition of VEL is either an atomic proposition or has one of the forms:</p><p>• one of: ¬ϕ, ϕ 1 ∧ ϕ 2 , Fϕ, Pϕ, ϕ, * ϕ, ϕ, ϕ,</p><p>• Holds-at(ϕ, τ ), where τ is of type σ t , • Holds-in(ϕ, ς ), where ς is of type σ s , • Occurs(e, δ), where e is of type σ e and δ is of type σ δ ,</p><p>• [e]ϕ, where e is of type σ e , • (∀χ)ϕ, where χ is a variable of one of the types σ t , σ δ , σ s , σ o , • (∀κ, υ)ϕ, where κ is of type σ c and υ is a variable of type σ i , • ∀θ, ε ϕ, where θ is of type σ e and ε is a variable of type σ ε , • one of: Perf θ , Progθ , Prosθ , where θ is type σ e , where in each case ϕ is any VEL proposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Formal semantics</head><p>We now give a fully formal semantics wherein each well formed VEL expression is evaluated relative to an index h, t on a VEL frame and an assignment A, which determines the values of non-logical constants. We write ❏α❑ A h,t to refer to the denotation of α at index h, t according to the assignment A.</p><p>For a propositional expression ϕ the value of ❏ϕ❑ A h,t is either t or f. In this case it is often convenient to use the notation ❏ϕ❑ TS to denote the set of assignments and indices for which ϕ is true-i.e., the 'truth set' of ϕ. Formally we have ❏ϕ❑ TS = { A, h, t | ❏ϕ❑ A h,t = t}. To describe the semantics of expressions such as quantifiers, we will need to talk about certain classes of similar assignments. We use the notation A (x→v) to refer to that assignment A which assigns the value v to the variable x and for all other variables assigns exactly the same values as A. <ref type="figure">V,</ref><ref type="figure">A</ref> , where:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">VEL model structures</head><formula xml:id="formula_21">A VEL model is a structure M = F , O,</formula><formula xml:id="formula_22">• F = T , N, I is a VEL frame, with T = S, T , ≺, H , • O is the set of possible values of observables, • V is a vocabulary, • A is an assignment structure.</formula><p>The assignment structure A is used to interpret all the non-logical atomic symbols of VEL. Specifically, A = a i , a t , a δ , a ε , a s , a o , a R , a f , a c , a v , where:</p><p>• a i : V i → I assigns an individual to each individual variable.</p><p>• a t : V t → T assigns a time point to each time variable.</p><p>• a δ : V δ → (T × T ) assigns to each interval variable an interval [t 1 . . . t 2 ], such that t 1 t 2 . • a ε : V ε → (Ep T × ℘ (Ep T )), assigns to each event-token variable a pair η, E , where η is episode and E is a set of episodes and η ∈ E. • a s : V s → S assigns a state to each state variable.</p><p>• a o : V o → O assigns an observable value to each observable variable.</p><p>• a c : V c → ((H × T ) → ℘ (I)) assigns to each count noun a function from indices to sets of individuals.</p><formula xml:id="formula_23">• a v : V v → ((H × T × I n ) → ℘ (Ep T</formula><p>)) assigns a denotation to each n-ary verb, this is a mapping from history and time indices and tuples of individuals to sets of episodes.</p><p>The assignment functions a R and a f are slightly harder to specify because of the variety of argument types. For each nominal type σ let U σ be the range of a σ . Then, for relations of type σ = σ 1 , . . . , σ n we have:</p><formula xml:id="formula_24">• a R σ : V R → ((H × T ) → ℘ (U σ 1 × • • • × U σ n ))</formula><p>assigns to each relation symbol a mapping from indices to the set of tuples of objects (from domains appropriate to the type σ ) that satisfy the relation;</p><p>and for functions of type σ = σ 0 , σ 1 , . . . , σ n</p><formula xml:id="formula_25">• a f σ : V o → ((H × T ) → ((U σ 1 × • • • × U σ n ) → U σ 0 )</formula><p>) assigns a suitable intensional function to each function symbol of type σ .</p><p>We can then define generic functions a R and a f which can be applied respectively to any relational or any functional symbol:</p><formula xml:id="formula_26">• a R = σ a f σ , • a f = σ a R σ .</formula><p>To ensure that the propositions constructed from the basic vocabulary are not affected by intermingling (see Section 2.8) we need to impose some further condition on VEL models. Specifically, we require that all those denotations which are functions of time (i.e., the denotations of individuals, count nouns, verbs, relations and functions) do not oscillate infinitely often within any finite interval. Also, the denotations of any pair of individuals cannot be such that they change to and from being co-realised infinitely often in a finite period; and the set of episodes in any event-type (or in the episode set associated with an event-token) cannot contain an infinite number of episodes that share a common history and either begin or end infinitely often within some finite interval. Because these constraints are somewhat awkward to specify formally, we instead express them in terms of the general condition that</p><p>• for any proposition ϕ, the value ❏ϕ❑ A h,t cannot change its value infinitely often within a finite time interval. This implicitly imposes the required restrictions on all denotations of propositional constituents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">The semantic denotation function</head><p>We now specify the semantic denotation for all meaningful expressions of VEL using standard set theory and quantification as a meta-language. Variables t i range over elements of the set of times (T ) and h i range over histories (elements of H ). For any non-logical symbol κ, A(κ) is the result of applying to κ the appropriate function in A, according to the type of κ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1.">Atomic symbols and nominal terms</head><formula xml:id="formula_27">(S1) ❏γ ❑ A h,t = A(γ ), where γ is any atomic non-logical symbol. (S2) ❏null❑ A h,t = ø. (S3) ❏b(δ)❑ A h,t = t 1 , where ❏δ❑ A h,t = [t 1 . . . t 2 ]. (S4) ❏e(δ)❑ A h,t = t 2 , where ❏δ❑ A h,t = [t 1 . . . t 2 ]. (S5) ❏state(τ )❑ A h,t = h(❏τ ❑ A h,t ). (S6) ❏dur(ε)❑ A h,t = [t 1 . . . t 2 ], where ❏ε❑ A h,t = [t 1 . . . t 2 ] ≈ h , E . (S7) ❏g(β 1 , . . . , β n )❑ A h,t = a f (g)(h, t, ❏β 1 ❑ A h,t , . . . , ❏β n ❑ A h,t ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.">Event-type expressions</head><p>Complex event-types are constructed either by combining a verb with individual constants or terms or by the event abstraction operator:</p><formula xml:id="formula_28">(S8) ❏v(α 1 , . . . , α n )❑ A h,t = a v (v)(h, t, a i (α 1 ), . . . , a i (α n ) ). (S9) ❏ δ : ϕ ❑ A h,t = {[t 1 . . . t 2 ] ≈ h | A δ→[t 1 •••t 2 ]) , h , t ∈ ❏ϕ❑ TS )}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3.">Atomic propositional formulae</head><formula xml:id="formula_29">(S10) ❏R(β 1 , . . . , β n )❑ TS = { A, h, t | ❏β 1 ❑ A h,t , . . . , ❏β n ❑ A h,t ∈ a R (R)(h, t)}. (S11) ❏α 1 = α 2 ❑ TS = { A, h, t | ❏α 1 ❑ A h,t (h(t)) = ❏α 2 ❑ A h,t (h(t))}. (S12) ❏τ 1 τ 2 ❑ TS = { A, h, t | ❏τ 1 ❑ A h,t ❏τ 2 ❑ A h,t }. (S13) ❏AT(τ )❑ TS = { A, h, t | ❏τ ❑ A h,t = t}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4.">Complex propositions</head><p>The Boolean connectives have standard interpretations:</p><formula xml:id="formula_30">(S14) ❏¬ϕ❑ TS = { A, h, t | A, h, t / ∈ ❏ϕ❑ T S }. (S15) ❏ϕ 1 ∧ ϕ 2 ❑ TS = ❏ϕ 1 ❑ TS ∩ ❏ϕ 2 ❑ TS .</formula><p>The constructs Holds-at(ϕ, τ ) and * ϕ are interpreted as follows:</p><formula xml:id="formula_31">(S16) ❏Holds-at(ϕ, τ )❑ TS = { A, h, t | A, h, ❏τ ❑ A h,t ∈ ❏ϕ❑ TS }. (S17) ❏ * ϕ❑ TS = { A, h, t | (∀h )[(h t ≈ h) → A, h , t ∈ ❏ϕ❑ TS ]}.</formula><p>The following clauses specify the various kinds of quantification that can be expressed in VEL: χ→v)   h,t</p><formula xml:id="formula_32">(S18) ❏(∀C, x)[ϕ]❑ TS = { A, h, t | (∀i)(i ∈ ❏C❑ A h,t → ❏ϕ❑ A (x→i) h,t = t)}. (S19) ❏ ∀ e, ε [ϕ]❑ TS = { A, h, t | (∀t 1 , t 2 , η)[([t 1 . . . t 2 ] ≈ h ∈ ❏e❑ A h,t ∧ η = [t 1 . . . t 2 ] ≈ h , ❏e❑ A h,t ) → ❏ϕ❑ A (ε→η) h,t = t]}. (S20) ❏∀ δ[ϕ]❑ TS = { A, h, t | (∀t 1 , t 2 )[(t 1 t 2 ) → ❏ϕ❑ A (δ→[t 1 ...t 2 ]) h,t = t]}. (S21) ❏∀ χ σ [ϕ]❑ TS = { A, h, t | (∀v ∈ U χ )[❏ϕ❑ A (</formula><p>= t]}, where σ is one of the types σ t , σ s or σ o and χ σ is a variable of type σ .</p><p>Quantification over individuals is always restricted to those satisfying a given count noun.</p><p>Similarly event-token quantification is always over tokens of a given type. Quantification over the other types is unrestricted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Definable constructs</head><p>The operators and constructs we defined semantically in the previous section constitute the logical primitives of VEL. We shall now use these to define a much richer vocabulary which provides a very expressive language for describing time and events, and in particular allows one to use all the modes of temporal representation that were considered in Section 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Temporal relations</head><p>The temporal relations &lt;, and &gt; between time points have standard definitions in terms of the primitives and =. By using the functions b(δ) and e(δ), it is also trivial to define each of Allen's 13 relations that can hold between temporal intervals <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Propositional operators</head><p>Standard past and future tense operators are definable in terms of Holds-at and the AT predicate. <ref type="foot" target="#foot_4">14</ref>(D4)</p><formula xml:id="formula_33">Pϕ ≡ def (∃t 1 , t 2 )[AT(t 1 ) ∧ (t 1 &gt; t 2 ) ∧ Holds-at(ϕ, t 2 )]. (D5) Fϕ ≡ def (∃t 1 , t 2 )[AT(t 1 ) ∧ (t 1 &lt; t 2 ) ∧ Holds-at(ϕ, t 2 )].</formula><p>We also define the following tense-like operators that allow us to say that a proposition is true throughout some open interval either immediately before or immediately after the current time point. These enable one to describe the ways in which truth values of propositions can change in dense or continuous time.</p><formula xml:id="formula_34">(D6) ϕ ≡ def (∃t 1 , t 2 )[AT(t 2 ) ∧ (t 1 &lt; t 2 ) ∧ (∀t 3 )[(t 1 t 3 &lt; t 2 ) → Holds-at(ϕ, t 3 )]]. (D7) ϕ ≡ def (∃t 1 , t 2 )[AT(t 1 ) ∧ (t 1 &lt; t 2 ) ∧ (∀t 3 )[(t 1 &lt; t 3 t 2 ) → Holds-at(ϕ, t 3 )]].</formula><p>We now define the necessity operator ϕ, which says that ϕ is true at all index points in the history tree model structure. The following definition is justified by the confluence property of history trees enforced by the SconfP condition.</p><formula xml:id="formula_35">(D8) ϕ ≡ def (∀t)[ Holds -at( * ∀t [Holds-at(ϕ, t )], t)].</formula><p>The following definitions characterise Galton's <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> perturbation and dominance relations which can be used to describe possible state changes in physical systems. One proposition is a perturbation of another just in case it is possible for there to be a direct transition between a state in which ϕ holds and a state in which ψ holds. ϕ is said to dominate ψ iff: whenever an open interval over which ϕ holds immediately precedes or follows an open interval over which ψ holds, then ϕ must also hold at the intermediate point between these two intervals.</p><formula xml:id="formula_36">(D9) Perturbation(ϕ, ψ) ≡ def ♦((ϕ ∧ ( ψ ∨ ψ)) ∨ (ψ ∧ ( ϕ ∨ ϕ))). (D10) Dominates(ϕ, ψ) ≡ def ((( ϕ ∧ ψ) ∨ ( ψ ∧ ϕ)) → ϕ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Operators forming propositions from event-types</head><p>The Occurs predicate, which relates event-types to the intervals over which they occur, has the following simple definition:</p><formula xml:id="formula_37">(D11) Occurs(e, δ) ≡ def (∃e, ε)[dur(ε) = δ].</formula><p>The aspect operators, which convert event radicals into propositions, are defined as follows:</p><formula xml:id="formula_38">(D12) Perf (e) ≡ def (∃δ)(∃t)[AT(t) ∧ (e(δ) t) ∧ Occurs(e, δ)]. (D13) Pros(e) ≡ def (∃δ)(∃t)[AT(t) ∧ (t b(δ)) ∧ Occurs(e, δ)]. (D14) Prog(e) ≡ def (∃δ)(∃t)[AT(t) ∧ (b(δ) &lt; t &lt; e(δ)) ∧ Occurs(e, δ)].</formula><p>We use the notation e(ε) to say that the event token ε is of type e. This is defined by </p><formula xml:id="formula_39">(D15) e(ε) ≡ def (∃e, ε )[ε = ε ].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Complex event-types</head><p>Using event abstraction we can define more complex event types. Conjunctive and disjunctive event-types can be defined as follows:</p><p>(D20) e 1 e 2 = def δ : (Occurs(e 1 , δ) ∧ Occurs(e 2 , δ)) . (D21) e 1 e 2 = def δ : (Occurs(e 1 , δ) ∨ Occurs(e 2 , δ)) .</p><p>We can also define an event-type corresponding to a concatenated sequence of two component event-types:</p><formula xml:id="formula_40">(D22) e 1 ; e 2 = def δ : (∃δ 1 , δ 2 )[Occurs(e 1 , δ 1 )∧Occurs(e 2 , δ 2 )∧b(δ) = b(δ 1 )∧e(δ 1 ) = b(δ 2 ) ∧ e(δ 2 ) = e(δ)] .</formula><p>We can introduce operators for converting an event-type, e, into punctual event-types corresponding to beginnings and endings of events of type e:</p><p>(D23) begin e = def δ 1 :</p><formula xml:id="formula_41">(∃δ 2 )[Occurs(e, δ 2 ) ∧ b(δ 1 ) = e(δ 1 ) ∧ b(δ 1 ) = b(δ 2 )] . (D24) end e = def δ 1 : (∃δ 2 )[Occurs(e, δ 2 ) ∧ b(δ 1 ) = e(δ 1 ) ∧ e(δ 1 ) = e(δ 2 )] .</formula><p>VEL allows the definition of many more useful operators for forming complex event-types.</p><p>For instance we can define various types of 'process' consisting of sequences of repeating and possibly overlapping sub-events. These will not be covered in the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.">Constructing event-types from propositions</head><p>It is often natural to define event-types by reference to the changing truth values of propositions. Within VEL we can define punctual event types which occur at the beginning and end points at which a proposition is true, or at points where a proposition is instantaneously true:</p><formula xml:id="formula_42">(D25) begin ϕ ≡ def δ : Holds-at((ϕ ∧ ¬ϕ), b(δ)) ∧ (b(δ) = e(δ)) . (D26) end ϕ ≡ def δ : Holds-at((ϕ ∧ ¬ϕ), b(δ)) ∧ (b(δ) = e(δ)) . (D27) inst ϕ ≡ def begin ϕ end ϕ .</formula><p>We can also regard the period of time over which a proposition is true as characterising an event. It is convenient to first define Holds-on(ϕ, δ) to mean that ϕ holds at all time points interior to the interval δ. <ref type="foot" target="#foot_5">15</ref>(D28) Holds-on(ϕ, δ)</p><formula xml:id="formula_43">≡ def (b(δ) &lt; e(δ)) ∧ (∀t)[(b(δ) &lt; t &lt; e(δ)) → Holds-at(ϕ, t)].</formula><p>We now define the construct ϕ to refer to the event-type which occurs during every interval such that ϕ is true for all times between its end points: <ref type="foot" target="#foot_6">16</ref>(D29) ϕ ≡ def δ : Holds-at( ¬ϕ, b(δ)) ∧ Holds-on(ϕ, δ) ∧ Holds-at( ¬ϕ, e(δ)) .</p><p>Note that ϕ occurs over an interval whether or not ϕ holds at its end points. Depending on the meaning of the proposition ϕ, intervals over which it holds may be either open or closed at each end. However we could easily define more restricted operators that give event-types corresponding to only open or only closed periods over which ϕ holds (or indeed periods that are open at one end and closed at the other).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.">Predicates and functions of states</head><p>Using Holds-at and the state function together with the alternative history operator, we can define the condition that a proposition holds in a particular state as follows: <ref type="foot" target="#foot_7">17</ref>(D30) Holds-in(ϕ, s) ≡ def (∀t)[state(t) = s → Holds-at( * ϕ, t)].</p><p>A proposition ϕ can only hold in a state s if the truth of ϕ at s does not depend on the future, otherwise its truth value is not settled by the state and Holds-in(ϕ, s) is taken to be false.</p><p>When describing scenarios in terms of states it is useful to have a predicate to pick out the actual state and a function to give the time at which a state occurs:</p><formula xml:id="formula_44">(D31) AS(s) ≡ def (∃t)[AT(t) ∧ state(t) = s]. (D32) time(s) = τ ≡ def ♦(state(τ ) = s).</formula><p>AS enables us to define useful relationships of accessibility between states. (e : s 1 ⇒ s 2 ) says that one can get from state s 1 to state s 2 via an occurrence of an event of type e (this relation is closely related to the accessibility relation of the [e] modal operator). s 1 ⇒ s 2 says that (either s 1 = s 2 or) on some history s 2 lies in the future of s 1 .</p><formula xml:id="formula_45">(D33) (e : s 1 ⇒ s 2 ) ≡ def ♦(AS(s 1 ) ∧ (∃δ)[AT(b(δ) ∧ Occurs(e, δ) ∧ state(e(δ)) = s 2 ]). (D34) (s 1 ⇒ s 2 ) ≡ def (s 1 = s 2 ) ∨ ♦(AS(s 1 ) ∧ F AS(s 2 )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Proof theory</head><p>The logic VEL is not designed as a language for automated reasoning. It is a general semantic theory of events, within which a variety of less expressive but more practical representations can be embedded. Nevertheless, a proof system for VEL could be used to test inferences within sublanguages of VEL and also for proving properties of the relationships between these sublanguages. Given the complexity of VEL the task of specifying an axiom system for the language is extremely difficult. Nevertheless we present the following set of axioms which we believe is close to being complete relative to our semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">An axiomatic proof system</head><p>We need to axiomatise the following undefined logical symbols: ¬ϕ, ϕ ∧ ψ, β 1 = β 2 , τ 1 τ 2 , Holds-at(ϕ, t), AT(t), * ϕ, null, b(δ), e(δ), dur(ε), state(t), δ : ϕ(δ) and the six kinds of quantifier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1.">Substitution notation</head><p>In stating the proof theory we shall use the following notation to specify the result of substituting one variable for another in a formula:</p><p>• ϕ t ⇒t is the result of substituting t for one or more occurrences of t in ϕ, which do not occur within the scope of a quantification w.r.t. either t or t . • ϕ t t is the result of substituting t for all occurrences of t in ϕ which do not occur within the scope of a quantification w.r.t. t . None of these occurrences may occur within the scope of a quantification w.r.t. t.</p><p>The first of these describes the type of substitution justified by an equality and the second describes that used in instantiating a universal quantifier. In both cases the substituent must be free and the substituent must not become bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2.">Classical propositional logic</head><p>At the core of the system is the classical propositional logic:</p><formula xml:id="formula_46">(R1) ϕ if ϕ is a classical propositional theorem. (R2) If ϕ and (ϕ → ψ) then ψ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3.">Identity and quantification theory</head><p>All types of nominal variables and terms obey the axioms of reflexive identity and substitution of necessary identicals: (A1) α = α, where α is any term. (A2) ( (α = α ) ∧ ϕ) → ϕ α⇒α , where α and α are nominal terms of the same type.</p><p>Since VEL is an intensional logic, substitution generally requires necessary identity rather then mere extensional identity. However, all variables except individuals are purely extensional. Thus we have the following axiom:</p><formula xml:id="formula_47">(A3) (χ = χ ) → (χ = χ )</formula><p>, where χ and χ are variables both of the same type, which is one of σ t , σ δ , σ s , σ o or σ ε .</p><p>Although individuals are intensional, their reference at an index h, t is determined by the state h(t). Thus, where h(t) = h (t) (i.e., h and h are confluent at t) an individual constant will have the same denotation at h, t and h , t . This semantic constraint is captured by the axiom:</p><formula xml:id="formula_48">(A4) (α 1 = α 2 ) → * (α 1 = α 2 )</formula><p>, where α 1 and α 2 are symbols of type σ i .</p><p>Variables denoting time points, intervals, states and observable values obey completely standard quantification theory. Let ν be a variable of any of the types σ t , σ δ , σ s or σ o and ν be any variable of the same type as ν. Then the proof theory for quantification over these types of variable can be specified by the rule and axiom:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.8.">Event quantification</head><p>The event quantification employed in VEL takes the form of quantifying over the eventtokens of a particular event-type. This is much the same as ordinary sorted quantification and inferences involving event quantifiers can be reduced to the following simple rules:</p><formula xml:id="formula_49">(R7) If (ϕ → ψ) then (ϕ → ∀e, ε [ψ]), provided ε does not occur free in ϕ. (A35) ( ∀e, ε ϕ ∧ e(ε )) → ϕ ε ε .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.9.">Event abstraction and the dur function</head><p>The following axiom characterises the event abstraction operator by ensuring that the intervals over which the instances of an abstracted event-type occur satisfy the interval predicate that was used to make the abstraction:<ref type="foot" target="#foot_8">26</ref> </p><formula xml:id="formula_50">(A36) ϕ(δ) ↔ ∃ δ : ϕ(δ ) , ε [dur(ε) = δ].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.10.">States and the state function</head><p>Finally we ensure that the state function respects the structure of the history frames. We need to ensure that the history tree constraint Gclock holds, that every two histories have a confluence point, and that this point is unique (SconfP):</p><formula xml:id="formula_51">(A37) (state(t 1 ) = s ∧ ♦state(t 2 ) = s) → t 1 = t 2 . (A38) (∀s 1 , s 2 )(∃s 3 )[(s 3 ⇒ s 1 ) ∧ (s 3 ⇒ s 2 )]. (A39) (∀t 1 , t 2 )[(t 1 &lt; t 2 ∧ state(t 1 ) = s 1 ∧ state(t 2 ) = s 2 ) → (state(t 2 ) = s 2 → state(t 1 ) = s 1 )].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Completeness</head><p>The task of establishing a complete axiom system for VEL is ongoing work. However, Bennett <ref type="bibr" target="#b6">[7]</ref> does give a completeness proof for a large fragment of the logic including the constructs: ¬ϕ, ϕ ∧ ψ, β 1 = β 2 , τ 1 τ 2 , Holds-at(ϕ, t), AT(t), * ϕ, together with quantification over time variables. That paper shows that the proof system consisting of rules (R1)-(R17) and axioms (A1)-(A4) is complete (for that sub-language) with respect to the branching history semantics.</p><p>Our axioms for interval variables and the b and e functions are very straightforward and we believe that it will be a routine matter to extend the completeness proof to include this part of the language. Gupta <ref type="bibr" target="#b23">[24]</ref> proves completeness of his axioms with respect to a very general modal semantics which seems to be compatible with the more specialised semantics of VEL. However, giving a rigorous completeness proof for the count-noun axioms within the setting of VEL would be a substantial task. As regards our axioms for event quantification, abstraction and the state function, these are based on our intuitive understanding of the VEL models. Here it is possible that we have omitted some essential property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Additional logical constraints</head><p>Because of the general nature of our semantics, possible interpretations of certain types of expression are more fluid than one would normally want. Specifically, since expressions such as relations, event-types and count nouns are intensional they could have quite different 'meanings' at different indices in a history tree. This limits the class of valid inferences involving multiple index points. Clearly, most ordinary concepts have a much more rigid meaning than this. Hence we present a number of constraints which one will often wish to apply to the basic vocabulary of theories formulated within VEL. <ref type="foot" target="#foot_9">27</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Static relations</head><p>In general, relation symbols may correspond to intentional relationships holding among individuals. However, many fundamental relations are extensional in that, at every index point, whether the relation holds of some tuple of individuals depends only on the entities denoted by the individuals at the particular state corresponding to that index point. In other words the truth of these relations depends on the actual state of the world. We thus refer to them as static relations. Amongst the static relations are all spatial relations and most other physical properties. An example of a non-static relation is 'is-approaching(a, b)'.</p><p>A static predicate ϕ(x) satisfies the following axiom schema, which means that only extensional equivalence (rather than necessary identity) is required for substitution into ϕ(x).</p><formula xml:id="formula_52">(C1) (ϕ(α) ∧ (α = β)) → ϕ(β).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.">Subjective event-types</head><p>Normally the meaning of an event-type expression is objective in that whatever possible world it is evaluated at, it denotes the same set of episodes. However, within the intensional language of VEL it is possible to define subjective event-types whose denotation is not constant. For instance we might define a type consisting of all accidents that take place during 'the next snow storm'. Since 'the next snow storm' varies according where we are in a VEL frame, any event-type defined in terms of a phrase such as this would be subjective.</p><p>Subjective event-types do not correspond to events in the ordinary sense but they arise inevitably within a sufficiently rich intensional language. Most events which one will want to talk about are not subjective and satisfy: (C2) Holds-at((∀e, ε)ϕ, t) ↔ (∀e, ε)Holds-at(ϕ, t). (C3) (∀s 1 , s 2 )[♦(e : s 1 ⇒ s 2 ) → (e : s 1 ⇒ s 2 )].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.">Verbs of direct participation</head><p>Participation in many verbs is determined completely by the static properties exemplified by individuals during the period over which the events corresponding to that verb occur. In the place of an individual argument α of such a verb we can substitute any other individual which is co-realised by α at all indices during the episode over which the event occurs. For instance if a ship burns then the quantity of wood co-realised with that ship also burns. More generally, this concept of direct participation can be attributed to a particular argument place within an expression describing a dynamic property. This is enforced by constraints of the form:</p><formula xml:id="formula_53">(C4) (Occurs(v(α), δ) ∧ (∀t)[(b(δ) t e(δ))</formula><p>→ Holds-at(α = β, t)]) → Occurs(v(β), δ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Relation to other AI theories</head><p>We now look at how two established AI theories of events can be described within VEL. It is worth noting that, despite the expressiveness of VEL, we encountered considerable difficulty in arriving at reasonable formulations. Because AI theories are oriented towards achieving certain reasoning tasks, they employ abstractions of the structure of time and events that are geared to achieving a compromise between expressivity and computational tractability. But how to spell out the nature of these abstractions relative to the very general model structures provided by VEL is not always obvious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1.">Situation Calculus</head><p>The Situation Calculus <ref type="bibr" target="#b34">[35]</ref> is a very well-known and influential representation for actions. The basic idea of this system is to use a language which contains, in addition to propositional expressions (fluents), variables over a domain of situations. Fluents are related to situations by the special relation Holds(ϕ, s). Action types are then modelled as functions from situations to situations. More specifically, if a is an action type, then result(a, s) is a term denoting the situation which occurs immediately after action a is performed in situation s.</p><p>Let us look at how the Situation Calculus could be interpreted within VEL. Our formalism already has situation variables and McCarthy's Holds predicate corresponds very closely to our Holds-in predicate. The only problem is the result function. The Situation Calculus is based on an assumption that when an action is performed in a given state then a unique state will result; but within our model of states and events there may be many different situations which could be the result of a given action because any given event-type can occur in various different ways.</p><p>We have the option of simply introducing sit-calc-actions into VEL as functions from states to states (possibly with additional parameters). We could then reconstruct Situation Calculus faithfully within VEL. However, this leaves completely unconstrained the relationship between sit-calc-actions and the verbs, event-types and event-tokens already provided by VEL. But we ought to have some strong connection between sit-calcactions and event-types.</p><p>A drastic solution is to force all VEL events to have a unique result state by adding a further axiom:</p><p>(A40) e AS(s) → [e]AS(s).</p><p>We could then identify sit-calc-actions directly with event-types. However, this would severely restrict the generality of our framework. In particular it would mean that we could no longer define event-types in terms of arbitrary conditions on the time intervals over which they occur.</p><p>A similar but more subtle approach is to treat Situation Calculus actions as a special subtype of VEL events for which (A40) holds. Thus rather than adopting (A40) as a general axiom, we would have a specific constraining formula sca i AS(s) → [sca i ]AS(s) for each sit-calc-action sca i . So, only the sit-calc-actions would be constrained to correspond to deterministic events.</p><p>At first consideration it may seem that, within the branching time structure of VEL, it would make little sense to simply deem certain event-types to be deterministic. However, since event-types are semantically identified with classes of episodes, any event-type must have at least one deterministic sub-type. Moreover, many modes of reasoning in terms of arbitrary event-types can be shown to be reducible to equivalent forms of reasoning with deterministic event-types. For instance, whenever there is a consecutive series of intervals δ 1 , . . . , δ n , satisfying a sequence of event types e 1 , . . . , e n , the same series of intervals must satisfy a sequence of deterministic event-types e 1 , . . . , e n , such that each e i ⊆ e i . So, to find whether a given goal can be achieved by a series of events, we need only consider whether it can be achieved by a series of deterministic events. Also, effect axioms for non-deterministic event-types, which constrain the states of all their possible outcomes, will clearly apply equally to any deterministic sub-types of those events. Thus, confining attention to deterministic events can often be a very useful simplifying abstraction of the space of possible event sequences. This is perhaps a reason for the power of the Situation Calculus ontology. However, we believe that allowing non-deterministic events provides for much more flexible modelling of parallel event sequences, especially where we do not wish to impose any fixed synchronisation between parallel events.</p><p>Another approach to representing the Situation Calculus, which may also be more appropriate in some cases, is to recast the function result as a kind of quantifier over possible resulting states. Thus rather than writing Φ(result(e)) (where Φ(. . .) is any VEL predicate that can take a state variable as argument) we would use the form (result e, s)[Φ(s)], where (result e, s)[Φ(s)] ≡ def (∀s )[(e : s ⇒ s ) → Φ(s )]. By using this transform, axioms which make sense under a deterministic model of action, can be transformed into analogous axioms which hold in a branching model that allows an occurrence of a given event-type occurring in a given state to lead to multiple possible outcome states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2.">Event calculus</head><p>Another formalism that has been used for describing and reasoning about actions and events is the Event Calculus <ref type="bibr" target="#b31">[32]</ref>. An account of this calculus and its variants can be found in <ref type="bibr" target="#b43">[44]</ref>. At the heart of the Event Calculus is a principle of inertia: if an event causes some 'fluent' (i.e., proposition) to hold, then it will continue to hold until some later event causes it to become false. This idea can be formalised by the following basic axioms of Event Calculus: <ref type="foot" target="#foot_10">28</ref>(EC1)</p><formula xml:id="formula_54">Holds-at(ϕ, t 2 ) ← Happens(ε, t 1 ) ∧ Initiates(ε, ϕ, t 1 ) ∧ (t 1 &lt; t 2 ) ∧ ¬Clipped(t 1 , ϕ, t 2 ). (EC2) Clipped(t 1 , ϕ, t 2 ) ← Happens(ε, t) ∧ (t 1 &lt; t &lt; t 2 ) ∧ Terminates(ε, ϕ, t).</formula><p>The predicate Clipped is introduced primarily to achieve a Horn clause formulation. Since it is not normally employed except within these two axioms (whereas the other predicates will also occur in scenario descriptions) it can be eliminated to give an equivalent single axiom:</p><formula xml:id="formula_55">(EC) Holds-at(ϕ, t 2 ) ← Happens(ε, t 1 ) ∧ Initiates(ε, ϕ, t 1 ) ∧ (t 1 &lt; t 2 ) ∧ ¬∃ε [Happens(ε , t) ∧ (t 1 &lt; t &lt; t 2 ) ∧ Terminates(ε , ϕ, t)].</formula><p>Here we formulate the axiom as applying to event-tokens, although later versions of the Event Calculus often work in terms of event types. Direct representation of the analogous event-type axiom would not be possible in VEL because we do not allow quantification over event-types. <ref type="foot" target="#foot_11">29</ref> Nevertheless, although inertia is specified in terms of tokens, one can still express conditions on the Initiates and Terminates predicates in terms of eventtypes, and these conditions would be inherited by the tokens of these types. Thus we can equally well emulate Event Calculus style reasoning, in which a causal theory is formulated either in terms of event-types or tokens (or both if we wish). Moreover, at the end of this section we shall give an encoding of Event Calculus in terms of event-types, where we use schematic event-type variables instead of quantification.</p><p>Let us now define VEL analogues of the Event Calculus predicates. Holds-at can be represented directly by the VEL predicate of the same name. With the other predicates we meet a small problem, because the events of Event Calculus are normally taken as being punctual (happening at a single point in time), whereas VEL events can occur either over punctual or extended intervals. To account for this we could restrict the axiom to apply only to punctual events. However, a more general approach seems to be available. The Event Calculus reasons about cause and effect in terms of which fluents are made to hold or cease to hold immediately after an event. Hence, it is the end point of the event that is relevant to this kind of reasoning. So in our VEL encoding we shall define Happens, Initiates and Terminates by reference to the end points of the events involved: Since event-token quantification in VEL is always relative to an event-type we will also need a further definition to enable us to quantify over a type of generic event that occurs over every arbitrary interval. Thus we define: 30   (D41) any-event ≡ def δ : δ = δ .</p><p>Using our definitions EC can now be represented in VEL by the formula:</p><formula xml:id="formula_56">(VEL-EC) ∀any-event, ε [(Happens(ε, t 1 ) ∧ Initiates(ε, ϕ, t 1 ) ∧ ¬ ∃any-event, ε (∃t)[Happens(ε , t) ∧ (t 1 &lt; t &lt; t 2 ) ∧ Terminates(ε , ϕ, t)]) → Holds-at(ϕ, t 2 )].</formula><p>What is the status of this formula? Since it represents the basis of Event Calculus reasoning one might hope that it is valid within VEL. But as it stands it is not. The problem is that VEL allows the following counter-example to VEL-EC: ϕ might be initiated by some event at t 1 and remain true for all times t such that (t 1 &lt; t &lt; t 2 ) but then ϕ could still become false at t 2 .</p><p>The reason why (t 1 &lt; t &lt; t 2 ) works for the Event Calculus is that it treats fluents as holding over intervals that are open at their beginning and closed at their end. 31 We shall call such an interval a BOEC interval; and a proposition that only holds over such intervals 30 Note that tokens of any-event will be distinct form tokens of any more specific type, so in quantifying over any-event tokens we are not quantifying over arbitrary event-tokens. But, since our definitions of Happens, Initiates and Terminates only refer to the end times of event-tokens and the changes in proposition that occur after these times, whenever an event of a more specific type happens and initiates or terminates a proposition there will also be a token of any-event that happens at the same time and initiates/terminates the same proposition. Hence, cause and effect rules specified for tokens of more specific event-types will be mirrored by the occurrences of tokens of the generic any-event event-type. 31 To be more precise, this requirement only applies to those fluents that are initiated or terminated. It is these inertial fluents that are forced by the axioms to maintain a persistent truth value between initiating and terminating events. A dual interpretation, where the duration of inertial fluents is closed at the beginning and open at the end, is also possible.</p><p>will be called a BOEC proposition. When an event ε changes a proposition ϕ from true to false, ϕ is taken as remaining true up to the time at which the event 'Happen's and then becoming false for some BOEC interval immediately following the time of the event.</p><p>From an ontological viewpoint, the condition that propositions should be BOEC seems to us unnatural. In our view, whether a proposition holds over an open or a closed interval is not an arbitrary modelling decision, but is determined by the meaning of the proposition. For instance a state of 'connectedness' between two objects that can move continuously in space can hold only over closed intervals, because the distance d t (a, b) between objects a and b at time t must be a continuous function of time. Thus any interval over which d t (a, b) = 0 must be closed. Similarly, 'disconnectedness' between a and b occurs over intervals where d t (a, b) &gt; 0, and these must be open.</p><p>Nevertheless, if one is interested in implementing practical reasoning algorithms, we accept that there may be good reasons to describe the world using BOEC propositions. In many cases one can get round the limitations of the BOEC requirement by adjusting the meanings of non-BOEC propositions to get a closely related BOEC version. For example, one can use a modified version of 'connectedness', C (x, y), which is true at a time point t just in case x and y were connected throughout some open interval immediately preceding t (i.e., C (x, y) ≡ def C(x, y)). There would still be a problem representing propositions that hold for an isolated instant (e.g., a thrown ball being at the apex of its trajectory). However, in richer versions of the Event Calculus, which have been developed to take account of continuously varying fluents, additional apparatus is used which can represent propositions that are true at instants or over closed intervals (e.g., by the use of a 'Trajectory' predicate as proposed in <ref type="bibr" target="#b42">[43]</ref> and further developed in <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b44">45]</ref>).</p><p>In VEL we can easily define a propositional operator 'BOEC', such that BOEC(ϕ) is true just in case ϕ is BOEC: 32   (D42) BOEC(ϕ) ≡ def ((ϕ → ϕ) ∧ (¬ϕ → ¬ϕ)).</p><p>We can now take the basis of Event Calculus reasoning as being represented by the VEL axiom (BOEC(ϕ) → VEL-EC), which can be shown to be valid according to the VEL semantics.</p><p>An alternative approach to representing Event Calculus within VEL would be to weaken VEL-EC by replacing (t 1 &lt; t &lt; t 2 ) by (t 1 &lt; t t 2 ). This would mean that some modification would be required in the reasoning mechanisms that are usually applied to compute inferences in Event Calculus, but we see no reason why this should not be feasible.</p><p>The two alternatives correspond to the following slight modifications of VEL-EC, each of which is valid in VEL:</p><p>(VEL-EC1) BOEC(ϕ) → ∀any-event, ε [(Happens(ε, t 1 ) ∧ Initiates(ε, ϕ, t 1 ) ∧ ¬ ∃any-event, ε (∃t)[Happens(ε , t) ∧ (t 1 &lt; t &lt; t 2 ) ∧ Terminates(ε , ϕ, t)]) → Holds-at(ϕ, t 2 )]. 32 This definition also implies that ϕ cannot undergo the pathological intermingling behaviour that was considered in Section 2.8. Thus, where we restrict to BOEC propositions, we do not need to enforce axioms (A19) and (A20).</p><p>(VEL-EC2) ∀any-event, ε [(Happens(ε, t 1 ) ∧ Initiates(ε, ϕ, t 1 ) ∧ ¬ ∃any-event, ε (∃t)[Happens(ε , t) ∧ (t 1 &lt; t t 2 ) ∧ Terminates(ε , ϕ, t)]) → Holds-at(ϕ, t 2 )].</p><p>We conclude this section by showing how each of VEL-EC1 and VEL-EC2 can be transformed back into a Horn clause formulation which is very close to published formats of the Event Calculus (e.g., <ref type="bibr" target="#b44">[45]</ref>). First we shall define Clipped &lt; and Clipped as follows:</p><p>(D43) We could use either VEL-EC-HS1 with Cl1 or VEL-EC-HS2 with Cl2 as the basis of an inference procedure, which would work in much the same way as existing Event Calculus implementations (e.g., SLD resolution with negation as failure). This means that an Event Calculus inference engine could be used as a reasoning module for VEL. Of course it would be limited to computing inferences from sets of VEL formulae that are expressed in form analogous to an Event Calculus theory. Also, if negation as failure is used to resolve the negated Clipped literals, one would be importing an additional non-monotonic inference rule into the VEL logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusion</head><p>We have given a precise formal semantics for a very expressive temporal language (VEL), which is capable of describing events in a variety of different ways. In particular it incorporates within a single system several of the most influential approaches to representing time and events. The framework provides a general temporal ontology within which more practically oriented representations can be interpreted. It also supports the design of modular reasoning systems combining decision procedures for tractable sublanguages of VEL.</p><p>In further work we hope to establish a complete axiom system for VEL and to relate our system to formalisms such as CTL * <ref type="bibr" target="#b12">[13]</ref>, whose computational properties are better understood <ref type="bibr" target="#b13">[14]</ref>. We would also like to explore how VEL might take account of issues such as the frame problem and how it relates to non-monotonic formalisms that deal with this.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>We may also want to compare event-types. The relation e 1 e 2 means that e 1 is a sub-type of e 2 , and e 1 ≡ e 2 means that e 1 and e 2 are equivalent: (D16) e 1 e 2 ≡ def (∀δ)[Occurs(e 1 , δ) → Occurs(e 2 , δ)]. (D17) e 1 ≡ e 2 ≡ def (e 1 e 2 ) ∧ (e 2 e 1 ). We can also define event modalities analogous to those used in dynamic logic: (D18) [e]ϕ ≡ def * (∀δ)[(AT(b(δ)) ∧ Occurs(e, δ)) → Holds-at(ϕ, e(δ))]]. (D19) e ϕ ≡ def ♦ * (∃δ)[AT(b(δ) ∧ ∧Occurs(e, δ) ∧ Holds-at(ϕ, e(δ))]].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>D35) Happens(ε, τ ) ≡ def (τ = e(dur(ε))). (D36) Initiates(ε, ϕ, τ ) ≡ def (τ = e(dur(ε)) ∧ Holds-at( ϕ, τ )). (D37) Terminates(ε, ϕ, τ ) ≡ def Initiates(ε, ¬ϕ, τ ). In order to specify what happens and the effects of initiation and termination in terms of event-types we could use the following defined predicates: (D38) Happens * (e, τ ) ≡ def ∃δ[Occurs(e, δ) ∧ e(δ) = τ ]. (D39) Initiates * (e, ϕ) ≡ def ( ∀e, ε [∀t[(e(dur(ε)) = t) → Initiates(ε, ϕ, t)]]). (D40) Terminates * (e, ϕ) ≡ def Initiates * (e, ¬ϕ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Clipped &lt; (t 1 , ϕ, t 2 ) ≡ def ∃any-event, ε [Happens(ε, t) ∧ (t 1 &lt; t &lt; t 2 ) ∧ Terminates(ε, ϕ, t)]. (D44) Clipped (t 1 , ϕ, t 2 ) ≡ def ∃any-event, ε [Happens(ε, t) ∧ (t 1 &lt; t t 2 ) ∧ Terminates(ε, ϕ, t)].From this it is easy to show that the following schematic Horn formulae are valid, where e stands for any event-type:(Cl1) Clipped &lt; (t 1 , ϕ, t 2 ) ← Happens * (e, t) ∧ (t 1 &lt; t &lt; t 2 ) ∧ Terminates * (e, ϕ, t). (Cl2) Clipped (t 1 , ϕ, t 2 ) ← Happens * (e, t) ∧ (t 1 &lt; t t 2 ) ∧ Terminates * (e, ϕ, t). If we substitute Clipped &lt; and Clipped respectively into VEL-EC1 and VEL-EC2, from the resulting formulae we can prove the following Horn schemas: (VEL-EC-HS1) Holds-at(ϕ, t 2 ) ← BOEC(ϕ) ∧ Happens * (e, t 1 ) ∧ Initiates * (e, ϕ, t 1 ) ∧ ¬Clipped &lt; (t 1 , ϕ, t 2 ). (VEL-EC-HS2) Holds-at(ϕ, t 2 ) ← Happens * (e, t 1 ) ∧ Initiates * (e, ϕ, t 1 ) ∧ ¬Clipped (t 1 , ϕ, t 2 ).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>It can be argued that any language which is sufficiently expressive to describe a variety of different possible models of causation must itself be to some degree neutral about the nature of causation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>In this setting we could not, as we do in VEL, define in terms of * and Holds-at; we would have to define it in terms of quantification over states.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Clearly, identical event-tokens must participate in the same causal relationships. Davidson<ref type="bibr" target="#b9">[10]</ref> proposed that, conversely, causal equivalence is a sufficient condition for the identity of event tokens. But our argument does not depend on this stronger claim.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>However, if we were to weaken the conditions SconfP and Gclock, so that the same state could occur at</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_4"><p>Here we take P and F as referring strictly to the past and future, whereas some logics use weaker tense operators such that whenever ϕ is true Pϕ and Fϕ are also true.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_5"><p>Note, that according to this definition, if δ is punctual no proposition Holds-on δ.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_6"><p>The expression ϕ has the same meaning as the 'po ϕ' construct introduced in<ref type="bibr" target="#b15">[16]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_7"><p>If we were to weaken the SconfP and Gclock constraints on history trees, other definitions of Holds-in might be more natural.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="26" xml:id="foot_8"><p>Expressed in terms of the defined Occurs relation, (A36) becomes ϕ(δ) ↔ Occurs( δ : ϕ(δ ) , δ). And from this it is easy to prove that (e ≡ δ : ϕ(δ) ) ↔ ∀δ[ϕ(δ) ↔ Occurs(e, δ)].</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="27" xml:id="foot_9"><p>Originally we attempted to build such constraints into the actual semantics of VEL but we found that this was incompatible with the definitional capabilities of the language.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="28" xml:id="foot_10"><p>These are the axioms given for the 'Simplified Event Calculus' of Shanahan[44, p. 252].</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="29" xml:id="foot_11"><p>Of course we could add event-type quantification, but this would have a second-order character, which we would like to avoid.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We plan to extend VEL to incorporate the representation of space and matter. Preliminary work on describing physical processes <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> suggests that VEL is well suited to this purpose. It would also be useful to establish the relationship of the VEL semantics to ontologies based on four-dimensional spatio-temporal regions <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b29">30]</ref>.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>URL: http://www.comp.leeds.ac.uk/brandon(B. Bennett). <ref type="bibr" target="#b0">1</ref> Supported by the EPSRC under grants GR/M56807 and GR/N13159.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(R3) If (ϕ → ψ) then (ϕ → ∀ν[ψ]), provided ν is not free in ϕ. (A5) ∀ν[ϕ] → ϕ ν ν .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.4.">Temporal logic</head><p>The temporal logic obeys the following inference rule and axioms:</p><p>(R4) If ϕ then Holds-at(ϕ, t). (A6) (t t ∧ t t ) → t t . (A7) t t ∨ t t. (A8) (t t ∧ t t) ↔ t = t . (A9) (Holds-at(ϕ, t) ∧ Holds-at(ϕ → ψ, t)) → Holds-at(ψ, t). (A10) ¬Holds-at(ϕ ∧ ¬ϕ, t). (A11) Holds-at(ϕ, t) ∨ Holds-at(¬ϕ, t). (A12) Holds-at(ϕ, t) ↔ Holds-at(Holds-at(ϕ, t), t ). (A13) t t ↔ Holds-at((t t ), t ). (A14) ∀t[Holds-at(ϕ, t )] → Holds-at(∀t[ϕ], t ).</p><p>Axioms (A6)-(A8) constrain the temporal comparison to satisfy the usual axioms for a total linear order. (A9) and (A10) ensure that the set of formulae holding at each time point is closed under implication and consistent. (A11) ensures that, for every proposition ϕ, at each time point either ϕ or ¬ϕ holds. (A14) means that time quantification commutes with the Holds-at(. . . , t) construct. Finally, axioms (A15)-(A17) give essential properties of the AT(t) predicate.</p><p>The temporal axioms given so far constrain time to be an arbitrary linear order. For applications in ontological modelling of physical processes there are strong arguments for requiring that time be dense (see, e.g., <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b21">22]</ref>). This can easily be ensured by adding the axiom: 18</p><p>To ensure that the truth values of propositions do not fluctuate infinitely often in a finite period of time we also impose the following axioms, which can be concisely expressed using the and operators: (A19) ϕ ∨ ¬ϕ. (A20) ϕ ∨ ¬ϕ. 18 One might also want time to be continuous; but this requires a second-order axiom and doesn't seem to be necessary for most applications.</p><p>These say that at each time point any proposition has a constant truth value during some open interval immediately following that point and also during some open interval immediately preceding the point. 19   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.5.">The * operator</head><p>The * operator satisfies the following proof rule and axioms: 20</p><p>(R5) is the rule of necessitation and axioms (A21)-(A23) are the standard modal schemata K, T and 5. Thus * is an S5 modal operator. Axioms (A24) and (A25) ensure that the actual time and all temporal inequalities are the same for alternative histories. Finally, (A26) captures the interaction between * and the Holds-at(ϕ, t) construct, arising from the fact that all historical alternatives at a given time share a common history up to that time. 21   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.6.">Intervals</head><p>The b and e functions obey the following axioms, which ensure that the beginning of an interval cannot come after its end and that there is a unique interval determined by every two time points: 19 These axioms are not equivalent: for example, in real-number time, if ϕ is true on the intervals (2 -2n , 2 -2n+1) ) (for n = 1, 2, 3, . . .) and at no other times, then (A20) holds throughout but (A19) is false at t = 0. If the temporal theory were combined with a theory of physical reality, it is possible that these axioms might be derivable from basic continuity properties of physical change. 20 These axioms were inspired by a set given by Thomason <ref type="bibr" target="#b46">[47]</ref> and attributed to Kamp <ref type="bibr" target="#b30">[31]</ref> for a logic whose models are similar to but somewhat less constrained than our history trees. Kamp found that his axioms were incomplete relative to his intended models, because they do not support inferences dependent on temporal interpolations involving more than one history; however, we believe that our explicit axiomatisation of a time structure shared by all histories circumvents this problem. 21 Since * is an S5 modality one can derive both the Barcan formula and the converse Barcan formula for * with respect to time quantification-i.e., we have the theorem ∀t[ * ϕ] ↔ * ∀t[ϕ].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.7.">Count nouns</head><p>To specify the logic of count nouns we use a proof rule and axioms which are a simplification of those given by Gupta <ref type="bibr" target="#b23">[24]</ref>. 22 Count noun quantification obeys the rule: 23   (R6) If ϕ → ψ then ϕ → (∀C, x)[ψ], provided x is not free in ϕ as well as the axioms:</p><p>Rule (R6) and axiom (A30) provide a standard basis for quantification theory, with the slight modification that the substitutions allowed by (A30) are restricted to individuals falling under the appropriate count noun. Axiom (A31) specifies a connection between count noun quantification and necessary identity. 24 (A32) ensures that the null entity does not belong to the domain of any count noun.</p><p>Gupta also motivates the adoption of the following count noun separation axiom, 25 which we may want to impose, although it is not actually necessitated by the model theory given for VEL. The axiom enforces the condition that if the same count noun applies (or possibly applies) to each of two co-realised, non-null individuals, then those individuals must be identical (i.e., co-realised at all worlds). Equivalently, if two individuals are corealised but not identical then they must be individuals of different categories, having different identity and persistence criteria (e.g., a pot and a lump of clay):</p><p>We also add the axiom (A34), which enforces the condition that the individuals falling under a count noun (at the index point where it is evaluated) must have a non-empty extension (at that index).</p><p>(A34) (∀C, x)[¬(x = null)]. 22 The only substantial difference is that we (in (A2)) always require necessary identity to permit substitutions, whereas Gupta allows extensionally equivalent individual variables to be substituted into contexts that are not within the scope of a modal operator. This is because our semantics allows atomic relations and verbs to be intensional, so no context can be guaranteed transparent by considering its syntax alone. 23 Actually Gupta uses the weaker proof rule: if ϕ then (∀C, x)[ψ]; and adds the further axioms ((∀C, x)(ϕ → ψ) ∧ (∀C, x)ϕ) → (∀C, x)ψ and ϕ → (∀C, x)ϕ, provided x is not free in ϕ. Together these are equivalent to our stronger proof rule. 24 Recall that C[x] ≡ def (∃C, x )[ (x = x )]. Gupta says that this axiom may not be independent of the others but we have not been able to derive it. 25 We actually use Gupta's AS13 * , the weaker of two separation axioms that he considers.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An interval-based representation of temporal knowledge</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Allen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IJCAI-81</title>
		<meeting>IJCAI-81<address><addrLine>Vancouver, BC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="221" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Towards a general theory of action and time</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Allen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="123" to="154" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Nonmonotonic reasoning in the framework of the situation calculus</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence (Special Issue on Knowledge Representation)</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="5" to="23" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Pnueli, A really abstract concurrent model and its fully abstract semantics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kuiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM Symposium on Principles of Programming Languages (POPL)</title>
		<meeting>the 13th ACM Symposium on Principles of Programming Languages (POPL)<address><addrLine>St. Petersburg Beach, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="173" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Bennett</surname></persName>
		</author>
		<title level="m">Proceedings of the 2nd International Conference on Formal Ontology in Information Systems (FOIS&apos;01)</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Welty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Smith</surname></persName>
		</editor>
		<meeting>the 2nd International Conference on Formal Ontology in Information Systems (FOIS&apos;01)<address><addrLine>Ogunquit</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="105" to="116" />
		</imprint>
	</monogr>
	<note>Space, time, matter and things</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Bennett</surname></persName>
		</author>
		<title level="m">Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002)</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Fensel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M.-A</forename><surname>Williams</surname></persName>
		</editor>
		<meeting>the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002)<address><addrLine>Toulouse, France; San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Physical objects, identity and vagueness</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A logic of branching histories with a shared linear time series</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bennett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations and Applications of Spatio-Temporal Reasoning (FASTR), AAAI Spring Symposium</title>
		<meeting><address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Frame Problem in Artificial Intelligence</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1987 Workshop</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Brown</surname></persName>
		</editor>
		<meeting>the 1987 Workshop<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The logical form of action sentences</title>
		<author>
			<persName><forename type="first">D</forename><surname>Davidson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Essays on Actions and Events</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Rescher</surname></persName>
		</editor>
		<meeting><address><addrLine>Pittsburgh, PA; Pittsburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1967">1967. 1980</date>
		</imprint>
	</monogr>
	<note>The Logic of Decision and Action</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The individuation of events</title>
		<author>
			<persName><forename type="first">D</forename><surname>Davidson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Essays in Honor of Carl G. Hempel, D. Reidel, 1969, reprinted in: Essays on Actions and Events</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Rescher</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Davis</surname></persName>
		</author>
		<title level="m">Representations of Commonsense Knowledge</title>
		<meeting><address><addrLine>San Mateo, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Infinite loops in finite time: Some observations</title>
		<author>
			<persName><forename type="first">E</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference, Principles of Knowledge Representation and Reasoning (KR&apos;92)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Nebel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Rich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Swartout</surname></persName>
		</editor>
		<meeting>the Third International Conference, Principles of Knowledge Representation and Reasoning (KR&apos;92)<address><addrLine>Cambridge, MA, Morgan Kaufmann, San Mateo, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="47" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sometimes&apos; and &apos;not never&apos; revisited: On branching time versus linear time temporal logics</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="151" to="178" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The complexity of tree automata and logics of programs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="132" to="158" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">STRIPS: A new approach to the application of theorem proving to problem solving</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Nilsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="189" to="208" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
		<title level="m">The Logic of Aspect: An Axiomatic Approach</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Clarendon Press</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The logic of occurrence</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Temporal Logics and their Applications</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</editor>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="169" to="196" />
		</imprint>
	</monogr>
	<note>Chapter 5</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Towards an integrated logic of space, time and motion</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IJCAI-93</title>
		<meeting>IJCAI-93<address><addrLine>Chambéry, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An investigation of &apos;non-intermingling&apos; principles in temporal logic</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="271" to="294" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
		<title level="m">Spatial and Temporal Reasoning</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Stock</surname></persName>
		</editor>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="321" to="352" />
		</imprint>
	</monogr>
	<note>Space, time and movement. Chapter 10</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Qualitative Spatial Change</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Oxford University Press</publisher>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Transitions in continuous time, with an application to qualitative changes in spatial relations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Galton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference on Temporal Logic, Advances in Temporal Logic, ICTL&apos;97</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</editor>
		<meeting>the Second International Conference on Temporal Logic, Advances in Temporal Logic, ICTL&apos;97<address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="279" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Guarino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference, Formal Ontology in Information Systems (FOIS-98)</title>
		<meeting>the 1st International Conference, Formal Ontology in Information Systems (FOIS-98)<address><addrLine>Trento, Italy; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">46</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<title level="m">The Logic of Common Nouns: An Investigation in Quantified Modal Logic</title>
		<meeting><address><addrLine>New Haven, CT</addrLine></address></meeting>
		<imprint>
			<publisher>Yale University Press</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Default reasoning, nonmonotonic logics, and the frame problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hanks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcdermott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI-86</title>
		<meeting>AAAI-86<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="328" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dynamic Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Philosophical Logic</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Guenthner</surname></persName>
		</editor>
		<meeting><address><addrLine>Reidel, Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Extensions of Classical Logic</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="497" to="604" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The frame problem and related problems in artificial intelligence</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial and Human Thinking</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Elithorn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Jones</surname></persName>
		</editor>
		<meeting><address><addrLine>San Fransisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="495" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Qualitative spatio-temporal continuity</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Hazarika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Cohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Spatial Information Theory: Foundations of Geographic Information Science; Proceedings of COSIT&apos;01</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Montello</surname></persName>
		</editor>
		<meeting><address><addrLine>Morro Bay, CA; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2205</biblScope>
			<biblScope unit="page" from="92" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</author>
		<title level="m">Expert Systems in the Micro-Electronic Age</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<meeting><address><addrLine>Edinburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Edinburgh University Press</publisher>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
	<note>The naïve physics manifesto</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">The Ontology of Physical Objects: Four Dimensional Hunks of Matter</title>
		<author>
			<persName><forename type="first">M</forename><surname>Heller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">The logic of historical necessity, part I, Unpublished typescript</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kamp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A logic-based calculus of events</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sergot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Gen. Comput</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="67" to="95" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Lehmann</surname></persName>
		</author>
		<title level="m">Semantic Networks in Artificial Intelligence</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Pergamon Press</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">CYC: A large-scale investment in knowledge infrastructure</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Some philosophical problems from the standpoint of artificial intelligence</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meltzer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<meeting><address><addrLine>Edinburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Edinburgh University Press</publisher>
			<date type="published" when="1969">1969</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="463" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A temporal logic for reasoning about processes and plans</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mcdermott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive Sci</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="101" to="155" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Logics for Concurrency: Structure versus Automata</title>
		<title level="s">Lecture Notes in Compute. Sci.</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Moller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Birtwistle</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1043</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">On the expressive power of CTL *</title>
		<author>
			<persName><forename type="first">F</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rabinovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LICS&apos;99: Logic in Computer Science</title>
		<meeting>LICS&apos;99: Logic in Computer Science<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">English as a formal language</title>
		<author>
			<persName><forename type="first">R</forename><surname>Montague</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Philosophy: Selected Papers of Richard Montague</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Thomason</surname></persName>
		</editor>
		<meeting><address><addrLine>New Haven, CT</addrLine></address></meeting>
		<imprint>
			<publisher>Yale University Press</publisher>
			<date type="published" when="1970">1970. 1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Universal grammar</title>
		<author>
			<persName><forename type="first">R</forename><surname>Montague</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Philosophy: Selected Papers of Richard Montague</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Thomason</surname></persName>
		</editor>
		<meeting><address><addrLine>New Haven, CT</addrLine></address></meeting>
		<imprint>
			<publisher>Yale University Press</publisher>
			<date type="published" when="1970">1970. 1970</date>
			<biblScope unit="page" from="153" to="167" />
		</imprint>
	</monogr>
	<note>Reprinted in</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A spatial logic based on regions and connection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Randell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Internat. Conf. on Knowledge Representation and Reasoning</title>
		<meeting>3rd Internat. Conf. on Knowledge Representation and Reasoning<address><addrLine>San Mateo, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="165" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Sandewall</surname></persName>
		</author>
		<title level="m">Features and Fluents</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Representing continuous change in the event calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th European Conference on Artificial Intelligence (ECAI-90)</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Aiello</surname></persName>
		</editor>
		<meeting>the 9th European Conference on Artificial Intelligence (ECAI-90)<address><addrLine>Stockholm, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="598" to="603" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Intertia</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shanahan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The event calculus explained</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence Today</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Wooldridge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Veloso</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1600</biblScope>
			<biblScope unit="page" from="409" to="430" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Time for action: On the relation between time, knowledge and action</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shoham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IJCAI-89</title>
		<meeting>the IJCAI-89<address><addrLine>Detroit, MI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="954" to="959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Thomason</surname></persName>
		</author>
		<title level="m">Combinations of tense and modality</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Guenthner</surname></persName>
		</editor>
		<meeting><address><addrLine>Sweden</addrLine></address></meeting>
		<imprint>
			<publisher>Reidel</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="135" to="165" />
		</imprint>
	</monogr>
	<note>Handbook of Philosophical Logic. Chapter 3</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
