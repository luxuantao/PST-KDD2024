<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Transformations of CLP modules</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sandro</forename><surname>Etalle</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Universit5 di Genova</orgName>
								<address>
									<addrLine>Via Dodecaneso 35</addrLine>
									<postBox>D.I.S.L</postBox>
									<postCode>16146</postCode>
									<settlement>Genova</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Maurizio</forename><surname>Gabbrielli B'</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dipartimento di Informatica</orgName>
								<orgName type="institution">Universith di Pisa</orgName>
								<address>
									<addrLine>Corso Italia 40</addrLine>
									<postCode>56125</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Transformations of CLP modules</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8E4F0DCD912A0C10C2298CBAD16B605F</idno>
					<note type="submission">Received January 1995; revised August 1995 Communicated by G. Levi</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a transformation system for Constraint Logic Programming (CLP) programs and modules. The framework is inspired by the one of <ref type="bibr" target="#b36">Tamaki and Sato (1984)</ref> for pure logic programs. However, the use of CLP allows us to introduce some new operations such as splitting and constraint replacement. We provide two sets of applicability conditions. The first one guarantees that the original and the transformed programs have the same computational behaviour, in terms of answer constraints. The second set contains more restrictive conditions that ensure compositional#y: we prove that under these conditions the original and the transformed modules have the same answer constraints also when they are composed with other modules. This result is proved by first introducing a new formulation, in terms of trees, of a resultants semantics for CLP. As corollaries we obtain the correctness of both the modular and the nonmodular system w.r.t, the least model semantics.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>As shown by a number of applications, programs transformation is a powerful methodology for the development and optimization of large programs. In this field, the unfold/fold transformation rules were first introduced by Burstall and Darlington <ref type="bibr" target="#b8">[9]</ref> for transforming declaratively clear functional programs into equivalent, more complex and efficient ones, and then adapted to logic programs both for program synthesis <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17]</ref>, and for program specialization and optimization <ref type="bibr" target="#b24">[25]</ref>. Soon later, Tamaki and Sato <ref type="bibr" target="#b36">[37]</ref> proposed an elegant framework for the transformation of logic programs based "~ This work has been carried out while both the authors were visiting the Centrum voor Wiskunde en Informatica (CWI), Amsterdam, The Netherlands. The research of the first author has been partially supported by the ERCIM Fellowship Program. The research of the second author has been supported by the EC/HCM network EUROFOCS under grant n. ERBCHBGCT930496. A preliminary, shorter version of this paper appeared as <ref type="bibr" target="#b10">[11]</ref>. on unfold/fold rules. Their system was proven to be correct w.r.t, the least Herbrand model semantics <ref type="bibr" target="#b36">[37]</ref> and the computed answer substitution semantics <ref type="bibr" target="#b23">[24]</ref>.</p><p>The system was then extended by Seki <ref type="bibr" target="#b33">[34]</ref> to logic programs with negation, in particular he provided new, more restrictive applicability conditions which guarantee that the system preserves also the finite failure set and the perfect model semantics of stratified programs. Since then serious research effort has been devoted to proving its correctness w.r.t, the various semantics available for normal programs. For instance, the new system was then adapted by Sato to full first-order programs <ref type="bibr" target="#b32">[33]</ref>. Related work has been done by Maher <ref type="bibr" target="#b28">[29]</ref>, Gardner and Shepherdson <ref type="bibr" target="#b15">[16]</ref>, Aravidan and Dung <ref type="bibr" target="#b1">[2]</ref>, Seki <ref type="bibr" target="#b34">[35]</ref>, Bossi and Cocco <ref type="bibr" target="#b4">[5]</ref> and Bensaou and Guessarian <ref type="bibr" target="#b2">[3]</ref>. Among these papers only <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b28">29]</ref> treated the case of Constrain Logic Programming. We defer to Section 7 a comparison of these approaches with ours.</p><p>All the (unfold/fold) transformation systems proposed so far for logic programming and for CLP, with the only exception of <ref type="bibr" target="#b28">[29]</ref>, assume that the entire program is available at the time of transformation. This is often an unpractical assumption, either because not all program components have been defined, or because for handling the complexity a large program has been broken into several smaller modules. Indeed, the incremental and modular design is by now a well-established software-engineering methodology which helps to verify and maintain large applications. Modularity has received a considerable attention also in the field of logic programming, as the recent survey <ref type="bibr" target="#b7">[8]</ref> shows.</p><p>Adhering to the above mentioned methodology, we consider here CLP programs as a combination of separate modules. Each module partially defines some predicates, and different modules are combined together by a simple composition operator which essentially consists of union of program clauses. Now, a transformation system for modules requires ad-hoc applicability conditions: when we transform P into p1 we do not just want P and PI to have the same observable behaviour (e.g. the same answer constraints); we want them to have the same observable behaviour whatever the context in which they are employed.</p><p>When this condition is satisfied we say that P and U are observationally congruent.</p><p>In this paper, we develop a transformation system for the optimization of CLP modules. This is accomplished in two steps. First, we generalize the unfold/fold system of Tamaki and Sato <ref type="bibr" target="#b36">[37]</ref> to CLP programs. The full use of CLP allows us to introduce some new operations, such as splitting and constraint replacement, which broaden the range of possible optimizations. In this first part we also define new applicability conditions for the folding operation which avoid the use of substitutions and which are simpler than the ones used previously.</p><p>Afterwards, we define a (compositional) transformation system for modules. This is obtained by adding some further applicability conditions, which we prove sufficient to guarantee that the transformed module is observationally congruent to the original one. This system allows us to transform independently the components of an application, and then to combine together the results while preserving the original meaning of the program in terms of answer constraints. This is useful when a program is not completely specified in all its parts, as it allows us to optimize on the available modules. When a new module is added, we can just compose it (or its transformed version) with the already optimized parts, being sure that the composition of the transformed modules and the composition of the original ones have the same computational behaviour in terms of answer constraints.</p><p>This result is proved by using a new formulation, in terms of trees, of a resultants semantics which models answer constraints and is compositional w.r.t, union of programs. From a particular case of the main theorem it follows that the transformation system for non-modular programs also preserves the computational behaviour of programs. Finally, since the least model (on the relevant algebraic structure) can be seen as an abstraction of the compositional semantics, we obtain as a corollary that the least model is also preserved.</p><p>The paper is organized as follows. The next section contains some preliminaries on CLP programs. In Section 3 we introduce the notion of module and we formalize the resultants semantics for CLP by using trees. Section 4 provides the definition of the transformation system. In Section 5 we add the applicability conditions needed to obtain a modular system and we state the main correctness result. In Section 6 we show that the system of Tamaki-Sato can be embedded into ours. As a consequence, the conditions given in Section 5 can also be added to those defined in <ref type="bibr" target="#b36">[37]</ref> in order to obtain a modular unfold/fold system for pure logic programs. Section 7 concludes by comparing our results with those contained in two related works. The proof of the main technical result of the paper is deferred to the Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries: CLP programs</head><p>The Constraint Logic Programming paradigm CLP(X) (CLP for short) has been proposed by Jaffar and Lassez <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> in order to integrate a generic computational mechanism based on constraints with the logic programming framework. The advantages of such an integration are several. From a pragmatic point of view, CLP(JO allows one to use a specific constraints domain X and a related constraint solver within the declarative paradigm of logic programming. From the theoretical viewpoint, CLP provides a unified view of several extensions of pure logic programming (e.g. arithmetics, equational programming) within a framework which preserves the existence of equivalent operational, model-theoretic and fixpoint semantics <ref type="bibr" target="#b17">[18]</ref>. Indeed, as discussed in <ref type="bibr" target="#b28">[29]</ref>, most of the results which hold for pure logic programs can be lifted to CLP in a quite straightforward way.</p><p>The reader is assumed to be familiar with the terminology and the main results on the semantics of (constraint) logic programs. In this subsection we introduce some notations we will use in the sequel and, for the reader's convenience, we recall some basic notions on constraint logic programs. Lloyd's book and the survey by Apt <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b27">28]</ref> provide the necessary background material for logic programming theory. For constraint logic programs we refer to the original papers <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> by Jaffar and Lassez and to the recent survey <ref type="bibr" target="#b19">[20]</ref> by Jaffar and Maher.</p><p>The CLP framework was originally defined using a many-sorted first-order language. In this paper, to keep the notation simple, we consider a one sorted language (the extension of our results to the many sorted case is immediate). We assume programs defined on a signature with predicates 2; consisting of a pair of disjoint sets containing function symbols and predicate symbols. The set of predicate symbols, denoted by//, is assumed to be partitioned into two disjoint sets: Ho (containing predicate symbols used for constraints) which contains also the equality symbol "=", and//u (containing symbols for user definable predicates). All the following definitions will refer to some given S, He and Hu.</p><p>The notations ? and J2 will denote a tuple of terms and of distinct variables respectively, while/} will denote a (finite, possibly empty) conjunction of atoms. The connectives "," and [] will often be used instead of "A" to denote conjunction.</p><p>A primitive constraint is an atomic formula p(tl ..... tn) where the ti's are terms (built from 2; and a denumerable set of variables) and p E Ho. A constraint is a first order formula built using primitive constraints. A CLP rule is a formula of the form</p><formula xml:id="formula_0">H +--cDB1,...,Bn.</formula><p>where c is a constraint, H (the head) and B1 .... ,Bn (the body) are atomic formulas which use predicate symbols from Hu only. When the body is empty we will omit the connective a. A goal (or query), denoted by c:zB1 ..... Bn, is a conjunction of a constraint and atomic formulas as before. A CLP program is a finite set of CLP rules.</p><p>The semantics of CLP programs is based on the notion of structure. Given a signature with predicates S, a S-structure (structure for short) @ consists of a set (the domain) D and an assignment that maps function symbols in 2; and predicate symbols in Hc to fimctions and relations on D respecting arities.</p><p>A ~-interpretation is an assignment that maps each predicate symbol in Ha to a relation on the domain of the structure. A ~-interpretation I is called a ~-model of a CLP program P if all the clauses of P evaluate to true under the assignment of relations and function provided by I and by N. We recall that there exists <ref type="bibr" target="#b18">[19]</ref> the least ~model of a program P which is the natural CLP counterpart of the least Herbrand model for logic programs.</p><p>Given a structure ~ and a constraint c, @ ~ c denotes that c is true under the interpretation for constraints provided by ~. Moreover if 0 is a valuation (i.e. a mapping of variables on the domain D), and @ ~ cO holds, then 0 is called a ~-solution of c (cO denotes the application of 0 to the variables in e).</p><p>Here and in the sequel, given the atoms A, H, we write A = H as a shorthand for:</p><p>This notation readily extends to conjunctions of atoms. We also find convenient to use the notation 3_e ~b from <ref type="bibr" target="#b19">[20]</ref> to denote the existential closure of the formula q5 except for the variables 2 which remain unquantified.</p><p>The operational model of CLP is obtained from SLD resolution by simply substituting ~-solvability for unifiability. More precisely, a derivation step for a goal G : cobB1 .... ,Bn in the program P results in the goal CO A (B i = H) A cDB1 .... ,Bi-I,B, Bi+I .... ,Bn provided that B i is the atom selected by the selection rule and there exists a clause in P standardized apart (i.e. with no variables in common with G) H ~ c[]B such that</p><formula xml:id="formula_1">(co A (Bi = H) A e) is ~-satisfiable, that is, ~ ~ 3 (co A (B~ = H) A c).</formula><p>A derivation via a selection rule R of a goal G in the program P is a finite or infinite sequence of goals, starting in G, such that every next goal is obtained from the previous one by means of a derivation step where the atom is selected according to R. A derivation is successful if it is finite and its last element is a goal of the form c, i.e. consisting only of a constraint. In this case, 3-va,(a) c is called the answer constraint. I In what follows a derivation of a goal G whose last goal is Gi in the program P will be denoted by G~ G.</p><p>Finally, by naturally extending the usual notion used for pure logic programs, we say that a query csC is an instance of the query d_q) iff for any solution 7 of c there exists a solution 6 of d such that 6'7 -/)3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Modular CLP programs</head><p>Following the original paper of O'Keefe <ref type="bibr" target="#b30">[31]</ref>, the approach to modular programming we consider here is based on a metalinguistic program composition mechanism. This provides a formal background to the usual software engineering techniques for the incremental development of programs.</p><p>Viewing modularity in terms of metalinguistic operations on programs has several advantages. In fact it leads to the definition of a simple and powerful methodology for structuring programs which does not require to extend the CLP theory (this is not the case if one tries to extend CLP programs by linguistic mechanisms richer than those offered by clausal logic). Moreover, metalinguistic operations are quite powerful, indeed the typical mechanisms of the object-oriented paradigm, such as encapsulation and information hiding, can be realized by means of simple composition operators <ref type="bibr" target="#b3">[4]</ref>.</p><p>Here, in order to keep the presentation simple, we follow <ref type="bibr" target="#b5">[6]</ref> and say that a module M is a CLP program P together with a set Op(M) of predicate symbols specifying the open predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.1 (Module).</head><p>A CLP module M is a pair (P, Op(M)) where P is a CLP program and Op(M) is a set of predicate symbols.</p><p>The idea underlying the previous definition is that the open predicates, specified in Op(M), behave as an interface for composing M with other modules. The definition of open predicates could be partially given in M and further specified by importin9 it from other modules. Symmetrically, the definitions of open predicates may be exported and used by other modules. A typical practical example is a deductive database composed of two modules, in which the first one J contains the intensional part in the form of some rules which refer to an unspecified extensional part. This latter is defined in the second module eg which contains facts (unit clauses) describing the basic relations. In this case the extensional predicates which are defined in g are exported to J, which in turn imports them when composing the two parts. Further definitions for the extensional predicates can be incrementally added to the database by adjoining new modules.</p><p>To simplify the notation, when no ambiguity arises we will denote by M also the set of clauses P. To compose CLP modules we again follow <ref type="bibr" target="#b5">[6]</ref> and use a simple program union operator. We denote by Pred(E) set of predicate symbols which appear in the expression E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2 (Module composition).</head><p>Let M = (P, Op(M)) and N : (Q, Op(N)) be modules. We define</p><formula xml:id="formula_2">M q3 N = (P U Q, Op(M) U Op(N)) provided that Pred(P) n Pred(Q) C_ Op(M) N Op(N) holds. Otherwise M ® N is unde- fined.</formula><p>So, when composing M and N, we require the common predicate symbols to be open in both modules. As previously mentioned, more sophisticated compositions (like encapsulation, inheritance and information hiding) can be obtained from the one defined above by suitably modifying the treatment of the interfaces (essentially by introducing reuamings to simulate hiding and overriding). Now, in order to define the correctness of our transformation systems, we need to fix the kind of module's (and program's) equivalence that we want to establish between a program and its transformed version.</p><p>Since the result of a CLP computation is an answer constraint, it is natural to say that two programs are observationally equivalent to each other iff they produce the same answer constraints (up to logical equivalence in the structure N) for any query. This concept is formalized in the following Definition. Definition 3.3 (Program's equivalence). Let PbP2 be CLP programs. We say that P1 and P2 are (observationally) equivalent, P1 ~ P2, iff, for any query Q and for any i,j E <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, if there exists a derivation Q ~ ci then Pj there exists a derivation</p><formula xml:id="formula_3">Q -~ cj such that @ ~ 3-Vat(Q) ci ~ ~-Var(Q) cj.</formula><p>This notion is satisfactory when programs are seen as completely defined units. However, the relation ~ is far too weak when considering modules. For instance, consider the following: Example 3.4. Consider the modules M1 : (P1, {P}) and M2: (P2, {P}) where P1 is q(X) +--trueDp(X). p(X) ~ X=a. While P2 is q(X) +--X=a~p(X). p(X) +--X=a.</p><p>It is easy to see that P1 ~ P2. However, if we compose these two modules with M: (P,(p}) where P is the program p(X) +-X=b.</p><p>we have that M1 ®M and M2 ®M have quite different behaviour, in particular M1 ®M MzOM.</p><p>The notion of equivalence which we need when transforming CLP modules has to take into account also the contexts given by the ® composition. In other words, we have to strengthen ~ to obtain a congruence w.r.t, the ® operator. Therefore the following. This notion of equivalence and of congruence are used to define the correctness of our transformation system. Definition 3.6 (Correctness). We say that a transformation for CLP programs (modules) is correct iff it maps a program (a module) into an ~-(~c-) equivalent one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">A compositional semantics for CLP modules</head><p>The correctness proofs for our transformation system will be carried out by showing that the system preserves a semantics (borrowed from <ref type="bibr" target="#b12">[13]</ref>) which models answer constraints and is compositional w.r.t. ®. This implies that it is also correct w.r.t. ~c, in the sense that if two modules have the same semantics then they are ~c-equivalent. From this property it follows the desired correctness result. Basically, the semantics we are going to use is a straightforward lifting to the CLP case of the compositional semantics defined in <ref type="bibr" target="#b5">[6]</ref> for logic programs. The aim of <ref type="bibr" target="#b5">[6]</ref> was to obtain a semantics compositional w.r.t, union of programs. In this respect it is easy to see that the standard semantics, such as the least ~-model and the computed answer semantics, are not compositional w.r.t, e; consider for instance the modules M1 and M2 in Example 3.4: they have the same least ~-model, where M1 ® M and M2 ® M do not (the same reasoning applies for the answer constraint semantics of <ref type="bibr" target="#b13">[14]</ref>). Following an idea first introduced in <ref type="bibr" target="#b14">[15]</ref>, compositionality was then obtained by choosing a semantic domain based on clauses. As we discuss below the resulting semantics tums out to model the notion of "resultant", hence its name.</p><p>In order to define the semantic domain, we use the following equivalence relation, which, intuitively, is a generalization to the CLP case of the notion of variance. Definition 3.7. Let ell : A1 +--Cl 5/~1 and cl2 : A2 +--C2 D/~2 be two clauses. We write Cll ~ cl2 iff for any i,j E <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> and for any @-solution 0 of ci there exists a ~-solution 7 of cj such that AiO --A j7 and BiO and /~j7 are equal as multisets. Moreover, given two programs P and P' we say that P -P' iff P' is obtained by replacing some clauses in P for ~-equivalent ones.</p><p>Notice that, in the previous definition, the body of a clause is considered as a multiset. Considering bodies of clauses as sets instead of multisets would not allow us to model correctly answer constraints, since adding a duplicate atom to the body of a clause can augment the set of computed constraints. For instance, if we consider the programs QI: Dr(X,Y) ,r(X,Y).</p><formula xml:id="formula_4">q(X,Y) +-true r(X,Y) +--X=a. r(X,Y) +--Y=b.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~r(X,Y).</head><p>The query q(X,Y) has the computed answer constraint X = a A Y = b in Q1 and not in Q2.</p><p>The following lemma shows that the equivalence relation _~ is correct w.r.t, the congruence relation ~e. <ref type="bibr">Lemma 3.8 (Gabbrielli [13]</ref>). Let M = (P, zc} and M'= (P',Tc} be two modules with the same set of open predicates. If P ~-P' then M ~ M'.</p><p>We are now able to define the semantic domain. For the sake of simplicity, we will denote the _~-equivalence class of a clause c by c itself. Definition 3.9 (Denotation). Let ~r be a set of predicate symbols and let cg be the set of the ___-equivalence classes of the CLP clauses in the given language. The interpretation base cg~ is the set {A +-cD/} 6 c~ ] Pred(B) C_ ~}. A denotation is any subset of cg~.</p><p>The following is the definition of the resultant semantics as it was originally given in <ref type="bibr" target="#b5">[6]</ref> for pure logic programs and applied to CLP in <ref type="bibr" target="#b12">[13]</ref>. If there exists a derivation cD~i ~ dDB, then the formula cD~i ~-dD/} is called a computed resultant for the query cc~A in P. It can be shown that computed resultants for generic queries can be obtained by combining together resultants for simple queries of the form true[]p <ref type="bibr" target="#b1">(2)</ref>. Therefore (9(M) is expressive enough to characterize all the resultants computable in P. In particular, (9(M) models also the answer constraints computed in M, since these can be obtained from resultants of the form c DA +-d. The compositionality of previous semantics w.r.t. ® is proved in <ref type="bibr" target="#b12">[13]</ref>. From such a result follows the correctness of (9 w.r.t. ~c, stated by the following proposition. Proposition 3.11 (Correctness, Gabbrielli <ref type="bibr" target="#b12">[13]</ref>). Let M = (P, Op(M)} and (Q, Op(N)} be modules such that Op(M) = Op(N). If (9(M) = (9(N) then M ~c N.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N=</head><p>In the particular case Op(M) = @, i.e. when all the predicates are completely defined, (9(M) coincides with the answer constraint semantics which is correct and fully abstract w.r.t. ~ (see <ref type="bibr" target="#b13">[14]</ref>). Example 3.12. Consider again the modules M1 and 2142 of Example 3.4. Then (9(M1) = {p(X) +-X = a, q(X) ~---X = a, q(X) +---truec~p(X)}.</p><formula xml:id="formula_5">(9(M2) = {p(X) ~-X = a, q(X) +--X = a, q(X) +--X = a~p(X)}.</formula><p>So the fact that M1 and M2 are not observationally congruent is reflected by the fact that (P(M1) ¢ (P(M2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Resultants semantics via trees</head><p>We now provide a new, altemative formulation of the resultant semantics in terms of proof trees. This particular notation will be used to prove the correctness results.</p><p>We assume known the usual notion of finite labelled tree and the related terminology. Given a finite labelled tree rooted in the node N, we say that T' is an immediate subtree of T if T' is the subtree of T which is rooted in a son of N. Definition 3.13 (Partial proof tree). Let A be an atom. A partial proof tree for A is any finite labelled tree T satisfying the following conditions: 1. The root node of T is labelled by a pair (A = Ao ; Ao ~ CA pAl ..... An) such that A0 and A have the same predicate symbol. 2. Each immediate subtree Tj of T is a partial proof tree for a distinct Aj with 1 ~&lt;j ~&lt; n. 3. All the clauses used in the labels of T do not share variables pairwise and have no variables in common with the atom in the 1.h.s (left-hand side) of the label equation in the root node.</p><p>We call label equation and label clause of the node N, the left-and the right-hand side of the label of N, respectively. Moreover, if A i is an atom in the body of the label clause of the root of T and Ti is an immediate subtree of T which is a partial proof tree for A/, we say that Tg is attached to A i. Using this notation, condition 2 can be restated as follows: "no two immediate subtrees of T are attached to the same atom of the label clause of the root (and therefore, of any) node". Finally, we say that T is a tree in P, if the label clauses of all its nodes are (variants of) clauses of the program P.</p><p>Notice that, according to previous definition, there might be some Aj in the bodies of label clauses with no subtrees attached to them. We call them the elements of the residual as specified below. Definition 3.14. Let T be a partial proof tree.</p><p>• The residual of a node in T having the clause label Ao +---cA:~A1 ..... An, is the multiset consisting of those Aj's, 1 &lt;&lt;.j&lt;.n, that do not have an immediate subtree attached to. • The residual of T is the multiset resulting from the (multiset) union of the residuals of its nodes.</p><p>In order to establish the connection between the resultants semantics and partial proof-trees, we introduce now in a natural way the notion of resultant of partial proof trees. Definition 3.15. Let T be a partial proof tree. We call the 9lobal constraint of T the conjunction of all the label equations together with the constraints of all the label clauses of the nodes of T. Definition 3.16. Let T be a partial proof tree of A. Let c be its global constraint and F1 ..... Fk be its residual. If c is satisfiable we call the clause A ~--cDF1,... ,Fk the resultant of T.</p><p>In the sequel we are interested in those partial trees whose residuals consist exclusively of only open atoms and whose global constraint is satisfiable. Therefore the following definition: Definition 3.17. Let n be a set of predicate symbols. We call n-atom any atom A such that Pred(A) E n. A n-tree is a partial proof tree T such that 1. the residual of T contains only n-atoms, 2. the global constraint of T is satisfiable.</p><p>We can now establish the relation between open trees and the resultant semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3.18 (Correspondence). Let M = (P, Op(M)) be a module. Then A ~-cDP E C(M) iff there exists a 7r-tree of A in P with A ~-c'DP' as resultant such that A +--cDP ~-A ~--c' •P' and n = Op(M).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ProoL Straightforward. []</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A transformation system for CLP</head><p>In this section we define a transformation system for optimizing constraint logic programs. The system is inspired by the unfold/fold method proposed by Tamaki and Sato <ref type="bibr" target="#b36">[37]</ref> for pure logic programs. Here, the use of constraint logic programs allows us to introduce some new operations which broaden the possible optimizations and to simplify the applicability conditions for the folding operation in <ref type="bibr" target="#b36">[37]</ref>.</p><p>Before we begin to define the transformation method, it is important to notice that all the observable properties of computations we refer to are invariant under _~. Moreover, as we formally prove later, such a replacement does not affect the applicability and the results of the transformations. Therefore we can always replace any clause cl in a program P by a clause cl', provided that cl' ~-cl. This operation is often useful to clean up the constraints, and, in general, to present a clause in a more readable form.</p><p>We start from some requirements on the original (i.e. initial) program that one wants to transform. Here we say that a predicate p is defined in a program P, if P contains at least one clause whose head has predicate symbol p. Definition 4.1 (lnithll program). We call a CLP program P0 an initial program if the following two conditions are satisfied: (I1) P0 is partitioned into two disjoint sets Pnow and Pore, <ref type="bibr" target="#b11">(12)</ref> the predicates defined in Pnow do not occur in Pore nor in the bodies of the clauses in/°new. Following this notation, we call new predicates those predicates that are defined in Pnew. We also call transformation sequence a sequence of programs P0 ..... Pn, in which P0 is an initial program and each Pi+l, is obtained from Pi via a transformation operation.</p><p>Our transformation system consists of five distinct operations. In order to illustrate them throughout this section we will use the following working example. To simplify the notation, when the constraint in a goal or in a clause is true we omit it. So the notation H ~--/} actually denotes the CLP clause H ~--trueDB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 4.2 (Computing an average).</head><p>Consider the following CLP(91 ) program 2 AVERAGE computing the average of the values in a list. Values may be given in different currencies, for this reason each element of the list contains a term of the form (Currency, Amount). The applicable exchange rates may be found by calling predicate exchange_rates, which will retum a list containing terms of the form (Currency, Exchange_Rate), where Exchange_Rate is the exchange rate relative to Currency. AVERAGE consists of the following clauses: together with the usual definition for member. Notice that the definition of average needs to scan the list Xs twice. This is a source of inefficiency that can be fixed via a transformation sequence.</p><p>The first transformation we consider is the unfolding. This operation is basic to all the transformation systems and essentially consists in applying a derivation step to an atom in the body of a program clause, in all possible ways. As previously mentioned, all the observable properties we consider are invariant under reordering of the atoms in the bodies of clauses. Therefore the definition of unfolding, as well as those of the other operations, is given modulo reordering of the bodies. To simplify the notation, in the following definition we also assume that the clauses of a program have been renamed so that they do not share variables pairwise. In this situation we also say that {H1 +-cl c/}1 ..... H~ ~ en D/},} are the unfoMing clauses.</p><p>Example 4.2 (Part 2). The transformation strategy which we use to optimize AVERAGE is often referred to as tupling <ref type="bibr" target="#b31">[32]</ref> or as procedural join <ref type="bibr" target="#b25">[26]</ref>. First, we introduce a new predicate avl defined by the following clause: avl (List, RATES, AV, LEN)+-AV is the average of the list List, and LEN is its length c2: avl(XS, RATES, AV, LEN)+--LEN&gt;0AAV*LEN--SUM exchange_rates (RATES), weighted_sum(Xs, RATES, SUM), len(XS, LEN). avl differs from average only in the fact that it reports also the list of exchange rates and the length of the list Xs. Notice that avl, as it is now, needs to traverse the list twice as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>! 14</head><p>Now let P0 be the initial program consisting of AVERAGE augmented by e2 and assume that avl is the only new predicate. We start to transform P0 by performing some unfolding operations. First we unfold weighted_sum(XS, RATES, SUM) in the body of e2. The resulting clauses, after having cleaned up the constraints and renamed some variables, are the following ones: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Furthermore, in the above clauses we unfold the atoms len([],</head><p>Len) and len([(Currency,Amount) ]Rest], Len). This yields the following two clauses: Notice that the constraint in the body of clause c3 is unsatisfiable. For this reason c3 could be removed from the program; to do that we need the following operation. Note 4.5. In <ref type="bibr" target="#b31">[32]</ref> we find the definition of a clause deletion operation for pure logic programs which in CLP terms can be expressed as follows: if cl : H ~--cDB is a clause in P such that query cD/} has a finitely failed tree in P then we 3 can remove cl from P. Obviously, if ~ ~ 73 c then the goal cDA has a (trivial) finitely failed tree; therefore each time that we can apply the clause removal operation we can also apply the clause deletion of <ref type="bibr" target="#b31">[32]</ref>. However, clause removal is only apparently more restrictive than clause deletion, since by combining it with the unfolding operation we can easily simulate the latter. Indeed, if cD/} has a finitely failed tree in P then, by a suitable sequence of unfoldings we can always transform the clause A +--c[]B, in such a way that the set of resulting clauses is either empty or contains only clauses whose constraints are unsatisfiable. So using clause removal, we can then (indirectly) remove cl from the program. We prefer to use clause removal rather than clause deletion, because when we will move to the context of modular CLP programs the first operation will remain unchanged while the latter will require some specific applicability conditions.</p><p>We now introduce the splitting operation. Here, just like for the unfolding operation, the definition is given modulo reordering of the bodies of the clauses and it is assumed that program clauses do not share variables pairwise. Definition 4.6 (Splitting). Let cl : A +--c~H,k be a clause in the program P, and {H1 +--cl []/~1 ..... Hn +--cn~Bn} be the set of the clauses in P such that cAciA(H = Hi) is @-satisfiable. For i 6 <ref type="bibr">[1,n]</ref>, let cl~ be the clause</p><formula xml:id="formula_6">.4 +--c A ci A(H = Hi)[]H,I£</formula><p>If, for any i,j 6 [1,n], i # j, the constraint (Hi = Hj) A ci A cj is unsatisfiable then splitting H in cl in P consists of replacing cl by {cl{ ..... cl~} in P.</p><p>In other words, the splitting operation is just an unfolding operation in which we do not replace the atom H by the bodies of the unfolding clauses. The condition that for no two distinct i,j (Hi = Hi) A ci A cj is satisfiable is easily seen needed in order to obtain ~ equivalent programs. Indeed, consider for instance the program Q q(X, Y)+--p(X, Y) p(a, W).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>p(Z, b).</head><p>If we split p (X, Y) in the body of the first clause we obtain the program Q', which after cleaning up the constraints consists of the following clauses:</p><formula xml:id="formula_7">q(a, Y)+--p(a, Y) q(X, b)+--p(X, b) p(a, W). p(Z, b).</formula><p>3 The definition of finitely failed tree for CLP is the obvious generalization of the one for pure logic programs. Now Q ~ Q' since the query q(X, Y) has in Q' the computed answer {X = a,Y = b}, while such an answer is not obtainable in Q. Note 4.7. We should mention that an operation called splitting has also been defined in a technical report of Tamaki and Sato <ref type="bibr" target="#b35">[36]</ref>. However, the operation described here is substantially different from theirs. In CLP terms the splitting operation defined in <ref type="bibr" target="#b35">[36]</ref> can be expressed as follows. If el : H +-caB is a clause and d a constraint then splitting el via d consists in replacing el by the two clauses {H ~ c A dc/~, H +c A ~d[]B}. This operation preserves the minimal Y-model (which corresponds to semantics used in <ref type="bibr" target="#b35">[36]</ref>) but is does not produce ~ equivalent programs. Indeed, if we consider the program P = {p (X).} then by splitting its only clause w.r.t, the constraint X=a we obtain the program P' = {p(X) +--X=a., p(X) ~--X ¢ a.}. Clearly P' ~ P, since the query p (X) returns the answer constraint X=a in P' only.  In clause c6 we can now remove the superfluous constraint (by replacing c6 for a -~-equivalent clause) Len' = Len' '+l, and in c5 we can do some cleaning up and we can unfold both weighted_sum([] ,Rates,Sum') and len([] ,0). After these operations we end up with the following clauses:  In order to be able to perform the folding operation on clause c8 we need now a last, preliminary operation: the constraint replacement. In fact, as we will discuss later, to apply such a folding, c8 should contain also the constraint Len'&gt;0. Clearly, adding Len'&gt;0 to the body of c8 cannot be done via a simple cleaning-up of the constraints, as it transforms c8 in a clause that is not ~-equivalent. However, notice that the variable Len' in the atom len([JlRest] , Len') (in the body of c8) represents the length of the list [JlRest] which obviously contains at least one element. Indeed, every time that c8 is used in a refutation its internal variable Len' will eventually be bounded to a numeric value greater than zero. We can then safely add the redundant constraint Len'&gt;0 to body of c8. This type of operation is formalized by the following definition of constraint replacement. Notice that this operation relies on the semantics of the program (in the previous specific case, on the fact that if len( [JlKest], Len') succeeds in the current program with answer constraint c then c is equivalent to c A Len' &gt; 0). Constraint replacement has some similarities with the refinement operation as defined by Marriott and Stuckey in <ref type="bibr" target="#b29">[30]</ref>. Refinement allows us to add a constrain c to a program clause H ~--Cl m/}, provided that (for a given set of initial queries of interest) for any answer constraint d of Cl c~/~, ~ ~ d --~ c holds, i.e. c is redundant in d. Clearly this case is covered by our definition. However, the similarities between this paper and <ref type="bibr" target="#b29">[30]</ref> end here. In <ref type="bibr" target="#b29">[30]</ref>, refinement, together with two other operations, is used to define an optimization strategy which manipulates exclusively the constraints of the clauses and which is devised to reduce the overhead of the constraint solver in presence of the fixed left-to-right selection rule, thus providing a kind of optimization technique totally different from the one here considered. As we said before, the applicability conditions for the constraint replacement operations are satisfied because each time that the query len([JlRest],</p><p>Len') succeeds in the current program the variable Len' is constrained to a value greater than zero.</p><p>We are now ready for the folding operation. This operation is a fundamental one, as it allows us to introduce recursion in the new definitions. Intuitively, folding can be seen as the inverse of unfolding. Here, we take advantage of this intuitive idea in order to give a different formalization of its applicability conditions which we hope will be more easily readable than those existing in the literature.</p><p>As in <ref type="bibr" target="#b36">[37]</ref>, the applicability conditions of the folding operations depend on the history of the transformation, that is, on some previous programs of the transformation sequence. Recall that a transformation sequence is a sequence of programs obtained by applying some operations of unfolding, clause removal, splitting, constraint replacement and folding, starting from an initial program Po which is partitioned into Pnew and Pold.</p><p>As usual, in the following definition we assume that the folding (d) and the folded (cl) clause are renamed apart and, as a notational convenience, that the body of the folded clause has been reordered so that the atoms that are going to be folded are found in the leftmost positions. Here, the constraint e acts as a bridge between the variables of d and cl. For this reason in the sequel we will often refer to it as bridge constraint. Moreover d and el will be referred to as the folding and folded clause, respectively.</p><p>Conditions (F1) and (F2) ensure that the folding operation behaves, to some extent, as the inverse of the unfolding one; the underlying idea is that if we unfolded the atom D in cF using only clauses from Pnew as unfolding clauses, then we would obtain cl back. In this context condition (F2) ensures that in Pnew there exists no clause other than d that can be used as unfoldin9 clause.</p><p>We now show that (Fl(i)) and (Fl(ii)) are equivalent to each other. First notice that the folding and the folded clause are assumed to be standardized apart, so D has no variables in common with A, cA, k and J. From this and the fact that CA _zK is an instance of trueDI2I, it follows that each solution of CA can be extended to a solution of CA A (H =/~). Hence</p><formula xml:id="formula_8">cl " A ~--CA~I{,J ~ A +--cA A ([7[ = ~2)Dff2,j.</formula><p>Now, because of the constraint H =/{, in the r.h.s, of the above formula, we also have that cl _~ A~--cAA(£r=~?)[]B,j.</p><p>(</p><p>On the other hand, if we unfold el I using d as unfolding clause, as a result we get the following clause:  This proves that condition (Fl(i)) is equivalent to (Fl(ii)). Of course, the former is more useful when we are transforming programs "by hand", while the latter is more suitable for an automatic implementation of the folding operation.</p><p>Here it is worth noticing that the folding clause is always found in P0 and usually does not belong to the "current" program, therefore in practice "undoing" a fold via an unfolding operation is usually not possible.</p><p>Finally, we should mention that the purpose of (F3) is to avoid the introduction of loops which can occur if a clause is folded by itself. This condition is the same one that is found in Tamaki-Sato's definition of folding for logic programs. Notice that, because of this last operation, the definition of avl is now recursive and it needs to traverse the list only once. Here, checking (F1) is a trivial task: what we have to do is to unfold ci0 using c2 as unfolding clause, and check that the resulting clause is _~-equivalent to c9.</p><p>Finally, in order to let also the definition of average enjoy of these improvements, we simply fold weighted_sum(Xs, Rates, Sum), len(Xs, Len) in the body of cl, using c2 as folding clause. The bridge constraint e is now</p><formula xml:id="formula_10">Xs = XSARATES = RatesAAV = AvALEN = Len</formula><p>and the resulting clause is, after the cleaning-up cll: average(List, Av) +-Len&gt;O ] avl(List, Rates, Av, Len).</p><p>Again, we could eliminate the constraint Len &gt; 0 in the body of cii, by applying a constraint replacement operation. In any case, the transformed version of the program AVERAGE, consisting of the clauses cii, c7, cl0 together with the definition of member, contains a definition of average which needs to scan the list only once.</p><p>The transformation system given by the previous five operations is correct w.r.t. ~, i.e. any transformed program together with a generic query Q will produce the same answer constraints of the original one. This is the content of the following result, which follows from the more general one contained in Section 5. Proof. Statement (a) is proven in Section 5 as a Corollary of Theorem 5.4. The fact that (a) implies (b) is proven in <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Invariance of the applicability conditions</head><p>As previously mentioned, we often substitute a clause in a program by an -~-equivalent one in order to clean up the constraints. The correctness of this operation w.r.t. the ~c congruence is stated in Lemma 3.8. We now show that this operation is correct also in the sense that it does not affect the applicability and the result (up to ~_) of the previously defined operations. This is the content of the following proposition. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.n], Pi ~-P~. If Pn+x is a program obtained from P~ via a transformation operation, then there exists a program P~+I which can be obtained from P~ via the same transformation operation and such that</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ProoL</head><p>In case that the operation used to obtain Pn+l from Pn was either an unfolding, a clause removal, a splitting, or a constraint replacement, this result follows immediately from the operation's definitions, so we only have to take care of the folding operation. We adopt the same notation used in Definition 4.9, so we let -cl : A +--CA c]f2,j be the folded clause, in Pn, -d : D +--CDC]I2I be the folding clause, in Pnew(CP0). Proof. (If) This is trivial, as if cA ,Jk is an instance of eD DH then it is also an instance of true ~IYI.</p><p>(Only if) The discussion after Definition 4.9 shows that, if cA Dk is an instance of true D I2I and (F1) holds, then we have the following equivalences:</p><formula xml:id="formula_11">cl : A +--cA DK, J ~-A +--CA A(H = K)D/£,J --~A *--cA A(/~ =/~)DH,,J ~-A +--cA A e A cDcsITI, J.</formula><p>This implies that cA D/( is an instance of cA A e A CD [3/~, which in turn is by definition an instance of CD DIrI. This concludes the proof of the Observation. [] This Observation shows that there is no loss of generality in modifying the applicability conditions of the folding operation Definition 4.9 by replacing the condition "ca cz/£ is an instance of true DI2I '' for "cA D/£ is an instance of el)[]/:7". Now, from the definitions of instance and of -~ it is immediate to verify that the following facts hold: (1) If CASE is an instance of CDaIZI then e~iDk* is an instance of ebDH .</p><p>(2) if (F1)A(F2)A(F3) are satisfied (by cl, d and e) in Pn, then they are also satisfied (by el*, d* and e*) in P*.</p><p>This concludes the proof of the proposition. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A transformation system for CLP modules</head><p>Theorem 4.10 shows the correctness of the transformation system when viewing each CLP program as an autonomous unit. However, as pointed out in the introduction, an essential requirement for programming-in-the-large is modularity: A program should be structured as a composition of interacting modules. In this framework Theorem 4.10 falls short from the minimal requirement since it does not guarantee that a module P will be transformed into a congruent one U.</p><p>Transforming CLP modules requires then a strengthening of (some of) the applicability conditions given in the previous section. In what follows, we discuss such modifications considering the various operations one by one. Recall that the open predicates of a module M are the ones specified on Op(M). Similarly, in the sequel we call open atoms those atoms whose predicate symbol belongs to Op(M). Moreover, we assume that the transformed version of a module has the same open predicates as the original one.</p><p>Unfolding. In order to preserve the compositional equivalence, for the unfolding operation we need the following additional applicability condition: (01) The unfolding cannot be applied to an open atom.</p><p>This condition is clearly needed, for instance, consider the module M0 consisting of the single clause {cl: p ~--q.} and where Op(Mo) = {q}. Since 340 contains no clause whose head unifies with q, unfolding q in cl will return an empty module 341 = (0. Obviously M0 and M1 are not observationally congruent.</p><p>Clause Removal. This operation may be safely applied to modules withoutthe need of any additional condition.</p><p>Splitting. Being closely connected to the unfolding operation, the splitting one requires the same kind of precautions when is applied to a modular program. Namely we need the following condition: (02) The splitting operation may not be applied to an open atom.</p><p>The example used to show the need for condition (O1) for the unfolding operation can be applied here to demonstrate the necessity of (02).</p><p>Constraint replacement. This operation is the most delicate one: in order to apply it to modules we need to restate completely its applicability conditions. As a simple example showing the need of such a change, let us consider the following module M0: cl: p(X) +--trueDq(X). q(a).</p><p>where Op(Mo) = {q}. The only answer constraint to the query q(X) in M0 is X = a. Therefore, if we refer to the applicability conditions of Definition 4.8, we could add the constraint X = a to the body of c 1 thus obtaining MI: c2: p(X)+--X=a [] q(X). q(a).</p><p>Once again M0 and M1 are not congruent. In fact, for N = ({q(b). }, {q}), the query p(b) succeeds in M0 ® N and fails in M1 ® N. Folding. Finally, we consider the folding operation. In order to preserve the compositional equivalence the head of the folding clause cannot be an open atom. This is shown by the following simple example. Consider the initial module M0: el: p +--q. c2: r +--q.</p><p>where we assume Op(Mo) = {p} and Mnew = {p +-q}. Since r is an old atom, we can fold q in c2 using cl as folding clause. The resulting module MI is c5: p +-q. c4: r+-p.</p><p>Again M0 and MI are not observationally congruent. Indeed, if we compose them with the module N = ({p. }, {p}), we have that the query r succeeds in MI ® N, but fails in M0 • N. Since the new predicates are the only ones that can be used in the heads of folding clauses, we can express this additional applicability condition for folding as follows: (04) No open predicate is also a new predicate.</p><p>It is worth noticing that open atoms may still be folded. Below (Example 4.2, part 6), we report an example of such a case.</p><p>Using the additional applicability conditions introduced above, we can define now the transformation sequence for CLP modules (for short, modular transformation sequence). Definition 5.2 (Modular transformation sequence). Let M0 = (P0, Op(Mo)} be a module and Po .... , Pn be a transformation sequence. We say that Mo .... ,M~ is a modular transformation sequence iff Mi = (Pi, Op(Mo)} for i E [0,n] and the conditions (O1),..., (04) are satisfied by all the operations used in P0 ..... Pn.</p><p>As expected, for a modular transformation sequence we can prove a correctness result stronger than the one contained in Theorem 4.10. Indeed, the system transforms a module into a congruent one.</p><p>This result is based on the following theorem which contains the main technical result of the paper and shows that any modular transformation sequence preserves the resultants semantics. [] In other words, for any module N such that M0 • N is defined, M= ® N is also defined 4 and a generic query has the same answer constraints in M0 • N and Mn ® N. From previous result we also obtain Theorem 4.10 of previous section. we consider that the exchange rates between currencies are typically fluctuating ratios, it comes natural to assume exchange_rates as an open predicate which may refer to some external "information server" to access always the most up-to-date information. In this context, it is easy to check that all the transformations we performed satisfied (O1) .... , (04). Therefore Theorem 5.4 guarantees that the final program will behave exactly as the initial one, even in this modular setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">From LP to CLP</head><p>It is well-known that pure logic programming (LP for short) can be seen as a particular instance of the CLP scheme obtained by considering the Herbrand constraint system. This is defined by taking as structure the Herbrand universe and interpreting as identity the only predicate symbol for constraints "=". So it is natural to expect that an unfold/fold transformation for LP can be embedded into one for CLP. Indeed, in this section we show that the transformation system we propose is a generalization to the CLP (and modular) case of the unfold/fold system designed by Yamaki and Sato <ref type="bibr" target="#b36">[37]</ref> for LP. As a consequence, conditions (O1) and (04) can be used also in the LP case to transform a module into a congruent one.</p><p>We introduce the system of Tamaki and Sato by first considering the unfold operation for LP. Again, we assume that the clauses are standardized apart and we give the following definition modulo reordering of the bodies. Definition 6.1 (Unfoldin9 for LP). Let cl: A +-H,K be a clause of a logic program P, and let {//1 ~/~1 ..... Hn +--/~n) be the set of clauses of P whose heads unify with H, by mgu's {01 ..... 0n). For i E <ref type="bibr">[1,n]</ref> let el~ be the clause</p><formula xml:id="formula_12">(A +--Bi,K)Oi {cll,...,eln} in P. Then unfoldin9 H in cl in P consists of replacing cl by ~ t</formula><p>Also in the LP case the notions of folding operation and of transformation sequence are defined in a mutually recursive way. So, in the sequel we use the same definition of initial program as before. However, since clause removal, splitting and constraint replacement are new operations which were not in <ref type="bibr" target="#b36">[37]</ref>, we call now LP transformation sequence a sequence of LP programs Po,...,Pn, in which P0 is an initial program and each Pi+i, is obtained from Pi either via an unfolding or via a folding operation 5.</p><p>Now we also need some extra preliminary notions. Given a substitution 0 = {Xl/tl ..... Xn/tn} we denote by Dom(O) the set of variables {xl ..... xn}, and by Ran(O) the set of variables appearing in {h,..., tn}, if Ran(O) = (3 we say that 0 is grounding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finally we denote by Var(O) the set Dora(O) U Ran(O).</head><p>We are now ready to give the definition of the folding operation for LP. Again, here we assume that the folding and the folded clause are renamed apart and that the body of the folded clause has been reordered (as in Definition 4.9). Definition 6.2 (Folding for LP, Tamaki and Sato <ref type="bibr" target="#b36">[37]</ref>). Let Po ..... Pi, i&gt;~O, be an LP transformation sequence and cl : A ~-K,J. be a clause in Pi, d : D ~--/J. be a clause in Pnew.</p><p>Let also f = Var(tt) \ Var(D) be the set of local variables of d. If there exists a substitution z such that Dom(z) = Var(d), then folding ~2 in cl via z consists of replacing el by cI r : A +--Dz, J, provided that the following conditions hold: (LP1)/~r~ = K; (LP2) For any x, y C</p><p>• xz is a variable; • xv does not appear in A, J, Dz;</p><p>• ifx~y thenxz~yz; (LP3) d is the only clause in Pnew whose head is unifiable with Dz; (LP4) one of the following two conditions holds: 1. the predicate in A is an old predicate; 2. cl is the result of at least one unfolding in the sequence P0 ..... Pi.</p><p>Concerning the unfolding operation, it is easy to see that Definition 6.1 is the LP counterpart of Definition 4.3. In fact, an LP clause is itself a CLP rule (with an empty constraint) and well-known results <ref type="bibr" target="#b26">[27]</ref> imply that two terms s and t have an mgu iff the equation s = t is satisfiable in the Herbrand constraint system. Therefore, given a logic program P, we can unfold P according to Definition 6.1 iff we can unfold P according to Definition 4.3. Clearly, the results of the two operations are syntactically different, since substitutions are used in the first case whereas constraints are employed in the second one. However, again by using standard results of unification theory, it is easy to check that the different results are -~ equivalent.</p><p>On the other hand, when considering the folding operation, the similarities between Definitions 6.2 and 4.9 are less immediate. Therefore we now formally prove that, whenever the folding operation for LP programs is applicable also the folding operation for CLP programs is, and the result of this latter operation is -~-equivalent to the result of the operation in LP. This is summarized in the following. Proof. In order to simplify the notation, we now define a simple mapping from LP clauses to clauses in pure CLP. 6 Let el: p0(i'0) +-pl(tl) ..... pn(t'n) be a clause in LP. Then #(cl) is the CLP clause P0(i~0) +--2~0 z t0 A3~1 = il A"" AX n ~--t'n Dpl(;~l) ..... pn(.~n), where 20,... ,2~ are tuple of new and distinct variables. Obviously #(cl) ~_ cl for any clause cl. Therefore it suffices to prove that if P0 ..... P. is a transformation sequence of logic programs, then #(P0) .... , #(P,) is a transformation sequence in CLP. The proof proceeds by induction on the length of the sequence. For the the base case (n --0) the result holds trivially, so we go immediately to the induction step: we assume that Po,...,P~+I is a transformation sequence in LP, that #(P0) ..... #(Pn) is a transformation sequence in CLP, and we now prove that #(P0) ..... #(Pn+l) is a transformation sequence in CLP as well.</p><p>If Pn+l is the result of unfolding a clause cl of Pi, then it is straightforward to check that by unfolding #(cl) in #(Pi) we obtain #(P/+I) (modulo ~_). Now we consider the case in which P~+I is the result of a folding operation (applied to Pn). We prove the thesis for the simplified situation where H, k and ff consist each of a single atom. The extension to the general case is straightforward. Let d : a(Y) ~ b([) be the folding clause, in Pnew.</p><p>Since we are assuming that the applicability conditions of Definition 6.2 are satisfied, by (LP1) the folded clause (in P~) can be written as follows:</p><formula xml:id="formula_13">cl : c(tT) +--b([z), d(g).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The result of the folding operation is then cl' : c(~t) +--a(2z), d(g).</head><p>which is a clause in P~+I.</p><p>By translating the folding and the folded clause in CLP, we obtain</p><formula xml:id="formula_14">g(d) -d* : a(2) *--2= ~ A y = [Db(~), #(cl) --cl* : c(Y.) +-2 = ~t A ~ = ['c A [c = ~sb(~),d([c).</formula><p>Where 2, y, Z, v? and /~ are tuples of new and distinct variables. Now, let e be the following constraint: e = 2=Yz the result of the folding operation in CLP is then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>cl:* : c(Z) +--~ = f A t? = ~ A ~: = ~ A2 = g~Da(Y),d([c).</head><p>It is straightforward to check that #(cF) ~_ cff*. Now, it is also clear that Z = fiat? = ~z A/~ = g~b(~) is an instance of trueab(y), so in order to prove the thesis we now need to verify that if d, cl and z satisfy (LP1), (LP2) in Pn then d*, cl* and e satisfy (F1) in #(Pn). Here the structure @ is the Herbrand structure, whose domain is the Herbrand universe and where "=" is interpreted as the identity. (</p><p>Recall that, when considering the Herbrand structure, g is a solution of a constraint c if g is a grounding substitution such that Dora(g) = Var(c) and ~ ~ cO. We now show that for each solution r/ of one side of (3) there exists a solution t/ of the other side of (3) such that tlle,;= t/tle,)~; this will imply the thesis.</p><p>We now prove the two implications separately: (+--) Let t/ be a solution of ff = f A y = [z. We assume that t/ is minimal, in the sense that if l is a variable not occurring in Z = fA)~ = t'z, then 1 f~ DomO~). Since, by standardization apart, Dora(v) rq Ran(q) = ~1, we have that Dom(tl) r] Dom(~) = 0. We can extend t/ to t/ where Dora(t~) = Dom(q)UDom(r): for each l ~ Dora(z), we let lt/ be equal to l~t/.</p><p>~/ is now also a solution of the left-hand side of (3). In fact gtf = g~t/ (by ( <ref type="formula" target="#formula_16">4</ref>))</p><p>= grr/ (because t/ is an extension of t/).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Moreover</head><p>)~r/ = t'rt/~ (because rf is an extension of t/, and t/ is a solution of y = if)</p><p>= tt I' (by( <ref type="formula" target="#formula_16">4</ref>)).</p><p>Since t/ is an extension of t/, we have that J/Is,; = ~//Iz,;. (---+) Let t/ be a solution of Z = f A g = gz A )3 = /'. Again, we assume t/ to be minimal (in the sense above, i.e. Dom(tl) =Var(ff = f A Y = Yv A )3 = ?)). Observe that Dom(tl) N Ran(z) = Var(s'c). We now extend t/to t/ in such a way that Dom(tl) encompasses the whole Ran(z) = Var(tz) U Var(sz). Let 7 be the tuple of variables given by Var(?)\Var(~), by (LP2) we have that 1-c is a tuple of distinct variables.</p><p>Moreover, the variables in lz do not occur anywhere else in the above formulas. So, for each l i E l, we can let liztl t be equal to lit I. <ref type="bibr" target="#b4">(5)</ref> Since q is already a solution of g = gz and q~ is an extension of r/, by <ref type="bibr" target="#b4">(5)</ref> we have that Since ~/is a solution of )3 = ?, t/' is then a solution of 33 = ~z, and hence of the whole LHS of (3), which concludes the proof. [] Theorem 6.3 allows us to apply the results of the previous section also to the Tamaki-Sato schema, thus obtaining a transformation system for LP modules. The following corollary show the correctness result for this case. Here we consider as LP module a logic program P together with a set of predicate symbols n. Module composition and the related notions are the same as in the previous sections. Given two logic programs P1 and P2, the concept of observational equivalence ~LP is defined as follows:</p><p>• P1 ~LPp2 iff, for any query Q and for any i,j E <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, if Q has a computed answer Oi in the program Pi then Q has a computed answer Oj in the program Pj such that OOi =-OOj. 7</p><p>Therefore, in the LP context, the concept of module congruence is defined as follows.</p><p>Given two modules M1 and M2,</p><p>• ml ~LP ~c M2 iff Op(M1 ) = Op(M2) and for every module N such that M1 ® N and M2 @ N are defined, M1 ® N ~LP M2 ® N holds. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>Among the works on program's transformations, the most closely related to this paper are Maher's <ref type="bibr" target="#b28">[29]</ref> and the one of Bensaou and Guessarian <ref type="bibr" target="#b2">[3]</ref>.</p><p>Maher considers several kinds of transformations for deductive database modules with constraints (allowing negation in the bodies of the clauses) and refers to the perfect model semantics. However, the folding operation proposed in <ref type="bibr" target="#b28">[29]</ref> is quite restrictive, in particular it lacks the possibility of introducing recursion. Indeed, for positive programs, it is a particular case of the one defined here. Moreover, our notion of module composition is more general than the one considered in <ref type="bibr" target="#b28">[29]</ref>, since the latter does not allow mutual recursion among modules.</p><p>Recently, an extension of the Tamaki-Sato method to CLP programs has also been proposed by Bensaou and Guessarian <ref type="bibr" target="#b2">[3]</ref>, yet there are some substantial differences between <ref type="bibr" target="#b2">[3]</ref> and our proposal.</p><p>Firstly, just as in the case of the operation defined in <ref type="bibr" target="#b28">[29]</ref>, also the folding defined in <ref type="bibr" target="#b2">[3]</ref> is very restrictive in that it lacks the possibility of introducing recursion.</p><p>Secondly, since in an unfold/fold transformation sequence we allow more operations (namely splitting and constraint replacement), we obtain a more powerful system. For instance, the transformation performed in Example 4.2 is not feasible with the tools of <ref type="bibr" target="#b2">[3]</ref>. On the other hand, since in <ref type="bibr" target="#b2">[3]</ref> the authors define also a goal replacement operation, there exist also some transformation which can be done with the tools of <ref type="bibr" target="#b2">[3]</ref> and not with ours. However, such a replacement operation does not fit in an unfold/fold transformation sequence, in particular no folding is allowed when the transformation sequence contains a goal replacement. For this reason a goal replacement operation as defined in <ref type="bibr" target="#b2">[3]</ref> has to be regarded as an issue which is orthogonal to the one of the unfold/fold transformations, and which is also beyond the scope of this paper: We have studied replacement operations for CLP modules in <ref type="bibr" target="#b11">[12]</ref>.</p><p>A third relevant difference is due to the fact that since modularity is not taken into account in <ref type="bibr" target="#b2">[3]</ref>, the system introduced in that paper does not produce observationally congruent programs. As pointed out in the introduction, this issue is particularly relevant for practical applications.</p><p>Finally, one last improvement over <ref type="bibr" target="#b2">[3]</ref> is that of the applicability conditions we propose are invariant under _~-equivalence (Proposition 4.11), while the ones in <ref type="bibr" target="#b2">[3]</ref> are not: this means that in some cases the folding conditions of <ref type="bibr" target="#b2">[3]</ref> may not be satisfiable unless we appropriately modify the constraints of the clauses (maintaining ~-equivalence). Moreover, since the reference semantics in <ref type="bibr" target="#b2">[3]</ref> is an abstraction (upward closure) of the answer constraint semantics, the result on the correctness of the unfold/fold system of <ref type="bibr" target="#b2">[3]</ref> can be seen as a particular case of our Theorem 4.10.</p><p>To conclude, the contributions of this paper can be summarized as follows.</p><p>We have defined a transformation system for CLP based on the unfold/fold framework of Tamaki and Sato for logic programs <ref type="bibr" target="#b36">[37]</ref>. Here, the use of CLP allowed us to define some new operations and to express the applicability conditions for the folding operation without the use of substitutions. Moreover, our definition of folding emphasizes its nature of being a quasi-inverse of the unfolding. We hope that this will provide a more intuitive explanation of its applicability conditions. The system is then proven to preserve the answer constraints and the least N-model of the original program.</p><p>A definition of a modular transformation sequence is given by adding some further applicability conditions. These conditions are shown to be sufficient to guarantee the correctness of the system w.r.t, the module's congruence. This means that the transformed version of a CLP module can replace the original one in any context, yet preserving the computational behaviour of the whole system in terms of answer constraints. As previously argued, this provides a useful tool for the development of real software since it allows incremental and modular optimizations of large programs.</p><p>Finally, the relations between transformation sequences for CLP and LP have been discussed. By mapping logic programs into CLP programs we have shown that our transformation system is a generalization to CLP (and to modules) of the one proposed by Tamaki and Sato <ref type="bibr" target="#b36">[37]</ref>. This relation allows us to prove that, under conditions (O1) and (O4), the system by Tamaki and Sato transforms an LP module into a congruent one.</p><p>In the literature we also find less related papers presenting methods which focus exclusively on the manipulation of the constraint for compile-time <ref type="bibr" target="#b29">[30]</ref> and for lowlevel local optimization (in which the constraint solving is partially compiled into imperative statements) <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b20">21]</ref>. These techniques are totally orthogonal to the one discussed here, and can therefore be integrated with our method. On the other hand, some strategies which use transformation rules for composing complex (pure) logic programs starting from simpler pieces have been presented in <ref type="bibr" target="#b25">[26]</ref> and further discussed in <ref type="bibr" target="#b31">[32]</ref>. Also these strategies could easily be extended to CLP and integrated with our transformation rules. Transformations based on partial evaluation for structured logic programs have been studied in <ref type="bibr" target="#b6">[7]</ref>. These results however are quite different from ours, since they are not concerned with CLP, use a completely different kind of program transformation and refer to a different notion of module. * There exists a partial proof tree of A in P whose whose resultant is A +-d" []/)" and such that A +-d[]/) ~A +---d":z/)".</p><p>Proof We can now state the partial correctness result for the transformation system. Proof. To simplify the notation, here and in the sequel we refer to P1 ..... Pn rather than to M1,...,M,.</p><p>In case Pi+l was obtained from Pi by unfolding or by a clause removal operation then the result is straightforward, therefore we need only to consider the remaining operations.</p><p>We now show that if there exists a u-tree TA of an atom A with resultant R in Pi+l, then there exists also u-tree of A with resultant R in Pi (modulo -~). By Proposition 3.18, this will imply/the thesis. The proof is by induction on the size of a proof tree, which corresponds to the number of nodes it contains. Let cl' be the label clause of the root node of TA, and let us distinguish various cases.</p><p>Case 1: cl' E Pi. This is the case in which clause cl' was not affected by the passage from Pi to Pi+l. The result follows then from the inductive hypothesis: For each subtree S of TA (in Pi+l) there exists a similar subtree S' in Pi, so the tree obtained by replacing each S with S' in TA is a re-tree in Pi similar to TA.</p><p>Case 2: cl' is the result of splitting. Let el be the corresponding clause in Pi, i.e., the clause that was split. There is no loss in generality in assuming that the atom that was split was the leftmost one. Therefore the situation is the following: -cl : Ao +---CADA1,...,A, -cl' : Ao +-CA A(AI =B) AcBGA1 .... ,An where B +-CB DJD is one of the splitting clauses, and has no variable in common with cl. Since by condition (02) no open atom can be split, we have that A1 may not belong to the residual of TA, therefore there exist a subtree TAm of TA which is attached to A1. Let C +-ecDE be the label clause of the root node of TAx. With this notation the global constraint of TA has the form</p><formula xml:id="formula_17">(A = Ao) A CA A (A1 = B) A eB A (A1 = C) A ¢C A'" (A. 1)</formula><p>Now C +--ccs/~ is also one of the clauses used to split A1; by the applicability conditions of the splitting operation either C and B are heads (of renamings) of the same clause, or C = BAccAcB is unsatisfiable. Since (A.1) is satisfiable, we have that C and B must be renamings of the heads of the same clause. Since by standardization apart, the variables in cB and in B may not occur anywhere else in TA, as far as global constraint of TA is concerned, the expression (A1 = B)/~ ce is already implied by the expression (A1 = C) A cc, therefore we can eliminate (A1 = B)/~ cB from the global constraint of TA, and obtain a tree which is similar to it; in other words, by replacing the clause cl r with cl in the label of the root of TA, we obtain a tree TJ which is similar to TA. By inductive hypothesis, for each subtree TA~ of TA (and TA 1) there exists a tree T 2</p><p>Ai in Pi+l which is similar to TAt. We can assume without loss of generality that the clauses in each T 2 do not share variables with those in TA 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A~</head><p>Finally, let T 2 be the tree obtained from T 1 by substituting each subtree TA, with T 2 by Lemma A.2 we have that TA 2 is similar to TJ, and therefore to TA. Since T~ is Ai' a ~-tree of A in Pi, the result follows.</p><p>Case 3: cF is the result of a constraint replacement. From now on, let us call internal constraint of a tree T, the conjunction of all the constraints in the label clauses of T, together with the label equations of the subtrees of T. So the internal constraint is obtained from the global constraint by removing from it the label equation of the root node of T. Now, let -cF " A +--cIDA1 .... ,An, and -cl " A ~ crA1 ..... An. where cl is the clause to which the replacement was applied. Let also T~, .... ,TAn, be the subtrees of TA (which we suppose attached to A1,...,An,), cA, ..... CA,, be their internal constraints and PAt ..... /?A,, be their residuals. With this notation, the resultant of TA is By combining these derivations together (Remark A.5) we have that there exists a derivation The proof of the completeness is basically done by induction on the weight of a tree, which is defined by the following. Definition A.8. (weight) • The weight of a n-tree T, w(T), is defined as follows:</p><p>-w(T) = size(T) -1 if the predicate of A is a new predicate; -w(T) = size(T) if the predicate of A is an oM predicate. • The weight of a pair (atom, resultant), (A,R), w(A,R), is the minimum of the weights of the n-trees of A in P0, that have R as resultant. (modulo _~).</p><p>In the proof we also make use of trees which have for label clause of their root a clause of Pi but that for the rest are trees of P0. In particular we need the following. Definition A.9. We call a tree T of atom A, descent tree in Pi U P0 if * the clause label of its root node cl, is in Pi; The above definition is a generalization of the definition of descent clause of <ref type="bibr" target="#b23">[24]</ref>.</p><p>Definition A.10. We call Pi weight complete iff for each atom A and resultant R, if there is a n-tree of A in P0 with resultant R, then there is a descent tree of A with resultant __-equivalent to R in Pi U P0.</p><p>So Pi is weight complete if we can actually reconstruct the resultants semantics of P0 by using only descent trees in Pi U Po.</p><p>We can now state the first part of the completeness result. Proposition A.11. If Pi is weight complete, then (9(Mo ) C_ <ref type="bibr">(9(Mi )</ref>.</p><p>Proof. We now proceed by induction on atom-resultant pairs ordered by the following well-founded ordering ~-: (A,R) ~ (Ar, R ~) iff • w(A,R) &gt; w(A',g'); or • w(A,R)= w(A~,R~), and the predicate of A is a new predicate, while the one of W is an old one. Let A, R, be an atom and a resultant such that there exist a n-tree of A in P0 with resultant R. Since Pi is weight complete, there exists descent tree ira of A in Pi U Po with resultant R. Let also -cl : Ao +---CA DAb...An (in Pi) be the label clause of its root, -Ab... ,An, be those atoms of cl that have an immediate subtree attached to -Tal ..... TA,, be the immediate subtrees of TA (in P0) and RAt,...,RA,, be their resultants.</p><p>Case 1: cl E Pi+l. That is, cI is not affected by the transformation step. Then TA is a descent tree of A with resultant R in Pi+I tA Po.</p><p>Case 2: cl is unfolded There is no loss in generality in assuming that A1 is the unfolded atom. In fact, by (O1), the unfolded atom cannot be a n-atom, so it cannot belong to the residual of TA. Now, since Pi is weight complete, there exist a descent tree TBo of A1 in Pi tA Po, with clause d : Bo ~ eBDB1 ..... Bm (in Pi) as label clause of the root, that has the same resultant (modulo _~) of TA1.</p><p>Let T] be the partial tree obtained from TA by replacing TA1 with TBo. T] is a n-tree of A in Pi U P0; let R] be its resultant, by Lemma A.2 and the usual assumption on the variables in the clauses of the subtrees, we have that R _~ R~.</p><p>(A.6)</p><p>Let TBI .... , TB~, be the immediate subtrees of TB0, which we suppose attached to B1,...,Bm,, let also RB~...RBm, be their resultants. By Lemma A.2 there is no loss in generality in assuming that TB1 .... , TBm, are the smallest trees of P0 in their equivalence class.</p><p>Let Crest be the conjunction of the global constraints of TB~ ..... TB~,, TA~,..., TA,,, and /~ be the multiset union of their residuals; we have that </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(a.7)</head><p>Since A s is the unfolded atom, d is one of the unfolding clauses, it follows that one of the clauses of P;+I resulting from the unfold operation is the following clause: el t : Ao +--cA/~ (A1 = B0) A e~DB1 ..... Bm,A2,...,An.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now consider the n-tree T]t of A which is built as follows:</head><p>-eF is the label clause of the root.</p><p>-TB~ .... , TB~,, T~: ..... TA,, are its immediate subtrees. Its resultant is then R tt : A +--(A : Ao) A CA A (As ~-B0) A cB A Crest~F, Bm,+l .... ,Bn,,An'+l ..... An. By (A.6) and (A.7) we have that the resultant of T~ ~ is R (modulo "~). Now, in order to prove that T] ~ is a descent tree, we have to prove that conditions (a) and (b) in Definition A.9 are satisfied. Now w(A,RA) ~w(AI,RA~)+... + w(An,,RA,,) (since TA is a descent tree), &gt;/w(B1,RB~ ) +... + w(Bm,,RB m, ) + w(Az,RA2 ) +"" -k w(An,,RA,, ) (since (TA~) is a descent tree) Moreover, if d satisfies (F3) then, by condition (b) in Definition A.9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w(A1,RA, ) &gt; w(B1,RB, ) +... + w(Bm',RB~, ).</head><p>On the other hand if d does not satisfy (F3), then by Remark A.7 the predicate of Bo and A1 must be a new predicate; again, by Remark A.7 we have that cl must satisfy (F3). It follows that w(A,RA) &gt; w(A1,RA1)+'"+ w(An,,RA,,).</p><p>So, in any case, we have that w(A,RA) &gt; w(Ta,) + .. . + w(Ta,o, ) + w(T&amp;) + ". + W <ref type="bibr">(TA,,, )</ref> This proves that TJ / is a descent tree.</p><p>Case 3: cl is removed from Pi via a clause removal operation. This simply cannot happen: the constraint of cl is a component of the global constraint of TA and since the latter is satisfiable, so is the first one. Therefore cl cannot be removed from Pi.</p><p>Case 4: cl is split. Since no K-atom can be split, the split atom may not belong to the residual of TA, therefore there is no loss in generality in assuming that A1 is the split atom and that n/~&gt; 1.</p><p>Since (9(P0) --(9(Pi), we have that for i E [1,n ~] there exist a ~z-tree SA~ of Ai in Pi, which is similar to TA~. Let SA be the ~z-tree obtained from ira by substituting its subtrees TAI .... , TAn, with SAI ..... SA°,. From Lemma A.2 and the usual standardization apart of the clauses in the subtrees, it follows that SA is a ~z-tree of A in Pi and that SA is similar to TA. Since d* is a renaming of d, and since its variables do not occur anywhere else in TJ, in the above formula the subexpression (A 1 = B~)/~ c~ is already implied by the fact that the expression contains (A1 = B0)/~ @, and therefore it may be removed from the constraint. So, from (A.8) it follows that T~ is similar to irA. Now, in order to prove the thesis we only need to prove that T~ is a descent tree, i.e. it satisfies conditions (a) and (b) of Definition A.9. This follows immediately from the fact that the subtrees of TA and T~ are the same ones (and TA is a descent tree) and the fact that cF satisfies (F3) iff cl does.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 3 . 5 (</head><label>35</label><figDesc>Module's congruence). Let M1 and M2 be CLP modules. We say that M1 is (observationally) congruent to M2, M1 ~c M2 iff Op(M1 ) = Op(M2) and for every module N such that M1 ® N and M2 ® N are defined, M1 G N ~ M2 ® N holds. So M1 ~c M2 iff they have the same open predicates and, for any query, they produce the same answer constraints in any O-context. By taking N as the empty module we immediately see that if M1 ~c M2 then M1 ~ M2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>and Q2: q(X,Y) +-true r(X,Y) +-X=a. r(X,Y) +-Y=b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 3 .</head><label>3</label><figDesc>1t) (Resultants Semantics for CLP ). Let M = (P, Op(M)} be a module. Then we define (9(M) = {p(x) +--e[ziB E 6~Op(M ) I there exists a derivation trueD p(2) P~ c~B }.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>average(List, AV) ~-Av is the average of the list List cl: average(Xs, Av) ~-Len &gt; 0AAv*Len = Sum [] exchange_rates (Rates), / . ~welghted_sum(Xs, Rates, Sum), len (Xs, Len). weighted_sum(List, Rates, Sum)e-Sum is the sum of the values in the list List and each amount is multiplied first by the exchange rate corresponding to its currency weighted_sum( [ ] , 0). weighted_sum([(Currency, Amount) l Rest], Rates, Sum)+-Sum = Amount*Value + Sum' [] member ((Currency, Value&gt; ,Rates) ,2 CLP(91 )<ref type="bibr" target="#b21">[22]</ref> is the CLP language obtained by considering the constraint domain 9t of arithmetic over the real numbers. weighted_sum(Rest, Rates, Sum ~). len(List, Len) +-Len is the length of the list List len([], 0 ). len([HIRest], Len) +--Len = Len'+l ~ fen(Rest, Len').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 4 . 3 (</head><label>43</label><figDesc>Unfolding). Let cl: A +---cDH,~2 be a clause in the program P, and {//1 ~-cl zB1 ..... Hn ~-cn DB,} be the set of the clauses in P such that cA ci A (H = Hi) is @-satisfiable. For i E [1,n], let cl~ be the clauseA +-c A ci A (H = Hi)DBi,KThen unfoldin9 H in cl in P consists of replacing el by ' ' {cl I ..... cl,} in P.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>avl([] , Rates, Average, Len) +-Len &gt; 0 A Average*Len = 0 [] exchange_rates (Rates), len([], Len). avl([(Currency,Amount) IRest],Rates, Average, Len)+-Len &gt; O AAverage*Len = Amount*Value+Sum' [] exchange_rates (Rates), member((Currency, Value&gt;, Rates), weighted_sum(Rest, Rates, Sum'), len([(Currency,Amount) IRest] , Len).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>c3: avl([], Rates, Average, O)+-0 &gt; OAAverage*O = 0 [] exchange_rates (Rates). c4: avl([(Currency,Amount) IRest], Rates, Average, Len)+-Len &gt; 0 ALen = Len'+l A Average*Len = Amount*Value+Sum' exchange_rates (Rates), member (&lt;Currency, Value&gt; ,Rates) , weighted_sum(Rest, Rates, Sum ') , len(Rest, Len').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Definition 4 . 4 (</head><label>44</label><figDesc>Clause removal). Let cl : H ~--c[]B be a clause in the program P. If ~3 c Then we can remove cl from the program P, obtaining the program P~ = P\{cl}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Example 4 . 2 (</head><label>42</label><figDesc>Part 3). By applying the splitting operation to len(Rest, U) in clause c4 we obtain the following two clauses: c5: avl([(Currency,Amount&gt;] ,Rates, Average, Len) *-Len &gt; 0 A Len = I A Average*Len = Amount*Value+Sum' [] exchange_rates (Rates).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>member((Currency, Value&gt;, Rates), weighted_sum ( [ ], Rates, Sum' ), fen([], 0). c6 : avl ( [&lt;Currency, Amount&gt;, J ] Rest] ,Rates,Average,Len) *-Len &gt; 0ALen = Len'+iALen' = Len''+IA Average*Len = Amount*Value+Sum' [] exchange_rates (Rates). member (&lt;Currency, Value&gt;, Rates), weighted_sum([JIRest] , Rates, Sum'), len([JIRest], Len').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>c7: avl([(Currency,Amount&gt;] ,Rates, Average, I) ~-Average = Amount*Value [] exchange_rates (Rates). member ( (Currency, Value ), Rat e s).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>c8: avl([(Currency,Amount},JIRest], Rates, Average, Len) ~-Len &gt; 0 ALen = Len'+l A Average*Len = Amount*Value+Sum' [] exchange_rates(Rates). member(&lt;Currency, Value},Rates), weighted_sum([JlRest], Rates, SumS), len([JIRest], Len').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Definition 4 . 8 (</head><label>48</label><figDesc>Constraint Replacement). Let cl : H ~--clDB be a clause of a ~ p program P and let c2 be a constraint. If, for each successful derivation true[]B ~ d, b ~--Var(H) C1 A d +-+ ~-Var(H) C2 A d holds, then replacing cl by c2 in cl consists in substituting cl by H ~-c2E/~ in P.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Example 4 . 2 (</head><label>42</label><figDesc>Part 4). By per~rming a constrai~ replacement of Len &gt; 0 ALen = Len'+l A Average*Len = Amount*Value+Sum' by Len &gt; 0 ALen = Len'+l A Average*Len = Amount*Value+Sum' ALen' &gt; 0 we can add the constraint Len' &gt;0 to the body of clause c8, thus obtaining the clause c9: avl([(Currency,Amount),JIRest], Rates, Average, Len) +--Len &gt; 0ALen = Len'+lA Average*Len =Amount*Value+Sum' ALen' &gt; 0 [] exchange_rates(Rates). member((Currency, Value),Rates), weighted_sum([JIRest], Rates, SumS), len([JIRest], Len').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Definition 4 . 9 (</head><label>49</label><figDesc>Folding). Let P0,...,Pi, cl : A +---cA Df2,J be a clause in Pi, d :D +-CD DIYI be a clause in Pnew. i/&gt; 0, be a transformation sequence. Let also If CA []K is an instance of true ~ITI and e is a constraint such that Var(e) C_ Var(D) U Var(cl), then folding f2 in cl via e consists of replacing cl by cl I" A +--cA A eGD, J provided that the following three conditions hold: (F1) (i) "If we unfold D in cF usin 9 d as unfoldin 9 clause, then we obtain el back" (modulo ~), or, equivalently, (ii) @ ~ 3_Var(A,J, ft ) CA A e A cz) ~ 3_Var(A,Z£r ) CA A (I2I = K) (F2) "d is the only clause of Pnew that can be used to unfold D in cl'", i.e. there is no clause b : B ~--cBs£ in Pnow such that b 7£ d and cA A e A (D = B) A cB is @-satisfiable. (F3) "No self-foldin9 is allowed ", i.e. (a) either the predicate in A is an old predicate; (b) or cl is the result of at least one unfolding in the sequence Po ..... Pi.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>cl II " A +--CA A e A (D = D I) A CDDH ,J where d ~ D I i ~ i • ~--c D DH is an appropriate renaming of d. Here, by the standardization apart and the fact that Var(e) C_ Var(D) U Var(el), the variables of cD, 121 which do not occur in D, do not occur anywhere else in this clause, so, by making exwith co and H~ with /~. Therefore we have plicit (D = D'), we can identify c o that cl" ~--A ~ cA A e A cD~I2I, J.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>and (2) it follows immediately that cl" ~-cl iff 3_Var(A,y,l: 0 cA A e A co +-* ~-Var(A,J, It) CA /~ (fir = I(~)"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Example 4 . 2 (</head><label>42</label><figDesc>Part 5). We can now fold exchange_rates(Rates), weighted_sum([JlRest], Rates, Sum'), len([JIRest], Len') in c9, using c2 as folding clause. In this case, the bridge constraint e has to beXS = [JIRest] ARATES = Rates A LEN = Len' A AV = Sum'/Len'In the resulting program, after cleaning up the constraints, the predicate avl is defined by the following clauses: c7: avl([(Currency,Amount)],Rates, Average, 1)+-Average = Amount*Value [] exchange_rates(Rates), member((Currency, Value),Rates). ci0: avl([(Currency,Amount),J]Rest], Rates, Average, Len) +-Len &gt; 0ALen = Len'+lA Average*Len = Amount*Value+(Average'*Len') ALen' &gt; 0 avl([JIRest],Rates, Average',Len'), member((Currency, Value),Rates).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Theorem 4 .</head><label>4</label><figDesc>10 (Correctness). If Po ..... P~ is a transformation sequence then (a) Po ~ P,,. (b) The least ~-models of Po and P. coincide.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Proposition 4 . 11 .</head><label>411</label><figDesc>Let Po .... ,Pn and P~ ..... P~ be two transformation sequences, such that, for i C [0..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>-e be the bridge constraint, Var(e) C Var(D) U Var(cI), -cl' : A +---CA A eDD, J be the result of the folding operation. Moreover, let cl* : A* ~ c] D/£*,J* be the clause of Pn corresponding to cl in Pn, -d* : D* +--@ c~H* be the clause of P~ corresponding to d in P0. Now let e* be a constraint such that Var(e*) C Var(D*) U Var(cl*) such that -cl*': A*+--c]Ae*c]D*,J* ~-cI': A~--CAAeDD, J We now only have to show that if the applicability conditions of the folding operation are satisfied (by el, d and e) in Pn, then they are also satisfied (by cl*, d* and e*) in P~. To this end, the only delicate step is taken care of by the following observation. Observation 1. Referring to the program Pn, the clauses cl and d, and the constraint e, CA:Z~2 is an instance of trueDIYI and (F1) holds iff eA[]K is an instance of cDc]I2I and (F1) holds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Definition 5 . 1 (</head><label>51</label><figDesc>Constraint replacement for modules). Let cl : H +-cl s/} be a clause of a module M and let c2 be a constraint. If (03) For each derivation trueDB ~ dsD such that /) is either empty or contains only open atoms, we have that H +--cl Ad:~I) ~ H +--c2Ad[]D then replacing cl by c2 in cl consists in substituting cl by H +--c2 D/~ in M. In order to compare this definition with the corresponding one for nonmodular programs notice that the applicability conditions of Definition 4.8 can be restated as follows. We can replace cl with c2 in the body of cl : H +--cl DB if, for each successful derivation truesB ~ d we have that H+---clAd ~--H+-c2Ad. Now it is clear that the difference lies in the fact that here we cannot just refer to the successful derivations true DE P~* d, but we also have to take into account those partial derivations that end in a tuple of open atoms, whose definition could eventually be modified. It follows immediately that when the set of open atoms is empty, Definitions 4.8 and 5.1 coincide, while if Op(M) # 0 then this definition is more restrictive than the previous one.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Theorem 5 . 3 .</head><label>53</label><figDesc>Let Mo .... ,M~ be a modular transformation sequence. Then O(Mo ) = O(Mn ). Proof. See the Appendix. From the previous theorem and the correctness result for the resultants semantics we can now easily derive the correctness of a modular transformation sequence. Theorem 5.4 (Correctness of the modular transformation sequence). Let Mo ..... M~ be a modular transformation sequence, then Mo ~cMn Proofi Immediate from Theorem 5.3 and Proposition 3.11.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Theorem 4 . 10 .</head><label>410</label><figDesc>If Po ..... Pn is a transformation sequence, then, Po ~ Pn. 4 The fact that Mn O N is also defined follows immediately from the fact that M0 and M, contain definitions for the same predicate symbols. Proof. Note that when Op(Po) is empty, conditions (O1),...,(O4) are trivially satisfied by any transformation sequence. Since ~ can be seen as the particular case of ~c applied to modules with an empty set of open predicates, the thesis follows from Theorem 5.4. [] Example 4.2 (Part 6). Program AVERAGE can be used in a modular context. Indeed, if</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Theorem 6 . 3 .</head><label>63</label><figDesc>If Po is a logic program and Po ..... P~ is an LP transformation sequence then there exists a CLP transformation sequence P~ ..... P~ such that, for i E [0, n], Pi ~--P*.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head></head><label></label><figDesc>Now the condition (F1) is ~ ~ E-e,; Cle~ +-+ 3_e,; Gight where cle~ is if= fiA~ = t'z A/~ = gAY = ~zA2 = ~A)3 = i" and Cright is In both sides of the formula we find the equations u~ = (z, /~ = g, 2 = gz, where u),/~,2 are tuple of fresh variable and are existentially quantified, hence we can simplify (F1) to ~b?_£;z~=fAi=i~Afi=( e-~ ?_e,2z=uA)~=t'~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Proposition A. 6 (</head><label>6</label><figDesc>Partial correctness). If (9( Mo ) = (9( Mi ) then (9( Mi ) D_ C( Mi+ I )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>A +---(A = Ao)/~ c ~/~ cat A ... A can, sFAt ..... FA,,,An,+I ..... An. By Lemma A.4, the existence of TAt .... , TA,, implies that for i E [1, n t] there exists a derivation trueDAi P~+l~ CAt SPA~ (modulo --~). Since by inductive hypothesis each subtree of TA has a similar subtree in Pi, Remark A.4 also implies that, for i E [1,nq there exists a derivation which is equal (modulo _~) to Pz trueuAi ~.* CA~ C]F A~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>. ,An ~ CAt /~ .../~ CA,, EFAt ..... FA., ,An'+l,... ,An. (A.2) Now, since cl C Pi it follows that there exists a derivation trueDA ~ (A = Ao ) /~ c A eat A . . . /~ eA,, DF'At ..... F A,,,A~' +I,. . . ,An.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>•</head><label></label><figDesc>its immediate subtrees TI .... , Tk are trees in P0; • if Tb...,Tk are trees of A1 .... ,Ak and R1,...,Rk are their resultants, then (a) w(A,R) &gt;7 w(A1,R1) +... + w(Ak,Rk); (b) w(A,R) &gt; w(AbR1) +... + w(Ak,Rk) if cI satisfies (F3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head></head><label></label><figDesc>R~ ~ A +-(A = A0) A cA A (AI = B0)/~ eB A Crest []F,B~'+I ..... Bm,An'+s ..... An.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head></head><label></label><figDesc>Now let (A1 ~ Bo ; d : Bo +-caEB1 ..... Bin) be the label of the root of SA~. With this notation, the resultant of ira (and SA) has the form A ~ (A = Ao) A cA A (A1 = Bo)/~ ca A CrestDResidual. (A.8) Since d is a clause of Pi it was certainly used to split A1 in Pi. Therefore in Pi+i we find the clause cl' • Ao +--cA /~ (A1 = B~) A c~A1 ..... An where d ..... B o +--c a DB'~, ..., B m* is a renaming of d. Here there in no loss in generality in assuming that the variables of d* do not occur anywhere else in the trees considered so far. Now, let TJ be the re-tree of A in Pi+l U Po obtained by substituting cl with cF as label clause of the root of TA. From (A.8) it follows that the resultant of TJ is (--~ equivalent to) A +--(A = A0) A cA A (A1 = B0) A ca A (A1 = B~)/~ c~/~ Crest E Residual.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Corollary 6.4. Let Mo : (Po, Tr) be a logic programming module, Po,...,Pn be an LP transformation sequence and for i C[1,n]  let Mi be the module (Pi, re). If conditions (01) and (04) are satisfied then Mo ~LP ~C mn"</figDesc><table><row><cell>Proof. Immediate from Theorems 6.3 and 5.4. []</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We follow here the more recent terminology used in<ref type="bibr" target="#b19">[20]</ref>. In the original papers<ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> a derivation step was defined by rewriting in parallel all the atoms of the goal. As far as successful derivation are concerned the two formulations are equivalent. Moreover in<ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> the answer constraint was considered c (without quantification).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>Pn+l ~-P~+l.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>However, we should mention that in<ref type="bibr" target="#b36">[37]</ref> also a more general replacement operation is taken into consideration, but this operation is beyond the scope of this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>Pure CLP programs are CLP programs in which the atoms in the clauses, apart from constraints, are always of the form p(Y), where 2 is a tuple of distinct variables.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>We assume here that generic mgu's are used in the SLD derivations. If only relevant mgu's were allowed, then the syntactic equality should be replaced by variance.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors want to thank K.R. Apt, A. Bossi and the referees for their helpful comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A</head><p>In this appendix we first give the proof of Theorem 5.3 which shows that any modular transformation sequence preserves the resultants semantics. The proof, quite long and tedious, is split in two parts (partial and total correctness) and is inspired by the one given in <ref type="bibr" target="#b23">[24]</ref>.</p><p>Throughout the Appendix we will adopt the following.</p><p>Notation. We refer to a fixed module Mo = &lt;Po, Op(Mo))</p><p>and to a fixed transformation sequence Mo . . .M,.</p><p>Moreover, for notational convenience, we set n = Op(Mo)</p><p>A. <ref type="bibr" target="#b0">1</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. Partial correctness</head><p>Intuitively, a transformation is called partially correct if it does not introduce new semantic information. In our case, partial correctness corresponds to the inclusion (9(M0) ___ (9(114,) of Theorem 5.3. Before proving such an inclusion we need to establish some further notation. Definition A.1. We say that two trees T and T' are similar if they are partial proof trees for the same atom, and they have the same resultant, modulo _~. This is (obviously) an equivalence relation, so we can also say that two trees belong to the same equivalence class iff they are trees of the same atom, and their resultants are equal, modulo -~.</p><p>The next two lemmata outline some simple properties of proof trees which will be useful in the sequel. The first one states that, given a tree T, we can replace a subtree S with a similar subtree S', without altering the main properties of T. Lemma A.2. Let T be a n-tree, S be a subtree of T, and S' be a partial proof tree similar to S and such that the clauses of S' do not share variables with T. Then the tree T' obtained from T by replacing S for S' is a n-tree and is similar to T.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Straightforward.</head><p>Lemma A.3. Let T be a partial proof tree of A; let also T' be the tree obtained from T by replacing A with A' in the l.h.s, of the label equation of the root node. If A' and A have the same predicate symbol, and A' does not share variables with T, then T' is a partial proof tree of A'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Obvious. []</head><p>In other words, a partial proof tree for A is basically also a partial proof tree for any A' that has the same relation symbol of A. Of course this lemma gives no guarantee that after the substitution of A with A', the global constraint of the tree will still be satisfiable.</p><p>We need a couple of final, preliminary results. From (A.2) and the applicability conditions for the replacement operation it follows that the resultant of SA is --~-similar to the one of TA. Hence the thesis. Case 4: eF is the result of foldin 9. Let -cl : Ao +---cA[]B 1 .... B~n,A1 ..... An be the folded clause (in Pi) -d : Bo +---@:zB1,...,Bm be the folding clause (in Pncw), so we have that -eF : Ao +--cA Ae[]Bo,A1,...,A, is the label clause of the root node of TA; Let also -Bo,A1 .... ,An, be the atoms of eF that have an immediate subtree (in Pi+l) attached to in TA; this choice causes no loss of generality, in fact, by (04), B0 cannot be a g-atom, and hence it cannot be part of the residual of the root node of TA. Since (9(P0) = (9(Pi), from Proposition 3.18 it follows that there exists a g-tree SB0</p><p>of B0 in P0 which is similar to T~0 (in Pi). Because of the condition (F2), the label clause of the root of Sa 0 is an appropriate renaming of d. Let We have that R 2 = A +--etot DF, Bm,+I,... ,Bm,An'+l,... ,An, where etot is</p><p>By (F1), this reduces to</p><p>Now we show that we can drop the constraint B~ = Bo. First notice that since B~ is a renaming of B0, then B~ = Bo can be reduced to a conjunction of equations of the form x = y, where x and y are distinct variables. In the case that for some x, y, B~ = B0 implies x = y, then we have that either x = y is already implied by the constraint (AT= 1 B] = Bj) or the variables x and y do not occur anywhere else in (A.4), nor in R 2. So (A.4) becomes</p><p>On the other hand, by replacing B] with B~-in the 1.h.s. of the label equations of the root nodes of the trees SB~ .... , S~2, ' , we obtain the trees SB~ .... , SB~-,, which, by Lemma A.3, are ~-trees ofB~,...,B~,. Now let T 3 be the ~-tree of A in PiUPo which is constructed as follows:</p><p>cl is the label clause of its root, -its immediate subtrees are S~1, ..., SB~ ' (in P0) and T'A~,..-, T'A,, (in Pi). Then the residual of T 3 is precisely A *--C3otaP, Bm,+l,...,Bm,AW+I .... ,A,, where c3ot is</p><p>By this, (A.5) and (A.3), we have that T 3 is similar to TA. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.I.1. Total correctness</head><p>We say that a transformation sequence is complete, if no information is lost during it, that is (9(M0)C_ (-9(Mi). When a transformation sequence is partially correct and complete we say that it is totally correct. Before entering in the details of the proof of total correctness, we need the following simple observation.</p><p>Remark A.7. If cl is a clause of Pi that does not satisfy condition (F3) then the predicate in the head of el is a new predicate, while the predicates in the atoms in the body are old predicates.</p><p>Then, since TA is a descent tree, w(A,R ) &gt;~ w(A1,RA~ ) +... + w(An,,RA~, ).  <ref type="figure">--~</ref>). As usual we assume that the clauses in the Tit's do not share variables with each other and with those in TA. By Lemma A.2 the tree TJ ~, obtained from T~ by replacing each subtree T~j with T" is a ~-tree Aj of A in Pi with resultant R. This proves the proposition. [] We are now ready to prove our total correctness theorem. Theorem 5.3 (Total correctness). Let M0 = {P0,Op(M0)) be a module and Mo ..... Mn be a modular transformation sequence. Then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• O(Mo) = O(Mn).</head><p>Proof. We will now prove, by induction on i, that for i E [0, n],</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• (;(M0) = (;(Mi),</head><p>• Pi is weight complete.</p><p>Base case. We just need to prove that P0 is weight complete.</p><p>Let A be an atom, and R be a resultant such that there is a ~-tree of A in P0 with resultant R. Let T be a minimal ~-tree of A in P0 having R as resultant. T obviously satisfies the condition (a) of Definition A.9. Let cl be the label clause of the root of T, notice that cl satisfies (F3) iff its head is an old atom, just like the elements of its body. From the definition of weight A.8 and the minimality of T, it follows that condition (b) in Definition A.9 is satisfied as well.</p><p>Induction step. We now assume that (9(P0) = O(Pi), and that Pi is weight complete. From Propositions A.6 and A.11 it follows that if Pi+l is weight complete then (?(Po) ~-(9(Pi+l). So we just need to prove that Pi+l is weight complete.</p><p>Let A be an atom, and R be a resultant such that there is a ~-tree of A in P0 with resultant R. Since Pi is weight complete, there exists a descent tree ira of A in Pi (A Po with resultant R.</p><p>Let cl :A0 +--cA~A1,...An be the label clause of its root. Let us assume that A1 ..... An, are the atoms of cI that have an immediate ~-subtree attached to in TA, let TA~,...,TAn , be the immediate subtrees of TA and let RA1,...,R~I, , be their resultants. By Lemma A.2 there is no loss in generality in assuming that TA~ .... ,TA,, are the minimal ~-trees of A1 ..... An, in P0 that have RA, ..... RA., as resultants.</p><p>We now show that there exists a descent tree of A with resultant R (modulo -~) in Pi+l U P0. We have to distinguish various cases, according to what happens to the clause el when we move from Pi to Pi+l. Case 5: The constraint of cl is replaced. The first part of this proof is similar to the one of the previous case. Since (9(Po) = (9(Pi), we have that for i E [1,n I] there exist a 7t-tree SAi of Ai in Pi, which is similar to TA~. Let SA be the n-tree obtained from TA by substituting its subtrees TA1 .... , TA,, with SAI ..... SAn,. From Lemma A.2 and the usual standardization apart of the subtrees it follows that SA is a zc-tree of A in Pi and that SA is similar to TA.</p><p>Let CA1 ..... CAn t be the intemal constraints of SA,,... ,SA,, and PAl,...,FA., be their residuals. With this notation, the resultant of TA (and SA) is</p><p>Recall that by the assumption that the trees are standardized apart, for distinct i,j E [1,n], we have that Var(cA~ DPA~)N Var(cAj CZff~Aj)C_ Var(Ai)A Var(Aj). Then, from the existence of SAt .... , SA,, and from Remarks A. <ref type="bibr" target="#b3">4</ref>  and from (A.9) it follows that TJ is similar to TA. Now, in order to prove the thesis we only need to prove that TJ is a descent tree, i.e., that it satisfies conditions (a) and (b) of Definition A.9; but this follows immediately from the fact that the subtrees of TA and TJ are the same ones (and TA is a descent tree) and the fact that cF satisfies (F3) iff cl does.</p><p>Case 6: el is folded Let {A1 = C1,...,A,, = C,,} be the label equations of the root nodes of TAI ..... TA,,, let also Crest be the conjunction of the remaining internal equations (label equations + clause constraints) of TA,,..., TA,, ; finally, let P be the residual of TA~ ..... TA,,. We have that There is no loss in generality in assumlng that there exists an index k such that Ak .... ,Ak+m are the folded atoms, so for j E <ref type="bibr">[1,m]</ref>, Ak+j and By are unifiable atoms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R ~ A ~--(A = Ao</head><p>The result of the folding operation is then cl I : Ao +-cA A eDA1,...Ak,Bo,Ak+m+b...An'. Now notice that of the atoms of cl that are going to be folded, Ak+l,...,An, are the ones that have an immediate subtree attached to in TA; these atoms correspond to B1 ..... Bn,-k in d (we should also consider explicitly the cases when they all have or have not a subtree attached to, i.e., the cases in which n ~ &lt; k or n' &gt;~m + k. However these are easy corollaries of the general case, so we now assume that k&lt;&lt;.n t &lt; m+k). Now let TBo be the ~-tree of B0 in P0 built as follows:</p><p>~ .</p><p>~ (an appropriate renaming of d) is the label clause of its</p><p>,__ CB:ZB1, ..,Bm.</p><p>root node, -B0 = B~ is then the label equation of its root node, -TB,,..., TB,,_~ are its immediate subtrees, which are obtained, as explained in Lemma A.3, from the trees TAk+I ..... TA,, by replacing Ak+j with B} in the 1.h.s. of the label equations of their root nodes.</p><p>-B~,,_k+l .... ,B~m is consequently the residual of its root node. Finally, let TJ ~ be the ~z-tree of A in Pi+l U Po which is built as follows:</p><p>cff is the label clause if its root (and this is a clause in Pi+l).</p><p>-TA~,..., TA~_~, TBo are its immediate subtrees (in P0).</p><p>Let R" be its resultant, we have that As we did in Proposition A.6, we now show that we can drop the constraint B0 = B~. First notice that since B~ is a renaming of B0, then B0 = B~ can be reduced to a conjunction of equations of the form x = y, where x and y are distinct variables. So suppose that for some x, y, B0 = B~ implies that x = y, then either x = y is m already implied by the constraint (Aj=I Bj = Bj.), or the variables x and y do not occur anywhere else in (A.12), nor in R".</p><p>Thus Cto t can be rewritten as follows:</p><p>(A=Ao)Ac~A Bj= A</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Aj=Cj /~ _k:Cj</head><p>A Crest =1 \j=k+l m By making explicit the constraint (Aj=I Bj = Bj) and comparing the result with (A.10) we see that 7J' is a zc-tree of A in Pi+l (-JPo with resultant R (modulo _~). We now need only to prove that 7J ~ is a descent tree, i.e..it satisfies the conditions (a), (b) of the Definition A.9.</p><p>Let RB0 be the resultant of TB0. Since d is the folding clause, the predicate of B0 must be a new predicate, while the predicates of B1,... ,Bin have to be oM predicates.  &gt;/w(A1,RA,) +'" + w(Ak,RAk) + w(Bo,RBo) (by ( <ref type="formula">18</ref>)).</p><p>Thus T~ ~ satisfies conditions (a) and (b) of Definition A.9.</p><p>[]</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Introduction to logic programming</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Computer Science, Vol. B: Formal Models and Semantics</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Amsterdam and The MIT Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="495" to="574" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">On the correctness of Unfold/Fold transformation of normal and extended logic programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aravidan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Dung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-04">April 1993</date>
			<pubPlace>Bangkok, Thailand</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Division of Computer Science, Asian Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Transforming constraint logic programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bensaou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Guessarian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Workshop on Logic Program Synthesis and Transformation</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Turini</surname></persName>
		</editor>
		<meeting>4th Workshop on Logic Program Synthesis and Transformation</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Differential logic programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bugliesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbrielli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Meo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Ann. A CM Symp. on Principles of Programming Languages</title>
		<meeting>20th Ann. A CM Symp. on Principles of Programming Languages<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">359</biblScope>
			<biblScope unit="page">70</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Basic transformation operations which preserve computed answer substitutions of logic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cocco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1 and 2</biblScope>
			<biblScope unit="page">87</biblScope>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Meo0 A compositional semantics for logic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbrielli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">122</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="3" to="47" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Partial deduction for structured logic programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bugliesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lamina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programmin</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="89" to="122" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Modularity in logic programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bugliesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programmin</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="443" to="502" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A transformation system for developing recursive programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Math</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="67" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Predicate logic: a calculus for deriving programs</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI&apos;77</title>
		<meeting>IJCAI&apos;77</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="419" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A transformation system for modular CLP programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Etalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbrielli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Internat. Conf. on Logic Programming</title>
		<meeting>20th Internat. Conf. on Logic Programming<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">95</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The replacement operation for CLP modules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Etalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbrielli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Syrup. Partial Evaluation and Semantics-Based Program Manipulation, PEPM &apos;95</title>
		<meeting>ACM SIGPLAN Syrup. Partial Evaluation and Semantics-Based Program Manipulation, PEPM &apos;95</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="168" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Observable semantics for constraint logic programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbrielli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Dore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="171" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Modeling answer constraints in constraint logic programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbrielli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Internat. Conf on Logic Programmin 9</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Furukawa</surname></persName>
		</editor>
		<meeting>8th Internat. Conf on Logic Programmin 9<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fully abstract compositional semantics for logic programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gaifman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc, 16th Ann</title>
		<meeting>16th Ann<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="134" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Unfold/fold transformations of logic programs</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Shepherdson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Logic: Essays in Honor of Alan Robinson</title>
		<editor>
			<persName><forename type="first">J-L</forename><surname>Lassez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Derivation of logic programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hogger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="372" to="392" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Constraint logic programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Lassez</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-06">June 1986</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Monash University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Constraint logic programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Lassez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Ann</title>
		<meeting>14th Ann<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="111" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Constraint logic programming: A survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page" from="503" to="581" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Yap, An abstract machine for CLP(¢~)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michaylov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Symp. on Programming Language Design and Implementation ( PLDI)</title>
		<meeting>ACM SIGPLAN Symp. on Programming Language Design and Implementation ( PLDI)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="128" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The CLP(~) language and system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michayov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H C</forename><surname>Yap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="339" to="395" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Some global compile-time optimizations for CLP(~)</title>
		<author>
			<persName><forename type="first">N</forename><surname>J~rgensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michaylov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ILPS&apos;91: Proc. the Internat. Logic Programmin 9 Symposium</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Saraswat</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Ueda</surname></persName>
		</editor>
		<meeting><address><addrLine>San Diego; Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1991-10">October 1991. 1991</date>
			<biblScope unit="page" from="420" to="434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Preservation of stronger equivalence in unfold/fold logic programming transformation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kawamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kanamori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on 5th Generation Computer Systems (Institute for New Generation Computer Technology</title>
		<editor>
			<persName><surname>Proe</surname></persName>
		</editor>
		<editor>
			<persName><surname>Internat</surname></persName>
		</editor>
		<meeting><address><addrLine>Tokyo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="413" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Partial evaluation as a means for inferencing data structures in an applicative language: A theory and implementation in the case of Prolog</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Komorowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th ACM Symp. on Principles of Programmin 9 Languages</title>
		<meeting><address><addrLine>Albuquerque, NM</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="255" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Composing recursive logic programs with clausal join</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lakhotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2,3</biblScope>
			<biblScope unit="page" from="211" to="225" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Unification revisited</title>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Lassez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Deductive Databases and Logic Programming</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</editor>
		<meeting><address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">587</biblScope>
			<biblScope unit="page">525</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lloyd</surname></persName>
		</author>
		<title level="m">Foundations of Logic Programmin9</title>
		<meeting><address><addrLine>Verlag, Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A transformation system for deductive databases with perfect model semantics</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page" from="377" to="403" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The 3 r&apos;s of optimizing constraint logic programs: Refinement, removal and reordering</title>
		<author>
			<persName><forename type="first">K</forename><surname>Marriott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL&apos;93: Proc. ACM SIGPLAN Symp. on Principles of Programming Languages</title>
		<meeting><address><addrLine>Charleston,</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-01">January 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Towards an algebra for constructing logic programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>O'keefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc, IEEE Symp. on Logic Programmin</title>
		<meeting>IEEE Symp. on Logic Programmin</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="152" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Transformation of logic programs: Foundations and techniques</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Proietti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page" from="261" to="320" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Equivalence-preserving first-order unfold/fold transformation system</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="84" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Unfold/fold transformation of stratified programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="139" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Unfold/fold transformation of general logic programs for the well-founded semantics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1 and 2</biblScope>
			<biblScope unit="page" from="5" to="23" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A transformation system for logic programs which preserves equivalence</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
		<idno>ICOT TR-018</idno>
	</analytic>
	<monogr>
		<title level="j">ICOT</title>
		<imprint>
			<date type="published" when="1983-08">August 1983</date>
			<pubPlace>Tokyo, Japan</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Unfold/fold transformations of logic programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Internat. Conf. on Logic Programming</title>
		<editor>
			<persName><forename type="first">Sten</forename><forename type="middle">-</forename><surname>~d(e T~irnlund</surname></persName>
		</editor>
		<meeting>2nd Internat. Conf. on Logic Programming</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="127" to="139" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
