<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Design and Verification of SystemC Transaction-Level Models</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><roleName>Member, IEEE</roleName><forename type="first">Ali</forename><surname>Habibi</surname></persName>
							<email>habibi@ece.concordia.ca</email>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Sofiène</forename><surname>Tahar</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engi-neering</orgName>
								<orgName type="institution">Concordia University</orgName>
								<address>
									<postCode>H3K 2H7</postCode>
									<settlement>Montréal</settlement>
									<region>QC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Université de Montréal</orgName>
								<address>
									<settlement>Montréal</settlement>
									<region>QC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">Concordia University</orgName>
								<address>
									<settlement>Montréal</settlement>
									<region>QC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Design and Verification of SystemC Transaction-Level Models</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">55DA21B44349303BDC63FCC19E7A1F2E</idno>
					<idno type="DOI">10.1109/TVLSI.2005.863187</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>SystemC</term>
					<term>system-level design</term>
					<term>system-level verification</term>
					<term>transaction-level modeling</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Transaction-level modeling allows exploring several SoC design architectures, leading to better performance and easier verification of the final product. In this paper, we present an approach to design and verify SystemC models at the transaction level. We integrate the verification as part of the design flow where we first model both the design and the properties (written in Property Specification language) in Unifed Modeling Language (UML); then, we translate them into an intermediate format modeled with AsmL [language based on Abstract State Machines (ASM)]. The AsmL model is used to generate a finite state machine of the design, including the properties. Checking the correctness of the properties is performed on the fly while generating the state machine.</p><p>Finally, we translate the verified design to SystemC and map the properties to a set of assertions (as monitors in C#) that can be reused to validate the design at lower levels by simulation. For existing SystemC designs, we propose to translate the code back to AsmL in order to apply the same verification approach. At the Sys-temC level, we also present a genetic algorithm to enhance the assertions coverage. We will ensure the soundness of our approach by proving the correctness of the SystemC-to-AsmL and AsmL-to-SystemC transformations. We illustrate our approach on two case studies including the PCI bus standard and a master/slave generic architecture from the SystemC library.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>the system and its properties are defined. We used a modified sequence diagram representation to capture more precise properties description. The UML model is then mapped to an Abstract State Machine (ASM), which is a formal specification method for software and hardware systems that has become successful for specifying and verifying complex systems. ASMs provide features to capture the behavioral semantics of programming and modeling languages where large systems are modeled at a high level of abstraction allowing easier validation and verification operations. We wrote the ASM models in the AsmL language <ref type="bibr" target="#b22">[23]</ref>, which is one of the very latest languages developed for ASM <ref type="bibr" target="#b9">[10]</ref> supporting object-oriented modeling at higher level of abstraction in comparison to C++ or Java. Besides, using the AsmL Tester, from an AsmL specification, it is possible to generate finite state machines (FSMs).</p><p>To enable the integration of both the model and the properties at the ASM level, we modeled the PSL semantics in AsmL. At this level, it is possible to verify these properties using model checking. For instance, we encode the property's evaluation in every state which enables evaluating its correctness on the fly while executing the FSM generation algorithm (which is part of the AsmL tool). An incorrect property detection stops the reachability algorithms and outputs a subportion from the complete FSM which represents a complete scenario for a counter-example. Eventually, not all of the properties can be verified due to the state explosion problem. For this reason, we complement our verification methodology by integrating the properties as assertion monitors in the final SystemC design. We compile the PSL property (using the AsmL compiler <ref type="bibr" target="#b22">[23]</ref>) to C# while we translate the design from AsmL to SystemC. Both codes, Sys-temC and C#, are then combined to form a single model, thus enabling the verification of the assertions by simulation.</p><p>The objective of the verification process is not only to write assertions but to verify them. This latter task is usually performed using test vector generation tools mostly based on random processes. This kind of blind simulation does not guarantee that the assertion will be covered during the test execution. Therefore, it is very important to consider a smarter and more efficient test vector generation approach. To do so, we propose first to use static code analysis to extract a dependency relation between the design inputs and the assertion's variables. This analysis will also define for every input the range of possible values that may trigger the assertion which provides some very useful information to improve the assertion's coverage.</p><p>In order to enhance the coverage even more, we also propose to use a genetic algorithm based on a community of random generators having a variety of DNA information <ref type="bibr" target="#b5">[6]</ref>. This latter will help define the list of variables considered in the test generation, their possible values, and a weighted probability over the previous range <ref type="bibr" target="#b13">[14]</ref>. The DNA update/mutation rules will be defined according to the coverage each generator offers. At the end of the genetic procedure, we expect the final DNA to provide an identification of a generator that offers a better coverage than a random one.</p><p>The soundness of our approach relies on proving the correctness of the SystemC to AsmL and vice versa transformations. The basic concept of this proof of soundness is based on the systematic design of program transformation frameworks defined in <ref type="bibr" target="#b3">[4]</ref>. For instance, we provide a formalization of the SystemC and AsmL semantics in fixpoint based on the OO general case given in <ref type="bibr" target="#b21">[22]</ref>. Then, we prove that, for every SystemC (respectively, AsmL) program, there exists an AsmL (respectively, Sys-temC) program preserving the same properties, with respect to an observation function .</p><p>The remainder of this paper is organized as follows. Section II describes the proposed design methodology. Section III discusses the proposed verification approach. Section IV presents the proofs of correctness of our approach. Section V illustrates our approach on two case studies. Section VI discusses the related work. Finally, Section VII concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. DESIGN METHODOLOGY</head><p>Our design methodology, as displayed in Fig. <ref type="figure" target="#fig_0">1</ref>, includes two parallel paths concerning the design and its properties. We model the design in the classical way that a C++ design is modeled using UML (i.e., using use cases and class diagrams) Then, we translate the UML model to an ASM model in AsmL in order to perform model checking of certain properties. These latter are obtained from the UML sequence diagram and encoded in the PSL syntax. The verification process ends to: 1) a completion either with a success or failure of the property or 2) a state explosion. Both tasks (UML update and UML-to-AsmL translation) are repeated until all the properties pass (either proved to be correct or do not complete). Then, we compile the PSL properties into a set of C# classes, using the AsmL tool to be used as assertion monitors. The design in AsmL is, from the other side, translated to SystemC and co-integrated with the assertions for verification by simulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Modeling PSL Properties</head><p>PSL is an implementation independent language to define properties. PSL is a hierarchical language, where every layer is built on top of the layer below. This approach allows the expressing of complex properties from simple primitives.</p><p>1) UML Model: Using UML as a high level of abstraction for design showed a lot of success when applied to Software. Main proposals consider either using UML as new system-level design <ref type="bibr" target="#b4">[5]</ref> or as a top layer in combination with existent languages (such as SystemC) <ref type="bibr" target="#b30">[31]</ref>. Nevertheless, the proposals completely neglected the properties of the system (PSL-like properties in particular) while sequence diagrams, for example, include very useful information to set transaction properties for TLM in particular <ref type="bibr" target="#b12">[13]</ref>.</p><p>Unfortunately, sequence diagrams do not allow a direct mapping to PSL due to two reasons: 1) the complexity of the PSL property which may include temporal operators and 2) the need for instantiation in PSL. In fact, PSL was defined for real instances formed from objects, from the design, while the sequence diagram considers only classes. For these facts, UML will not present completely and precisely all PSL property. However, it can be used to provide a general skeleton of the property that could be refined and instantiated at the ASM level.</p><p>In order to make the UML sequence diagram more adequate for PSL representation, we introduced the following operators.</p><p>Clocks: We use the operator to specify the clock that activates the current action.</p><p>Number of Cycles: Every action can be include the information about after how many cycles the action will start executing (for, e.g., says that the action Mtd is executed for exactly five consecutive cycles).</p><p>Temporal Operators: These includes operators specifying if, for example, the action will be always executed , eventually executed , or executed Until a condition is fulfilled , etc. These, in fact, represent a mapping to the PSL temporal operators (second layer of PSL).</p><p>Sequence Operations: These includes information about the order of executing certain sequences (e.g., next and prev)</p><p>Text Output: This refers to a message that is displayed in case the action fails.</p><p>Action Duration: Certain actions are supposed to execute for a certain number of cycles (e.g., reading cycle takes four cycles). We added an operator to specify this information.</p><p>" " Operator: This specifies the set of arguments for a specific action.</p><p>Fig. <ref type="figure" target="#fig_1">2</ref> gives an example of a sequence diagram describing a PSL property saying that, if a nonblocking master sends a new request, then, in the next cycle, the arbiter will be notified. After an additional cycle, the arbitration will take place and the master starts sending. The bus is released in the fourth cycle, and a notification will be eventually sent by the slave to the bus who will forward it in the next cycle to the Master.</p><p>2) ASML Model: There are two ways to embed PSL properties into the design, either as part of the design code itself or by adding them as external monitors. We adopted the second approach, where all of the parameters of PSL properties are defined as objects. The objective of the embedding is to reuse PSL properties, as modeled in AsmL, at lower design levels since the AsmL tool can automatically compile them into a C# or. NET code, which can be executed with the concrete SystemC level or as a stand-alone module.</p><p>PSL properties are defined in a hierarchical way inspired from the hardware design modular concept. For this reason we defined the embedding in a similar structure, where all the components are defined as objects and every PSL layer extends its lower layer using the inheritance feature of AsmL <ref type="bibr" target="#b12">[13]</ref>.</p><p>Boolean Layer: This layer is the basic layer of PSL. Even though it is called the Boolean layer, it includes types other than Boolean such as integers and bit vectors. We modeled this layer in AsmL by defining classes for all types and expressions, including their actions. Our embedding is based on the semiformal semantics presented in the reference manual <ref type="bibr" target="#b0">[1]</ref> and the formal semantics definition in HOL <ref type="bibr" target="#b6">[7]</ref>. Our embedding of the PSL Boolean layer mainly includes the following.</p><p>1) Expression type class includes the basic five types: Boolean, PSLBit, PSLBitVector, Numeric, and String. Both Boolean and String types are directly inherited from the AsmL's AsmL.Boolean and AsmL.String, respectively. 2) PSL Expressions includes constructing properties using the implication and equivalence operators. 3) PSL Built Functions include all the functions defined by PSL to operate at the Boolean layer. We distinguish two actions: a action providing the previous values of a variable (e.g., prev()) and an action providing the future values of a variable (e.g., next()). Temporal Layer: PSL supports sequential extended regular expressions (SEREs). The syntax is derived from standard UNIX regular expressions and, hence, the name SERE. The curly braces around the sequence mark the beginning and ending of a SERE. In real life, the delay between two such expressions can be: 1) more than one; 2) a range; and 3) not necessarily occurring in contiguous clock cycles. PSL supports all of these requirements via its repetition operators.</p><p>Modeling the SERE feature in AsmL refers to modeling the following.</p><p>1) Sequential Expressions, where a SERE is defined as an AsmL sequence of Boolean. It offers several operations to construct, manipulate, and evaluate the SERE expression. 2) Properties including the operations necessary to create properties from sequential expressions. It also controls when and how the sequence is to be verified (i.e., the property "verify the sequence is true after states" is defined as PSL_Property.EvaluateNext(n)). Fig. <ref type="figure" target="#fig_2">3</ref> shows the example of the PSL_SERE.Evaluate(), which checks if a sequence is true in a certain path. This action is activated according to an INIT signal that must be set by the property.</p><p>Verification Layer: This layer is intended to tell the verification tool how to perform the verification process. It allows to construct assertions from properties and to specify relations between them. The embedding mainly includes the following.</p><p>1) Verification Directives to specify how the property will be interpreted (e.g., assertion or requirement). This class extends the PSL_Property class from the temporal layer. 2) Verification Unit is a compact way to include several properties together. The modeled class includes a set operations to add, remove, and update the unit's list of properties.</p><p>Modeling Layer: This layer is not used in our verification approach since it is intended for VHDL and Verilog flavors of PSL. Thus, we did not consider it in our embedding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Modeling SystemC</head><p>SystemC is built on standard C++. The core language consists of an event-driven simulator as the base. It works with events and processes. The other core language elements consist of modules and ports for representing structures. Interfaces and channels are used to describe communications. SystemC provides data types for hardware modeling and certain types of software programming as well.</p><p>1) AsmL Model: Our design model at the ASM level is purely OO where every class includes a set of parameters and methods. The particularity of this model resides in the fact that it will be used to generate an FSM using the reachability algorithm part of AsmL tool. Thus, a specific style of programming is required in addition to a precise configuration of the algorithm. This latter generates the FSM by executing the model program in a special execution environment, keeping track of the actions it performs and recording the states it visits. This process is called exploration. The FSM generation algorithm requires as input: domains, methods, actions, and variables (optional inputs are filters, action groups, and properties). The transitions in the FSM are the method calls (including argument values) in the test sequences. The methods in the model program that appear in the transitions are called actions. The states in the FSM are determined by the values of selected variables in the model program. In order for the exploration to succeed to generate the FSM, the algorithm requires: 1) initializing all of the model's objects; 2) defining a set of preconditions for every action considered in the exploration process; and 3) providing for every state variable an exploration domain.</p><p>For a model including a set of classes , where is the total number of classes in . For every class in , we denote its set of methods by and the set of members by . We defined a set of rules (called ) to guarantee the generation of an FSM representing a portion of the complete system's FSM; these include the following.</p><p>Rule : For every class in , we have to define a list of instantiations of the class. This ensures that the algorithm will not throw an exception.</p><p>Rule : The first executed method in the design must verify that all of the objects from the class domains were correctly instantiated. This ensures that the algorithm will not misbehave.</p><p>Rule : For every class in , every method in must include a list of preconditions to specify when the algorithm considers this method in the exploration process. This ensures that, in every state, we only explore the involved methods.</p><p>Rule : For every class in , domains for all members in must be inherited from AsmL types and restricted to the possible values the system can accept (in particular for inputs). This will allow exploring known types and limits the risks of state explosion.</p><p>The optimal scenario is to explore all of the methods and domains in the model; nevertheless, this is not possible all of the time due to the state space explosion. For this reason, working carefully, the domains and the set of actions is the very critical path in the FSM generation process. For illustration purposes, Fig. <ref type="figure" target="#fig_3">4</ref> shows a generic AsmL model with a method including a precondition (denoted by the require keyword) setting that the method needs the system to be initialized (SystemInit true) and that it has both variables and set to false before it can be executed. Such conditions define strictly at which state the system can execute a particular set of actions.</p><p>2) Translation to SystemC: Once the AsmL model is verified using the properties describing its behavior, we translate it to SystemC according to a set of rules to ensure that the final SystemC model preserves the original AsmL code properties. The transformation is purely syntactical, it is performed to certain rules (that we call ) that could be summarized in the following.</p><p>Rule : "Basic types": AsmL basic types are all mapped to their equivalent SystemC types (e.g., Integer to int, Byte to unsigned char). AsmL includes the same types as C++ which are used for SystemC also.</p><p>Rule : "Class Translation": this includes two separate rules for variables and methods.</p><p>Rule : "Class Members": are translated into SystemC signals having the same basic type, e.g., var m_val as Integer is translated to . Rule : "Class Methods": in AsmL, these contain two parts, with the first one defining the postconditions/preconditions for its execution and the method itself. The first part is integrated in the SystemC module's constructor. For instance, a method Send defined in AsmL with the following precondition require clk true is inserted into the SystemC module constructor area as " ". The method itself is integrated as it is in the SystemC module (we just modify the basic types according to Rule 1).</p><p>Rule : "Global Modules" are integrated in the Sys-temC's main procedure sc_main. The naming mapping is used to link different modules together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. VERIFICATION METHODOLOGY</head><p>The verification process is decomposed into two parts: 1) by model checking at the ASM level and 2) by assertion-based verification at the SystemC (C++)/C# level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Model Checking</head><p>PSL properties are modeled in AsmL as specific objects providing a unique view of the property in every system's state (we will refer to these particular object as A-Property: AsmL Property). It also simulates the design with the property as a monitor. We build the object starting from basic Boolean components, sequences, and then verification units. We encapsulate sequences in the verification unit as an A-Property which is embedded in the design. Given a set of Boolean items , and belonging to the Boolean layer, and the sequences and belonging to the temporal layer, we can define:</p><p>, and and then use a A-Property to check any PSL operation between and such as , where OP is a PSL operator (e.g., implication or equivalence ). The A-Property is built as follows.</p><p>Step 1) Add all of the Boolean items to the sequences:</p><p>Step 2) Create the property:</p><p>Step 3) Define the verification unit as an A-Property, , that includes the property This property is monitored in every state in the FSM generated by the AsmL tool and is represented by two Boolean state variables P_eval and P_value (saying, respectively, if the property can be evaluated and what the value of the property in the current state is). A violated property is detected once P_eval = true and P_value = false. We set the previous condition as filter for the FSM generation algorithm. This way, the generation stops when an error is detected. The generated portion of the state machine, at this point, can be used to identify the problem through a scenario of a counter-example. For multiple properties, the filter is set as a conjunction of all of the conditions for the separate properties. This technique minimizes radically the number of state variables (the FSM size and its generation time). A correct verification process results on the generation of the system's FSM (according the configuration file constraints).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Assertion-Based Verification</head><p>Fig. <ref type="figure" target="#fig_4">5</ref> describes our methodology to integrate and verify PSL assertions for SystemC designs, which consists of the following three main steps: 1) updating the SystemC design to interface to the assertion monitor; 2) generating the assertion as a C# code from its AsmL description; and 3) integrating the assertion into the design.</p><p>Generating the table of symbols from the SystemC design is important in order to validate the variables (names and types) that are used in the assertion. While compiling the assertion, we are concerned with, first, its syntactical correctness, and second, its semantical validity where we check the type and the naming of the assertion variables.</p><p>Once the assertion's structure is verified, we translate it to its equivalent AsmL code. In our embedding of the assertion in AsmL, we defined a one-to-one mapping between the PSL assertion and their AsmL embedding. Hence, the transformation is purely syntactical, which guarantees the correctness of the modeled assertion.</p><p>In the validation phase of the assertion structure, we also generate a list of updates required to prepare the design to integrate the assertion. For instance, the signals (variables) that are used in the assertion have to be input to the assertion monitor. For this reason, we provide the Design Updater with a list of variables as defined by their unique identifier in the table of symbols. Then, the Design Updater modifies the SystemC design to make the needed variables visible to the monitor. This transformation does not affect the behavior of the code because these variables will be accessed in a read-only mode. Once the code is updated and the assertion is generated, the Design Integrator will add the required instantiation of the assertion to bind it to the existing SystemC design modules. The assertion monitor, acting as part of the design, can do the following: 1) stop the simulation when the assertion is fired; 2) write a report about the assertion status and all its variables; and 3) send a warning signal to other modules (if required). We note that the internal code of the assertion is C# so the designer can update it or do any other functionalities that can be coded in C#.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Assertions' Coverage Enhancement</head><p>Once the assertion integrated in with the design, our next goal is to define a test generation approach that offers better coverage of the assertions. To do so, we first start by statically analyzing the design in order to define a dependency relation between the system inputs and the assertions variables. Such a relation is very useful to omit the inputs that are not affecting the assertion. It serves also to identify the required inputs and the range of their possible values that may affect the assertion. We also identify which processes need to be activated in order to get the assertion fired. Fig. <ref type="figure" target="#fig_5">6</ref> gives an overview of our methodology, including the following steps.</p><p>Step 1) Static analysis: We apply a static analysis technique to generate an abstract representation of the design modeled as graph, called hypergraph <ref type="bibr" target="#b31">[32]</ref>, that will include a representation of both the program's environment and the process's environment.</p><p>Step 2) Dependency check: From the hypergraph representation, we extract the dependency graph and the range of inputs that may affect the assertion.</p><p>Step 3) Test program generator: Using the abstract program (modeled as a hypergraph structure) and the dependency graph, we generate a reduced model containing only the units involved in the assertion.</p><p>Step 4) Initial DNA generation: Considering the list of input variables of interest for the assertion and their ranges, we create a DNA structure that will serve as starting point for the genetic algorithm.</p><p>Step 5) DNA evaluation/update: Using the initial DNA, the algorithm will update the generators' community starting from the initial DNA to obtain an optimal DNA using the assertion coverage as selection criteria.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Static Code Analysis:</head><p>In order to analyze SystemC designs statically and extract the required information to generate the "inputs/assertions variables" dependency relation, we considered an approach based on abstract interpretation <ref type="bibr" target="#b2">[3]</ref>, which is a formal technique that has proven to be efficient with object-oriented languages and large programs.</p><p>At the end of the analysis, the program is represented as a hypergraph <ref type="bibr" target="#b31">[32]</ref>, which can be interpreted as a general automata connecting its states by branches (also called hyper-branches). These branches can be seen as an extension to binary decision diagrams (BDDs), but more adapted to programs representation. We augmented this work to support the SystemC library and simulator in the form of specific classes to extract information related to SystemC processes and events from the design <ref type="bibr" target="#b15">[17]</ref>.</p><p>2) Genetic Algorithm: Genetic algorithms belong to a family of computational models inspired by evolution <ref type="bibr" target="#b19">[20]</ref>. They encode a potential solution to a specific problem on a simple chromosome-like data structure and apply recombination operators to these structures to preserve critical information. Since their introduction by Holland <ref type="bibr" target="#b19">[20]</ref>, genetic algorithms have been applied to a broad range of learning and optimization problems <ref type="bibr" target="#b28">[29]</ref>. Typically, a genetic algorithm starts with a random population of encoded candidate solutions (test generators for our case), called chromosomes. The objective is to maximize the likelihood of generating an optimal solution. This can be guaranteed by: 1) evaluating the fitness of each candidate solution in the current population; 2) selecting the fittest candidate solutions to act as parents of the next generation of candidate solutions; and 3) recombining and mutating selected parents to generate offsprings.</p><p>In our context, the search space to be explored is the state space of the system that may trigger the assertion(s) under verification. Candidate solutions are finite sequences of input ranges and probability weights. Each candidate solution is encoded by a chromosome (a finite string of bits). The information encoded in the DNA includes: 1) the list of input variables; 2) their ranges (possible values); and 3) a weighted probability to their random generation. The algorithm evaluates the fitness of the candidate by executing a test generation based on the information embedded in the corresponding chromosome. A coverage report is then generated to serve in the fitness evaluation phase.</p><p>The chromosome encoding is the most important aspect of our algorithm. During the static analysis phase, we obtain the list of variables of the program and their types. Each variable is given a unique identifier. Each type is also given a space of possible values (for example, for the type char, the range is [0..255]). The chromosome encodes the list of variables, their types, and a weight relation over the range of possible values. This latter varies according to the type and its interpretation. For every basic type, we defined a list of possible weight relations, e.g., for Integer, we use the following window relation: or for and for . This relation states that the integer variable is generated randomly in the interval with a probability of 80% and 20% inside and outside the interval, respectively.</p><p>The proposed fitness function serves to guide the genetic search toward firing the assertion's variables. Its intuitive idea is to reduce the range of possible values of the input variables and to find the best probability distribution of the random test generation that will modify the assertion's variables. This way, we maximize the assertion evaluations, since the evaluation of the chromosomes is defined as an award bonus that is proportional to the number of assertion evaluations. In order to improve the efficiency of the algorithm, we keep track of the best and worst chromosome fitness in each generation; if both fitness values become equal, we increase the mutation rate, in order to help the genetic evolution get out of local maxima. Once there is an improvement in the overall fitness, we restore the original mutation rate to continue the evolution normally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. CORRECTNESS OF THE SYSTEMC/ASML AND ASML/SYSTEMC TRANSFORMATIONS</head><p>The work of Patrick and Radhia Cousot in <ref type="bibr" target="#b3">[4]</ref> is the essence for any program transformation using abstract interpretation. The tactical choice of using semantics to link the subject program to the transformed program is very smart in the sense that it enables proving the soundness proof of the transformation, related to an observational semantics. The transformation from SystemC to AsmL, and vice versa, represents an online program transformation which corresponds to the approach described in [4, Sec. 3.9 ]. Fig. <ref type="figure" target="#fig_6">7</ref> displays a projection of that generic methodology on a SystemC subject program and an AsmL-transformed program. The same figure can be used to perform the soundness of a transformation and to construct it. In both cases, we need to define the syntax, semantics, and observation functions for both AsmL and SystemC. , where IF is a set of the virtual methods declarations, N is the number of interfaces that may be connected to the port, is an input port (provides only a Read method), SC_Out is an output port (provides only a Write method), and SC_InOut is an input/output port (provides Read and Write methods).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Systemc Fixpoint Semantics</head><p>In contrast to default-class constructors for OO languages, the SystemC module constructor SC_Ctr contains the information about the processes and threads that will be executed during simulation. , where PMth is a method process (defined as a set including the method and its sensitivity list), PTh is a thread process (accepts a wait statement in comparison to the method process), and PTh is a clocked thread process (sensitive to the clock event). Proof: (Sketch) We have to consider both cases when contains an object , instantiation of , and when it does not include any . For the second situation, the proof of the theorem is trivial considering that will be an empty trace. In the first case, the trace is not empty (let it be ). Since SystemC modules are initialized in the main program sc main before the simulation starts, there exist an initial environment, store and set of variables that define the initial trace . The rest of the traces in are interaction states of because they are obtained by applying on . Therefore, .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.3: (Completeness of</head><p>) Let be a Sys-temC module. Then Proof: (Sketch) A SystemC program satisfying the previous theorem can be constructed by creating an instance of in the sc_main function, where the initial state corresponds to the state when the module's constructor was executed. An execution of a method of corresponds to executing a method thread (setting of the events in its sensitivity list to Active), and a change of a port corresponds to updating its internal signal by the new values. Hence, it is always possible to construct both SC P and . For instance, there exist many other possible constructions involving SystemC threads or clocked threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. AsmL Fixpoint Semantics 1) Syntactical Domains: Definition 4.11 (AsmL Class: AS_C): An AsmL class is a set</head><p>, where AS_DMem is a set of the module data members, AS_Mth a set of methods (functions) definition and AS_Ctr is the module constructor.</p><p>One of the important features that we are going to use in AsmL corresponds to the methods preconditions (the Boolean proposition was verified before the execution of the method).</p><p>Definition 4.12 (AsmL Method: AS_Mth): An AsmL method is a set , where AS_M is the method's core, is a set of preconditions, is a set of postconditions and AS_Cst is a set of constraints.</p><p>Note that AS_Pre, and AS_Cst share the same structure. They are differentiated in the methods by using a specific keyword for each of them (e.g., require for preconditions). 2) Fixpoint Semantics: Similar to the notion of delta delay of SystemC, AsmL considers two phases: evaluate and update. The program will be always running in the evaluate mode except if an update is requested. There are two types of updates, total and partial (usually performed using the Step instruction).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Program Transformation</head><p>The equivalence in behavior, with respect to an observation , between the source SystemC program and the target AsmL program is required to ensure that the soundness of any verification results at the AsmL level. Our objective is to define a relation between the SystemC processes active for certain delta cycles and the set of methods allowed to be executed in the AsmL model. Hence, we will map every thread (method, sensitivity list) in the SystemC design to a method (e.g., method core or preconditions) in the AsmL model.</p><p>The SystemC observation function needs to see all the active processes at the beginning of a delta-cycle by checking for the end of the update phase.</p><p>Definition 4.17: (SystemC Observation Function: ): Let be a SystemC program, the observation function is</p><p>In the previous definition, is only tracing the initial states of a simulation cycle. For instance, the third condition ensures that the list of process ready to run is empty. Similarly, we define an observation function for an AsmL program. Definition 4.18: (AsmL Observation Function:</p><p>): Let be an AsmL program, the observation function is</p><p>Next, we define the notion of equivalence between the two observations. Although SystemC and AsmL have different environment and store structures, it is possible to ensure that they contain the same information. ) Let SC_Pg be a whole SystemC program, let be a set of inputs, and let SC_Dout be a set of outputs. Then, , an AsmL program, such that . Proof: (Sketch) The proof is done by constructing the AsmL program. For instance, for every SystemC module, we affect an AsmL class having the same data members and methods. We set the preconditions for the AsmL methods as a conjunction of the state of the events present in the sensitivity list, , of the SystemC program processes. The tricky point in the construction is when to make the updates in the AsmL program. We have two possibilities: 1) C++ variables update: whenever a C++ variable is involved in an instruction, a partial update can be applied using the notion of binders in AsmL ) Let AS_Pg be a whole AsmL program, let be a set of inputs, and let AS_Dout be a set of outputs. Then, , a SystemC program, such that .</p><p>Proof: (Sketch) Similar to Theorem 4.7, the proof is done by constructing the transformed program (in SystemC for this case). For instance, for every AsmL class, we affect a SystemC module having the same data members and methods. In the Sys-temC module, for every method, we affect a process method having as sensitivity list SC_SL the list of preconditions of the corresponding AsmL method. Updates are set whenever a</p><p>Step is found in the AsmL program. Once the set of SystemC classes defined, Theorem 4.3 ensures the existence of the transformed SystemC program. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTAL RESULTS</head><p>In order to illustrate the proposed design and verification methodology, we considered two models: 1) peripheral component interconnect (PCI) <ref type="bibr" target="#b8">[9]</ref> local bus standard and (2) an extension of the master/slave bus structure provided by the Sys-temC distribution <ref type="bibr" target="#b26">[27]</ref>. Both models include ceratin properties, such as liveness, that cannot be verified using simulation, which requires using formal verification techniques such as model checking. Moreover, we aim to evaluate the performance of the overall approach according to the system's size, which can be performed by varying the number of masters and slaves. The experiments were conducted on a Pentium IV processor (2.4 GHz) with 512 MB.</p><p>Additional case studies can be found in <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b18">[19]</ref>, and <ref type="bibr" target="#b10">[11]</ref>. In particular, in <ref type="bibr" target="#b10">[11]</ref>, we compared the performances of our approach to the RuleBase <ref type="bibr" target="#b20">[21]</ref> model checker on a lookaside interface <ref type="bibr" target="#b25">[26]</ref>. Experiments showed the performance of our approach to handle cases that classical HDL model checkers cannot support (due to state explosion problem).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Models Description</head><p>PCI boasts a 32-b-data-path 33-MHz clock speed and a maximum data transfer rate of 132 MB/s. Each PCI master has a pair of arbitration lines that connect it directly to the PCI bus arbiter. In the PCI environment, bus arbitration can take place while another master is still in control of the bus. Data are transferred between an initiator which is the bus master, and a target, which is the bus slave. PCI supports several masters and slaves and allows stopping transactions.</p><p>The SystemC master/slave bus represents a more generic bus structure including a set of masters, a set of slaves, an arbiter, and a shared bus. The arbiter is responsible for choosing the appropriate master (if more than one are connected to the bus). Two modes are supported by the bus: 1) blocking mode: data are moved through the bus in a burst-mode and 2) non-blocking mode: the master reads or writes a single data word.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Model Checking</head><p>For model checking, we consider, for both models, a set of properties describing all of the possible scenarios of transactions over the bus (e.g., reading, writing, and arbitration). The machine time (user time) needed for verifying the properties depends on the complexity of the original model as well as the property parameters. The CPU time required for the model checking of the properties of the PCI bus for different numbers of masters and slaves is given in Table <ref type="table" target="#tab_0">I</ref>. We note that the numbers of states and transitions increase exponentially as a function of the number of masters and slaves connected to the bus, which explains the need for a sharp definition of the exploration domains and active actions. Similar results for the generic master/slave case study are given in Table <ref type="table" target="#tab_0">II</ref>, where, for masters, "B" refers to blocking and "NB" to nonblocking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Assertion-Based Verification</head><p>The last column in Table <ref type="table" target="#tab_0">I</ref> shows a simulation evaluation of the PCI bus when implemented in SystemC including the assertions monitors. We display the average execution time per clock ( given in nanoseconds) as a function of the number of masters and slaves connected to the bus. This shows a very short time (few seconds) to simulate million of cycles, which offers good coverage for the assertions. In this case also, we obtained similar results for the generic master/slave model, as shown in the last column of Table <ref type="table" target="#tab_0">II</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Assertions Coverage Enhancement</head><p>In order to evaluate the proposed genetic algorithm, we considered the master/slave bus structure model and a set of ten assertions, 1 Table III compares the assertion coverage results obtained: 1) with a blind random generation; 2) in the initialization phase of the genetic algorithm (GA), i.e., just after the first DNA was generated from the static analysis phase; and 3) after 35 generations of the GA. We used simulation cycles for every generation. The coverage is measuring the percentage of test vectors that updated at least one of the variables of the as- 1 For more details, we refer the reader to http://hvg.ece.concordia.ca/Research/SoC/GeneticAlgo/. sertion. We clearly notice that the static analysis phase already offers a better initial state than starting with totally random generation. The last column in Table <ref type="table" target="#tab_0">III</ref> illustrates the average execution time per iteration of the genetic algorithm. For assertion A6, for example, the execution time required to raise the coverage from 16% for the random generation to 91% is 1722.7s.</p><p>Fig. <ref type="figure" target="#fig_16">8</ref> gives more details about the evolution of the algorithm for the three assertions (A1, A2, and A3). Typically, a genetic algorithm makes relatively quick progress in the beginning stages of evolution. We noted that there exist some phases, where the algorithm hits local maxima before mutating further, which improves its performance. We even noticed that the coverage sometimes decreases slowly from generation to generation (e.g., generation 20 for A3). This is due to the fact that the evaluation of the assertion is based on weighted random generation. In other terms, since the number of tests is finite, a generator may have two different coverage results for two different test trials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>Related work to ours concerns mainly: 1) defining system-level design methodologies using SystemC; 2) writing the formal semantics of PSL, SystemC and AsmL; 3) using genetic algorithms to enhance assertions coverage; and 4) performing program transformation from SystemC to AsmL and vice versa.</p><p>Several proposals for system-level design, in particular, <ref type="bibr" target="#b30">[31]</ref>, used a combination of UML and SystemC for SoC design in general (TLM in particular). We are not aware of any other work that considered ASM as an intermediate layer between UML and SystemC to enable model checking. Besides, we focused on extracting and defining the system properties at the early design stages (from the UML sequence diagram), which makes our study complementary to existing approaches by offering an in-design verification solution.</p><p>Genetic algorithms have already been used for a broad range of applications. The most related work to ours is that of Godefroid et al. <ref type="bibr" target="#b5">[6]</ref>, which, in contrast to other approaches, addressed in particular the exploration of large state spaces of concurrent reactive systems as defined for model checking. Nevertheless, this work was restricted to simple Boolean assertions and was based on BDDs, which is not suitable for high-level languages like SystemC. We added to <ref type="bibr" target="#b5">[6]</ref> a static analysis phase before applying the genetic algorithm. We also considered a chromosome-encoding based on weighted probability over the space of the possible values of the program variables. We are not aware of any other work where genetic algorithms have been combined with static code analysis to optimize test vector generators in order to improve assertions coverage for SystemC.</p><p>In <ref type="bibr" target="#b6">[7]</ref>, Gordon used the semiformal semantics in the PSL/Sugar documentation to create a deep embedding of the whole language in the HOL theorem prover <ref type="bibr" target="#b7">[8]</ref>. The author described how to "execute" the formal semantics of PSL using HOL to see if it is feasible to implement useful tools that work directly from the formal semantics by a mechanized proof. However, he did not provide any framework for the verification of PSL for any implementation language. Besides, he does not offer any approach to reuse the PSL properties as assertion (which is a very important feature in PSL).</p><p>Several approaches have been used to write the SystemC semantics (e.g., using ASM in <ref type="bibr" target="#b23">[24]</ref>). Denotational semantics <ref type="bibr" target="#b24">[25]</ref> are found to be the most effective, since objects can be expressed as fixpoints on suitable domains. Salem in <ref type="bibr" target="#b29">[30]</ref> proposed a denotational semantics for SystemC, but his proposal was very shallow, neglecting to relate the semantics of the whole SystemC program to the semantics of its classes. Therefore, in order to construct a transformation relation between SystemC and AsmL and to prove its soundness, we defined, in this paper, our own SystemC denotational semantics.</p><p>Regarding the program transformation, the work of Cousot and Cousot in <ref type="bibr" target="#b3">[4]</ref> is the essence for any program transformation using abstract interpretation. We used a projection of that generic approach, described in [4, Sec. 3.9] on a SystemC subject program and an AsmL transformed program can be used to perform the soundness of a transformation and to construct it. In both cases, we defined the syntax, semantics, and observation functions for both AsmL and SystemC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>In this paper, we presented a methodology to design and verify SystemC transactional models starting from a UML system specification and integrating an intermediate layer using the AsmL language. We proposed to upgrade the UML sequence diagram in order to capture transaction-related system properties. Then, both the design and its properties are modeled in AsmL to enable performing model checking. On the other hand, to cover for the state explosion problem that may result due to the system's complexity, we completed our approach by offering a methodology to apply assertion-based verification reusing the already defined PSL properties. To do so, we defined a set of translation rules to transform the design's model in AsmL to its implementation in SystemC.</p><p>In order to efficiently verify assertions in SystemC, we further apply a static code analysis technique based on abstract interpretation. This phase generates an abstracted version of the initial design modeled as a hypergraph that helps defining the dependency between the system inputs and the assertion's variables, as well as restricting the possible values of the inputs to certain ranges that may update the assertion. Although experiments showed that this approach improves the assertion's coverage, we proposed to use a genetic algorithm that optimizes the probability distribution of the inputs over the space of their possible values.</p><p>We also presented the fixpoint semantics of the SystemC library including, in particular, the semantics of a SystemC Module that we proved to be sound and complete w.r.t. a trace semantics of a SystemC program. We provided also the semantics of a subset of AsmL, and we proved the soundness and completeness of an AsmL class w.r.t. to a trace semantics of the AsmL program. Then, we proved the existence, for every SystemC program, of an AsmL program having similar behavior w.r.t. an observation function that we set to consider the traces of the system just after the update phase of the SystemC simulator. We have used this SystemC to AsmL transformation to reduce the complexity of SystemC models and enabled their formal verification using model checking and theorem-proving approaches used with AsmL and ASM languages in general.</p><p>Experimental results showed good model checking results even for complex systems such as the PCI bus standard. The final SystemC models also were running a quite fast simulation, thus enabling to offer better coverage for the whole system state space. Our genetic algorithm showed an improvement of the assertions coverage by a factor of eight in comparison to the random case. As future work in this direction, we target to optimize the genetic algorithm to improve various coverage metrics.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Design and verification methodology.</figDesc><graphic coords="2,39.60,65.34,251.00,156.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Example of a modified UML sequence diagram.</figDesc><graphic coords="3,40.62,65.30,246.00,160.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Embedding PSL SERE in AsmL.</figDesc><graphic coords="3,308.10,65.30,237.00,142.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. An example of an AsmL model.</figDesc><graphic coords="4,44.10,65.54,242.00,94.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Methodology to verify PSL assertions for SystemC designs.</figDesc><graphic coords="5,38.10,66.18,251.00,138.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Enhancing the assertion's coverage.</figDesc><graphic coords="5,308.34,65.30,236.00,145.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Online program transformation.</figDesc><graphic coords="6,302.64,65.74,251.00,131.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>1 )</head><label>1</label><figDesc>Syntactical Domains: SystemC has a large number of syntactical domains. However, they are all based on the single SC_Module domain. Hence, the minimum representation for a general SystemC program is as a set of modules. Definition 4.1: (SystemC Module: SC_Module): A Sys-temC Module is a set , where DMem is a set of the module data members, Ports is a set of ports, Chan a set of SystemC Chan, Mth is a set of methods (functions) definition, and SC_Ctr the module constructor. Definition 4.2: (SystemC Port: SC_Port): A SystemC Port is a set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Definition 4.3: (SystemC Constructor: SC_Ctr): A Sys-temC Constructor is a set , where Name is a string specifying the module name, is a default class constructor, a set of processes, and SC_SSt is a set of sensitivity statements (to set the process sensitivity list SC_SL). Definition 4.4: (SystemC Process: SC_Pr): A SystemC process is a set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Definition 4.5: (SystemC Program: SC_Pg): A SystemC program is a set, where is a set of SystemC modules and SC_main is the main function in the program that performs the simulator initialization and contains the modules declarations.2) Fixpoint Semantics: In this section, we define the semantics of the whole SystemC program, , and the SystemC module,. Then, we present the proofs (or proof sketches) of the soundness and completeness of . Definition 4.6: (Delta Delay: ): The SystemC simulator considers two phases evaluate and update. The separation between these two phases is called delta delay. Definition 4.7: (SystemC Environment: SC_Env): The SystemC environment is the summation of the default C++ environment (Env) as defined in<ref type="bibr" target="#b21">[22]</ref> and the signal environment (Sig_Store) specific to SystemC:, where Var is a set of variables, is a set of SystemC signals, and is a set of addresses. Definition 4.8: (SystemC Store: SC_Store): The SystemC store is the summation of the default C++ store (Store) as defined in<ref type="bibr" target="#b21">[22]</ref> and the signal store (Sig_Store):, where Val is a set of values such that . Let be a set of initial states, be the entry point of the main function, and be a transition relation. Definition 4.9: (Whole SystemC Program Semantics: ): Let be a Sys-temC program. Then, the semantics of is Both definitions of the semantics of process declaration and SystemC module constructor are given in [15]. In contrast to the semantics definition of an OO object in [22], a SystemC method can be activated either by the default context or by the SystemC simulator through the sensitivity list of the process. A complete definition of the semantics of a SystemC module object through the definition of a transition function , including both parts C++ related and SystemC specific functions, can be found in [Let be a SystemC module, and then its semantics can be given as Theorem 4.1: (SystemC Module Semantics in Fixpoint) Let Then, . Proof: Although the SystemC model presents some additional functionalities on top of C++, the proof of this theorem is similar to [22, Proof of Theorem 3.2]. For instance, considering the definition of and applying in order Definition of a SystemC module object in [15], [18, Theorem 2.10], and the fixpoint theorem in [2], the proof is straightforward. The last step in the SystemC fixpoint semantics is to relate the module semantics to the whole SystemC program semantics. Hence, we consider an updated version of the function abstract as defined in [22]. The new function is upgraded to support the SystemC simulation semantics, environment, and store. The complete definitions of can be found in [15]. Theorem 4.2: (Soundness of ) Let be a whole SystemC program and let . Then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Definition 4.13: (AsmL Program: AS_Pg): An AsmL Program is a set , where is a set of AsmL classes and INIT is the main function in the program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Definition 4.14: (AsmL Environment: AS_Env): The AsmL Environment is a modified OO environment , where Var is a set of variables and is as set of addresses (two addresses store the current and new values of ). Definition 4.15: (AsmL Store: AS_Store): The AsmL store is , where Val is a set of values such that . The whole AsmL program semantics , method semantics and object semantics through the definition of a transition function can be found in [16]. The AsmL class constructor can be defined according to [22, Definition 3.8].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Definition 4 .</head><label>4</label><figDesc>16: (AsmL Class Semantics: ): Let be an AsmL class, then its semantics is: is an instance of . Theorem 4.4: (AsmL Class Semantics in Fixpoint) Let Then, . Proof: (See [18]) The function is an updated version of the function abstractdefined in<ref type="bibr" target="#b21">[22]</ref>. The complete definition of is given in<ref type="bibr" target="#b14">[16]</ref>.Theorem 4.5: (Soundness of ) Let be a whole AsmL program and let . Then , Proof: (See<ref type="bibr" target="#b17">[18]</ref>). Theorem 4.6: (Completeness of ) Let be a AsmL class. Then Proof: (See<ref type="bibr" target="#b17">[18]</ref>).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Definition 4.19 (Equivalence w.r.t. ): Let SC_Pg be a SystemC program, a set of its variables, be an AsmL program and Dout_as a set of its output variables The observation function ensures that the AsmL program is mimicking the evaluate and update phases (same length of the sets). The first if condition takes care of the SystemC signals while the second one concerns basic C++ variables. Theorem 4.7: (Existence of transformed AsmL program w.r.t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>and 2) SystemC signals: all signals are updated when all methods preconditions are false. Once the set of AsmL classes are defined, Theorem 4.6 ensures the existence of the AsmL program. Theorem 4.8: (Existence of transformed SystemC program w.r.t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Theorem 4 . 9 :</head><label>49</label><figDesc>(Soundness of the transformations) Let SC_Pg be a whole SystemC program and let AS_Pg be a whole AsmL program. Then where Prop is a program's property, V_sc is a set of variables of the SystemC program, and V_as are their corresponding variables in the AsmL program. Proof: The proof is straightforward from the construction of equivalence relation in Definition 4.19.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Assertion coverage evolution as function of the population generation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I PCI</head><label>I</label><figDesc>BUS: MODEL CHECKING AND SIMULATION RESULTS</figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by the IEEE.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<ptr target="http://www.accellera.org" />
	</analytic>
	<monogr>
		<title level="j">Accellera Property Specification Language Reference Manual</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Systematic design of program analysis frameworks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Principles Programming Languages, San Antonio</title>
		<meeting>Symp. Principles Programming Languages, San Antonio</meeting>
		<imprint>
			<publisher>TX</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="269" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Abstract interpretation frameworks</title>
	</analytic>
	<monogr>
		<title level="j">J. Logic Computat</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="511" to="547" />
			<date type="published" when="1992-08">Aug. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Systematic design of program transformation frameworks by abstract interpretation</title>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Principles Programming Languages</title>
		<meeting>Symp. Principles Programming Languages<address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-01">Jan. 2002</date>
			<biblScope unit="page" from="178" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Application of UML for hardware design based on design process model</title>
		<author>
			<persName><forename type="first">R</forename><surname>Damasevicius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Stuikys</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Asia South Pacific Design Automat</title>
		<meeting>Asia South Pacific Design Automat</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="244" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Exploring very large state spaces using genetic algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Tools Algorithms Construction Anal. Syst</title>
		<meeting>Tools Algorithms Construction Anal. Syst</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Validating the PSL/Sugar semantics using automated reasoning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Formal Aspects Comput</title>
		<meeting>Formal Aspects Comput</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="306" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Melham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Cambridge Univ. Press</publisher>
			<pubPlace>Cambridge, U.K.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">PCI Special Interest Group</orgName>
		</author>
		<ptr target="http://www.pcisig.com/" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Evolving algebras 1993: Lipari guide</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Specification and Validation Methods</title>
		<meeting><address><addrLine>Oxford, U.K.</addrLine></address></meeting>
		<imprint>
			<publisher>Oxford Univ. Press</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the design and verification of the look-aside interface</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">A</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automat</title>
		<meeting>Design Automat<address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="290" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Assertion based verification of PSL for SystemC designs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gawanmeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Symp. System-on-Chip</title>
		<meeting>IEEE Int. Symp. System-on-Chip<address><addrLine>Tampere, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
			<biblScope unit="page" from="177" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design for verification of SystemC transaction level models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automat</title>
		<meeting>Design Automat<address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="560" to="565" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Toward an efficient assertion based verification of SystemC designs</title>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Int. High Level Design Validation Test Workshop</title>
		<meeting>9th Int. High Level Design Validation Test Workshop<address><addrLine>Sonoma Valley, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
			<biblScope unit="page" from="19" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m">AsmL Fixpoint Semantics. Dept. Elect</title>
		<imprint>
			<date type="published" when="2004-12">2004. Dec</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Abstract Interpretation of SystemC Designs</title>
		<imprint/>
	</monogr>
	<note>Dept</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<ptr target="www.ece.con-cordia.ca/~habibi/techrp/TR0404/" />
	</analytic>
	<monogr>
		<title level="j">Tech. Rep</title>
		<imprint>
			<date type="published" when="2004-06">Jun. 2004</date>
		</imprint>
		<respStmt>
			<orgName>Elect. Comput. Eng., Concordia Univ</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the transformation of SystemC to AsmL using abstract interpretation</title>
	</analytic>
	<monogr>
		<title level="j">Electronic Notes Theoret. Computer Sci</title>
		<imprint>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page" from="39" to="49" />
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Formal verification of a bus structure modeled in SystemC</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Halleb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Annu</title>
		<meeting>2nd Annu<address><addrLine>Montreal, QC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-06">Jun. 2004</date>
			<biblScope unit="page" from="61" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Adaptation in Natural and Artificial Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Holland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>Univ. Michigan Press</publisher>
			<pubPlace>Ann Arbor, MI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">RuleBase Formal Verification Tool (Version 1.5). User&apos;s Guide</title>
	</analytic>
	<monogr>
		<title level="j">IBM Haifa Res. Labs</title>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Anhalyze statique modulaire de langages a objets</title>
		<author>
			<persName><forename type="first">F</forename><surname>Logozzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ph.D. dissertation, Math. Comput. Scie. Dept., Ecole Polytechnique</title>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
			<pubPlace>Paris, France</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Microsoft</forename><surname>Asml</surname></persName>
		</author>
		<ptr target="Available:research.mi-crosoft.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ruf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Rosenstiel</surname></persName>
		</author>
		<title level="m">SystemC Methodologies and Applications</title>
		<meeting><address><addrLine>Norwell, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Volume B of Handbook of Theoretical Computer Science</title>
		<author>
			<persName><forename type="first">Denotational</forename><surname>Semantics</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>P. D. Mosses</publisher>
			<biblScope unit="page" from="575" to="631" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">LA-1) Interface, Implementation Agreement, Revision 1.1, Apr</title>
		<author>
			<persName><surname>Look-Aside</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network Processing Forum/Kluwer</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<ptr target="http://www.sys-temc.org" />
		<title level="m">Open SystemC Initiative</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Design for verification of a PCI bus in SystemC</title>
		<author>
			<persName><forename type="first">K</forename><surname>Oumalou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. System-on-Chip</title>
		<meeting>Symp. System-on-Chip<address><addrLine>Tampere, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
			<biblScope unit="page" from="201" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Protocol development success stories: Part I</title>
		<author>
			<persName><forename type="first">H</forename><surname>Rudin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int. Symp. Protocol Spec., Testing Verificat</title>
		<meeting>12th Int. Symp. Protocol Spec., Testing Verificat</meeting>
		<imprint>
			<date type="published" when="1992-06">Jun. 1992</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Formal semantics of synchronous SystemC</title>
		<author>
			<persName><forename type="first">A</forename><surname>Salem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design</title>
		<meeting>Design<address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03">Mar. 2003</date>
			<biblScope unit="page" from="376" to="381" />
		</imprint>
		<respStmt>
			<orgName>Automat. Test Europe Conf.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Object-oriented modeling and synthesis of SystemC specifications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Schulz-Key</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winterholer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schweizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Rosenstiel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Asia South Pacific Design Automation</title>
		<meeting>Conf. Asia South Pacific Design Automation</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="238" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Ali Habibi (S&apos;04-M&apos;06) received the Diploma degree in computer engineering from the École Supérieure des</title>
		<author>
			<persName><forename type="first">F</forename><surname>Vederine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Diplôme des Études Approfondies (DEA) in communications from École Des Ingénieures de Tunis (ENIT), in 2001, and the Ph.D. degree in electrical engineering from Concordia University</title>
		<meeting><address><addrLine>Paris, France; Tunis, Tunisia; Montréal, QC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">2000. 1999. 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
	<note>He is currently a Postdoctoral Fellow with Concordia University. His research interests include system-level verification, formal verification, and microprocessor verification</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
