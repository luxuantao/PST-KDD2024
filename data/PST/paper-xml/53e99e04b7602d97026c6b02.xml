<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Planar orientations with low out-degree and compaction of adjacency matrices</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marek</forename><surname>Chrobak</surname></persName>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Eppstein</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Columbia University</orgName>
								<address>
									<postCode>10027</postCode>
									<settlement>New York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">On leave from Institute of Informatics</orgName>
								<orgName type="institution">Warsaw University</orgName>
								<address>
									<addrLine>PKIN VIIIp</addrLine>
									<postCode>00-901</postCode>
									<settlement>Warsaw</settlement>
									<country key="PL">Poland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Planar orientations with low out-degree and compaction of adjacency matrices</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BC73C2F37ED297A8F18D6E8D2A5FE8AD</idno>
					<note type="submission">Received March 1988 Revised March 1989</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Chrobak, M., and D. Eppstein, Planar orientations with low out-degree and compaction of adjacency matrices, Theoretical Computer Science 86 (1991) 243-266.</p><p>We consider the problem of orienting the edges of a planar graph in such a way that the out-degree of each vertex is minimized.</p><p>If, for each vertex u, the out-degree is at most d, then we say that such an orientation is d-bounded. We prove the following results:</p><p>l Each planar graph has a 5-bounded acyclic orientation, which can be constructed in linear time.</p><p>l Each planar graph has a 3-bounded orientation, which can be constructed in linear time.</p><p>l A 6-bounded acyclic orientation, and a 3-bounded orientation, of each planar graph can each be constructed in parallel time O(log n log* n) on an EREW PRAM, using O(n/log n log* n) processors. As an application of these results, we present a data structure such that each entry in the adjacency matrix of a planar graph can be looked up in constant time. The data structure uses linear storage, and can be constructed in linear time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>There are two basic ways of representing a graph G = ( V, E) in a computer. The first way is to keep the list of neighbours N(v) for each vertex u E V. If ) VI = n and (E I= tn, then this representation uses 0( n + m) memory, and is very useful in many graph algorithms, especially those which involve searching a graph.</p><p>The second way is the adjacency matrix: for every two vertices u, u E V we keep a Boolean value A[ u, v] which tells us whether (u, v) E E or not. This representation uses as much as O(n*) memory, and this does not depend on the number of edges in G. The advantage of the adjacency matrix is that queries of the type:</p><p>(*) Givenu,vEV,is(u,u)EE? can be answered in time O(l), whereas this does not seem possible if we use adjacency lists.</p><p>For planar graphs, the waste of memory when the adjacency matrix is used is especially painful: of the n* entries in A, only at most 6n of them are actually used. There is also a problem with initialization of this matrix; it seems at first glance that O(n*) time is necessary to initialize A. There is, however, a solution to this problem which takes only O(n) time (see <ref type="bibr">[l,</ref><ref type="bibr">Exercise 2.121)</ref>.</p><p>In this note we show an easy way to represent a planar graph in such a way that the queries (*) can be answered in time 0( 1) and the whole data structure uses only O(n) space.</p><p>An orientation w of a graph is a function which replaces each edge (u, v) E E by an arc u + v or v + u. By degfu(v) we will denote the out-degree of v, under this orientation w (for simplicity we will avoid the subscript w). We say that w is d-bounded if for each vertex v E V we have deg+( v) s d.</p><p>The main results of the paper are:</p><p>l We prove that each planar graph has a Sbounded acyclic orientation.</p><p>It is easy to see that there are graphs which cannot have 4-bounded acyclic orientations, so this bound is optimal. We also present an algorithm for finding this orientation in linear time. l We show that each planar graph has a 3-bounded orientation, and show that it can be found in linear time. Actually, we present two different linear time algorithms for this problem. The existence of a 3-bounded orientation can be also derived from the fact that planar graphs have arboricity at most 3 (see <ref type="bibr" target="#b21">[19,</ref><ref type="bibr">12761)</ref>. l We give an optimal NC parallel algorithm for finding 3-bounded orientations in planar graphs. This algorithm works in time O(log n log* n) on an EREW PRAM and uses O(n/log n log* n) processors. Later, we also consider outerplanar graphs. We prove that each outerplanar graph has a 2-bounded acyclic orientation, and present the following algorithms: We also show that some of those results for outerplanar graphs can be extended to series-parallel graphs. Most of our algorithms do not use an embedding of the input graph. For sequential algorithms this leads to simpler algorithms. More importantly, the best known parallel algorithm for planar embedding takes time 0(log2 n) [14], so the use of an embedding would considerably slow down our parallel algorithms. These results immediately give algorithms for constructing compacted adjacency matrices: given a d-bounded orientation w of G, it is sufficient to store, for each 0, only these neighbours x of Y such that W(U, x) = v + X.</p><p>We also show that this new way of representing planar graphs is very useful in some algorithms on graphs. We concentrate on the subgraph listing problems. We show how this data structure yields linear-time algorithms for listing triangles and 4-cliques in planar graphs. It has been known before that these two probiems can be solved in linear time <ref type="bibr" target="#b22">[20,</ref><ref type="bibr">6]</ref>. However, using our compacted adjacency matrix, both problems become trivial.</p><p>Let us also point out the connection between our work and the recent paper of <ref type="bibr">Kannan et al. [ 161.</ref> They investigate the problem of labelling the vertices of a graph G in such a way that given the labels of u and v, it is possible to tell whether u and u are adjacent. Their solution for planar graphs, in our terminology, is to label u with the four-tuple (u, x, y, z), where x, y, z are neighbours of U, such that the edges (0, x), (u, y) and (u, z) are directed outwards from V, in some fixed 3-bounded orientation of G. They call it a 4-/abelling. It is obvious that these labels indeed determine the adjacency relation. The algorithms from our paper can also be applied to yield a linear-time algorithm for finding such a 4-labelling of planar graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Acyclic orientations</head><p>Theorem 2.1. Eachplanargraph G = ( V, E) has a 5-bounded acyclic orientation; such an orientation can be constructed in linear time. In order to answer query (*) we check first which off( u),f( v) is smaller. Suppose that f( u) cf( v). Then we check whether v E N+(u) by scanning the entries B[ u, i] for i from 1 to 5. Thus in at most 5 steps we can answer our query. Alternatively, we can sort the entries B[ u, i] for each u, and perform binary search. This solution requires 5n memory locations, so only 2n of them are not used. It may actually be more space-and time-efficient than lists, because we do not need pointers. It is easy to see that there are planar graphs which do not have acyclic 4-bounded orientations.</p><p>Take, for example, any planar graph with minimum degree 5. Then for each acyclic orientation there is a vertex v which has in-degree 0, so deg+( v) 2 5. Proof. The algorithm is very similar to parallel 5-colouring algorithms for planar graphs (see, for example [I l]), so we only sketch it here. The computation is divided into O(log n) phases. In phase i we find a set R of vertices of degree at most 6. Now we construct a graph H = (R, F), where (u, v) E F if either (u, v) E E or u and v have a common neighbour x such that the edges (u, x) and (v, x) are consecutive in the adjacency list of x. In the next step we compute a maximal independent set (see <ref type="bibr">[lo]</ref>). We use the first method for the first O(log* n) phases, after which we use the second method. Because at each step the number of operations to be performed decreases as the size of the graph decreases, the total number of operations is O(n). By a theorem of <ref type="bibr">Brent [3]</ref>, if these operations can be scheduled among p processors, the total parallel time will be O(n/p +log n log* n).</p><p>We perform this scheduling by keeping the names of remaining vertices and edges in an array, and periodically compacting the array to remove positions no longer holding an edge or vertex. The compaction is performed with a prefix computation NC, remains open. This question is related to a problem if a p(G)-colouring can be computed fast in parallel (p(G) is the maximum over all subgraphs G' of G, of the minimum degree of G'). This other problem was shown recently to be P-complete (see <ref type="bibr" target="#b27">[24]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Three-bounded orientations</head><p>In this section we show that planar graphs have a 3-bounded orientation. This result can be derived independently from a general fact about arboricity of planar graphs. The arboricity of a graph G, denoted by a(G) is the smallest number of edge-disjoint spanning forests, whose union is G. Nash-Williams <ref type="bibr" target="#b21">[19]</ref> proved a general fact that</p><formula xml:id="formula_0">9 a(G)=max,- p-l'</formula><p>where the maximum is over all non-trivial subgraphs of G, p is the number of vertices and q is the number of edges in H. From this formula it is easy to derive that if G is planar, then a(G) s 3. Since we can orient every forest such that the out-degree of every vertex is at most 1, this shows that every planar graph has a 3-bounded orientation.</p><p>However, the proof of <ref type="bibr" target="#b21">[19]</ref> does not seem to yield a linear time algorithm. We present below another proof of this fact, and two linear-time algorithms for this problem.</p><p>Theorem 3.1. Each p!anar graph G has a 3-bounded orientation, and it can be found in linear time.</p><p>Proof. Assume we are given an embedding of G in the plane, and let one face of the embedding be specially marked (we call this the unbounded face). Call each vertex v of G either exterior if v is on the unbounded face, or interior otherwise. We prove a stronger version of the theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 1. Every planar graph G has a 3 -bounded orientation such that for each exterior</head><formula xml:id="formula_1">vertex v, deg+( v) s 2.</formula><p>Claim 1 is proved by induction on n. There must be some exterior vertex v adjacent to at most 2 other exterior vertices. (Actually, there must be at least two such vertices. This is obvious when one realizes that the subgraph of G induced by the external vertices is outerplanar.)</p><p>Let the graph G' be the subgraph of G formed by removing v, and having as its exterior vertices, the remaining exterior vertices of G together with the neighbours of v. Then by induction G' has a 3-bounded orientation such that, for each exterior vertex w of G', deg+( w) s 2. Now we may orient the edges (u, x) between u and each of its neighbours. If x is exterior in G, we orient (v, x) from u to x; otherwise we orient it from x to v. It can be seen that the resulting orientation satisfies the properties of the theorem. We explain now how to implement the method from the proof in linear time. The algorithm consists of two phases. In the first phase we remove vertices from the graph. In the second phase we return these vertices in reverse order, and orient the edges adjacent to them.</p><p>In the first phase we keep for each vertex an information whether it is or is not exterior, and how many exterior neighbours it has. We also have a queue Q of the exterior vertices which have at most 2 exterior neighbours.</p><p>A vertex v to be removed is chosen in time O(1) by taking the first vertex from Q. When we remove v, we have to update the information stored in other vertices. Let e(v) be a Boolean variable which tells whether v is exterior or not, and let also deg'( v) be the number of exterior neighbours of v. The steps taken to remove a vertex v are as follows. Charge the time for each iteration of the inner loop to the edge (w, x), and charge the remaining time in each iteration of the outer loop to the edge (v, w). Then each edge (s, t) in the graph is charged at most three times: once when each of e(s) and e(t) become true, and once when one of s or t is removed from the graph. The total number of edges is at most 3n, so at most on charges are made, and the total time of the algorithm is O(n).</p><p>The second phase is very easy to implement in time O(n) by following the method from the proof. 0</p><p>Note that in fact the algorithm above can be used to give a linear time decomposition of a planar graph into three forests, giving another proof that the arboricity of a planar graph is at most 3. Note also that we use an embedding of G when we construct our 3-bounded orientation.</p><p>The question arises whether it is possible to find such an orientation without using an embedding.</p><p>There are two reasons for considering this question.</p><p>First, it is not clear whether the existence of a linear-time algorithm for constructing a 3-bounded orientation is a topological property of planar graphs, or whether it follows simply from their low density. Observe that the proof of Theorem 3.1 does not work for toroidal graphs, because if we take a face of a toroidal graph then each vertex on this face may have three neighbours on this face. But toroidal graphs have, asymptotically, the same density as planar graphs. Second, from the point of view of the application to compressing adjacency matrices, it would be optima1 to use a 3-bounded orientation, because then we would need only 3n entries in the adjacency matrix. It seems to us, however, that the need to find an embedding before actually computing the representation, would limit possible applications of our method. Therefore, we present now another proof of Theorem 3.1, and an algorithm which does not need the embedding.</p><p>We need some more definitions.</p><p>By nd we will denote the number of vertices of degree d. A vertex v E V will be called small if deg( v) s 18, otherwise it will be called large. A vertex u E V is reducible if it satisfies one of the following conditions: (1) da?</p><p>From the assumption that G does not have reducible vertices, we obtain that each vertex of degree 4 has at least 3 large neighbours, and each vertex of degree 5 has at least 2 large neighbours.</p><p>By counting the edges between vertices of degree 4, 5</p><p>and large vertices, we obtain that 3n,+2n,s 2 dn,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>dZlX</head><p>(2)</p><p>Then, from ( <ref type="formula">1</ref>) and ( <ref type="formula">2</ref>) we have</p><formula xml:id="formula_2">&gt; 1 (d-6)n,. da7 (3)</formula><p>This gives the contradiction by rearranging the inequality above, as follows:</p><formula xml:id="formula_3">1 (3d-18)n,+ 2 (d-18)n,&lt;o. da7 da18</formula><p>This completes the proof. 0</p><p>The idea of the algorithm is as follows: we choose a reducible vertex u, and perform an appropriate reduction. A reduction consists of removing v and possibly adding some edges between its neighbours.</p><p>We orient the graph obtained, and then we extend the orientation to the edges incident to v. The extension method will depend on the orientation of the edges added during the reduction. Let us note first the following, easy lemma. (b) (a) is false. This means, that w(t,, x) = t, + x, for all x E T\{ t,}. That is, all added edges are directed outwards from t,. Since w is 3-bounded, we must have that)T\{t,}l~3,so~N(t,)nN(v&gt;l=l or 2. In both cases there is a non-added edge (t,, z) such that z E N( t,) n N(u) and w( t,, z) = z + t,. Therefore we can proceed as follows: w(z, t,) := t, + z (that is, we reorient (z, t,)), w( c,, v) := t, + z), w( z, u) := z+ z) and for all XE N(v)\{t,, z} do w(x, u):= zl*x.</p><p>An example of a reduction and an extension is shown in Fig. <ref type="figure" target="#fig_9">1</ref>. We note now the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.4. Let G' be a graph obtained from G by applying one of the reductions above. Then,</head><p>(i) ifG is planar then so is G'; (ii) if w is 3-bounded on G', then it is also 3-bounded on G.</p><p>Proof. The first part of the lemma is obvious, since the edges we add can be drawn through the region we obtain after removing v, and they do not cross because they all have a common endpoint t,. So let us concentrate now on (ii). We have three cases, corresponding to the three reductions above. The case when deg( v) s 3 is obvious. The case when deg( v) = 4 is also easy. No matter what the orientation of (t,, x) is, we will have at least one edge oriented into does not increase. This is because we remove at least one outwards oriented edge, so even though we reorient (t,, z), the total change of deg'(t,,) cannot be positive. 0</p><p>Note that the reductions above can be applied to any vertex of degree at most 5. This gives an easy O(n') algorithm for finding a 3-bounded orientation, because each reduction and extension can be implemented in time O(n). The difficulty is in finding the vertex t,, because we need to choose t,. such that it has at most 2 common neighbours with v. It does not seem possible to do it faster than in time O(n), unless one uses an adjacency matrix, but this leads to a vicious circle, considering the applications we have in mind. A way around this is to put some restrictions on the vertices we reduce, as shown in the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.5. lf v is a reducible vertex, then the reduction of v, and the extension of w can be done in time 0( 1).</head><p>Proof. Consider first a reducible vertex v of degree 4. The vertex t, can be found as follows: let x, y E N(v) be small. If one of them has at most two common neighbours with v, then let t, be this vertex. Otherwise, take t, to be any vertex in N(v)\{x, y}. By planarity, if z is the fourth neighbour of v, t, and z cannot be adjacent.</p><p>If deg( u) = 5, look at the four small neighbours of v. By Lemma 3.3, at least one of them must have at most two common neighbours with v. Cl</p><p>Now we can describe the algorithm. We maintain a queue Q which contains all reducible vertices in G. The algorithm consists of two phases. In the first phase we perform the reductions on G, until G is empty. We have also a stack S, on which we store the information about the applied reductions, sufficient to undo them in the second phase. Clearly, O(1) space per reduction suffices. In the second phase we take the reductions from S, so that they will be considered in reverse order, undo them and extend gradually the current orientation.</p><p>The vertex to be reduced can be found in time O(1) by taking the first vertex from Q. The reductions and extensions cost time O(1) each. Therefore, to prove that the algorithm can be implemented in time O(n) we need to show that the total time of updating Q is also O(n).</p><p>Let Update(x) be the following procedure:</p><formula xml:id="formula_4">if x is reducible then ifx&amp;QthenQ+Qu{x} else if x E Q then Q +-Q\(x)</formula><p>While executing the reduction at IJ we update the information about Q, by looking at all vertices which have to be put into, or removed from Q. Note that the only vertices whose degree changes during the reduction are the neighbours of v. Several things can happen:</p><p>l A vertex x E N(u) had deg(x) &gt; 5 but now deg(x) s 5. Clearly, x may now be reducible.</p><p>l A vertex x E N(u) had deg(x)s 5, but now deg(x)&gt; 5. Then, we may have to remove x from Q.</p><p>l A vertex x E N(v) was large, but now it is small. If x has a neighbour z of degree at most five, then z may have become reducible, and we have to put it in Q.</p><p>l A vertex x E N(v) was small, but now it is large. Then we may have to remove one of its neighbours from Q. Therefore we need to look at small neighbours of v, and their neighbours of degree at most five. We do the following:</p><p>for each x E N(v) do if x is small or x was small before reducing v then begin Update(x); for each y E N(x) with deg( y) s 5 do Updufe( y) end By the consideration above, this will ensure that Q contains exactly those vertices which are reducible. It is easy to see that the procedure above takes only 0( 1) time. So, finally, we obtain the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3.6. There is an O(n)-time algorithm which jinds a 3-bounded orientation in a planar graph, and does not use an embedding of this graph.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A parallel algorithm for 3-bounded orientations</head><p>Before we present the algorithm, we need to prove a combinatorial result about the distribution of degrees in planar graphs. The idea of the algorithm is similar to that of the second sequential algorithm from the preceding section. This time, however, we must reduce a linear number of vertices simultaneously.</p><p>Therefore we need a more relaxed notion of reducibility, and an appropriate stronger version of Lemma 3.2.</p><p>We will now redefine slightly the notions of small and reducible vertices. A vertex v E V will be called small if deg(v) G 25. Also, let us call a vertex reducible if it satisfies one of the conditions (rl), (r2), r(3), or the additional condition below:</p><p>(r4) deg( u) s 6 and all neighbours of u are small.</p><p>We will use the following theorem. Using Euler's formula, and some simple rearrangements similar to those in the proof of Lemma 3.2, we obtain dll, (6 -dh 2 dlE, (d -61%</p><p>(4)</p><p>By counting the edges between non-reducible vertices of degree 4,5,6, and large vertices, we obtain 3n",+2n',+ri,G C dn,.</p><p>(5) da25</p><p>Using ( <ref type="formula">4</ref>) and ( <ref type="formula">5</ref>), we proceed as follows:</p><p>21~R(~21n,+17n2+13n,+9fi,+5fi5+3ii, The above inequality directly implies the lemma. 0</p><p>The general idea of the algorithm is to perform some reductions on the graph such that it will eventually become empty. Reductions consist of removing some vertices, and possibly adding some edges between the neighbours of removed vertices. In the second phase, the removed vertices are returned to the graph in reverse order, and the current orientation is extended to new edges. The method of extending the orientation depends on the applied reduction. The reduction and extension methods for vertices of degree at most 5 are the same as in the second algorithm from the preceding section. We show only how to reduce vertices of degree 6. (cl) (u, 0) E E; (~2) there is a small vertex x E N(u) n N(v); (~3) there is a vertex x E N(u) n N(v) such that the entries in the adjacency list of x corresponding to edges (x, U) and (x, v) are consecutive. Intuitively, the edges of X correspond to possible conflicts in the reductions in G. So to avoid conflicts, we must execute only reductions belonging to an independent set in X. We now show that, if we do this, the resulting algorithm will be correct. Proof. Correctness could only be violated if two reductions or extensions attempted to perform an operation on the same edge. All edges involved in extensions and reductions have both endpoints either u itself or a neighbour of U, so if an edge has a small endpoint then (cl) or (~2) will prevent any conflict in this case. The only remaining possibility is that two degree-4 vertices attempt to add the same edge, in each case between two large vertices. But this would mean that the two vertices are non-adjacent, each has two adjacent (small) neighbours, and both are adjacent to the same pair of (large) vertices. But this is not possible in a planar graph.</p><p>Finally, condition (~3) ensures that no memory conflict can occur in updating the adjacency lists of each vertex.</p><p>!Z</p><p>The following lemma ensures that restricting our reductions to an independent subset of X still allows us to perform many reductions at once. Proof. Since IRl =O(n), it is sufficient to show that )I) = @(JR\). This fact follows easily from the observation that the maximum degree in 2 is at most 6(1+24)=150. q</p><p>Now we are ready to present the algorithm. A similar analysis shows that each iteration in the second phase costs time O(1). cl</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Outerplanar graphs</head><p>In this section we consider the outerplanar graphs. An outerplanar graph is a planar graph with the additional requirement that it has an embedding such that all vertices are on the same face. We first prove the following.</p><p>Using ( <ref type="formula">6</ref>) and ( <ref type="formula">7</ref>), we proceed as follows: lO)I+ lOn,+7n,+4h,+8fiz, 2 ; nd+3(3n,+2n,+n,)-4(&amp;+2&amp;) d=l This completes the proof. 0</p><p>The algorithm is almost identical to the one from the preceding section, so we only sketch it here. As before, we reduce only reducible vertices. We define a conflict graph ZX, find a maximal independent set 1 in 2, and execute only the reduction for vertices in I. It is not hard to see that the lemmas corresponding to Lemmas 4.2, 4.3 and 4.5 are also true. This yields the following theorem. Let us now consider acyclic orientations.</p><p>It is easy to see that each outerplanar graph has a linear number of vertices of degree at most 4. Following the idea of the algorithm for the 6-bounded acyclic orientations in planar graphs, we obtain the following result. a given vertex U. It is easy to see that there is at most one region around u, such that its father in d is not a region around u, because otherwise we would have a contradiction with the fact that d is an in-tree. Therefore, in d the regions around u correspond to two paths meeting at p (one of these paths may be empty). Let us look at some region q around U. Suppose that q f p. This means that the successor of q, say r, is also a region around u. Let (u, y) = e,,. If (u, s) is the other edge from q incident to U, then, according to the algorithm, we will have w(u, s) = s+ u.</p><p>Therefore all edges incident to U, except these which are on region p, will be directed To complete the proof we need to make yet two observations. First, all 4-cliques will indeed be listed. Consider some 4-clique {v, x, y, z}, and let u be the vertex which was put first into Q. Then this clique will be listed when v is removed from Q. This also shows that this clique will be listed only once.</p><p>Second, observe that we also have to update our compacted adjacency matrix when we remove v. This is easy to do if we also have adjacency lists: we remove all entries at the row v, and for all neighbours</p><p>x E N(v) we remove v from the row ofx. q</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Final remarks</head><p>In this paper we have presented sequential and parallel algorithms for orienting edges in a planar graph in such a way that the out-degree of each vertex is bounded by a constant: 5 or 6 in case of acyclic orientations, and 3 in case of arbitrary orientations.</p><p>Our sequential algorithms are optimal; they run in linear time. The parallel algorithms are also optimal, and they do not need the input graph to be given with an embedding.</p><p>For outerplanar graphs, the most interesting fact, in our opinion, is that it is possible to compute in NC an optimal, that is 2-bounded, acyclic orientation. Actually, the algorithm we presented runs in time O(log n) with O(n) processors, so it is almost optimal. It would be very interesting to find fast parallel algorithms for better acyclic orientations of planar graphs, that is at least 5-bounded. Unfortunately, the technique we use for outerplanar graphs does not seem to apply in more general cases.</p><p>As already noted, these bounded orientations can be applied to compact the adjacency matrix of planar graphs. This work was motivated by the paper of <ref type="bibr">Chiba et al. [4]</ref>, who present an 0( n log n)-time algorithm for finding large independent sets in planar graphs. The main drawback of this algorithm is that it uses an adjacency matrix, so it requires 0(n2) space. Unfortunately, the way of compacting the adjacency matrix we present is not yet sufficient to reduce the space requirements in their algorithm, because their algorithm performs vertex contractions during its execution, and it is not clear how these contractions can be done with such a compacted adjacency matrix. This problem was solved in [6] by a different method, which also reduces the total time of the algorithm to O(n).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>l</head><label></label><figDesc>We give an optima1 NC parallel algorithm for finding 6-bounded acyclic orientations in planar graphs. The algorithm works in time O(log n log* n) on EREW PRAM and uses O(n/log n log* n) processors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>l</head><label></label><figDesc>An optimal parallel EREW algorithm for finding a 2-bounded orientation which works in time O(log n log* n) on O(n/log n log* n) processors. l A parallel CRCW algorithm for finding an acyclic 2-bounded orientation which works in time O(log n) on O(n) processors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>be computed by the following algorithm: for i + 1 to n do begin choose v E V with deg( v) 4 5; f(u) + i; remove z7 from G end By Euler's formula G always has a vertex of degree at most 5, so we can always find u in the for loop. The function f computed above determines the acyclic orientation in the following way: given (u, V) E E, let w( u, v) = u -+ u if f( u) &lt;f(v), and u + u otherwise. At the moment we remove ZJ, it has at most 5 neighbours, and they will be assigned numbers greater than f(v); therefore the resulting orientation is 5-bounded. It remains to show that the algorithm above can be implemented in time O(n). To do this, we use a queue Q in which we keep all vertices in G of degree at most 5. The vertex 21 can be found in time O(1) by taking the first vertex from Q. When we remove u we have to update Q: look at all the neighbours of ZI, and if any of them has degree at most 5 after removing v and does not belong to Q, then add it to Q. This takes time O(1). Therefore the whole computation takes time O(n). 0 Using Theorem 2.1 we can represent a planar graph in the following way. Compute the function f as in the proof of Theorem 2.1, and let N+(v) denote the set of descendants of v under the orientation determined by f: Represent G by an n x 5 array B such that B[ v, 1 . . .5] contains the list of the vertices in N+(v). This representation can be computed in linear time, as in the proof of Theorem 2.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>I</head><label></label><figDesc>in H. Since the maximum degree in H is O(l), 11) =n(n). Finally, we remove all vertices in 1, and each ZJ E I is assigned the number f(v) = i. The orientation is determined from f as in the sequential case. The time for each phase is dominated by the computation of the maximal independent set I. This can be done in either of two similar ways, one taking time O(log n) with O(n/log n) processors, and the other taking time O(log* n) with O(n) processors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>[</head><label></label><figDesc>17], each iteration of which takes time O(log n) and uses O(n) operations. Again the total number of operations is O(n). If we perform these compactions at appropriately chosen intervals, the compactions will also take a total time of O(log n log* n), and we can use Brent's theorem to perform the algorithm with only 0( n/log n log* n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>G +-G\(v); for each w E N(v) do begin deg'( w) + deg'( w) -1; if e(w) = false do begin e(w) + true; for each x E N(w) do begin deg"(x) + deg"( w) + 1; if deg'(x) 2 3 and x E Q then Q + Q\(x) end; end; if deg'( w) s 2 and w F? Q then Q + Q u {w} end Let us now analyse the complexity of this algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>(</head><label></label><figDesc>rl) deg(v)53; (r2) deg( u) = 4 and ~1 has at least 2 small neighbours; (r3) deg(v) = 5 and u has at least 4 small neighbours. Before describing the algorithm, we prove the following lemma. Lemma 3.2. Each planar graph G has a reducible vertex. Proof. The proof is by contradiction. Suppose that G does not have reducible vertices. Therefore, nd = 0 for d = 0, . . . ,3. From Euler's formula we have m &lt; 3n, which after substituting n = C,_, nd and m = $2, ;-4 dn,, and some simple rearrang-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Lemma 3. 3 .</head><label>3</label><figDesc>Let v E V. Then there are at least two vertices x, y E N(v) such that (N(x)n N(v)(~2 and (N(y)n N(v)(~2. Proof. This follows from the observation that the subgraph of G induced by the vertices in N(v) is outerplanar. q Now we describe the reduction and extension methods. We have three cases, depending on the degree of v. (1) deg( v) s 3. Reduction: Remove v from G. Extension: Add v to G. For each edge (v, x), set w(v, x) := v + x.(2) deg( u) = 4. Reduction: Find a vertex tL. E N(v) such that 1 N( t,) n N(v)] s 2.Remove v, and add an edge (t,, x) for some x E N(v)\N(t,).Extension: Add v to G. Suppose that w( tu, x) = t, + x (the other case is symmetric). Set w ( to, v) := t, + v. For all s E N(v)\{ t,}, set w (s, v) := v + s. (3) deg( u) = 5. Reduction: Find a vertex t, such that N( t,) n N(v)1 s 2. Remove v, and add edges (t,, x), for all x E N(v)\ N( t,). Extension: Add v to G. Let T = N(v)\N(t,). Therefore T contains t, and all vertices x joined to t, by added edges. We have some cases now. (a) Two of the vertices in T have an added edge directed outwards from it. Let x and y be these vertices. Then, set w(x, v) := x + v, w( y, v) := y + v, and for all SE N(v)\{x, y} do o(s, v):= v+s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. An example of a reduction and extension. (a) A reducible vertex v before a reduction. (b) After the reduction. (c) After orienting G'. (d) After extending the orientation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Lemma 4.1. If R is the set of reducible vertices in G, then (RI&gt; n/21. Proof. The proof is similar to the one for Lemma 3.2. It is sufficient to consider only connected graphs, so n, =O. Let us denote by fid the number of reducible vertices of degree d, and by Gd the number of non-reducible vertices of degree d. Clearly, rid = nd for d = 1,2,3, and nd = fid + &amp; for d = 4,5,6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>arises when we remove vertices which have a common neighbour, not necessarily small. Say, u and v are reducible and x E N(u) n N(u). When we remove u and ZI we need to update the adjacency list at x. More specifically, we need to remove the entries corresponding to u and ZI. But this obviously causes a problem when these entries are consecutive. Finally, two different reductions might attempt to add the same edge to the graph. Therefore we need to choose the set of vertices to be reduced very carefully. By a conflict graph we will mean a graph X = (R, F), where (u, II) E F if one of the following conditions holds:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Lemma 4. 4 .</head><label>4</label><figDesc>Let I be an independent set in X If we execute the reductions from I in parallel, they remain correct and no memory conflict occurs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Lemma 4. 5 .</head><label>5</label><figDesc>Let I be a maximal independent set in 2. Then iI/= O(n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>for kc 1</head><label>1</label><figDesc>to c log n do begin identify the set R of reducible vertices; construct the conflict graph 32 = (R, F); c log n down to 1 do begin Zt{u(nr(u)=k}; for each ~1 E I do parallel extend the orientation w at u end Theorem 4.6. There is a parallel EREW PRAM algorithm, which computes a 3bounded orientation of a planar graph G, and it runs in time O(log n log* n) with O(n/log n log* n) processors. Proof. By Lemma 4.1, if c is a large enough constant, the graph will be exhausted after c log n steps. As in the algorithm for acyclic 6-orientation, the computation of maximal independent sets can be performed in time O(log* n). So it is sufficient to show that the remaining steps in each iteration can be performed in time O(1). During the algorithm we have processors assigned to each vertex, and to each entry of adjacency lists in the representation of G. Consider one iteration of the reduction phase. We need O(1) time for finding R. The construction of X can be also done in time O(1) by the processors assigned to the reducible vertices. This can be achieved by coordinating their scanning the adjacency lists of their small neighbours. After computing the independent set Z, each vertex o E I can safely execute its reduction independently of the others, in constant time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Theorem 5.3. A 2-bounded orientation in an outerplanar graph G can be found in time O(log n log* n) on an EREW PRAM with O(n/log n log* n) processors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Theorem 5. 4 .</head><label>4</label><figDesc>Fig. 2. An example of an outerplanar graph G (thick lines) and its dual fi (thin lines) after orientation. The root of d is denoted by r.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>into U. This implies that deg+( u) d 2. A similar argument shows that deg+(z) = 0. Consider now the complexity of this algorithm. Finding the embedding and the tree Y of 2-connected components costs time O(log n), using the algorithm from [7,22]. In Orient( C', z), construction of D(G) and d can be done in O(log n) time, if the embedding is already computed. Orienting the edges around a region also can be done in time O(log n). Therefore the total time complexity is O(log n). 0 6. Series-parallel graphs In this section we show that the results from the previous section can be generalized to series-parallel graphs. The class of series-parallel graphs contains graphs G in Theorem 7.1. The algorithm above lists all 4-cliques in a planar graph, and it works in time O(n). Proof. Let v be a vertex chosen at some iteration from Q. We have O(1) triples of neighbours of v to check. Using our compacted adjacency matrix, each test costs time O(1). So in time O(1) we list all 4-cliques containing v at this phase. (Some of the cliques containing v might have been already listed before, though.)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>We would like to thank the referee for pointing out several references, and suggesting that our results for outerplanar graphs can be extended to series-parallel graphs.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>** Work partially supported by NSF grants DCR-U-11713 and CCR-86-05353.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reduction:</head><p>Remove u from the graph. Find a small vertex 1, E N(U) such that (N(v)nN(t,)l~2.</p><p>Add all edges (t,,x) for x~N(u)\N(t,). Extension: There are four cases. In each case we find three edges (0, x) to direct as x + u; we direct the re;naining three edges (~1, y) as u + y.</p><p>(a) Three of the edges (t,,, x) added in the reduction are directed x+ t,,. Then for each such x we direct the edge (u, x) as x + u. (b) Two added edges (t,,x) are directed x+ t,. For both such x we direct the edge (u, x) as x+ v, and we direct the edge (v, tc) as t, + u. (c) One added edge (t,,, x) is directed x + t,. We direct the edge (x, u) as x+ u, and the edge (v, t,) as t, + u. In addition, since t, is adjacent in the reduced graph to all 5 neighbours of u, it can only have 3 out-edges among these adjacencies, so one edge (f,, z) that was not added in the reduction must also be directed as z+ t,.. We reverse the orientation of this edge and direct the edge (u, z) as z + u. ' (d) All added edges (t,,, x) are directed t, +x. Then t,. must be adjacent in the unreduced graph to exactly two neighbours z of v, and both edges (t,, z) must be directed (z, t?). We reverse the orientation of both edges and direct both edges (v, z) as z-+ v. In addition we direct the edge (t,, v) as t,. + u.</p><p>We first note the following lemma. Proof. Part (a) follows as in the proof of Lemma 3.4.</p><p>For part (b), we need only consider the new extensions for degree-6 vertices. First note that each neighbour of u other than t, has its out-degree unchanged by the extension.</p><p>Also, u itself is given in-degree 3, and therefore out-degree 3. Finally, each edge for which we change the orientation to be away from t, is balanced by an edge directed from t,. in the reduced graph which no longer exists in the unreduced graph. Therefore the out-degree at t,. also remains at most 3, and the lemma follows.</p><p>q</p><p>Before presenting the whole algorithm we observe the following.</p><p>Lemma 4.3. If v is a reducible vertex, then the vertex t,. can be found in time O(1).</p><p>In the algorithm we will attempt to reduce many reducible vertices. The problem is that some of the reductions might conflict one with another. For example, we cannot, in general, apply a reduction to adjacent vertices. A more subtle problem arises when we execute reductions of vertices u and v such that t, = t,. Then it may happen that u and v have another common neighbour x, and in the extension procedure, u will try to reorient (t,, x), while the extension at v does not need it. Now we will present a parallel algorithm for finding a %-bounded orientation, not necessarily acyclic. The algorithm is very similar to the 3-orientation algorithm for planar graphs.</p><p>We first redefine the notion of reducibility. for two such regions p, q, we have (p, q) E F iff the regions p and q have a common edge. This edge will be called the edge dual to (p, q), and denoted by e,,q. The relationship between an outerplanar graph and its dual was studied in <ref type="bibr">[9]</ref>. The following fact is well known. let X and Y be, respectively, the paths from t to x and y, along p; orient the edges in X from t to x; orient the edges in Y from t to y; if p contains z then orient (z, z') from z' to z end Note that each region p orients all edges on this region, excep't the edge dual to (p, q), where q is the father of p. This edge e,,,q will be oriented by q. In Fig. <ref type="figure">2</ref>, the reader can find an example of an outerplanar graph G, its dual 6, and a relationship between 6 and the orientation of G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5.6. There is a parallel CRCW PRAM algorithm which jinds an acyclic Z-bounded orientation in an outerplanar graph, and which runs in time O(log n) on 0 ( n ) processors.</head><p>Proof. First we prove the correctness. As already mentioned above, it is sufficient to prove the correctness of the procedure Orient( C, z). Consider the regions around which two vertices sG and tG are distinguished, and called often source and sink. We define such graphs inductively as follows.</p><p>(a) A single edge (s, t) is a series-parallel graph.</p><p>(b) Suppose that H, and Hz are series-parallel. Then Then, H is also series-parallel.</p><p>The operation 0 will be called the parallel composition.</p><p>Both series and parallel compositions can be extended in an obvious way to have more than two arguments.</p><p>We first prove the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 6.1. Each series-parallel graph has an acyclic 2-bounded orientation, and this orientation can be found in linear time.</head><p>Proof. We will prove a slightly stronger fact. Suppose first that H is a series composition, that is H = H, 0 Hz. We know that Hz has an acyclic orientation such that degi(sH,) s 1 and deg+( tHz) = 0. By symmetry, HI has an acyclic orientation such that deg+( tH,) s 1 and deg+(s,,) = 0. After identifying sH, with In, we obtain a desired orientation of H. Suppose now that H is a parallel composition.</p><p>Then we can represent H as H = H,@ . . . 0 H,, where the graphs H, are series compositions, except possibly of one of them, say H,,, which is a single edge. If HI, = (sn, tu), then we set o(sH, tH) = sH + td. The orientation of the other graphs H, remains unchanged.</p><p>Then H clearly satisfies (*).</p><p>It is very easy to implement this method in linear time, given a series-parallel representation of a given graph. Such a representation can be also found in linear time (see <ref type="bibr" target="#b25">[23]</ref>). 17 The total time complexity is dominated by the construction of the representation of G, the rest is easy to do within the complexity bounds stated in the theorem. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Applications</head><p>In this section we show how our compacted adjacency matrix can be applied in some algorithms for planar graphs. Consider the two following problems:</p><p>l given a planar graph G, list all triangles in G; l given a planar graph G, list all 4-cliques in G.</p><p>There are several algorithms for these problems which use a linear time <ref type="bibr">[2,</ref><ref type="bibr">15,</ref><ref type="bibr" target="#b22">20,</ref><ref type="bibr">6]</ref>. However, some of them tend to be rather complicated, especially the algorithm of Papadimitriou and Yannakekis for listing all 4-cliques. In this section we show how we can use a compacted adjacency matrix, together with adjacency lists, for this purpose.</p><p>We consider only the problem of listing 4-cliques; listing all triangles is even simpler. As in some previous algorithms we maintain a queue Q on which we keep all vertices of degree at most 5. The algorithm is as follows: properties, but we suspect that suitable modifications of our algorithms may give an appropriate decomposition.</p><p>As we have shown in the preceding section, our method turns out to be useful in other algorithms on planar graphs. Having both the adjacency lists and our compacted adjacency matrix, it is possible both to search a graph quickly, and to answer queries (*) in constant time.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis qf Computer Algorithms</title>
		<idno>41 I51 [61 [71 PI [91</idno>
		<editor>Aho, J. Hopcroft and J. Ullman</editor>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
	<note>Ill t121 [I31 [I41 r151 [I61 [I71 A</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On approximating a vertex cover for planar graphs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bar-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th</title>
		<meeting>14th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">Ann</forename></persName>
		</author>
		<title level="m">ACM Symp. on Theory @&apos;Computing</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="303" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The parallel evaluation of general arithmetic expressions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Brent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Compu/. Mach</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="201" to="206" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An approximation algorithm for the maximum independent set problem on planar graphs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nishizeki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Saito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="page" from="663" to="675" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Arboricity and subgraph listing algorithms</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nishizeki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">An efficient parallel algorithm for computing a large independent set in planar graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chrobak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Parallel recognition of outer-planar graphs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Diks</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Parallel recognition of series-parallel graphs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Outerplanar graphs and weak duals</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Fleishner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Geller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Indian Math</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>Sw</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="215" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Parallel symmetry breaking in sparse graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shannon</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ann. Symp. on Theory of Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="15" to="324" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimal parallel 5-coloring of planar graphs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hagerup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chrobak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Diks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
		<title level="m">Graph Theory</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Parallel recognition and decomposition of two terminal series parallel graphs</title>
		<author>
			<persName><forename type="first">X</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yesha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="15" to="38" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient planarity testing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="549" to="568" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Finding a minimum circuit in a graph</title>
		<author>
			<persName><forename type="first">A</forename><surname>Itai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="413" to="423" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Implicit representations of graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Ann. Symp. on Theory of Computing</title>
		<meeting>20th Ann. Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="334" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Parallel prefix computation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Camput. Mach</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="831" to="838" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On orientations, connectivity and odd-vertex pairings in finite graphs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nash-Willjams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Can. J. Marh</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="555" to="567" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Edge-disjoint spanning trees of finite graphs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nash-Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. London Math. Sot</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="445" to="450" />
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The clique problem for planar graphs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process Left</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="131" to="133" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Embedding planar graphs on the grids, a manuscript</title>
		<author>
			<persName><forename type="first">W</forename><surname>Schnyder</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An eficient parallel biconnectivity algorithm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Vishkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAMJ. Cornput</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="862" to="874" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The recognition of series parallel digraphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Valdes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th</title>
		<meeting>11th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ann. ACM Symp. on Theory of Compuring</title>
		<imprint>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Some results on graph coloring in parallel</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Sridhar</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>manuscript</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
